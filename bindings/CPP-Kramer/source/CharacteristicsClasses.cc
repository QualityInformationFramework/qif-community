/* ***************************************************************** */

#include <stdio.h>             // for printf, etc.
#include <string.h>            // for strdup
#include <stdlib.h>            // for exit
#include <list>
#include  <map>
#include <xmlSchemaInstance.hh>
#include "CharacteristicsClasses.hh"

#define INDENT 2
extern std::map<unsigned int, XmlSchemaInstanceBase *> idMap;

/* ***************************************************************** */
/* ***************************************************************** */

/* class AngleBetweenCharacteristicDefinitionType

*/

AngleBetweenCharacteristicDefinitionType::AngleBetweenCharacteristicDefinitionType() :
  AngularCharacteristicDefinitionBaseType()
{
}

AngleBetweenCharacteristicDefinitionType::AngleBetweenCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 AngularCharacteristicDefinitionBaseTypeChoicePair * AngularCharacteristicDefinitionBaseTypePairIn) :
  AngularCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    AngularCharacteristicDefinitionBaseTypePairIn)
{
}

AngleBetweenCharacteristicDefinitionType::AngleBetweenCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 AngularCharacteristicDefinitionBaseTypeChoicePair * AngularCharacteristicDefinitionBaseTypePairIn) :
  AngularCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    AngularCharacteristicDefinitionBaseTypePairIn)
{
}

AngleBetweenCharacteristicDefinitionType::~AngleBetweenCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void AngleBetweenCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (DimensionType)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionType");
      DimensionType->printSelf(outFile);
      fprintf(outFile, "</DimensionType>\n");
    }
  if (DimensionModifiers)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionModifiers");
      DimensionModifiers->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DimensionModifiers>\n");
    }
  AngularCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

bool AngleBetweenCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in AngleBetweenCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in AngleBetweenCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in AngleBetweenCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in AngleBetweenCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class AngleBetweenCharacteristicItemType

*/

AngleBetweenCharacteristicItemType::AngleBetweenCharacteristicItemType() :
  AngularCharacteristicItemBaseType()
{
}

AngleBetweenCharacteristicItemType::AngleBetweenCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  AngularCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

AngleBetweenCharacteristicItemType::AngleBetweenCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  AngularCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

AngleBetweenCharacteristicItemType::~AngleBetweenCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void AngleBetweenCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool AngleBetweenCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in AngleBetweenCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in AngleBetweenCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in AngleBetweenCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in AngleBetweenCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class AngleBetweenCharacteristicMeasurementType

*/

AngleBetweenCharacteristicMeasurementType::AngleBetweenCharacteristicMeasurementType() :
  AngularCharacteristicMeasurementBaseType()
{
  AnalysisVector = 0;
  Vertex = 0;
}

AngleBetweenCharacteristicMeasurementType::AngleBetweenCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredAngularValueType * ValueIn,
 MeasuredAngularValueType * MaxValueIn,
 MeasuredAngularValueType * MinValueIn,
 MeasuredUnitVectorType * AnalysisVectorIn,
 MeasuredPointType * VertexIn) :
  AngularCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
  AnalysisVector = AnalysisVectorIn;
  Vertex = VertexIn;
}

AngleBetweenCharacteristicMeasurementType::AngleBetweenCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredAngularValueType * ValueIn,
 MeasuredAngularValueType * MaxValueIn,
 MeasuredAngularValueType * MinValueIn,
 MeasuredUnitVectorType * AnalysisVectorIn,
 MeasuredPointType * VertexIn) :
  AngularCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
  AnalysisVector = AnalysisVectorIn;
  Vertex = VertexIn;
}

AngleBetweenCharacteristicMeasurementType::~AngleBetweenCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  delete AnalysisVector;
  delete Vertex;
  #endif
}

void AngleBetweenCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  if (AnalysisVector)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AnalysisVector");
      AnalysisVector->printSelf(outFile);
      fprintf(outFile, "</AnalysisVector>\n");
    }
  if (Vertex)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Vertex");
      Vertex->printSelf(outFile);
      fprintf(outFile, "</Vertex>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool AngleBetweenCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in AngleBetweenCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in AngleBetweenCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in AngleBetweenCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in AngleBetweenCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredUnitVectorType * AngleBetweenCharacteristicMeasurementType::getAnalysisVector()
{return AnalysisVector;}

void AngleBetweenCharacteristicMeasurementType::setAnalysisVector(MeasuredUnitVectorType * AnalysisVectorIn)
{AnalysisVector = AnalysisVectorIn;}

MeasuredPointType * AngleBetweenCharacteristicMeasurementType::getVertex()
{return Vertex;}

void AngleBetweenCharacteristicMeasurementType::setVertex(MeasuredPointType * VertexIn)
{Vertex = VertexIn;}

/* ***************************************************************** */

/* class AngleBetweenCharacteristicNominalType

*/

AngleBetweenCharacteristicNominalType::AngleBetweenCharacteristicNominalType() :
  AngularCharacteristicNominalBaseType()
{
  FeatureNominalPairs = 0;
  AnalysisVector = 0;
  AnalysisMode = 0;
  CoordinateSystemId = 0;
  MeasurementDirective = 0;
  Vertex = 0;
}

AngleBetweenCharacteristicNominalType::AngleBetweenCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 AngularValueType * TargetValueIn,
 ArrayPairReferenceFullType * FeatureNominalPairsIn,
 UnitVectorType * AnalysisVectorIn,
 AngleBetweenAnalysisModeEnumType * AnalysisModeIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 MeasurementDirectiveType * MeasurementDirectiveIn,
 PointType * VertexIn) :
  AngularCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn)
{
  FeatureNominalPairs = FeatureNominalPairsIn;
  AnalysisVector = AnalysisVectorIn;
  AnalysisMode = AnalysisModeIn;
  CoordinateSystemId = CoordinateSystemIdIn;
  MeasurementDirective = MeasurementDirectiveIn;
  Vertex = VertexIn;
}

AngleBetweenCharacteristicNominalType::AngleBetweenCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 AngularValueType * TargetValueIn,
 ArrayPairReferenceFullType * FeatureNominalPairsIn,
 UnitVectorType * AnalysisVectorIn,
 AngleBetweenAnalysisModeEnumType * AnalysisModeIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 MeasurementDirectiveType * MeasurementDirectiveIn,
 PointType * VertexIn) :
  AngularCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn)
{
  FeatureNominalPairs = FeatureNominalPairsIn;
  AnalysisVector = AnalysisVectorIn;
  AnalysisMode = AnalysisModeIn;
  CoordinateSystemId = CoordinateSystemIdIn;
  MeasurementDirective = MeasurementDirectiveIn;
  Vertex = VertexIn;
}

AngleBetweenCharacteristicNominalType::~AngleBetweenCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  delete FeatureNominalPairs;
  delete AnalysisVector;
  delete AnalysisMode;
  delete CoordinateSystemId;
  delete MeasurementDirective;
  delete Vertex;
  #endif
}

void AngleBetweenCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  if (FeatureNominalPairs)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalPairs");
      FeatureNominalPairs->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalPairs>\n");
    }
  if (AnalysisVector)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AnalysisVector");
      AnalysisVector->printSelf(outFile);
      fprintf(outFile, "</AnalysisVector>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<AnalysisMode");
  AnalysisMode->printSelf(outFile);
  fprintf(outFile, "</AnalysisMode>\n");
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (MeasurementDirective)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDirective");
      MeasurementDirective->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDirective>\n");
    }
  if (Vertex)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Vertex");
      Vertex->printSelf(outFile);
      fprintf(outFile, "</Vertex>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool AngleBetweenCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in AngleBetweenCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in AngleBetweenCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in AngleBetweenCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in AngleBetweenCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

ArrayPairReferenceFullType * AngleBetweenCharacteristicNominalType::getFeatureNominalPairs()
{return FeatureNominalPairs;}

void AngleBetweenCharacteristicNominalType::setFeatureNominalPairs(ArrayPairReferenceFullType * FeatureNominalPairsIn)
{FeatureNominalPairs = FeatureNominalPairsIn;}

UnitVectorType * AngleBetweenCharacteristicNominalType::getAnalysisVector()
{return AnalysisVector;}

void AngleBetweenCharacteristicNominalType::setAnalysisVector(UnitVectorType * AnalysisVectorIn)
{AnalysisVector = AnalysisVectorIn;}

AngleBetweenAnalysisModeEnumType * AngleBetweenCharacteristicNominalType::getAnalysisMode()
{return AnalysisMode;}

void AngleBetweenCharacteristicNominalType::setAnalysisMode(AngleBetweenAnalysisModeEnumType * AnalysisModeIn)
{AnalysisMode = AnalysisModeIn;}

QIFReferenceFullType * AngleBetweenCharacteristicNominalType::getCoordinateSystemId()
{return CoordinateSystemId;}

void AngleBetweenCharacteristicNominalType::setCoordinateSystemId(QIFReferenceFullType * CoordinateSystemIdIn)
{CoordinateSystemId = CoordinateSystemIdIn;}

MeasurementDirectiveType * AngleBetweenCharacteristicNominalType::getMeasurementDirective()
{return MeasurementDirective;}

void AngleBetweenCharacteristicNominalType::setMeasurementDirective(MeasurementDirectiveType * MeasurementDirectiveIn)
{MeasurementDirective = MeasurementDirectiveIn;}

PointType * AngleBetweenCharacteristicNominalType::getVertex()
{return Vertex;}

void AngleBetweenCharacteristicNominalType::setVertex(PointType * VertexIn)
{Vertex = VertexIn;}

/* ***************************************************************** */

/* class AngleCharacteristicDefinitionType

*/

AngleCharacteristicDefinitionType::AngleCharacteristicDefinitionType() :
  AngularCharacteristicDefinitionBaseType()
{
}

AngleCharacteristicDefinitionType::AngleCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 AngularCharacteristicDefinitionBaseTypeChoicePair * AngularCharacteristicDefinitionBaseTypePairIn) :
  AngularCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    AngularCharacteristicDefinitionBaseTypePairIn)
{
}

AngleCharacteristicDefinitionType::AngleCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 AngularCharacteristicDefinitionBaseTypeChoicePair * AngularCharacteristicDefinitionBaseTypePairIn) :
  AngularCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    AngularCharacteristicDefinitionBaseTypePairIn)
{
}

AngleCharacteristicDefinitionType::~AngleCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void AngleCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (DimensionType)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionType");
      DimensionType->printSelf(outFile);
      fprintf(outFile, "</DimensionType>\n");
    }
  if (DimensionModifiers)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionModifiers");
      DimensionModifiers->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DimensionModifiers>\n");
    }
  AngularCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

bool AngleCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in AngleCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in AngleCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in AngleCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in AngleCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class AngleCharacteristicItemType

*/

AngleCharacteristicItemType::AngleCharacteristicItemType() :
  AngularCharacteristicItemBaseType()
{
}

AngleCharacteristicItemType::AngleCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  AngularCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

AngleCharacteristicItemType::AngleCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  AngularCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

AngleCharacteristicItemType::~AngleCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void AngleCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool AngleCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in AngleCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in AngleCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in AngleCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in AngleCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class AngleCharacteristicMeasurementType

*/

AngleCharacteristicMeasurementType::AngleCharacteristicMeasurementType() :
  AngularCharacteristicMeasurementBaseType()
{
}

AngleCharacteristicMeasurementType::AngleCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredAngularValueType * ValueIn,
 MeasuredAngularValueType * MaxValueIn,
 MeasuredAngularValueType * MinValueIn) :
  AngularCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

AngleCharacteristicMeasurementType::AngleCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredAngularValueType * ValueIn,
 MeasuredAngularValueType * MaxValueIn,
 MeasuredAngularValueType * MinValueIn) :
  AngularCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

AngleCharacteristicMeasurementType::~AngleCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void AngleCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool AngleCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in AngleCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in AngleCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in AngleCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in AngleCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class AngleCharacteristicNominalType

*/

AngleCharacteristicNominalType::AngleCharacteristicNominalType() :
  AngularCharacteristicNominalBaseType()
{
}

AngleCharacteristicNominalType::AngleCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 AngularValueType * TargetValueIn) :
  AngularCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn)
{
}

AngleCharacteristicNominalType::AngleCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 AngularValueType * TargetValueIn) :
  AngularCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn)
{
}

AngleCharacteristicNominalType::~AngleCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void AngleCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool AngleCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in AngleCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in AngleCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in AngleCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in AngleCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class AngleFromCharacteristicDefinitionType

*/

AngleFromCharacteristicDefinitionType::AngleFromCharacteristicDefinitionType() :
  AngularCharacteristicDefinitionBaseType()
{
}

AngleFromCharacteristicDefinitionType::AngleFromCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 AngularCharacteristicDefinitionBaseTypeChoicePair * AngularCharacteristicDefinitionBaseTypePairIn) :
  AngularCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    AngularCharacteristicDefinitionBaseTypePairIn)
{
}

AngleFromCharacteristicDefinitionType::AngleFromCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 AngularCharacteristicDefinitionBaseTypeChoicePair * AngularCharacteristicDefinitionBaseTypePairIn) :
  AngularCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    AngularCharacteristicDefinitionBaseTypePairIn)
{
}

AngleFromCharacteristicDefinitionType::~AngleFromCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void AngleFromCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (DimensionType)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionType");
      DimensionType->printSelf(outFile);
      fprintf(outFile, "</DimensionType>\n");
    }
  if (DimensionModifiers)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionModifiers");
      DimensionModifiers->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DimensionModifiers>\n");
    }
  AngularCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

bool AngleFromCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in AngleFromCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in AngleFromCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in AngleFromCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in AngleFromCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class AngleFromCharacteristicItemType

*/

AngleFromCharacteristicItemType::AngleFromCharacteristicItemType() :
  AngularCharacteristicItemBaseType()
{
}

AngleFromCharacteristicItemType::AngleFromCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  AngularCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

AngleFromCharacteristicItemType::AngleFromCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  AngularCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

AngleFromCharacteristicItemType::~AngleFromCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void AngleFromCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool AngleFromCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in AngleFromCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in AngleFromCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in AngleFromCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in AngleFromCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class AngleFromCharacteristicMeasurementType

*/

AngleFromCharacteristicMeasurementType::AngleFromCharacteristicMeasurementType() :
  AngularCharacteristicMeasurementBaseType()
{
  AnalysisVector = 0;
  Vertex = 0;
}

AngleFromCharacteristicMeasurementType::AngleFromCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredAngularValueType * ValueIn,
 MeasuredAngularValueType * MaxValueIn,
 MeasuredAngularValueType * MinValueIn,
 MeasuredUnitVectorType * AnalysisVectorIn,
 MeasuredPointType * VertexIn) :
  AngularCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
  AnalysisVector = AnalysisVectorIn;
  Vertex = VertexIn;
}

AngleFromCharacteristicMeasurementType::AngleFromCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredAngularValueType * ValueIn,
 MeasuredAngularValueType * MaxValueIn,
 MeasuredAngularValueType * MinValueIn,
 MeasuredUnitVectorType * AnalysisVectorIn,
 MeasuredPointType * VertexIn) :
  AngularCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
  AnalysisVector = AnalysisVectorIn;
  Vertex = VertexIn;
}

AngleFromCharacteristicMeasurementType::~AngleFromCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  delete AnalysisVector;
  delete Vertex;
  #endif
}

void AngleFromCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  if (AnalysisVector)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AnalysisVector");
      AnalysisVector->printSelf(outFile);
      fprintf(outFile, "</AnalysisVector>\n");
    }
  if (Vertex)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Vertex");
      Vertex->printSelf(outFile);
      fprintf(outFile, "</Vertex>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool AngleFromCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in AngleFromCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in AngleFromCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in AngleFromCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in AngleFromCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredUnitVectorType * AngleFromCharacteristicMeasurementType::getAnalysisVector()
{return AnalysisVector;}

void AngleFromCharacteristicMeasurementType::setAnalysisVector(MeasuredUnitVectorType * AnalysisVectorIn)
{AnalysisVector = AnalysisVectorIn;}

MeasuredPointType * AngleFromCharacteristicMeasurementType::getVertex()
{return Vertex;}

void AngleFromCharacteristicMeasurementType::setVertex(MeasuredPointType * VertexIn)
{Vertex = VertexIn;}

/* ***************************************************************** */

/* class AngleFromCharacteristicNominalType

*/

AngleFromCharacteristicNominalType::AngleFromCharacteristicNominalType() :
  AngularCharacteristicNominalBaseType()
{
  OriginReference = 0;
  AnalysisVector = 0;
  AnalysisMode = 0;
  CoordinateSystemId = 0;
  MeasurementDirective = 0;
  Vertex = 0;
}

AngleFromCharacteristicNominalType::AngleFromCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 AngularValueType * TargetValueIn,
 OriginReferenceType * OriginReferenceIn,
 UnitVectorType * AnalysisVectorIn,
 AngleBetweenAnalysisModeEnumType * AnalysisModeIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 MeasurementDirectiveType * MeasurementDirectiveIn,
 PointType * VertexIn) :
  AngularCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn)
{
  OriginReference = OriginReferenceIn;
  AnalysisVector = AnalysisVectorIn;
  AnalysisMode = AnalysisModeIn;
  CoordinateSystemId = CoordinateSystemIdIn;
  MeasurementDirective = MeasurementDirectiveIn;
  Vertex = VertexIn;
}

AngleFromCharacteristicNominalType::AngleFromCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 AngularValueType * TargetValueIn,
 OriginReferenceType * OriginReferenceIn,
 UnitVectorType * AnalysisVectorIn,
 AngleBetweenAnalysisModeEnumType * AnalysisModeIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 MeasurementDirectiveType * MeasurementDirectiveIn,
 PointType * VertexIn) :
  AngularCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn)
{
  OriginReference = OriginReferenceIn;
  AnalysisVector = AnalysisVectorIn;
  AnalysisMode = AnalysisModeIn;
  CoordinateSystemId = CoordinateSystemIdIn;
  MeasurementDirective = MeasurementDirectiveIn;
  Vertex = VertexIn;
}

AngleFromCharacteristicNominalType::~AngleFromCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  delete OriginReference;
  delete AnalysisVector;
  delete AnalysisMode;
  delete CoordinateSystemId;
  delete MeasurementDirective;
  delete Vertex;
  #endif
}

void AngleFromCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  if (OriginReference)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OriginReference");
      OriginReference->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OriginReference>\n");
    }
  if (AnalysisVector)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AnalysisVector");
      AnalysisVector->printSelf(outFile);
      fprintf(outFile, "</AnalysisVector>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<AnalysisMode");
  AnalysisMode->printSelf(outFile);
  fprintf(outFile, "</AnalysisMode>\n");
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (MeasurementDirective)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDirective");
      MeasurementDirective->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDirective>\n");
    }
  if (Vertex)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Vertex");
      Vertex->printSelf(outFile);
      fprintf(outFile, "</Vertex>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool AngleFromCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in AngleFromCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in AngleFromCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in AngleFromCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in AngleFromCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

OriginReferenceType * AngleFromCharacteristicNominalType::getOriginReference()
{return OriginReference;}

void AngleFromCharacteristicNominalType::setOriginReference(OriginReferenceType * OriginReferenceIn)
{OriginReference = OriginReferenceIn;}

UnitVectorType * AngleFromCharacteristicNominalType::getAnalysisVector()
{return AnalysisVector;}

void AngleFromCharacteristicNominalType::setAnalysisVector(UnitVectorType * AnalysisVectorIn)
{AnalysisVector = AnalysisVectorIn;}

AngleBetweenAnalysisModeEnumType * AngleFromCharacteristicNominalType::getAnalysisMode()
{return AnalysisMode;}

void AngleFromCharacteristicNominalType::setAnalysisMode(AngleBetweenAnalysisModeEnumType * AnalysisModeIn)
{AnalysisMode = AnalysisModeIn;}

QIFReferenceFullType * AngleFromCharacteristicNominalType::getCoordinateSystemId()
{return CoordinateSystemId;}

void AngleFromCharacteristicNominalType::setCoordinateSystemId(QIFReferenceFullType * CoordinateSystemIdIn)
{CoordinateSystemId = CoordinateSystemIdIn;}

MeasurementDirectiveType * AngleFromCharacteristicNominalType::getMeasurementDirective()
{return MeasurementDirective;}

void AngleFromCharacteristicNominalType::setMeasurementDirective(MeasurementDirectiveType * MeasurementDirectiveIn)
{MeasurementDirective = MeasurementDirectiveIn;}

PointType * AngleFromCharacteristicNominalType::getVertex()
{return Vertex;}

void AngleFromCharacteristicNominalType::setVertex(PointType * VertexIn)
{Vertex = VertexIn;}

/* ***************************************************************** */

/* class AngularCharacteristicDefinitionBaseType

*/

AngularCharacteristicDefinitionBaseType::AngularCharacteristicDefinitionBaseType() :
  DimensionalCharacteristicDefinitionBaseType()
{
  AngularCharacteristicDefinitionBaseTypePair = 0;
}

AngularCharacteristicDefinitionBaseType::AngularCharacteristicDefinitionBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 AngularCharacteristicDefinitionBaseTypeChoicePair * AngularCharacteristicDefinitionBaseTypePairIn) :
  DimensionalCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn)
{
  AngularCharacteristicDefinitionBaseTypePair = AngularCharacteristicDefinitionBaseTypePairIn;
}

AngularCharacteristicDefinitionBaseType::AngularCharacteristicDefinitionBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 AngularCharacteristicDefinitionBaseTypeChoicePair * AngularCharacteristicDefinitionBaseTypePairIn) :
  DimensionalCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn)
{
  AngularCharacteristicDefinitionBaseTypePair = AngularCharacteristicDefinitionBaseTypePairIn;
}

AngularCharacteristicDefinitionBaseType::~AngularCharacteristicDefinitionBaseType()
{
  #ifndef NODESTRUCT
  delete AngularCharacteristicDefinitionBaseTypePair;
  #endif
}

void AngularCharacteristicDefinitionBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (DimensionType)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionType");
      DimensionType->printSelf(outFile);
      fprintf(outFile, "</DimensionType>\n");
    }
  if (DimensionModifiers)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionModifiers");
      DimensionModifiers->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DimensionModifiers>\n");
    }
  AngularCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}
AngularCharacteristicDefinitionBaseTypeChoicePair * AngularCharacteristicDefinitionBaseType::getAngularCharacteristicDefinitionBaseTypeChoicePair()
{return AngularCharacteristicDefinitionBaseTypePair;}

void AngularCharacteristicDefinitionBaseType::setAngularCharacteristicDefinitionBaseTypeChoicePair(AngularCharacteristicDefinitionBaseTypeChoicePair * AngularCharacteristicDefinitionBaseTypePairIn)
{AngularCharacteristicDefinitionBaseTypePair = AngularCharacteristicDefinitionBaseTypePairIn;}

/* ***************************************************************** */

AngularCharacteristicDefinitionBaseTypeChoicePair::AngularCharacteristicDefinitionBaseTypeChoicePair() {}

AngularCharacteristicDefinitionBaseTypeChoicePair::AngularCharacteristicDefinitionBaseTypeChoicePair(
 whichOne AngularCharacteristicDefinitionBaseTypeTypeIn,
 AngularCharacteristicDefinitionBaseTypeVal AngularCharacteristicDefinitionBaseTypeValueIn)
{
  AngularCharacteristicDefinitionBaseTypeType = AngularCharacteristicDefinitionBaseTypeTypeIn;
  AngularCharacteristicDefinitionBaseTypeValue = AngularCharacteristicDefinitionBaseTypeValueIn;
}

AngularCharacteristicDefinitionBaseTypeChoicePair::~AngularCharacteristicDefinitionBaseTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (AngularCharacteristicDefinitionBaseTypeType == ToleranceE)
    delete AngularCharacteristicDefinitionBaseTypeValue.Tolerance;
  else if (AngularCharacteristicDefinitionBaseTypeType == NonToleranceE)
    delete AngularCharacteristicDefinitionBaseTypeValue.NonTolerance;
  #endif
}

void AngularCharacteristicDefinitionBaseTypeChoicePair::printSelf(FILE * outFile)
{
  if (AngularCharacteristicDefinitionBaseTypeType == ToleranceE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Tolerance");
      AngularCharacteristicDefinitionBaseTypeValue.Tolerance->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Tolerance>\n");
    }
  else if (AngularCharacteristicDefinitionBaseTypeType == NonToleranceE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonTolerance");
      AngularCharacteristicDefinitionBaseTypeValue.NonTolerance->printSelf(outFile);
      fprintf(outFile, "</NonTolerance>\n");
    }
}

bool AngularCharacteristicDefinitionBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in AngularCharacteristicDefinitionBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in AngularCharacteristicDefinitionBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in AngularCharacteristicDefinitionBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in AngularCharacteristicDefinitionBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class AngularCharacteristicItemBaseType

*/

AngularCharacteristicItemBaseType::AngularCharacteristicItemBaseType() :
  DimensionalCharacteristicItemBaseType()
{
}

AngularCharacteristicItemBaseType::AngularCharacteristicItemBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  DimensionalCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

AngularCharacteristicItemBaseType::AngularCharacteristicItemBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  DimensionalCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

AngularCharacteristicItemBaseType::~AngularCharacteristicItemBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void AngularCharacteristicItemBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool AngularCharacteristicItemBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in AngularCharacteristicItemBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in AngularCharacteristicItemBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in AngularCharacteristicItemBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in AngularCharacteristicItemBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class AngularCharacteristicMeasurementBaseType

*/

AngularCharacteristicMeasurementBaseType::AngularCharacteristicMeasurementBaseType() :
  DimensionalCharacteristicMeasurementBaseType()
{
  Value = 0;
  MaxValue = 0;
  MinValue = 0;
}

AngularCharacteristicMeasurementBaseType::AngularCharacteristicMeasurementBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredAngularValueType * ValueIn,
 MeasuredAngularValueType * MaxValueIn,
 MeasuredAngularValueType * MinValueIn) :
  DimensionalCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  Value = ValueIn;
  MaxValue = MaxValueIn;
  MinValue = MinValueIn;
}

AngularCharacteristicMeasurementBaseType::AngularCharacteristicMeasurementBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredAngularValueType * ValueIn,
 MeasuredAngularValueType * MaxValueIn,
 MeasuredAngularValueType * MinValueIn) :
  DimensionalCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  Value = ValueIn;
  MaxValue = MaxValueIn;
  MinValue = MinValueIn;
}

AngularCharacteristicMeasurementBaseType::~AngularCharacteristicMeasurementBaseType()
{
  #ifndef NODESTRUCT
  delete Value;
  delete MaxValue;
  delete MinValue;
  #endif
}

void AngularCharacteristicMeasurementBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool AngularCharacteristicMeasurementBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in AngularCharacteristicMeasurementBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in AngularCharacteristicMeasurementBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in AngularCharacteristicMeasurementBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in AngularCharacteristicMeasurementBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredAngularValueType * AngularCharacteristicMeasurementBaseType::getValue()
{return Value;}

void AngularCharacteristicMeasurementBaseType::setValue(MeasuredAngularValueType * ValueIn)
{Value = ValueIn;}

MeasuredAngularValueType * AngularCharacteristicMeasurementBaseType::getMaxValue()
{return MaxValue;}

void AngularCharacteristicMeasurementBaseType::setMaxValue(MeasuredAngularValueType * MaxValueIn)
{MaxValue = MaxValueIn;}

MeasuredAngularValueType * AngularCharacteristicMeasurementBaseType::getMinValue()
{return MinValue;}

void AngularCharacteristicMeasurementBaseType::setMinValue(MeasuredAngularValueType * MinValueIn)
{MinValue = MinValueIn;}

/* ***************************************************************** */

/* class AngularCharacteristicNominalBaseType

*/

AngularCharacteristicNominalBaseType::AngularCharacteristicNominalBaseType() :
  DimensionalCharacteristicNominalBaseType()
{
  TargetValue = 0;
}

AngularCharacteristicNominalBaseType::AngularCharacteristicNominalBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 AngularValueType * TargetValueIn) :
  DimensionalCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  TargetValue = TargetValueIn;
}

AngularCharacteristicNominalBaseType::AngularCharacteristicNominalBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 AngularValueType * TargetValueIn) :
  DimensionalCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  TargetValue = TargetValueIn;
}

AngularCharacteristicNominalBaseType::~AngularCharacteristicNominalBaseType()
{
  #ifndef NODESTRUCT
  delete TargetValue;
  #endif
}

void AngularCharacteristicNominalBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool AngularCharacteristicNominalBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in AngularCharacteristicNominalBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in AngularCharacteristicNominalBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in AngularCharacteristicNominalBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in AngularCharacteristicNominalBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

AngularValueType * AngularCharacteristicNominalBaseType::getTargetValue()
{return TargetValue;}

void AngularCharacteristicNominalBaseType::setTargetValue(AngularValueType * TargetValueIn)
{TargetValue = TargetValueIn;}

/* ***************************************************************** */

/* class AngularCoordinateCharacteristicDefinitionType

*/

AngularCoordinateCharacteristicDefinitionType::AngularCoordinateCharacteristicDefinitionType() :
  CoordinateCharacteristicDefinitionBaseType()
{
  AngularCoordinateCharacteristicDefinitionTypePair = 0;
}

AngularCoordinateCharacteristicDefinitionType::AngularCoordinateCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 AngularCoordinateCharacteristicDefinitionTypeChoicePair * AngularCoordinateCharacteristicDefinitionTypePairIn) :
  CoordinateCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn)
{
  AngularCoordinateCharacteristicDefinitionTypePair = AngularCoordinateCharacteristicDefinitionTypePairIn;
}

AngularCoordinateCharacteristicDefinitionType::AngularCoordinateCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 AngularCoordinateCharacteristicDefinitionTypeChoicePair * AngularCoordinateCharacteristicDefinitionTypePairIn) :
  CoordinateCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn)
{
  AngularCoordinateCharacteristicDefinitionTypePair = AngularCoordinateCharacteristicDefinitionTypePairIn;
}

AngularCoordinateCharacteristicDefinitionType::~AngularCoordinateCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  delete AngularCoordinateCharacteristicDefinitionTypePair;
  #endif
}

void AngularCoordinateCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (DimensionType)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionType");
      DimensionType->printSelf(outFile);
      fprintf(outFile, "</DimensionType>\n");
    }
  if (DimensionModifiers)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionModifiers");
      DimensionModifiers->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DimensionModifiers>\n");
    }
  AngularCoordinateCharacteristicDefinitionTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}
AngularCoordinateCharacteristicDefinitionTypeChoicePair * AngularCoordinateCharacteristicDefinitionType::getAngularCoordinateCharacteristicDefinitionTypeChoicePair()
{return AngularCoordinateCharacteristicDefinitionTypePair;}

void AngularCoordinateCharacteristicDefinitionType::setAngularCoordinateCharacteristicDefinitionTypeChoicePair(AngularCoordinateCharacteristicDefinitionTypeChoicePair * AngularCoordinateCharacteristicDefinitionTypePairIn)
{AngularCoordinateCharacteristicDefinitionTypePair = AngularCoordinateCharacteristicDefinitionTypePairIn;}

/* ***************************************************************** */

AngularCoordinateCharacteristicDefinitionTypeChoicePair::AngularCoordinateCharacteristicDefinitionTypeChoicePair() {}

AngularCoordinateCharacteristicDefinitionTypeChoicePair::AngularCoordinateCharacteristicDefinitionTypeChoicePair(
 whichOne AngularCoordinateCharacteristicDefinitionTypeTypeIn,
 AngularCoordinateCharacteristicDefinitionTypeVal AngularCoordinateCharacteristicDefinitionTypeValueIn)
{
  AngularCoordinateCharacteristicDefinitionTypeType = AngularCoordinateCharacteristicDefinitionTypeTypeIn;
  AngularCoordinateCharacteristicDefinitionTypeValue = AngularCoordinateCharacteristicDefinitionTypeValueIn;
}

AngularCoordinateCharacteristicDefinitionTypeChoicePair::~AngularCoordinateCharacteristicDefinitionTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (AngularCoordinateCharacteristicDefinitionTypeType == ToleranceE)
    delete AngularCoordinateCharacteristicDefinitionTypeValue.Tolerance;
  else if (AngularCoordinateCharacteristicDefinitionTypeType == NonToleranceE)
    delete AngularCoordinateCharacteristicDefinitionTypeValue.NonTolerance;
  #endif
}

void AngularCoordinateCharacteristicDefinitionTypeChoicePair::printSelf(FILE * outFile)
{
  if (AngularCoordinateCharacteristicDefinitionTypeType == ToleranceE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Tolerance");
      AngularCoordinateCharacteristicDefinitionTypeValue.Tolerance->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Tolerance>\n");
    }
  else if (AngularCoordinateCharacteristicDefinitionTypeType == NonToleranceE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonTolerance");
      AngularCoordinateCharacteristicDefinitionTypeValue.NonTolerance->printSelf(outFile);
      fprintf(outFile, "</NonTolerance>\n");
    }
}

bool AngularCoordinateCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in AngularCoordinateCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in AngularCoordinateCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in AngularCoordinateCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in AngularCoordinateCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class AngularCoordinateCharacteristicItemType

*/

AngularCoordinateCharacteristicItemType::AngularCoordinateCharacteristicItemType() :
  CoordinateCharacteristicItemBaseType()
{
}

AngularCoordinateCharacteristicItemType::AngularCoordinateCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  CoordinateCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

AngularCoordinateCharacteristicItemType::AngularCoordinateCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  CoordinateCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

AngularCoordinateCharacteristicItemType::~AngularCoordinateCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void AngularCoordinateCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool AngularCoordinateCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in AngularCoordinateCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in AngularCoordinateCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in AngularCoordinateCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in AngularCoordinateCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class AngularCoordinateCharacteristicMeasurementType

*/

AngularCoordinateCharacteristicMeasurementType::AngularCoordinateCharacteristicMeasurementType() :
  CoordinateCharacteristicMeasurementBaseType()
{
  Value = 0;
  MaxValue = 0;
  MinValue = 0;
}

AngularCoordinateCharacteristicMeasurementType::AngularCoordinateCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 TypeOfCoordinatesType * TypeOfCoordinatesIn,
 MeasuredAngularValueType * ValueIn,
 MeasuredAngularValueType * MaxValueIn,
 MeasuredAngularValueType * MinValueIn) :
  CoordinateCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    TypeOfCoordinatesIn)
{
  Value = ValueIn;
  MaxValue = MaxValueIn;
  MinValue = MinValueIn;
}

AngularCoordinateCharacteristicMeasurementType::AngularCoordinateCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 TypeOfCoordinatesType * TypeOfCoordinatesIn,
 MeasuredAngularValueType * ValueIn,
 MeasuredAngularValueType * MaxValueIn,
 MeasuredAngularValueType * MinValueIn) :
  CoordinateCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    TypeOfCoordinatesIn)
{
  Value = ValueIn;
  MaxValue = MaxValueIn;
  MinValue = MinValueIn;
}

AngularCoordinateCharacteristicMeasurementType::~AngularCoordinateCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  delete Value;
  delete MaxValue;
  delete MinValue;
  #endif
}

void AngularCoordinateCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<TypeOfCoordinates");
  TypeOfCoordinates->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</TypeOfCoordinates>\n");
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool AngularCoordinateCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in AngularCoordinateCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in AngularCoordinateCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in AngularCoordinateCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in AngularCoordinateCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredAngularValueType * AngularCoordinateCharacteristicMeasurementType::getValue()
{return Value;}

void AngularCoordinateCharacteristicMeasurementType::setValue(MeasuredAngularValueType * ValueIn)
{Value = ValueIn;}

MeasuredAngularValueType * AngularCoordinateCharacteristicMeasurementType::getMaxValue()
{return MaxValue;}

void AngularCoordinateCharacteristicMeasurementType::setMaxValue(MeasuredAngularValueType * MaxValueIn)
{MaxValue = MaxValueIn;}

MeasuredAngularValueType * AngularCoordinateCharacteristicMeasurementType::getMinValue()
{return MinValue;}

void AngularCoordinateCharacteristicMeasurementType::setMinValue(MeasuredAngularValueType * MinValueIn)
{MinValue = MinValueIn;}

/* ***************************************************************** */

/* class AngularCoordinateCharacteristicNominalType

*/

AngularCoordinateCharacteristicNominalType::AngularCoordinateCharacteristicNominalType() :
  CoordinateCharacteristicNominalBaseType()
{
  TargetValue = 0;
  Direction = 0;
  CoordinateSystemId = 0;
}

AngularCoordinateCharacteristicNominalType::AngularCoordinateCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 AngularValueType * TargetValueIn,
 AngularCoordinateDirectionEnumType * DirectionIn,
 QIFReferenceFullType * CoordinateSystemIdIn) :
  CoordinateCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  TargetValue = TargetValueIn;
  Direction = DirectionIn;
  CoordinateSystemId = CoordinateSystemIdIn;
}

AngularCoordinateCharacteristicNominalType::AngularCoordinateCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 AngularValueType * TargetValueIn,
 AngularCoordinateDirectionEnumType * DirectionIn,
 QIFReferenceFullType * CoordinateSystemIdIn) :
  CoordinateCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  TargetValue = TargetValueIn;
  Direction = DirectionIn;
  CoordinateSystemId = CoordinateSystemIdIn;
}

AngularCoordinateCharacteristicNominalType::~AngularCoordinateCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  delete TargetValue;
  delete Direction;
  delete CoordinateSystemId;
  #endif
}

void AngularCoordinateCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Direction");
  Direction->printSelf(outFile);
  fprintf(outFile, "</Direction>\n");
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool AngularCoordinateCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in AngularCoordinateCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in AngularCoordinateCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in AngularCoordinateCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in AngularCoordinateCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

AngularValueType * AngularCoordinateCharacteristicNominalType::getTargetValue()
{return TargetValue;}

void AngularCoordinateCharacteristicNominalType::setTargetValue(AngularValueType * TargetValueIn)
{TargetValue = TargetValueIn;}

AngularCoordinateDirectionEnumType * AngularCoordinateCharacteristicNominalType::getDirection()
{return Direction;}

void AngularCoordinateCharacteristicNominalType::setDirection(AngularCoordinateDirectionEnumType * DirectionIn)
{Direction = DirectionIn;}

QIFReferenceFullType * AngularCoordinateCharacteristicNominalType::getCoordinateSystemId()
{return CoordinateSystemId;}

void AngularCoordinateCharacteristicNominalType::setCoordinateSystemId(QIFReferenceFullType * CoordinateSystemIdIn)
{CoordinateSystemId = CoordinateSystemIdIn;}

/* ***************************************************************** */

/* class AngularityCharacteristicDefinitionType

*/

AngularityCharacteristicDefinitionType::AngularityCharacteristicDefinitionType() :
  OrientationCharacteristicDefinitionBaseType()
{
}

AngularityCharacteristicDefinitionType::AngularityCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 QIFReferenceFullType * DatumReferenceFrameIdIn,
 MaterialModifierEnumType * MaterialConditionIn,
 QIFReferenceType * SizeCharacteristicDefinitionIdIn,
 OrientationZoneShapeType * ZoneShapeIn,
 XmlBoolean * TangentPlaneIn,
 LinearValueType * MaximumToleranceValueIn,
 LinearValueType * ProjectedToleranceZoneValueIn,
 OrientationChar_1054_Type * OrientationChar_1054In) :
  OrientationCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn,
    ToleranceValueIn,
    ToleranceDualValueIn,
    DatumReferenceFrameIdIn,
    MaterialConditionIn,
    SizeCharacteristicDefinitionIdIn,
    ZoneShapeIn,
    TangentPlaneIn,
    MaximumToleranceValueIn,
    ProjectedToleranceZoneValueIn,
    OrientationChar_1054In)
{
}

AngularityCharacteristicDefinitionType::AngularityCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 QIFReferenceFullType * DatumReferenceFrameIdIn,
 MaterialModifierEnumType * MaterialConditionIn,
 QIFReferenceType * SizeCharacteristicDefinitionIdIn,
 OrientationZoneShapeType * ZoneShapeIn,
 XmlBoolean * TangentPlaneIn,
 LinearValueType * MaximumToleranceValueIn,
 LinearValueType * ProjectedToleranceZoneValueIn,
 OrientationChar_1054_Type * OrientationChar_1054In) :
  OrientationCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn,
    ToleranceValueIn,
    ToleranceDualValueIn,
    DatumReferenceFrameIdIn,
    MaterialConditionIn,
    SizeCharacteristicDefinitionIdIn,
    ZoneShapeIn,
    TangentPlaneIn,
    MaximumToleranceValueIn,
    ProjectedToleranceZoneValueIn,
    OrientationChar_1054In)
{
}

AngularityCharacteristicDefinitionType::~AngularityCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void AngularityCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (GeometricCharac_1050)
    {
  GeometricCharac_1050->printSelf(outFile);
    }
  if (DirectionFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DirectionFeature");
      DirectionFeature->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DirectionFeature>\n");
    }
  if (CollectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CollectionPlane");
      CollectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CollectionPlane>\n");
    }
  if (IntersectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IntersectionPlane");
      IntersectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</IntersectionPlane>\n");
    }
  if (OrientationPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OrientationPlane");
      OrientationPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OrientationPlane>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ToleranceValue");
  ToleranceValue->printSelf(outFile);
  fprintf(outFile, "</ToleranceValue>\n");
  if (ToleranceDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceDualValue");
      ToleranceDualValue->printSelf(outFile);
      fprintf(outFile, "</ToleranceDualValue>\n");
    }
  if (DatumReferenceFrameId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumReferenceFrameId");
      DatumReferenceFrameId->printSelf(outFile);
      fprintf(outFile, "</DatumReferenceFrameId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<MaterialCondition");
  MaterialCondition->printSelf(outFile);
  fprintf(outFile, "</MaterialCondition>\n");
  if (SizeCharacteristicDefinitionId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SizeCharacteristicDefinitionId");
      SizeCharacteristicDefinitionId->printSelf(outFile);
      fprintf(outFile, "</SizeCharacteristicDefinitionId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ZoneShape");
  ZoneShape->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ZoneShape>\n");
  if (TangentPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TangentPlane");
      TangentPlane->printSelf(outFile);
      fprintf(outFile, "</TangentPlane>\n");
    }
  if (MaximumToleranceValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaximumToleranceValue");
      MaximumToleranceValue->printSelf(outFile);
      fprintf(outFile, "</MaximumToleranceValue>\n");
    }
  if (ProjectedToleranceZoneValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProjectedToleranceZoneValue");
      ProjectedToleranceZoneValue->printSelf(outFile);
      fprintf(outFile, "</ProjectedToleranceZoneValue>\n");
    }
  if (OrientationChar_1054)
    {
  OrientationChar_1054->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool AngularityCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in AngularityCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in AngularityCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in AngularityCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in AngularityCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class AngularityCharacteristicItemType

*/

AngularityCharacteristicItemType::AngularityCharacteristicItemType() :
  OrientationCharacteristicItemBaseType()
{
}

AngularityCharacteristicItemType::AngularityCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  OrientationCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

AngularityCharacteristicItemType::AngularityCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  OrientationCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

AngularityCharacteristicItemType::~AngularityCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void AngularityCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool AngularityCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in AngularityCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in AngularityCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in AngularityCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in AngularityCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class AngularityCharacteristicMeasurementType

*/

AngularityCharacteristicMeasurementType::AngularityCharacteristicMeasurementType() :
  OrientationCharacteristicMeasurementBaseType()
{
}

AngularityCharacteristicMeasurementType::AngularityCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 XmlBoolean * DatumsOkIn,
 MeasuredLinearValueType * BonusIn,
 LinearValueType * ReferenceLengthIn,
 QIFReferenceType * DRFTransformActualIdIn) :
  OrientationCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn,
    DatumsOkIn,
    BonusIn,
    ReferenceLengthIn,
    DRFTransformActualIdIn)
{
}

AngularityCharacteristicMeasurementType::AngularityCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 XmlBoolean * DatumsOkIn,
 MeasuredLinearValueType * BonusIn,
 LinearValueType * ReferenceLengthIn,
 QIFReferenceType * DRFTransformActualIdIn) :
  OrientationCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn,
    DatumsOkIn,
    BonusIn,
    ReferenceLengthIn,
    DRFTransformActualIdIn)
{
}

AngularityCharacteristicMeasurementType::~AngularityCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void AngularityCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  if (DatumsOk)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumsOk");
      DatumsOk->printSelf(outFile);
      fprintf(outFile, "</DatumsOk>\n");
    }
  if (Bonus)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Bonus");
      Bonus->printSelf(outFile);
      fprintf(outFile, "</Bonus>\n");
    }
  if (ReferenceLength)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ReferenceLength");
      ReferenceLength->printSelf(outFile);
      fprintf(outFile, "</ReferenceLength>\n");
    }
  if (DRFTransformActualId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DRFTransformActualId");
      DRFTransformActualId->printSelf(outFile);
      fprintf(outFile, "</DRFTransformActualId>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool AngularityCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in AngularityCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in AngularityCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in AngularityCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in AngularityCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class AngularityCharacteristicNominalType

*/

AngularityCharacteristicNominalType::AngularityCharacteristicNominalType() :
  OrientationCharacteristicNominalBaseType()
{
  Angle = 0;
}

AngularityCharacteristicNominalType::AngularityCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 AngularValueType * AngleIn) :
  OrientationCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  Angle = AngleIn;
}

AngularityCharacteristicNominalType::AngularityCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 AngularValueType * AngleIn) :
  OrientationCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  Angle = AngleIn;
}

AngularityCharacteristicNominalType::~AngularityCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  delete Angle;
  #endif
}

void AngularityCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (Angle)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Angle");
      Angle->printSelf(outFile);
      fprintf(outFile, "</Angle>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool AngularityCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in AngularityCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in AngularityCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in AngularityCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in AngularityCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

AngularValueType * AngularityCharacteristicNominalType::getAngle()
{return Angle;}

void AngularityCharacteristicNominalType::setAngle(AngularValueType * AngleIn)
{Angle = AngleIn;}

/* ***************************************************************** */

/* class AreaCharacteristicDefinitionBaseType

*/

AreaCharacteristicDefinitionBaseType::AreaCharacteristicDefinitionBaseType() :
  CharacteristicDefinitionBaseType()
{
  AreaCharacteristicDefinitionBaseTypePair = 0;
}

AreaCharacteristicDefinitionBaseType::AreaCharacteristicDefinitionBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 AreaCharacteristicDefinitionBaseTypeChoicePair * AreaCharacteristicDefinitionBaseTypePairIn) :
  CharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
  AreaCharacteristicDefinitionBaseTypePair = AreaCharacteristicDefinitionBaseTypePairIn;
}

AreaCharacteristicDefinitionBaseType::AreaCharacteristicDefinitionBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 AreaCharacteristicDefinitionBaseTypeChoicePair * AreaCharacteristicDefinitionBaseTypePairIn) :
  CharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
  AreaCharacteristicDefinitionBaseTypePair = AreaCharacteristicDefinitionBaseTypePairIn;
}

AreaCharacteristicDefinitionBaseType::~AreaCharacteristicDefinitionBaseType()
{
  #ifndef NODESTRUCT
  delete AreaCharacteristicDefinitionBaseTypePair;
  #endif
}

void AreaCharacteristicDefinitionBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  AreaCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}
AreaCharacteristicDefinitionBaseTypeChoicePair * AreaCharacteristicDefinitionBaseType::getAreaCharacteristicDefinitionBaseTypeChoicePair()
{return AreaCharacteristicDefinitionBaseTypePair;}

void AreaCharacteristicDefinitionBaseType::setAreaCharacteristicDefinitionBaseTypeChoicePair(AreaCharacteristicDefinitionBaseTypeChoicePair * AreaCharacteristicDefinitionBaseTypePairIn)
{AreaCharacteristicDefinitionBaseTypePair = AreaCharacteristicDefinitionBaseTypePairIn;}

/* ***************************************************************** */

AreaCharacteristicDefinitionBaseTypeChoicePair::AreaCharacteristicDefinitionBaseTypeChoicePair() {}

AreaCharacteristicDefinitionBaseTypeChoicePair::AreaCharacteristicDefinitionBaseTypeChoicePair(
 whichOne AreaCharacteristicDefinitionBaseTypeTypeIn,
 AreaCharacteristicDefinitionBaseTypeVal AreaCharacteristicDefinitionBaseTypeValueIn)
{
  AreaCharacteristicDefinitionBaseTypeType = AreaCharacteristicDefinitionBaseTypeTypeIn;
  AreaCharacteristicDefinitionBaseTypeValue = AreaCharacteristicDefinitionBaseTypeValueIn;
}

AreaCharacteristicDefinitionBaseTypeChoicePair::~AreaCharacteristicDefinitionBaseTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (AreaCharacteristicDefinitionBaseTypeType == ToleranceE)
    delete AreaCharacteristicDefinitionBaseTypeValue.Tolerance;
  else if (AreaCharacteristicDefinitionBaseTypeType == NonToleranceE)
    delete AreaCharacteristicDefinitionBaseTypeValue.NonTolerance;
  #endif
}

void AreaCharacteristicDefinitionBaseTypeChoicePair::printSelf(FILE * outFile)
{
  if (AreaCharacteristicDefinitionBaseTypeType == ToleranceE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Tolerance");
      AreaCharacteristicDefinitionBaseTypeValue.Tolerance->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Tolerance>\n");
    }
  else if (AreaCharacteristicDefinitionBaseTypeType == NonToleranceE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonTolerance");
      AreaCharacteristicDefinitionBaseTypeValue.NonTolerance->printSelf(outFile);
      fprintf(outFile, "</NonTolerance>\n");
    }
}

bool AreaCharacteristicDefinitionBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in AreaCharacteristicDefinitionBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in AreaCharacteristicDefinitionBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in AreaCharacteristicDefinitionBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in AreaCharacteristicDefinitionBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class AreaCharacteristicItemBaseType

*/

AreaCharacteristicItemBaseType::AreaCharacteristicItemBaseType() :
  CharacteristicItemBaseType()
{
}

AreaCharacteristicItemBaseType::AreaCharacteristicItemBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  CharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

AreaCharacteristicItemBaseType::AreaCharacteristicItemBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  CharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

AreaCharacteristicItemBaseType::~AreaCharacteristicItemBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void AreaCharacteristicItemBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool AreaCharacteristicItemBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in AreaCharacteristicItemBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in AreaCharacteristicItemBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in AreaCharacteristicItemBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in AreaCharacteristicItemBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class AreaCharacteristicMeasurementBaseType

*/

AreaCharacteristicMeasurementBaseType::AreaCharacteristicMeasurementBaseType() :
  CharacteristicMeasurementBaseType()
{
  Value = 0;
  MaxValue = 0;
  MinValue = 0;
}

AreaCharacteristicMeasurementBaseType::AreaCharacteristicMeasurementBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredAreaValueType * ValueIn,
 MeasuredAreaValueType * MaxValueIn,
 MeasuredAreaValueType * MinValueIn) :
  CharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  Value = ValueIn;
  MaxValue = MaxValueIn;
  MinValue = MinValueIn;
}

AreaCharacteristicMeasurementBaseType::AreaCharacteristicMeasurementBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredAreaValueType * ValueIn,
 MeasuredAreaValueType * MaxValueIn,
 MeasuredAreaValueType * MinValueIn) :
  CharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  Value = ValueIn;
  MaxValue = MaxValueIn;
  MinValue = MinValueIn;
}

AreaCharacteristicMeasurementBaseType::~AreaCharacteristicMeasurementBaseType()
{
  #ifndef NODESTRUCT
  delete Value;
  delete MaxValue;
  delete MinValue;
  #endif
}

void AreaCharacteristicMeasurementBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool AreaCharacteristicMeasurementBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in AreaCharacteristicMeasurementBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in AreaCharacteristicMeasurementBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in AreaCharacteristicMeasurementBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in AreaCharacteristicMeasurementBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredAreaValueType * AreaCharacteristicMeasurementBaseType::getValue()
{return Value;}

void AreaCharacteristicMeasurementBaseType::setValue(MeasuredAreaValueType * ValueIn)
{Value = ValueIn;}

MeasuredAreaValueType * AreaCharacteristicMeasurementBaseType::getMaxValue()
{return MaxValue;}

void AreaCharacteristicMeasurementBaseType::setMaxValue(MeasuredAreaValueType * MaxValueIn)
{MaxValue = MaxValueIn;}

MeasuredAreaValueType * AreaCharacteristicMeasurementBaseType::getMinValue()
{return MinValue;}

void AreaCharacteristicMeasurementBaseType::setMinValue(MeasuredAreaValueType * MinValueIn)
{MinValue = MinValueIn;}

/* ***************************************************************** */

/* class AreaCharacteristicNominalBaseType

*/

AreaCharacteristicNominalBaseType::AreaCharacteristicNominalBaseType() :
  CharacteristicNominalBaseType()
{
  TargetValue = 0;
}

AreaCharacteristicNominalBaseType::AreaCharacteristicNominalBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 AreaValueType * TargetValueIn) :
  CharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  TargetValue = TargetValueIn;
}

AreaCharacteristicNominalBaseType::AreaCharacteristicNominalBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 AreaValueType * TargetValueIn) :
  CharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  TargetValue = TargetValueIn;
}

AreaCharacteristicNominalBaseType::~AreaCharacteristicNominalBaseType()
{
  #ifndef NODESTRUCT
  delete TargetValue;
  #endif
}

void AreaCharacteristicNominalBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool AreaCharacteristicNominalBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in AreaCharacteristicNominalBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in AreaCharacteristicNominalBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in AreaCharacteristicNominalBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in AreaCharacteristicNominalBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

AreaValueType * AreaCharacteristicNominalBaseType::getTargetValue()
{return TargetValue;}

void AreaCharacteristicNominalBaseType::setTargetValue(AreaValueType * TargetValueIn)
{TargetValue = TargetValueIn;}

/* ***************************************************************** */

/* class ArrayNonDestructiveTestingType

*/

ArrayNonDestructiveTestingType::ArrayNonDestructiveTestingType()
{
  n = 0;
  TypeOfTest = 0;
}

ArrayNonDestructiveTestingType::ArrayNonDestructiveTestingType(
 NonDestructiveTestingEnumTypeLisd * TypeOfTestIn)
{
  n = 0;
  TypeOfTest = TypeOfTestIn;
}

ArrayNonDestructiveTestingType::ArrayNonDestructiveTestingType(
 NaturalType * nIn,
 NonDestructiveTestingEnumTypeLisd * TypeOfTestIn)
{
  n = nIn;
  TypeOfTest = TypeOfTestIn;
}

ArrayNonDestructiveTestingType::~ArrayNonDestructiveTestingType()
{
  #ifndef NODESTRUCT
  delete n;
  delete TypeOfTest;
  #endif
}

void ArrayNonDestructiveTestingType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!TypeOfTest)
      {
        fprintf(stderr, "TypeOfTest list is missing\n");
        exit(1);
      }
    if (TypeOfTest->size() == 0)
      {
        fprintf(stderr, "TypeOfTest list is empty\n");
        exit(1);
      }
    if (TypeOfTest->size() < 1)
      {
        fprintf(stderr,
                "size of TypeOfTest list (%d) less than minimum required (1)\n",
                (int)TypeOfTest->size());
        exit(1);
      }
    std::list<NonDestructiveTestingEnumType *>::iterator iter;
    for (iter = TypeOfTest->begin();
         iter != TypeOfTest->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<TypeOfTest");
        (*iter)->printSelf(outFile);
        fprintf(outFile, "</TypeOfTest>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool ArrayNonDestructiveTestingType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in ArrayNonDestructiveTestingType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in ArrayNonDestructiveTestingType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ArrayNonDestructiveTestingType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in ArrayNonDestructiveTestingType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * ArrayNonDestructiveTestingType::getn()
{return n;}

void ArrayNonDestructiveTestingType::setn(NaturalType * nIn)
{n = nIn;}

NonDestructiveTestingEnumTypeLisd * ArrayNonDestructiveTestingType::getTypeOfTest()
{return TypeOfTest;}

void ArrayNonDestructiveTestingType::setTypeOfTest(NonDestructiveTestingEnumTypeLisd * TypeOfTestIn)
{TypeOfTest = TypeOfTestIn;}

/* ***************************************************************** */

/* class AssociatedTolerancedFeatureSpecificationElementEnumType

*/

AssociatedTolerancedFeatureSpecificationElementEnumType::AssociatedTolerancedFeatureSpecificationElementEnumType() :
  XmlNMTOKEN()
{
}

AssociatedTolerancedFeatureSpecificationElementEnumType::AssociatedTolerancedFeatureSpecificationElementEnumType(
 const char * valIn) :
  XmlNMTOKEN(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "C") &&
           strcmp(val.c_str(), "G") &&
           strcmp(val.c_str(), "N") &&
           strcmp(val.c_str(), "T") &&
           strcmp(val.c_str(), "X"));
}

AssociatedTolerancedFeatureSpecificationElementEnumType::~AssociatedTolerancedFeatureSpecificationElementEnumType() {}

bool AssociatedTolerancedFeatureSpecificationElementEnumType::AssociatedTolerancedFeatureSpecificationElementEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "C") &&
          strcmp(val.c_str(), "G") &&
          strcmp(val.c_str(), "N") &&
          strcmp(val.c_str(), "T") &&
          strcmp(val.c_str(), "X"));
}

void AssociatedTolerancedFeatureSpecificationElementEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "AssociatedTolerancedFeatureSpecificationElementEnumType");
}

void AssociatedTolerancedFeatureSpecificationElementEnumType::printSelf(FILE * outFile)
{
  if (AssociatedTolerancedFeatureSpecificationElementEnumTypeIsBad())
    {
      fprintf(stderr, "bad AssociatedTolerancedFeatureSpecificationElementEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::printSelf(outFile);
}

void AssociatedTolerancedFeatureSpecificationElementEnumType::oPrintSelf(FILE * outFile)
{
  if (AssociatedTolerancedFeatureSpecificationElementEnumTypeIsBad())
    {
      fprintf(stderr, "bad AssociatedTolerancedFeatureSpecificationElementEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class CharacteristicAspectsListsType

*/

CharacteristicAspectsListsType::CharacteristicAspectsListsType()
{
  FormalStandardId = 0;
  CharacteristicDefinitions = 0;
  DefaultCharacteristicDefinitions = 0;
  DefaultToleranceDefinitions = 0;
  CharacteristicNominals = 0;
  CharacteristicItems = 0;
  CharacteristicGroups = 0;
  SimultaneousRequirementGroups = 0;
}

CharacteristicAspectsListsType::CharacteristicAspectsListsType(
 QIFReferenceType * FormalStandardIdIn,
 CharacteristicDefinitionsType * CharacteristicDefinitionsIn,
 CharacteristicDefinitionsType * DefaultCharacteristicDefinitionsIn,
 ToleranceDefinitionsType * DefaultToleranceDefinitionsIn,
 CharacteristicNominalsType * CharacteristicNominalsIn,
 CharacteristicItemsType * CharacteristicItemsIn,
 CharacteristicGroupsType * CharacteristicGroupsIn,
 SimultaneousRequirementGroupsType * SimultaneousRequirementGroupsIn)
{
  FormalStandardId = FormalStandardIdIn;
  CharacteristicDefinitions = CharacteristicDefinitionsIn;
  DefaultCharacteristicDefinitions = DefaultCharacteristicDefinitionsIn;
  DefaultToleranceDefinitions = DefaultToleranceDefinitionsIn;
  CharacteristicNominals = CharacteristicNominalsIn;
  CharacteristicItems = CharacteristicItemsIn;
  CharacteristicGroups = CharacteristicGroupsIn;
  SimultaneousRequirementGroups = SimultaneousRequirementGroupsIn;
}

CharacteristicAspectsListsType::~CharacteristicAspectsListsType()
{
  #ifndef NODESTRUCT
  delete FormalStandardId;
  delete CharacteristicDefinitions;
  delete DefaultCharacteristicDefinitions;
  delete DefaultToleranceDefinitions;
  delete CharacteristicNominals;
  delete CharacteristicItems;
  delete CharacteristicGroups;
  delete SimultaneousRequirementGroups;
  #endif
}

void CharacteristicAspectsListsType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<FormalStandardId");
  FormalStandardId->printSelf(outFile);
  fprintf(outFile, "</FormalStandardId>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitions");
  CharacteristicDefinitions->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</CharacteristicDefinitions>\n");
  if (DefaultCharacteristicDefinitions)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DefaultCharacteristicDefinitions");
      DefaultCharacteristicDefinitions->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DefaultCharacteristicDefinitions>\n");
    }
  if (DefaultToleranceDefinitions)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DefaultToleranceDefinitions");
      DefaultToleranceDefinitions->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DefaultToleranceDefinitions>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominals");
  CharacteristicNominals->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</CharacteristicNominals>\n");
  if (CharacteristicItems)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicItems");
      CharacteristicItems->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicItems>\n");
    }
  if (CharacteristicGroups)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicGroups");
      CharacteristicGroups->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicGroups>\n");
    }
  if (SimultaneousRequirementGroups)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SimultaneousRequirementGroups");
      SimultaneousRequirementGroups->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SimultaneousRequirementGroups>\n");
    }
  doSpaces(-INDENT, outFile);
}

QIFReferenceType * CharacteristicAspectsListsType::getFormalStandardId()
{return FormalStandardId;}

void CharacteristicAspectsListsType::setFormalStandardId(QIFReferenceType * FormalStandardIdIn)
{FormalStandardId = FormalStandardIdIn;}

CharacteristicDefinitionsType * CharacteristicAspectsListsType::getCharacteristicDefinitions()
{return CharacteristicDefinitions;}

void CharacteristicAspectsListsType::setCharacteristicDefinitions(CharacteristicDefinitionsType * CharacteristicDefinitionsIn)
{CharacteristicDefinitions = CharacteristicDefinitionsIn;}

CharacteristicDefinitionsType * CharacteristicAspectsListsType::getDefaultCharacteristicDefinitions()
{return DefaultCharacteristicDefinitions;}

void CharacteristicAspectsListsType::setDefaultCharacteristicDefinitions(CharacteristicDefinitionsType * DefaultCharacteristicDefinitionsIn)
{DefaultCharacteristicDefinitions = DefaultCharacteristicDefinitionsIn;}

ToleranceDefinitionsType * CharacteristicAspectsListsType::getDefaultToleranceDefinitions()
{return DefaultToleranceDefinitions;}

void CharacteristicAspectsListsType::setDefaultToleranceDefinitions(ToleranceDefinitionsType * DefaultToleranceDefinitionsIn)
{DefaultToleranceDefinitions = DefaultToleranceDefinitionsIn;}

CharacteristicNominalsType * CharacteristicAspectsListsType::getCharacteristicNominals()
{return CharacteristicNominals;}

void CharacteristicAspectsListsType::setCharacteristicNominals(CharacteristicNominalsType * CharacteristicNominalsIn)
{CharacteristicNominals = CharacteristicNominalsIn;}

CharacteristicItemsType * CharacteristicAspectsListsType::getCharacteristicItems()
{return CharacteristicItems;}

void CharacteristicAspectsListsType::setCharacteristicItems(CharacteristicItemsType * CharacteristicItemsIn)
{CharacteristicItems = CharacteristicItemsIn;}

CharacteristicGroupsType * CharacteristicAspectsListsType::getCharacteristicGroups()
{return CharacteristicGroups;}

void CharacteristicAspectsListsType::setCharacteristicGroups(CharacteristicGroupsType * CharacteristicGroupsIn)
{CharacteristicGroups = CharacteristicGroupsIn;}

SimultaneousRequirementGroupsType * CharacteristicAspectsListsType::getSimultaneousRequirementGroups()
{return SimultaneousRequirementGroups;}

void CharacteristicAspectsListsType::setSimultaneousRequirementGroups(SimultaneousRequirementGroupsType * SimultaneousRequirementGroupsIn)
{SimultaneousRequirementGroups = SimultaneousRequirementGroupsIn;}

/* ***************************************************************** */

/* class CharacteristicBalloonLocationEnumType

*/

CharacteristicBalloonLocationEnumType::CharacteristicBalloonLocationEnumType() :
  XmlNMTOKEN()
{
}

CharacteristicBalloonLocationEnumType::CharacteristicBalloonLocationEnumType(
 const char * valIn) :
  XmlNMTOKEN(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "ABOVE") &&
           strcmp(val.c_str(), "BELOW") &&
           strcmp(val.c_str(), "LEFT") &&
           strcmp(val.c_str(), "RIGHT") &&
           strcmp(val.c_str(), "DEFAULT") &&
           strcmp(val.c_str(), "UNDEFINED"));
}

CharacteristicBalloonLocationEnumType::~CharacteristicBalloonLocationEnumType() {}

bool CharacteristicBalloonLocationEnumType::CharacteristicBalloonLocationEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "ABOVE") &&
          strcmp(val.c_str(), "BELOW") &&
          strcmp(val.c_str(), "LEFT") &&
          strcmp(val.c_str(), "RIGHT") &&
          strcmp(val.c_str(), "DEFAULT") &&
          strcmp(val.c_str(), "UNDEFINED"));
}

void CharacteristicBalloonLocationEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "CharacteristicBalloonLocationEnumType");
}

void CharacteristicBalloonLocationEnumType::printSelf(FILE * outFile)
{
  if (CharacteristicBalloonLocationEnumTypeIsBad())
    {
      fprintf(stderr, "bad CharacteristicBalloonLocationEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::printSelf(outFile);
}

void CharacteristicBalloonLocationEnumType::oPrintSelf(FILE * outFile)
{
  if (CharacteristicBalloonLocationEnumTypeIsBad())
    {
      fprintf(stderr, "bad CharacteristicBalloonLocationEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class CharacteristicBalloonStyleEnumType

*/

CharacteristicBalloonStyleEnumType::CharacteristicBalloonStyleEnumType() :
  XmlNMTOKEN()
{
}

CharacteristicBalloonStyleEnumType::CharacteristicBalloonStyleEnumType(
 const char * valIn) :
  XmlNMTOKEN(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "OPEN_CIRCLE") &&
           strcmp(val.c_str(), "BARRED_CIRCLE") &&
           strcmp(val.c_str(), "ELONGATED_CIRCLE") &&
           strcmp(val.c_str(), "SPLIT_CIRCLE") &&
           strcmp(val.c_str(), "PENTAGON") &&
           strcmp(val.c_str(), "HEXAGON") &&
           strcmp(val.c_str(), "OCTAGON") &&
           strcmp(val.c_str(), "RECTANGLE") &&
           strcmp(val.c_str(), "ROUNDED_RECTANGLE") &&
           strcmp(val.c_str(), "ELONGATED_HEXAGON") &&
           strcmp(val.c_str(), "FORWARD_CHEVRON") &&
           strcmp(val.c_str(), "BACKWARD_CHEVRON") &&
           strcmp(val.c_str(), "DEFAULT") &&
           strcmp(val.c_str(), "UNDEFINED"));
}

CharacteristicBalloonStyleEnumType::~CharacteristicBalloonStyleEnumType() {}

bool CharacteristicBalloonStyleEnumType::CharacteristicBalloonStyleEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "OPEN_CIRCLE") &&
          strcmp(val.c_str(), "BARRED_CIRCLE") &&
          strcmp(val.c_str(), "ELONGATED_CIRCLE") &&
          strcmp(val.c_str(), "SPLIT_CIRCLE") &&
          strcmp(val.c_str(), "PENTAGON") &&
          strcmp(val.c_str(), "HEXAGON") &&
          strcmp(val.c_str(), "OCTAGON") &&
          strcmp(val.c_str(), "RECTANGLE") &&
          strcmp(val.c_str(), "ROUNDED_RECTANGLE") &&
          strcmp(val.c_str(), "ELONGATED_HEXAGON") &&
          strcmp(val.c_str(), "FORWARD_CHEVRON") &&
          strcmp(val.c_str(), "BACKWARD_CHEVRON") &&
          strcmp(val.c_str(), "DEFAULT") &&
          strcmp(val.c_str(), "UNDEFINED"));
}

void CharacteristicBalloonStyleEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "CharacteristicBalloonStyleEnumType");
}

void CharacteristicBalloonStyleEnumType::printSelf(FILE * outFile)
{
  if (CharacteristicBalloonStyleEnumTypeIsBad())
    {
      fprintf(stderr, "bad CharacteristicBalloonStyleEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::printSelf(outFile);
}

void CharacteristicBalloonStyleEnumType::oPrintSelf(FILE * outFile)
{
  if (CharacteristicBalloonStyleEnumTypeIsBad())
    {
      fprintf(stderr, "bad CharacteristicBalloonStyleEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class CharacteristicBalloonType

*/

CharacteristicBalloonType::CharacteristicBalloonType()
{
  BalloonLocation = 0;
  BalloonStyle = 0;
}

CharacteristicBalloonType::CharacteristicBalloonType(
 CharacteristicBalloonLocationEnumType * BalloonLocationIn,
 CharacteristicBalloonStyleEnumType * BalloonStyleIn)
{
  BalloonLocation = BalloonLocationIn;
  BalloonStyle = BalloonStyleIn;
}

CharacteristicBalloonType::~CharacteristicBalloonType()
{
  #ifndef NODESTRUCT
  delete BalloonLocation;
  delete BalloonStyle;
  #endif
}

void CharacteristicBalloonType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<BalloonLocation");
  BalloonLocation->printSelf(outFile);
  fprintf(outFile, "</BalloonLocation>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<BalloonStyle");
  BalloonStyle->printSelf(outFile);
  fprintf(outFile, "</BalloonStyle>\n");
  doSpaces(-INDENT, outFile);
}

CharacteristicBalloonLocationEnumType * CharacteristicBalloonType::getBalloonLocation()
{return BalloonLocation;}

void CharacteristicBalloonType::setBalloonLocation(CharacteristicBalloonLocationEnumType * BalloonLocationIn)
{BalloonLocation = BalloonLocationIn;}

CharacteristicBalloonStyleEnumType * CharacteristicBalloonType::getBalloonStyle()
{return BalloonStyle;}

void CharacteristicBalloonType::setBalloonStyle(CharacteristicBalloonStyleEnumType * BalloonStyleIn)
{BalloonStyle = BalloonStyleIn;}

/* ***************************************************************** */

/* class CharacteristicBaseType

*/

CharacteristicBaseType::CharacteristicBaseType()
{
  id = 0;
  Attributes = 0;
  Description = 0;
}

CharacteristicBaseType::CharacteristicBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn)
{
  id = 0;
  Attributes = AttributesIn;
  Description = DescriptionIn;
}

CharacteristicBaseType::CharacteristicBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn)
{
  id = idIn;
  Attributes = AttributesIn;
  Description = DescriptionIn;
}

CharacteristicBaseType::~CharacteristicBaseType()
{
  #ifndef NODESTRUCT
  delete id;
  delete Attributes;
  delete Description;
  #endif
}

void CharacteristicBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CharacteristicBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CharacteristicBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CharacteristicBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CharacteristicBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CharacteristicBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

QIFIdType * CharacteristicBaseType::getid()
{return id;}

void CharacteristicBaseType::setid(QIFIdType * idIn)
{id = idIn;}

AttributesType * CharacteristicBaseType::getAttributes()
{return Attributes;}

void CharacteristicBaseType::setAttributes(AttributesType * AttributesIn)
{Attributes = AttributesIn;}

XmlString * CharacteristicBaseType::getDescription()
{return Description;}

void CharacteristicBaseType::setDescription(XmlString * DescriptionIn)
{Description = DescriptionIn;}

/* ***************************************************************** */

/* class CharacteristicDefinitionBaseType

*/

CharacteristicDefinitionBaseType::CharacteristicDefinitionBaseType() :
  CharacteristicBaseType()
{
  Name = 0;
  CharacteristicDesignator = 0;
  FreeState = 0;
  StatisticalCharacteristic = 0;
  CommonZone = 0;
  CommonTolerance = 0;
  MedianFeature = 0;
  EnvelopeRequirement = 0;
  Independency = 0;
  UnitedOrContinuousFeature = 0;
  SeparateZone = 0;
}

CharacteristicDefinitionBaseType::CharacteristicDefinitionBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  CharacteristicBaseType(
    AttributesIn,
    DescriptionIn)
{
  Name = NameIn;
  CharacteristicDesignator = CharacteristicDesignatorIn;
  FreeState = FreeStateIn;
  StatisticalCharacteristic = StatisticalCharacteristicIn;
  CommonZone = CommonZoneIn;
  CommonTolerance = CommonToleranceIn;
  MedianFeature = MedianFeatureIn;
  EnvelopeRequirement = EnvelopeRequirementIn;
  Independency = IndependencyIn;
  UnitedOrContinuousFeature = UnitedOrContinuousFeatureIn;
  SeparateZone = SeparateZoneIn;
}

CharacteristicDefinitionBaseType::CharacteristicDefinitionBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  CharacteristicBaseType(
    idIn,
    AttributesIn,
    DescriptionIn)
{
  Name = NameIn;
  CharacteristicDesignator = CharacteristicDesignatorIn;
  FreeState = FreeStateIn;
  StatisticalCharacteristic = StatisticalCharacteristicIn;
  CommonZone = CommonZoneIn;
  CommonTolerance = CommonToleranceIn;
  MedianFeature = MedianFeatureIn;
  EnvelopeRequirement = EnvelopeRequirementIn;
  Independency = IndependencyIn;
  UnitedOrContinuousFeature = UnitedOrContinuousFeatureIn;
  SeparateZone = SeparateZoneIn;
}

CharacteristicDefinitionBaseType::~CharacteristicDefinitionBaseType()
{
  #ifndef NODESTRUCT
  delete Name;
  delete CharacteristicDesignator;
  delete FreeState;
  delete StatisticalCharacteristic;
  delete CommonZone;
  delete CommonTolerance;
  delete MedianFeature;
  delete EnvelopeRequirement;
  delete Independency;
  delete UnitedOrContinuousFeature;
  delete SeparateZone;
  #endif
}

void CharacteristicDefinitionBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CharacteristicDefinitionBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CharacteristicDefinitionBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CharacteristicDefinitionBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CharacteristicDefinitionBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CharacteristicDefinitionBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

XmlToken * CharacteristicDefinitionBaseType::getName()
{return Name;}

void CharacteristicDefinitionBaseType::setName(XmlToken * NameIn)
{Name = NameIn;}

CharacteristicDesignatorType * CharacteristicDefinitionBaseType::getCharacteristicDesignator()
{return CharacteristicDesignator;}

void CharacteristicDefinitionBaseType::setCharacteristicDesignator(CharacteristicDesignatorType * CharacteristicDesignatorIn)
{CharacteristicDesignator = CharacteristicDesignatorIn;}

XmlBoolean * CharacteristicDefinitionBaseType::getFreeState()
{return FreeState;}

void CharacteristicDefinitionBaseType::setFreeState(XmlBoolean * FreeStateIn)
{FreeState = FreeStateIn;}

XmlBoolean * CharacteristicDefinitionBaseType::getStatisticalCharacteristic()
{return StatisticalCharacteristic;}

void CharacteristicDefinitionBaseType::setStatisticalCharacteristic(XmlBoolean * StatisticalCharacteristicIn)
{StatisticalCharacteristic = StatisticalCharacteristicIn;}

XmlBoolean * CharacteristicDefinitionBaseType::getCommonZone()
{return CommonZone;}

void CharacteristicDefinitionBaseType::setCommonZone(XmlBoolean * CommonZoneIn)
{CommonZone = CommonZoneIn;}

XmlBoolean * CharacteristicDefinitionBaseType::getCommonTolerance()
{return CommonTolerance;}

void CharacteristicDefinitionBaseType::setCommonTolerance(XmlBoolean * CommonToleranceIn)
{CommonTolerance = CommonToleranceIn;}

XmlBoolean * CharacteristicDefinitionBaseType::getMedianFeature()
{return MedianFeature;}

void CharacteristicDefinitionBaseType::setMedianFeature(XmlBoolean * MedianFeatureIn)
{MedianFeature = MedianFeatureIn;}

XmlBoolean * CharacteristicDefinitionBaseType::getEnvelopeRequirement()
{return EnvelopeRequirement;}

void CharacteristicDefinitionBaseType::setEnvelopeRequirement(XmlBoolean * EnvelopeRequirementIn)
{EnvelopeRequirement = EnvelopeRequirementIn;}

XmlBoolean * CharacteristicDefinitionBaseType::getIndependency()
{return Independency;}

void CharacteristicDefinitionBaseType::setIndependency(XmlBoolean * IndependencyIn)
{Independency = IndependencyIn;}

XmlBoolean * CharacteristicDefinitionBaseType::getUnitedOrContinuousFeature()
{return UnitedOrContinuousFeature;}

void CharacteristicDefinitionBaseType::setUnitedOrContinuousFeature(XmlBoolean * UnitedOrContinuousFeatureIn)
{UnitedOrContinuousFeature = UnitedOrContinuousFeatureIn;}

XmlBoolean * CharacteristicDefinitionBaseType::getSeparateZone()
{return SeparateZone;}

void CharacteristicDefinitionBaseType::setSeparateZone(XmlBoolean * SeparateZoneIn)
{SeparateZone = SeparateZoneIn;}

/* ***************************************************************** */

/* class CharacteristicDefinitionBaseTypeLisd

*/

CharacteristicDefinitionBaseTypeLisd::CharacteristicDefinitionBaseTypeLisd() {}

CharacteristicDefinitionBaseTypeLisd::CharacteristicDefinitionBaseTypeLisd(CharacteristicDefinitionBaseType * aCharacteristicDefinitionBaseType)
{
  push_back(aCharacteristicDefinitionBaseType);
}

CharacteristicDefinitionBaseTypeLisd::~CharacteristicDefinitionBaseTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<CharacteristicDefinitionBaseType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void CharacteristicDefinitionBaseTypeLisd::printSelf(FILE * outFile)
{
  std::list<CharacteristicDefinitionBaseType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class CharacteristicDefinitionsType

*/

CharacteristicDefinitionsType::CharacteristicDefinitionsType()
{
  n = 0;
  CharacteristicDefinition = 0;
}

CharacteristicDefinitionsType::CharacteristicDefinitionsType(
 CharacteristicDefinitionBaseTypeLisd * CharacteristicDefinitionIn)
{
  n = 0;
  CharacteristicDefinition = CharacteristicDefinitionIn;
}

CharacteristicDefinitionsType::CharacteristicDefinitionsType(
 NaturalType * nIn,
 CharacteristicDefinitionBaseTypeLisd * CharacteristicDefinitionIn)
{
  n = nIn;
  CharacteristicDefinition = CharacteristicDefinitionIn;
}

CharacteristicDefinitionsType::~CharacteristicDefinitionsType()
{
  #ifndef NODESTRUCT
  delete n;
  delete CharacteristicDefinition;
  #endif
}

void CharacteristicDefinitionsType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!CharacteristicDefinition)
      {
        fprintf(stderr, "CharacteristicDefinition list is missing\n");
        exit(1);
      }
    if (CharacteristicDefinition->size() == 0)
      {
        fprintf(stderr, "CharacteristicDefinition list is empty\n");
        exit(1);
      }
    if (CharacteristicDefinition->size() < 1)
      {
        fprintf(stderr,
                "size of CharacteristicDefinition list (%d) less than minimum required (1)\n",
                (int)CharacteristicDefinition->size());
        exit(1);
      }
    std::list<CharacteristicDefinitionBaseType *>::iterator iter;
    for (iter = CharacteristicDefinition->begin();
         iter != CharacteristicDefinition->end(); iter++)
      {
        CharacteristicDefinitionBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->getprintElement(), "AngleBetweenCharacteristicDefinition") == 0)
          {
            AngleBetweenCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<AngleBetweenCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<AngleBetweenCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AngleBetweenCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad AngleBetweenCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "AngleCharacteristicDefinition") == 0)
          {
            AngleCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<AngleCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<AngleCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AngleCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad AngleCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "AngularCoordinateCharacteristicDefinition") == 0)
          {
            AngularCoordinateCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<AngularCoordinateCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<AngularCoordinateCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AngularCoordinateCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad AngularCoordinateCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "AngleFromCharacteristicDefinition") == 0)
          {
            AngleFromCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<AngleFromCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<AngleFromCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AngleFromCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad AngleFromCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "AngularityCharacteristicDefinition") == 0)
          {
            AngularityCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<AngularityCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<AngularityCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AngularityCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad AngularityCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ChordCharacteristicDefinition") == 0)
          {
            ChordCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<ChordCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<ChordCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ChordCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad ChordCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CircularityCharacteristicDefinition") == 0)
          {
            CircularityCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<CircularityCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<CircularityCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CircularityCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad CircularityCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CircularRunoutCharacteristicDefinition") == 0)
          {
            CircularRunoutCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<CircularRunoutCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<CircularRunoutCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CircularRunoutCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad CircularRunoutCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CoaxialityCharacteristicDefinition") == 0)
          {
            CoaxialityCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<CoaxialityCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<CoaxialityCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CoaxialityCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad CoaxialityCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ConcentricityCharacteristicDefinition") == 0)
          {
            ConcentricityCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<ConcentricityCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<ConcentricityCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ConcentricityCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad ConcentricityCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ConicalTaperCharacteristicDefinition") == 0)
          {
            ConicalTaperCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<ConicalTaperCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<ConicalTaperCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ConicalTaperCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad ConicalTaperCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ConicityCharacteristicDefinition") == 0)
          {
            ConicityCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<ConicityCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<ConicityCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ConicityCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad ConicityCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CurveLengthCharacteristicDefinition") == 0)
          {
            CurveLengthCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<CurveLengthCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<CurveLengthCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CurveLengthCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad CurveLengthCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CylindricityCharacteristicDefinition") == 0)
          {
            CylindricityCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<CylindricityCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<CylindricityCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CylindricityCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad CylindricityCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "DepthCharacteristicDefinition") == 0)
          {
            DepthCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<DepthCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<DepthCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</DepthCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad DepthCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "DiameterCharacteristicDefinition") == 0)
          {
            DiameterCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<DiameterCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<DiameterCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</DiameterCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad DiameterCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "DistanceBetweenCharacteristicDefinition") == 0)
          {
            DistanceBetweenCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<DistanceBetweenCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<DistanceBetweenCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</DistanceBetweenCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad DistanceBetweenCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "DistanceFromCharacteristicDefinition") == 0)
          {
            DistanceFromCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<DistanceFromCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<DistanceFromCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</DistanceFromCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad DistanceFromCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "EllipticityCharacteristicDefinition") == 0)
          {
            EllipticityCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<EllipticityCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<EllipticityCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EllipticityCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad EllipticityCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "FlatTaperCharacteristicDefinition") == 0)
          {
            FlatTaperCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<FlatTaperCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<FlatTaperCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</FlatTaperCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad FlatTaperCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "FlatnessCharacteristicDefinition") == 0)
          {
            FlatnessCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<FlatnessCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<FlatnessCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</FlatnessCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad FlatnessCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "HeightCharacteristicDefinition") == 0)
          {
            HeightCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<HeightCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<HeightCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</HeightCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad HeightCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "LengthCharacteristicDefinition") == 0)
          {
            LengthCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<LengthCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<LengthCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LengthCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad LengthCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "LinearCoordinateCharacteristicDefinition") == 0)
          {
            LinearCoordinateCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<LinearCoordinateCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<LinearCoordinateCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LinearCoordinateCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad LinearCoordinateCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "LineProfileCharacteristicDefinition") == 0)
          {
            LineProfileCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<LineProfileCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<LineProfileCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LineProfileCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad LineProfileCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OtherFormCharacteristicDefinition") == 0)
          {
            OtherFormCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<OtherFormCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<OtherFormCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OtherFormCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad OtherFormCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ParallelismCharacteristicDefinition") == 0)
          {
            ParallelismCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<ParallelismCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<ParallelismCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ParallelismCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad ParallelismCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PerpendicularityCharacteristicDefinition") == 0)
          {
            PerpendicularityCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<PerpendicularityCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<PerpendicularityCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PerpendicularityCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad PerpendicularityCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PointProfileCharacteristicDefinition") == 0)
          {
            PointProfileCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<PointProfileCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<PointProfileCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PointProfileCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad PointProfileCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PositionCharacteristicDefinition") == 0)
          {
            PositionCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<PositionCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<PositionCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PositionCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad PositionCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "RadiusCharacteristicDefinition") == 0)
          {
            RadiusCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<RadiusCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<RadiusCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RadiusCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad RadiusCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SphericalDiameterCharacteristicDefinition") == 0)
          {
            SphericalDiameterCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<SphericalDiameterCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<SphericalDiameterCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalDiameterCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalDiameterCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SphericalRadiusCharacteristicDefinition") == 0)
          {
            SphericalRadiusCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<SphericalRadiusCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<SphericalRadiusCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalRadiusCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalRadiusCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SphericityCharacteristicDefinition") == 0)
          {
            SphericityCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<SphericityCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<SphericityCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericityCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericityCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SquareCharacteristicDefinition") == 0)
          {
            SquareCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<SquareCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<SquareCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SquareCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad SquareCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "StraightnessCharacteristicDefinition") == 0)
          {
            StraightnessCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<StraightnessCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<StraightnessCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</StraightnessCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad StraightnessCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SurfaceProfileCharacteristicDefinition") == 0)
          {
            SurfaceProfileCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<SurfaceProfileCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<SurfaceProfileCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SurfaceProfileCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad SurfaceProfileCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SurfaceProfileNonUniformCharacteristicDefinition") == 0)
          {
            SurfaceProfileNonUniformCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<SurfaceProfileNonUniformCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<SurfaceProfileNonUniformCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SurfaceProfileNonUniformCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad SurfaceProfileNonUniformCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SurfaceTextureCharacteristicDefinition") == 0)
          {
            SurfaceTextureCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<SurfaceTextureCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<SurfaceTextureCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SurfaceTextureCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad SurfaceTextureCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SymmetryCharacteristicDefinition") == 0)
          {
            SymmetryCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<SymmetryCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<SymmetryCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SymmetryCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad SymmetryCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ThicknessCharacteristicDefinition") == 0)
          {
            ThicknessCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<ThicknessCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<ThicknessCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ThicknessCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad ThicknessCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ThreadCharacteristicDefinition") == 0)
          {
            ThreadCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<ThreadCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<ThreadCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ThreadCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad ThreadCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ToroidicityCharacteristicDefinition") == 0)
          {
            ToroidicityCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<ToroidicityCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<ToroidicityCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ToroidicityCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad ToroidicityCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "TotalRunoutCharacteristicDefinition") == 0)
          {
            TotalRunoutCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<TotalRunoutCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<TotalRunoutCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalRunoutCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalRunoutCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedAttributeCharacteristicDefinition") == 0)
          {
            UserDefinedAttributeCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<UserDefinedAttributeCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedAttributeCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedAttributeCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedAttributeCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedLinearCharacteristicDefinition") == 0)
          {
            UserDefinedLinearCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<UserDefinedLinearCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedLinearCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedLinearCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedLinearCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedAngularCharacteristicDefinition") == 0)
          {
            UserDefinedAngularCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<UserDefinedAngularCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedAngularCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedAngularCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedAngularCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedTemperatureCharacteristicDefinition") == 0)
          {
            UserDefinedTemperatureCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<UserDefinedTemperatureCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedTemperatureCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedTemperatureCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedTemperatureCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedAreaCharacteristicDefinition") == 0)
          {
            UserDefinedAreaCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<UserDefinedAreaCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedAreaCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedAreaCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedAreaCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedForceCharacteristicDefinition") == 0)
          {
            UserDefinedForceCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<UserDefinedForceCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedForceCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedForceCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedForceCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedMassCharacteristicDefinition") == 0)
          {
            UserDefinedMassCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<UserDefinedMassCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedMassCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedMassCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedMassCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedPressureCharacteristicDefinition") == 0)
          {
            UserDefinedPressureCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<UserDefinedPressureCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedPressureCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedPressureCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedPressureCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedSpeedCharacteristicDefinition") == 0)
          {
            UserDefinedSpeedCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<UserDefinedSpeedCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedSpeedCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedSpeedCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedSpeedCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedTimeCharacteristicDefinition") == 0)
          {
            UserDefinedTimeCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<UserDefinedTimeCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedTimeCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedTimeCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedTimeCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedUnitCharacteristicDefinition") == 0)
          {
            UserDefinedUnitCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<UserDefinedUnitCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedUnitCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedUnitCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedUnitCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WidthCharacteristicDefinition") == 0)
          {
            WidthCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<WidthCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<WidthCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WidthCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad WidthCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldFilletCharacteristicDefinition") == 0)
          {
            WeldFilletCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<WeldFilletCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<WeldFilletCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldFilletCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldFilletCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldPlugCharacteristicDefinition") == 0)
          {
            WeldPlugCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<WeldPlugCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<WeldPlugCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldPlugCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldPlugCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldSlotCharacteristicDefinition") == 0)
          {
            WeldSlotCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<WeldSlotCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<WeldSlotCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldSlotCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldSlotCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldSpotCharacteristicDefinition") == 0)
          {
            WeldSpotCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<WeldSpotCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<WeldSpotCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldSpotCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldSpotCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldStudCharacteristicDefinition") == 0)
          {
            WeldStudCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<WeldStudCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<WeldStudCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldStudCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldStudCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldSeamCharacteristicDefinition") == 0)
          {
            WeldSeamCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<WeldSeamCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<WeldSeamCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldSeamCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldSeamCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldSurfacingCharacteristicDefinition") == 0)
          {
            WeldSurfacingCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<WeldSurfacingCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<WeldSurfacingCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldSurfacingCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldSurfacingCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldEdgeCharacteristicDefinition") == 0)
          {
            WeldEdgeCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<WeldEdgeCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<WeldEdgeCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldEdgeCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldEdgeCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldSquareCharacteristicDefinition") == 0)
          {
            WeldSquareCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<WeldSquareCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<WeldSquareCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldSquareCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldSquareCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldBevelCharacteristicDefinition") == 0)
          {
            WeldBevelCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<WeldBevelCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<WeldBevelCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldBevelCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldBevelCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldVCharacteristicDefinition") == 0)
          {
            WeldVCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<WeldVCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<WeldVCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldVCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldVCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldUCharacteristicDefinition") == 0)
          {
            WeldUCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<WeldUCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<WeldUCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldUCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldUCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldJCharacteristicDefinition") == 0)
          {
            WeldJCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<WeldJCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<WeldJCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldJCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldJCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldFlareVCharacteristicDefinition") == 0)
          {
            WeldFlareVCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<WeldFlareVCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<WeldFlareVCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldFlareVCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldFlareVCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldFlareBevelCharacteristicDefinition") == 0)
          {
            WeldFlareBevelCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<WeldFlareBevelCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<WeldFlareBevelCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldFlareBevelCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldFlareBevelCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldScarfCharacteristicDefinition") == 0)
          {
            WeldScarfCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<WeldScarfCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<WeldScarfCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldScarfCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldScarfCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldCompoundCharacteristicDefinition") == 0)
          {
            WeldCompoundCharacteristicDefinitionType * typ;
            if ((typ = dynamic_cast<WeldCompoundCharacteristicDefinitionType *>(basie)))
              {
                fprintf(outFile, "<WeldCompoundCharacteristicDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldCompoundCharacteristicDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldCompoundCharacteristicDefinition element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad CharacteristicDefinition type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool CharacteristicDefinitionsType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in CharacteristicDefinitionsType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in CharacteristicDefinitionsType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CharacteristicDefinitionsType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in CharacteristicDefinitionsType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * CharacteristicDefinitionsType::getn()
{return n;}

void CharacteristicDefinitionsType::setn(NaturalType * nIn)
{n = nIn;}

CharacteristicDefinitionBaseTypeLisd * CharacteristicDefinitionsType::getCharacteristicDefinition()
{return CharacteristicDefinition;}

void CharacteristicDefinitionsType::setCharacteristicDefinition(CharacteristicDefinitionBaseTypeLisd * CharacteristicDefinitionIn)
{CharacteristicDefinition = CharacteristicDefinitionIn;}

/* ***************************************************************** */

/* class CharacteristicDesignatorType

*/

CharacteristicDesignatorType::CharacteristicDesignatorType()
{
  Designator = 0;
  UUID = 0;
  Criticality = 0;
  Balloon = 0;
}

CharacteristicDesignatorType::CharacteristicDesignatorType(
 XmlToken * DesignatorIn,
 QPIdType * UUIDIn,
 CriticalityType * CriticalityIn,
 CharacteristicBalloonType * BalloonIn)
{
  Designator = DesignatorIn;
  UUID = UUIDIn;
  Criticality = CriticalityIn;
  Balloon = BalloonIn;
}

CharacteristicDesignatorType::~CharacteristicDesignatorType()
{
  #ifndef NODESTRUCT
  delete Designator;
  delete UUID;
  delete Criticality;
  delete Balloon;
  #endif
}

void CharacteristicDesignatorType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Designator");
  Designator->printSelf(outFile);
  fprintf(outFile, "</Designator>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (Criticality)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Criticality");
      Criticality->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Criticality>\n");
    }
  if (Balloon)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Balloon");
      Balloon->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Balloon>\n");
    }
  doSpaces(-INDENT, outFile);
}

XmlToken * CharacteristicDesignatorType::getDesignator()
{return Designator;}

void CharacteristicDesignatorType::setDesignator(XmlToken * DesignatorIn)
{Designator = DesignatorIn;}

QPIdType * CharacteristicDesignatorType::getUUID()
{return UUID;}

void CharacteristicDesignatorType::setUUID(QPIdType * UUIDIn)
{UUID = UUIDIn;}

CriticalityType * CharacteristicDesignatorType::getCriticality()
{return Criticality;}

void CharacteristicDesignatorType::setCriticality(CriticalityType * CriticalityIn)
{Criticality = CriticalityIn;}

CharacteristicBalloonType * CharacteristicDesignatorType::getBalloon()
{return Balloon;}

void CharacteristicDesignatorType::setBalloon(CharacteristicBalloonType * BalloonIn)
{Balloon = BalloonIn;}

/* ***************************************************************** */

/* class CharacteristicGroupStatusType

*/

CharacteristicGroupStatusType::CharacteristicGroupStatusType()
{
  Status = 0;
  GroupId = 0;
}

CharacteristicGroupStatusType::CharacteristicGroupStatusType(
 CharacteristicStatusType * StatusIn,
 QIFReferenceFullType * GroupIdIn)
{
  Status = StatusIn;
  GroupId = GroupIdIn;
}

CharacteristicGroupStatusType::~CharacteristicGroupStatusType()
{
  #ifndef NODESTRUCT
  delete Status;
  delete GroupId;
  #endif
}

void CharacteristicGroupStatusType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<GroupId");
  GroupId->printSelf(outFile);
  fprintf(outFile, "</GroupId>\n");
  doSpaces(-INDENT, outFile);
}

CharacteristicStatusType * CharacteristicGroupStatusType::getStatus()
{return Status;}

void CharacteristicGroupStatusType::setStatus(CharacteristicStatusType * StatusIn)
{Status = StatusIn;}

QIFReferenceFullType * CharacteristicGroupStatusType::getGroupId()
{return GroupId;}

void CharacteristicGroupStatusType::setGroupId(QIFReferenceFullType * GroupIdIn)
{GroupId = GroupIdIn;}

/* ***************************************************************** */

/* class CharacteristicGroupStatusTypeLisd

*/

CharacteristicGroupStatusTypeLisd::CharacteristicGroupStatusTypeLisd() {}

CharacteristicGroupStatusTypeLisd::CharacteristicGroupStatusTypeLisd(CharacteristicGroupStatusType * aCharacteristicGroupStatusType)
{
  push_back(aCharacteristicGroupStatusType);
}

CharacteristicGroupStatusTypeLisd::~CharacteristicGroupStatusTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<CharacteristicGroupStatusType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void CharacteristicGroupStatusTypeLisd::printSelf(FILE * outFile)
{
  std::list<CharacteristicGroupStatusType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class CharacteristicGroupStatusesType

*/

CharacteristicGroupStatusesType::CharacteristicGroupStatusesType()
{
  n = 0;
  CharacteristicGroupStatus = 0;
}

CharacteristicGroupStatusesType::CharacteristicGroupStatusesType(
 CharacteristicGroupStatusTypeLisd * CharacteristicGroupStatusIn)
{
  n = 0;
  CharacteristicGroupStatus = CharacteristicGroupStatusIn;
}

CharacteristicGroupStatusesType::CharacteristicGroupStatusesType(
 NaturalType * nIn,
 CharacteristicGroupStatusTypeLisd * CharacteristicGroupStatusIn)
{
  n = nIn;
  CharacteristicGroupStatus = CharacteristicGroupStatusIn;
}

CharacteristicGroupStatusesType::~CharacteristicGroupStatusesType()
{
  #ifndef NODESTRUCT
  delete n;
  delete CharacteristicGroupStatus;
  #endif
}

void CharacteristicGroupStatusesType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!CharacteristicGroupStatus)
      {
        fprintf(stderr, "CharacteristicGroupStatus list is missing\n");
        exit(1);
      }
    if (CharacteristicGroupStatus->size() == 0)
      {
        fprintf(stderr, "CharacteristicGroupStatus list is empty\n");
        exit(1);
      }
    if (CharacteristicGroupStatus->size() < 1)
      {
        fprintf(stderr,
                "size of CharacteristicGroupStatus list (%d) less than minimum required (1)\n",
                (int)CharacteristicGroupStatus->size());
        exit(1);
      }
    std::list<CharacteristicGroupStatusType *>::iterator iter;
    for (iter = CharacteristicGroupStatus->begin();
         iter != CharacteristicGroupStatus->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<CharacteristicGroupStatus");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</CharacteristicGroupStatus>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool CharacteristicGroupStatusesType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in CharacteristicGroupStatusesType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in CharacteristicGroupStatusesType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CharacteristicGroupStatusesType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in CharacteristicGroupStatusesType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * CharacteristicGroupStatusesType::getn()
{return n;}

void CharacteristicGroupStatusesType::setn(NaturalType * nIn)
{n = nIn;}

CharacteristicGroupStatusTypeLisd * CharacteristicGroupStatusesType::getCharacteristicGroupStatus()
{return CharacteristicGroupStatus;}

void CharacteristicGroupStatusesType::setCharacteristicGroupStatus(CharacteristicGroupStatusTypeLisd * CharacteristicGroupStatusIn)
{CharacteristicGroupStatus = CharacteristicGroupStatusIn;}

/* ***************************************************************** */

/* class CharacteristicGroupType

*/

CharacteristicGroupType::CharacteristicGroupType()
{
  id = 0;
  CharacteristicItemIds = 0;
  Description = 0;
  Name = 0;
  TransformId = 0;
  Units = 0;
  Scale = 0;
  Attributes = 0;
}

CharacteristicGroupType::CharacteristicGroupType(
 ArrayReferenceType * CharacteristicItemIdsIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 QIFReferenceType * TransformIdIn,
 OtherUnitsType * UnitsIn,
 ScaleType * ScaleIn,
 AttributesType * AttributesIn)
{
  id = 0;
  CharacteristicItemIds = CharacteristicItemIdsIn;
  Description = DescriptionIn;
  Name = NameIn;
  TransformId = TransformIdIn;
  Units = UnitsIn;
  Scale = ScaleIn;
  Attributes = AttributesIn;
}

CharacteristicGroupType::CharacteristicGroupType(
 QIFIdType * idIn,
 ArrayReferenceType * CharacteristicItemIdsIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 QIFReferenceType * TransformIdIn,
 OtherUnitsType * UnitsIn,
 ScaleType * ScaleIn,
 AttributesType * AttributesIn)
{
  id = idIn;
  CharacteristicItemIds = CharacteristicItemIdsIn;
  Description = DescriptionIn;
  Name = NameIn;
  TransformId = TransformIdIn;
  Units = UnitsIn;
  Scale = ScaleIn;
  Attributes = AttributesIn;
}

CharacteristicGroupType::~CharacteristicGroupType()
{
  #ifndef NODESTRUCT
  delete id;
  delete CharacteristicItemIds;
  delete Description;
  delete Name;
  delete TransformId;
  delete Units;
  delete Scale;
  delete Attributes;
  #endif
}

void CharacteristicGroupType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemIds");
  CharacteristicItemIds->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</CharacteristicItemIds>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (TransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TransformId");
      TransformId->printSelf(outFile);
      fprintf(outFile, "</TransformId>\n");
    }
  if (Units)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Units");
      Units->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Units>\n");
    }
  if (Scale)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Scale");
      Scale->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Scale>\n");
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CharacteristicGroupType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CharacteristicGroupType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CharacteristicGroupType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CharacteristicGroupType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CharacteristicGroupType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

QIFIdType * CharacteristicGroupType::getid()
{return id;}

void CharacteristicGroupType::setid(QIFIdType * idIn)
{id = idIn;}

ArrayReferenceType * CharacteristicGroupType::getCharacteristicItemIds()
{return CharacteristicItemIds;}

void CharacteristicGroupType::setCharacteristicItemIds(ArrayReferenceType * CharacteristicItemIdsIn)
{CharacteristicItemIds = CharacteristicItemIdsIn;}

XmlString * CharacteristicGroupType::getDescription()
{return Description;}

void CharacteristicGroupType::setDescription(XmlString * DescriptionIn)
{Description = DescriptionIn;}

XmlToken * CharacteristicGroupType::getName()
{return Name;}

void CharacteristicGroupType::setName(XmlToken * NameIn)
{Name = NameIn;}

QIFReferenceType * CharacteristicGroupType::getTransformId()
{return TransformId;}

void CharacteristicGroupType::setTransformId(QIFReferenceType * TransformIdIn)
{TransformId = TransformIdIn;}

OtherUnitsType * CharacteristicGroupType::getUnits()
{return Units;}

void CharacteristicGroupType::setUnits(OtherUnitsType * UnitsIn)
{Units = UnitsIn;}

ScaleType * CharacteristicGroupType::getScale()
{return Scale;}

void CharacteristicGroupType::setScale(ScaleType * ScaleIn)
{Scale = ScaleIn;}

AttributesType * CharacteristicGroupType::getAttributes()
{return Attributes;}

void CharacteristicGroupType::setAttributes(AttributesType * AttributesIn)
{Attributes = AttributesIn;}

/* ***************************************************************** */

/* class CharacteristicGroupTypeLisd

*/

CharacteristicGroupTypeLisd::CharacteristicGroupTypeLisd() {}

CharacteristicGroupTypeLisd::CharacteristicGroupTypeLisd(CharacteristicGroupType * aCharacteristicGroupType)
{
  push_back(aCharacteristicGroupType);
}

CharacteristicGroupTypeLisd::~CharacteristicGroupTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<CharacteristicGroupType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void CharacteristicGroupTypeLisd::printSelf(FILE * outFile)
{
  std::list<CharacteristicGroupType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class CharacteristicGroupsType

*/

CharacteristicGroupsType::CharacteristicGroupsType()
{
  n = 0;
  CharacteristicGroup = 0;
}

CharacteristicGroupsType::CharacteristicGroupsType(
 CharacteristicGroupTypeLisd * CharacteristicGroupIn)
{
  n = 0;
  CharacteristicGroup = CharacteristicGroupIn;
}

CharacteristicGroupsType::CharacteristicGroupsType(
 NaturalType * nIn,
 CharacteristicGroupTypeLisd * CharacteristicGroupIn)
{
  n = nIn;
  CharacteristicGroup = CharacteristicGroupIn;
}

CharacteristicGroupsType::~CharacteristicGroupsType()
{
  #ifndef NODESTRUCT
  delete n;
  delete CharacteristicGroup;
  #endif
}

void CharacteristicGroupsType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!CharacteristicGroup)
      {
        fprintf(stderr, "CharacteristicGroup list is missing\n");
        exit(1);
      }
    if (CharacteristicGroup->size() == 0)
      {
        fprintf(stderr, "CharacteristicGroup list is empty\n");
        exit(1);
      }
    if (CharacteristicGroup->size() < 1)
      {
        fprintf(stderr,
                "size of CharacteristicGroup list (%d) less than minimum required (1)\n",
                (int)CharacteristicGroup->size());
        exit(1);
      }
    std::list<CharacteristicGroupType *>::iterator iter;
    for (iter = CharacteristicGroup->begin();
         iter != CharacteristicGroup->end(); iter++)
      {
        CharacteristicGroupType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->getprintElement(), "CharacteristicManufacturingProcessGroup") == 0)
          {
            CharacteristicManufacturingProcessGroupType * typ;
            if ((typ = dynamic_cast<CharacteristicManufacturingProcessGroupType *>(basie)))
              {
                fprintf(outFile, "<CharacteristicManufacturingProcessGroup");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CharacteristicManufacturingProcessGroup>\n");
              }
            else
              {
                fprintf(stderr, "bad CharacteristicManufacturingProcessGroup element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CharacteristicGroup") == 0)
          {
            CharacteristicGroupType * typ;
            if ((typ = dynamic_cast<CharacteristicGroupType *>(basie)))
              {
                fprintf(outFile, "<CharacteristicGroup");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CharacteristicGroup>\n");
              }
            else
              {
                fprintf(stderr, "bad CharacteristicGroup element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad CharacteristicGroup type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool CharacteristicGroupsType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in CharacteristicGroupsType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in CharacteristicGroupsType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CharacteristicGroupsType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in CharacteristicGroupsType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * CharacteristicGroupsType::getn()
{return n;}

void CharacteristicGroupsType::setn(NaturalType * nIn)
{n = nIn;}

CharacteristicGroupTypeLisd * CharacteristicGroupsType::getCharacteristicGroup()
{return CharacteristicGroup;}

void CharacteristicGroupsType::setCharacteristicGroup(CharacteristicGroupTypeLisd * CharacteristicGroupIn)
{CharacteristicGroup = CharacteristicGroupIn;}

/* ***************************************************************** */

/* class CharacteristicItemBaseType

*/

CharacteristicItemBaseType::CharacteristicItemBaseType() :
  CharacteristicBaseType()
{
  Name = 0;
  CharacteristicDesignator = 0;
  FeatureItemIds = 0;
  SubstituteFeatureAlgorithm = 0;
  NotableEventIds = 0;
  MeasurementDeviceIds = 0;
  CharacteristicNominalId = 0;
  LocationOnDrawing = 0;
  VirtualMeasurement = 0;
}

CharacteristicItemBaseType::CharacteristicItemBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  CharacteristicBaseType(
    AttributesIn,
    DescriptionIn)
{
  Name = NameIn;
  CharacteristicDesignator = CharacteristicDesignatorIn;
  FeatureItemIds = FeatureItemIdsIn;
  SubstituteFeatureAlgorithm = SubstituteFeatureAlgorithmIn;
  NotableEventIds = NotableEventIdsIn;
  MeasurementDeviceIds = MeasurementDeviceIdsIn;
  CharacteristicNominalId = CharacteristicNominalIdIn;
  LocationOnDrawing = LocationOnDrawingIn;
  VirtualMeasurement = VirtualMeasurementIn;
}

CharacteristicItemBaseType::CharacteristicItemBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  CharacteristicBaseType(
    idIn,
    AttributesIn,
    DescriptionIn)
{
  Name = NameIn;
  CharacteristicDesignator = CharacteristicDesignatorIn;
  FeatureItemIds = FeatureItemIdsIn;
  SubstituteFeatureAlgorithm = SubstituteFeatureAlgorithmIn;
  NotableEventIds = NotableEventIdsIn;
  MeasurementDeviceIds = MeasurementDeviceIdsIn;
  CharacteristicNominalId = CharacteristicNominalIdIn;
  LocationOnDrawing = LocationOnDrawingIn;
  VirtualMeasurement = VirtualMeasurementIn;
}

CharacteristicItemBaseType::~CharacteristicItemBaseType()
{
  #ifndef NODESTRUCT
  delete Name;
  delete CharacteristicDesignator;
  delete FeatureItemIds;
  delete SubstituteFeatureAlgorithm;
  delete NotableEventIds;
  delete MeasurementDeviceIds;
  delete CharacteristicNominalId;
  delete LocationOnDrawing;
  delete VirtualMeasurement;
  #endif
}

void CharacteristicItemBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool CharacteristicItemBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CharacteristicItemBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CharacteristicItemBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CharacteristicItemBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CharacteristicItemBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

XmlToken * CharacteristicItemBaseType::getName()
{return Name;}

void CharacteristicItemBaseType::setName(XmlToken * NameIn)
{Name = NameIn;}

CharacteristicDesignatorType * CharacteristicItemBaseType::getCharacteristicDesignator()
{return CharacteristicDesignator;}

void CharacteristicItemBaseType::setCharacteristicDesignator(CharacteristicDesignatorType * CharacteristicDesignatorIn)
{CharacteristicDesignator = CharacteristicDesignatorIn;}

ArrayReferenceType * CharacteristicItemBaseType::getFeatureItemIds()
{return FeatureItemIds;}

void CharacteristicItemBaseType::setFeatureItemIds(ArrayReferenceType * FeatureItemIdsIn)
{FeatureItemIds = FeatureItemIdsIn;}

SubstituteFeatureAlgorithmType * CharacteristicItemBaseType::getSubstituteFeatureAlgorithm()
{return SubstituteFeatureAlgorithm;}

void CharacteristicItemBaseType::setSubstituteFeatureAlgorithm(SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn)
{SubstituteFeatureAlgorithm = SubstituteFeatureAlgorithmIn;}

ArrayReferenceType * CharacteristicItemBaseType::getNotableEventIds()
{return NotableEventIds;}

void CharacteristicItemBaseType::setNotableEventIds(ArrayReferenceType * NotableEventIdsIn)
{NotableEventIds = NotableEventIdsIn;}

ArrayReferenceType * CharacteristicItemBaseType::getMeasurementDeviceIds()
{return MeasurementDeviceIds;}

void CharacteristicItemBaseType::setMeasurementDeviceIds(ArrayReferenceType * MeasurementDeviceIdsIn)
{MeasurementDeviceIds = MeasurementDeviceIdsIn;}

QIFReferenceFullType * CharacteristicItemBaseType::getCharacteristicNominalId()
{return CharacteristicNominalId;}

void CharacteristicItemBaseType::setCharacteristicNominalId(QIFReferenceFullType * CharacteristicNominalIdIn)
{CharacteristicNominalId = CharacteristicNominalIdIn;}

LocationOnDrawingType * CharacteristicItemBaseType::getLocationOnDrawing()
{return LocationOnDrawing;}

void CharacteristicItemBaseType::setLocationOnDrawing(LocationOnDrawingType * LocationOnDrawingIn)
{LocationOnDrawing = LocationOnDrawingIn;}

VirtualMeasurementType * CharacteristicItemBaseType::getVirtualMeasurement()
{return VirtualMeasurement;}

void CharacteristicItemBaseType::setVirtualMeasurement(VirtualMeasurementType * VirtualMeasurementIn)
{VirtualMeasurement = VirtualMeasurementIn;}

/* ***************************************************************** */

/* class CharacteristicItemBaseTypeLisd

*/

CharacteristicItemBaseTypeLisd::CharacteristicItemBaseTypeLisd() {}

CharacteristicItemBaseTypeLisd::CharacteristicItemBaseTypeLisd(CharacteristicItemBaseType * aCharacteristicItemBaseType)
{
  push_back(aCharacteristicItemBaseType);
}

CharacteristicItemBaseTypeLisd::~CharacteristicItemBaseTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<CharacteristicItemBaseType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void CharacteristicItemBaseTypeLisd::printSelf(FILE * outFile)
{
  std::list<CharacteristicItemBaseType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class CharacteristicItemsType

*/

CharacteristicItemsType::CharacteristicItemsType()
{
  n = 0;
  CharacteristicItem = 0;
}

CharacteristicItemsType::CharacteristicItemsType(
 CharacteristicItemBaseTypeLisd * CharacteristicItemIn)
{
  n = 0;
  CharacteristicItem = CharacteristicItemIn;
}

CharacteristicItemsType::CharacteristicItemsType(
 NaturalType * nIn,
 CharacteristicItemBaseTypeLisd * CharacteristicItemIn)
{
  n = nIn;
  CharacteristicItem = CharacteristicItemIn;
}

CharacteristicItemsType::~CharacteristicItemsType()
{
  #ifndef NODESTRUCT
  delete n;
  delete CharacteristicItem;
  #endif
}

void CharacteristicItemsType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!CharacteristicItem)
      {
        fprintf(stderr, "CharacteristicItem list is missing\n");
        exit(1);
      }
    if (CharacteristicItem->size() == 0)
      {
        fprintf(stderr, "CharacteristicItem list is empty\n");
        exit(1);
      }
    if (CharacteristicItem->size() < 1)
      {
        fprintf(stderr,
                "size of CharacteristicItem list (%d) less than minimum required (1)\n",
                (int)CharacteristicItem->size());
        exit(1);
      }
    std::list<CharacteristicItemBaseType *>::iterator iter;
    for (iter = CharacteristicItem->begin();
         iter != CharacteristicItem->end(); iter++)
      {
        CharacteristicItemBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->getprintElement(), "AngleBetweenCharacteristicItem") == 0)
          {
            AngleBetweenCharacteristicItemType * typ;
            if ((typ = dynamic_cast<AngleBetweenCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<AngleBetweenCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AngleBetweenCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad AngleBetweenCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "AngleCharacteristicItem") == 0)
          {
            AngleCharacteristicItemType * typ;
            if ((typ = dynamic_cast<AngleCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<AngleCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AngleCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad AngleCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "AngularCoordinateCharacteristicItem") == 0)
          {
            AngularCoordinateCharacteristicItemType * typ;
            if ((typ = dynamic_cast<AngularCoordinateCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<AngularCoordinateCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AngularCoordinateCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad AngularCoordinateCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "AngleFromCharacteristicItem") == 0)
          {
            AngleFromCharacteristicItemType * typ;
            if ((typ = dynamic_cast<AngleFromCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<AngleFromCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AngleFromCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad AngleFromCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "AngularityCharacteristicItem") == 0)
          {
            AngularityCharacteristicItemType * typ;
            if ((typ = dynamic_cast<AngularityCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<AngularityCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AngularityCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad AngularityCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ChordCharacteristicItem") == 0)
          {
            ChordCharacteristicItemType * typ;
            if ((typ = dynamic_cast<ChordCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<ChordCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ChordCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad ChordCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CircularityCharacteristicItem") == 0)
          {
            CircularityCharacteristicItemType * typ;
            if ((typ = dynamic_cast<CircularityCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<CircularityCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CircularityCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad CircularityCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CircularRunoutCharacteristicItem") == 0)
          {
            CircularRunoutCharacteristicItemType * typ;
            if ((typ = dynamic_cast<CircularRunoutCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<CircularRunoutCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CircularRunoutCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad CircularRunoutCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CoaxialityCharacteristicItem") == 0)
          {
            CoaxialityCharacteristicItemType * typ;
            if ((typ = dynamic_cast<CoaxialityCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<CoaxialityCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CoaxialityCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad CoaxialityCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ConcentricityCharacteristicItem") == 0)
          {
            ConcentricityCharacteristicItemType * typ;
            if ((typ = dynamic_cast<ConcentricityCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<ConcentricityCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ConcentricityCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad ConcentricityCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ConicalTaperCharacteristicItem") == 0)
          {
            ConicalTaperCharacteristicItemType * typ;
            if ((typ = dynamic_cast<ConicalTaperCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<ConicalTaperCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ConicalTaperCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad ConicalTaperCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ConicityCharacteristicItem") == 0)
          {
            ConicityCharacteristicItemType * typ;
            if ((typ = dynamic_cast<ConicityCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<ConicityCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ConicityCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad ConicityCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CurveLengthCharacteristicItem") == 0)
          {
            CurveLengthCharacteristicItemType * typ;
            if ((typ = dynamic_cast<CurveLengthCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<CurveLengthCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CurveLengthCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad CurveLengthCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CylindricityCharacteristicItem") == 0)
          {
            CylindricityCharacteristicItemType * typ;
            if ((typ = dynamic_cast<CylindricityCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<CylindricityCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CylindricityCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad CylindricityCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "DepthCharacteristicItem") == 0)
          {
            DepthCharacteristicItemType * typ;
            if ((typ = dynamic_cast<DepthCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<DepthCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</DepthCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad DepthCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "DiameterCharacteristicItem") == 0)
          {
            DiameterCharacteristicItemType * typ;
            if ((typ = dynamic_cast<DiameterCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<DiameterCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</DiameterCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad DiameterCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "DistanceBetweenCharacteristicItem") == 0)
          {
            DistanceBetweenCharacteristicItemType * typ;
            if ((typ = dynamic_cast<DistanceBetweenCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<DistanceBetweenCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</DistanceBetweenCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad DistanceBetweenCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "DistanceFromCharacteristicItem") == 0)
          {
            DistanceFromCharacteristicItemType * typ;
            if ((typ = dynamic_cast<DistanceFromCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<DistanceFromCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</DistanceFromCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad DistanceFromCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "EllipticityCharacteristicItem") == 0)
          {
            EllipticityCharacteristicItemType * typ;
            if ((typ = dynamic_cast<EllipticityCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<EllipticityCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EllipticityCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad EllipticityCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "FlatTaperCharacteristicItem") == 0)
          {
            FlatTaperCharacteristicItemType * typ;
            if ((typ = dynamic_cast<FlatTaperCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<FlatTaperCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</FlatTaperCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad FlatTaperCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "FlatnessCharacteristicItem") == 0)
          {
            FlatnessCharacteristicItemType * typ;
            if ((typ = dynamic_cast<FlatnessCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<FlatnessCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</FlatnessCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad FlatnessCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "HeightCharacteristicItem") == 0)
          {
            HeightCharacteristicItemType * typ;
            if ((typ = dynamic_cast<HeightCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<HeightCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</HeightCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad HeightCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "LengthCharacteristicItem") == 0)
          {
            LengthCharacteristicItemType * typ;
            if ((typ = dynamic_cast<LengthCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<LengthCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LengthCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad LengthCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "LinearCoordinateCharacteristicItem") == 0)
          {
            LinearCoordinateCharacteristicItemType * typ;
            if ((typ = dynamic_cast<LinearCoordinateCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<LinearCoordinateCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LinearCoordinateCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad LinearCoordinateCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "LineProfileCharacteristicItem") == 0)
          {
            LineProfileCharacteristicItemType * typ;
            if ((typ = dynamic_cast<LineProfileCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<LineProfileCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LineProfileCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad LineProfileCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OtherFormCharacteristicItem") == 0)
          {
            OtherFormCharacteristicItemType * typ;
            if ((typ = dynamic_cast<OtherFormCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<OtherFormCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OtherFormCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad OtherFormCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ParallelismCharacteristicItem") == 0)
          {
            ParallelismCharacteristicItemType * typ;
            if ((typ = dynamic_cast<ParallelismCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<ParallelismCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ParallelismCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad ParallelismCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PerpendicularityCharacteristicItem") == 0)
          {
            PerpendicularityCharacteristicItemType * typ;
            if ((typ = dynamic_cast<PerpendicularityCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<PerpendicularityCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PerpendicularityCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad PerpendicularityCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PointProfileCharacteristicItem") == 0)
          {
            PointProfileCharacteristicItemType * typ;
            if ((typ = dynamic_cast<PointProfileCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<PointProfileCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PointProfileCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad PointProfileCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PositionCharacteristicItem") == 0)
          {
            PositionCharacteristicItemType * typ;
            if ((typ = dynamic_cast<PositionCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<PositionCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PositionCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad PositionCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "RadiusCharacteristicItem") == 0)
          {
            RadiusCharacteristicItemType * typ;
            if ((typ = dynamic_cast<RadiusCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<RadiusCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RadiusCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad RadiusCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SphericalDiameterCharacteristicItem") == 0)
          {
            SphericalDiameterCharacteristicItemType * typ;
            if ((typ = dynamic_cast<SphericalDiameterCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<SphericalDiameterCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalDiameterCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalDiameterCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SphericalRadiusCharacteristicItem") == 0)
          {
            SphericalRadiusCharacteristicItemType * typ;
            if ((typ = dynamic_cast<SphericalRadiusCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<SphericalRadiusCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalRadiusCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalRadiusCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SphericityCharacteristicItem") == 0)
          {
            SphericityCharacteristicItemType * typ;
            if ((typ = dynamic_cast<SphericityCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<SphericityCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericityCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericityCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SquareCharacteristicItem") == 0)
          {
            SquareCharacteristicItemType * typ;
            if ((typ = dynamic_cast<SquareCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<SquareCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SquareCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad SquareCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "StraightnessCharacteristicItem") == 0)
          {
            StraightnessCharacteristicItemType * typ;
            if ((typ = dynamic_cast<StraightnessCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<StraightnessCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</StraightnessCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad StraightnessCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SurfaceProfileCharacteristicItem") == 0)
          {
            SurfaceProfileCharacteristicItemType * typ;
            if ((typ = dynamic_cast<SurfaceProfileCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<SurfaceProfileCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SurfaceProfileCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad SurfaceProfileCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SurfaceProfileNonUniformCharacteristicItem") == 0)
          {
            SurfaceProfileNonUniformCharacteristicItemType * typ;
            if ((typ = dynamic_cast<SurfaceProfileNonUniformCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<SurfaceProfileNonUniformCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SurfaceProfileNonUniformCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad SurfaceProfileNonUniformCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SurfaceTextureCharacteristicItem") == 0)
          {
            SurfaceTextureCharacteristicItemType * typ;
            if ((typ = dynamic_cast<SurfaceTextureCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<SurfaceTextureCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SurfaceTextureCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad SurfaceTextureCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SymmetryCharacteristicItem") == 0)
          {
            SymmetryCharacteristicItemType * typ;
            if ((typ = dynamic_cast<SymmetryCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<SymmetryCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SymmetryCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad SymmetryCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ThicknessCharacteristicItem") == 0)
          {
            ThicknessCharacteristicItemType * typ;
            if ((typ = dynamic_cast<ThicknessCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<ThicknessCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ThicknessCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad ThicknessCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ThreadCharacteristicItem") == 0)
          {
            ThreadCharacteristicItemType * typ;
            if ((typ = dynamic_cast<ThreadCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<ThreadCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ThreadCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad ThreadCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ToroidicityCharacteristicItem") == 0)
          {
            ToroidicityCharacteristicItemType * typ;
            if ((typ = dynamic_cast<ToroidicityCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<ToroidicityCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ToroidicityCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad ToroidicityCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "TotalRunoutCharacteristicItem") == 0)
          {
            TotalRunoutCharacteristicItemType * typ;
            if ((typ = dynamic_cast<TotalRunoutCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<TotalRunoutCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalRunoutCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalRunoutCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedAttributeCharacteristicItem") == 0)
          {
            UserDefinedAttributeCharacteristicItemType * typ;
            if ((typ = dynamic_cast<UserDefinedAttributeCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedAttributeCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedAttributeCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedAttributeCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedLinearCharacteristicItem") == 0)
          {
            UserDefinedLinearCharacteristicItemType * typ;
            if ((typ = dynamic_cast<UserDefinedLinearCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedLinearCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedLinearCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedLinearCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedAngularCharacteristicItem") == 0)
          {
            UserDefinedAngularCharacteristicItemType * typ;
            if ((typ = dynamic_cast<UserDefinedAngularCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedAngularCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedAngularCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedAngularCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedTemperatureCharacteristicItem") == 0)
          {
            UserDefinedTemperatureCharacteristicItemType * typ;
            if ((typ = dynamic_cast<UserDefinedTemperatureCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedTemperatureCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedTemperatureCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedTemperatureCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedAreaCharacteristicItem") == 0)
          {
            UserDefinedAreaCharacteristicItemType * typ;
            if ((typ = dynamic_cast<UserDefinedAreaCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedAreaCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedAreaCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedAreaCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedForceCharacteristicItem") == 0)
          {
            UserDefinedForceCharacteristicItemType * typ;
            if ((typ = dynamic_cast<UserDefinedForceCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedForceCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedForceCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedForceCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedMassCharacteristicItem") == 0)
          {
            UserDefinedMassCharacteristicItemType * typ;
            if ((typ = dynamic_cast<UserDefinedMassCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedMassCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedMassCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedMassCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedPressureCharacteristicItem") == 0)
          {
            UserDefinedPressureCharacteristicItemType * typ;
            if ((typ = dynamic_cast<UserDefinedPressureCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedPressureCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedPressureCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedPressureCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedSpeedCharacteristicItem") == 0)
          {
            UserDefinedSpeedCharacteristicItemType * typ;
            if ((typ = dynamic_cast<UserDefinedSpeedCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedSpeedCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedSpeedCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedSpeedCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedTimeCharacteristicItem") == 0)
          {
            UserDefinedTimeCharacteristicItemType * typ;
            if ((typ = dynamic_cast<UserDefinedTimeCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedTimeCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedTimeCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedTimeCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedUnitCharacteristicItem") == 0)
          {
            UserDefinedUnitCharacteristicItemType * typ;
            if ((typ = dynamic_cast<UserDefinedUnitCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedUnitCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedUnitCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedUnitCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WidthCharacteristicItem") == 0)
          {
            WidthCharacteristicItemType * typ;
            if ((typ = dynamic_cast<WidthCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<WidthCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WidthCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad WidthCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldFilletCharacteristicItem") == 0)
          {
            WeldFilletCharacteristicItemType * typ;
            if ((typ = dynamic_cast<WeldFilletCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<WeldFilletCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldFilletCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldFilletCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldPlugCharacteristicItem") == 0)
          {
            WeldPlugCharacteristicItemType * typ;
            if ((typ = dynamic_cast<WeldPlugCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<WeldPlugCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldPlugCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldPlugCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldSlotCharacteristicItem") == 0)
          {
            WeldSlotCharacteristicItemType * typ;
            if ((typ = dynamic_cast<WeldSlotCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<WeldSlotCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldSlotCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldSlotCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldSpotCharacteristicItem") == 0)
          {
            WeldSpotCharacteristicItemType * typ;
            if ((typ = dynamic_cast<WeldSpotCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<WeldSpotCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldSpotCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldSpotCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldStudCharacteristicItem") == 0)
          {
            WeldStudCharacteristicItemType * typ;
            if ((typ = dynamic_cast<WeldStudCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<WeldStudCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldStudCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldStudCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldSeamCharacteristicItem") == 0)
          {
            WeldSeamCharacteristicItemType * typ;
            if ((typ = dynamic_cast<WeldSeamCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<WeldSeamCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldSeamCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldSeamCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldSurfacingCharacteristicItem") == 0)
          {
            WeldSurfacingCharacteristicItemType * typ;
            if ((typ = dynamic_cast<WeldSurfacingCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<WeldSurfacingCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldSurfacingCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldSurfacingCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldEdgeCharacteristicItem") == 0)
          {
            WeldEdgeCharacteristicItemType * typ;
            if ((typ = dynamic_cast<WeldEdgeCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<WeldEdgeCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldEdgeCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldEdgeCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldSquareCharacteristicItem") == 0)
          {
            WeldSquareCharacteristicItemType * typ;
            if ((typ = dynamic_cast<WeldSquareCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<WeldSquareCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldSquareCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldSquareCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldBevelCharacteristicItem") == 0)
          {
            WeldBevelCharacteristicItemType * typ;
            if ((typ = dynamic_cast<WeldBevelCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<WeldBevelCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldBevelCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldBevelCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldVCharacteristicItem") == 0)
          {
            WeldVCharacteristicItemType * typ;
            if ((typ = dynamic_cast<WeldVCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<WeldVCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldVCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldVCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldUCharacteristicItem") == 0)
          {
            WeldUCharacteristicItemType * typ;
            if ((typ = dynamic_cast<WeldUCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<WeldUCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldUCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldUCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldJCharacteristicItem") == 0)
          {
            WeldJCharacteristicItemType * typ;
            if ((typ = dynamic_cast<WeldJCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<WeldJCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldJCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldJCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldFlareVCharacteristicItem") == 0)
          {
            WeldFlareVCharacteristicItemType * typ;
            if ((typ = dynamic_cast<WeldFlareVCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<WeldFlareVCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldFlareVCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldFlareVCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldFlareBevelCharacteristicItem") == 0)
          {
            WeldFlareBevelCharacteristicItemType * typ;
            if ((typ = dynamic_cast<WeldFlareBevelCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<WeldFlareBevelCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldFlareBevelCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldFlareBevelCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldScarfCharacteristicItem") == 0)
          {
            WeldScarfCharacteristicItemType * typ;
            if ((typ = dynamic_cast<WeldScarfCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<WeldScarfCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldScarfCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldScarfCharacteristicItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldCompoundCharacteristicItem") == 0)
          {
            WeldCompoundCharacteristicItemType * typ;
            if ((typ = dynamic_cast<WeldCompoundCharacteristicItemType *>(basie)))
              {
                fprintf(outFile, "<WeldCompoundCharacteristicItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldCompoundCharacteristicItem>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldCompoundCharacteristicItem element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad CharacteristicItem type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool CharacteristicItemsType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in CharacteristicItemsType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in CharacteristicItemsType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CharacteristicItemsType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in CharacteristicItemsType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * CharacteristicItemsType::getn()
{return n;}

void CharacteristicItemsType::setn(NaturalType * nIn)
{n = nIn;}

CharacteristicItemBaseTypeLisd * CharacteristicItemsType::getCharacteristicItem()
{return CharacteristicItem;}

void CharacteristicItemsType::setCharacteristicItem(CharacteristicItemBaseTypeLisd * CharacteristicItemIn)
{CharacteristicItem = CharacteristicItemIn;}

/* ***************************************************************** */

/* class CharacteristicManufacturingProcessGroupType

*/

CharacteristicManufacturingProcessGroupType::CharacteristicManufacturingProcessGroupType() :
  CharacteristicGroupType()
{
  ManufacturingProcessId = 0;
}

CharacteristicManufacturingProcessGroupType::CharacteristicManufacturingProcessGroupType(
 ArrayReferenceType * CharacteristicItemIdsIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 QIFReferenceType * TransformIdIn,
 OtherUnitsType * UnitsIn,
 ScaleType * ScaleIn,
 AttributesType * AttributesIn,
 QIFReferenceType * ManufacturingProcessIdIn) :
  CharacteristicGroupType(
    CharacteristicItemIdsIn,
    DescriptionIn,
    NameIn,
    TransformIdIn,
    UnitsIn,
    ScaleIn,
    AttributesIn)
{
  ManufacturingProcessId = ManufacturingProcessIdIn;
}

CharacteristicManufacturingProcessGroupType::CharacteristicManufacturingProcessGroupType(
 QIFIdType * idIn,
 ArrayReferenceType * CharacteristicItemIdsIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 QIFReferenceType * TransformIdIn,
 OtherUnitsType * UnitsIn,
 ScaleType * ScaleIn,
 AttributesType * AttributesIn,
 QIFReferenceType * ManufacturingProcessIdIn) :
  CharacteristicGroupType(
    idIn,
    CharacteristicItemIdsIn,
    DescriptionIn,
    NameIn,
    TransformIdIn,
    UnitsIn,
    ScaleIn,
    AttributesIn)
{
  ManufacturingProcessId = ManufacturingProcessIdIn;
}

CharacteristicManufacturingProcessGroupType::~CharacteristicManufacturingProcessGroupType()
{
  #ifndef NODESTRUCT
  delete ManufacturingProcessId;
  #endif
}

void CharacteristicManufacturingProcessGroupType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemIds");
  CharacteristicItemIds->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</CharacteristicItemIds>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (TransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TransformId");
      TransformId->printSelf(outFile);
      fprintf(outFile, "</TransformId>\n");
    }
  if (Units)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Units");
      Units->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Units>\n");
    }
  if (Scale)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Scale");
      Scale->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Scale>\n");
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CharacteristicManufacturingProcessGroupType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CharacteristicManufacturingProcessGroupType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CharacteristicManufacturingProcessGroupType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CharacteristicManufacturingProcessGroupType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CharacteristicManufacturingProcessGroupType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

QIFReferenceType * CharacteristicManufacturingProcessGroupType::getManufacturingProcessId()
{return ManufacturingProcessId;}

void CharacteristicManufacturingProcessGroupType::setManufacturingProcessId(QIFReferenceType * ManufacturingProcessIdIn)
{ManufacturingProcessId = ManufacturingProcessIdIn;}

/* ***************************************************************** */

/* class CharacteristicMeasurementBaseType

*/

CharacteristicMeasurementBaseType::CharacteristicMeasurementBaseType() :
  CharacteristicBaseType()
{
  Status = 0;
  CharacteristicItemId = 0;
  TimeStamp = 0;
  FeatureMeasurementIds = 0;
  SubstituteFeatureAlgorithm = 0;
  ActualComponentId = 0;
  MeasurementDeviceIds = 0;
  ManufacturingProcessId = 0;
  NotedEventIds = 0;
  NonConformanceDesignator = 0;
}

CharacteristicMeasurementBaseType::CharacteristicMeasurementBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn) :
  CharacteristicBaseType(
    AttributesIn,
    DescriptionIn)
{
  Status = StatusIn;
  CharacteristicItemId = CharacteristicItemIdIn;
  TimeStamp = TimeStampIn;
  FeatureMeasurementIds = FeatureMeasurementIdsIn;
  SubstituteFeatureAlgorithm = SubstituteFeatureAlgorithmIn;
  ActualComponentId = ActualComponentIdIn;
  MeasurementDeviceIds = MeasurementDeviceIdsIn;
  ManufacturingProcessId = ManufacturingProcessIdIn;
  NotedEventIds = NotedEventIdsIn;
  NonConformanceDesignator = NonConformanceDesignatorIn;
}

CharacteristicMeasurementBaseType::CharacteristicMeasurementBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn) :
  CharacteristicBaseType(
    idIn,
    AttributesIn,
    DescriptionIn)
{
  Status = StatusIn;
  CharacteristicItemId = CharacteristicItemIdIn;
  TimeStamp = TimeStampIn;
  FeatureMeasurementIds = FeatureMeasurementIdsIn;
  SubstituteFeatureAlgorithm = SubstituteFeatureAlgorithmIn;
  ActualComponentId = ActualComponentIdIn;
  MeasurementDeviceIds = MeasurementDeviceIdsIn;
  ManufacturingProcessId = ManufacturingProcessIdIn;
  NotedEventIds = NotedEventIdsIn;
  NonConformanceDesignator = NonConformanceDesignatorIn;
}

CharacteristicMeasurementBaseType::~CharacteristicMeasurementBaseType()
{
  #ifndef NODESTRUCT
  delete Status;
  delete CharacteristicItemId;
  delete TimeStamp;
  delete FeatureMeasurementIds;
  delete SubstituteFeatureAlgorithm;
  delete ActualComponentId;
  delete MeasurementDeviceIds;
  delete ManufacturingProcessId;
  delete NotedEventIds;
  delete NonConformanceDesignator;
  #endif
}

void CharacteristicMeasurementBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CharacteristicMeasurementBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CharacteristicMeasurementBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CharacteristicMeasurementBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CharacteristicMeasurementBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CharacteristicMeasurementBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

CharacteristicStatusType * CharacteristicMeasurementBaseType::getStatus()
{return Status;}

void CharacteristicMeasurementBaseType::setStatus(CharacteristicStatusType * StatusIn)
{Status = StatusIn;}

QIFReferenceType * CharacteristicMeasurementBaseType::getCharacteristicItemId()
{return CharacteristicItemId;}

void CharacteristicMeasurementBaseType::setCharacteristicItemId(QIFReferenceType * CharacteristicItemIdIn)
{CharacteristicItemId = CharacteristicItemIdIn;}

XmlDateTime * CharacteristicMeasurementBaseType::getTimeStamp()
{return TimeStamp;}

void CharacteristicMeasurementBaseType::setTimeStamp(XmlDateTime * TimeStampIn)
{TimeStamp = TimeStampIn;}

ArrayReferenceType * CharacteristicMeasurementBaseType::getFeatureMeasurementIds()
{return FeatureMeasurementIds;}

void CharacteristicMeasurementBaseType::setFeatureMeasurementIds(ArrayReferenceType * FeatureMeasurementIdsIn)
{FeatureMeasurementIds = FeatureMeasurementIdsIn;}

SubstituteFeatureAlgorithmType * CharacteristicMeasurementBaseType::getSubstituteFeatureAlgorithm()
{return SubstituteFeatureAlgorithm;}

void CharacteristicMeasurementBaseType::setSubstituteFeatureAlgorithm(SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn)
{SubstituteFeatureAlgorithm = SubstituteFeatureAlgorithmIn;}

QIFReferenceType * CharacteristicMeasurementBaseType::getActualComponentId()
{return ActualComponentId;}

void CharacteristicMeasurementBaseType::setActualComponentId(QIFReferenceType * ActualComponentIdIn)
{ActualComponentId = ActualComponentIdIn;}

ArrayReferenceType * CharacteristicMeasurementBaseType::getMeasurementDeviceIds()
{return MeasurementDeviceIds;}

void CharacteristicMeasurementBaseType::setMeasurementDeviceIds(ArrayReferenceType * MeasurementDeviceIdsIn)
{MeasurementDeviceIds = MeasurementDeviceIdsIn;}

QIFReferenceType * CharacteristicMeasurementBaseType::getManufacturingProcessId()
{return ManufacturingProcessId;}

void CharacteristicMeasurementBaseType::setManufacturingProcessId(QIFReferenceType * ManufacturingProcessIdIn)
{ManufacturingProcessId = ManufacturingProcessIdIn;}

ArrayReferenceType * CharacteristicMeasurementBaseType::getNotedEventIds()
{return NotedEventIds;}

void CharacteristicMeasurementBaseType::setNotedEventIds(ArrayReferenceType * NotedEventIdsIn)
{NotedEventIds = NotedEventIdsIn;}

XmlToken * CharacteristicMeasurementBaseType::getNonConformanceDesignator()
{return NonConformanceDesignator;}

void CharacteristicMeasurementBaseType::setNonConformanceDesignator(XmlToken * NonConformanceDesignatorIn)
{NonConformanceDesignator = NonConformanceDesignatorIn;}

/* ***************************************************************** */

/* class CharacteristicMeasurementBaseTypeLisd

*/

CharacteristicMeasurementBaseTypeLisd::CharacteristicMeasurementBaseTypeLisd() {}

CharacteristicMeasurementBaseTypeLisd::CharacteristicMeasurementBaseTypeLisd(CharacteristicMeasurementBaseType * aCharacteristicMeasurementBaseType)
{
  push_back(aCharacteristicMeasurementBaseType);
}

CharacteristicMeasurementBaseTypeLisd::~CharacteristicMeasurementBaseTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<CharacteristicMeasurementBaseType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void CharacteristicMeasurementBaseTypeLisd::printSelf(FILE * outFile)
{
  std::list<CharacteristicMeasurementBaseType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class CharacteristicMeasurementsType

*/

CharacteristicMeasurementsType::CharacteristicMeasurementsType()
{
  n = 0;
  CharacteristicMeasurement = 0;
}

CharacteristicMeasurementsType::CharacteristicMeasurementsType(
 CharacteristicMeasurementBaseTypeLisd * CharacteristicMeasurementIn)
{
  n = 0;
  CharacteristicMeasurement = CharacteristicMeasurementIn;
}

CharacteristicMeasurementsType::CharacteristicMeasurementsType(
 NaturalType * nIn,
 CharacteristicMeasurementBaseTypeLisd * CharacteristicMeasurementIn)
{
  n = nIn;
  CharacteristicMeasurement = CharacteristicMeasurementIn;
}

CharacteristicMeasurementsType::~CharacteristicMeasurementsType()
{
  #ifndef NODESTRUCT
  delete n;
  delete CharacteristicMeasurement;
  #endif
}

void CharacteristicMeasurementsType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!CharacteristicMeasurement)
      {
        fprintf(stderr, "CharacteristicMeasurement list is missing\n");
        exit(1);
      }
    if (CharacteristicMeasurement->size() == 0)
      {
        fprintf(stderr, "CharacteristicMeasurement list is empty\n");
        exit(1);
      }
    if (CharacteristicMeasurement->size() < 1)
      {
        fprintf(stderr,
                "size of CharacteristicMeasurement list (%d) less than minimum required (1)\n",
                (int)CharacteristicMeasurement->size());
        exit(1);
      }
    std::list<CharacteristicMeasurementBaseType *>::iterator iter;
    for (iter = CharacteristicMeasurement->begin();
         iter != CharacteristicMeasurement->end(); iter++)
      {
        CharacteristicMeasurementBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->getprintElement(), "AngleBetweenCharacteristicMeasurement") == 0)
          {
            AngleBetweenCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<AngleBetweenCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<AngleBetweenCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AngleBetweenCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad AngleBetweenCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "AngleCharacteristicMeasurement") == 0)
          {
            AngleCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<AngleCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<AngleCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AngleCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad AngleCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "AngularCoordinateCharacteristicMeasurement") == 0)
          {
            AngularCoordinateCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<AngularCoordinateCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<AngularCoordinateCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AngularCoordinateCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad AngularCoordinateCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "AngleFromCharacteristicMeasurement") == 0)
          {
            AngleFromCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<AngleFromCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<AngleFromCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AngleFromCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad AngleFromCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "AngularityCharacteristicMeasurement") == 0)
          {
            AngularityCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<AngularityCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<AngularityCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AngularityCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad AngularityCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ChordCharacteristicMeasurement") == 0)
          {
            ChordCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<ChordCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<ChordCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ChordCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad ChordCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CircularityCharacteristicMeasurement") == 0)
          {
            CircularityCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<CircularityCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<CircularityCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CircularityCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad CircularityCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CircularRunoutCharacteristicMeasurement") == 0)
          {
            CircularRunoutCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<CircularRunoutCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<CircularRunoutCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CircularRunoutCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad CircularRunoutCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CoaxialityCharacteristicMeasurement") == 0)
          {
            CoaxialityCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<CoaxialityCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<CoaxialityCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CoaxialityCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad CoaxialityCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ConcentricityCharacteristicMeasurement") == 0)
          {
            ConcentricityCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<ConcentricityCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<ConcentricityCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ConcentricityCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad ConcentricityCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ConicalTaperCharacteristicMeasurement") == 0)
          {
            ConicalTaperCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<ConicalTaperCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<ConicalTaperCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ConicalTaperCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad ConicalTaperCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ConicityCharacteristicMeasurement") == 0)
          {
            ConicityCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<ConicityCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<ConicityCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ConicityCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad ConicityCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CurveLengthCharacteristicMeasurement") == 0)
          {
            CurveLengthCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<CurveLengthCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<CurveLengthCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CurveLengthCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad CurveLengthCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CylindricityCharacteristicMeasurement") == 0)
          {
            CylindricityCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<CylindricityCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<CylindricityCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CylindricityCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad CylindricityCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "DepthCharacteristicMeasurement") == 0)
          {
            DepthCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<DepthCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<DepthCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</DepthCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad DepthCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "DiameterCharacteristicMeasurement") == 0)
          {
            DiameterCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<DiameterCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<DiameterCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</DiameterCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad DiameterCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "DistanceBetweenCharacteristicMeasurement") == 0)
          {
            DistanceBetweenCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<DistanceBetweenCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<DistanceBetweenCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</DistanceBetweenCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad DistanceBetweenCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "DistanceFromCharacteristicMeasurement") == 0)
          {
            DistanceFromCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<DistanceFromCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<DistanceFromCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</DistanceFromCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad DistanceFromCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "EllipticityCharacteristicMeasurement") == 0)
          {
            EllipticityCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<EllipticityCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<EllipticityCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EllipticityCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad EllipticityCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "FlatTaperCharacteristicMeasurement") == 0)
          {
            FlatTaperCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<FlatTaperCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<FlatTaperCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</FlatTaperCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad FlatTaperCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "FlatnessCharacteristicMeasurement") == 0)
          {
            FlatnessCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<FlatnessCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<FlatnessCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</FlatnessCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad FlatnessCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "HeightCharacteristicMeasurement") == 0)
          {
            HeightCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<HeightCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<HeightCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</HeightCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad HeightCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "LengthCharacteristicMeasurement") == 0)
          {
            LengthCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<LengthCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<LengthCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LengthCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad LengthCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "LinearCoordinateCharacteristicMeasurement") == 0)
          {
            LinearCoordinateCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<LinearCoordinateCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<LinearCoordinateCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LinearCoordinateCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad LinearCoordinateCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "LineProfileCharacteristicMeasurement") == 0)
          {
            LineProfileCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<LineProfileCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<LineProfileCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LineProfileCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad LineProfileCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OtherFormCharacteristicMeasurement") == 0)
          {
            OtherFormCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<OtherFormCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<OtherFormCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OtherFormCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad OtherFormCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ParallelismCharacteristicMeasurement") == 0)
          {
            ParallelismCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<ParallelismCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<ParallelismCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ParallelismCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad ParallelismCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PerpendicularityCharacteristicMeasurement") == 0)
          {
            PerpendicularityCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<PerpendicularityCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<PerpendicularityCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PerpendicularityCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad PerpendicularityCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PointProfileCharacteristicMeasurement") == 0)
          {
            PointProfileCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<PointProfileCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<PointProfileCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PointProfileCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad PointProfileCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PositionCharacteristicMeasurement") == 0)
          {
            PositionCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<PositionCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<PositionCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PositionCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad PositionCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "RadiusCharacteristicMeasurement") == 0)
          {
            RadiusCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<RadiusCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<RadiusCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RadiusCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad RadiusCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SphericalDiameterCharacteristicMeasurement") == 0)
          {
            SphericalDiameterCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<SphericalDiameterCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<SphericalDiameterCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalDiameterCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalDiameterCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SphericalRadiusCharacteristicMeasurement") == 0)
          {
            SphericalRadiusCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<SphericalRadiusCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<SphericalRadiusCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalRadiusCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalRadiusCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SphericityCharacteristicMeasurement") == 0)
          {
            SphericityCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<SphericityCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<SphericityCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericityCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericityCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SquareCharacteristicMeasurement") == 0)
          {
            SquareCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<SquareCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<SquareCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SquareCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad SquareCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "StraightnessCharacteristicMeasurement") == 0)
          {
            StraightnessCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<StraightnessCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<StraightnessCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</StraightnessCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad StraightnessCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SurfaceProfileCharacteristicMeasurement") == 0)
          {
            SurfaceProfileCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<SurfaceProfileCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<SurfaceProfileCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SurfaceProfileCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad SurfaceProfileCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SurfaceProfileNonUniformCharacteristicMeasurement") == 0)
          {
            SurfaceProfileNonUniformCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<SurfaceProfileNonUniformCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<SurfaceProfileNonUniformCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SurfaceProfileNonUniformCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad SurfaceProfileNonUniformCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SurfaceTextureCharacteristicMeasurement") == 0)
          {
            SurfaceTextureCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<SurfaceTextureCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<SurfaceTextureCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SurfaceTextureCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad SurfaceTextureCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SymmetryCharacteristicMeasurement") == 0)
          {
            SymmetryCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<SymmetryCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<SymmetryCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SymmetryCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad SymmetryCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ThicknessCharacteristicMeasurement") == 0)
          {
            ThicknessCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<ThicknessCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<ThicknessCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ThicknessCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad ThicknessCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ThreadCharacteristicMeasurement") == 0)
          {
            ThreadCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<ThreadCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<ThreadCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ThreadCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad ThreadCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ToroidicityCharacteristicMeasurement") == 0)
          {
            ToroidicityCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<ToroidicityCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<ToroidicityCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ToroidicityCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad ToroidicityCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "TotalRunoutCharacteristicMeasurement") == 0)
          {
            TotalRunoutCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<TotalRunoutCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<TotalRunoutCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalRunoutCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalRunoutCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedAttributeCharacteristicMeasurement") == 0)
          {
            UserDefinedAttributeCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<UserDefinedAttributeCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedAttributeCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedAttributeCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedAttributeCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedLinearCharacteristicMeasurement") == 0)
          {
            UserDefinedLinearCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<UserDefinedLinearCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedLinearCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedLinearCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedLinearCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedAngularCharacteristicMeasurement") == 0)
          {
            UserDefinedAngularCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<UserDefinedAngularCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedAngularCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedAngularCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedAngularCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedTemperatureCharacteristicMeasurement") == 0)
          {
            UserDefinedTemperatureCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<UserDefinedTemperatureCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedTemperatureCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedTemperatureCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedTemperatureCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedAreaCharacteristicMeasurement") == 0)
          {
            UserDefinedAreaCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<UserDefinedAreaCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedAreaCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedAreaCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedAreaCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedForceCharacteristicMeasurement") == 0)
          {
            UserDefinedForceCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<UserDefinedForceCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedForceCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedForceCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedForceCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedMassCharacteristicMeasurement") == 0)
          {
            UserDefinedMassCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<UserDefinedMassCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedMassCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedMassCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedMassCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedPressureCharacteristicMeasurement") == 0)
          {
            UserDefinedPressureCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<UserDefinedPressureCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedPressureCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedPressureCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedPressureCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedSpeedCharacteristicMeasurement") == 0)
          {
            UserDefinedSpeedCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<UserDefinedSpeedCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedSpeedCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedSpeedCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedSpeedCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedTimeCharacteristicMeasurement") == 0)
          {
            UserDefinedTimeCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<UserDefinedTimeCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedTimeCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedTimeCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedTimeCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedUnitCharacteristicMeasurement") == 0)
          {
            UserDefinedUnitCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<UserDefinedUnitCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedUnitCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedUnitCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedUnitCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WidthCharacteristicMeasurement") == 0)
          {
            WidthCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<WidthCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<WidthCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WidthCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad WidthCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldFilletCharacteristicMeasurement") == 0)
          {
            WeldFilletCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<WeldFilletCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<WeldFilletCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldFilletCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldFilletCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldPlugCharacteristicMeasurement") == 0)
          {
            WeldPlugCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<WeldPlugCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<WeldPlugCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldPlugCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldPlugCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldSlotCharacteristicMeasurement") == 0)
          {
            WeldSlotCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<WeldSlotCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<WeldSlotCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldSlotCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldSlotCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldSpotCharacteristicMeasurement") == 0)
          {
            WeldSpotCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<WeldSpotCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<WeldSpotCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldSpotCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldSpotCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldStudCharacteristicMeasurement") == 0)
          {
            WeldStudCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<WeldStudCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<WeldStudCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldStudCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldStudCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldSeamCharacteristicMeasurement") == 0)
          {
            WeldSeamCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<WeldSeamCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<WeldSeamCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldSeamCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldSeamCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldSurfacingCharacteristicMeasurement") == 0)
          {
            WeldSurfacingCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<WeldSurfacingCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<WeldSurfacingCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldSurfacingCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldSurfacingCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldEdgeCharacteristicMeasurement") == 0)
          {
            WeldEdgeCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<WeldEdgeCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<WeldEdgeCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldEdgeCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldEdgeCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldSquareCharacteristicMeasurement") == 0)
          {
            WeldSquareCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<WeldSquareCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<WeldSquareCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldSquareCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldSquareCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldBevelCharacteristicMeasurement") == 0)
          {
            WeldBevelCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<WeldBevelCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<WeldBevelCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldBevelCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldBevelCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldVCharacteristicMeasurement") == 0)
          {
            WeldVCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<WeldVCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<WeldVCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldVCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldVCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldUCharacteristicMeasurement") == 0)
          {
            WeldUCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<WeldUCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<WeldUCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldUCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldUCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldJCharacteristicMeasurement") == 0)
          {
            WeldJCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<WeldJCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<WeldJCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldJCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldJCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldFlareVCharacteristicMeasurement") == 0)
          {
            WeldFlareVCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<WeldFlareVCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<WeldFlareVCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldFlareVCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldFlareVCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldFlareBevelCharacteristicMeasurement") == 0)
          {
            WeldFlareBevelCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<WeldFlareBevelCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<WeldFlareBevelCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldFlareBevelCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldFlareBevelCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldScarfCharacteristicMeasurement") == 0)
          {
            WeldScarfCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<WeldScarfCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<WeldScarfCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldScarfCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldScarfCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldCompoundCharacteristicMeasurement") == 0)
          {
            WeldCompoundCharacteristicMeasurementType * typ;
            if ((typ = dynamic_cast<WeldCompoundCharacteristicMeasurementType *>(basie)))
              {
                fprintf(outFile, "<WeldCompoundCharacteristicMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldCompoundCharacteristicMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldCompoundCharacteristicMeasurement element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad CharacteristicMeasurement type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool CharacteristicMeasurementsType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in CharacteristicMeasurementsType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in CharacteristicMeasurementsType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CharacteristicMeasurementsType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in CharacteristicMeasurementsType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * CharacteristicMeasurementsType::getn()
{return n;}

void CharacteristicMeasurementsType::setn(NaturalType * nIn)
{n = nIn;}

CharacteristicMeasurementBaseTypeLisd * CharacteristicMeasurementsType::getCharacteristicMeasurement()
{return CharacteristicMeasurement;}

void CharacteristicMeasurementsType::setCharacteristicMeasurement(CharacteristicMeasurementBaseTypeLisd * CharacteristicMeasurementIn)
{CharacteristicMeasurement = CharacteristicMeasurementIn;}

/* ***************************************************************** */

/* class CharacteristicNominalBaseType

*/

CharacteristicNominalBaseType::CharacteristicNominalBaseType() :
  CharacteristicBaseType()
{
  CharacteristicDefinitionId = 0;
  FeatureNominalIds = 0;
  SubstituteFeatureAlgorithm = 0;
  FeatureZoneIds = 0;
  EntityInternalIds = 0;
  EntityExternalIds = 0;
  Name = 0;
  CharacteristicDesignator = 0;
}

CharacteristicNominalBaseType::CharacteristicNominalBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  CharacteristicBaseType(
    AttributesIn,
    DescriptionIn)
{
  CharacteristicDefinitionId = CharacteristicDefinitionIdIn;
  FeatureNominalIds = FeatureNominalIdsIn;
  SubstituteFeatureAlgorithm = SubstituteFeatureAlgorithmIn;
  FeatureZoneIds = FeatureZoneIdsIn;
  EntityInternalIds = EntityInternalIdsIn;
  EntityExternalIds = EntityExternalIdsIn;
  Name = NameIn;
  CharacteristicDesignator = CharacteristicDesignatorIn;
}

CharacteristicNominalBaseType::CharacteristicNominalBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  CharacteristicBaseType(
    idIn,
    AttributesIn,
    DescriptionIn)
{
  CharacteristicDefinitionId = CharacteristicDefinitionIdIn;
  FeatureNominalIds = FeatureNominalIdsIn;
  SubstituteFeatureAlgorithm = SubstituteFeatureAlgorithmIn;
  FeatureZoneIds = FeatureZoneIdsIn;
  EntityInternalIds = EntityInternalIdsIn;
  EntityExternalIds = EntityExternalIdsIn;
  Name = NameIn;
  CharacteristicDesignator = CharacteristicDesignatorIn;
}

CharacteristicNominalBaseType::~CharacteristicNominalBaseType()
{
  #ifndef NODESTRUCT
  delete CharacteristicDefinitionId;
  delete FeatureNominalIds;
  delete SubstituteFeatureAlgorithm;
  delete FeatureZoneIds;
  delete EntityInternalIds;
  delete EntityExternalIds;
  delete Name;
  delete CharacteristicDesignator;
  #endif
}

void CharacteristicNominalBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CharacteristicNominalBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CharacteristicNominalBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CharacteristicNominalBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CharacteristicNominalBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CharacteristicNominalBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

QIFReferenceType * CharacteristicNominalBaseType::getCharacteristicDefinitionId()
{return CharacteristicDefinitionId;}

void CharacteristicNominalBaseType::setCharacteristicDefinitionId(QIFReferenceType * CharacteristicDefinitionIdIn)
{CharacteristicDefinitionId = CharacteristicDefinitionIdIn;}

ArrayReferenceFullType * CharacteristicNominalBaseType::getFeatureNominalIds()
{return FeatureNominalIds;}

void CharacteristicNominalBaseType::setFeatureNominalIds(ArrayReferenceFullType * FeatureNominalIdsIn)
{FeatureNominalIds = FeatureNominalIdsIn;}

SubstituteFeatureAlgorithmType * CharacteristicNominalBaseType::getSubstituteFeatureAlgorithm()
{return SubstituteFeatureAlgorithm;}

void CharacteristicNominalBaseType::setSubstituteFeatureAlgorithm(SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn)
{SubstituteFeatureAlgorithm = SubstituteFeatureAlgorithmIn;}

ArrayReferenceFullType * CharacteristicNominalBaseType::getFeatureZoneIds()
{return FeatureZoneIds;}

void CharacteristicNominalBaseType::setFeatureZoneIds(ArrayReferenceFullType * FeatureZoneIdsIn)
{FeatureZoneIds = FeatureZoneIdsIn;}

ArrayReferenceFullType * CharacteristicNominalBaseType::getEntityInternalIds()
{return EntityInternalIds;}

void CharacteristicNominalBaseType::setEntityInternalIds(ArrayReferenceFullType * EntityInternalIdsIn)
{EntityInternalIds = EntityInternalIdsIn;}

ArrayReferenceFullType * CharacteristicNominalBaseType::getEntityExternalIds()
{return EntityExternalIds;}

void CharacteristicNominalBaseType::setEntityExternalIds(ArrayReferenceFullType * EntityExternalIdsIn)
{EntityExternalIds = EntityExternalIdsIn;}

XmlToken * CharacteristicNominalBaseType::getName()
{return Name;}

void CharacteristicNominalBaseType::setName(XmlToken * NameIn)
{Name = NameIn;}

CharacteristicDesignatorType * CharacteristicNominalBaseType::getCharacteristicDesignator()
{return CharacteristicDesignator;}

void CharacteristicNominalBaseType::setCharacteristicDesignator(CharacteristicDesignatorType * CharacteristicDesignatorIn)
{CharacteristicDesignator = CharacteristicDesignatorIn;}

/* ***************************************************************** */

/* class CharacteristicNominalBaseTypeLisd

*/

CharacteristicNominalBaseTypeLisd::CharacteristicNominalBaseTypeLisd() {}

CharacteristicNominalBaseTypeLisd::CharacteristicNominalBaseTypeLisd(CharacteristicNominalBaseType * aCharacteristicNominalBaseType)
{
  push_back(aCharacteristicNominalBaseType);
}

CharacteristicNominalBaseTypeLisd::~CharacteristicNominalBaseTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<CharacteristicNominalBaseType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void CharacteristicNominalBaseTypeLisd::printSelf(FILE * outFile)
{
  std::list<CharacteristicNominalBaseType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class CharacteristicNominalsType

*/

CharacteristicNominalsType::CharacteristicNominalsType()
{
  n = 0;
  CharacteristicNominal = 0;
}

CharacteristicNominalsType::CharacteristicNominalsType(
 CharacteristicNominalBaseTypeLisd * CharacteristicNominalIn)
{
  n = 0;
  CharacteristicNominal = CharacteristicNominalIn;
}

CharacteristicNominalsType::CharacteristicNominalsType(
 NaturalType * nIn,
 CharacteristicNominalBaseTypeLisd * CharacteristicNominalIn)
{
  n = nIn;
  CharacteristicNominal = CharacteristicNominalIn;
}

CharacteristicNominalsType::~CharacteristicNominalsType()
{
  #ifndef NODESTRUCT
  delete n;
  delete CharacteristicNominal;
  #endif
}

void CharacteristicNominalsType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!CharacteristicNominal)
      {
        fprintf(stderr, "CharacteristicNominal list is missing\n");
        exit(1);
      }
    if (CharacteristicNominal->size() == 0)
      {
        fprintf(stderr, "CharacteristicNominal list is empty\n");
        exit(1);
      }
    if (CharacteristicNominal->size() < 1)
      {
        fprintf(stderr,
                "size of CharacteristicNominal list (%d) less than minimum required (1)\n",
                (int)CharacteristicNominal->size());
        exit(1);
      }
    std::list<CharacteristicNominalBaseType *>::iterator iter;
    for (iter = CharacteristicNominal->begin();
         iter != CharacteristicNominal->end(); iter++)
      {
        CharacteristicNominalBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->getprintElement(), "AngleBetweenCharacteristicNominal") == 0)
          {
            AngleBetweenCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<AngleBetweenCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<AngleBetweenCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AngleBetweenCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad AngleBetweenCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "AngleCharacteristicNominal") == 0)
          {
            AngleCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<AngleCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<AngleCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AngleCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad AngleCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "AngularCoordinateCharacteristicNominal") == 0)
          {
            AngularCoordinateCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<AngularCoordinateCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<AngularCoordinateCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AngularCoordinateCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad AngularCoordinateCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "AngleFromCharacteristicNominal") == 0)
          {
            AngleFromCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<AngleFromCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<AngleFromCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AngleFromCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad AngleFromCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "AngularityCharacteristicNominal") == 0)
          {
            AngularityCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<AngularityCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<AngularityCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AngularityCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad AngularityCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ChordCharacteristicNominal") == 0)
          {
            ChordCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<ChordCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<ChordCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ChordCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad ChordCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CircularityCharacteristicNominal") == 0)
          {
            CircularityCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<CircularityCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<CircularityCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CircularityCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad CircularityCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CircularRunoutCharacteristicNominal") == 0)
          {
            CircularRunoutCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<CircularRunoutCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<CircularRunoutCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CircularRunoutCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad CircularRunoutCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CoaxialityCharacteristicNominal") == 0)
          {
            CoaxialityCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<CoaxialityCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<CoaxialityCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CoaxialityCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad CoaxialityCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ConcentricityCharacteristicNominal") == 0)
          {
            ConcentricityCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<ConcentricityCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<ConcentricityCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ConcentricityCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad ConcentricityCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ConicalTaperCharacteristicNominal") == 0)
          {
            ConicalTaperCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<ConicalTaperCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<ConicalTaperCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ConicalTaperCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad ConicalTaperCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ConicityCharacteristicNominal") == 0)
          {
            ConicityCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<ConicityCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<ConicityCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ConicityCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad ConicityCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CurveLengthCharacteristicNominal") == 0)
          {
            CurveLengthCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<CurveLengthCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<CurveLengthCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CurveLengthCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad CurveLengthCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CylindricityCharacteristicNominal") == 0)
          {
            CylindricityCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<CylindricityCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<CylindricityCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CylindricityCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad CylindricityCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "DepthCharacteristicNominal") == 0)
          {
            DepthCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<DepthCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<DepthCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</DepthCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad DepthCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "DiameterCharacteristicNominal") == 0)
          {
            DiameterCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<DiameterCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<DiameterCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</DiameterCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad DiameterCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "DistanceBetweenCharacteristicNominal") == 0)
          {
            DistanceBetweenCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<DistanceBetweenCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<DistanceBetweenCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</DistanceBetweenCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad DistanceBetweenCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "DistanceFromCharacteristicNominal") == 0)
          {
            DistanceFromCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<DistanceFromCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<DistanceFromCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</DistanceFromCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad DistanceFromCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "EllipticityCharacteristicNominal") == 0)
          {
            EllipticityCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<EllipticityCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<EllipticityCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EllipticityCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad EllipticityCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "FlatTaperCharacteristicNominal") == 0)
          {
            FlatTaperCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<FlatTaperCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<FlatTaperCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</FlatTaperCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad FlatTaperCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "FlatnessCharacteristicNominal") == 0)
          {
            FlatnessCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<FlatnessCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<FlatnessCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</FlatnessCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad FlatnessCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "HeightCharacteristicNominal") == 0)
          {
            HeightCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<HeightCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<HeightCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</HeightCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad HeightCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "LengthCharacteristicNominal") == 0)
          {
            LengthCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<LengthCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<LengthCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LengthCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad LengthCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "LinearCoordinateCharacteristicNominal") == 0)
          {
            LinearCoordinateCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<LinearCoordinateCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<LinearCoordinateCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LinearCoordinateCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad LinearCoordinateCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "LineProfileCharacteristicNominal") == 0)
          {
            LineProfileCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<LineProfileCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<LineProfileCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LineProfileCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad LineProfileCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OtherFormCharacteristicNominal") == 0)
          {
            OtherFormCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<OtherFormCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<OtherFormCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OtherFormCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad OtherFormCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ParallelismCharacteristicNominal") == 0)
          {
            ParallelismCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<ParallelismCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<ParallelismCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ParallelismCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad ParallelismCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PerpendicularityCharacteristicNominal") == 0)
          {
            PerpendicularityCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<PerpendicularityCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<PerpendicularityCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PerpendicularityCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad PerpendicularityCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PointProfileCharacteristicNominal") == 0)
          {
            PointProfileCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<PointProfileCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<PointProfileCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PointProfileCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad PointProfileCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PositionCharacteristicNominal") == 0)
          {
            PositionCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<PositionCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<PositionCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PositionCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad PositionCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "RadiusCharacteristicNominal") == 0)
          {
            RadiusCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<RadiusCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<RadiusCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RadiusCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad RadiusCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SphericalDiameterCharacteristicNominal") == 0)
          {
            SphericalDiameterCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<SphericalDiameterCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<SphericalDiameterCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalDiameterCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalDiameterCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SphericalRadiusCharacteristicNominal") == 0)
          {
            SphericalRadiusCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<SphericalRadiusCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<SphericalRadiusCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalRadiusCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalRadiusCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SphericityCharacteristicNominal") == 0)
          {
            SphericityCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<SphericityCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<SphericityCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericityCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericityCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SquareCharacteristicNominal") == 0)
          {
            SquareCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<SquareCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<SquareCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SquareCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad SquareCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "StraightnessCharacteristicNominal") == 0)
          {
            StraightnessCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<StraightnessCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<StraightnessCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</StraightnessCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad StraightnessCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SurfaceProfileCharacteristicNominal") == 0)
          {
            SurfaceProfileCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<SurfaceProfileCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<SurfaceProfileCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SurfaceProfileCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad SurfaceProfileCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SurfaceProfileNonUniformCharacteristicNominal") == 0)
          {
            SurfaceProfileNonUniformCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<SurfaceProfileNonUniformCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<SurfaceProfileNonUniformCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SurfaceProfileNonUniformCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad SurfaceProfileNonUniformCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SurfaceTextureCharacteristicNominal") == 0)
          {
            SurfaceTextureCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<SurfaceTextureCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<SurfaceTextureCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SurfaceTextureCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad SurfaceTextureCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SymmetryCharacteristicNominal") == 0)
          {
            SymmetryCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<SymmetryCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<SymmetryCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SymmetryCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad SymmetryCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ThicknessCharacteristicNominal") == 0)
          {
            ThicknessCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<ThicknessCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<ThicknessCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ThicknessCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad ThicknessCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ThreadCharacteristicNominal") == 0)
          {
            ThreadCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<ThreadCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<ThreadCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ThreadCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad ThreadCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ToroidicityCharacteristicNominal") == 0)
          {
            ToroidicityCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<ToroidicityCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<ToroidicityCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ToroidicityCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad ToroidicityCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "TotalRunoutCharacteristicNominal") == 0)
          {
            TotalRunoutCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<TotalRunoutCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<TotalRunoutCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalRunoutCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalRunoutCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedAttributeCharacteristicNominal") == 0)
          {
            UserDefinedAttributeCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<UserDefinedAttributeCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedAttributeCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedAttributeCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedAttributeCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedLinearCharacteristicNominal") == 0)
          {
            UserDefinedLinearCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<UserDefinedLinearCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedLinearCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedLinearCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedLinearCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedAngularCharacteristicNominal") == 0)
          {
            UserDefinedAngularCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<UserDefinedAngularCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedAngularCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedAngularCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedAngularCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedTemperatureCharacteristicNominal") == 0)
          {
            UserDefinedTemperatureCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<UserDefinedTemperatureCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedTemperatureCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedTemperatureCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedTemperatureCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedAreaCharacteristicNominal") == 0)
          {
            UserDefinedAreaCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<UserDefinedAreaCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedAreaCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedAreaCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedAreaCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedForceCharacteristicNominal") == 0)
          {
            UserDefinedForceCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<UserDefinedForceCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedForceCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedForceCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedForceCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedMassCharacteristicNominal") == 0)
          {
            UserDefinedMassCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<UserDefinedMassCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedMassCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedMassCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedMassCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedPressureCharacteristicNominal") == 0)
          {
            UserDefinedPressureCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<UserDefinedPressureCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedPressureCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedPressureCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedPressureCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedSpeedCharacteristicNominal") == 0)
          {
            UserDefinedSpeedCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<UserDefinedSpeedCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedSpeedCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedSpeedCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedSpeedCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedTimeCharacteristicNominal") == 0)
          {
            UserDefinedTimeCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<UserDefinedTimeCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedTimeCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedTimeCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedTimeCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UserDefinedUnitCharacteristicNominal") == 0)
          {
            UserDefinedUnitCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<UserDefinedUnitCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedUnitCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedUnitCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedUnitCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WidthCharacteristicNominal") == 0)
          {
            WidthCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<WidthCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<WidthCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WidthCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad WidthCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldFilletCharacteristicNominal") == 0)
          {
            WeldFilletCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<WeldFilletCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<WeldFilletCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldFilletCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldFilletCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldPlugCharacteristicNominal") == 0)
          {
            WeldPlugCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<WeldPlugCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<WeldPlugCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldPlugCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldPlugCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldSlotCharacteristicNominal") == 0)
          {
            WeldSlotCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<WeldSlotCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<WeldSlotCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldSlotCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldSlotCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldSpotCharacteristicNominal") == 0)
          {
            WeldSpotCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<WeldSpotCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<WeldSpotCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldSpotCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldSpotCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldStudCharacteristicNominal") == 0)
          {
            WeldStudCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<WeldStudCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<WeldStudCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldStudCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldStudCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldSeamCharacteristicNominal") == 0)
          {
            WeldSeamCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<WeldSeamCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<WeldSeamCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldSeamCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldSeamCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldSurfacingCharacteristicNominal") == 0)
          {
            WeldSurfacingCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<WeldSurfacingCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<WeldSurfacingCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldSurfacingCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldSurfacingCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldEdgeCharacteristicNominal") == 0)
          {
            WeldEdgeCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<WeldEdgeCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<WeldEdgeCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldEdgeCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldEdgeCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldSquareCharacteristicNominal") == 0)
          {
            WeldSquareCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<WeldSquareCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<WeldSquareCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldSquareCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldSquareCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldBevelCharacteristicNominal") == 0)
          {
            WeldBevelCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<WeldBevelCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<WeldBevelCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldBevelCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldBevelCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldVCharacteristicNominal") == 0)
          {
            WeldVCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<WeldVCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<WeldVCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldVCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldVCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldUCharacteristicNominal") == 0)
          {
            WeldUCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<WeldUCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<WeldUCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldUCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldUCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldJCharacteristicNominal") == 0)
          {
            WeldJCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<WeldJCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<WeldJCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldJCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldJCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldFlareVCharacteristicNominal") == 0)
          {
            WeldFlareVCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<WeldFlareVCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<WeldFlareVCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldFlareVCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldFlareVCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldFlareBevelCharacteristicNominal") == 0)
          {
            WeldFlareBevelCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<WeldFlareBevelCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<WeldFlareBevelCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldFlareBevelCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldFlareBevelCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldScarfCharacteristicNominal") == 0)
          {
            WeldScarfCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<WeldScarfCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<WeldScarfCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldScarfCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldScarfCharacteristicNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "WeldCompoundCharacteristicNominal") == 0)
          {
            WeldCompoundCharacteristicNominalType * typ;
            if ((typ = dynamic_cast<WeldCompoundCharacteristicNominalType *>(basie)))
              {
                fprintf(outFile, "<WeldCompoundCharacteristicNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldCompoundCharacteristicNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldCompoundCharacteristicNominal element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad CharacteristicNominal type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool CharacteristicNominalsType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in CharacteristicNominalsType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in CharacteristicNominalsType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CharacteristicNominalsType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in CharacteristicNominalsType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * CharacteristicNominalsType::getn()
{return n;}

void CharacteristicNominalsType::setn(NaturalType * nIn)
{n = nIn;}

CharacteristicNominalBaseTypeLisd * CharacteristicNominalsType::getCharacteristicNominal()
{return CharacteristicNominal;}

void CharacteristicNominalsType::setCharacteristicNominal(CharacteristicNominalBaseTypeLisd * CharacteristicNominalIn)
{CharacteristicNominal = CharacteristicNominalIn;}

/* ***************************************************************** */

/* class CharacteristicStatusEnumType

*/

CharacteristicStatusEnumType::CharacteristicStatusEnumType() :
  XmlNMTOKEN()
{
}

CharacteristicStatusEnumType::CharacteristicStatusEnumType(
 const char * valIn) :
  XmlNMTOKEN(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "PASS") &&
           strcmp(val.c_str(), "FAIL") &&
           strcmp(val.c_str(), "REWORK") &&
           strcmp(val.c_str(), "SYSERROR") &&
           strcmp(val.c_str(), "INDETERMINATE") &&
           strcmp(val.c_str(), "NOT_ANALYZED") &&
           strcmp(val.c_str(), "BASIC_OR_TED") &&
           strcmp(val.c_str(), "UNDEFINED"));
}

CharacteristicStatusEnumType::~CharacteristicStatusEnumType() {}

bool CharacteristicStatusEnumType::CharacteristicStatusEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "PASS") &&
          strcmp(val.c_str(), "FAIL") &&
          strcmp(val.c_str(), "REWORK") &&
          strcmp(val.c_str(), "SYSERROR") &&
          strcmp(val.c_str(), "INDETERMINATE") &&
          strcmp(val.c_str(), "NOT_ANALYZED") &&
          strcmp(val.c_str(), "BASIC_OR_TED") &&
          strcmp(val.c_str(), "UNDEFINED"));
}

void CharacteristicStatusEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "CharacteristicStatusEnumType");
}

void CharacteristicStatusEnumType::printSelf(FILE * outFile)
{
  if (CharacteristicStatusEnumTypeIsBad())
    {
      fprintf(stderr, "bad CharacteristicStatusEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::printSelf(outFile);
}

void CharacteristicStatusEnumType::oPrintSelf(FILE * outFile)
{
  if (CharacteristicStatusEnumTypeIsBad())
    {
      fprintf(stderr, "bad CharacteristicStatusEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class CharacteristicStatusType

*/

CharacteristicStatusType::CharacteristicStatusType()
{
  CharacteristicStatusTypePair = 0;
}

CharacteristicStatusType::CharacteristicStatusType(
 CharacteristicStatusTypeChoicePair * CharacteristicStatusTypePairIn)
{
  CharacteristicStatusTypePair = CharacteristicStatusTypePairIn;
}

CharacteristicStatusType::~CharacteristicStatusType()
{
  #ifndef NODESTRUCT
  delete CharacteristicStatusTypePair;
  #endif
}

void CharacteristicStatusType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  CharacteristicStatusTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

CharacteristicStatusTypeChoicePair * CharacteristicStatusType::getCharacteristicStatusTypePair()
{return CharacteristicStatusTypePair;}

void CharacteristicStatusType::setCharacteristicStatusTypePair(CharacteristicStatusTypeChoicePair * CharacteristicStatusTypePairIn)
{CharacteristicStatusTypePair = CharacteristicStatusTypePairIn;}
CharacteristicStatusTypeChoicePair::CharacteristicStatusTypeChoicePair() {}

CharacteristicStatusTypeChoicePair::CharacteristicStatusTypeChoicePair(
 whichOne CharacteristicStatusTypeTypeIn,
 CharacteristicStatusTypeVal CharacteristicStatusTypeValueIn)
{
  CharacteristicStatusTypeType = CharacteristicStatusTypeTypeIn;
  CharacteristicStatusTypeValue = CharacteristicStatusTypeValueIn;
}

CharacteristicStatusTypeChoicePair::~CharacteristicStatusTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (CharacteristicStatusTypeType == CharacteristicStatusEnumE)
    delete CharacteristicStatusTypeValue.CharacteristicStatusEnum;
  else if (CharacteristicStatusTypeType == OtherCharacteristicStatusE)
    delete CharacteristicStatusTypeValue.OtherCharacteristicStatus;
  #endif
}

void CharacteristicStatusTypeChoicePair::printSelf(FILE * outFile)
{
  if (CharacteristicStatusTypeType == CharacteristicStatusEnumE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicStatusEnum");
      CharacteristicStatusTypeValue.CharacteristicStatusEnum->printSelf(outFile);
      fprintf(outFile, "</CharacteristicStatusEnum>\n");
    }
  else if (CharacteristicStatusTypeType == OtherCharacteristicStatusE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OtherCharacteristicStatus");
      CharacteristicStatusTypeValue.OtherCharacteristicStatus->printSelf(outFile);
      fprintf(outFile, "</OtherCharacteristicStatus>\n");
    }
}

/* ***************************************************************** */

/* class ChordCharacteristicDefinitionType

*/

ChordCharacteristicDefinitionType::ChordCharacteristicDefinitionType() :
  LinearCharacteristicDefinitionBaseType()
{
}

ChordCharacteristicDefinitionType::ChordCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseTypePairIn) :
  LinearCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    LinearCharacteristicDefinitionBaseTypePairIn)
{
}

ChordCharacteristicDefinitionType::ChordCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseTypePairIn) :
  LinearCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    LinearCharacteristicDefinitionBaseTypePairIn)
{
}

ChordCharacteristicDefinitionType::~ChordCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void ChordCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (DimensionType)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionType");
      DimensionType->printSelf(outFile);
      fprintf(outFile, "</DimensionType>\n");
    }
  if (DimensionModifiers)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionModifiers");
      DimensionModifiers->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DimensionModifiers>\n");
    }
  LinearCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

bool ChordCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ChordCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ChordCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ChordCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ChordCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class ChordCharacteristicItemType

*/

ChordCharacteristicItemType::ChordCharacteristicItemType() :
  LinearCharacteristicItemBaseType()
{
}

ChordCharacteristicItemType::ChordCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LinearCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

ChordCharacteristicItemType::ChordCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LinearCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

ChordCharacteristicItemType::~ChordCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void ChordCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool ChordCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ChordCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ChordCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ChordCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ChordCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class ChordCharacteristicMeasurementType

*/

ChordCharacteristicMeasurementType::ChordCharacteristicMeasurementType() :
  LinearCharacteristicMeasurementBaseType()
{
}

ChordCharacteristicMeasurementType::ChordCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  LinearCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

ChordCharacteristicMeasurementType::ChordCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  LinearCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

ChordCharacteristicMeasurementType::~ChordCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void ChordCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ChordCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ChordCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ChordCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ChordCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ChordCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class ChordCharacteristicNominalType

*/

ChordCharacteristicNominalType::ChordCharacteristicNominalType() :
  LinearCharacteristicNominalBaseType()
{
}

ChordCharacteristicNominalType::ChordCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn) :
  LinearCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn,
    TargetDualValueIn)
{
}

ChordCharacteristicNominalType::ChordCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn) :
  LinearCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn,
    TargetDualValueIn)
{
}

ChordCharacteristicNominalType::~ChordCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void ChordCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  if (TargetDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetDualValue");
      TargetDualValue->printSelf(outFile);
      fprintf(outFile, "</TargetDualValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ChordCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ChordCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ChordCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ChordCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ChordCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class CircularRunoutCharacteristicDefinitionType

*/

CircularRunoutCharacteristicDefinitionType::CircularRunoutCharacteristicDefinitionType() :
  RunoutCharacteristicDefinitionBaseType()
{
}

CircularRunoutCharacteristicDefinitionType::CircularRunoutCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 QIFReferenceFullType * DatumReferenceFrameIdIn) :
  RunoutCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn,
    ToleranceValueIn,
    ToleranceDualValueIn,
    DatumReferenceFrameIdIn)
{
}

CircularRunoutCharacteristicDefinitionType::CircularRunoutCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 QIFReferenceFullType * DatumReferenceFrameIdIn) :
  RunoutCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn,
    ToleranceValueIn,
    ToleranceDualValueIn,
    DatumReferenceFrameIdIn)
{
}

CircularRunoutCharacteristicDefinitionType::~CircularRunoutCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void CircularRunoutCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (GeometricCharac_1050)
    {
  GeometricCharac_1050->printSelf(outFile);
    }
  if (DirectionFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DirectionFeature");
      DirectionFeature->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DirectionFeature>\n");
    }
  if (CollectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CollectionPlane");
      CollectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CollectionPlane>\n");
    }
  if (IntersectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IntersectionPlane");
      IntersectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</IntersectionPlane>\n");
    }
  if (OrientationPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OrientationPlane");
      OrientationPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OrientationPlane>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ToleranceValue");
  ToleranceValue->printSelf(outFile);
  fprintf(outFile, "</ToleranceValue>\n");
  if (ToleranceDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceDualValue");
      ToleranceDualValue->printSelf(outFile);
      fprintf(outFile, "</ToleranceDualValue>\n");
    }
  if (DatumReferenceFrameId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumReferenceFrameId");
      DatumReferenceFrameId->printSelf(outFile);
      fprintf(outFile, "</DatumReferenceFrameId>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CircularRunoutCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CircularRunoutCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CircularRunoutCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CircularRunoutCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CircularRunoutCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class CircularRunoutCharacteristicItemType

*/

CircularRunoutCharacteristicItemType::CircularRunoutCharacteristicItemType() :
  RunoutCharacteristicItemBaseType()
{
}

CircularRunoutCharacteristicItemType::CircularRunoutCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  RunoutCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

CircularRunoutCharacteristicItemType::CircularRunoutCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  RunoutCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

CircularRunoutCharacteristicItemType::~CircularRunoutCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void CircularRunoutCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool CircularRunoutCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CircularRunoutCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CircularRunoutCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CircularRunoutCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CircularRunoutCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class CircularRunoutCharacteristicMeasurementType

*/

CircularRunoutCharacteristicMeasurementType::CircularRunoutCharacteristicMeasurementType() :
  RunoutCharacteristicMeasurementBaseType()
{
}

CircularRunoutCharacteristicMeasurementType::CircularRunoutCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 XmlBoolean * DatumsOkIn) :
  RunoutCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn,
    DatumsOkIn)
{
}

CircularRunoutCharacteristicMeasurementType::CircularRunoutCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 XmlBoolean * DatumsOkIn) :
  RunoutCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn,
    DatumsOkIn)
{
}

CircularRunoutCharacteristicMeasurementType::~CircularRunoutCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void CircularRunoutCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  if (DatumsOk)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumsOk");
      DatumsOk->printSelf(outFile);
      fprintf(outFile, "</DatumsOk>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CircularRunoutCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CircularRunoutCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CircularRunoutCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CircularRunoutCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CircularRunoutCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class CircularRunoutCharacteristicNominalType

*/

CircularRunoutCharacteristicNominalType::CircularRunoutCharacteristicNominalType() :
  RunoutCharacteristicNominalBaseType()
{
  ZoneDirection = 0;
  ProfileCurveId = 0;
}

CircularRunoutCharacteristicNominalType::CircularRunoutCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 UnitVectorType * ZoneDirectionIn,
 QIFReferenceFullType * ProfileCurveIdIn) :
  RunoutCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  ZoneDirection = ZoneDirectionIn;
  ProfileCurveId = ProfileCurveIdIn;
}

CircularRunoutCharacteristicNominalType::CircularRunoutCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 UnitVectorType * ZoneDirectionIn,
 QIFReferenceFullType * ProfileCurveIdIn) :
  RunoutCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  ZoneDirection = ZoneDirectionIn;
  ProfileCurveId = ProfileCurveIdIn;
}

CircularRunoutCharacteristicNominalType::~CircularRunoutCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  delete ZoneDirection;
  delete ProfileCurveId;
  #endif
}

void CircularRunoutCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (ZoneDirection)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ZoneDirection");
      ZoneDirection->printSelf(outFile);
      fprintf(outFile, "</ZoneDirection>\n");
    }
  if (ProfileCurveId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProfileCurveId");
      ProfileCurveId->printSelf(outFile);
      fprintf(outFile, "</ProfileCurveId>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CircularRunoutCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CircularRunoutCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CircularRunoutCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CircularRunoutCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CircularRunoutCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

UnitVectorType * CircularRunoutCharacteristicNominalType::getZoneDirection()
{return ZoneDirection;}

void CircularRunoutCharacteristicNominalType::setZoneDirection(UnitVectorType * ZoneDirectionIn)
{ZoneDirection = ZoneDirectionIn;}

QIFReferenceFullType * CircularRunoutCharacteristicNominalType::getProfileCurveId()
{return ProfileCurveId;}

void CircularRunoutCharacteristicNominalType::setProfileCurveId(QIFReferenceFullType * ProfileCurveIdIn)
{ProfileCurveId = ProfileCurveIdIn;}

/* ***************************************************************** */

/* class CircularityCharacteristicDefinitionType

*/

CircularityCharacteristicDefinitionType::CircularityCharacteristicDefinitionType() :
  FormCharacteristicDefinitionBaseType()
{
  CircularityCharacteristicDefinitionTypePair = 0;
}

CircularityCharacteristicDefinitionType::CircularityCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 CircularityCharacteristicDefinitionTypeChoicePair * CircularityCharacteristicDefinitionTypePairIn) :
  FormCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn)
{
  CircularityCharacteristicDefinitionTypePair = CircularityCharacteristicDefinitionTypePairIn;
}

CircularityCharacteristicDefinitionType::CircularityCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 CircularityCharacteristicDefinitionTypeChoicePair * CircularityCharacteristicDefinitionTypePairIn) :
  FormCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn)
{
  CircularityCharacteristicDefinitionTypePair = CircularityCharacteristicDefinitionTypePairIn;
}

CircularityCharacteristicDefinitionType::~CircularityCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  delete CircularityCharacteristicDefinitionTypePair;
  #endif
}

void CircularityCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (GeometricCharac_1050)
    {
  GeometricCharac_1050->printSelf(outFile);
    }
  if (DirectionFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DirectionFeature");
      DirectionFeature->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DirectionFeature>\n");
    }
  if (CollectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CollectionPlane");
      CollectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CollectionPlane>\n");
    }
  if (IntersectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IntersectionPlane");
      IntersectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</IntersectionPlane>\n");
    }
  if (OrientationPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OrientationPlane");
      OrientationPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OrientationPlane>\n");
    }
  CircularityCharacteristicDefinitionTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}
CircularityCharacteristicDefinitionTypeChoicePair * CircularityCharacteristicDefinitionType::getCircularityCharacteristicDefinitionTypeChoicePair()
{return CircularityCharacteristicDefinitionTypePair;}

void CircularityCharacteristicDefinitionType::setCircularityCharacteristicDefinitionTypeChoicePair(CircularityCharacteristicDefinitionTypeChoicePair * CircularityCharacteristicDefinitionTypePairIn)
{CircularityCharacteristicDefinitionTypePair = CircularityCharacteristicDefinitionTypePairIn;}

/* ***************************************************************** */

CircularityCharacteristicDefinitionTypeChoicePair::CircularityCharacteristicDefinitionTypeChoicePair() {}

CircularityCharacteristicDefinitionTypeChoicePair::CircularityCharacteristicDefinitionTypeChoicePair(
 whichOne CircularityCharacteristicDefinitionTypeTypeIn,
 CircularityCharacteristicDefinitionTypeVal CircularityCharacteristicDefinitionTypeValueIn)
{
  CircularityCharacteristicDefinitionTypeType = CircularityCharacteristicDefinitionTypeTypeIn;
  CircularityCharacteristicDefinitionTypeValue = CircularityCharacteristicDefinitionTypeValueIn;
}

CircularityCharacteristicDefinitionTypeChoicePair::~CircularityCharacteristicDefinitionTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (CircularityCharacteristicDefinitionTypeType == CircularityChar_1041E)
    delete CircularityCharacteristicDefinitionTypeValue.CircularityChar_1041;
  else if (CircularityCharacteristicDefinitionTypeType == CircularityChar_1042E)
    delete CircularityCharacteristicDefinitionTypeValue.CircularityChar_1042;
  #endif
}

void CircularityCharacteristicDefinitionTypeChoicePair::printSelf(FILE * outFile)
{
  if (CircularityCharacteristicDefinitionTypeType == CircularityChar_1041E)
    {
      CircularityCharacteristicDefinitionTypeValue.CircularityChar_1041->printSelf(outFile);
    }
  else if (CircularityCharacteristicDefinitionTypeType == CircularityChar_1042E)
    {
      CircularityCharacteristicDefinitionTypeValue.CircularityChar_1042->printSelf(outFile);
    }
}

bool CircularityCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CircularityCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CircularityCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CircularityCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CircularityCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class CircularityCharacteristicItemType

*/

CircularityCharacteristicItemType::CircularityCharacteristicItemType() :
  FormCharacteristicItemBaseType()
{
}

CircularityCharacteristicItemType::CircularityCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  FormCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

CircularityCharacteristicItemType::CircularityCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  FormCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

CircularityCharacteristicItemType::~CircularityCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void CircularityCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool CircularityCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CircularityCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CircularityCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CircularityCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CircularityCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class CircularityCharacteristicMeasurementType

*/

CircularityCharacteristicMeasurementType::CircularityCharacteristicMeasurementType() :
  FormCharacteristicMeasurementBaseType()
{
  MaxCircularity = 0;
  CircularityChar_1043 = 0;
}

CircularityCharacteristicMeasurementType::CircularityCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 MeasuredLinearValueType * MaxCircularityIn,
 CircularityChar_1043_Type * CircularityChar_1043In) :
  FormCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
  MaxCircularity = MaxCircularityIn;
  CircularityChar_1043 = CircularityChar_1043In;
}

CircularityCharacteristicMeasurementType::CircularityCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 MeasuredLinearValueType * MaxCircularityIn,
 CircularityChar_1043_Type * CircularityChar_1043In) :
  FormCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
  MaxCircularity = MaxCircularityIn;
  CircularityChar_1043 = CircularityChar_1043In;
}

CircularityCharacteristicMeasurementType::~CircularityCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  delete MaxCircularity;
  delete CircularityChar_1043;
  #endif
}

void CircularityCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  if (MaxCircularity)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxCircularity");
      MaxCircularity->printSelf(outFile);
      fprintf(outFile, "</MaxCircularity>\n");
    }
  if (CircularityChar_1043)
    {
      CircularityChar_1043->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool CircularityCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CircularityCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CircularityCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CircularityCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CircularityCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredLinearValueType * CircularityCharacteristicMeasurementType::getMaxCircularity()
{return MaxCircularity;}

void CircularityCharacteristicMeasurementType::setMaxCircularity(MeasuredLinearValueType * MaxCircularityIn)
{MaxCircularity = MaxCircularityIn;}

CircularityChar_1043_Type * CircularityCharacteristicMeasurementType::getCircularityChar_1043()
{return CircularityChar_1043;}

void CircularityCharacteristicMeasurementType::setCircularityChar_1043(CircularityChar_1043_Type * CircularityChar_1043In)
{CircularityChar_1043 = CircularityChar_1043In;}

/* ***************************************************************** */

/* class CircularityCharacteristicNominalType

*/

CircularityCharacteristicNominalType::CircularityCharacteristicNominalType() :
  FormCharacteristicNominalBaseType()
{
  ProfileCurveId = 0;
}

CircularityCharacteristicNominalType::CircularityCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 QIFReferenceFullType * ProfileCurveIdIn) :
  FormCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  ProfileCurveId = ProfileCurveIdIn;
}

CircularityCharacteristicNominalType::CircularityCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 QIFReferenceFullType * ProfileCurveIdIn) :
  FormCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  ProfileCurveId = ProfileCurveIdIn;
}

CircularityCharacteristicNominalType::~CircularityCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  delete ProfileCurveId;
  #endif
}

void CircularityCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (ProfileCurveId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProfileCurveId");
      ProfileCurveId->printSelf(outFile);
      fprintf(outFile, "</ProfileCurveId>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CircularityCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CircularityCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CircularityCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CircularityCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CircularityCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

QIFReferenceFullType * CircularityCharacteristicNominalType::getProfileCurveId()
{return ProfileCurveId;}

void CircularityCharacteristicNominalType::setProfileCurveId(QIFReferenceFullType * ProfileCurveIdIn)
{ProfileCurveId = ProfileCurveIdIn;}

/* ***************************************************************** */

/* class CoaxialityCharacteristicDefinitionType

*/

CoaxialityCharacteristicDefinitionType::CoaxialityCharacteristicDefinitionType() :
  LocationCharacteristicDefinitionBaseType()
{
  ZoneShape = 0;
}

CoaxialityCharacteristicDefinitionType::CoaxialityCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 QIFReferenceFullType * DatumReferenceFrameIdIn,
 CoaxialityZoneShapeType * ZoneShapeIn) :
  LocationCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn,
    ToleranceValueIn,
    ToleranceDualValueIn,
    DatumReferenceFrameIdIn)
{
  ZoneShape = ZoneShapeIn;
}

CoaxialityCharacteristicDefinitionType::CoaxialityCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 QIFReferenceFullType * DatumReferenceFrameIdIn,
 CoaxialityZoneShapeType * ZoneShapeIn) :
  LocationCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn,
    ToleranceValueIn,
    ToleranceDualValueIn,
    DatumReferenceFrameIdIn)
{
  ZoneShape = ZoneShapeIn;
}

CoaxialityCharacteristicDefinitionType::~CoaxialityCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  delete ZoneShape;
  #endif
}

void CoaxialityCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (GeometricCharac_1050)
    {
  GeometricCharac_1050->printSelf(outFile);
    }
  if (DirectionFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DirectionFeature");
      DirectionFeature->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DirectionFeature>\n");
    }
  if (CollectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CollectionPlane");
      CollectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CollectionPlane>\n");
    }
  if (IntersectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IntersectionPlane");
      IntersectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</IntersectionPlane>\n");
    }
  if (OrientationPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OrientationPlane");
      OrientationPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OrientationPlane>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ToleranceValue");
  ToleranceValue->printSelf(outFile);
  fprintf(outFile, "</ToleranceValue>\n");
  if (ToleranceDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceDualValue");
      ToleranceDualValue->printSelf(outFile);
      fprintf(outFile, "</ToleranceDualValue>\n");
    }
  if (DatumReferenceFrameId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumReferenceFrameId");
      DatumReferenceFrameId->printSelf(outFile);
      fprintf(outFile, "</DatumReferenceFrameId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ZoneShape");
  ZoneShape->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ZoneShape>\n");
  doSpaces(-INDENT, outFile);
}

bool CoaxialityCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CoaxialityCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CoaxialityCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CoaxialityCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CoaxialityCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

CoaxialityZoneShapeType * CoaxialityCharacteristicDefinitionType::getZoneShape()
{return ZoneShape;}

void CoaxialityCharacteristicDefinitionType::setZoneShape(CoaxialityZoneShapeType * ZoneShapeIn)
{ZoneShape = ZoneShapeIn;}

/* ***************************************************************** */

/* class CoaxialityCharacteristicItemType

*/

CoaxialityCharacteristicItemType::CoaxialityCharacteristicItemType() :
  LocationCharacteristicItemBaseType()
{
}

CoaxialityCharacteristicItemType::CoaxialityCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LocationCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

CoaxialityCharacteristicItemType::CoaxialityCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LocationCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

CoaxialityCharacteristicItemType::~CoaxialityCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void CoaxialityCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool CoaxialityCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CoaxialityCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CoaxialityCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CoaxialityCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CoaxialityCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class CoaxialityCharacteristicMeasurementType

*/

CoaxialityCharacteristicMeasurementType::CoaxialityCharacteristicMeasurementType() :
  LocationCharacteristicMeasurementBaseType()
{
}

CoaxialityCharacteristicMeasurementType::CoaxialityCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 ZoneDataSetType * ZoneDataSetIn,
 XmlBoolean * DatumsOkIn) :
  LocationCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn,
    ZoneDataSetIn,
    DatumsOkIn)
{
}

CoaxialityCharacteristicMeasurementType::CoaxialityCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 ZoneDataSetType * ZoneDataSetIn,
 XmlBoolean * DatumsOkIn) :
  LocationCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn,
    ZoneDataSetIn,
    DatumsOkIn)
{
}

CoaxialityCharacteristicMeasurementType::~CoaxialityCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void CoaxialityCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  if (ZoneDataSet)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ZoneDataSet");
      ZoneDataSet->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ZoneDataSet>\n");
    }
  if (DatumsOk)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumsOk");
      DatumsOk->printSelf(outFile);
      fprintf(outFile, "</DatumsOk>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CoaxialityCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CoaxialityCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CoaxialityCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CoaxialityCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CoaxialityCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class CoaxialityCharacteristicNominalType

*/

CoaxialityCharacteristicNominalType::CoaxialityCharacteristicNominalType() :
  LocationCharacteristicNominalBaseType()
{
}

CoaxialityCharacteristicNominalType::CoaxialityCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  LocationCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

CoaxialityCharacteristicNominalType::CoaxialityCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  LocationCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

CoaxialityCharacteristicNominalType::~CoaxialityCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void CoaxialityCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CoaxialityCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CoaxialityCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CoaxialityCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CoaxialityCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CoaxialityCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class CoaxialityDiametricalZoneType

*/

CoaxialityDiametricalZoneType::CoaxialityDiametricalZoneType()
{}

CoaxialityDiametricalZoneType::~CoaxialityDiametricalZoneType() {}

void CoaxialityDiametricalZoneType::printSelf(FILE * outFile)
{
  fprintf(outFile, "/>\n");
}

/* ***************************************************************** */

/* class CoaxialityNonDiametricalZoneType

*/

CoaxialityNonDiametricalZoneType::CoaxialityNonDiametricalZoneType()
{}

CoaxialityNonDiametricalZoneType::~CoaxialityNonDiametricalZoneType() {}

void CoaxialityNonDiametricalZoneType::printSelf(FILE * outFile)
{
  fprintf(outFile, "/>\n");
}

/* ***************************************************************** */

/* class CoaxialityZoneShapeType

*/

CoaxialityZoneShapeType::CoaxialityZoneShapeType()
{
  CoaxialityZoneShapeTypePair = 0;
}

CoaxialityZoneShapeType::CoaxialityZoneShapeType(
 CoaxialityZoneShapeTypeChoicePair * CoaxialityZoneShapeTypePairIn)
{
  CoaxialityZoneShapeTypePair = CoaxialityZoneShapeTypePairIn;
}

CoaxialityZoneShapeType::~CoaxialityZoneShapeType()
{
  #ifndef NODESTRUCT
  delete CoaxialityZoneShapeTypePair;
  #endif
}

void CoaxialityZoneShapeType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  CoaxialityZoneShapeTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

CoaxialityZoneShapeTypeChoicePair * CoaxialityZoneShapeType::getCoaxialityZoneShapeTypePair()
{return CoaxialityZoneShapeTypePair;}

void CoaxialityZoneShapeType::setCoaxialityZoneShapeTypePair(CoaxialityZoneShapeTypeChoicePair * CoaxialityZoneShapeTypePairIn)
{CoaxialityZoneShapeTypePair = CoaxialityZoneShapeTypePairIn;}
CoaxialityZoneShapeTypeChoicePair::CoaxialityZoneShapeTypeChoicePair() {}

CoaxialityZoneShapeTypeChoicePair::CoaxialityZoneShapeTypeChoicePair(
 whichOne CoaxialityZoneShapeTypeTypeIn,
 CoaxialityZoneShapeTypeVal CoaxialityZoneShapeTypeValueIn)
{
  CoaxialityZoneShapeTypeType = CoaxialityZoneShapeTypeTypeIn;
  CoaxialityZoneShapeTypeValue = CoaxialityZoneShapeTypeValueIn;
}

CoaxialityZoneShapeTypeChoicePair::~CoaxialityZoneShapeTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (CoaxialityZoneShapeTypeType == DiametricalZoneE)
    delete CoaxialityZoneShapeTypeValue.DiametricalZone;
  else if (CoaxialityZoneShapeTypeType == NonDiametricalZoneE)
    delete CoaxialityZoneShapeTypeValue.NonDiametricalZone;
  #endif
}

void CoaxialityZoneShapeTypeChoicePair::printSelf(FILE * outFile)
{
  if (CoaxialityZoneShapeTypeType == DiametricalZoneE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DiametricalZone");
      CoaxialityZoneShapeTypeValue.DiametricalZone->printSelf(outFile);
    }
  else if (CoaxialityZoneShapeTypeType == NonDiametricalZoneE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonDiametricalZone");
      CoaxialityZoneShapeTypeValue.NonDiametricalZone->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class CompositeSegmentDefinitionBaseType

*/

CompositeSegmentDefinitionBaseType::CompositeSegmentDefinitionBaseType()
{
  DatumReferenceFrameId = 0;
  ToleranceValue = 0;
  ToleranceDualValue = 0;
  CharacteristicDesignator = 0;
}

CompositeSegmentDefinitionBaseType::CompositeSegmentDefinitionBaseType(
 QIFReferenceFullType * DatumReferenceFrameIdIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn)
{
  DatumReferenceFrameId = DatumReferenceFrameIdIn;
  ToleranceValue = ToleranceValueIn;
  ToleranceDualValue = ToleranceDualValueIn;
  CharacteristicDesignator = CharacteristicDesignatorIn;
}

CompositeSegmentDefinitionBaseType::~CompositeSegmentDefinitionBaseType()
{
  #ifndef NODESTRUCT
  delete DatumReferenceFrameId;
  delete ToleranceValue;
  delete ToleranceDualValue;
  delete CharacteristicDesignator;
  #endif
}

void CompositeSegmentDefinitionBaseType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (DatumReferenceFrameId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumReferenceFrameId");
      DatumReferenceFrameId->printSelf(outFile);
      fprintf(outFile, "</DatumReferenceFrameId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ToleranceValue");
  ToleranceValue->printSelf(outFile);
  fprintf(outFile, "</ToleranceValue>\n");
  if (ToleranceDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceDualValue");
      ToleranceDualValue->printSelf(outFile);
      fprintf(outFile, "</ToleranceDualValue>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  doSpaces(-INDENT, outFile);
}

QIFReferenceFullType * CompositeSegmentDefinitionBaseType::getDatumReferenceFrameId()
{return DatumReferenceFrameId;}

void CompositeSegmentDefinitionBaseType::setDatumReferenceFrameId(QIFReferenceFullType * DatumReferenceFrameIdIn)
{DatumReferenceFrameId = DatumReferenceFrameIdIn;}

LinearValueType * CompositeSegmentDefinitionBaseType::getToleranceValue()
{return ToleranceValue;}

void CompositeSegmentDefinitionBaseType::setToleranceValue(LinearValueType * ToleranceValueIn)
{ToleranceValue = ToleranceValueIn;}

LinearDualValueType * CompositeSegmentDefinitionBaseType::getToleranceDualValue()
{return ToleranceDualValue;}

void CompositeSegmentDefinitionBaseType::setToleranceDualValue(LinearDualValueType * ToleranceDualValueIn)
{ToleranceDualValue = ToleranceDualValueIn;}

CharacteristicDesignatorType * CompositeSegmentDefinitionBaseType::getCharacteristicDesignator()
{return CharacteristicDesignator;}

void CompositeSegmentDefinitionBaseType::setCharacteristicDesignator(CharacteristicDesignatorType * CharacteristicDesignatorIn)
{CharacteristicDesignator = CharacteristicDesignatorIn;}

/* ***************************************************************** */

/* class CompositeSegmentLowerLevelEnumType

*/

CompositeSegmentLowerLevelEnumType::CompositeSegmentLowerLevelEnumType() :
  XmlNMTOKEN()
{
}

CompositeSegmentLowerLevelEnumType::CompositeSegmentLowerLevelEnumType(
 const char * valIn) :
  XmlNMTOKEN(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "SECOND") &&
           strcmp(val.c_str(), "THIRD") &&
           strcmp(val.c_str(), "FOURTH") &&
           strcmp(val.c_str(), "FIFTH"));
}

CompositeSegmentLowerLevelEnumType::~CompositeSegmentLowerLevelEnumType() {}

bool CompositeSegmentLowerLevelEnumType::CompositeSegmentLowerLevelEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "SECOND") &&
          strcmp(val.c_str(), "THIRD") &&
          strcmp(val.c_str(), "FOURTH") &&
          strcmp(val.c_str(), "FIFTH"));
}

void CompositeSegmentLowerLevelEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "CompositeSegmentLowerLevelEnumType");
}

void CompositeSegmentLowerLevelEnumType::printSelf(FILE * outFile)
{
  if (CompositeSegmentLowerLevelEnumTypeIsBad())
    {
      fprintf(stderr, "bad CompositeSegmentLowerLevelEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::printSelf(outFile);
}

void CompositeSegmentLowerLevelEnumType::oPrintSelf(FILE * outFile)
{
  if (CompositeSegmentLowerLevelEnumTypeIsBad())
    {
      fprintf(stderr, "bad CompositeSegmentLowerLevelEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class CompositeSegmentMeasurementBaseType

*/

CompositeSegmentMeasurementBaseType::CompositeSegmentMeasurementBaseType()
{
  Value = 0;
  MaxValue = 0;
  MinValue = 0;
  Status = 0;
  DRFTransformActualId = 0;
  ZoneDataSet = 0;
}

CompositeSegmentMeasurementBaseType::CompositeSegmentMeasurementBaseType(
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * DRFTransformActualIdIn,
 ZoneDataSetType * ZoneDataSetIn)
{
  Value = ValueIn;
  MaxValue = MaxValueIn;
  MinValue = MinValueIn;
  Status = StatusIn;
  DRFTransformActualId = DRFTransformActualIdIn;
  ZoneDataSet = ZoneDataSetIn;
}

CompositeSegmentMeasurementBaseType::~CompositeSegmentMeasurementBaseType()
{
  #ifndef NODESTRUCT
  delete Value;
  delete MaxValue;
  delete MinValue;
  delete Status;
  delete DRFTransformActualId;
  delete ZoneDataSet;
  #endif
}

void CompositeSegmentMeasurementBaseType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (DRFTransformActualId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DRFTransformActualId");
      DRFTransformActualId->printSelf(outFile);
      fprintf(outFile, "</DRFTransformActualId>\n");
    }
  if (ZoneDataSet)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ZoneDataSet");
      ZoneDataSet->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ZoneDataSet>\n");
    }
  doSpaces(-INDENT, outFile);
}

MeasuredLinearValueType * CompositeSegmentMeasurementBaseType::getValue()
{return Value;}

void CompositeSegmentMeasurementBaseType::setValue(MeasuredLinearValueType * ValueIn)
{Value = ValueIn;}

MeasuredLinearValueType * CompositeSegmentMeasurementBaseType::getMaxValue()
{return MaxValue;}

void CompositeSegmentMeasurementBaseType::setMaxValue(MeasuredLinearValueType * MaxValueIn)
{MaxValue = MaxValueIn;}

MeasuredLinearValueType * CompositeSegmentMeasurementBaseType::getMinValue()
{return MinValue;}

void CompositeSegmentMeasurementBaseType::setMinValue(MeasuredLinearValueType * MinValueIn)
{MinValue = MinValueIn;}

CharacteristicStatusType * CompositeSegmentMeasurementBaseType::getStatus()
{return Status;}

void CompositeSegmentMeasurementBaseType::setStatus(CharacteristicStatusType * StatusIn)
{Status = StatusIn;}

QIFReferenceType * CompositeSegmentMeasurementBaseType::getDRFTransformActualId()
{return DRFTransformActualId;}

void CompositeSegmentMeasurementBaseType::setDRFTransformActualId(QIFReferenceType * DRFTransformActualIdIn)
{DRFTransformActualId = DRFTransformActualIdIn;}

ZoneDataSetType * CompositeSegmentMeasurementBaseType::getZoneDataSet()
{return ZoneDataSet;}

void CompositeSegmentMeasurementBaseType::setZoneDataSet(ZoneDataSetType * ZoneDataSetIn)
{ZoneDataSet = ZoneDataSetIn;}

/* ***************************************************************** */

/* class CompositeSegmentPositionDefinitionType

*/

CompositeSegmentPositionDefinitionType::CompositeSegmentPositionDefinitionType() :
  CompositeSegmentDefinitionBaseType()
{
  MaterialCondition = 0;
  ZoneShape = 0;
  MaximumToleranceValue = 0;
  ProjectedToleranceZone = 0;
}

CompositeSegmentPositionDefinitionType::CompositeSegmentPositionDefinitionType(
 QIFReferenceFullType * DatumReferenceFrameIdIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 MaterialModifierEnumType * MaterialConditionIn,
 PositionZoneShapeType * ZoneShapeIn,
 LinearValueType * MaximumToleranceValueIn,
 LinearValueType * ProjectedToleranceZoneIn) :
  CompositeSegmentDefinitionBaseType(
    DatumReferenceFrameIdIn,
    ToleranceValueIn,
    ToleranceDualValueIn,
    CharacteristicDesignatorIn)
{
  MaterialCondition = MaterialConditionIn;
  ZoneShape = ZoneShapeIn;
  MaximumToleranceValue = MaximumToleranceValueIn;
  ProjectedToleranceZone = ProjectedToleranceZoneIn;
}

CompositeSegmentPositionDefinitionType::~CompositeSegmentPositionDefinitionType()
{
  #ifndef NODESTRUCT
  delete MaterialCondition;
  delete ZoneShape;
  delete MaximumToleranceValue;
  delete ProjectedToleranceZone;
  #endif
}

void CompositeSegmentPositionDefinitionType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (DatumReferenceFrameId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumReferenceFrameId");
      DatumReferenceFrameId->printSelf(outFile);
      fprintf(outFile, "</DatumReferenceFrameId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ToleranceValue");
  ToleranceValue->printSelf(outFile);
  fprintf(outFile, "</ToleranceValue>\n");
  if (ToleranceDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceDualValue");
      ToleranceDualValue->printSelf(outFile);
      fprintf(outFile, "</ToleranceDualValue>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<MaterialCondition");
  MaterialCondition->printSelf(outFile);
  fprintf(outFile, "</MaterialCondition>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<ZoneShape");
  ZoneShape->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ZoneShape>\n");
  if (MaximumToleranceValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaximumToleranceValue");
      MaximumToleranceValue->printSelf(outFile);
      fprintf(outFile, "</MaximumToleranceValue>\n");
    }
  if (ProjectedToleranceZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProjectedToleranceZone");
      ProjectedToleranceZone->printSelf(outFile);
      fprintf(outFile, "</ProjectedToleranceZone>\n");
    }
  doSpaces(-INDENT, outFile);
}

MaterialModifierEnumType * CompositeSegmentPositionDefinitionType::getMaterialCondition()
{return MaterialCondition;}

void CompositeSegmentPositionDefinitionType::setMaterialCondition(MaterialModifierEnumType * MaterialConditionIn)
{MaterialCondition = MaterialConditionIn;}

PositionZoneShapeType * CompositeSegmentPositionDefinitionType::getZoneShape()
{return ZoneShape;}

void CompositeSegmentPositionDefinitionType::setZoneShape(PositionZoneShapeType * ZoneShapeIn)
{ZoneShape = ZoneShapeIn;}

LinearValueType * CompositeSegmentPositionDefinitionType::getMaximumToleranceValue()
{return MaximumToleranceValue;}

void CompositeSegmentPositionDefinitionType::setMaximumToleranceValue(LinearValueType * MaximumToleranceValueIn)
{MaximumToleranceValue = MaximumToleranceValueIn;}

LinearValueType * CompositeSegmentPositionDefinitionType::getProjectedToleranceZone()
{return ProjectedToleranceZone;}

void CompositeSegmentPositionDefinitionType::setProjectedToleranceZone(LinearValueType * ProjectedToleranceZoneIn)
{ProjectedToleranceZone = ProjectedToleranceZoneIn;}

/* ***************************************************************** */

/* class CompositeSegmentPositionMeasurementType

*/

CompositeSegmentPositionMeasurementType::CompositeSegmentPositionMeasurementType() :
  CompositeSegmentMeasurementBaseType() {}

CompositeSegmentPositionMeasurementType::CompositeSegmentPositionMeasurementType(
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * DRFTransformActualIdIn,
 ZoneDataSetType * ZoneDataSetIn) :
  CompositeSegmentMeasurementBaseType(
    ValueIn,
    MaxValueIn,
    MinValueIn,
    StatusIn,
    DRFTransformActualIdIn,
    ZoneDataSetIn)
{}

CompositeSegmentPositionMeasurementType::~CompositeSegmentPositionMeasurementType() {}

void CompositeSegmentPositionMeasurementType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (DRFTransformActualId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DRFTransformActualId");
      DRFTransformActualId->printSelf(outFile);
      fprintf(outFile, "</DRFTransformActualId>\n");
    }
  if (ZoneDataSet)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ZoneDataSet");
      ZoneDataSet->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ZoneDataSet>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class CompositeSegmentProfileDefinitionType

*/

CompositeSegmentProfileDefinitionType::CompositeSegmentProfileDefinitionType() :
  CompositeSegmentDefinitionBaseType()
{
  OuterDisposition = 0;
}

CompositeSegmentProfileDefinitionType::CompositeSegmentProfileDefinitionType(
 QIFReferenceFullType * DatumReferenceFrameIdIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * OuterDispositionIn) :
  CompositeSegmentDefinitionBaseType(
    DatumReferenceFrameIdIn,
    ToleranceValueIn,
    ToleranceDualValueIn,
    CharacteristicDesignatorIn)
{
  OuterDisposition = OuterDispositionIn;
}

CompositeSegmentProfileDefinitionType::~CompositeSegmentProfileDefinitionType()
{
  #ifndef NODESTRUCT
  delete OuterDisposition;
  #endif
}

void CompositeSegmentProfileDefinitionType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (DatumReferenceFrameId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumReferenceFrameId");
      DatumReferenceFrameId->printSelf(outFile);
      fprintf(outFile, "</DatumReferenceFrameId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ToleranceValue");
  ToleranceValue->printSelf(outFile);
  fprintf(outFile, "</ToleranceValue>\n");
  if (ToleranceDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceDualValue");
      ToleranceDualValue->printSelf(outFile);
      fprintf(outFile, "</ToleranceDualValue>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (OuterDisposition)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OuterDisposition");
      OuterDisposition->printSelf(outFile);
      fprintf(outFile, "</OuterDisposition>\n");
    }
  doSpaces(-INDENT, outFile);
}

LinearValueType * CompositeSegmentProfileDefinitionType::getOuterDisposition()
{return OuterDisposition;}

void CompositeSegmentProfileDefinitionType::setOuterDisposition(LinearValueType * OuterDispositionIn)
{OuterDisposition = OuterDispositionIn;}

/* ***************************************************************** */

/* class CompositeSegmentProfileMeasurementType

*/

CompositeSegmentProfileMeasurementType::CompositeSegmentProfileMeasurementType() :
  CompositeSegmentMeasurementBaseType() {}

CompositeSegmentProfileMeasurementType::CompositeSegmentProfileMeasurementType(
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * DRFTransformActualIdIn,
 ZoneDataSetType * ZoneDataSetIn) :
  CompositeSegmentMeasurementBaseType(
    ValueIn,
    MaxValueIn,
    MinValueIn,
    StatusIn,
    DRFTransformActualIdIn,
    ZoneDataSetIn)
{}

CompositeSegmentProfileMeasurementType::~CompositeSegmentProfileMeasurementType() {}

void CompositeSegmentProfileMeasurementType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (DRFTransformActualId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DRFTransformActualId");
      DRFTransformActualId->printSelf(outFile);
      fprintf(outFile, "</DRFTransformActualId>\n");
    }
  if (ZoneDataSet)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ZoneDataSet");
      ZoneDataSet->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ZoneDataSet>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class CompositeSegmentSymmetryDefinitionType

*/

CompositeSegmentSymmetryDefinitionType::CompositeSegmentSymmetryDefinitionType() :
  CompositeSegmentDefinitionBaseType() {}

CompositeSegmentSymmetryDefinitionType::CompositeSegmentSymmetryDefinitionType(
 QIFReferenceFullType * DatumReferenceFrameIdIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  CompositeSegmentDefinitionBaseType(
    DatumReferenceFrameIdIn,
    ToleranceValueIn,
    ToleranceDualValueIn,
    CharacteristicDesignatorIn)
{}

CompositeSegmentSymmetryDefinitionType::~CompositeSegmentSymmetryDefinitionType() {}

void CompositeSegmentSymmetryDefinitionType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (DatumReferenceFrameId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumReferenceFrameId");
      DatumReferenceFrameId->printSelf(outFile);
      fprintf(outFile, "</DatumReferenceFrameId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ToleranceValue");
  ToleranceValue->printSelf(outFile);
  fprintf(outFile, "</ToleranceValue>\n");
  if (ToleranceDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceDualValue");
      ToleranceDualValue->printSelf(outFile);
      fprintf(outFile, "</ToleranceDualValue>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class CompositeSegmentSymmetryMeasurementType

*/

CompositeSegmentSymmetryMeasurementType::CompositeSegmentSymmetryMeasurementType() :
  CompositeSegmentMeasurementBaseType() {}

CompositeSegmentSymmetryMeasurementType::CompositeSegmentSymmetryMeasurementType(
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * DRFTransformActualIdIn,
 ZoneDataSetType * ZoneDataSetIn) :
  CompositeSegmentMeasurementBaseType(
    ValueIn,
    MaxValueIn,
    MinValueIn,
    StatusIn,
    DRFTransformActualIdIn,
    ZoneDataSetIn)
{}

CompositeSegmentSymmetryMeasurementType::~CompositeSegmentSymmetryMeasurementType() {}

void CompositeSegmentSymmetryMeasurementType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (DRFTransformActualId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DRFTransformActualId");
      DRFTransformActualId->printSelf(outFile);
      fprintf(outFile, "</DRFTransformActualId>\n");
    }
  if (ZoneDataSet)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ZoneDataSet");
      ZoneDataSet->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ZoneDataSet>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class ConcentricityCharacteristicDefinitionType

*/

ConcentricityCharacteristicDefinitionType::ConcentricityCharacteristicDefinitionType() :
  LocationCharacteristicDefinitionBaseType()
{
  ZoneShape = 0;
}

ConcentricityCharacteristicDefinitionType::ConcentricityCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 QIFReferenceFullType * DatumReferenceFrameIdIn,
 ConcentricityZoneShapeType * ZoneShapeIn) :
  LocationCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn,
    ToleranceValueIn,
    ToleranceDualValueIn,
    DatumReferenceFrameIdIn)
{
  ZoneShape = ZoneShapeIn;
}

ConcentricityCharacteristicDefinitionType::ConcentricityCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 QIFReferenceFullType * DatumReferenceFrameIdIn,
 ConcentricityZoneShapeType * ZoneShapeIn) :
  LocationCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn,
    ToleranceValueIn,
    ToleranceDualValueIn,
    DatumReferenceFrameIdIn)
{
  ZoneShape = ZoneShapeIn;
}

ConcentricityCharacteristicDefinitionType::~ConcentricityCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  delete ZoneShape;
  #endif
}

void ConcentricityCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (GeometricCharac_1050)
    {
  GeometricCharac_1050->printSelf(outFile);
    }
  if (DirectionFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DirectionFeature");
      DirectionFeature->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DirectionFeature>\n");
    }
  if (CollectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CollectionPlane");
      CollectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CollectionPlane>\n");
    }
  if (IntersectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IntersectionPlane");
      IntersectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</IntersectionPlane>\n");
    }
  if (OrientationPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OrientationPlane");
      OrientationPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OrientationPlane>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ToleranceValue");
  ToleranceValue->printSelf(outFile);
  fprintf(outFile, "</ToleranceValue>\n");
  if (ToleranceDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceDualValue");
      ToleranceDualValue->printSelf(outFile);
      fprintf(outFile, "</ToleranceDualValue>\n");
    }
  if (DatumReferenceFrameId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumReferenceFrameId");
      DatumReferenceFrameId->printSelf(outFile);
      fprintf(outFile, "</DatumReferenceFrameId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ZoneShape");
  ZoneShape->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ZoneShape>\n");
  doSpaces(-INDENT, outFile);
}

bool ConcentricityCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ConcentricityCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ConcentricityCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ConcentricityCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ConcentricityCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

ConcentricityZoneShapeType * ConcentricityCharacteristicDefinitionType::getZoneShape()
{return ZoneShape;}

void ConcentricityCharacteristicDefinitionType::setZoneShape(ConcentricityZoneShapeType * ZoneShapeIn)
{ZoneShape = ZoneShapeIn;}

/* ***************************************************************** */

/* class ConcentricityCharacteristicItemType

*/

ConcentricityCharacteristicItemType::ConcentricityCharacteristicItemType() :
  LocationCharacteristicItemBaseType()
{
}

ConcentricityCharacteristicItemType::ConcentricityCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LocationCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

ConcentricityCharacteristicItemType::ConcentricityCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LocationCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

ConcentricityCharacteristicItemType::~ConcentricityCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void ConcentricityCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool ConcentricityCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ConcentricityCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ConcentricityCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ConcentricityCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ConcentricityCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class ConcentricityCharacteristicMeasurementType

*/

ConcentricityCharacteristicMeasurementType::ConcentricityCharacteristicMeasurementType() :
  LocationCharacteristicMeasurementBaseType()
{
}

ConcentricityCharacteristicMeasurementType::ConcentricityCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 ZoneDataSetType * ZoneDataSetIn,
 XmlBoolean * DatumsOkIn) :
  LocationCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn,
    ZoneDataSetIn,
    DatumsOkIn)
{
}

ConcentricityCharacteristicMeasurementType::ConcentricityCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 ZoneDataSetType * ZoneDataSetIn,
 XmlBoolean * DatumsOkIn) :
  LocationCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn,
    ZoneDataSetIn,
    DatumsOkIn)
{
}

ConcentricityCharacteristicMeasurementType::~ConcentricityCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void ConcentricityCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  if (ZoneDataSet)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ZoneDataSet");
      ZoneDataSet->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ZoneDataSet>\n");
    }
  if (DatumsOk)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumsOk");
      DatumsOk->printSelf(outFile);
      fprintf(outFile, "</DatumsOk>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ConcentricityCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ConcentricityCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ConcentricityCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ConcentricityCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ConcentricityCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class ConcentricityCharacteristicNominalType

*/

ConcentricityCharacteristicNominalType::ConcentricityCharacteristicNominalType() :
  LocationCharacteristicNominalBaseType()
{
}

ConcentricityCharacteristicNominalType::ConcentricityCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  LocationCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

ConcentricityCharacteristicNominalType::ConcentricityCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  LocationCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

ConcentricityCharacteristicNominalType::~ConcentricityCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void ConcentricityCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ConcentricityCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ConcentricityCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ConcentricityCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ConcentricityCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ConcentricityCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class ConcentricityDiametricalZoneType

*/

ConcentricityDiametricalZoneType::ConcentricityDiametricalZoneType()
{}

ConcentricityDiametricalZoneType::~ConcentricityDiametricalZoneType() {}

void ConcentricityDiametricalZoneType::printSelf(FILE * outFile)
{
  fprintf(outFile, "/>\n");
}

/* ***************************************************************** */

/* class ConcentricityNonDiametricalZoneType

*/

ConcentricityNonDiametricalZoneType::ConcentricityNonDiametricalZoneType()
{}

ConcentricityNonDiametricalZoneType::~ConcentricityNonDiametricalZoneType() {}

void ConcentricityNonDiametricalZoneType::printSelf(FILE * outFile)
{
  fprintf(outFile, "/>\n");
}

/* ***************************************************************** */

/* class ConcentricitySphericalZoneType

*/

ConcentricitySphericalZoneType::ConcentricitySphericalZoneType()
{}

ConcentricitySphericalZoneType::~ConcentricitySphericalZoneType() {}

void ConcentricitySphericalZoneType::printSelf(FILE * outFile)
{
  fprintf(outFile, "/>\n");
}

/* ***************************************************************** */

/* class ConcentricityZoneShapeType

*/

ConcentricityZoneShapeType::ConcentricityZoneShapeType()
{
  ConcentricityZoneShapeTypePair = 0;
}

ConcentricityZoneShapeType::ConcentricityZoneShapeType(
 ConcentricityZoneShapeTypeChoicePair * ConcentricityZoneShapeTypePairIn)
{
  ConcentricityZoneShapeTypePair = ConcentricityZoneShapeTypePairIn;
}

ConcentricityZoneShapeType::~ConcentricityZoneShapeType()
{
  #ifndef NODESTRUCT
  delete ConcentricityZoneShapeTypePair;
  #endif
}

void ConcentricityZoneShapeType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  ConcentricityZoneShapeTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

ConcentricityZoneShapeTypeChoicePair * ConcentricityZoneShapeType::getConcentricityZoneShapeTypePair()
{return ConcentricityZoneShapeTypePair;}

void ConcentricityZoneShapeType::setConcentricityZoneShapeTypePair(ConcentricityZoneShapeTypeChoicePair * ConcentricityZoneShapeTypePairIn)
{ConcentricityZoneShapeTypePair = ConcentricityZoneShapeTypePairIn;}
ConcentricityZoneShapeTypeChoicePair::ConcentricityZoneShapeTypeChoicePair() {}

ConcentricityZoneShapeTypeChoicePair::ConcentricityZoneShapeTypeChoicePair(
 whichOne ConcentricityZoneShapeTypeTypeIn,
 ConcentricityZoneShapeTypeVal ConcentricityZoneShapeTypeValueIn)
{
  ConcentricityZoneShapeTypeType = ConcentricityZoneShapeTypeTypeIn;
  ConcentricityZoneShapeTypeValue = ConcentricityZoneShapeTypeValueIn;
}

ConcentricityZoneShapeTypeChoicePair::~ConcentricityZoneShapeTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (ConcentricityZoneShapeTypeType == SphericalZoneE)
    delete ConcentricityZoneShapeTypeValue.SphericalZone;
  else if (ConcentricityZoneShapeTypeType == DiametricalZoneE)
    delete ConcentricityZoneShapeTypeValue.DiametricalZone;
  else if (ConcentricityZoneShapeTypeType == NonDiametricalZoneE)
    delete ConcentricityZoneShapeTypeValue.NonDiametricalZone;
  #endif
}

void ConcentricityZoneShapeTypeChoicePair::printSelf(FILE * outFile)
{
  if (ConcentricityZoneShapeTypeType == SphericalZoneE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SphericalZone");
      ConcentricityZoneShapeTypeValue.SphericalZone->printSelf(outFile);
    }
  else if (ConcentricityZoneShapeTypeType == DiametricalZoneE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DiametricalZone");
      ConcentricityZoneShapeTypeValue.DiametricalZone->printSelf(outFile);
    }
  else if (ConcentricityZoneShapeTypeType == NonDiametricalZoneE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonDiametricalZone");
      ConcentricityZoneShapeTypeValue.NonDiametricalZone->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class ConicalTaperCharacteristicDefinitionType

*/

ConicalTaperCharacteristicDefinitionType::ConicalTaperCharacteristicDefinitionType() :
  LinearCharacteristicDefinitionBaseType()
{
}

ConicalTaperCharacteristicDefinitionType::ConicalTaperCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseTypePairIn) :
  LinearCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    LinearCharacteristicDefinitionBaseTypePairIn)
{
}

ConicalTaperCharacteristicDefinitionType::ConicalTaperCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseTypePairIn) :
  LinearCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    LinearCharacteristicDefinitionBaseTypePairIn)
{
}

ConicalTaperCharacteristicDefinitionType::~ConicalTaperCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void ConicalTaperCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (DimensionType)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionType");
      DimensionType->printSelf(outFile);
      fprintf(outFile, "</DimensionType>\n");
    }
  if (DimensionModifiers)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionModifiers");
      DimensionModifiers->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DimensionModifiers>\n");
    }
  LinearCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

bool ConicalTaperCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ConicalTaperCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ConicalTaperCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ConicalTaperCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ConicalTaperCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class ConicalTaperCharacteristicItemType

*/

ConicalTaperCharacteristicItemType::ConicalTaperCharacteristicItemType() :
  LinearCharacteristicItemBaseType()
{
}

ConicalTaperCharacteristicItemType::ConicalTaperCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LinearCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

ConicalTaperCharacteristicItemType::ConicalTaperCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LinearCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

ConicalTaperCharacteristicItemType::~ConicalTaperCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void ConicalTaperCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool ConicalTaperCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ConicalTaperCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ConicalTaperCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ConicalTaperCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ConicalTaperCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class ConicalTaperCharacteristicMeasurementType

*/

ConicalTaperCharacteristicMeasurementType::ConicalTaperCharacteristicMeasurementType() :
  LinearCharacteristicMeasurementBaseType()
{
  Distance = 0;
}

ConicalTaperCharacteristicMeasurementType::ConicalTaperCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 MeasuredLinearValueType * DistanceIn) :
  LinearCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
  Distance = DistanceIn;
}

ConicalTaperCharacteristicMeasurementType::ConicalTaperCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 MeasuredLinearValueType * DistanceIn) :
  LinearCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
  Distance = DistanceIn;
}

ConicalTaperCharacteristicMeasurementType::~ConicalTaperCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  delete Distance;
  #endif
}

void ConicalTaperCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  if (Distance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Distance");
      Distance->printSelf(outFile);
      fprintf(outFile, "</Distance>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ConicalTaperCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ConicalTaperCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ConicalTaperCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ConicalTaperCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ConicalTaperCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredLinearValueType * ConicalTaperCharacteristicMeasurementType::getDistance()
{return Distance;}

void ConicalTaperCharacteristicMeasurementType::setDistance(MeasuredLinearValueType * DistanceIn)
{Distance = DistanceIn;}

/* ***************************************************************** */

/* class ConicalTaperCharacteristicNominalType

*/

ConicalTaperCharacteristicNominalType::ConicalTaperCharacteristicNominalType() :
  LinearCharacteristicNominalBaseType()
{
  Distance = 0;
}

ConicalTaperCharacteristicNominalType::ConicalTaperCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn,
 LinearValueType * DistanceIn) :
  LinearCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn,
    TargetDualValueIn)
{
  Distance = DistanceIn;
}

ConicalTaperCharacteristicNominalType::ConicalTaperCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn,
 LinearValueType * DistanceIn) :
  LinearCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn,
    TargetDualValueIn)
{
  Distance = DistanceIn;
}

ConicalTaperCharacteristicNominalType::~ConicalTaperCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  delete Distance;
  #endif
}

void ConicalTaperCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  if (TargetDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetDualValue");
      TargetDualValue->printSelf(outFile);
      fprintf(outFile, "</TargetDualValue>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Distance");
  Distance->printSelf(outFile);
  fprintf(outFile, "</Distance>\n");
  doSpaces(-INDENT, outFile);
}

bool ConicalTaperCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ConicalTaperCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ConicalTaperCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ConicalTaperCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ConicalTaperCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LinearValueType * ConicalTaperCharacteristicNominalType::getDistance()
{return Distance;}

void ConicalTaperCharacteristicNominalType::setDistance(LinearValueType * DistanceIn)
{Distance = DistanceIn;}

/* ***************************************************************** */

/* class ConicityCharacteristicDefinitionType

*/

ConicityCharacteristicDefinitionType::ConicityCharacteristicDefinitionType() :
  FormCharacteristicDefinitionBaseType()
{
  ToleranceValue = 0;
  ToleranceDualValue = 0;
}

ConicityCharacteristicDefinitionType::ConicityCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn) :
  FormCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn)
{
  ToleranceValue = ToleranceValueIn;
  ToleranceDualValue = ToleranceDualValueIn;
}

ConicityCharacteristicDefinitionType::ConicityCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn) :
  FormCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn)
{
  ToleranceValue = ToleranceValueIn;
  ToleranceDualValue = ToleranceDualValueIn;
}

ConicityCharacteristicDefinitionType::~ConicityCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  delete ToleranceValue;
  delete ToleranceDualValue;
  #endif
}

void ConicityCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (GeometricCharac_1050)
    {
  GeometricCharac_1050->printSelf(outFile);
    }
  if (DirectionFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DirectionFeature");
      DirectionFeature->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DirectionFeature>\n");
    }
  if (CollectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CollectionPlane");
      CollectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CollectionPlane>\n");
    }
  if (IntersectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IntersectionPlane");
      IntersectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</IntersectionPlane>\n");
    }
  if (OrientationPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OrientationPlane");
      OrientationPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OrientationPlane>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ToleranceValue");
  ToleranceValue->printSelf(outFile);
  fprintf(outFile, "</ToleranceValue>\n");
  if (ToleranceDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceDualValue");
      ToleranceDualValue->printSelf(outFile);
      fprintf(outFile, "</ToleranceDualValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ConicityCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ConicityCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ConicityCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ConicityCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ConicityCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LinearValueType * ConicityCharacteristicDefinitionType::getToleranceValue()
{return ToleranceValue;}

void ConicityCharacteristicDefinitionType::setToleranceValue(LinearValueType * ToleranceValueIn)
{ToleranceValue = ToleranceValueIn;}

LinearDualValueType * ConicityCharacteristicDefinitionType::getToleranceDualValue()
{return ToleranceDualValue;}

void ConicityCharacteristicDefinitionType::setToleranceDualValue(LinearDualValueType * ToleranceDualValueIn)
{ToleranceDualValue = ToleranceDualValueIn;}

/* ***************************************************************** */

/* class ConicityCharacteristicItemType

*/

ConicityCharacteristicItemType::ConicityCharacteristicItemType() :
  FormCharacteristicItemBaseType()
{
}

ConicityCharacteristicItemType::ConicityCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  FormCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

ConicityCharacteristicItemType::ConicityCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  FormCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

ConicityCharacteristicItemType::~ConicityCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void ConicityCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool ConicityCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ConicityCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ConicityCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ConicityCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ConicityCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class ConicityCharacteristicMeasurementType

*/

ConicityCharacteristicMeasurementType::ConicityCharacteristicMeasurementType() :
  FormCharacteristicMeasurementBaseType()
{
}

ConicityCharacteristicMeasurementType::ConicityCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  FormCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

ConicityCharacteristicMeasurementType::ConicityCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  FormCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

ConicityCharacteristicMeasurementType::~ConicityCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void ConicityCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ConicityCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ConicityCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ConicityCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ConicityCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ConicityCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class ConicityCharacteristicNominalType

*/

ConicityCharacteristicNominalType::ConicityCharacteristicNominalType() :
  FormCharacteristicNominalBaseType()
{
}

ConicityCharacteristicNominalType::ConicityCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  FormCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

ConicityCharacteristicNominalType::ConicityCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  FormCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

ConicityCharacteristicNominalType::~ConicityCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void ConicityCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ConicityCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ConicityCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ConicityCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ConicityCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ConicityCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class CoordinateCharacteristicDefinitionBaseType

*/

CoordinateCharacteristicDefinitionBaseType::CoordinateCharacteristicDefinitionBaseType() :
  DimensionalCharacteristicDefinitionBaseType()
{
}

CoordinateCharacteristicDefinitionBaseType::CoordinateCharacteristicDefinitionBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn) :
  DimensionalCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn)
{
}

CoordinateCharacteristicDefinitionBaseType::CoordinateCharacteristicDefinitionBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn) :
  DimensionalCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn)
{
}

CoordinateCharacteristicDefinitionBaseType::~CoordinateCharacteristicDefinitionBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void CoordinateCharacteristicDefinitionBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (DimensionType)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionType");
      DimensionType->printSelf(outFile);
      fprintf(outFile, "</DimensionType>\n");
    }
  if (DimensionModifiers)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionModifiers");
      DimensionModifiers->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DimensionModifiers>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CoordinateCharacteristicDefinitionBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CoordinateCharacteristicDefinitionBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CoordinateCharacteristicDefinitionBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CoordinateCharacteristicDefinitionBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CoordinateCharacteristicDefinitionBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class CoordinateCharacteristicItemBaseType

*/

CoordinateCharacteristicItemBaseType::CoordinateCharacteristicItemBaseType() :
  DimensionalCharacteristicItemBaseType()
{
}

CoordinateCharacteristicItemBaseType::CoordinateCharacteristicItemBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  DimensionalCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

CoordinateCharacteristicItemBaseType::CoordinateCharacteristicItemBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  DimensionalCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

CoordinateCharacteristicItemBaseType::~CoordinateCharacteristicItemBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void CoordinateCharacteristicItemBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool CoordinateCharacteristicItemBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CoordinateCharacteristicItemBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CoordinateCharacteristicItemBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CoordinateCharacteristicItemBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CoordinateCharacteristicItemBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class CoordinateCharacteristicMeasurementBaseType

*/

CoordinateCharacteristicMeasurementBaseType::CoordinateCharacteristicMeasurementBaseType() :
  DimensionalCharacteristicMeasurementBaseType()
{
  TypeOfCoordinates = 0;
}

CoordinateCharacteristicMeasurementBaseType::CoordinateCharacteristicMeasurementBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 TypeOfCoordinatesType * TypeOfCoordinatesIn) :
  DimensionalCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  TypeOfCoordinates = TypeOfCoordinatesIn;
}

CoordinateCharacteristicMeasurementBaseType::CoordinateCharacteristicMeasurementBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 TypeOfCoordinatesType * TypeOfCoordinatesIn) :
  DimensionalCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  TypeOfCoordinates = TypeOfCoordinatesIn;
}

CoordinateCharacteristicMeasurementBaseType::~CoordinateCharacteristicMeasurementBaseType()
{
  #ifndef NODESTRUCT
  delete TypeOfCoordinates;
  #endif
}

void CoordinateCharacteristicMeasurementBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<TypeOfCoordinates");
  TypeOfCoordinates->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</TypeOfCoordinates>\n");
  doSpaces(-INDENT, outFile);
}

bool CoordinateCharacteristicMeasurementBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CoordinateCharacteristicMeasurementBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CoordinateCharacteristicMeasurementBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CoordinateCharacteristicMeasurementBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CoordinateCharacteristicMeasurementBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

TypeOfCoordinatesType * CoordinateCharacteristicMeasurementBaseType::getTypeOfCoordinates()
{return TypeOfCoordinates;}

void CoordinateCharacteristicMeasurementBaseType::setTypeOfCoordinates(TypeOfCoordinatesType * TypeOfCoordinatesIn)
{TypeOfCoordinates = TypeOfCoordinatesIn;}

/* ***************************************************************** */

/* class CoordinateCharacteristicNominalBaseType

*/

CoordinateCharacteristicNominalBaseType::CoordinateCharacteristicNominalBaseType() :
  DimensionalCharacteristicNominalBaseType()
{
}

CoordinateCharacteristicNominalBaseType::CoordinateCharacteristicNominalBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  DimensionalCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

CoordinateCharacteristicNominalBaseType::CoordinateCharacteristicNominalBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  DimensionalCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

CoordinateCharacteristicNominalBaseType::~CoordinateCharacteristicNominalBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void CoordinateCharacteristicNominalBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CoordinateCharacteristicNominalBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CoordinateCharacteristicNominalBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CoordinateCharacteristicNominalBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CoordinateCharacteristicNominalBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CoordinateCharacteristicNominalBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class CriticalityAreaEnumType

*/

CriticalityAreaEnumType::CriticalityAreaEnumType() :
  XmlNMTOKEN()
{
}

CriticalityAreaEnumType::CriticalityAreaEnumType(
 const char * valIn) :
  XmlNMTOKEN(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "SAFETY") &&
           strcmp(val.c_str(), "MISSION") &&
           strcmp(val.c_str(), "FIT") &&
           strcmp(val.c_str(), "FUNCTION") &&
           strcmp(val.c_str(), "APPEARANCE") &&
           strcmp(val.c_str(), "UNDEFINED"));
}

CriticalityAreaEnumType::~CriticalityAreaEnumType() {}

bool CriticalityAreaEnumType::CriticalityAreaEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "SAFETY") &&
          strcmp(val.c_str(), "MISSION") &&
          strcmp(val.c_str(), "FIT") &&
          strcmp(val.c_str(), "FUNCTION") &&
          strcmp(val.c_str(), "APPEARANCE") &&
          strcmp(val.c_str(), "UNDEFINED"));
}

void CriticalityAreaEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "CriticalityAreaEnumType");
}

void CriticalityAreaEnumType::printSelf(FILE * outFile)
{
  if (CriticalityAreaEnumTypeIsBad())
    {
      fprintf(stderr, "bad CriticalityAreaEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::printSelf(outFile);
}

void CriticalityAreaEnumType::oPrintSelf(FILE * outFile)
{
  if (CriticalityAreaEnumTypeIsBad())
    {
      fprintf(stderr, "bad CriticalityAreaEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class CriticalityLevelEnumType

*/

CriticalityLevelEnumType::CriticalityLevelEnumType() :
  XmlNMTOKEN()
{
}

CriticalityLevelEnumType::CriticalityLevelEnumType(
 const char * valIn) :
  XmlNMTOKEN(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "MINOR") &&
           strcmp(val.c_str(), "MAJOR") &&
           strcmp(val.c_str(), "CRITICAL") &&
           strcmp(val.c_str(), "KEY") &&
           strcmp(val.c_str(), "UNDEFINED"));
}

CriticalityLevelEnumType::~CriticalityLevelEnumType() {}

bool CriticalityLevelEnumType::CriticalityLevelEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "MINOR") &&
          strcmp(val.c_str(), "MAJOR") &&
          strcmp(val.c_str(), "CRITICAL") &&
          strcmp(val.c_str(), "KEY") &&
          strcmp(val.c_str(), "UNDEFINED"));
}

void CriticalityLevelEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "CriticalityLevelEnumType");
}

void CriticalityLevelEnumType::printSelf(FILE * outFile)
{
  if (CriticalityLevelEnumTypeIsBad())
    {
      fprintf(stderr, "bad CriticalityLevelEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::printSelf(outFile);
}

void CriticalityLevelEnumType::oPrintSelf(FILE * outFile)
{
  if (CriticalityLevelEnumTypeIsBad())
    {
      fprintf(stderr, "bad CriticalityLevelEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class CriticalityType

*/

CriticalityType::CriticalityType()
{
  CriticalityType_1044 = 0;
  CriticalityType_1045 = 0;
}

CriticalityType::CriticalityType(
 CriticalityType_1044_Type * CriticalityType_1044In,
 CriticalityType_1045_Type * CriticalityType_1045In)
{
  CriticalityType_1044 = CriticalityType_1044In;
  CriticalityType_1045 = CriticalityType_1045In;
}

CriticalityType::~CriticalityType()
{
  #ifndef NODESTRUCT
  delete CriticalityType_1044;
  delete CriticalityType_1045;
  #endif
}

void CriticalityType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  CriticalityType_1044->printSelf(outFile);
  if (CriticalityType_1045)
    {
  CriticalityType_1045->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

CriticalityType_1044_Type * CriticalityType::getCriticalityType_1044()
{return CriticalityType_1044;}

void CriticalityType::setCriticalityType_1044(CriticalityType_1044_Type * CriticalityType_1044In)
{CriticalityType_1044 = CriticalityType_1044In;}

CriticalityType_1045_Type * CriticalityType::getCriticalityType_1045()
{return CriticalityType_1045;}

void CriticalityType::setCriticalityType_1045(CriticalityType_1045_Type * CriticalityType_1045In)
{CriticalityType_1045 = CriticalityType_1045In;}

/* ***************************************************************** */

/* class CurveLengthCharacteristicDefinitionType

*/

CurveLengthCharacteristicDefinitionType::CurveLengthCharacteristicDefinitionType() :
  LinearCharacteristicDefinitionBaseType()
{
}

CurveLengthCharacteristicDefinitionType::CurveLengthCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseTypePairIn) :
  LinearCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    LinearCharacteristicDefinitionBaseTypePairIn)
{
}

CurveLengthCharacteristicDefinitionType::CurveLengthCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseTypePairIn) :
  LinearCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    LinearCharacteristicDefinitionBaseTypePairIn)
{
}

CurveLengthCharacteristicDefinitionType::~CurveLengthCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void CurveLengthCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (DimensionType)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionType");
      DimensionType->printSelf(outFile);
      fprintf(outFile, "</DimensionType>\n");
    }
  if (DimensionModifiers)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionModifiers");
      DimensionModifiers->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DimensionModifiers>\n");
    }
  LinearCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

bool CurveLengthCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CurveLengthCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CurveLengthCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CurveLengthCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CurveLengthCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class CurveLengthCharacteristicItemType

*/

CurveLengthCharacteristicItemType::CurveLengthCharacteristicItemType() :
  LinearCharacteristicItemBaseType()
{
}

CurveLengthCharacteristicItemType::CurveLengthCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LinearCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

CurveLengthCharacteristicItemType::CurveLengthCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LinearCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

CurveLengthCharacteristicItemType::~CurveLengthCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void CurveLengthCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool CurveLengthCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CurveLengthCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CurveLengthCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CurveLengthCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CurveLengthCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class CurveLengthCharacteristicMeasurementType

*/

CurveLengthCharacteristicMeasurementType::CurveLengthCharacteristicMeasurementType() :
  LinearCharacteristicMeasurementBaseType()
{
}

CurveLengthCharacteristicMeasurementType::CurveLengthCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  LinearCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

CurveLengthCharacteristicMeasurementType::CurveLengthCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  LinearCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

CurveLengthCharacteristicMeasurementType::~CurveLengthCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void CurveLengthCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CurveLengthCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CurveLengthCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CurveLengthCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CurveLengthCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CurveLengthCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class CurveLengthCharacteristicNominalType

*/

CurveLengthCharacteristicNominalType::CurveLengthCharacteristicNominalType() :
  LinearCharacteristicNominalBaseType()
{
}

CurveLengthCharacteristicNominalType::CurveLengthCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn) :
  LinearCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn,
    TargetDualValueIn)
{
}

CurveLengthCharacteristicNominalType::CurveLengthCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn) :
  LinearCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn,
    TargetDualValueIn)
{
}

CurveLengthCharacteristicNominalType::~CurveLengthCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void CurveLengthCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  if (TargetDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetDualValue");
      TargetDualValue->printSelf(outFile);
      fprintf(outFile, "</TargetDualValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CurveLengthCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CurveLengthCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CurveLengthCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CurveLengthCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CurveLengthCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class CylindricityCharacteristicDefinitionType

*/

CylindricityCharacteristicDefinitionType::CylindricityCharacteristicDefinitionType() :
  FormCharacteristicDefinitionBaseType()
{
  CylindricityCharacteristicDefinitionTypePair = 0;
}

CylindricityCharacteristicDefinitionType::CylindricityCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 CylindricityCharacteristicDefinitionTypeChoicePair * CylindricityCharacteristicDefinitionTypePairIn) :
  FormCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn)
{
  CylindricityCharacteristicDefinitionTypePair = CylindricityCharacteristicDefinitionTypePairIn;
}

CylindricityCharacteristicDefinitionType::CylindricityCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 CylindricityCharacteristicDefinitionTypeChoicePair * CylindricityCharacteristicDefinitionTypePairIn) :
  FormCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn)
{
  CylindricityCharacteristicDefinitionTypePair = CylindricityCharacteristicDefinitionTypePairIn;
}

CylindricityCharacteristicDefinitionType::~CylindricityCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  delete CylindricityCharacteristicDefinitionTypePair;
  #endif
}

void CylindricityCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (GeometricCharac_1050)
    {
  GeometricCharac_1050->printSelf(outFile);
    }
  if (DirectionFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DirectionFeature");
      DirectionFeature->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DirectionFeature>\n");
    }
  if (CollectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CollectionPlane");
      CollectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CollectionPlane>\n");
    }
  if (IntersectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IntersectionPlane");
      IntersectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</IntersectionPlane>\n");
    }
  if (OrientationPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OrientationPlane");
      OrientationPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OrientationPlane>\n");
    }
  CylindricityCharacteristicDefinitionTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}
CylindricityCharacteristicDefinitionTypeChoicePair * CylindricityCharacteristicDefinitionType::getCylindricityCharacteristicDefinitionTypeChoicePair()
{return CylindricityCharacteristicDefinitionTypePair;}

void CylindricityCharacteristicDefinitionType::setCylindricityCharacteristicDefinitionTypeChoicePair(CylindricityCharacteristicDefinitionTypeChoicePair * CylindricityCharacteristicDefinitionTypePairIn)
{CylindricityCharacteristicDefinitionTypePair = CylindricityCharacteristicDefinitionTypePairIn;}

/* ***************************************************************** */

CylindricityCharacteristicDefinitionTypeChoicePair::CylindricityCharacteristicDefinitionTypeChoicePair() {}

CylindricityCharacteristicDefinitionTypeChoicePair::CylindricityCharacteristicDefinitionTypeChoicePair(
 whichOne CylindricityCharacteristicDefinitionTypeTypeIn,
 CylindricityCharacteristicDefinitionTypeVal CylindricityCharacteristicDefinitionTypeValueIn)
{
  CylindricityCharacteristicDefinitionTypeType = CylindricityCharacteristicDefinitionTypeTypeIn;
  CylindricityCharacteristicDefinitionTypeValue = CylindricityCharacteristicDefinitionTypeValueIn;
}

CylindricityCharacteristicDefinitionTypeChoicePair::~CylindricityCharacteristicDefinitionTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (CylindricityCharacteristicDefinitionTypeType == CylindricityCha_1046E)
    delete CylindricityCharacteristicDefinitionTypeValue.CylindricityCha_1046;
  else if (CylindricityCharacteristicDefinitionTypeType == CylindricityCha_1047E)
    delete CylindricityCharacteristicDefinitionTypeValue.CylindricityCha_1047;
  #endif
}

void CylindricityCharacteristicDefinitionTypeChoicePair::printSelf(FILE * outFile)
{
  if (CylindricityCharacteristicDefinitionTypeType == CylindricityCha_1046E)
    {
      CylindricityCharacteristicDefinitionTypeValue.CylindricityCha_1046->printSelf(outFile);
    }
  else if (CylindricityCharacteristicDefinitionTypeType == CylindricityCha_1047E)
    {
      CylindricityCharacteristicDefinitionTypeValue.CylindricityCha_1047->printSelf(outFile);
    }
}

bool CylindricityCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CylindricityCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CylindricityCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CylindricityCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CylindricityCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class CylindricityCharacteristicItemType

*/

CylindricityCharacteristicItemType::CylindricityCharacteristicItemType() :
  FormCharacteristicItemBaseType()
{
}

CylindricityCharacteristicItemType::CylindricityCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  FormCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

CylindricityCharacteristicItemType::CylindricityCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  FormCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

CylindricityCharacteristicItemType::~CylindricityCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void CylindricityCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool CylindricityCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CylindricityCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CylindricityCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CylindricityCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CylindricityCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class CylindricityCharacteristicMeasurementType

*/

CylindricityCharacteristicMeasurementType::CylindricityCharacteristicMeasurementType() :
  FormCharacteristicMeasurementBaseType()
{
  MaxCylindricity = 0;
  CylindricityCha_1048 = 0;
}

CylindricityCharacteristicMeasurementType::CylindricityCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 MeasuredLinearValueType * MaxCylindricityIn,
 CylindricityCha_1048_Type * CylindricityCha_1048In) :
  FormCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
  MaxCylindricity = MaxCylindricityIn;
  CylindricityCha_1048 = CylindricityCha_1048In;
}

CylindricityCharacteristicMeasurementType::CylindricityCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 MeasuredLinearValueType * MaxCylindricityIn,
 CylindricityCha_1048_Type * CylindricityCha_1048In) :
  FormCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
  MaxCylindricity = MaxCylindricityIn;
  CylindricityCha_1048 = CylindricityCha_1048In;
}

CylindricityCharacteristicMeasurementType::~CylindricityCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  delete MaxCylindricity;
  delete CylindricityCha_1048;
  #endif
}

void CylindricityCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  if (MaxCylindricity)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxCylindricity");
      MaxCylindricity->printSelf(outFile);
      fprintf(outFile, "</MaxCylindricity>\n");
    }
  if (CylindricityCha_1048)
    {
      CylindricityCha_1048->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool CylindricityCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CylindricityCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CylindricityCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CylindricityCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CylindricityCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredLinearValueType * CylindricityCharacteristicMeasurementType::getMaxCylindricity()
{return MaxCylindricity;}

void CylindricityCharacteristicMeasurementType::setMaxCylindricity(MeasuredLinearValueType * MaxCylindricityIn)
{MaxCylindricity = MaxCylindricityIn;}

CylindricityCha_1048_Type * CylindricityCharacteristicMeasurementType::getCylindricityCha_1048()
{return CylindricityCha_1048;}

void CylindricityCharacteristicMeasurementType::setCylindricityCha_1048(CylindricityCha_1048_Type * CylindricityCha_1048In)
{CylindricityCha_1048 = CylindricityCha_1048In;}

/* ***************************************************************** */

/* class CylindricityCharacteristicNominalType

*/

CylindricityCharacteristicNominalType::CylindricityCharacteristicNominalType() :
  FormCharacteristicNominalBaseType()
{
}

CylindricityCharacteristicNominalType::CylindricityCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  FormCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

CylindricityCharacteristicNominalType::CylindricityCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  FormCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

CylindricityCharacteristicNominalType::~CylindricityCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void CylindricityCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CylindricityCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CylindricityCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CylindricityCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CylindricityCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CylindricityCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class DepthCharacteristicDefinitionType

*/

DepthCharacteristicDefinitionType::DepthCharacteristicDefinitionType() :
  LinearCharacteristicDefinitionBaseType()
{
}

DepthCharacteristicDefinitionType::DepthCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseTypePairIn) :
  LinearCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    LinearCharacteristicDefinitionBaseTypePairIn)
{
}

DepthCharacteristicDefinitionType::DepthCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseTypePairIn) :
  LinearCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    LinearCharacteristicDefinitionBaseTypePairIn)
{
}

DepthCharacteristicDefinitionType::~DepthCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void DepthCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (DimensionType)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionType");
      DimensionType->printSelf(outFile);
      fprintf(outFile, "</DimensionType>\n");
    }
  if (DimensionModifiers)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionModifiers");
      DimensionModifiers->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DimensionModifiers>\n");
    }
  LinearCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

bool DepthCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in DepthCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in DepthCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in DepthCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in DepthCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class DepthCharacteristicItemType

*/

DepthCharacteristicItemType::DepthCharacteristicItemType() :
  LinearCharacteristicItemBaseType()
{
}

DepthCharacteristicItemType::DepthCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LinearCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

DepthCharacteristicItemType::DepthCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LinearCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

DepthCharacteristicItemType::~DepthCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void DepthCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool DepthCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in DepthCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in DepthCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in DepthCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in DepthCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class DepthCharacteristicMeasurementType

*/

DepthCharacteristicMeasurementType::DepthCharacteristicMeasurementType() :
  LinearCharacteristicMeasurementBaseType()
{
}

DepthCharacteristicMeasurementType::DepthCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  LinearCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

DepthCharacteristicMeasurementType::DepthCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  LinearCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

DepthCharacteristicMeasurementType::~DepthCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void DepthCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool DepthCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in DepthCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in DepthCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in DepthCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in DepthCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class DepthCharacteristicNominalType

*/

DepthCharacteristicNominalType::DepthCharacteristicNominalType() :
  LinearCharacteristicNominalBaseType()
{
}

DepthCharacteristicNominalType::DepthCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn) :
  LinearCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn,
    TargetDualValueIn)
{
}

DepthCharacteristicNominalType::DepthCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn) :
  LinearCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn,
    TargetDualValueIn)
{
}

DepthCharacteristicNominalType::~DepthCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void DepthCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  if (TargetDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetDualValue");
      TargetDualValue->printSelf(outFile);
      fprintf(outFile, "</TargetDualValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool DepthCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in DepthCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in DepthCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in DepthCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in DepthCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class DiameterCharacteristicDefinitionType

*/

DiameterCharacteristicDefinitionType::DiameterCharacteristicDefinitionType() :
  DimensionalCharacteristicDefinitionBaseType()
{
  DiameterCharacteristicDefinitionTypePair = 0;
}

DiameterCharacteristicDefinitionType::DiameterCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 DiameterCharacteristicDefinitionTypeChoicePair * DiameterCharacteristicDefinitionTypePairIn) :
  DimensionalCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn)
{
  DiameterCharacteristicDefinitionTypePair = DiameterCharacteristicDefinitionTypePairIn;
}

DiameterCharacteristicDefinitionType::DiameterCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 DiameterCharacteristicDefinitionTypeChoicePair * DiameterCharacteristicDefinitionTypePairIn) :
  DimensionalCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn)
{
  DiameterCharacteristicDefinitionTypePair = DiameterCharacteristicDefinitionTypePairIn;
}

DiameterCharacteristicDefinitionType::~DiameterCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  delete DiameterCharacteristicDefinitionTypePair;
  #endif
}

void DiameterCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (DimensionType)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionType");
      DimensionType->printSelf(outFile);
      fprintf(outFile, "</DimensionType>\n");
    }
  if (DimensionModifiers)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionModifiers");
      DimensionModifiers->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DimensionModifiers>\n");
    }
  DiameterCharacteristicDefinitionTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}
DiameterCharacteristicDefinitionTypeChoicePair * DiameterCharacteristicDefinitionType::getDiameterCharacteristicDefinitionTypeChoicePair()
{return DiameterCharacteristicDefinitionTypePair;}

void DiameterCharacteristicDefinitionType::setDiameterCharacteristicDefinitionTypeChoicePair(DiameterCharacteristicDefinitionTypeChoicePair * DiameterCharacteristicDefinitionTypePairIn)
{DiameterCharacteristicDefinitionTypePair = DiameterCharacteristicDefinitionTypePairIn;}

/* ***************************************************************** */

DiameterCharacteristicDefinitionTypeChoicePair::DiameterCharacteristicDefinitionTypeChoicePair() {}

DiameterCharacteristicDefinitionTypeChoicePair::DiameterCharacteristicDefinitionTypeChoicePair(
 whichOne DiameterCharacteristicDefinitionTypeTypeIn,
 DiameterCharacteristicDefinitionTypeVal DiameterCharacteristicDefinitionTypeValueIn)
{
  DiameterCharacteristicDefinitionTypeType = DiameterCharacteristicDefinitionTypeTypeIn;
  DiameterCharacteristicDefinitionTypeValue = DiameterCharacteristicDefinitionTypeValueIn;
}

DiameterCharacteristicDefinitionTypeChoicePair::~DiameterCharacteristicDefinitionTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (DiameterCharacteristicDefinitionTypeType == ToleranceE)
    delete DiameterCharacteristicDefinitionTypeValue.Tolerance;
  else if (DiameterCharacteristicDefinitionTypeType == LimitsAndFitsSpecificationE)
    delete DiameterCharacteristicDefinitionTypeValue.LimitsAndFitsSpecification;
  else if (DiameterCharacteristicDefinitionTypeType == NonToleranceE)
    delete DiameterCharacteristicDefinitionTypeValue.NonTolerance;
  #endif
}

void DiameterCharacteristicDefinitionTypeChoicePair::printSelf(FILE * outFile)
{
  if (DiameterCharacteristicDefinitionTypeType == ToleranceE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Tolerance");
      DiameterCharacteristicDefinitionTypeValue.Tolerance->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Tolerance>\n");
    }
  else if (DiameterCharacteristicDefinitionTypeType == LimitsAndFitsSpecificationE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LimitsAndFitsSpecification");
      DiameterCharacteristicDefinitionTypeValue.LimitsAndFitsSpecification->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LimitsAndFitsSpecification>\n");
    }
  else if (DiameterCharacteristicDefinitionTypeType == NonToleranceE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonTolerance");
      DiameterCharacteristicDefinitionTypeValue.NonTolerance->printSelf(outFile);
      fprintf(outFile, "</NonTolerance>\n");
    }
}

bool DiameterCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in DiameterCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in DiameterCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in DiameterCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in DiameterCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class DiameterCharacteristicItemType

*/

DiameterCharacteristicItemType::DiameterCharacteristicItemType() :
  LinearCharacteristicItemBaseType()
{
}

DiameterCharacteristicItemType::DiameterCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LinearCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

DiameterCharacteristicItemType::DiameterCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LinearCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

DiameterCharacteristicItemType::~DiameterCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void DiameterCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool DiameterCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in DiameterCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in DiameterCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in DiameterCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in DiameterCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class DiameterCharacteristicMeasurementType

*/

DiameterCharacteristicMeasurementType::DiameterCharacteristicMeasurementType() :
  LinearCharacteristicMeasurementBaseType()
{
}

DiameterCharacteristicMeasurementType::DiameterCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  LinearCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

DiameterCharacteristicMeasurementType::DiameterCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  LinearCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

DiameterCharacteristicMeasurementType::~DiameterCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void DiameterCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool DiameterCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in DiameterCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in DiameterCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in DiameterCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in DiameterCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class DiameterCharacteristicNominalType

*/

DiameterCharacteristicNominalType::DiameterCharacteristicNominalType() :
  LinearCharacteristicNominalBaseType()
{
}

DiameterCharacteristicNominalType::DiameterCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn) :
  LinearCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn,
    TargetDualValueIn)
{
}

DiameterCharacteristicNominalType::DiameterCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn) :
  LinearCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn,
    TargetDualValueIn)
{
}

DiameterCharacteristicNominalType::~DiameterCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void DiameterCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  if (TargetDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetDualValue");
      TargetDualValue->printSelf(outFile);
      fprintf(outFile, "</TargetDualValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool DiameterCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in DiameterCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in DiameterCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in DiameterCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in DiameterCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class DimensionalCharacteristicDefinitionBaseType

*/

DimensionalCharacteristicDefinitionBaseType::DimensionalCharacteristicDefinitionBaseType() :
  CharacteristicDefinitionBaseType()
{
  DimensionType = 0;
  DimensionModifiers = 0;
}

DimensionalCharacteristicDefinitionBaseType::DimensionalCharacteristicDefinitionBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn) :
  CharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
  DimensionType = DimensionTypeIn;
  DimensionModifiers = DimensionModifiersIn;
}

DimensionalCharacteristicDefinitionBaseType::DimensionalCharacteristicDefinitionBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn) :
  CharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
  DimensionType = DimensionTypeIn;
  DimensionModifiers = DimensionModifiersIn;
}

DimensionalCharacteristicDefinitionBaseType::~DimensionalCharacteristicDefinitionBaseType()
{
  #ifndef NODESTRUCT
  delete DimensionType;
  delete DimensionModifiers;
  #endif
}

void DimensionalCharacteristicDefinitionBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (DimensionType)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionType");
      DimensionType->printSelf(outFile);
      fprintf(outFile, "</DimensionType>\n");
    }
  if (DimensionModifiers)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionModifiers");
      DimensionModifiers->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DimensionModifiers>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool DimensionalCharacteristicDefinitionBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in DimensionalCharacteristicDefinitionBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in DimensionalCharacteristicDefinitionBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in DimensionalCharacteristicDefinitionBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in DimensionalCharacteristicDefinitionBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

DimensionModifierEnumType * DimensionalCharacteristicDefinitionBaseType::getDimensionType()
{return DimensionType;}

void DimensionalCharacteristicDefinitionBaseType::setDimensionType(DimensionModifierEnumType * DimensionTypeIn)
{DimensionType = DimensionTypeIn;}

DimensionModifiersType * DimensionalCharacteristicDefinitionBaseType::getDimensionModifiers()
{return DimensionModifiers;}

void DimensionalCharacteristicDefinitionBaseType::setDimensionModifiers(DimensionModifiersType * DimensionModifiersIn)
{DimensionModifiers = DimensionModifiersIn;}

/* ***************************************************************** */

/* class DimensionalCharacteristicItemBaseType

*/

DimensionalCharacteristicItemBaseType::DimensionalCharacteristicItemBaseType() :
  CharacteristicItemBaseType()
{
}

DimensionalCharacteristicItemBaseType::DimensionalCharacteristicItemBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  CharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

DimensionalCharacteristicItemBaseType::DimensionalCharacteristicItemBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  CharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

DimensionalCharacteristicItemBaseType::~DimensionalCharacteristicItemBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void DimensionalCharacteristicItemBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool DimensionalCharacteristicItemBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in DimensionalCharacteristicItemBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in DimensionalCharacteristicItemBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in DimensionalCharacteristicItemBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in DimensionalCharacteristicItemBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class DimensionalCharacteristicMeasurementBaseType

*/

DimensionalCharacteristicMeasurementBaseType::DimensionalCharacteristicMeasurementBaseType() :
  CharacteristicMeasurementBaseType()
{
}

DimensionalCharacteristicMeasurementBaseType::DimensionalCharacteristicMeasurementBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn) :
  CharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
}

DimensionalCharacteristicMeasurementBaseType::DimensionalCharacteristicMeasurementBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn) :
  CharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
}

DimensionalCharacteristicMeasurementBaseType::~DimensionalCharacteristicMeasurementBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void DimensionalCharacteristicMeasurementBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool DimensionalCharacteristicMeasurementBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in DimensionalCharacteristicMeasurementBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in DimensionalCharacteristicMeasurementBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in DimensionalCharacteristicMeasurementBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in DimensionalCharacteristicMeasurementBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class DimensionalCharacteristicNominalBaseType

*/

DimensionalCharacteristicNominalBaseType::DimensionalCharacteristicNominalBaseType() :
  CharacteristicNominalBaseType()
{
}

DimensionalCharacteristicNominalBaseType::DimensionalCharacteristicNominalBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  CharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

DimensionalCharacteristicNominalBaseType::DimensionalCharacteristicNominalBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  CharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

DimensionalCharacteristicNominalBaseType::~DimensionalCharacteristicNominalBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void DimensionalCharacteristicNominalBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool DimensionalCharacteristicNominalBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in DimensionalCharacteristicNominalBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in DimensionalCharacteristicNominalBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in DimensionalCharacteristicNominalBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in DimensionalCharacteristicNominalBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class DistanceBetweenCharacteristicDefinitionType

*/

DistanceBetweenCharacteristicDefinitionType::DistanceBetweenCharacteristicDefinitionType() :
  LinearCharacteristicDefinitionBaseType()
{
}

DistanceBetweenCharacteristicDefinitionType::DistanceBetweenCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseTypePairIn) :
  LinearCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    LinearCharacteristicDefinitionBaseTypePairIn)
{
}

DistanceBetweenCharacteristicDefinitionType::DistanceBetweenCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseTypePairIn) :
  LinearCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    LinearCharacteristicDefinitionBaseTypePairIn)
{
}

DistanceBetweenCharacteristicDefinitionType::~DistanceBetweenCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void DistanceBetweenCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (DimensionType)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionType");
      DimensionType->printSelf(outFile);
      fprintf(outFile, "</DimensionType>\n");
    }
  if (DimensionModifiers)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionModifiers");
      DimensionModifiers->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DimensionModifiers>\n");
    }
  LinearCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

bool DistanceBetweenCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in DistanceBetweenCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in DistanceBetweenCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in DistanceBetweenCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in DistanceBetweenCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class DistanceBetweenCharacteristicItemType

*/

DistanceBetweenCharacteristicItemType::DistanceBetweenCharacteristicItemType() :
  LinearCharacteristicItemBaseType()
{
}

DistanceBetweenCharacteristicItemType::DistanceBetweenCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LinearCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

DistanceBetweenCharacteristicItemType::DistanceBetweenCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LinearCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

DistanceBetweenCharacteristicItemType::~DistanceBetweenCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void DistanceBetweenCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool DistanceBetweenCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in DistanceBetweenCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in DistanceBetweenCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in DistanceBetweenCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in DistanceBetweenCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class DistanceBetweenCharacteristicMeasurementType

*/

DistanceBetweenCharacteristicMeasurementType::DistanceBetweenCharacteristicMeasurementType() :
  LinearCharacteristicMeasurementBaseType()
{
  AnalysisVector = 0;
}

DistanceBetweenCharacteristicMeasurementType::DistanceBetweenCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 MeasuredUnitVectorType * AnalysisVectorIn) :
  LinearCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
  AnalysisVector = AnalysisVectorIn;
}

DistanceBetweenCharacteristicMeasurementType::DistanceBetweenCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 MeasuredUnitVectorType * AnalysisVectorIn) :
  LinearCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
  AnalysisVector = AnalysisVectorIn;
}

DistanceBetweenCharacteristicMeasurementType::~DistanceBetweenCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  delete AnalysisVector;
  #endif
}

void DistanceBetweenCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  if (AnalysisVector)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AnalysisVector");
      AnalysisVector->printSelf(outFile);
      fprintf(outFile, "</AnalysisVector>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool DistanceBetweenCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in DistanceBetweenCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in DistanceBetweenCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in DistanceBetweenCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in DistanceBetweenCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredUnitVectorType * DistanceBetweenCharacteristicMeasurementType::getAnalysisVector()
{return AnalysisVector;}

void DistanceBetweenCharacteristicMeasurementType::setAnalysisVector(MeasuredUnitVectorType * AnalysisVectorIn)
{AnalysisVector = AnalysisVectorIn;}

/* ***************************************************************** */

/* class DistanceBetweenCharacteristicNominalType

*/

DistanceBetweenCharacteristicNominalType::DistanceBetweenCharacteristicNominalType() :
  LinearCharacteristicNominalBaseType()
{
  FeatureNominalPairs = 0;
  AnalysisVector = 0;
  AnalysisMode = 0;
  MeasurementDirective = 0;
  CoordinateSystemId = 0;
}

DistanceBetweenCharacteristicNominalType::DistanceBetweenCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn,
 ArrayPairReferenceFullType * FeatureNominalPairsIn,
 UnitVectorType * AnalysisVectorIn,
 DistanceBetweenAnalysisModeEnumType * AnalysisModeIn,
 MeasurementDirectiveType * MeasurementDirectiveIn,
 QIFReferenceFullType * CoordinateSystemIdIn) :
  LinearCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn,
    TargetDualValueIn)
{
  FeatureNominalPairs = FeatureNominalPairsIn;
  AnalysisVector = AnalysisVectorIn;
  AnalysisMode = AnalysisModeIn;
  MeasurementDirective = MeasurementDirectiveIn;
  CoordinateSystemId = CoordinateSystemIdIn;
}

DistanceBetweenCharacteristicNominalType::DistanceBetweenCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn,
 ArrayPairReferenceFullType * FeatureNominalPairsIn,
 UnitVectorType * AnalysisVectorIn,
 DistanceBetweenAnalysisModeEnumType * AnalysisModeIn,
 MeasurementDirectiveType * MeasurementDirectiveIn,
 QIFReferenceFullType * CoordinateSystemIdIn) :
  LinearCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn,
    TargetDualValueIn)
{
  FeatureNominalPairs = FeatureNominalPairsIn;
  AnalysisVector = AnalysisVectorIn;
  AnalysisMode = AnalysisModeIn;
  MeasurementDirective = MeasurementDirectiveIn;
  CoordinateSystemId = CoordinateSystemIdIn;
}

DistanceBetweenCharacteristicNominalType::~DistanceBetweenCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  delete FeatureNominalPairs;
  delete AnalysisVector;
  delete AnalysisMode;
  delete MeasurementDirective;
  delete CoordinateSystemId;
  #endif
}

void DistanceBetweenCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  if (TargetDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetDualValue");
      TargetDualValue->printSelf(outFile);
      fprintf(outFile, "</TargetDualValue>\n");
    }
  if (FeatureNominalPairs)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalPairs");
      FeatureNominalPairs->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalPairs>\n");
    }
  if (AnalysisVector)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AnalysisVector");
      AnalysisVector->printSelf(outFile);
      fprintf(outFile, "</AnalysisVector>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<AnalysisMode");
  AnalysisMode->printSelf(outFile);
  fprintf(outFile, "</AnalysisMode>\n");
  if (MeasurementDirective)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDirective");
      MeasurementDirective->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDirective>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool DistanceBetweenCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in DistanceBetweenCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in DistanceBetweenCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in DistanceBetweenCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in DistanceBetweenCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

ArrayPairReferenceFullType * DistanceBetweenCharacteristicNominalType::getFeatureNominalPairs()
{return FeatureNominalPairs;}

void DistanceBetweenCharacteristicNominalType::setFeatureNominalPairs(ArrayPairReferenceFullType * FeatureNominalPairsIn)
{FeatureNominalPairs = FeatureNominalPairsIn;}

UnitVectorType * DistanceBetweenCharacteristicNominalType::getAnalysisVector()
{return AnalysisVector;}

void DistanceBetweenCharacteristicNominalType::setAnalysisVector(UnitVectorType * AnalysisVectorIn)
{AnalysisVector = AnalysisVectorIn;}

DistanceBetweenAnalysisModeEnumType * DistanceBetweenCharacteristicNominalType::getAnalysisMode()
{return AnalysisMode;}

void DistanceBetweenCharacteristicNominalType::setAnalysisMode(DistanceBetweenAnalysisModeEnumType * AnalysisModeIn)
{AnalysisMode = AnalysisModeIn;}

MeasurementDirectiveType * DistanceBetweenCharacteristicNominalType::getMeasurementDirective()
{return MeasurementDirective;}

void DistanceBetweenCharacteristicNominalType::setMeasurementDirective(MeasurementDirectiveType * MeasurementDirectiveIn)
{MeasurementDirective = MeasurementDirectiveIn;}

QIFReferenceFullType * DistanceBetweenCharacteristicNominalType::getCoordinateSystemId()
{return CoordinateSystemId;}

void DistanceBetweenCharacteristicNominalType::setCoordinateSystemId(QIFReferenceFullType * CoordinateSystemIdIn)
{CoordinateSystemId = CoordinateSystemIdIn;}

/* ***************************************************************** */

/* class DistanceFromCharacteristicDefinitionType

*/

DistanceFromCharacteristicDefinitionType::DistanceFromCharacteristicDefinitionType() :
  LinearCharacteristicDefinitionBaseType()
{
}

DistanceFromCharacteristicDefinitionType::DistanceFromCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseTypePairIn) :
  LinearCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    LinearCharacteristicDefinitionBaseTypePairIn)
{
}

DistanceFromCharacteristicDefinitionType::DistanceFromCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseTypePairIn) :
  LinearCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    LinearCharacteristicDefinitionBaseTypePairIn)
{
}

DistanceFromCharacteristicDefinitionType::~DistanceFromCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void DistanceFromCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (DimensionType)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionType");
      DimensionType->printSelf(outFile);
      fprintf(outFile, "</DimensionType>\n");
    }
  if (DimensionModifiers)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionModifiers");
      DimensionModifiers->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DimensionModifiers>\n");
    }
  LinearCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

bool DistanceFromCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in DistanceFromCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in DistanceFromCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in DistanceFromCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in DistanceFromCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class DistanceFromCharacteristicItemType

*/

DistanceFromCharacteristicItemType::DistanceFromCharacteristicItemType() :
  LinearCharacteristicItemBaseType()
{
}

DistanceFromCharacteristicItemType::DistanceFromCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LinearCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

DistanceFromCharacteristicItemType::DistanceFromCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LinearCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

DistanceFromCharacteristicItemType::~DistanceFromCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void DistanceFromCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool DistanceFromCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in DistanceFromCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in DistanceFromCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in DistanceFromCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in DistanceFromCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class DistanceFromCharacteristicMeasurementType

*/

DistanceFromCharacteristicMeasurementType::DistanceFromCharacteristicMeasurementType() :
  LinearCharacteristicMeasurementBaseType()
{
  AnalysisVector = 0;
}

DistanceFromCharacteristicMeasurementType::DistanceFromCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 MeasuredUnitVectorType * AnalysisVectorIn) :
  LinearCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
  AnalysisVector = AnalysisVectorIn;
}

DistanceFromCharacteristicMeasurementType::DistanceFromCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 MeasuredUnitVectorType * AnalysisVectorIn) :
  LinearCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
  AnalysisVector = AnalysisVectorIn;
}

DistanceFromCharacteristicMeasurementType::~DistanceFromCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  delete AnalysisVector;
  #endif
}

void DistanceFromCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  if (AnalysisVector)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AnalysisVector");
      AnalysisVector->printSelf(outFile);
      fprintf(outFile, "</AnalysisVector>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool DistanceFromCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in DistanceFromCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in DistanceFromCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in DistanceFromCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in DistanceFromCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredUnitVectorType * DistanceFromCharacteristicMeasurementType::getAnalysisVector()
{return AnalysisVector;}

void DistanceFromCharacteristicMeasurementType::setAnalysisVector(MeasuredUnitVectorType * AnalysisVectorIn)
{AnalysisVector = AnalysisVectorIn;}

/* ***************************************************************** */

/* class DistanceFromCharacteristicNominalType

*/

DistanceFromCharacteristicNominalType::DistanceFromCharacteristicNominalType() :
  LinearCharacteristicNominalBaseType()
{
  OriginReference = 0;
  AnalysisVector = 0;
  AnalysisMode = 0;
  MeasurementDirective = 0;
  CoordinateSystemId = 0;
}

DistanceFromCharacteristicNominalType::DistanceFromCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn,
 OriginReferenceType * OriginReferenceIn,
 UnitVectorType * AnalysisVectorIn,
 DistanceBetweenAnalysisModeEnumType * AnalysisModeIn,
 MeasurementDirectiveType * MeasurementDirectiveIn,
 QIFReferenceFullType * CoordinateSystemIdIn) :
  LinearCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn,
    TargetDualValueIn)
{
  OriginReference = OriginReferenceIn;
  AnalysisVector = AnalysisVectorIn;
  AnalysisMode = AnalysisModeIn;
  MeasurementDirective = MeasurementDirectiveIn;
  CoordinateSystemId = CoordinateSystemIdIn;
}

DistanceFromCharacteristicNominalType::DistanceFromCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn,
 OriginReferenceType * OriginReferenceIn,
 UnitVectorType * AnalysisVectorIn,
 DistanceBetweenAnalysisModeEnumType * AnalysisModeIn,
 MeasurementDirectiveType * MeasurementDirectiveIn,
 QIFReferenceFullType * CoordinateSystemIdIn) :
  LinearCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn,
    TargetDualValueIn)
{
  OriginReference = OriginReferenceIn;
  AnalysisVector = AnalysisVectorIn;
  AnalysisMode = AnalysisModeIn;
  MeasurementDirective = MeasurementDirectiveIn;
  CoordinateSystemId = CoordinateSystemIdIn;
}

DistanceFromCharacteristicNominalType::~DistanceFromCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  delete OriginReference;
  delete AnalysisVector;
  delete AnalysisMode;
  delete MeasurementDirective;
  delete CoordinateSystemId;
  #endif
}

void DistanceFromCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  if (TargetDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetDualValue");
      TargetDualValue->printSelf(outFile);
      fprintf(outFile, "</TargetDualValue>\n");
    }
  if (OriginReference)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OriginReference");
      OriginReference->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OriginReference>\n");
    }
  if (AnalysisVector)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AnalysisVector");
      AnalysisVector->printSelf(outFile);
      fprintf(outFile, "</AnalysisVector>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<AnalysisMode");
  AnalysisMode->printSelf(outFile);
  fprintf(outFile, "</AnalysisMode>\n");
  if (MeasurementDirective)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDirective");
      MeasurementDirective->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDirective>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool DistanceFromCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in DistanceFromCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in DistanceFromCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in DistanceFromCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in DistanceFromCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

OriginReferenceType * DistanceFromCharacteristicNominalType::getOriginReference()
{return OriginReference;}

void DistanceFromCharacteristicNominalType::setOriginReference(OriginReferenceType * OriginReferenceIn)
{OriginReference = OriginReferenceIn;}

UnitVectorType * DistanceFromCharacteristicNominalType::getAnalysisVector()
{return AnalysisVector;}

void DistanceFromCharacteristicNominalType::setAnalysisVector(UnitVectorType * AnalysisVectorIn)
{AnalysisVector = AnalysisVectorIn;}

DistanceBetweenAnalysisModeEnumType * DistanceFromCharacteristicNominalType::getAnalysisMode()
{return AnalysisMode;}

void DistanceFromCharacteristicNominalType::setAnalysisMode(DistanceBetweenAnalysisModeEnumType * AnalysisModeIn)
{AnalysisMode = AnalysisModeIn;}

MeasurementDirectiveType * DistanceFromCharacteristicNominalType::getMeasurementDirective()
{return MeasurementDirective;}

void DistanceFromCharacteristicNominalType::setMeasurementDirective(MeasurementDirectiveType * MeasurementDirectiveIn)
{MeasurementDirective = MeasurementDirectiveIn;}

QIFReferenceFullType * DistanceFromCharacteristicNominalType::getCoordinateSystemId()
{return CoordinateSystemId;}

void DistanceFromCharacteristicNominalType::setCoordinateSystemId(QIFReferenceFullType * CoordinateSystemIdIn)
{CoordinateSystemId = CoordinateSystemIdIn;}

/* ***************************************************************** */

/* class DualNestingIndexFilterSymbolEnumType

*/

DualNestingIndexFilterSymbolEnumType::DualNestingIndexFilterSymbolEnumType() :
  XmlNMTOKEN()
{
}

DualNestingIndexFilterSymbolEnumType::DualNestingIndexFilterSymbolEnumType(
 const char * valIn) :
  XmlNMTOKEN(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "CW") &&
           strcmp(val.c_str(), "F") &&
           strcmp(val.c_str(), "G") &&
           strcmp(val.c_str(), "RG") &&
           strcmp(val.c_str(), "RS") &&
           strcmp(val.c_str(), "S") &&
           strcmp(val.c_str(), "SW"));
}

DualNestingIndexFilterSymbolEnumType::~DualNestingIndexFilterSymbolEnumType() {}

bool DualNestingIndexFilterSymbolEnumType::DualNestingIndexFilterSymbolEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "CW") &&
          strcmp(val.c_str(), "F") &&
          strcmp(val.c_str(), "G") &&
          strcmp(val.c_str(), "RG") &&
          strcmp(val.c_str(), "RS") &&
          strcmp(val.c_str(), "S") &&
          strcmp(val.c_str(), "SW"));
}

void DualNestingIndexFilterSymbolEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "DualNestingIndexFilterSymbolEnumType");
}

void DualNestingIndexFilterSymbolEnumType::printSelf(FILE * outFile)
{
  if (DualNestingIndexFilterSymbolEnumTypeIsBad())
    {
      fprintf(stderr, "bad DualNestingIndexFilterSymbolEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::printSelf(outFile);
}

void DualNestingIndexFilterSymbolEnumType::oPrintSelf(FILE * outFile)
{
  if (DualNestingIndexFilterSymbolEnumTypeIsBad())
    {
      fprintf(stderr, "bad DualNestingIndexFilterSymbolEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class DualNestingIndexFilterType

*/

DualNestingIndexFilterType::DualNestingIndexFilterType()
{
  Symbol = 0;
  FirstNestingIndex = 0;
  SecondNestingIndex = 0;
  SecondDirectionFirstNestingIndex = 0;
  SecondDirectionSecondNestingIndex = 0;
}

DualNestingIndexFilterType::DualNestingIndexFilterType(
 DualNestingIndexFilterSymbolEnumType * SymbolIn,
 LinearValueType * FirstNestingIndexIn,
 LinearValueType * SecondNestingIndexIn,
 LinearValueType * SecondDirectionFirstNestingIndexIn,
 LinearValueType * SecondDirectionSecondNestingIndexIn)
{
  Symbol = SymbolIn;
  FirstNestingIndex = FirstNestingIndexIn;
  SecondNestingIndex = SecondNestingIndexIn;
  SecondDirectionFirstNestingIndex = SecondDirectionFirstNestingIndexIn;
  SecondDirectionSecondNestingIndex = SecondDirectionSecondNestingIndexIn;
}

DualNestingIndexFilterType::~DualNestingIndexFilterType()
{
  #ifndef NODESTRUCT
  delete Symbol;
  delete FirstNestingIndex;
  delete SecondNestingIndex;
  delete SecondDirectionFirstNestingIndex;
  delete SecondDirectionSecondNestingIndex;
  #endif
}

void DualNestingIndexFilterType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Symbol");
  Symbol->printSelf(outFile);
  fprintf(outFile, "</Symbol>\n");
  if (FirstNestingIndex)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FirstNestingIndex");
      FirstNestingIndex->printSelf(outFile);
      fprintf(outFile, "</FirstNestingIndex>\n");
    }
  if (SecondNestingIndex)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SecondNestingIndex");
      SecondNestingIndex->printSelf(outFile);
      fprintf(outFile, "</SecondNestingIndex>\n");
    }
  if (SecondDirectionFirstNestingIndex)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SecondDirectionFirstNestingIndex");
      SecondDirectionFirstNestingIndex->printSelf(outFile);
      fprintf(outFile, "</SecondDirectionFirstNestingIndex>\n");
    }
  if (SecondDirectionSecondNestingIndex)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SecondDirectionSecondNestingIndex");
      SecondDirectionSecondNestingIndex->printSelf(outFile);
      fprintf(outFile, "</SecondDirectionSecondNestingIndex>\n");
    }
  doSpaces(-INDENT, outFile);
}

DualNestingIndexFilterSymbolEnumType * DualNestingIndexFilterType::getSymbol()
{return Symbol;}

void DualNestingIndexFilterType::setSymbol(DualNestingIndexFilterSymbolEnumType * SymbolIn)
{Symbol = SymbolIn;}

LinearValueType * DualNestingIndexFilterType::getFirstNestingIndex()
{return FirstNestingIndex;}

void DualNestingIndexFilterType::setFirstNestingIndex(LinearValueType * FirstNestingIndexIn)
{FirstNestingIndex = FirstNestingIndexIn;}

LinearValueType * DualNestingIndexFilterType::getSecondNestingIndex()
{return SecondNestingIndex;}

void DualNestingIndexFilterType::setSecondNestingIndex(LinearValueType * SecondNestingIndexIn)
{SecondNestingIndex = SecondNestingIndexIn;}

LinearValueType * DualNestingIndexFilterType::getSecondDirectionFirstNestingIndex()
{return SecondDirectionFirstNestingIndex;}

void DualNestingIndexFilterType::setSecondDirectionFirstNestingIndex(LinearValueType * SecondDirectionFirstNestingIndexIn)
{SecondDirectionFirstNestingIndex = SecondDirectionFirstNestingIndexIn;}

LinearValueType * DualNestingIndexFilterType::getSecondDirectionSecondNestingIndex()
{return SecondDirectionSecondNestingIndex;}

void DualNestingIndexFilterType::setSecondDirectionSecondNestingIndex(LinearValueType * SecondDirectionSecondNestingIndexIn)
{SecondDirectionSecondNestingIndex = SecondDirectionSecondNestingIndexIn;}

/* ***************************************************************** */

/* class EllipticityCharacteristicDefinitionType

*/

EllipticityCharacteristicDefinitionType::EllipticityCharacteristicDefinitionType() :
  FormCharacteristicDefinitionBaseType()
{
  ToleranceValue = 0;
  ToleranceDualValue = 0;
}

EllipticityCharacteristicDefinitionType::EllipticityCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn) :
  FormCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn)
{
  ToleranceValue = ToleranceValueIn;
  ToleranceDualValue = ToleranceDualValueIn;
}

EllipticityCharacteristicDefinitionType::EllipticityCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn) :
  FormCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn)
{
  ToleranceValue = ToleranceValueIn;
  ToleranceDualValue = ToleranceDualValueIn;
}

EllipticityCharacteristicDefinitionType::~EllipticityCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  delete ToleranceValue;
  delete ToleranceDualValue;
  #endif
}

void EllipticityCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (GeometricCharac_1050)
    {
  GeometricCharac_1050->printSelf(outFile);
    }
  if (DirectionFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DirectionFeature");
      DirectionFeature->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DirectionFeature>\n");
    }
  if (CollectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CollectionPlane");
      CollectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CollectionPlane>\n");
    }
  if (IntersectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IntersectionPlane");
      IntersectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</IntersectionPlane>\n");
    }
  if (OrientationPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OrientationPlane");
      OrientationPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OrientationPlane>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ToleranceValue");
  ToleranceValue->printSelf(outFile);
  fprintf(outFile, "</ToleranceValue>\n");
  if (ToleranceDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceDualValue");
      ToleranceDualValue->printSelf(outFile);
      fprintf(outFile, "</ToleranceDualValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool EllipticityCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in EllipticityCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in EllipticityCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in EllipticityCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in EllipticityCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LinearValueType * EllipticityCharacteristicDefinitionType::getToleranceValue()
{return ToleranceValue;}

void EllipticityCharacteristicDefinitionType::setToleranceValue(LinearValueType * ToleranceValueIn)
{ToleranceValue = ToleranceValueIn;}

LinearDualValueType * EllipticityCharacteristicDefinitionType::getToleranceDualValue()
{return ToleranceDualValue;}

void EllipticityCharacteristicDefinitionType::setToleranceDualValue(LinearDualValueType * ToleranceDualValueIn)
{ToleranceDualValue = ToleranceDualValueIn;}

/* ***************************************************************** */

/* class EllipticityCharacteristicItemType

*/

EllipticityCharacteristicItemType::EllipticityCharacteristicItemType() :
  FormCharacteristicItemBaseType()
{
}

EllipticityCharacteristicItemType::EllipticityCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  FormCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

EllipticityCharacteristicItemType::EllipticityCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  FormCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

EllipticityCharacteristicItemType::~EllipticityCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void EllipticityCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool EllipticityCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in EllipticityCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in EllipticityCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in EllipticityCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in EllipticityCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class EllipticityCharacteristicMeasurementType

*/

EllipticityCharacteristicMeasurementType::EllipticityCharacteristicMeasurementType() :
  FormCharacteristicMeasurementBaseType()
{
}

EllipticityCharacteristicMeasurementType::EllipticityCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  FormCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

EllipticityCharacteristicMeasurementType::EllipticityCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  FormCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

EllipticityCharacteristicMeasurementType::~EllipticityCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void EllipticityCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool EllipticityCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in EllipticityCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in EllipticityCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in EllipticityCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in EllipticityCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class EllipticityCharacteristicNominalType

*/

EllipticityCharacteristicNominalType::EllipticityCharacteristicNominalType() :
  FormCharacteristicNominalBaseType()
{
}

EllipticityCharacteristicNominalType::EllipticityCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  FormCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

EllipticityCharacteristicNominalType::EllipticityCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  FormCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

EllipticityCharacteristicNominalType::~EllipticityCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void EllipticityCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool EllipticityCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in EllipticityCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in EllipticityCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in EllipticityCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in EllipticityCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class ExtentEnumType

*/

ExtentEnumType::ExtentEnumType() :
  XmlNMTOKEN()
{
}

ExtentEnumType::ExtentEnumType(
 const char * valIn) :
  XmlNMTOKEN(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "ALL_OVER") &&
           strcmp(val.c_str(), "ALL_AROUND") &&
           strcmp(val.c_str(), "ALL_OVER_THIS_SIDE") &&
           strcmp(val.c_str(), "ALL_AROUND_THIS_SIDE") &&
           strcmp(val.c_str(), "UNDEFINED"));
}

ExtentEnumType::~ExtentEnumType() {}

bool ExtentEnumType::ExtentEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "ALL_OVER") &&
          strcmp(val.c_str(), "ALL_AROUND") &&
          strcmp(val.c_str(), "ALL_OVER_THIS_SIDE") &&
          strcmp(val.c_str(), "ALL_AROUND_THIS_SIDE") &&
          strcmp(val.c_str(), "UNDEFINED"));
}

void ExtentEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "ExtentEnumType");
}

void ExtentEnumType::printSelf(FILE * outFile)
{
  if (ExtentEnumTypeIsBad())
    {
      fprintf(stderr, "bad ExtentEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::printSelf(outFile);
}

void ExtentEnumType::oPrintSelf(FILE * outFile)
{
  if (ExtentEnumTypeIsBad())
    {
      fprintf(stderr, "bad ExtentEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class ExtentType

*/

ExtentType::ExtentType()
{
  ExtentTypePair = 0;
}

ExtentType::ExtentType(
 ExtentTypeChoicePair * ExtentTypePairIn)
{
  ExtentTypePair = ExtentTypePairIn;
}

ExtentType::~ExtentType()
{
  #ifndef NODESTRUCT
  delete ExtentTypePair;
  #endif
}

void ExtentType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  ExtentTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

ExtentTypeChoicePair * ExtentType::getExtentTypePair()
{return ExtentTypePair;}

void ExtentType::setExtentTypePair(ExtentTypeChoicePair * ExtentTypePairIn)
{ExtentTypePair = ExtentTypePairIn;}
ExtentTypeChoicePair::ExtentTypeChoicePair() {}

ExtentTypeChoicePair::ExtentTypeChoicePair(
 whichOne ExtentTypeTypeIn,
 ExtentTypeVal ExtentTypeValueIn)
{
  ExtentTypeType = ExtentTypeTypeIn;
  ExtentTypeValue = ExtentTypeValueIn;
}

ExtentTypeChoicePair::~ExtentTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (ExtentTypeType == ExtentEnumE)
    delete ExtentTypeValue.ExtentEnum;
  else if (ExtentTypeType == OtherExtentE)
    delete ExtentTypeValue.OtherExtent;
  #endif
}

void ExtentTypeChoicePair::printSelf(FILE * outFile)
{
  if (ExtentTypeType == ExtentEnumE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ExtentEnum");
      ExtentTypeValue.ExtentEnum->printSelf(outFile);
      fprintf(outFile, "</ExtentEnum>\n");
    }
  else if (ExtentTypeType == OtherExtentE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OtherExtent");
      ExtentTypeValue.OtherExtent->printSelf(outFile);
      fprintf(outFile, "</OtherExtent>\n");
    }
}

/* ***************************************************************** */

/* class FilterType

*/

FilterType::FilterType()
{
  FilterTypePair = 0;
}

FilterType::FilterType(
 FilterTypeChoicePair * FilterTypePairIn)
{
  FilterTypePair = FilterTypePairIn;
}

FilterType::~FilterType()
{
  #ifndef NODESTRUCT
  delete FilterTypePair;
  #endif
}

void FilterType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  FilterTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

FilterTypeChoicePair * FilterType::getFilterTypePair()
{return FilterTypePair;}

void FilterType::setFilterTypePair(FilterTypeChoicePair * FilterTypePairIn)
{FilterTypePair = FilterTypePairIn;}
FilterTypeChoicePair::FilterTypeChoicePair() {}

FilterTypeChoicePair::FilterTypeChoicePair(
 whichOne FilterTypeTypeIn,
 FilterTypeVal FilterTypeValueIn)
{
  FilterTypeType = FilterTypeTypeIn;
  FilterTypeValue = FilterTypeValueIn;
}

FilterTypeChoicePair::~FilterTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (FilterTypeType == SingleNestingIndexFilterE)
    delete FilterTypeValue.SingleNestingIndexFilter;
  else if (FilterTypeType == DualNestingIndexFilterE)
    delete FilterTypeValue.DualNestingIndexFilter;
  #endif
}

void FilterTypeChoicePair::printSelf(FILE * outFile)
{
  if (FilterTypeType == SingleNestingIndexFilterE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SingleNestingIndexFilter");
      FilterTypeValue.SingleNestingIndexFilter->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SingleNestingIndexFilter>\n");
    }
  else if (FilterTypeType == DualNestingIndexFilterE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DualNestingIndexFilter");
      FilterTypeValue.DualNestingIndexFilter->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DualNestingIndexFilter>\n");
    }
}

/* ***************************************************************** */

/* class FlatTaperCharacteristicDefinitionType

*/

FlatTaperCharacteristicDefinitionType::FlatTaperCharacteristicDefinitionType() :
  LinearCharacteristicDefinitionBaseType()
{
}

FlatTaperCharacteristicDefinitionType::FlatTaperCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseTypePairIn) :
  LinearCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    LinearCharacteristicDefinitionBaseTypePairIn)
{
}

FlatTaperCharacteristicDefinitionType::FlatTaperCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseTypePairIn) :
  LinearCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    LinearCharacteristicDefinitionBaseTypePairIn)
{
}

FlatTaperCharacteristicDefinitionType::~FlatTaperCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void FlatTaperCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (DimensionType)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionType");
      DimensionType->printSelf(outFile);
      fprintf(outFile, "</DimensionType>\n");
    }
  if (DimensionModifiers)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionModifiers");
      DimensionModifiers->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DimensionModifiers>\n");
    }
  LinearCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

bool FlatTaperCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in FlatTaperCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in FlatTaperCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FlatTaperCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in FlatTaperCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class FlatTaperCharacteristicItemType

*/

FlatTaperCharacteristicItemType::FlatTaperCharacteristicItemType() :
  LinearCharacteristicItemBaseType()
{
}

FlatTaperCharacteristicItemType::FlatTaperCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LinearCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

FlatTaperCharacteristicItemType::FlatTaperCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LinearCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

FlatTaperCharacteristicItemType::~FlatTaperCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void FlatTaperCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool FlatTaperCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in FlatTaperCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in FlatTaperCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FlatTaperCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in FlatTaperCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class FlatTaperCharacteristicMeasurementType

*/

FlatTaperCharacteristicMeasurementType::FlatTaperCharacteristicMeasurementType() :
  LinearCharacteristicMeasurementBaseType()
{
  Distance = 0;
}

FlatTaperCharacteristicMeasurementType::FlatTaperCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 MeasuredLinearValueType * DistanceIn) :
  LinearCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
  Distance = DistanceIn;
}

FlatTaperCharacteristicMeasurementType::FlatTaperCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 MeasuredLinearValueType * DistanceIn) :
  LinearCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
  Distance = DistanceIn;
}

FlatTaperCharacteristicMeasurementType::~FlatTaperCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  delete Distance;
  #endif
}

void FlatTaperCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  if (Distance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Distance");
      Distance->printSelf(outFile);
      fprintf(outFile, "</Distance>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool FlatTaperCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in FlatTaperCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in FlatTaperCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FlatTaperCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in FlatTaperCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredLinearValueType * FlatTaperCharacteristicMeasurementType::getDistance()
{return Distance;}

void FlatTaperCharacteristicMeasurementType::setDistance(MeasuredLinearValueType * DistanceIn)
{Distance = DistanceIn;}

/* ***************************************************************** */

/* class FlatTaperCharacteristicNominalType

*/

FlatTaperCharacteristicNominalType::FlatTaperCharacteristicNominalType() :
  LinearCharacteristicNominalBaseType()
{
  Distance = 0;
}

FlatTaperCharacteristicNominalType::FlatTaperCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn,
 LinearValueType * DistanceIn) :
  LinearCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn,
    TargetDualValueIn)
{
  Distance = DistanceIn;
}

FlatTaperCharacteristicNominalType::FlatTaperCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn,
 LinearValueType * DistanceIn) :
  LinearCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn,
    TargetDualValueIn)
{
  Distance = DistanceIn;
}

FlatTaperCharacteristicNominalType::~FlatTaperCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  delete Distance;
  #endif
}

void FlatTaperCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  if (TargetDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetDualValue");
      TargetDualValue->printSelf(outFile);
      fprintf(outFile, "</TargetDualValue>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Distance");
  Distance->printSelf(outFile);
  fprintf(outFile, "</Distance>\n");
  doSpaces(-INDENT, outFile);
}

bool FlatTaperCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in FlatTaperCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in FlatTaperCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FlatTaperCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in FlatTaperCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LinearValueType * FlatTaperCharacteristicNominalType::getDistance()
{return Distance;}

void FlatTaperCharacteristicNominalType::setDistance(LinearValueType * DistanceIn)
{Distance = DistanceIn;}

/* ***************************************************************** */

/* class FlatnessCharacteristicDefinitionType

*/

FlatnessCharacteristicDefinitionType::FlatnessCharacteristicDefinitionType() :
  FormCharacteristicDefinitionBaseType()
{
  FlatnessCharact_1049 = 0;
  MaterialCondition = 0;
  SizeCharacteristicDefinitionId = 0;
  MaximumToleranceValue = 0;
  NotConvex = 0;
}

FlatnessCharacteristicDefinitionType::FlatnessCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 FlatnessCharact_1049_Type * FlatnessCharact_1049In,
 MaterialModifierEnumType * MaterialConditionIn,
 QIFReferenceType * SizeCharacteristicDefinitionIdIn,
 LinearValueType * MaximumToleranceValueIn,
 XmlBoolean * NotConvexIn) :
  FormCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn)
{
  FlatnessCharact_1049 = FlatnessCharact_1049In;
  MaterialCondition = MaterialConditionIn;
  SizeCharacteristicDefinitionId = SizeCharacteristicDefinitionIdIn;
  MaximumToleranceValue = MaximumToleranceValueIn;
  NotConvex = NotConvexIn;
}

FlatnessCharacteristicDefinitionType::FlatnessCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 FlatnessCharact_1049_Type * FlatnessCharact_1049In,
 MaterialModifierEnumType * MaterialConditionIn,
 QIFReferenceType * SizeCharacteristicDefinitionIdIn,
 LinearValueType * MaximumToleranceValueIn,
 XmlBoolean * NotConvexIn) :
  FormCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn)
{
  FlatnessCharact_1049 = FlatnessCharact_1049In;
  MaterialCondition = MaterialConditionIn;
  SizeCharacteristicDefinitionId = SizeCharacteristicDefinitionIdIn;
  MaximumToleranceValue = MaximumToleranceValueIn;
  NotConvex = NotConvexIn;
}

FlatnessCharacteristicDefinitionType::~FlatnessCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  delete FlatnessCharact_1049;
  delete MaterialCondition;
  delete SizeCharacteristicDefinitionId;
  delete MaximumToleranceValue;
  delete NotConvex;
  #endif
}

void FlatnessCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (GeometricCharac_1050)
    {
  GeometricCharac_1050->printSelf(outFile);
    }
  if (DirectionFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DirectionFeature");
      DirectionFeature->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DirectionFeature>\n");
    }
  if (CollectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CollectionPlane");
      CollectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CollectionPlane>\n");
    }
  if (IntersectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IntersectionPlane");
      IntersectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</IntersectionPlane>\n");
    }
  if (OrientationPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OrientationPlane");
      OrientationPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OrientationPlane>\n");
    }
  FlatnessCharact_1049->printSelf(outFile);
  if (MaterialCondition)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaterialCondition");
      MaterialCondition->printSelf(outFile);
      fprintf(outFile, "</MaterialCondition>\n");
    }
  if (SizeCharacteristicDefinitionId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SizeCharacteristicDefinitionId");
      SizeCharacteristicDefinitionId->printSelf(outFile);
      fprintf(outFile, "</SizeCharacteristicDefinitionId>\n");
    }
  if (MaximumToleranceValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaximumToleranceValue");
      MaximumToleranceValue->printSelf(outFile);
      fprintf(outFile, "</MaximumToleranceValue>\n");
    }
  if (NotConvex)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotConvex");
      NotConvex->printSelf(outFile);
      fprintf(outFile, "</NotConvex>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool FlatnessCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in FlatnessCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in FlatnessCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FlatnessCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in FlatnessCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

FlatnessCharact_1049_Type * FlatnessCharacteristicDefinitionType::getFlatnessCharact_1049()
{return FlatnessCharact_1049;}

void FlatnessCharacteristicDefinitionType::setFlatnessCharact_1049(FlatnessCharact_1049_Type * FlatnessCharact_1049In)
{FlatnessCharact_1049 = FlatnessCharact_1049In;}

MaterialModifierEnumType * FlatnessCharacteristicDefinitionType::getMaterialCondition()
{return MaterialCondition;}

void FlatnessCharacteristicDefinitionType::setMaterialCondition(MaterialModifierEnumType * MaterialConditionIn)
{MaterialCondition = MaterialConditionIn;}

QIFReferenceType * FlatnessCharacteristicDefinitionType::getSizeCharacteristicDefinitionId()
{return SizeCharacteristicDefinitionId;}

void FlatnessCharacteristicDefinitionType::setSizeCharacteristicDefinitionId(QIFReferenceType * SizeCharacteristicDefinitionIdIn)
{SizeCharacteristicDefinitionId = SizeCharacteristicDefinitionIdIn;}

LinearValueType * FlatnessCharacteristicDefinitionType::getMaximumToleranceValue()
{return MaximumToleranceValue;}

void FlatnessCharacteristicDefinitionType::setMaximumToleranceValue(LinearValueType * MaximumToleranceValueIn)
{MaximumToleranceValue = MaximumToleranceValueIn;}

XmlBoolean * FlatnessCharacteristicDefinitionType::getNotConvex()
{return NotConvex;}

void FlatnessCharacteristicDefinitionType::setNotConvex(XmlBoolean * NotConvexIn)
{NotConvex = NotConvexIn;}

/* ***************************************************************** */

/* class FlatnessCharacteristicItemType

*/

FlatnessCharacteristicItemType::FlatnessCharacteristicItemType() :
  FormCharacteristicItemBaseType()
{
}

FlatnessCharacteristicItemType::FlatnessCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  FormCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

FlatnessCharacteristicItemType::FlatnessCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  FormCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

FlatnessCharacteristicItemType::~FlatnessCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void FlatnessCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool FlatnessCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in FlatnessCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in FlatnessCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FlatnessCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in FlatnessCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class FlatnessCharacteristicMeasurementType

*/

FlatnessCharacteristicMeasurementType::FlatnessCharacteristicMeasurementType() :
  FormCharacteristicMeasurementBaseType()
{
  Bonus = 0;
  MaxFlatness = 0;
  ZonePlane = 0;
}

FlatnessCharacteristicMeasurementType::FlatnessCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 MeasuredLinearValueType * BonusIn,
 MeasuredLinearValueType * MaxFlatnessIn,
 MeasuredPlaneType * ZonePlaneIn) :
  FormCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
  Bonus = BonusIn;
  MaxFlatness = MaxFlatnessIn;
  ZonePlane = ZonePlaneIn;
}

FlatnessCharacteristicMeasurementType::FlatnessCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 MeasuredLinearValueType * BonusIn,
 MeasuredLinearValueType * MaxFlatnessIn,
 MeasuredPlaneType * ZonePlaneIn) :
  FormCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
  Bonus = BonusIn;
  MaxFlatness = MaxFlatnessIn;
  ZonePlane = ZonePlaneIn;
}

FlatnessCharacteristicMeasurementType::~FlatnessCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  delete Bonus;
  delete MaxFlatness;
  delete ZonePlane;
  #endif
}

void FlatnessCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  if (Bonus)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Bonus");
      Bonus->printSelf(outFile);
      fprintf(outFile, "</Bonus>\n");
    }
  if (MaxFlatness)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxFlatness");
      MaxFlatness->printSelf(outFile);
      fprintf(outFile, "</MaxFlatness>\n");
    }
  if (ZonePlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ZonePlane");
      ZonePlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ZonePlane>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool FlatnessCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in FlatnessCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in FlatnessCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FlatnessCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in FlatnessCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredLinearValueType * FlatnessCharacteristicMeasurementType::getBonus()
{return Bonus;}

void FlatnessCharacteristicMeasurementType::setBonus(MeasuredLinearValueType * BonusIn)
{Bonus = BonusIn;}

MeasuredLinearValueType * FlatnessCharacteristicMeasurementType::getMaxFlatness()
{return MaxFlatness;}

void FlatnessCharacteristicMeasurementType::setMaxFlatness(MeasuredLinearValueType * MaxFlatnessIn)
{MaxFlatness = MaxFlatnessIn;}

MeasuredPlaneType * FlatnessCharacteristicMeasurementType::getZonePlane()
{return ZonePlane;}

void FlatnessCharacteristicMeasurementType::setZonePlane(MeasuredPlaneType * ZonePlaneIn)
{ZonePlane = ZonePlaneIn;}

/* ***************************************************************** */

/* class FlatnessCharacteristicNominalType

*/

FlatnessCharacteristicNominalType::FlatnessCharacteristicNominalType() :
  FormCharacteristicNominalBaseType()
{
}

FlatnessCharacteristicNominalType::FlatnessCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  FormCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

FlatnessCharacteristicNominalType::FlatnessCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  FormCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

FlatnessCharacteristicNominalType::~FlatnessCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void FlatnessCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool FlatnessCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in FlatnessCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in FlatnessCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FlatnessCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in FlatnessCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class ForceCharacteristicDefinitionBaseType

*/

ForceCharacteristicDefinitionBaseType::ForceCharacteristicDefinitionBaseType() :
  CharacteristicDefinitionBaseType()
{
  ForceCharacteristicDefinitionBaseTypePair = 0;
}

ForceCharacteristicDefinitionBaseType::ForceCharacteristicDefinitionBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 ForceCharacteristicDefinitionBaseTypeChoicePair * ForceCharacteristicDefinitionBaseTypePairIn) :
  CharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
  ForceCharacteristicDefinitionBaseTypePair = ForceCharacteristicDefinitionBaseTypePairIn;
}

ForceCharacteristicDefinitionBaseType::ForceCharacteristicDefinitionBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 ForceCharacteristicDefinitionBaseTypeChoicePair * ForceCharacteristicDefinitionBaseTypePairIn) :
  CharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
  ForceCharacteristicDefinitionBaseTypePair = ForceCharacteristicDefinitionBaseTypePairIn;
}

ForceCharacteristicDefinitionBaseType::~ForceCharacteristicDefinitionBaseType()
{
  #ifndef NODESTRUCT
  delete ForceCharacteristicDefinitionBaseTypePair;
  #endif
}

void ForceCharacteristicDefinitionBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  ForceCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}
ForceCharacteristicDefinitionBaseTypeChoicePair * ForceCharacteristicDefinitionBaseType::getForceCharacteristicDefinitionBaseTypeChoicePair()
{return ForceCharacteristicDefinitionBaseTypePair;}

void ForceCharacteristicDefinitionBaseType::setForceCharacteristicDefinitionBaseTypeChoicePair(ForceCharacteristicDefinitionBaseTypeChoicePair * ForceCharacteristicDefinitionBaseTypePairIn)
{ForceCharacteristicDefinitionBaseTypePair = ForceCharacteristicDefinitionBaseTypePairIn;}

/* ***************************************************************** */

ForceCharacteristicDefinitionBaseTypeChoicePair::ForceCharacteristicDefinitionBaseTypeChoicePair() {}

ForceCharacteristicDefinitionBaseTypeChoicePair::ForceCharacteristicDefinitionBaseTypeChoicePair(
 whichOne ForceCharacteristicDefinitionBaseTypeTypeIn,
 ForceCharacteristicDefinitionBaseTypeVal ForceCharacteristicDefinitionBaseTypeValueIn)
{
  ForceCharacteristicDefinitionBaseTypeType = ForceCharacteristicDefinitionBaseTypeTypeIn;
  ForceCharacteristicDefinitionBaseTypeValue = ForceCharacteristicDefinitionBaseTypeValueIn;
}

ForceCharacteristicDefinitionBaseTypeChoicePair::~ForceCharacteristicDefinitionBaseTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (ForceCharacteristicDefinitionBaseTypeType == ToleranceE)
    delete ForceCharacteristicDefinitionBaseTypeValue.Tolerance;
  else if (ForceCharacteristicDefinitionBaseTypeType == NonToleranceE)
    delete ForceCharacteristicDefinitionBaseTypeValue.NonTolerance;
  #endif
}

void ForceCharacteristicDefinitionBaseTypeChoicePair::printSelf(FILE * outFile)
{
  if (ForceCharacteristicDefinitionBaseTypeType == ToleranceE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Tolerance");
      ForceCharacteristicDefinitionBaseTypeValue.Tolerance->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Tolerance>\n");
    }
  else if (ForceCharacteristicDefinitionBaseTypeType == NonToleranceE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonTolerance");
      ForceCharacteristicDefinitionBaseTypeValue.NonTolerance->printSelf(outFile);
      fprintf(outFile, "</NonTolerance>\n");
    }
}

bool ForceCharacteristicDefinitionBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ForceCharacteristicDefinitionBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ForceCharacteristicDefinitionBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ForceCharacteristicDefinitionBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ForceCharacteristicDefinitionBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class ForceCharacteristicItemBaseType

*/

ForceCharacteristicItemBaseType::ForceCharacteristicItemBaseType() :
  CharacteristicItemBaseType()
{
}

ForceCharacteristicItemBaseType::ForceCharacteristicItemBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  CharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

ForceCharacteristicItemBaseType::ForceCharacteristicItemBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  CharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

ForceCharacteristicItemBaseType::~ForceCharacteristicItemBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void ForceCharacteristicItemBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool ForceCharacteristicItemBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ForceCharacteristicItemBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ForceCharacteristicItemBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ForceCharacteristicItemBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ForceCharacteristicItemBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class ForceCharacteristicMeasurementBaseType

*/

ForceCharacteristicMeasurementBaseType::ForceCharacteristicMeasurementBaseType() :
  CharacteristicMeasurementBaseType()
{
  Value = 0;
  MaxValue = 0;
  MinValue = 0;
}

ForceCharacteristicMeasurementBaseType::ForceCharacteristicMeasurementBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredForceValueType * ValueIn,
 MeasuredForceValueType * MaxValueIn,
 MeasuredForceValueType * MinValueIn) :
  CharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  Value = ValueIn;
  MaxValue = MaxValueIn;
  MinValue = MinValueIn;
}

ForceCharacteristicMeasurementBaseType::ForceCharacteristicMeasurementBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredForceValueType * ValueIn,
 MeasuredForceValueType * MaxValueIn,
 MeasuredForceValueType * MinValueIn) :
  CharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  Value = ValueIn;
  MaxValue = MaxValueIn;
  MinValue = MinValueIn;
}

ForceCharacteristicMeasurementBaseType::~ForceCharacteristicMeasurementBaseType()
{
  #ifndef NODESTRUCT
  delete Value;
  delete MaxValue;
  delete MinValue;
  #endif
}

void ForceCharacteristicMeasurementBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ForceCharacteristicMeasurementBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ForceCharacteristicMeasurementBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ForceCharacteristicMeasurementBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ForceCharacteristicMeasurementBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ForceCharacteristicMeasurementBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredForceValueType * ForceCharacteristicMeasurementBaseType::getValue()
{return Value;}

void ForceCharacteristicMeasurementBaseType::setValue(MeasuredForceValueType * ValueIn)
{Value = ValueIn;}

MeasuredForceValueType * ForceCharacteristicMeasurementBaseType::getMaxValue()
{return MaxValue;}

void ForceCharacteristicMeasurementBaseType::setMaxValue(MeasuredForceValueType * MaxValueIn)
{MaxValue = MaxValueIn;}

MeasuredForceValueType * ForceCharacteristicMeasurementBaseType::getMinValue()
{return MinValue;}

void ForceCharacteristicMeasurementBaseType::setMinValue(MeasuredForceValueType * MinValueIn)
{MinValue = MinValueIn;}

/* ***************************************************************** */

/* class ForceCharacteristicNominalBaseType

*/

ForceCharacteristicNominalBaseType::ForceCharacteristicNominalBaseType() :
  CharacteristicNominalBaseType()
{
  TargetValue = 0;
}

ForceCharacteristicNominalBaseType::ForceCharacteristicNominalBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ForceValueType * TargetValueIn) :
  CharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  TargetValue = TargetValueIn;
}

ForceCharacteristicNominalBaseType::ForceCharacteristicNominalBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ForceValueType * TargetValueIn) :
  CharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  TargetValue = TargetValueIn;
}

ForceCharacteristicNominalBaseType::~ForceCharacteristicNominalBaseType()
{
  #ifndef NODESTRUCT
  delete TargetValue;
  #endif
}

void ForceCharacteristicNominalBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ForceCharacteristicNominalBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ForceCharacteristicNominalBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ForceCharacteristicNominalBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ForceCharacteristicNominalBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ForceCharacteristicNominalBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

ForceValueType * ForceCharacteristicNominalBaseType::getTargetValue()
{return TargetValue;}

void ForceCharacteristicNominalBaseType::setTargetValue(ForceValueType * TargetValueIn)
{TargetValue = TargetValueIn;}

/* ***************************************************************** */

/* class FormCharacteristicDefinitionBaseType

*/

FormCharacteristicDefinitionBaseType::FormCharacteristicDefinitionBaseType() :
  GeometricCharacteristicDefinitionBaseType()
{
}

FormCharacteristicDefinitionBaseType::FormCharacteristicDefinitionBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn) :
  GeometricCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn)
{
}

FormCharacteristicDefinitionBaseType::FormCharacteristicDefinitionBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn) :
  GeometricCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn)
{
}

FormCharacteristicDefinitionBaseType::~FormCharacteristicDefinitionBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void FormCharacteristicDefinitionBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (GeometricCharac_1050)
    {
  GeometricCharac_1050->printSelf(outFile);
    }
  if (DirectionFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DirectionFeature");
      DirectionFeature->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DirectionFeature>\n");
    }
  if (CollectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CollectionPlane");
      CollectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CollectionPlane>\n");
    }
  if (IntersectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IntersectionPlane");
      IntersectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</IntersectionPlane>\n");
    }
  if (OrientationPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OrientationPlane");
      OrientationPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OrientationPlane>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool FormCharacteristicDefinitionBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in FormCharacteristicDefinitionBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in FormCharacteristicDefinitionBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FormCharacteristicDefinitionBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in FormCharacteristicDefinitionBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class FormCharacteristicItemBaseType

*/

FormCharacteristicItemBaseType::FormCharacteristicItemBaseType() :
  GeometricCharacteristicItemBaseType()
{
}

FormCharacteristicItemBaseType::FormCharacteristicItemBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  GeometricCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

FormCharacteristicItemBaseType::FormCharacteristicItemBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  GeometricCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

FormCharacteristicItemBaseType::~FormCharacteristicItemBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void FormCharacteristicItemBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool FormCharacteristicItemBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in FormCharacteristicItemBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in FormCharacteristicItemBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FormCharacteristicItemBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in FormCharacteristicItemBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class FormCharacteristicMeasurementBaseType

*/

FormCharacteristicMeasurementBaseType::FormCharacteristicMeasurementBaseType() :
  GeometricCharacteristicMeasurementBaseType()
{
}

FormCharacteristicMeasurementBaseType::FormCharacteristicMeasurementBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  GeometricCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

FormCharacteristicMeasurementBaseType::FormCharacteristicMeasurementBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  GeometricCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

FormCharacteristicMeasurementBaseType::~FormCharacteristicMeasurementBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void FormCharacteristicMeasurementBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool FormCharacteristicMeasurementBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in FormCharacteristicMeasurementBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in FormCharacteristicMeasurementBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FormCharacteristicMeasurementBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in FormCharacteristicMeasurementBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class FormCharacteristicNominalBaseType

*/

FormCharacteristicNominalBaseType::FormCharacteristicNominalBaseType() :
  GeometricCharacteristicNominalBaseType()
{
}

FormCharacteristicNominalBaseType::FormCharacteristicNominalBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  GeometricCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

FormCharacteristicNominalBaseType::FormCharacteristicNominalBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  GeometricCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

FormCharacteristicNominalBaseType::~FormCharacteristicNominalBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void FormCharacteristicNominalBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool FormCharacteristicNominalBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in FormCharacteristicNominalBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in FormCharacteristicNominalBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FormCharacteristicNominalBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in FormCharacteristicNominalBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class GeometricCharacteristicDefinitionBaseType

*/

GeometricCharacteristicDefinitionBaseType::GeometricCharacteristicDefinitionBaseType() :
  CharacteristicDefinitionBaseType()
{
  GeometricCharac_1050 = 0;
  DirectionFeature = 0;
  CollectionPlane = 0;
  IntersectionPlane = 0;
  OrientationPlane = 0;
}

GeometricCharacteristicDefinitionBaseType::GeometricCharacteristicDefinitionBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn) :
  CharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
  GeometricCharac_1050 = GeometricCharac_1050In;
  DirectionFeature = DirectionFeatureIn;
  CollectionPlane = CollectionPlaneIn;
  IntersectionPlane = IntersectionPlaneIn;
  OrientationPlane = OrientationPlaneIn;
}

GeometricCharacteristicDefinitionBaseType::GeometricCharacteristicDefinitionBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn) :
  CharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
  GeometricCharac_1050 = GeometricCharac_1050In;
  DirectionFeature = DirectionFeatureIn;
  CollectionPlane = CollectionPlaneIn;
  IntersectionPlane = IntersectionPlaneIn;
  OrientationPlane = OrientationPlaneIn;
}

GeometricCharacteristicDefinitionBaseType::~GeometricCharacteristicDefinitionBaseType()
{
  #ifndef NODESTRUCT
  delete GeometricCharac_1050;
  delete DirectionFeature;
  delete CollectionPlane;
  delete IntersectionPlane;
  delete OrientationPlane;
  #endif
}

void GeometricCharacteristicDefinitionBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (GeometricCharac_1050)
    {
  GeometricCharac_1050->printSelf(outFile);
    }
  if (DirectionFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DirectionFeature");
      DirectionFeature->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DirectionFeature>\n");
    }
  if (CollectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CollectionPlane");
      CollectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CollectionPlane>\n");
    }
  if (IntersectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IntersectionPlane");
      IntersectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</IntersectionPlane>\n");
    }
  if (OrientationPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OrientationPlane");
      OrientationPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OrientationPlane>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool GeometricCharacteristicDefinitionBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in GeometricCharacteristicDefinitionBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in GeometricCharacteristicDefinitionBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in GeometricCharacteristicDefinitionBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in GeometricCharacteristicDefinitionBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

GeometricCharac_1050_Type * GeometricCharacteristicDefinitionBaseType::getGeometricCharac_1050()
{return GeometricCharac_1050;}

void GeometricCharacteristicDefinitionBaseType::setGeometricCharac_1050(GeometricCharac_1050_Type * GeometricCharac_1050In)
{GeometricCharac_1050 = GeometricCharac_1050In;}

DirectionFeatureType * GeometricCharacteristicDefinitionBaseType::getDirectionFeature()
{return DirectionFeature;}

void GeometricCharacteristicDefinitionBaseType::setDirectionFeature(DirectionFeatureType * DirectionFeatureIn)
{DirectionFeature = DirectionFeatureIn;}

CollectionPlaneType * GeometricCharacteristicDefinitionBaseType::getCollectionPlane()
{return CollectionPlane;}

void GeometricCharacteristicDefinitionBaseType::setCollectionPlane(CollectionPlaneType * CollectionPlaneIn)
{CollectionPlane = CollectionPlaneIn;}

IntersectionPlaneType * GeometricCharacteristicDefinitionBaseType::getIntersectionPlane()
{return IntersectionPlane;}

void GeometricCharacteristicDefinitionBaseType::setIntersectionPlane(IntersectionPlaneType * IntersectionPlaneIn)
{IntersectionPlane = IntersectionPlaneIn;}

OrientationPlaneType * GeometricCharacteristicDefinitionBaseType::getOrientationPlane()
{return OrientationPlane;}

void GeometricCharacteristicDefinitionBaseType::setOrientationPlane(OrientationPlaneType * OrientationPlaneIn)
{OrientationPlane = OrientationPlaneIn;}

/* ***************************************************************** */

/* class GeometricCharacteristicItemBaseType

*/

GeometricCharacteristicItemBaseType::GeometricCharacteristicItemBaseType() :
  CharacteristicItemBaseType()
{
}

GeometricCharacteristicItemBaseType::GeometricCharacteristicItemBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  CharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

GeometricCharacteristicItemBaseType::GeometricCharacteristicItemBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  CharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

GeometricCharacteristicItemBaseType::~GeometricCharacteristicItemBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void GeometricCharacteristicItemBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool GeometricCharacteristicItemBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in GeometricCharacteristicItemBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in GeometricCharacteristicItemBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in GeometricCharacteristicItemBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in GeometricCharacteristicItemBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class GeometricCharacteristicMeasurementBaseType

*/

GeometricCharacteristicMeasurementBaseType::GeometricCharacteristicMeasurementBaseType() :
  CharacteristicMeasurementBaseType()
{
  Value = 0;
  MaxValue = 0;
  MinValue = 0;
}

GeometricCharacteristicMeasurementBaseType::GeometricCharacteristicMeasurementBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  CharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  Value = ValueIn;
  MaxValue = MaxValueIn;
  MinValue = MinValueIn;
}

GeometricCharacteristicMeasurementBaseType::GeometricCharacteristicMeasurementBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  CharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  Value = ValueIn;
  MaxValue = MaxValueIn;
  MinValue = MinValueIn;
}

GeometricCharacteristicMeasurementBaseType::~GeometricCharacteristicMeasurementBaseType()
{
  #ifndef NODESTRUCT
  delete Value;
  delete MaxValue;
  delete MinValue;
  #endif
}

void GeometricCharacteristicMeasurementBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool GeometricCharacteristicMeasurementBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in GeometricCharacteristicMeasurementBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in GeometricCharacteristicMeasurementBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in GeometricCharacteristicMeasurementBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in GeometricCharacteristicMeasurementBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredLinearValueType * GeometricCharacteristicMeasurementBaseType::getValue()
{return Value;}

void GeometricCharacteristicMeasurementBaseType::setValue(MeasuredLinearValueType * ValueIn)
{Value = ValueIn;}

MeasuredLinearValueType * GeometricCharacteristicMeasurementBaseType::getMaxValue()
{return MaxValue;}

void GeometricCharacteristicMeasurementBaseType::setMaxValue(MeasuredLinearValueType * MaxValueIn)
{MaxValue = MaxValueIn;}

MeasuredLinearValueType * GeometricCharacteristicMeasurementBaseType::getMinValue()
{return MinValue;}

void GeometricCharacteristicMeasurementBaseType::setMinValue(MeasuredLinearValueType * MinValueIn)
{MinValue = MinValueIn;}

/* ***************************************************************** */

/* class GeometricCharacteristicNominalBaseType

*/

GeometricCharacteristicNominalBaseType::GeometricCharacteristicNominalBaseType() :
  CharacteristicNominalBaseType()
{
}

GeometricCharacteristicNominalBaseType::GeometricCharacteristicNominalBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  CharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

GeometricCharacteristicNominalBaseType::GeometricCharacteristicNominalBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  CharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

GeometricCharacteristicNominalBaseType::~GeometricCharacteristicNominalBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void GeometricCharacteristicNominalBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool GeometricCharacteristicNominalBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in GeometricCharacteristicNominalBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in GeometricCharacteristicNominalBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in GeometricCharacteristicNominalBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in GeometricCharacteristicNominalBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class HeightCharacteristicDefinitionType

*/

HeightCharacteristicDefinitionType::HeightCharacteristicDefinitionType() :
  LinearCharacteristicDefinitionBaseType()
{
}

HeightCharacteristicDefinitionType::HeightCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseTypePairIn) :
  LinearCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    LinearCharacteristicDefinitionBaseTypePairIn)
{
}

HeightCharacteristicDefinitionType::HeightCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseTypePairIn) :
  LinearCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    LinearCharacteristicDefinitionBaseTypePairIn)
{
}

HeightCharacteristicDefinitionType::~HeightCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void HeightCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (DimensionType)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionType");
      DimensionType->printSelf(outFile);
      fprintf(outFile, "</DimensionType>\n");
    }
  if (DimensionModifiers)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionModifiers");
      DimensionModifiers->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DimensionModifiers>\n");
    }
  LinearCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

bool HeightCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in HeightCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in HeightCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in HeightCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in HeightCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class HeightCharacteristicItemType

*/

HeightCharacteristicItemType::HeightCharacteristicItemType() :
  LinearCharacteristicItemBaseType()
{
}

HeightCharacteristicItemType::HeightCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LinearCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

HeightCharacteristicItemType::HeightCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LinearCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

HeightCharacteristicItemType::~HeightCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void HeightCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool HeightCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in HeightCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in HeightCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in HeightCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in HeightCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class HeightCharacteristicMeasurementType

*/

HeightCharacteristicMeasurementType::HeightCharacteristicMeasurementType() :
  LinearCharacteristicMeasurementBaseType()
{
}

HeightCharacteristicMeasurementType::HeightCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  LinearCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

HeightCharacteristicMeasurementType::HeightCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  LinearCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

HeightCharacteristicMeasurementType::~HeightCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void HeightCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool HeightCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in HeightCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in HeightCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in HeightCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in HeightCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class HeightCharacteristicNominalType

*/

HeightCharacteristicNominalType::HeightCharacteristicNominalType() :
  LinearCharacteristicNominalBaseType()
{
}

HeightCharacteristicNominalType::HeightCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn) :
  LinearCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn,
    TargetDualValueIn)
{
}

HeightCharacteristicNominalType::HeightCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn) :
  LinearCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn,
    TargetDualValueIn)
{
}

HeightCharacteristicNominalType::~HeightCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void HeightCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  if (TargetDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetDualValue");
      TargetDualValue->printSelf(outFile);
      fprintf(outFile, "</TargetDualValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool HeightCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in HeightCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in HeightCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in HeightCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in HeightCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class LengthCharacteristicDefinitionType

*/

LengthCharacteristicDefinitionType::LengthCharacteristicDefinitionType() :
  LinearCharacteristicDefinitionBaseType()
{
}

LengthCharacteristicDefinitionType::LengthCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseTypePairIn) :
  LinearCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    LinearCharacteristicDefinitionBaseTypePairIn)
{
}

LengthCharacteristicDefinitionType::LengthCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseTypePairIn) :
  LinearCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    LinearCharacteristicDefinitionBaseTypePairIn)
{
}

LengthCharacteristicDefinitionType::~LengthCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void LengthCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (DimensionType)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionType");
      DimensionType->printSelf(outFile);
      fprintf(outFile, "</DimensionType>\n");
    }
  if (DimensionModifiers)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionModifiers");
      DimensionModifiers->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DimensionModifiers>\n");
    }
  LinearCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

bool LengthCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in LengthCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in LengthCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in LengthCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in LengthCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class LengthCharacteristicItemType

*/

LengthCharacteristicItemType::LengthCharacteristicItemType() :
  LinearCharacteristicItemBaseType()
{
}

LengthCharacteristicItemType::LengthCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LinearCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

LengthCharacteristicItemType::LengthCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LinearCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

LengthCharacteristicItemType::~LengthCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void LengthCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool LengthCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in LengthCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in LengthCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in LengthCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in LengthCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class LengthCharacteristicMeasurementType

*/

LengthCharacteristicMeasurementType::LengthCharacteristicMeasurementType() :
  LinearCharacteristicMeasurementBaseType()
{
}

LengthCharacteristicMeasurementType::LengthCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  LinearCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

LengthCharacteristicMeasurementType::LengthCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  LinearCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

LengthCharacteristicMeasurementType::~LengthCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void LengthCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool LengthCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in LengthCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in LengthCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in LengthCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in LengthCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class LengthCharacteristicNominalType

*/

LengthCharacteristicNominalType::LengthCharacteristicNominalType() :
  LinearCharacteristicNominalBaseType()
{
}

LengthCharacteristicNominalType::LengthCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn) :
  LinearCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn,
    TargetDualValueIn)
{
}

LengthCharacteristicNominalType::LengthCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn) :
  LinearCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn,
    TargetDualValueIn)
{
}

LengthCharacteristicNominalType::~LengthCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void LengthCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  if (TargetDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetDualValue");
      TargetDualValue->printSelf(outFile);
      fprintf(outFile, "</TargetDualValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool LengthCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in LengthCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in LengthCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in LengthCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in LengthCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class LineProfileCharacteristicDefinitionType

*/

LineProfileCharacteristicDefinitionType::LineProfileCharacteristicDefinitionType() :
  ProfileCharacteristicDefinitionBaseType()
{
  Extent = 0;
}

LineProfileCharacteristicDefinitionType::LineProfileCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 ProfileCharacte_1056_Type * ProfileCharacte_1056In,
 XmlBoolean * OffsetZoneIn,
 XmlBoolean * VariableAngleIn,
 CompositeSegmentProfileDefinitionType * SecondCompositeSegmentProfileDefinitionIn,
 CompositeSegmentProfileDefinitionType * ThirdCompositeSegmentProfileDefinitionIn,
 CompositeSegmentProfileDefinitionType * FourthCompositeSegmentProfileDefinitionIn,
 QIFReferenceFullType * DatumReferenceFrameIdIn,
 XmlBoolean * OrientationOnlyIn,
 ExtentType * ExtentIn) :
  ProfileCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn,
    ToleranceValueIn,
    ToleranceDualValueIn,
    ProfileCharacte_1056In,
    OffsetZoneIn,
    VariableAngleIn,
    SecondCompositeSegmentProfileDefinitionIn,
    ThirdCompositeSegmentProfileDefinitionIn,
    FourthCompositeSegmentProfileDefinitionIn,
    DatumReferenceFrameIdIn,
    OrientationOnlyIn)
{
  Extent = ExtentIn;
}

LineProfileCharacteristicDefinitionType::LineProfileCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 ProfileCharacte_1056_Type * ProfileCharacte_1056In,
 XmlBoolean * OffsetZoneIn,
 XmlBoolean * VariableAngleIn,
 CompositeSegmentProfileDefinitionType * SecondCompositeSegmentProfileDefinitionIn,
 CompositeSegmentProfileDefinitionType * ThirdCompositeSegmentProfileDefinitionIn,
 CompositeSegmentProfileDefinitionType * FourthCompositeSegmentProfileDefinitionIn,
 QIFReferenceFullType * DatumReferenceFrameIdIn,
 XmlBoolean * OrientationOnlyIn,
 ExtentType * ExtentIn) :
  ProfileCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn,
    ToleranceValueIn,
    ToleranceDualValueIn,
    ProfileCharacte_1056In,
    OffsetZoneIn,
    VariableAngleIn,
    SecondCompositeSegmentProfileDefinitionIn,
    ThirdCompositeSegmentProfileDefinitionIn,
    FourthCompositeSegmentProfileDefinitionIn,
    DatumReferenceFrameIdIn,
    OrientationOnlyIn)
{
  Extent = ExtentIn;
}

LineProfileCharacteristicDefinitionType::~LineProfileCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  delete Extent;
  #endif
}

void LineProfileCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (GeometricCharac_1050)
    {
  GeometricCharac_1050->printSelf(outFile);
    }
  if (DirectionFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DirectionFeature");
      DirectionFeature->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DirectionFeature>\n");
    }
  if (CollectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CollectionPlane");
      CollectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CollectionPlane>\n");
    }
  if (IntersectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IntersectionPlane");
      IntersectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</IntersectionPlane>\n");
    }
  if (OrientationPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OrientationPlane");
      OrientationPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OrientationPlane>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ToleranceValue");
  ToleranceValue->printSelf(outFile);
  fprintf(outFile, "</ToleranceValue>\n");
  if (ToleranceDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceDualValue");
      ToleranceDualValue->printSelf(outFile);
      fprintf(outFile, "</ToleranceDualValue>\n");
    }
  if (ProfileCharacte_1056)
    {
  ProfileCharacte_1056->printSelf(outFile);
    }
  if (OffsetZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OffsetZone");
      OffsetZone->printSelf(outFile);
      fprintf(outFile, "</OffsetZone>\n");
    }
  if (VariableAngle)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VariableAngle");
      VariableAngle->printSelf(outFile);
      fprintf(outFile, "</VariableAngle>\n");
    }
  if (SecondCompositeSegmentProfileDefinition)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SecondCompositeSegmentProfileDefinition");
      SecondCompositeSegmentProfileDefinition->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SecondCompositeSegmentProfileDefinition>\n");
    }
  if (ThirdCompositeSegmentProfileDefinition)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ThirdCompositeSegmentProfileDefinition");
      ThirdCompositeSegmentProfileDefinition->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ThirdCompositeSegmentProfileDefinition>\n");
    }
  if (FourthCompositeSegmentProfileDefinition)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FourthCompositeSegmentProfileDefinition");
      FourthCompositeSegmentProfileDefinition->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FourthCompositeSegmentProfileDefinition>\n");
    }
  if (DatumReferenceFrameId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumReferenceFrameId");
      DatumReferenceFrameId->printSelf(outFile);
      fprintf(outFile, "</DatumReferenceFrameId>\n");
    }
  if (OrientationOnly)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OrientationOnly");
      OrientationOnly->printSelf(outFile);
      fprintf(outFile, "</OrientationOnly>\n");
    }
  if (Extent)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Extent");
      Extent->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Extent>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool LineProfileCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in LineProfileCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in LineProfileCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in LineProfileCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in LineProfileCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

ExtentType * LineProfileCharacteristicDefinitionType::getExtent()
{return Extent;}

void LineProfileCharacteristicDefinitionType::setExtent(ExtentType * ExtentIn)
{Extent = ExtentIn;}

/* ***************************************************************** */

/* class LineProfileCharacteristicItemType

*/

LineProfileCharacteristicItemType::LineProfileCharacteristicItemType() :
  ProfileCharacteristicItemBaseType()
{
}

LineProfileCharacteristicItemType::LineProfileCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  ProfileCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

LineProfileCharacteristicItemType::LineProfileCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  ProfileCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

LineProfileCharacteristicItemType::~LineProfileCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void LineProfileCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool LineProfileCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in LineProfileCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in LineProfileCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in LineProfileCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in LineProfileCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class LineProfileCharacteristicMeasurementType

*/

LineProfileCharacteristicMeasurementType::LineProfileCharacteristicMeasurementType() :
  ProfileCharacteristicMeasurementBaseType()
{
}

LineProfileCharacteristicMeasurementType::LineProfileCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 LinearValueType * WorstPositiveDeviationIn,
 LinearValueType * WorstNegativeDeviationIn,
 PointDeviationsType * PointDeviationsIn,
 XmlBoolean * DatumsOkIn,
 QIFReferenceType * DRFTransformActualIdIn,
 CompositeSegmentProfileMeasurementType * SecondCompositeSegmentProfileMeasurementIn,
 CompositeSegmentProfileMeasurementType * ThirdCompositeSegmentProfileMeasurementIn,
 CompositeSegmentProfileMeasurementType * FourthCompositeSegmentProfileMeasurementIn) :
  ProfileCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn,
    WorstPositiveDeviationIn,
    WorstNegativeDeviationIn,
    PointDeviationsIn,
    DatumsOkIn,
    DRFTransformActualIdIn,
    SecondCompositeSegmentProfileMeasurementIn,
    ThirdCompositeSegmentProfileMeasurementIn,
    FourthCompositeSegmentProfileMeasurementIn)
{
}

LineProfileCharacteristicMeasurementType::LineProfileCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 LinearValueType * WorstPositiveDeviationIn,
 LinearValueType * WorstNegativeDeviationIn,
 PointDeviationsType * PointDeviationsIn,
 XmlBoolean * DatumsOkIn,
 QIFReferenceType * DRFTransformActualIdIn,
 CompositeSegmentProfileMeasurementType * SecondCompositeSegmentProfileMeasurementIn,
 CompositeSegmentProfileMeasurementType * ThirdCompositeSegmentProfileMeasurementIn,
 CompositeSegmentProfileMeasurementType * FourthCompositeSegmentProfileMeasurementIn) :
  ProfileCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn,
    WorstPositiveDeviationIn,
    WorstNegativeDeviationIn,
    PointDeviationsIn,
    DatumsOkIn,
    DRFTransformActualIdIn,
    SecondCompositeSegmentProfileMeasurementIn,
    ThirdCompositeSegmentProfileMeasurementIn,
    FourthCompositeSegmentProfileMeasurementIn)
{
}

LineProfileCharacteristicMeasurementType::~LineProfileCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void LineProfileCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  if (WorstPositiveDeviation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WorstPositiveDeviation");
      WorstPositiveDeviation->printSelf(outFile);
      fprintf(outFile, "</WorstPositiveDeviation>\n");
    }
  if (WorstNegativeDeviation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WorstNegativeDeviation");
      WorstNegativeDeviation->printSelf(outFile);
      fprintf(outFile, "</WorstNegativeDeviation>\n");
    }
  if (PointDeviations)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointDeviations");
      PointDeviations->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointDeviations>\n");
    }
  if (DatumsOk)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumsOk");
      DatumsOk->printSelf(outFile);
      fprintf(outFile, "</DatumsOk>\n");
    }
  if (DRFTransformActualId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DRFTransformActualId");
      DRFTransformActualId->printSelf(outFile);
      fprintf(outFile, "</DRFTransformActualId>\n");
    }
  if (SecondCompositeSegmentProfileMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SecondCompositeSegmentProfileMeasurement");
      SecondCompositeSegmentProfileMeasurement->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SecondCompositeSegmentProfileMeasurement>\n");
    }
  if (ThirdCompositeSegmentProfileMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ThirdCompositeSegmentProfileMeasurement");
      ThirdCompositeSegmentProfileMeasurement->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ThirdCompositeSegmentProfileMeasurement>\n");
    }
  if (FourthCompositeSegmentProfileMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FourthCompositeSegmentProfileMeasurement");
      FourthCompositeSegmentProfileMeasurement->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FourthCompositeSegmentProfileMeasurement>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool LineProfileCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in LineProfileCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in LineProfileCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in LineProfileCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in LineProfileCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class LineProfileCharacteristicNominalType

*/

LineProfileCharacteristicNominalType::LineProfileCharacteristicNominalType() :
  ProfileCharacteristicNominalBaseType()
{
  Vector = 0;
  ProfileCurveId = 0;
}

LineProfileCharacteristicNominalType::LineProfileCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 UnitVectorType * VectorIn,
 QIFReferenceFullType * ProfileCurveIdIn) :
  ProfileCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn)
{
  Vector = VectorIn;
  ProfileCurveId = ProfileCurveIdIn;
}

LineProfileCharacteristicNominalType::LineProfileCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 UnitVectorType * VectorIn,
 QIFReferenceFullType * ProfileCurveIdIn) :
  ProfileCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn)
{
  Vector = VectorIn;
  ProfileCurveId = ProfileCurveIdIn;
}

LineProfileCharacteristicNominalType::~LineProfileCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  delete Vector;
  delete ProfileCurveId;
  #endif
}

void LineProfileCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Vector");
  Vector->printSelf(outFile);
  fprintf(outFile, "</Vector>\n");
  if (ProfileCurveId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProfileCurveId");
      ProfileCurveId->printSelf(outFile);
      fprintf(outFile, "</ProfileCurveId>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool LineProfileCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in LineProfileCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in LineProfileCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in LineProfileCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in LineProfileCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

UnitVectorType * LineProfileCharacteristicNominalType::getVector()
{return Vector;}

void LineProfileCharacteristicNominalType::setVector(UnitVectorType * VectorIn)
{Vector = VectorIn;}

QIFReferenceFullType * LineProfileCharacteristicNominalType::getProfileCurveId()
{return ProfileCurveId;}

void LineProfileCharacteristicNominalType::setProfileCurveId(QIFReferenceFullType * ProfileCurveIdIn)
{ProfileCurveId = ProfileCurveIdIn;}

/* ***************************************************************** */

/* class LinearCharacteristicDefinitionBaseType

*/

LinearCharacteristicDefinitionBaseType::LinearCharacteristicDefinitionBaseType() :
  DimensionalCharacteristicDefinitionBaseType()
{
  LinearCharacteristicDefinitionBaseTypePair = 0;
}

LinearCharacteristicDefinitionBaseType::LinearCharacteristicDefinitionBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseTypePairIn) :
  DimensionalCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn)
{
  LinearCharacteristicDefinitionBaseTypePair = LinearCharacteristicDefinitionBaseTypePairIn;
}

LinearCharacteristicDefinitionBaseType::LinearCharacteristicDefinitionBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseTypePairIn) :
  DimensionalCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn)
{
  LinearCharacteristicDefinitionBaseTypePair = LinearCharacteristicDefinitionBaseTypePairIn;
}

LinearCharacteristicDefinitionBaseType::~LinearCharacteristicDefinitionBaseType()
{
  #ifndef NODESTRUCT
  delete LinearCharacteristicDefinitionBaseTypePair;
  #endif
}

void LinearCharacteristicDefinitionBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (DimensionType)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionType");
      DimensionType->printSelf(outFile);
      fprintf(outFile, "</DimensionType>\n");
    }
  if (DimensionModifiers)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionModifiers");
      DimensionModifiers->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DimensionModifiers>\n");
    }
  LinearCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}
LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseType::getLinearCharacteristicDefinitionBaseTypeChoicePair()
{return LinearCharacteristicDefinitionBaseTypePair;}

void LinearCharacteristicDefinitionBaseType::setLinearCharacteristicDefinitionBaseTypeChoicePair(LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseTypePairIn)
{LinearCharacteristicDefinitionBaseTypePair = LinearCharacteristicDefinitionBaseTypePairIn;}

/* ***************************************************************** */

LinearCharacteristicDefinitionBaseTypeChoicePair::LinearCharacteristicDefinitionBaseTypeChoicePair() {}

LinearCharacteristicDefinitionBaseTypeChoicePair::LinearCharacteristicDefinitionBaseTypeChoicePair(
 whichOne LinearCharacteristicDefinitionBaseTypeTypeIn,
 LinearCharacteristicDefinitionBaseTypeVal LinearCharacteristicDefinitionBaseTypeValueIn)
{
  LinearCharacteristicDefinitionBaseTypeType = LinearCharacteristicDefinitionBaseTypeTypeIn;
  LinearCharacteristicDefinitionBaseTypeValue = LinearCharacteristicDefinitionBaseTypeValueIn;
}

LinearCharacteristicDefinitionBaseTypeChoicePair::~LinearCharacteristicDefinitionBaseTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (LinearCharacteristicDefinitionBaseTypeType == ToleranceE)
    delete LinearCharacteristicDefinitionBaseTypeValue.Tolerance;
  else if (LinearCharacteristicDefinitionBaseTypeType == NonToleranceE)
    delete LinearCharacteristicDefinitionBaseTypeValue.NonTolerance;
  #endif
}

void LinearCharacteristicDefinitionBaseTypeChoicePair::printSelf(FILE * outFile)
{
  if (LinearCharacteristicDefinitionBaseTypeType == ToleranceE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Tolerance");
      LinearCharacteristicDefinitionBaseTypeValue.Tolerance->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Tolerance>\n");
    }
  else if (LinearCharacteristicDefinitionBaseTypeType == NonToleranceE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonTolerance");
      LinearCharacteristicDefinitionBaseTypeValue.NonTolerance->printSelf(outFile);
      fprintf(outFile, "</NonTolerance>\n");
    }
}

bool LinearCharacteristicDefinitionBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in LinearCharacteristicDefinitionBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in LinearCharacteristicDefinitionBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in LinearCharacteristicDefinitionBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in LinearCharacteristicDefinitionBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class LinearCharacteristicItemBaseType

*/

LinearCharacteristicItemBaseType::LinearCharacteristicItemBaseType() :
  DimensionalCharacteristicItemBaseType()
{
}

LinearCharacteristicItemBaseType::LinearCharacteristicItemBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  DimensionalCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

LinearCharacteristicItemBaseType::LinearCharacteristicItemBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  DimensionalCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

LinearCharacteristicItemBaseType::~LinearCharacteristicItemBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void LinearCharacteristicItemBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool LinearCharacteristicItemBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in LinearCharacteristicItemBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in LinearCharacteristicItemBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in LinearCharacteristicItemBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in LinearCharacteristicItemBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class LinearCharacteristicMeasurementBaseType

*/

LinearCharacteristicMeasurementBaseType::LinearCharacteristicMeasurementBaseType() :
  DimensionalCharacteristicMeasurementBaseType()
{
  Value = 0;
  MaxValue = 0;
  MinValue = 0;
}

LinearCharacteristicMeasurementBaseType::LinearCharacteristicMeasurementBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  DimensionalCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  Value = ValueIn;
  MaxValue = MaxValueIn;
  MinValue = MinValueIn;
}

LinearCharacteristicMeasurementBaseType::LinearCharacteristicMeasurementBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  DimensionalCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  Value = ValueIn;
  MaxValue = MaxValueIn;
  MinValue = MinValueIn;
}

LinearCharacteristicMeasurementBaseType::~LinearCharacteristicMeasurementBaseType()
{
  #ifndef NODESTRUCT
  delete Value;
  delete MaxValue;
  delete MinValue;
  #endif
}

void LinearCharacteristicMeasurementBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool LinearCharacteristicMeasurementBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in LinearCharacteristicMeasurementBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in LinearCharacteristicMeasurementBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in LinearCharacteristicMeasurementBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in LinearCharacteristicMeasurementBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredLinearValueType * LinearCharacteristicMeasurementBaseType::getValue()
{return Value;}

void LinearCharacteristicMeasurementBaseType::setValue(MeasuredLinearValueType * ValueIn)
{Value = ValueIn;}

MeasuredLinearValueType * LinearCharacteristicMeasurementBaseType::getMaxValue()
{return MaxValue;}

void LinearCharacteristicMeasurementBaseType::setMaxValue(MeasuredLinearValueType * MaxValueIn)
{MaxValue = MaxValueIn;}

MeasuredLinearValueType * LinearCharacteristicMeasurementBaseType::getMinValue()
{return MinValue;}

void LinearCharacteristicMeasurementBaseType::setMinValue(MeasuredLinearValueType * MinValueIn)
{MinValue = MinValueIn;}

/* ***************************************************************** */

/* class LinearCharacteristicNominalBaseType

*/

LinearCharacteristicNominalBaseType::LinearCharacteristicNominalBaseType() :
  DimensionalCharacteristicNominalBaseType()
{
  TargetValue = 0;
  TargetDualValue = 0;
}

LinearCharacteristicNominalBaseType::LinearCharacteristicNominalBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn) :
  DimensionalCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  TargetValue = TargetValueIn;
  TargetDualValue = TargetDualValueIn;
}

LinearCharacteristicNominalBaseType::LinearCharacteristicNominalBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn) :
  DimensionalCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  TargetValue = TargetValueIn;
  TargetDualValue = TargetDualValueIn;
}

LinearCharacteristicNominalBaseType::~LinearCharacteristicNominalBaseType()
{
  #ifndef NODESTRUCT
  delete TargetValue;
  delete TargetDualValue;
  #endif
}

void LinearCharacteristicNominalBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  if (TargetDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetDualValue");
      TargetDualValue->printSelf(outFile);
      fprintf(outFile, "</TargetDualValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool LinearCharacteristicNominalBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in LinearCharacteristicNominalBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in LinearCharacteristicNominalBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in LinearCharacteristicNominalBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in LinearCharacteristicNominalBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LinearValueType * LinearCharacteristicNominalBaseType::getTargetValue()
{return TargetValue;}

void LinearCharacteristicNominalBaseType::setTargetValue(LinearValueType * TargetValueIn)
{TargetValue = TargetValueIn;}

LinearDualValueType * LinearCharacteristicNominalBaseType::getTargetDualValue()
{return TargetDualValue;}

void LinearCharacteristicNominalBaseType::setTargetDualValue(LinearDualValueType * TargetDualValueIn)
{TargetDualValue = TargetDualValueIn;}

/* ***************************************************************** */

/* class LinearCoordinateCharacteristicDefinitionType

*/

LinearCoordinateCharacteristicDefinitionType::LinearCoordinateCharacteristicDefinitionType() :
  CoordinateCharacteristicDefinitionBaseType()
{
  LinearCoordinateCharacteristicDefinitionTypePair = 0;
}

LinearCoordinateCharacteristicDefinitionType::LinearCoordinateCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCoordinateCharacteristicDefinitionTypeChoicePair * LinearCoordinateCharacteristicDefinitionTypePairIn) :
  CoordinateCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn)
{
  LinearCoordinateCharacteristicDefinitionTypePair = LinearCoordinateCharacteristicDefinitionTypePairIn;
}

LinearCoordinateCharacteristicDefinitionType::LinearCoordinateCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCoordinateCharacteristicDefinitionTypeChoicePair * LinearCoordinateCharacteristicDefinitionTypePairIn) :
  CoordinateCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn)
{
  LinearCoordinateCharacteristicDefinitionTypePair = LinearCoordinateCharacteristicDefinitionTypePairIn;
}

LinearCoordinateCharacteristicDefinitionType::~LinearCoordinateCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  delete LinearCoordinateCharacteristicDefinitionTypePair;
  #endif
}

void LinearCoordinateCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (DimensionType)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionType");
      DimensionType->printSelf(outFile);
      fprintf(outFile, "</DimensionType>\n");
    }
  if (DimensionModifiers)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionModifiers");
      DimensionModifiers->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DimensionModifiers>\n");
    }
  LinearCoordinateCharacteristicDefinitionTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}
LinearCoordinateCharacteristicDefinitionTypeChoicePair * LinearCoordinateCharacteristicDefinitionType::getLinearCoordinateCharacteristicDefinitionTypeChoicePair()
{return LinearCoordinateCharacteristicDefinitionTypePair;}

void LinearCoordinateCharacteristicDefinitionType::setLinearCoordinateCharacteristicDefinitionTypeChoicePair(LinearCoordinateCharacteristicDefinitionTypeChoicePair * LinearCoordinateCharacteristicDefinitionTypePairIn)
{LinearCoordinateCharacteristicDefinitionTypePair = LinearCoordinateCharacteristicDefinitionTypePairIn;}

/* ***************************************************************** */

LinearCoordinateCharacteristicDefinitionTypeChoicePair::LinearCoordinateCharacteristicDefinitionTypeChoicePair() {}

LinearCoordinateCharacteristicDefinitionTypeChoicePair::LinearCoordinateCharacteristicDefinitionTypeChoicePair(
 whichOne LinearCoordinateCharacteristicDefinitionTypeTypeIn,
 LinearCoordinateCharacteristicDefinitionTypeVal LinearCoordinateCharacteristicDefinitionTypeValueIn)
{
  LinearCoordinateCharacteristicDefinitionTypeType = LinearCoordinateCharacteristicDefinitionTypeTypeIn;
  LinearCoordinateCharacteristicDefinitionTypeValue = LinearCoordinateCharacteristicDefinitionTypeValueIn;
}

LinearCoordinateCharacteristicDefinitionTypeChoicePair::~LinearCoordinateCharacteristicDefinitionTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (LinearCoordinateCharacteristicDefinitionTypeType == ToleranceE)
    delete LinearCoordinateCharacteristicDefinitionTypeValue.Tolerance;
  else if (LinearCoordinateCharacteristicDefinitionTypeType == NonToleranceE)
    delete LinearCoordinateCharacteristicDefinitionTypeValue.NonTolerance;
  #endif
}

void LinearCoordinateCharacteristicDefinitionTypeChoicePair::printSelf(FILE * outFile)
{
  if (LinearCoordinateCharacteristicDefinitionTypeType == ToleranceE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Tolerance");
      LinearCoordinateCharacteristicDefinitionTypeValue.Tolerance->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Tolerance>\n");
    }
  else if (LinearCoordinateCharacteristicDefinitionTypeType == NonToleranceE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonTolerance");
      LinearCoordinateCharacteristicDefinitionTypeValue.NonTolerance->printSelf(outFile);
      fprintf(outFile, "</NonTolerance>\n");
    }
}

bool LinearCoordinateCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in LinearCoordinateCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in LinearCoordinateCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in LinearCoordinateCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in LinearCoordinateCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class LinearCoordinateCharacteristicItemType

*/

LinearCoordinateCharacteristicItemType::LinearCoordinateCharacteristicItemType() :
  CoordinateCharacteristicItemBaseType()
{
}

LinearCoordinateCharacteristicItemType::LinearCoordinateCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  CoordinateCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

LinearCoordinateCharacteristicItemType::LinearCoordinateCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  CoordinateCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

LinearCoordinateCharacteristicItemType::~LinearCoordinateCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void LinearCoordinateCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool LinearCoordinateCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in LinearCoordinateCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in LinearCoordinateCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in LinearCoordinateCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in LinearCoordinateCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class LinearCoordinateCharacteristicMeasurementType

*/

LinearCoordinateCharacteristicMeasurementType::LinearCoordinateCharacteristicMeasurementType() :
  CoordinateCharacteristicMeasurementBaseType()
{
  Value = 0;
  MaxValue = 0;
  MinValue = 0;
}

LinearCoordinateCharacteristicMeasurementType::LinearCoordinateCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 TypeOfCoordinatesType * TypeOfCoordinatesIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  CoordinateCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    TypeOfCoordinatesIn)
{
  Value = ValueIn;
  MaxValue = MaxValueIn;
  MinValue = MinValueIn;
}

LinearCoordinateCharacteristicMeasurementType::LinearCoordinateCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 TypeOfCoordinatesType * TypeOfCoordinatesIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  CoordinateCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    TypeOfCoordinatesIn)
{
  Value = ValueIn;
  MaxValue = MaxValueIn;
  MinValue = MinValueIn;
}

LinearCoordinateCharacteristicMeasurementType::~LinearCoordinateCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  delete Value;
  delete MaxValue;
  delete MinValue;
  #endif
}

void LinearCoordinateCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<TypeOfCoordinates");
  TypeOfCoordinates->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</TypeOfCoordinates>\n");
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool LinearCoordinateCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in LinearCoordinateCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in LinearCoordinateCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in LinearCoordinateCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in LinearCoordinateCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredLinearValueType * LinearCoordinateCharacteristicMeasurementType::getValue()
{return Value;}

void LinearCoordinateCharacteristicMeasurementType::setValue(MeasuredLinearValueType * ValueIn)
{Value = ValueIn;}

MeasuredLinearValueType * LinearCoordinateCharacteristicMeasurementType::getMaxValue()
{return MaxValue;}

void LinearCoordinateCharacteristicMeasurementType::setMaxValue(MeasuredLinearValueType * MaxValueIn)
{MaxValue = MaxValueIn;}

MeasuredLinearValueType * LinearCoordinateCharacteristicMeasurementType::getMinValue()
{return MinValue;}

void LinearCoordinateCharacteristicMeasurementType::setMinValue(MeasuredLinearValueType * MinValueIn)
{MinValue = MinValueIn;}

/* ***************************************************************** */

/* class LinearCoordinateCharacteristicNominalType

*/

LinearCoordinateCharacteristicNominalType::LinearCoordinateCharacteristicNominalType() :
  CoordinateCharacteristicNominalBaseType()
{
  TargetValue = 0;
  Direction = 0;
  CoordinateSystemId = 0;
}

LinearCoordinateCharacteristicNominalType::LinearCoordinateCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearCoordinateDirectionEnumType * DirectionIn,
 QIFReferenceFullType * CoordinateSystemIdIn) :
  CoordinateCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  TargetValue = TargetValueIn;
  Direction = DirectionIn;
  CoordinateSystemId = CoordinateSystemIdIn;
}

LinearCoordinateCharacteristicNominalType::LinearCoordinateCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearCoordinateDirectionEnumType * DirectionIn,
 QIFReferenceFullType * CoordinateSystemIdIn) :
  CoordinateCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  TargetValue = TargetValueIn;
  Direction = DirectionIn;
  CoordinateSystemId = CoordinateSystemIdIn;
}

LinearCoordinateCharacteristicNominalType::~LinearCoordinateCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  delete TargetValue;
  delete Direction;
  delete CoordinateSystemId;
  #endif
}

void LinearCoordinateCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Direction");
  Direction->printSelf(outFile);
  fprintf(outFile, "</Direction>\n");
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool LinearCoordinateCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in LinearCoordinateCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in LinearCoordinateCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in LinearCoordinateCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in LinearCoordinateCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LinearValueType * LinearCoordinateCharacteristicNominalType::getTargetValue()
{return TargetValue;}

void LinearCoordinateCharacteristicNominalType::setTargetValue(LinearValueType * TargetValueIn)
{TargetValue = TargetValueIn;}

LinearCoordinateDirectionEnumType * LinearCoordinateCharacteristicNominalType::getDirection()
{return Direction;}

void LinearCoordinateCharacteristicNominalType::setDirection(LinearCoordinateDirectionEnumType * DirectionIn)
{Direction = DirectionIn;}

QIFReferenceFullType * LinearCoordinateCharacteristicNominalType::getCoordinateSystemId()
{return CoordinateSystemId;}

void LinearCoordinateCharacteristicNominalType::setCoordinateSystemId(QIFReferenceFullType * CoordinateSystemIdIn)
{CoordinateSystemId = CoordinateSystemIdIn;}

/* ***************************************************************** */

/* class LocationCharacteristicDefinitionBaseType

*/

LocationCharacteristicDefinitionBaseType::LocationCharacteristicDefinitionBaseType() :
  GeometricCharacteristicDefinitionBaseType()
{
  ToleranceValue = 0;
  ToleranceDualValue = 0;
  DatumReferenceFrameId = 0;
}

LocationCharacteristicDefinitionBaseType::LocationCharacteristicDefinitionBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 QIFReferenceFullType * DatumReferenceFrameIdIn) :
  GeometricCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn)
{
  ToleranceValue = ToleranceValueIn;
  ToleranceDualValue = ToleranceDualValueIn;
  DatumReferenceFrameId = DatumReferenceFrameIdIn;
}

LocationCharacteristicDefinitionBaseType::LocationCharacteristicDefinitionBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 QIFReferenceFullType * DatumReferenceFrameIdIn) :
  GeometricCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn)
{
  ToleranceValue = ToleranceValueIn;
  ToleranceDualValue = ToleranceDualValueIn;
  DatumReferenceFrameId = DatumReferenceFrameIdIn;
}

LocationCharacteristicDefinitionBaseType::~LocationCharacteristicDefinitionBaseType()
{
  #ifndef NODESTRUCT
  delete ToleranceValue;
  delete ToleranceDualValue;
  delete DatumReferenceFrameId;
  #endif
}

void LocationCharacteristicDefinitionBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (GeometricCharac_1050)
    {
  GeometricCharac_1050->printSelf(outFile);
    }
  if (DirectionFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DirectionFeature");
      DirectionFeature->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DirectionFeature>\n");
    }
  if (CollectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CollectionPlane");
      CollectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CollectionPlane>\n");
    }
  if (IntersectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IntersectionPlane");
      IntersectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</IntersectionPlane>\n");
    }
  if (OrientationPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OrientationPlane");
      OrientationPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OrientationPlane>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ToleranceValue");
  ToleranceValue->printSelf(outFile);
  fprintf(outFile, "</ToleranceValue>\n");
  if (ToleranceDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceDualValue");
      ToleranceDualValue->printSelf(outFile);
      fprintf(outFile, "</ToleranceDualValue>\n");
    }
  if (DatumReferenceFrameId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumReferenceFrameId");
      DatumReferenceFrameId->printSelf(outFile);
      fprintf(outFile, "</DatumReferenceFrameId>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool LocationCharacteristicDefinitionBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in LocationCharacteristicDefinitionBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in LocationCharacteristicDefinitionBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in LocationCharacteristicDefinitionBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in LocationCharacteristicDefinitionBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LinearValueType * LocationCharacteristicDefinitionBaseType::getToleranceValue()
{return ToleranceValue;}

void LocationCharacteristicDefinitionBaseType::setToleranceValue(LinearValueType * ToleranceValueIn)
{ToleranceValue = ToleranceValueIn;}

LinearDualValueType * LocationCharacteristicDefinitionBaseType::getToleranceDualValue()
{return ToleranceDualValue;}

void LocationCharacteristicDefinitionBaseType::setToleranceDualValue(LinearDualValueType * ToleranceDualValueIn)
{ToleranceDualValue = ToleranceDualValueIn;}

QIFReferenceFullType * LocationCharacteristicDefinitionBaseType::getDatumReferenceFrameId()
{return DatumReferenceFrameId;}

void LocationCharacteristicDefinitionBaseType::setDatumReferenceFrameId(QIFReferenceFullType * DatumReferenceFrameIdIn)
{DatumReferenceFrameId = DatumReferenceFrameIdIn;}

/* ***************************************************************** */

/* class LocationCharacteristicItemBaseType

*/

LocationCharacteristicItemBaseType::LocationCharacteristicItemBaseType() :
  GeometricCharacteristicItemBaseType()
{
}

LocationCharacteristicItemBaseType::LocationCharacteristicItemBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  GeometricCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

LocationCharacteristicItemBaseType::LocationCharacteristicItemBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  GeometricCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

LocationCharacteristicItemBaseType::~LocationCharacteristicItemBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void LocationCharacteristicItemBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool LocationCharacteristicItemBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in LocationCharacteristicItemBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in LocationCharacteristicItemBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in LocationCharacteristicItemBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in LocationCharacteristicItemBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class LocationCharacteristicMeasurementBaseType

*/

LocationCharacteristicMeasurementBaseType::LocationCharacteristicMeasurementBaseType() :
  GeometricCharacteristicMeasurementBaseType()
{
  ZoneDataSet = 0;
  DatumsOk = 0;
}

LocationCharacteristicMeasurementBaseType::LocationCharacteristicMeasurementBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 ZoneDataSetType * ZoneDataSetIn,
 XmlBoolean * DatumsOkIn) :
  GeometricCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
  ZoneDataSet = ZoneDataSetIn;
  DatumsOk = DatumsOkIn;
}

LocationCharacteristicMeasurementBaseType::LocationCharacteristicMeasurementBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 ZoneDataSetType * ZoneDataSetIn,
 XmlBoolean * DatumsOkIn) :
  GeometricCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
  ZoneDataSet = ZoneDataSetIn;
  DatumsOk = DatumsOkIn;
}

LocationCharacteristicMeasurementBaseType::~LocationCharacteristicMeasurementBaseType()
{
  #ifndef NODESTRUCT
  delete ZoneDataSet;
  delete DatumsOk;
  #endif
}

void LocationCharacteristicMeasurementBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  if (ZoneDataSet)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ZoneDataSet");
      ZoneDataSet->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ZoneDataSet>\n");
    }
  if (DatumsOk)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumsOk");
      DatumsOk->printSelf(outFile);
      fprintf(outFile, "</DatumsOk>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool LocationCharacteristicMeasurementBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in LocationCharacteristicMeasurementBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in LocationCharacteristicMeasurementBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in LocationCharacteristicMeasurementBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in LocationCharacteristicMeasurementBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

ZoneDataSetType * LocationCharacteristicMeasurementBaseType::getZoneDataSet()
{return ZoneDataSet;}

void LocationCharacteristicMeasurementBaseType::setZoneDataSet(ZoneDataSetType * ZoneDataSetIn)
{ZoneDataSet = ZoneDataSetIn;}

XmlBoolean * LocationCharacteristicMeasurementBaseType::getDatumsOk()
{return DatumsOk;}

void LocationCharacteristicMeasurementBaseType::setDatumsOk(XmlBoolean * DatumsOkIn)
{DatumsOk = DatumsOkIn;}

/* ***************************************************************** */

/* class LocationCharacteristicNominalBaseType

*/

LocationCharacteristicNominalBaseType::LocationCharacteristicNominalBaseType() :
  GeometricCharacteristicNominalBaseType()
{
}

LocationCharacteristicNominalBaseType::LocationCharacteristicNominalBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  GeometricCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

LocationCharacteristicNominalBaseType::LocationCharacteristicNominalBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  GeometricCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

LocationCharacteristicNominalBaseType::~LocationCharacteristicNominalBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void LocationCharacteristicNominalBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool LocationCharacteristicNominalBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in LocationCharacteristicNominalBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in LocationCharacteristicNominalBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in LocationCharacteristicNominalBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in LocationCharacteristicNominalBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class LocationOnDrawingType

*/

LocationOnDrawingType::LocationOnDrawingType()
{
  LocationOnDrawingTypePair = 0;
}

LocationOnDrawingType::LocationOnDrawingType(
 LocationOnDrawingTypeChoicePair * LocationOnDrawingTypePairIn)
{
  LocationOnDrawingTypePair = LocationOnDrawingTypePairIn;
}

LocationOnDrawingType::~LocationOnDrawingType()
{
  #ifndef NODESTRUCT
  delete LocationOnDrawingTypePair;
  #endif
}

void LocationOnDrawingType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  LocationOnDrawingTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

LocationOnDrawingTypeChoicePair * LocationOnDrawingType::getLocationOnDrawingTypePair()
{return LocationOnDrawingTypePair;}

void LocationOnDrawingType::setLocationOnDrawingTypePair(LocationOnDrawingTypeChoicePair * LocationOnDrawingTypePairIn)
{LocationOnDrawingTypePair = LocationOnDrawingTypePairIn;}
LocationOnDrawingTypeChoicePair::LocationOnDrawingTypeChoicePair() {}

LocationOnDrawingTypeChoicePair::LocationOnDrawingTypeChoicePair(
 whichOne LocationOnDrawingTypeTypeIn,
 LocationOnDrawingTypeVal LocationOnDrawingTypeValueIn)
{
  LocationOnDrawingTypeType = LocationOnDrawingTypeTypeIn;
  LocationOnDrawingTypeValue = LocationOnDrawingTypeValueIn;
}

LocationOnDrawingTypeChoicePair::~LocationOnDrawingTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (LocationOnDrawingTypeType == LocationOnDrawi_1051E)
    delete LocationOnDrawingTypeValue.LocationOnDrawi_1051;
  else if (LocationOnDrawingTypeType == LocationOnDrawi_1052E)
    delete LocationOnDrawingTypeValue.LocationOnDrawi_1052;
  else if (LocationOnDrawingTypeType == LocationOnDrawi_1053E)
    delete LocationOnDrawingTypeValue.LocationOnDrawi_1053;
  #endif
}

void LocationOnDrawingTypeChoicePair::printSelf(FILE * outFile)
{
  if (LocationOnDrawingTypeType == LocationOnDrawi_1051E)
    {
      LocationOnDrawingTypeValue.LocationOnDrawi_1051->printSelf(outFile);
    }
  else if (LocationOnDrawingTypeType == LocationOnDrawi_1052E)
    {
      LocationOnDrawingTypeValue.LocationOnDrawi_1052->printSelf(outFile);
    }
  else if (LocationOnDrawingTypeType == LocationOnDrawi_1053E)
    {
      LocationOnDrawingTypeValue.LocationOnDrawi_1053->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class LocationSignificanceAllEnumType

*/

LocationSignificanceAllEnumType::LocationSignificanceAllEnumType() :
  XmlString()
{
}

LocationSignificanceAllEnumType::LocationSignificanceAllEnumType(
 const char * valIn) :
  XmlString(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "ARROW_SIDE") &&
           strcmp(val.c_str(), "OTHER_SIDE") &&
           strcmp(val.c_str(), "BOTH_SIDE"));
}

LocationSignificanceAllEnumType::~LocationSignificanceAllEnumType() {}

bool LocationSignificanceAllEnumType::LocationSignificanceAllEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "ARROW_SIDE") &&
          strcmp(val.c_str(), "OTHER_SIDE") &&
          strcmp(val.c_str(), "BOTH_SIDE"));
}

void LocationSignificanceAllEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "LocationSignificanceAllEnumType");
}

void LocationSignificanceAllEnumType::printSelf(FILE * outFile)
{
  if (LocationSignificanceAllEnumTypeIsBad())
    {
      fprintf(stderr, "bad LocationSignificanceAllEnumType value, ");
      XmlString::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlString::printSelf(outFile);
}

void LocationSignificanceAllEnumType::oPrintSelf(FILE * outFile)
{
  if (LocationSignificanceAllEnumTypeIsBad())
    {
      fprintf(stderr, "bad LocationSignificanceAllEnumType value, ");
      XmlString::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlString::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class LocationSignificanceOneSidesEnumType

*/

LocationSignificanceOneSidesEnumType::LocationSignificanceOneSidesEnumType() :
  XmlString()
{
}

LocationSignificanceOneSidesEnumType::LocationSignificanceOneSidesEnumType(
 const char * valIn) :
  XmlString(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "ARROW_SIDE") &&
           strcmp(val.c_str(), "OTHER_SIDE"));
}

LocationSignificanceOneSidesEnumType::~LocationSignificanceOneSidesEnumType() {}

bool LocationSignificanceOneSidesEnumType::LocationSignificanceOneSidesEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "ARROW_SIDE") &&
          strcmp(val.c_str(), "OTHER_SIDE"));
}

void LocationSignificanceOneSidesEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "LocationSignificanceOneSidesEnumType");
}

void LocationSignificanceOneSidesEnumType::printSelf(FILE * outFile)
{
  if (LocationSignificanceOneSidesEnumTypeIsBad())
    {
      fprintf(stderr, "bad LocationSignificanceOneSidesEnumType value, ");
      XmlString::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlString::printSelf(outFile);
}

void LocationSignificanceOneSidesEnumType::oPrintSelf(FILE * outFile)
{
  if (LocationSignificanceOneSidesEnumTypeIsBad())
    {
      fprintf(stderr, "bad LocationSignificanceOneSidesEnumType value, ");
      XmlString::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlString::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class LocationSignificanceSpotSeamEnumType

*/

LocationSignificanceSpotSeamEnumType::LocationSignificanceSpotSeamEnumType() :
  XmlString()
{
}

LocationSignificanceSpotSeamEnumType::LocationSignificanceSpotSeamEnumType(
 const char * valIn) :
  XmlString(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "ARROW_SIDE") &&
           strcmp(val.c_str(), "OTHER_SIDE") &&
           strcmp(val.c_str(), "NO_SIDE"));
}

LocationSignificanceSpotSeamEnumType::~LocationSignificanceSpotSeamEnumType() {}

bool LocationSignificanceSpotSeamEnumType::LocationSignificanceSpotSeamEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "ARROW_SIDE") &&
          strcmp(val.c_str(), "OTHER_SIDE") &&
          strcmp(val.c_str(), "NO_SIDE"));
}

void LocationSignificanceSpotSeamEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "LocationSignificanceSpotSeamEnumType");
}

void LocationSignificanceSpotSeamEnumType::printSelf(FILE * outFile)
{
  if (LocationSignificanceSpotSeamEnumTypeIsBad())
    {
      fprintf(stderr, "bad LocationSignificanceSpotSeamEnumType value, ");
      XmlString::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlString::printSelf(outFile);
}

void LocationSignificanceSpotSeamEnumType::oPrintSelf(FILE * outFile)
{
  if (LocationSignificanceSpotSeamEnumTypeIsBad())
    {
      fprintf(stderr, "bad LocationSignificanceSpotSeamEnumType value, ");
      XmlString::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlString::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class MassCharacteristicDefinitionBaseType

*/

MassCharacteristicDefinitionBaseType::MassCharacteristicDefinitionBaseType() :
  CharacteristicDefinitionBaseType()
{
  MassCharacteristicDefinitionBaseTypePair = 0;
}

MassCharacteristicDefinitionBaseType::MassCharacteristicDefinitionBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 MassCharacteristicDefinitionBaseTypeChoicePair * MassCharacteristicDefinitionBaseTypePairIn) :
  CharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
  MassCharacteristicDefinitionBaseTypePair = MassCharacteristicDefinitionBaseTypePairIn;
}

MassCharacteristicDefinitionBaseType::MassCharacteristicDefinitionBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 MassCharacteristicDefinitionBaseTypeChoicePair * MassCharacteristicDefinitionBaseTypePairIn) :
  CharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
  MassCharacteristicDefinitionBaseTypePair = MassCharacteristicDefinitionBaseTypePairIn;
}

MassCharacteristicDefinitionBaseType::~MassCharacteristicDefinitionBaseType()
{
  #ifndef NODESTRUCT
  delete MassCharacteristicDefinitionBaseTypePair;
  #endif
}

void MassCharacteristicDefinitionBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  MassCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}
MassCharacteristicDefinitionBaseTypeChoicePair * MassCharacteristicDefinitionBaseType::getMassCharacteristicDefinitionBaseTypeChoicePair()
{return MassCharacteristicDefinitionBaseTypePair;}

void MassCharacteristicDefinitionBaseType::setMassCharacteristicDefinitionBaseTypeChoicePair(MassCharacteristicDefinitionBaseTypeChoicePair * MassCharacteristicDefinitionBaseTypePairIn)
{MassCharacteristicDefinitionBaseTypePair = MassCharacteristicDefinitionBaseTypePairIn;}

/* ***************************************************************** */

MassCharacteristicDefinitionBaseTypeChoicePair::MassCharacteristicDefinitionBaseTypeChoicePair() {}

MassCharacteristicDefinitionBaseTypeChoicePair::MassCharacteristicDefinitionBaseTypeChoicePair(
 whichOne MassCharacteristicDefinitionBaseTypeTypeIn,
 MassCharacteristicDefinitionBaseTypeVal MassCharacteristicDefinitionBaseTypeValueIn)
{
  MassCharacteristicDefinitionBaseTypeType = MassCharacteristicDefinitionBaseTypeTypeIn;
  MassCharacteristicDefinitionBaseTypeValue = MassCharacteristicDefinitionBaseTypeValueIn;
}

MassCharacteristicDefinitionBaseTypeChoicePair::~MassCharacteristicDefinitionBaseTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (MassCharacteristicDefinitionBaseTypeType == ToleranceE)
    delete MassCharacteristicDefinitionBaseTypeValue.Tolerance;
  else if (MassCharacteristicDefinitionBaseTypeType == NonToleranceE)
    delete MassCharacteristicDefinitionBaseTypeValue.NonTolerance;
  #endif
}

void MassCharacteristicDefinitionBaseTypeChoicePair::printSelf(FILE * outFile)
{
  if (MassCharacteristicDefinitionBaseTypeType == ToleranceE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Tolerance");
      MassCharacteristicDefinitionBaseTypeValue.Tolerance->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Tolerance>\n");
    }
  else if (MassCharacteristicDefinitionBaseTypeType == NonToleranceE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonTolerance");
      MassCharacteristicDefinitionBaseTypeValue.NonTolerance->printSelf(outFile);
      fprintf(outFile, "</NonTolerance>\n");
    }
}

bool MassCharacteristicDefinitionBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in MassCharacteristicDefinitionBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in MassCharacteristicDefinitionBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in MassCharacteristicDefinitionBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in MassCharacteristicDefinitionBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class MassCharacteristicItemBaseType

*/

MassCharacteristicItemBaseType::MassCharacteristicItemBaseType() :
  CharacteristicItemBaseType()
{
}

MassCharacteristicItemBaseType::MassCharacteristicItemBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  CharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

MassCharacteristicItemBaseType::MassCharacteristicItemBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  CharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

MassCharacteristicItemBaseType::~MassCharacteristicItemBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void MassCharacteristicItemBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool MassCharacteristicItemBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in MassCharacteristicItemBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in MassCharacteristicItemBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in MassCharacteristicItemBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in MassCharacteristicItemBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class MassCharacteristicMeasurementBaseType

*/

MassCharacteristicMeasurementBaseType::MassCharacteristicMeasurementBaseType() :
  CharacteristicMeasurementBaseType()
{
  Value = 0;
  MaxValue = 0;
  MinValue = 0;
}

MassCharacteristicMeasurementBaseType::MassCharacteristicMeasurementBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredMassValueType * ValueIn,
 MeasuredMassValueType * MaxValueIn,
 MeasuredMassValueType * MinValueIn) :
  CharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  Value = ValueIn;
  MaxValue = MaxValueIn;
  MinValue = MinValueIn;
}

MassCharacteristicMeasurementBaseType::MassCharacteristicMeasurementBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredMassValueType * ValueIn,
 MeasuredMassValueType * MaxValueIn,
 MeasuredMassValueType * MinValueIn) :
  CharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  Value = ValueIn;
  MaxValue = MaxValueIn;
  MinValue = MinValueIn;
}

MassCharacteristicMeasurementBaseType::~MassCharacteristicMeasurementBaseType()
{
  #ifndef NODESTRUCT
  delete Value;
  delete MaxValue;
  delete MinValue;
  #endif
}

void MassCharacteristicMeasurementBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool MassCharacteristicMeasurementBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in MassCharacteristicMeasurementBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in MassCharacteristicMeasurementBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in MassCharacteristicMeasurementBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in MassCharacteristicMeasurementBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredMassValueType * MassCharacteristicMeasurementBaseType::getValue()
{return Value;}

void MassCharacteristicMeasurementBaseType::setValue(MeasuredMassValueType * ValueIn)
{Value = ValueIn;}

MeasuredMassValueType * MassCharacteristicMeasurementBaseType::getMaxValue()
{return MaxValue;}

void MassCharacteristicMeasurementBaseType::setMaxValue(MeasuredMassValueType * MaxValueIn)
{MaxValue = MaxValueIn;}

MeasuredMassValueType * MassCharacteristicMeasurementBaseType::getMinValue()
{return MinValue;}

void MassCharacteristicMeasurementBaseType::setMinValue(MeasuredMassValueType * MinValueIn)
{MinValue = MinValueIn;}

/* ***************************************************************** */

/* class MassCharacteristicNominalBaseType

*/

MassCharacteristicNominalBaseType::MassCharacteristicNominalBaseType() :
  CharacteristicNominalBaseType()
{
  TargetValue = 0;
}

MassCharacteristicNominalBaseType::MassCharacteristicNominalBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 MassValueType * TargetValueIn) :
  CharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  TargetValue = TargetValueIn;
}

MassCharacteristicNominalBaseType::MassCharacteristicNominalBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 MassValueType * TargetValueIn) :
  CharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  TargetValue = TargetValueIn;
}

MassCharacteristicNominalBaseType::~MassCharacteristicNominalBaseType()
{
  #ifndef NODESTRUCT
  delete TargetValue;
  #endif
}

void MassCharacteristicNominalBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool MassCharacteristicNominalBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in MassCharacteristicNominalBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in MassCharacteristicNominalBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in MassCharacteristicNominalBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in MassCharacteristicNominalBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MassValueType * MassCharacteristicNominalBaseType::getTargetValue()
{return TargetValue;}

void MassCharacteristicNominalBaseType::setTargetValue(MassValueType * TargetValueIn)
{TargetValue = TargetValueIn;}

/* ***************************************************************** */

/* class MeasuredCharacteristicsType

*/

MeasuredCharacteristicsType::MeasuredCharacteristicsType()
{
  CharacteristicMeasurements = 0;
  CharacteristicGroupStatuses = 0;
}

MeasuredCharacteristicsType::MeasuredCharacteristicsType(
 CharacteristicMeasurementsType * CharacteristicMeasurementsIn,
 CharacteristicGroupStatusesType * CharacteristicGroupStatusesIn)
{
  CharacteristicMeasurements = CharacteristicMeasurementsIn;
  CharacteristicGroupStatuses = CharacteristicGroupStatusesIn;
}

MeasuredCharacteristicsType::~MeasuredCharacteristicsType()
{
  #ifndef NODESTRUCT
  delete CharacteristicMeasurements;
  delete CharacteristicGroupStatuses;
  #endif
}

void MeasuredCharacteristicsType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicMeasurements");
  CharacteristicMeasurements->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</CharacteristicMeasurements>\n");
  if (CharacteristicGroupStatuses)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicGroupStatuses");
      CharacteristicGroupStatuses->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicGroupStatuses>\n");
    }
  doSpaces(-INDENT, outFile);
}

CharacteristicMeasurementsType * MeasuredCharacteristicsType::getCharacteristicMeasurements()
{return CharacteristicMeasurements;}

void MeasuredCharacteristicsType::setCharacteristicMeasurements(CharacteristicMeasurementsType * CharacteristicMeasurementsIn)
{CharacteristicMeasurements = CharacteristicMeasurementsIn;}

CharacteristicGroupStatusesType * MeasuredCharacteristicsType::getCharacteristicGroupStatuses()
{return CharacteristicGroupStatuses;}

void MeasuredCharacteristicsType::setCharacteristicGroupStatuses(CharacteristicGroupStatusesType * CharacteristicGroupStatusesIn)
{CharacteristicGroupStatuses = CharacteristicGroupStatusesIn;}

/* ***************************************************************** */

/* class MeasuredZoneRadiiType

*/

MeasuredZoneRadiiType::MeasuredZoneRadiiType()
{
  MinRadius = 0;
  MaxRadius = 0;
}

MeasuredZoneRadiiType::MeasuredZoneRadiiType(
 MeasuredLinearValueType * MinRadiusIn,
 MeasuredLinearValueType * MaxRadiusIn)
{
  MinRadius = MinRadiusIn;
  MaxRadius = MaxRadiusIn;
}

MeasuredZoneRadiiType::~MeasuredZoneRadiiType()
{
  #ifndef NODESTRUCT
  delete MinRadius;
  delete MaxRadius;
  #endif
}

void MeasuredZoneRadiiType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<MinRadius");
  MinRadius->printSelf(outFile);
  fprintf(outFile, "</MinRadius>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxRadius");
  MaxRadius->printSelf(outFile);
  fprintf(outFile, "</MaxRadius>\n");
  doSpaces(-INDENT, outFile);
}

MeasuredLinearValueType * MeasuredZoneRadiiType::getMinRadius()
{return MinRadius;}

void MeasuredZoneRadiiType::setMinRadius(MeasuredLinearValueType * MinRadiusIn)
{MinRadius = MinRadiusIn;}

MeasuredLinearValueType * MeasuredZoneRadiiType::getMaxRadius()
{return MaxRadius;}

void MeasuredZoneRadiiType::setMaxRadius(MeasuredLinearValueType * MaxRadiusIn)
{MaxRadius = MaxRadiusIn;}

/* ***************************************************************** */

/* class NonDestructiveTestingEnumType

*/

NonDestructiveTestingEnumType::NonDestructiveTestingEnumType() :
  XmlString()
{
}

NonDestructiveTestingEnumType::NonDestructiveTestingEnumType(
 const char * valIn) :
  XmlString(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "ACOUSTIC_EMISSION") &&
           strcmp(val.c_str(), "ELECTROMAGNETIC") &&
           strcmp(val.c_str(), "LEAK") &&
           strcmp(val.c_str(), "MAGNETIC_PARTICLE") &&
           strcmp(val.c_str(), "NEUTRON_RADIOGRAPHIC") &&
           strcmp(val.c_str(), "PENETRANT") &&
           strcmp(val.c_str(), "PROOF") &&
           strcmp(val.c_str(), "RADIOGRAPHIC") &&
           strcmp(val.c_str(), "ULTRASONIC") &&
           strcmp(val.c_str(), "VISUAL"));
}

NonDestructiveTestingEnumType::~NonDestructiveTestingEnumType() {}

bool NonDestructiveTestingEnumType::NonDestructiveTestingEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "ACOUSTIC_EMISSION") &&
          strcmp(val.c_str(), "ELECTROMAGNETIC") &&
          strcmp(val.c_str(), "LEAK") &&
          strcmp(val.c_str(), "MAGNETIC_PARTICLE") &&
          strcmp(val.c_str(), "NEUTRON_RADIOGRAPHIC") &&
          strcmp(val.c_str(), "PENETRANT") &&
          strcmp(val.c_str(), "PROOF") &&
          strcmp(val.c_str(), "RADIOGRAPHIC") &&
          strcmp(val.c_str(), "ULTRASONIC") &&
          strcmp(val.c_str(), "VISUAL"));
}

void NonDestructiveTestingEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "NonDestructiveTestingEnumType");
}

void NonDestructiveTestingEnumType::printSelf(FILE * outFile)
{
  if (NonDestructiveTestingEnumTypeIsBad())
    {
      fprintf(stderr, "bad NonDestructiveTestingEnumType value, ");
      XmlString::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlString::printSelf(outFile);
}

void NonDestructiveTestingEnumType::oPrintSelf(FILE * outFile)
{
  if (NonDestructiveTestingEnumTypeIsBad())
    {
      fprintf(stderr, "bad NonDestructiveTestingEnumType value, ");
      XmlString::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlString::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class NonDestructiveTestingEnumTypeLisd

*/

NonDestructiveTestingEnumTypeLisd::NonDestructiveTestingEnumTypeLisd() {}

NonDestructiveTestingEnumTypeLisd::NonDestructiveTestingEnumTypeLisd(
  NonDestructiveTestingEnumType * aNonDestructiveTestingEnumType)
{
  push_back(aNonDestructiveTestingEnumType);
}

NonDestructiveTestingEnumTypeLisd::NonDestructiveTestingEnumTypeLisd(
  NonDestructiveTestingEnumTypeLisd * aNonDestructiveTestingEnumTypeLisd)
{
  *this = *aNonDestructiveTestingEnumTypeLisd;
}

NonDestructiveTestingEnumTypeLisd::~NonDestructiveTestingEnumTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<NonDestructiveTestingEnumType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void NonDestructiveTestingEnumTypeLisd::printSelf(FILE * outFile)
{
  std::list<NonDestructiveTestingEnumType *>::iterator iter;

  fprintf(outFile, ">");
  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
      if ((*iter) != back())
        fprintf(outFile, " ");
    }
}

/* ***************************************************************** */

/* class OrientationCharacteristicDefinitionBaseType

*/

OrientationCharacteristicDefinitionBaseType::OrientationCharacteristicDefinitionBaseType() :
  GeometricCharacteristicDefinitionBaseType()
{
  ToleranceValue = 0;
  ToleranceDualValue = 0;
  DatumReferenceFrameId = 0;
  MaterialCondition = 0;
  SizeCharacteristicDefinitionId = 0;
  ZoneShape = 0;
  TangentPlane = 0;
  MaximumToleranceValue = 0;
  ProjectedToleranceZoneValue = 0;
  OrientationChar_1054 = 0;
}

OrientationCharacteristicDefinitionBaseType::OrientationCharacteristicDefinitionBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 QIFReferenceFullType * DatumReferenceFrameIdIn,
 MaterialModifierEnumType * MaterialConditionIn,
 QIFReferenceType * SizeCharacteristicDefinitionIdIn,
 OrientationZoneShapeType * ZoneShapeIn,
 XmlBoolean * TangentPlaneIn,
 LinearValueType * MaximumToleranceValueIn,
 LinearValueType * ProjectedToleranceZoneValueIn,
 OrientationChar_1054_Type * OrientationChar_1054In) :
  GeometricCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn)
{
  ToleranceValue = ToleranceValueIn;
  ToleranceDualValue = ToleranceDualValueIn;
  DatumReferenceFrameId = DatumReferenceFrameIdIn;
  MaterialCondition = MaterialConditionIn;
  SizeCharacteristicDefinitionId = SizeCharacteristicDefinitionIdIn;
  ZoneShape = ZoneShapeIn;
  TangentPlane = TangentPlaneIn;
  MaximumToleranceValue = MaximumToleranceValueIn;
  ProjectedToleranceZoneValue = ProjectedToleranceZoneValueIn;
  OrientationChar_1054 = OrientationChar_1054In;
}

OrientationCharacteristicDefinitionBaseType::OrientationCharacteristicDefinitionBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 QIFReferenceFullType * DatumReferenceFrameIdIn,
 MaterialModifierEnumType * MaterialConditionIn,
 QIFReferenceType * SizeCharacteristicDefinitionIdIn,
 OrientationZoneShapeType * ZoneShapeIn,
 XmlBoolean * TangentPlaneIn,
 LinearValueType * MaximumToleranceValueIn,
 LinearValueType * ProjectedToleranceZoneValueIn,
 OrientationChar_1054_Type * OrientationChar_1054In) :
  GeometricCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn)
{
  ToleranceValue = ToleranceValueIn;
  ToleranceDualValue = ToleranceDualValueIn;
  DatumReferenceFrameId = DatumReferenceFrameIdIn;
  MaterialCondition = MaterialConditionIn;
  SizeCharacteristicDefinitionId = SizeCharacteristicDefinitionIdIn;
  ZoneShape = ZoneShapeIn;
  TangentPlane = TangentPlaneIn;
  MaximumToleranceValue = MaximumToleranceValueIn;
  ProjectedToleranceZoneValue = ProjectedToleranceZoneValueIn;
  OrientationChar_1054 = OrientationChar_1054In;
}

OrientationCharacteristicDefinitionBaseType::~OrientationCharacteristicDefinitionBaseType()
{
  #ifndef NODESTRUCT
  delete ToleranceValue;
  delete ToleranceDualValue;
  delete DatumReferenceFrameId;
  delete MaterialCondition;
  delete SizeCharacteristicDefinitionId;
  delete ZoneShape;
  delete TangentPlane;
  delete MaximumToleranceValue;
  delete ProjectedToleranceZoneValue;
  delete OrientationChar_1054;
  #endif
}

void OrientationCharacteristicDefinitionBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (GeometricCharac_1050)
    {
  GeometricCharac_1050->printSelf(outFile);
    }
  if (DirectionFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DirectionFeature");
      DirectionFeature->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DirectionFeature>\n");
    }
  if (CollectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CollectionPlane");
      CollectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CollectionPlane>\n");
    }
  if (IntersectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IntersectionPlane");
      IntersectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</IntersectionPlane>\n");
    }
  if (OrientationPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OrientationPlane");
      OrientationPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OrientationPlane>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ToleranceValue");
  ToleranceValue->printSelf(outFile);
  fprintf(outFile, "</ToleranceValue>\n");
  if (ToleranceDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceDualValue");
      ToleranceDualValue->printSelf(outFile);
      fprintf(outFile, "</ToleranceDualValue>\n");
    }
  if (DatumReferenceFrameId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumReferenceFrameId");
      DatumReferenceFrameId->printSelf(outFile);
      fprintf(outFile, "</DatumReferenceFrameId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<MaterialCondition");
  MaterialCondition->printSelf(outFile);
  fprintf(outFile, "</MaterialCondition>\n");
  if (SizeCharacteristicDefinitionId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SizeCharacteristicDefinitionId");
      SizeCharacteristicDefinitionId->printSelf(outFile);
      fprintf(outFile, "</SizeCharacteristicDefinitionId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ZoneShape");
  ZoneShape->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ZoneShape>\n");
  if (TangentPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TangentPlane");
      TangentPlane->printSelf(outFile);
      fprintf(outFile, "</TangentPlane>\n");
    }
  if (MaximumToleranceValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaximumToleranceValue");
      MaximumToleranceValue->printSelf(outFile);
      fprintf(outFile, "</MaximumToleranceValue>\n");
    }
  if (ProjectedToleranceZoneValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProjectedToleranceZoneValue");
      ProjectedToleranceZoneValue->printSelf(outFile);
      fprintf(outFile, "</ProjectedToleranceZoneValue>\n");
    }
  if (OrientationChar_1054)
    {
  OrientationChar_1054->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool OrientationCharacteristicDefinitionBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OrientationCharacteristicDefinitionBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OrientationCharacteristicDefinitionBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OrientationCharacteristicDefinitionBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OrientationCharacteristicDefinitionBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LinearValueType * OrientationCharacteristicDefinitionBaseType::getToleranceValue()
{return ToleranceValue;}

void OrientationCharacteristicDefinitionBaseType::setToleranceValue(LinearValueType * ToleranceValueIn)
{ToleranceValue = ToleranceValueIn;}

LinearDualValueType * OrientationCharacteristicDefinitionBaseType::getToleranceDualValue()
{return ToleranceDualValue;}

void OrientationCharacteristicDefinitionBaseType::setToleranceDualValue(LinearDualValueType * ToleranceDualValueIn)
{ToleranceDualValue = ToleranceDualValueIn;}

QIFReferenceFullType * OrientationCharacteristicDefinitionBaseType::getDatumReferenceFrameId()
{return DatumReferenceFrameId;}

void OrientationCharacteristicDefinitionBaseType::setDatumReferenceFrameId(QIFReferenceFullType * DatumReferenceFrameIdIn)
{DatumReferenceFrameId = DatumReferenceFrameIdIn;}

MaterialModifierEnumType * OrientationCharacteristicDefinitionBaseType::getMaterialCondition()
{return MaterialCondition;}

void OrientationCharacteristicDefinitionBaseType::setMaterialCondition(MaterialModifierEnumType * MaterialConditionIn)
{MaterialCondition = MaterialConditionIn;}

QIFReferenceType * OrientationCharacteristicDefinitionBaseType::getSizeCharacteristicDefinitionId()
{return SizeCharacteristicDefinitionId;}

void OrientationCharacteristicDefinitionBaseType::setSizeCharacteristicDefinitionId(QIFReferenceType * SizeCharacteristicDefinitionIdIn)
{SizeCharacteristicDefinitionId = SizeCharacteristicDefinitionIdIn;}

OrientationZoneShapeType * OrientationCharacteristicDefinitionBaseType::getZoneShape()
{return ZoneShape;}

void OrientationCharacteristicDefinitionBaseType::setZoneShape(OrientationZoneShapeType * ZoneShapeIn)
{ZoneShape = ZoneShapeIn;}

XmlBoolean * OrientationCharacteristicDefinitionBaseType::getTangentPlane()
{return TangentPlane;}

void OrientationCharacteristicDefinitionBaseType::setTangentPlane(XmlBoolean * TangentPlaneIn)
{TangentPlane = TangentPlaneIn;}

LinearValueType * OrientationCharacteristicDefinitionBaseType::getMaximumToleranceValue()
{return MaximumToleranceValue;}

void OrientationCharacteristicDefinitionBaseType::setMaximumToleranceValue(LinearValueType * MaximumToleranceValueIn)
{MaximumToleranceValue = MaximumToleranceValueIn;}

LinearValueType * OrientationCharacteristicDefinitionBaseType::getProjectedToleranceZoneValue()
{return ProjectedToleranceZoneValue;}

void OrientationCharacteristicDefinitionBaseType::setProjectedToleranceZoneValue(LinearValueType * ProjectedToleranceZoneValueIn)
{ProjectedToleranceZoneValue = ProjectedToleranceZoneValueIn;}

OrientationChar_1054_Type * OrientationCharacteristicDefinitionBaseType::getOrientationChar_1054()
{return OrientationChar_1054;}

void OrientationCharacteristicDefinitionBaseType::setOrientationChar_1054(OrientationChar_1054_Type * OrientationChar_1054In)
{OrientationChar_1054 = OrientationChar_1054In;}

/* ***************************************************************** */

/* class OrientationCharacteristicItemBaseType

*/

OrientationCharacteristicItemBaseType::OrientationCharacteristicItemBaseType() :
  GeometricCharacteristicItemBaseType()
{
}

OrientationCharacteristicItemBaseType::OrientationCharacteristicItemBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  GeometricCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

OrientationCharacteristicItemBaseType::OrientationCharacteristicItemBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  GeometricCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

OrientationCharacteristicItemBaseType::~OrientationCharacteristicItemBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void OrientationCharacteristicItemBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool OrientationCharacteristicItemBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OrientationCharacteristicItemBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OrientationCharacteristicItemBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OrientationCharacteristicItemBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OrientationCharacteristicItemBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class OrientationCharacteristicMeasurementBaseType

*/

OrientationCharacteristicMeasurementBaseType::OrientationCharacteristicMeasurementBaseType() :
  GeometricCharacteristicMeasurementBaseType()
{
  DatumsOk = 0;
  Bonus = 0;
  ReferenceLength = 0;
  DRFTransformActualId = 0;
}

OrientationCharacteristicMeasurementBaseType::OrientationCharacteristicMeasurementBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 XmlBoolean * DatumsOkIn,
 MeasuredLinearValueType * BonusIn,
 LinearValueType * ReferenceLengthIn,
 QIFReferenceType * DRFTransformActualIdIn) :
  GeometricCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
  DatumsOk = DatumsOkIn;
  Bonus = BonusIn;
  ReferenceLength = ReferenceLengthIn;
  DRFTransformActualId = DRFTransformActualIdIn;
}

OrientationCharacteristicMeasurementBaseType::OrientationCharacteristicMeasurementBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 XmlBoolean * DatumsOkIn,
 MeasuredLinearValueType * BonusIn,
 LinearValueType * ReferenceLengthIn,
 QIFReferenceType * DRFTransformActualIdIn) :
  GeometricCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
  DatumsOk = DatumsOkIn;
  Bonus = BonusIn;
  ReferenceLength = ReferenceLengthIn;
  DRFTransformActualId = DRFTransformActualIdIn;
}

OrientationCharacteristicMeasurementBaseType::~OrientationCharacteristicMeasurementBaseType()
{
  #ifndef NODESTRUCT
  delete DatumsOk;
  delete Bonus;
  delete ReferenceLength;
  delete DRFTransformActualId;
  #endif
}

void OrientationCharacteristicMeasurementBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  if (DatumsOk)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumsOk");
      DatumsOk->printSelf(outFile);
      fprintf(outFile, "</DatumsOk>\n");
    }
  if (Bonus)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Bonus");
      Bonus->printSelf(outFile);
      fprintf(outFile, "</Bonus>\n");
    }
  if (ReferenceLength)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ReferenceLength");
      ReferenceLength->printSelf(outFile);
      fprintf(outFile, "</ReferenceLength>\n");
    }
  if (DRFTransformActualId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DRFTransformActualId");
      DRFTransformActualId->printSelf(outFile);
      fprintf(outFile, "</DRFTransformActualId>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool OrientationCharacteristicMeasurementBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OrientationCharacteristicMeasurementBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OrientationCharacteristicMeasurementBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OrientationCharacteristicMeasurementBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OrientationCharacteristicMeasurementBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

XmlBoolean * OrientationCharacteristicMeasurementBaseType::getDatumsOk()
{return DatumsOk;}

void OrientationCharacteristicMeasurementBaseType::setDatumsOk(XmlBoolean * DatumsOkIn)
{DatumsOk = DatumsOkIn;}

MeasuredLinearValueType * OrientationCharacteristicMeasurementBaseType::getBonus()
{return Bonus;}

void OrientationCharacteristicMeasurementBaseType::setBonus(MeasuredLinearValueType * BonusIn)
{Bonus = BonusIn;}

LinearValueType * OrientationCharacteristicMeasurementBaseType::getReferenceLength()
{return ReferenceLength;}

void OrientationCharacteristicMeasurementBaseType::setReferenceLength(LinearValueType * ReferenceLengthIn)
{ReferenceLength = ReferenceLengthIn;}

QIFReferenceType * OrientationCharacteristicMeasurementBaseType::getDRFTransformActualId()
{return DRFTransformActualId;}

void OrientationCharacteristicMeasurementBaseType::setDRFTransformActualId(QIFReferenceType * DRFTransformActualIdIn)
{DRFTransformActualId = DRFTransformActualIdIn;}

/* ***************************************************************** */

/* class OrientationCharacteristicNominalBaseType

*/

OrientationCharacteristicNominalBaseType::OrientationCharacteristicNominalBaseType() :
  GeometricCharacteristicNominalBaseType()
{
}

OrientationCharacteristicNominalBaseType::OrientationCharacteristicNominalBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  GeometricCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

OrientationCharacteristicNominalBaseType::OrientationCharacteristicNominalBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  GeometricCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

OrientationCharacteristicNominalBaseType::~OrientationCharacteristicNominalBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void OrientationCharacteristicNominalBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool OrientationCharacteristicNominalBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OrientationCharacteristicNominalBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OrientationCharacteristicNominalBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OrientationCharacteristicNominalBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OrientationCharacteristicNominalBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class OrientationDiametricalZoneType

*/

OrientationDiametricalZoneType::OrientationDiametricalZoneType()
{
  ZoneOrientationVector = 0;
}

OrientationDiametricalZoneType::OrientationDiametricalZoneType(
 UnitVectorType * ZoneOrientationVectorIn)
{
  ZoneOrientationVector = ZoneOrientationVectorIn;
}

OrientationDiametricalZoneType::~OrientationDiametricalZoneType()
{
  #ifndef NODESTRUCT
  delete ZoneOrientationVector;
  #endif
}

void OrientationDiametricalZoneType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (ZoneOrientationVector)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ZoneOrientationVector");
      ZoneOrientationVector->printSelf(outFile);
      fprintf(outFile, "</ZoneOrientationVector>\n");
    }
  doSpaces(-INDENT, outFile);
}

UnitVectorType * OrientationDiametricalZoneType::getZoneOrientationVector()
{return ZoneOrientationVector;}

void OrientationDiametricalZoneType::setZoneOrientationVector(UnitVectorType * ZoneOrientationVectorIn)
{ZoneOrientationVector = ZoneOrientationVectorIn;}

/* ***************************************************************** */

/* class OrientationPlanarZoneType

*/

OrientationPlanarZoneType::OrientationPlanarZoneType()
{
  ZoneOrientationVector = 0;
}

OrientationPlanarZoneType::OrientationPlanarZoneType(
 UnitVectorType * ZoneOrientationVectorIn)
{
  ZoneOrientationVector = ZoneOrientationVectorIn;
}

OrientationPlanarZoneType::~OrientationPlanarZoneType()
{
  #ifndef NODESTRUCT
  delete ZoneOrientationVector;
  #endif
}

void OrientationPlanarZoneType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (ZoneOrientationVector)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ZoneOrientationVector");
      ZoneOrientationVector->printSelf(outFile);
      fprintf(outFile, "</ZoneOrientationVector>\n");
    }
  doSpaces(-INDENT, outFile);
}

UnitVectorType * OrientationPlanarZoneType::getZoneOrientationVector()
{return ZoneOrientationVector;}

void OrientationPlanarZoneType::setZoneOrientationVector(UnitVectorType * ZoneOrientationVectorIn)
{ZoneOrientationVector = ZoneOrientationVectorIn;}

/* ***************************************************************** */

/* class OrientationZoneShapeType

*/

OrientationZoneShapeType::OrientationZoneShapeType()
{
  OrientationZoneShapeTypePair = 0;
}

OrientationZoneShapeType::OrientationZoneShapeType(
 OrientationZoneShapeTypeChoicePair * OrientationZoneShapeTypePairIn)
{
  OrientationZoneShapeTypePair = OrientationZoneShapeTypePairIn;
}

OrientationZoneShapeType::~OrientationZoneShapeType()
{
  #ifndef NODESTRUCT
  delete OrientationZoneShapeTypePair;
  #endif
}

void OrientationZoneShapeType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  OrientationZoneShapeTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

OrientationZoneShapeTypeChoicePair * OrientationZoneShapeType::getOrientationZoneShapeTypePair()
{return OrientationZoneShapeTypePair;}

void OrientationZoneShapeType::setOrientationZoneShapeTypePair(OrientationZoneShapeTypeChoicePair * OrientationZoneShapeTypePairIn)
{OrientationZoneShapeTypePair = OrientationZoneShapeTypePairIn;}
OrientationZoneShapeTypeChoicePair::OrientationZoneShapeTypeChoicePair() {}

OrientationZoneShapeTypeChoicePair::OrientationZoneShapeTypeChoicePair(
 whichOne OrientationZoneShapeTypeTypeIn,
 OrientationZoneShapeTypeVal OrientationZoneShapeTypeValueIn)
{
  OrientationZoneShapeTypeType = OrientationZoneShapeTypeTypeIn;
  OrientationZoneShapeTypeValue = OrientationZoneShapeTypeValueIn;
}

OrientationZoneShapeTypeChoicePair::~OrientationZoneShapeTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (OrientationZoneShapeTypeType == DiametricalZoneE)
    delete OrientationZoneShapeTypeValue.DiametricalZone;
  else if (OrientationZoneShapeTypeType == PlanarZoneE)
    delete OrientationZoneShapeTypeValue.PlanarZone;
  #endif
}

void OrientationZoneShapeTypeChoicePair::printSelf(FILE * outFile)
{
  if (OrientationZoneShapeTypeType == DiametricalZoneE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DiametricalZone");
      OrientationZoneShapeTypeValue.DiametricalZone->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DiametricalZone>\n");
    }
  else if (OrientationZoneShapeTypeType == PlanarZoneE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PlanarZone");
      OrientationZoneShapeTypeValue.PlanarZone->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PlanarZone>\n");
    }
}

/* ***************************************************************** */

/* class OriginReferenceType

*/

OriginReferenceType::OriginReferenceType()
{
  OriginReferenceTypePair = 0;
}

OriginReferenceType::OriginReferenceType(
 OriginReferenceTypeChoicePair * OriginReferenceTypePairIn)
{
  OriginReferenceTypePair = OriginReferenceTypePairIn;
}

OriginReferenceType::~OriginReferenceType()
{
  #ifndef NODESTRUCT
  delete OriginReferenceTypePair;
  #endif
}

void OriginReferenceType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  OriginReferenceTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

OriginReferenceTypeChoicePair * OriginReferenceType::getOriginReferenceTypePair()
{return OriginReferenceTypePair;}

void OriginReferenceType::setOriginReferenceTypePair(OriginReferenceTypeChoicePair * OriginReferenceTypePairIn)
{OriginReferenceTypePair = OriginReferenceTypePairIn;}
OriginReferenceTypeChoicePair::OriginReferenceTypeChoicePair() {}

OriginReferenceTypeChoicePair::OriginReferenceTypeChoicePair(
 whichOne OriginReferenceTypeTypeIn,
 OriginReferenceTypeVal OriginReferenceTypeValueIn)
{
  OriginReferenceTypeType = OriginReferenceTypeTypeIn;
  OriginReferenceTypeValue = OriginReferenceTypeValueIn;
}

OriginReferenceTypeChoicePair::~OriginReferenceTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (OriginReferenceTypeType == OriginReference_1055E)
    delete OriginReferenceTypeValue.OriginReference_1055;
  else if (OriginReferenceTypeType == DatumDefinitionIdE)
    delete OriginReferenceTypeValue.DatumDefinitionId;
  #endif
}

void OriginReferenceTypeChoicePair::printSelf(FILE * outFile)
{
  if (OriginReferenceTypeType == OriginReference_1055E)
    {
      OriginReferenceTypeValue.OriginReference_1055->printSelf(outFile);
    }
  else if (OriginReferenceTypeType == DatumDefinitionIdE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumDefinitionId");
      OriginReferenceTypeValue.DatumDefinitionId->printSelf(outFile);
      fprintf(outFile, "</DatumDefinitionId>\n");
    }
}

/* ***************************************************************** */

/* class OtherFormCharacteristicDefinitionType

*/

OtherFormCharacteristicDefinitionType::OtherFormCharacteristicDefinitionType() :
  FormCharacteristicDefinitionBaseType()
{
  ToleranceValue = 0;
  ToleranceDualValue = 0;
}

OtherFormCharacteristicDefinitionType::OtherFormCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn) :
  FormCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn)
{
  ToleranceValue = ToleranceValueIn;
  ToleranceDualValue = ToleranceDualValueIn;
}

OtherFormCharacteristicDefinitionType::OtherFormCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn) :
  FormCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn)
{
  ToleranceValue = ToleranceValueIn;
  ToleranceDualValue = ToleranceDualValueIn;
}

OtherFormCharacteristicDefinitionType::~OtherFormCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  delete ToleranceValue;
  delete ToleranceDualValue;
  #endif
}

void OtherFormCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (GeometricCharac_1050)
    {
  GeometricCharac_1050->printSelf(outFile);
    }
  if (DirectionFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DirectionFeature");
      DirectionFeature->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DirectionFeature>\n");
    }
  if (CollectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CollectionPlane");
      CollectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CollectionPlane>\n");
    }
  if (IntersectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IntersectionPlane");
      IntersectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</IntersectionPlane>\n");
    }
  if (OrientationPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OrientationPlane");
      OrientationPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OrientationPlane>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ToleranceValue");
  ToleranceValue->printSelf(outFile);
  fprintf(outFile, "</ToleranceValue>\n");
  if (ToleranceDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceDualValue");
      ToleranceDualValue->printSelf(outFile);
      fprintf(outFile, "</ToleranceDualValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool OtherFormCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OtherFormCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OtherFormCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OtherFormCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OtherFormCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LinearValueType * OtherFormCharacteristicDefinitionType::getToleranceValue()
{return ToleranceValue;}

void OtherFormCharacteristicDefinitionType::setToleranceValue(LinearValueType * ToleranceValueIn)
{ToleranceValue = ToleranceValueIn;}

LinearDualValueType * OtherFormCharacteristicDefinitionType::getToleranceDualValue()
{return ToleranceDualValue;}

void OtherFormCharacteristicDefinitionType::setToleranceDualValue(LinearDualValueType * ToleranceDualValueIn)
{ToleranceDualValue = ToleranceDualValueIn;}

/* ***************************************************************** */

/* class OtherFormCharacteristicItemType

*/

OtherFormCharacteristicItemType::OtherFormCharacteristicItemType() :
  FormCharacteristicItemBaseType()
{
}

OtherFormCharacteristicItemType::OtherFormCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  FormCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

OtherFormCharacteristicItemType::OtherFormCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  FormCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

OtherFormCharacteristicItemType::~OtherFormCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void OtherFormCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool OtherFormCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OtherFormCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OtherFormCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OtherFormCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OtherFormCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class OtherFormCharacteristicMeasurementType

*/

OtherFormCharacteristicMeasurementType::OtherFormCharacteristicMeasurementType() :
  FormCharacteristicMeasurementBaseType()
{
}

OtherFormCharacteristicMeasurementType::OtherFormCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  FormCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

OtherFormCharacteristicMeasurementType::OtherFormCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  FormCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

OtherFormCharacteristicMeasurementType::~OtherFormCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void OtherFormCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool OtherFormCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OtherFormCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OtherFormCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OtherFormCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OtherFormCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class OtherFormCharacteristicNominalType

*/

OtherFormCharacteristicNominalType::OtherFormCharacteristicNominalType() :
  FormCharacteristicNominalBaseType()
{
}

OtherFormCharacteristicNominalType::OtherFormCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  FormCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

OtherFormCharacteristicNominalType::OtherFormCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  FormCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

OtherFormCharacteristicNominalType::~OtherFormCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void OtherFormCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool OtherFormCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OtherFormCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OtherFormCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OtherFormCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OtherFormCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class ParallelismCharacteristicDefinitionType

*/

ParallelismCharacteristicDefinitionType::ParallelismCharacteristicDefinitionType() :
  OrientationCharacteristicDefinitionBaseType()
{
}

ParallelismCharacteristicDefinitionType::ParallelismCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 QIFReferenceFullType * DatumReferenceFrameIdIn,
 MaterialModifierEnumType * MaterialConditionIn,
 QIFReferenceType * SizeCharacteristicDefinitionIdIn,
 OrientationZoneShapeType * ZoneShapeIn,
 XmlBoolean * TangentPlaneIn,
 LinearValueType * MaximumToleranceValueIn,
 LinearValueType * ProjectedToleranceZoneValueIn,
 OrientationChar_1054_Type * OrientationChar_1054In) :
  OrientationCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn,
    ToleranceValueIn,
    ToleranceDualValueIn,
    DatumReferenceFrameIdIn,
    MaterialConditionIn,
    SizeCharacteristicDefinitionIdIn,
    ZoneShapeIn,
    TangentPlaneIn,
    MaximumToleranceValueIn,
    ProjectedToleranceZoneValueIn,
    OrientationChar_1054In)
{
}

ParallelismCharacteristicDefinitionType::ParallelismCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 QIFReferenceFullType * DatumReferenceFrameIdIn,
 MaterialModifierEnumType * MaterialConditionIn,
 QIFReferenceType * SizeCharacteristicDefinitionIdIn,
 OrientationZoneShapeType * ZoneShapeIn,
 XmlBoolean * TangentPlaneIn,
 LinearValueType * MaximumToleranceValueIn,
 LinearValueType * ProjectedToleranceZoneValueIn,
 OrientationChar_1054_Type * OrientationChar_1054In) :
  OrientationCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn,
    ToleranceValueIn,
    ToleranceDualValueIn,
    DatumReferenceFrameIdIn,
    MaterialConditionIn,
    SizeCharacteristicDefinitionIdIn,
    ZoneShapeIn,
    TangentPlaneIn,
    MaximumToleranceValueIn,
    ProjectedToleranceZoneValueIn,
    OrientationChar_1054In)
{
}

ParallelismCharacteristicDefinitionType::~ParallelismCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void ParallelismCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (GeometricCharac_1050)
    {
  GeometricCharac_1050->printSelf(outFile);
    }
  if (DirectionFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DirectionFeature");
      DirectionFeature->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DirectionFeature>\n");
    }
  if (CollectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CollectionPlane");
      CollectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CollectionPlane>\n");
    }
  if (IntersectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IntersectionPlane");
      IntersectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</IntersectionPlane>\n");
    }
  if (OrientationPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OrientationPlane");
      OrientationPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OrientationPlane>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ToleranceValue");
  ToleranceValue->printSelf(outFile);
  fprintf(outFile, "</ToleranceValue>\n");
  if (ToleranceDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceDualValue");
      ToleranceDualValue->printSelf(outFile);
      fprintf(outFile, "</ToleranceDualValue>\n");
    }
  if (DatumReferenceFrameId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumReferenceFrameId");
      DatumReferenceFrameId->printSelf(outFile);
      fprintf(outFile, "</DatumReferenceFrameId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<MaterialCondition");
  MaterialCondition->printSelf(outFile);
  fprintf(outFile, "</MaterialCondition>\n");
  if (SizeCharacteristicDefinitionId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SizeCharacteristicDefinitionId");
      SizeCharacteristicDefinitionId->printSelf(outFile);
      fprintf(outFile, "</SizeCharacteristicDefinitionId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ZoneShape");
  ZoneShape->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ZoneShape>\n");
  if (TangentPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TangentPlane");
      TangentPlane->printSelf(outFile);
      fprintf(outFile, "</TangentPlane>\n");
    }
  if (MaximumToleranceValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaximumToleranceValue");
      MaximumToleranceValue->printSelf(outFile);
      fprintf(outFile, "</MaximumToleranceValue>\n");
    }
  if (ProjectedToleranceZoneValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProjectedToleranceZoneValue");
      ProjectedToleranceZoneValue->printSelf(outFile);
      fprintf(outFile, "</ProjectedToleranceZoneValue>\n");
    }
  if (OrientationChar_1054)
    {
  OrientationChar_1054->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool ParallelismCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ParallelismCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ParallelismCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ParallelismCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ParallelismCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class ParallelismCharacteristicItemType

*/

ParallelismCharacteristicItemType::ParallelismCharacteristicItemType() :
  OrientationCharacteristicItemBaseType()
{
}

ParallelismCharacteristicItemType::ParallelismCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  OrientationCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

ParallelismCharacteristicItemType::ParallelismCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  OrientationCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

ParallelismCharacteristicItemType::~ParallelismCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void ParallelismCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool ParallelismCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ParallelismCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ParallelismCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ParallelismCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ParallelismCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class ParallelismCharacteristicMeasurementType

*/

ParallelismCharacteristicMeasurementType::ParallelismCharacteristicMeasurementType() :
  OrientationCharacteristicMeasurementBaseType()
{
}

ParallelismCharacteristicMeasurementType::ParallelismCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 XmlBoolean * DatumsOkIn,
 MeasuredLinearValueType * BonusIn,
 LinearValueType * ReferenceLengthIn,
 QIFReferenceType * DRFTransformActualIdIn) :
  OrientationCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn,
    DatumsOkIn,
    BonusIn,
    ReferenceLengthIn,
    DRFTransformActualIdIn)
{
}

ParallelismCharacteristicMeasurementType::ParallelismCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 XmlBoolean * DatumsOkIn,
 MeasuredLinearValueType * BonusIn,
 LinearValueType * ReferenceLengthIn,
 QIFReferenceType * DRFTransformActualIdIn) :
  OrientationCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn,
    DatumsOkIn,
    BonusIn,
    ReferenceLengthIn,
    DRFTransformActualIdIn)
{
}

ParallelismCharacteristicMeasurementType::~ParallelismCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void ParallelismCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  if (DatumsOk)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumsOk");
      DatumsOk->printSelf(outFile);
      fprintf(outFile, "</DatumsOk>\n");
    }
  if (Bonus)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Bonus");
      Bonus->printSelf(outFile);
      fprintf(outFile, "</Bonus>\n");
    }
  if (ReferenceLength)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ReferenceLength");
      ReferenceLength->printSelf(outFile);
      fprintf(outFile, "</ReferenceLength>\n");
    }
  if (DRFTransformActualId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DRFTransformActualId");
      DRFTransformActualId->printSelf(outFile);
      fprintf(outFile, "</DRFTransformActualId>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ParallelismCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ParallelismCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ParallelismCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ParallelismCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ParallelismCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class ParallelismCharacteristicNominalType

*/

ParallelismCharacteristicNominalType::ParallelismCharacteristicNominalType() :
  OrientationCharacteristicNominalBaseType()
{
}

ParallelismCharacteristicNominalType::ParallelismCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  OrientationCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

ParallelismCharacteristicNominalType::ParallelismCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  OrientationCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

ParallelismCharacteristicNominalType::~ParallelismCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void ParallelismCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ParallelismCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ParallelismCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ParallelismCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ParallelismCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ParallelismCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class PerpendicularityCharacteristicDefinitionType

*/

PerpendicularityCharacteristicDefinitionType::PerpendicularityCharacteristicDefinitionType() :
  OrientationCharacteristicDefinitionBaseType()
{
}

PerpendicularityCharacteristicDefinitionType::PerpendicularityCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 QIFReferenceFullType * DatumReferenceFrameIdIn,
 MaterialModifierEnumType * MaterialConditionIn,
 QIFReferenceType * SizeCharacteristicDefinitionIdIn,
 OrientationZoneShapeType * ZoneShapeIn,
 XmlBoolean * TangentPlaneIn,
 LinearValueType * MaximumToleranceValueIn,
 LinearValueType * ProjectedToleranceZoneValueIn,
 OrientationChar_1054_Type * OrientationChar_1054In) :
  OrientationCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn,
    ToleranceValueIn,
    ToleranceDualValueIn,
    DatumReferenceFrameIdIn,
    MaterialConditionIn,
    SizeCharacteristicDefinitionIdIn,
    ZoneShapeIn,
    TangentPlaneIn,
    MaximumToleranceValueIn,
    ProjectedToleranceZoneValueIn,
    OrientationChar_1054In)
{
}

PerpendicularityCharacteristicDefinitionType::PerpendicularityCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 QIFReferenceFullType * DatumReferenceFrameIdIn,
 MaterialModifierEnumType * MaterialConditionIn,
 QIFReferenceType * SizeCharacteristicDefinitionIdIn,
 OrientationZoneShapeType * ZoneShapeIn,
 XmlBoolean * TangentPlaneIn,
 LinearValueType * MaximumToleranceValueIn,
 LinearValueType * ProjectedToleranceZoneValueIn,
 OrientationChar_1054_Type * OrientationChar_1054In) :
  OrientationCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn,
    ToleranceValueIn,
    ToleranceDualValueIn,
    DatumReferenceFrameIdIn,
    MaterialConditionIn,
    SizeCharacteristicDefinitionIdIn,
    ZoneShapeIn,
    TangentPlaneIn,
    MaximumToleranceValueIn,
    ProjectedToleranceZoneValueIn,
    OrientationChar_1054In)
{
}

PerpendicularityCharacteristicDefinitionType::~PerpendicularityCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void PerpendicularityCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (GeometricCharac_1050)
    {
  GeometricCharac_1050->printSelf(outFile);
    }
  if (DirectionFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DirectionFeature");
      DirectionFeature->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DirectionFeature>\n");
    }
  if (CollectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CollectionPlane");
      CollectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CollectionPlane>\n");
    }
  if (IntersectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IntersectionPlane");
      IntersectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</IntersectionPlane>\n");
    }
  if (OrientationPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OrientationPlane");
      OrientationPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OrientationPlane>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ToleranceValue");
  ToleranceValue->printSelf(outFile);
  fprintf(outFile, "</ToleranceValue>\n");
  if (ToleranceDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceDualValue");
      ToleranceDualValue->printSelf(outFile);
      fprintf(outFile, "</ToleranceDualValue>\n");
    }
  if (DatumReferenceFrameId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumReferenceFrameId");
      DatumReferenceFrameId->printSelf(outFile);
      fprintf(outFile, "</DatumReferenceFrameId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<MaterialCondition");
  MaterialCondition->printSelf(outFile);
  fprintf(outFile, "</MaterialCondition>\n");
  if (SizeCharacteristicDefinitionId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SizeCharacteristicDefinitionId");
      SizeCharacteristicDefinitionId->printSelf(outFile);
      fprintf(outFile, "</SizeCharacteristicDefinitionId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ZoneShape");
  ZoneShape->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ZoneShape>\n");
  if (TangentPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TangentPlane");
      TangentPlane->printSelf(outFile);
      fprintf(outFile, "</TangentPlane>\n");
    }
  if (MaximumToleranceValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaximumToleranceValue");
      MaximumToleranceValue->printSelf(outFile);
      fprintf(outFile, "</MaximumToleranceValue>\n");
    }
  if (ProjectedToleranceZoneValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProjectedToleranceZoneValue");
      ProjectedToleranceZoneValue->printSelf(outFile);
      fprintf(outFile, "</ProjectedToleranceZoneValue>\n");
    }
  if (OrientationChar_1054)
    {
  OrientationChar_1054->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool PerpendicularityCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PerpendicularityCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PerpendicularityCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PerpendicularityCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PerpendicularityCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class PerpendicularityCharacteristicItemType

*/

PerpendicularityCharacteristicItemType::PerpendicularityCharacteristicItemType() :
  OrientationCharacteristicItemBaseType()
{
}

PerpendicularityCharacteristicItemType::PerpendicularityCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  OrientationCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

PerpendicularityCharacteristicItemType::PerpendicularityCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  OrientationCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

PerpendicularityCharacteristicItemType::~PerpendicularityCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void PerpendicularityCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool PerpendicularityCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PerpendicularityCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PerpendicularityCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PerpendicularityCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PerpendicularityCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class PerpendicularityCharacteristicMeasurementType

*/

PerpendicularityCharacteristicMeasurementType::PerpendicularityCharacteristicMeasurementType() :
  OrientationCharacteristicMeasurementBaseType()
{
}

PerpendicularityCharacteristicMeasurementType::PerpendicularityCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 XmlBoolean * DatumsOkIn,
 MeasuredLinearValueType * BonusIn,
 LinearValueType * ReferenceLengthIn,
 QIFReferenceType * DRFTransformActualIdIn) :
  OrientationCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn,
    DatumsOkIn,
    BonusIn,
    ReferenceLengthIn,
    DRFTransformActualIdIn)
{
}

PerpendicularityCharacteristicMeasurementType::PerpendicularityCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 XmlBoolean * DatumsOkIn,
 MeasuredLinearValueType * BonusIn,
 LinearValueType * ReferenceLengthIn,
 QIFReferenceType * DRFTransformActualIdIn) :
  OrientationCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn,
    DatumsOkIn,
    BonusIn,
    ReferenceLengthIn,
    DRFTransformActualIdIn)
{
}

PerpendicularityCharacteristicMeasurementType::~PerpendicularityCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void PerpendicularityCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  if (DatumsOk)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumsOk");
      DatumsOk->printSelf(outFile);
      fprintf(outFile, "</DatumsOk>\n");
    }
  if (Bonus)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Bonus");
      Bonus->printSelf(outFile);
      fprintf(outFile, "</Bonus>\n");
    }
  if (ReferenceLength)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ReferenceLength");
      ReferenceLength->printSelf(outFile);
      fprintf(outFile, "</ReferenceLength>\n");
    }
  if (DRFTransformActualId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DRFTransformActualId");
      DRFTransformActualId->printSelf(outFile);
      fprintf(outFile, "</DRFTransformActualId>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool PerpendicularityCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PerpendicularityCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PerpendicularityCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PerpendicularityCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PerpendicularityCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class PerpendicularityCharacteristicNominalType

*/

PerpendicularityCharacteristicNominalType::PerpendicularityCharacteristicNominalType() :
  OrientationCharacteristicNominalBaseType()
{
}

PerpendicularityCharacteristicNominalType::PerpendicularityCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  OrientationCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

PerpendicularityCharacteristicNominalType::PerpendicularityCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  OrientationCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

PerpendicularityCharacteristicNominalType::~PerpendicularityCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void PerpendicularityCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool PerpendicularityCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PerpendicularityCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PerpendicularityCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PerpendicularityCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PerpendicularityCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class PointDeviationType

*/

PointDeviationType::PointDeviationType()
{
  MeasurePointId = 0;
  Deviation = 0;
}

PointDeviationType::PointDeviationType(
 PointSetReferenceSingleType * MeasurePointIdIn,
 LinearValueType * DeviationIn)
{
  MeasurePointId = MeasurePointIdIn;
  Deviation = DeviationIn;
}

PointDeviationType::~PointDeviationType()
{
  #ifndef NODESTRUCT
  delete MeasurePointId;
  delete Deviation;
  #endif
}

void PointDeviationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<MeasurePointId");
  MeasurePointId->printSelf(outFile);
  fprintf(outFile, "</MeasurePointId>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Deviation");
  Deviation->printSelf(outFile);
  fprintf(outFile, "</Deviation>\n");
  doSpaces(-INDENT, outFile);
}

PointSetReferenceSingleType * PointDeviationType::getMeasurePointId()
{return MeasurePointId;}

void PointDeviationType::setMeasurePointId(PointSetReferenceSingleType * MeasurePointIdIn)
{MeasurePointId = MeasurePointIdIn;}

LinearValueType * PointDeviationType::getDeviation()
{return Deviation;}

void PointDeviationType::setDeviation(LinearValueType * DeviationIn)
{Deviation = DeviationIn;}

/* ***************************************************************** */

/* class PointDeviationTypeLisd

*/

PointDeviationTypeLisd::PointDeviationTypeLisd() {}

PointDeviationTypeLisd::PointDeviationTypeLisd(PointDeviationType * aPointDeviationType)
{
  push_back(aPointDeviationType);
}

PointDeviationTypeLisd::~PointDeviationTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<PointDeviationType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void PointDeviationTypeLisd::printSelf(FILE * outFile)
{
  std::list<PointDeviationType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class PointDeviationsType

*/

PointDeviationsType::PointDeviationsType()
{
  n = 0;
  PointDeviation = 0;
}

PointDeviationsType::PointDeviationsType(
 PointDeviationTypeLisd * PointDeviationIn)
{
  n = 0;
  PointDeviation = PointDeviationIn;
}

PointDeviationsType::PointDeviationsType(
 NaturalType * nIn,
 PointDeviationTypeLisd * PointDeviationIn)
{
  n = nIn;
  PointDeviation = PointDeviationIn;
}

PointDeviationsType::~PointDeviationsType()
{
  #ifndef NODESTRUCT
  delete n;
  delete PointDeviation;
  #endif
}

void PointDeviationsType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!PointDeviation)
      {
        fprintf(stderr, "PointDeviation list is missing\n");
        exit(1);
      }
    if (PointDeviation->size() == 0)
      {
        fprintf(stderr, "PointDeviation list is empty\n");
        exit(1);
      }
    if (PointDeviation->size() < 1)
      {
        fprintf(stderr,
                "size of PointDeviation list (%d) less than minimum required (1)\n",
                (int)PointDeviation->size());
        exit(1);
      }
    std::list<PointDeviationType *>::iterator iter;
    for (iter = PointDeviation->begin();
         iter != PointDeviation->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<PointDeviation");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</PointDeviation>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool PointDeviationsType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in PointDeviationsType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in PointDeviationsType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PointDeviationsType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in PointDeviationsType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * PointDeviationsType::getn()
{return n;}

void PointDeviationsType::setn(NaturalType * nIn)
{n = nIn;}

PointDeviationTypeLisd * PointDeviationsType::getPointDeviation()
{return PointDeviation;}

void PointDeviationsType::setPointDeviation(PointDeviationTypeLisd * PointDeviationIn)
{PointDeviation = PointDeviationIn;}

/* ***************************************************************** */

/* class PointProfileCharacteristicDefinitionType

*/

PointProfileCharacteristicDefinitionType::PointProfileCharacteristicDefinitionType() :
  ProfileCharacteristicDefinitionBaseType()
{
}

PointProfileCharacteristicDefinitionType::PointProfileCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 ProfileCharacte_1056_Type * ProfileCharacte_1056In,
 XmlBoolean * OffsetZoneIn,
 XmlBoolean * VariableAngleIn,
 CompositeSegmentProfileDefinitionType * SecondCompositeSegmentProfileDefinitionIn,
 CompositeSegmentProfileDefinitionType * ThirdCompositeSegmentProfileDefinitionIn,
 CompositeSegmentProfileDefinitionType * FourthCompositeSegmentProfileDefinitionIn,
 QIFReferenceFullType * DatumReferenceFrameIdIn,
 XmlBoolean * OrientationOnlyIn) :
  ProfileCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn,
    ToleranceValueIn,
    ToleranceDualValueIn,
    ProfileCharacte_1056In,
    OffsetZoneIn,
    VariableAngleIn,
    SecondCompositeSegmentProfileDefinitionIn,
    ThirdCompositeSegmentProfileDefinitionIn,
    FourthCompositeSegmentProfileDefinitionIn,
    DatumReferenceFrameIdIn,
    OrientationOnlyIn)
{
}

PointProfileCharacteristicDefinitionType::PointProfileCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 ProfileCharacte_1056_Type * ProfileCharacte_1056In,
 XmlBoolean * OffsetZoneIn,
 XmlBoolean * VariableAngleIn,
 CompositeSegmentProfileDefinitionType * SecondCompositeSegmentProfileDefinitionIn,
 CompositeSegmentProfileDefinitionType * ThirdCompositeSegmentProfileDefinitionIn,
 CompositeSegmentProfileDefinitionType * FourthCompositeSegmentProfileDefinitionIn,
 QIFReferenceFullType * DatumReferenceFrameIdIn,
 XmlBoolean * OrientationOnlyIn) :
  ProfileCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn,
    ToleranceValueIn,
    ToleranceDualValueIn,
    ProfileCharacte_1056In,
    OffsetZoneIn,
    VariableAngleIn,
    SecondCompositeSegmentProfileDefinitionIn,
    ThirdCompositeSegmentProfileDefinitionIn,
    FourthCompositeSegmentProfileDefinitionIn,
    DatumReferenceFrameIdIn,
    OrientationOnlyIn)
{
}

PointProfileCharacteristicDefinitionType::~PointProfileCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void PointProfileCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (GeometricCharac_1050)
    {
  GeometricCharac_1050->printSelf(outFile);
    }
  if (DirectionFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DirectionFeature");
      DirectionFeature->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DirectionFeature>\n");
    }
  if (CollectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CollectionPlane");
      CollectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CollectionPlane>\n");
    }
  if (IntersectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IntersectionPlane");
      IntersectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</IntersectionPlane>\n");
    }
  if (OrientationPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OrientationPlane");
      OrientationPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OrientationPlane>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ToleranceValue");
  ToleranceValue->printSelf(outFile);
  fprintf(outFile, "</ToleranceValue>\n");
  if (ToleranceDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceDualValue");
      ToleranceDualValue->printSelf(outFile);
      fprintf(outFile, "</ToleranceDualValue>\n");
    }
  if (ProfileCharacte_1056)
    {
  ProfileCharacte_1056->printSelf(outFile);
    }
  if (OffsetZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OffsetZone");
      OffsetZone->printSelf(outFile);
      fprintf(outFile, "</OffsetZone>\n");
    }
  if (VariableAngle)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VariableAngle");
      VariableAngle->printSelf(outFile);
      fprintf(outFile, "</VariableAngle>\n");
    }
  if (SecondCompositeSegmentProfileDefinition)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SecondCompositeSegmentProfileDefinition");
      SecondCompositeSegmentProfileDefinition->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SecondCompositeSegmentProfileDefinition>\n");
    }
  if (ThirdCompositeSegmentProfileDefinition)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ThirdCompositeSegmentProfileDefinition");
      ThirdCompositeSegmentProfileDefinition->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ThirdCompositeSegmentProfileDefinition>\n");
    }
  if (FourthCompositeSegmentProfileDefinition)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FourthCompositeSegmentProfileDefinition");
      FourthCompositeSegmentProfileDefinition->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FourthCompositeSegmentProfileDefinition>\n");
    }
  if (DatumReferenceFrameId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumReferenceFrameId");
      DatumReferenceFrameId->printSelf(outFile);
      fprintf(outFile, "</DatumReferenceFrameId>\n");
    }
  if (OrientationOnly)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OrientationOnly");
      OrientationOnly->printSelf(outFile);
      fprintf(outFile, "</OrientationOnly>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool PointProfileCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PointProfileCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PointProfileCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PointProfileCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PointProfileCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class PointProfileCharacteristicItemType

*/

PointProfileCharacteristicItemType::PointProfileCharacteristicItemType() :
  ProfileCharacteristicItemBaseType()
{
}

PointProfileCharacteristicItemType::PointProfileCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  ProfileCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

PointProfileCharacteristicItemType::PointProfileCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  ProfileCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

PointProfileCharacteristicItemType::~PointProfileCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void PointProfileCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool PointProfileCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PointProfileCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PointProfileCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PointProfileCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PointProfileCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class PointProfileCharacteristicMeasurementType

*/

PointProfileCharacteristicMeasurementType::PointProfileCharacteristicMeasurementType() :
  ProfileCharacteristicMeasurementBaseType()
{
}

PointProfileCharacteristicMeasurementType::PointProfileCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 LinearValueType * WorstPositiveDeviationIn,
 LinearValueType * WorstNegativeDeviationIn,
 PointDeviationsType * PointDeviationsIn,
 XmlBoolean * DatumsOkIn,
 QIFReferenceType * DRFTransformActualIdIn,
 CompositeSegmentProfileMeasurementType * SecondCompositeSegmentProfileMeasurementIn,
 CompositeSegmentProfileMeasurementType * ThirdCompositeSegmentProfileMeasurementIn,
 CompositeSegmentProfileMeasurementType * FourthCompositeSegmentProfileMeasurementIn) :
  ProfileCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn,
    WorstPositiveDeviationIn,
    WorstNegativeDeviationIn,
    PointDeviationsIn,
    DatumsOkIn,
    DRFTransformActualIdIn,
    SecondCompositeSegmentProfileMeasurementIn,
    ThirdCompositeSegmentProfileMeasurementIn,
    FourthCompositeSegmentProfileMeasurementIn)
{
}

PointProfileCharacteristicMeasurementType::PointProfileCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 LinearValueType * WorstPositiveDeviationIn,
 LinearValueType * WorstNegativeDeviationIn,
 PointDeviationsType * PointDeviationsIn,
 XmlBoolean * DatumsOkIn,
 QIFReferenceType * DRFTransformActualIdIn,
 CompositeSegmentProfileMeasurementType * SecondCompositeSegmentProfileMeasurementIn,
 CompositeSegmentProfileMeasurementType * ThirdCompositeSegmentProfileMeasurementIn,
 CompositeSegmentProfileMeasurementType * FourthCompositeSegmentProfileMeasurementIn) :
  ProfileCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn,
    WorstPositiveDeviationIn,
    WorstNegativeDeviationIn,
    PointDeviationsIn,
    DatumsOkIn,
    DRFTransformActualIdIn,
    SecondCompositeSegmentProfileMeasurementIn,
    ThirdCompositeSegmentProfileMeasurementIn,
    FourthCompositeSegmentProfileMeasurementIn)
{
}

PointProfileCharacteristicMeasurementType::~PointProfileCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void PointProfileCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  if (WorstPositiveDeviation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WorstPositiveDeviation");
      WorstPositiveDeviation->printSelf(outFile);
      fprintf(outFile, "</WorstPositiveDeviation>\n");
    }
  if (WorstNegativeDeviation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WorstNegativeDeviation");
      WorstNegativeDeviation->printSelf(outFile);
      fprintf(outFile, "</WorstNegativeDeviation>\n");
    }
  if (PointDeviations)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointDeviations");
      PointDeviations->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointDeviations>\n");
    }
  if (DatumsOk)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumsOk");
      DatumsOk->printSelf(outFile);
      fprintf(outFile, "</DatumsOk>\n");
    }
  if (DRFTransformActualId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DRFTransformActualId");
      DRFTransformActualId->printSelf(outFile);
      fprintf(outFile, "</DRFTransformActualId>\n");
    }
  if (SecondCompositeSegmentProfileMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SecondCompositeSegmentProfileMeasurement");
      SecondCompositeSegmentProfileMeasurement->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SecondCompositeSegmentProfileMeasurement>\n");
    }
  if (ThirdCompositeSegmentProfileMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ThirdCompositeSegmentProfileMeasurement");
      ThirdCompositeSegmentProfileMeasurement->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ThirdCompositeSegmentProfileMeasurement>\n");
    }
  if (FourthCompositeSegmentProfileMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FourthCompositeSegmentProfileMeasurement");
      FourthCompositeSegmentProfileMeasurement->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FourthCompositeSegmentProfileMeasurement>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool PointProfileCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PointProfileCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PointProfileCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PointProfileCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PointProfileCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class PointProfileCharacteristicNominalType

*/

PointProfileCharacteristicNominalType::PointProfileCharacteristicNominalType() :
  ProfileCharacteristicNominalBaseType()
{
}

PointProfileCharacteristicNominalType::PointProfileCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn) :
  ProfileCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn)
{
}

PointProfileCharacteristicNominalType::PointProfileCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn) :
  ProfileCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn)
{
}

PointProfileCharacteristicNominalType::~PointProfileCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void PointProfileCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool PointProfileCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PointProfileCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PointProfileCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PointProfileCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PointProfileCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class PositionCharacteristicDefinitionType

*/

PositionCharacteristicDefinitionType::PositionCharacteristicDefinitionType() :
  LocationCharacteristicDefinitionBaseType()
{
  MaterialCondition = 0;
  SizeCharacteristicDefinitionId = 0;
  ZoneShape = 0;
  MaximumToleranceValue = 0;
  ProjectedToleranceZoneValue = 0;
  SecondCompositeSegmentPositionDefinition = 0;
  ThirdCompositeSegmentPositionDefinition = 0;
  FourthCompositeSegmentPositionDefinition = 0;
  ToPointToleranceValue = 0;
  OrientationOnly = 0;
}

PositionCharacteristicDefinitionType::PositionCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 QIFReferenceFullType * DatumReferenceFrameIdIn,
 MaterialModifierEnumType * MaterialConditionIn,
 QIFReferenceType * SizeCharacteristicDefinitionIdIn,
 PositionZoneShapeType * ZoneShapeIn,
 LinearValueType * MaximumToleranceValueIn,
 LinearValueType * ProjectedToleranceZoneValueIn,
 CompositeSegmentPositionDefinitionType * SecondCompositeSegmentPositionDefinitionIn,
 CompositeSegmentPositionDefinitionType * ThirdCompositeSegmentPositionDefinitionIn,
 CompositeSegmentPositionDefinitionType * FourthCompositeSegmentPositionDefinitionIn,
 LinearValueType * ToPointToleranceValueIn,
 XmlBoolean * OrientationOnlyIn) :
  LocationCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn,
    ToleranceValueIn,
    ToleranceDualValueIn,
    DatumReferenceFrameIdIn)
{
  MaterialCondition = MaterialConditionIn;
  SizeCharacteristicDefinitionId = SizeCharacteristicDefinitionIdIn;
  ZoneShape = ZoneShapeIn;
  MaximumToleranceValue = MaximumToleranceValueIn;
  ProjectedToleranceZoneValue = ProjectedToleranceZoneValueIn;
  SecondCompositeSegmentPositionDefinition = SecondCompositeSegmentPositionDefinitionIn;
  ThirdCompositeSegmentPositionDefinition = ThirdCompositeSegmentPositionDefinitionIn;
  FourthCompositeSegmentPositionDefinition = FourthCompositeSegmentPositionDefinitionIn;
  ToPointToleranceValue = ToPointToleranceValueIn;
  OrientationOnly = OrientationOnlyIn;
}

PositionCharacteristicDefinitionType::PositionCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 QIFReferenceFullType * DatumReferenceFrameIdIn,
 MaterialModifierEnumType * MaterialConditionIn,
 QIFReferenceType * SizeCharacteristicDefinitionIdIn,
 PositionZoneShapeType * ZoneShapeIn,
 LinearValueType * MaximumToleranceValueIn,
 LinearValueType * ProjectedToleranceZoneValueIn,
 CompositeSegmentPositionDefinitionType * SecondCompositeSegmentPositionDefinitionIn,
 CompositeSegmentPositionDefinitionType * ThirdCompositeSegmentPositionDefinitionIn,
 CompositeSegmentPositionDefinitionType * FourthCompositeSegmentPositionDefinitionIn,
 LinearValueType * ToPointToleranceValueIn,
 XmlBoolean * OrientationOnlyIn) :
  LocationCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn,
    ToleranceValueIn,
    ToleranceDualValueIn,
    DatumReferenceFrameIdIn)
{
  MaterialCondition = MaterialConditionIn;
  SizeCharacteristicDefinitionId = SizeCharacteristicDefinitionIdIn;
  ZoneShape = ZoneShapeIn;
  MaximumToleranceValue = MaximumToleranceValueIn;
  ProjectedToleranceZoneValue = ProjectedToleranceZoneValueIn;
  SecondCompositeSegmentPositionDefinition = SecondCompositeSegmentPositionDefinitionIn;
  ThirdCompositeSegmentPositionDefinition = ThirdCompositeSegmentPositionDefinitionIn;
  FourthCompositeSegmentPositionDefinition = FourthCompositeSegmentPositionDefinitionIn;
  ToPointToleranceValue = ToPointToleranceValueIn;
  OrientationOnly = OrientationOnlyIn;
}

PositionCharacteristicDefinitionType::~PositionCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  delete MaterialCondition;
  delete SizeCharacteristicDefinitionId;
  delete ZoneShape;
  delete MaximumToleranceValue;
  delete ProjectedToleranceZoneValue;
  delete SecondCompositeSegmentPositionDefinition;
  delete ThirdCompositeSegmentPositionDefinition;
  delete FourthCompositeSegmentPositionDefinition;
  delete ToPointToleranceValue;
  delete OrientationOnly;
  #endif
}

void PositionCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (GeometricCharac_1050)
    {
  GeometricCharac_1050->printSelf(outFile);
    }
  if (DirectionFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DirectionFeature");
      DirectionFeature->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DirectionFeature>\n");
    }
  if (CollectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CollectionPlane");
      CollectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CollectionPlane>\n");
    }
  if (IntersectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IntersectionPlane");
      IntersectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</IntersectionPlane>\n");
    }
  if (OrientationPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OrientationPlane");
      OrientationPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OrientationPlane>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ToleranceValue");
  ToleranceValue->printSelf(outFile);
  fprintf(outFile, "</ToleranceValue>\n");
  if (ToleranceDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceDualValue");
      ToleranceDualValue->printSelf(outFile);
      fprintf(outFile, "</ToleranceDualValue>\n");
    }
  if (DatumReferenceFrameId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumReferenceFrameId");
      DatumReferenceFrameId->printSelf(outFile);
      fprintf(outFile, "</DatumReferenceFrameId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<MaterialCondition");
  MaterialCondition->printSelf(outFile);
  fprintf(outFile, "</MaterialCondition>\n");
  if (SizeCharacteristicDefinitionId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SizeCharacteristicDefinitionId");
      SizeCharacteristicDefinitionId->printSelf(outFile);
      fprintf(outFile, "</SizeCharacteristicDefinitionId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ZoneShape");
  ZoneShape->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ZoneShape>\n");
  if (MaximumToleranceValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaximumToleranceValue");
      MaximumToleranceValue->printSelf(outFile);
      fprintf(outFile, "</MaximumToleranceValue>\n");
    }
  if (ProjectedToleranceZoneValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProjectedToleranceZoneValue");
      ProjectedToleranceZoneValue->printSelf(outFile);
      fprintf(outFile, "</ProjectedToleranceZoneValue>\n");
    }
  if (SecondCompositeSegmentPositionDefinition)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SecondCompositeSegmentPositionDefinition");
      SecondCompositeSegmentPositionDefinition->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SecondCompositeSegmentPositionDefinition>\n");
    }
  if (ThirdCompositeSegmentPositionDefinition)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ThirdCompositeSegmentPositionDefinition");
      ThirdCompositeSegmentPositionDefinition->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ThirdCompositeSegmentPositionDefinition>\n");
    }
  if (FourthCompositeSegmentPositionDefinition)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FourthCompositeSegmentPositionDefinition");
      FourthCompositeSegmentPositionDefinition->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FourthCompositeSegmentPositionDefinition>\n");
    }
  if (ToPointToleranceValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToPointToleranceValue");
      ToPointToleranceValue->printSelf(outFile);
      fprintf(outFile, "</ToPointToleranceValue>\n");
    }
  if (OrientationOnly)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OrientationOnly");
      OrientationOnly->printSelf(outFile);
      fprintf(outFile, "</OrientationOnly>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool PositionCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PositionCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PositionCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PositionCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PositionCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MaterialModifierEnumType * PositionCharacteristicDefinitionType::getMaterialCondition()
{return MaterialCondition;}

void PositionCharacteristicDefinitionType::setMaterialCondition(MaterialModifierEnumType * MaterialConditionIn)
{MaterialCondition = MaterialConditionIn;}

QIFReferenceType * PositionCharacteristicDefinitionType::getSizeCharacteristicDefinitionId()
{return SizeCharacteristicDefinitionId;}

void PositionCharacteristicDefinitionType::setSizeCharacteristicDefinitionId(QIFReferenceType * SizeCharacteristicDefinitionIdIn)
{SizeCharacteristicDefinitionId = SizeCharacteristicDefinitionIdIn;}

PositionZoneShapeType * PositionCharacteristicDefinitionType::getZoneShape()
{return ZoneShape;}

void PositionCharacteristicDefinitionType::setZoneShape(PositionZoneShapeType * ZoneShapeIn)
{ZoneShape = ZoneShapeIn;}

LinearValueType * PositionCharacteristicDefinitionType::getMaximumToleranceValue()
{return MaximumToleranceValue;}

void PositionCharacteristicDefinitionType::setMaximumToleranceValue(LinearValueType * MaximumToleranceValueIn)
{MaximumToleranceValue = MaximumToleranceValueIn;}

LinearValueType * PositionCharacteristicDefinitionType::getProjectedToleranceZoneValue()
{return ProjectedToleranceZoneValue;}

void PositionCharacteristicDefinitionType::setProjectedToleranceZoneValue(LinearValueType * ProjectedToleranceZoneValueIn)
{ProjectedToleranceZoneValue = ProjectedToleranceZoneValueIn;}

CompositeSegmentPositionDefinitionType * PositionCharacteristicDefinitionType::getSecondCompositeSegmentPositionDefinition()
{return SecondCompositeSegmentPositionDefinition;}

void PositionCharacteristicDefinitionType::setSecondCompositeSegmentPositionDefinition(CompositeSegmentPositionDefinitionType * SecondCompositeSegmentPositionDefinitionIn)
{SecondCompositeSegmentPositionDefinition = SecondCompositeSegmentPositionDefinitionIn;}

CompositeSegmentPositionDefinitionType * PositionCharacteristicDefinitionType::getThirdCompositeSegmentPositionDefinition()
{return ThirdCompositeSegmentPositionDefinition;}

void PositionCharacteristicDefinitionType::setThirdCompositeSegmentPositionDefinition(CompositeSegmentPositionDefinitionType * ThirdCompositeSegmentPositionDefinitionIn)
{ThirdCompositeSegmentPositionDefinition = ThirdCompositeSegmentPositionDefinitionIn;}

CompositeSegmentPositionDefinitionType * PositionCharacteristicDefinitionType::getFourthCompositeSegmentPositionDefinition()
{return FourthCompositeSegmentPositionDefinition;}

void PositionCharacteristicDefinitionType::setFourthCompositeSegmentPositionDefinition(CompositeSegmentPositionDefinitionType * FourthCompositeSegmentPositionDefinitionIn)
{FourthCompositeSegmentPositionDefinition = FourthCompositeSegmentPositionDefinitionIn;}

LinearValueType * PositionCharacteristicDefinitionType::getToPointToleranceValue()
{return ToPointToleranceValue;}

void PositionCharacteristicDefinitionType::setToPointToleranceValue(LinearValueType * ToPointToleranceValueIn)
{ToPointToleranceValue = ToPointToleranceValueIn;}

XmlBoolean * PositionCharacteristicDefinitionType::getOrientationOnly()
{return OrientationOnly;}

void PositionCharacteristicDefinitionType::setOrientationOnly(XmlBoolean * OrientationOnlyIn)
{OrientationOnly = OrientationOnlyIn;}

/* ***************************************************************** */

/* class PositionCharacteristicItemType

*/

PositionCharacteristicItemType::PositionCharacteristicItemType() :
  LocationCharacteristicItemBaseType()
{
}

PositionCharacteristicItemType::PositionCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LocationCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

PositionCharacteristicItemType::PositionCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LocationCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

PositionCharacteristicItemType::~PositionCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void PositionCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool PositionCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PositionCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PositionCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PositionCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PositionCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class PositionCharacteristicMeasurementType

*/

PositionCharacteristicMeasurementType::PositionCharacteristicMeasurementType() :
  LocationCharacteristicMeasurementBaseType()
{
  Bonus = 0;
  DRFTransformActualId = 0;
  SecondCompositeSegmentPositionMeasurement = 0;
  ThirdCompositeSegmentPositionMeasurement = 0;
  FourthCompositeSegmentPositionMeasurement = 0;
}

PositionCharacteristicMeasurementType::PositionCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 ZoneDataSetType * ZoneDataSetIn,
 XmlBoolean * DatumsOkIn,
 MeasuredLinearValueType * BonusIn,
 QIFReferenceType * DRFTransformActualIdIn,
 CompositeSegmentPositionMeasurementType * SecondCompositeSegmentPositionMeasurementIn,
 CompositeSegmentPositionMeasurementType * ThirdCompositeSegmentPositionMeasurementIn,
 CompositeSegmentPositionMeasurementType * FourthCompositeSegmentPositionMeasurementIn) :
  LocationCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn,
    ZoneDataSetIn,
    DatumsOkIn)
{
  Bonus = BonusIn;
  DRFTransformActualId = DRFTransformActualIdIn;
  SecondCompositeSegmentPositionMeasurement = SecondCompositeSegmentPositionMeasurementIn;
  ThirdCompositeSegmentPositionMeasurement = ThirdCompositeSegmentPositionMeasurementIn;
  FourthCompositeSegmentPositionMeasurement = FourthCompositeSegmentPositionMeasurementIn;
}

PositionCharacteristicMeasurementType::PositionCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 ZoneDataSetType * ZoneDataSetIn,
 XmlBoolean * DatumsOkIn,
 MeasuredLinearValueType * BonusIn,
 QIFReferenceType * DRFTransformActualIdIn,
 CompositeSegmentPositionMeasurementType * SecondCompositeSegmentPositionMeasurementIn,
 CompositeSegmentPositionMeasurementType * ThirdCompositeSegmentPositionMeasurementIn,
 CompositeSegmentPositionMeasurementType * FourthCompositeSegmentPositionMeasurementIn) :
  LocationCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn,
    ZoneDataSetIn,
    DatumsOkIn)
{
  Bonus = BonusIn;
  DRFTransformActualId = DRFTransformActualIdIn;
  SecondCompositeSegmentPositionMeasurement = SecondCompositeSegmentPositionMeasurementIn;
  ThirdCompositeSegmentPositionMeasurement = ThirdCompositeSegmentPositionMeasurementIn;
  FourthCompositeSegmentPositionMeasurement = FourthCompositeSegmentPositionMeasurementIn;
}

PositionCharacteristicMeasurementType::~PositionCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  delete Bonus;
  delete DRFTransformActualId;
  delete SecondCompositeSegmentPositionMeasurement;
  delete ThirdCompositeSegmentPositionMeasurement;
  delete FourthCompositeSegmentPositionMeasurement;
  #endif
}

void PositionCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  if (ZoneDataSet)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ZoneDataSet");
      ZoneDataSet->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ZoneDataSet>\n");
    }
  if (DatumsOk)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumsOk");
      DatumsOk->printSelf(outFile);
      fprintf(outFile, "</DatumsOk>\n");
    }
  if (Bonus)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Bonus");
      Bonus->printSelf(outFile);
      fprintf(outFile, "</Bonus>\n");
    }
  if (DRFTransformActualId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DRFTransformActualId");
      DRFTransformActualId->printSelf(outFile);
      fprintf(outFile, "</DRFTransformActualId>\n");
    }
  if (SecondCompositeSegmentPositionMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SecondCompositeSegmentPositionMeasurement");
      SecondCompositeSegmentPositionMeasurement->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SecondCompositeSegmentPositionMeasurement>\n");
    }
  if (ThirdCompositeSegmentPositionMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ThirdCompositeSegmentPositionMeasurement");
      ThirdCompositeSegmentPositionMeasurement->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ThirdCompositeSegmentPositionMeasurement>\n");
    }
  if (FourthCompositeSegmentPositionMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FourthCompositeSegmentPositionMeasurement");
      FourthCompositeSegmentPositionMeasurement->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FourthCompositeSegmentPositionMeasurement>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool PositionCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PositionCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PositionCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PositionCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PositionCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredLinearValueType * PositionCharacteristicMeasurementType::getBonus()
{return Bonus;}

void PositionCharacteristicMeasurementType::setBonus(MeasuredLinearValueType * BonusIn)
{Bonus = BonusIn;}

QIFReferenceType * PositionCharacteristicMeasurementType::getDRFTransformActualId()
{return DRFTransformActualId;}

void PositionCharacteristicMeasurementType::setDRFTransformActualId(QIFReferenceType * DRFTransformActualIdIn)
{DRFTransformActualId = DRFTransformActualIdIn;}

CompositeSegmentPositionMeasurementType * PositionCharacteristicMeasurementType::getSecondCompositeSegmentPositionMeasurement()
{return SecondCompositeSegmentPositionMeasurement;}

void PositionCharacteristicMeasurementType::setSecondCompositeSegmentPositionMeasurement(CompositeSegmentPositionMeasurementType * SecondCompositeSegmentPositionMeasurementIn)
{SecondCompositeSegmentPositionMeasurement = SecondCompositeSegmentPositionMeasurementIn;}

CompositeSegmentPositionMeasurementType * PositionCharacteristicMeasurementType::getThirdCompositeSegmentPositionMeasurement()
{return ThirdCompositeSegmentPositionMeasurement;}

void PositionCharacteristicMeasurementType::setThirdCompositeSegmentPositionMeasurement(CompositeSegmentPositionMeasurementType * ThirdCompositeSegmentPositionMeasurementIn)
{ThirdCompositeSegmentPositionMeasurement = ThirdCompositeSegmentPositionMeasurementIn;}

CompositeSegmentPositionMeasurementType * PositionCharacteristicMeasurementType::getFourthCompositeSegmentPositionMeasurement()
{return FourthCompositeSegmentPositionMeasurement;}

void PositionCharacteristicMeasurementType::setFourthCompositeSegmentPositionMeasurement(CompositeSegmentPositionMeasurementType * FourthCompositeSegmentPositionMeasurementIn)
{FourthCompositeSegmentPositionMeasurement = FourthCompositeSegmentPositionMeasurementIn;}

/* ***************************************************************** */

/* class PositionCharacteristicNominalType

*/

PositionCharacteristicNominalType::PositionCharacteristicNominalType() :
  LocationCharacteristicNominalBaseType()
{
  CoordinateMethod = 0;
}

PositionCharacteristicNominalType::PositionCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 PositionCoordinateMethodType * CoordinateMethodIn) :
  LocationCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  CoordinateMethod = CoordinateMethodIn;
}

PositionCharacteristicNominalType::PositionCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 PositionCoordinateMethodType * CoordinateMethodIn) :
  LocationCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  CoordinateMethod = CoordinateMethodIn;
}

PositionCharacteristicNominalType::~PositionCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  delete CoordinateMethod;
  #endif
}

void PositionCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (CoordinateMethod)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateMethod");
      CoordinateMethod->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CoordinateMethod>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool PositionCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PositionCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PositionCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PositionCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PositionCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

PositionCoordinateMethodType * PositionCharacteristicNominalType::getCoordinateMethod()
{return CoordinateMethod;}

void PositionCharacteristicNominalType::setCoordinateMethod(PositionCoordinateMethodType * CoordinateMethodIn)
{CoordinateMethod = CoordinateMethodIn;}

/* ***************************************************************** */

/* class PositionCoordinateMethodEnumType

*/

PositionCoordinateMethodEnumType::PositionCoordinateMethodEnumType() :
  XmlString()
{
}

PositionCoordinateMethodEnumType::PositionCoordinateMethodEnumType(
 const char * valIn) :
  XmlString(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "RECTANGULAR") &&
           strcmp(val.c_str(), "POLAR"));
}

PositionCoordinateMethodEnumType::~PositionCoordinateMethodEnumType() {}

bool PositionCoordinateMethodEnumType::PositionCoordinateMethodEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "RECTANGULAR") &&
          strcmp(val.c_str(), "POLAR"));
}

void PositionCoordinateMethodEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "PositionCoordinateMethodEnumType");
}

void PositionCoordinateMethodEnumType::printSelf(FILE * outFile)
{
  if (PositionCoordinateMethodEnumTypeIsBad())
    {
      fprintf(stderr, "bad PositionCoordinateMethodEnumType value, ");
      XmlString::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlString::printSelf(outFile);
}

void PositionCoordinateMethodEnumType::oPrintSelf(FILE * outFile)
{
  if (PositionCoordinateMethodEnumTypeIsBad())
    {
      fprintf(stderr, "bad PositionCoordinateMethodEnumType value, ");
      XmlString::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlString::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class PositionCoordinateMethodType

*/

PositionCoordinateMethodType::PositionCoordinateMethodType()
{
  Method = 0;
  FeatureZoneIds = 0;
}

PositionCoordinateMethodType::PositionCoordinateMethodType(
 PositionCoordinateMethodEnumType * MethodIn,
 ArrayReferenceFullType * FeatureZoneIdsIn)
{
  Method = MethodIn;
  FeatureZoneIds = FeatureZoneIdsIn;
}

PositionCoordinateMethodType::~PositionCoordinateMethodType()
{
  #ifndef NODESTRUCT
  delete Method;
  delete FeatureZoneIds;
  #endif
}

void PositionCoordinateMethodType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Method");
  Method->printSelf(outFile);
  fprintf(outFile, "</Method>\n");
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  doSpaces(-INDENT, outFile);
}

PositionCoordinateMethodEnumType * PositionCoordinateMethodType::getMethod()
{return Method;}

void PositionCoordinateMethodType::setMethod(PositionCoordinateMethodEnumType * MethodIn)
{Method = MethodIn;}

ArrayReferenceFullType * PositionCoordinateMethodType::getFeatureZoneIds()
{return FeatureZoneIds;}

void PositionCoordinateMethodType::setFeatureZoneIds(ArrayReferenceFullType * FeatureZoneIdsIn)
{FeatureZoneIds = FeatureZoneIdsIn;}

/* ***************************************************************** */

/* class PositionDiametricalZoneType

*/

PositionDiametricalZoneType::PositionDiametricalZoneType()
{
  Dimensionality = 0;
  ZoneOrientationVector = 0;
  ElongatedZone = 0;
}

PositionDiametricalZoneType::PositionDiametricalZoneType(
 DimensionCountEnumType * DimensionalityIn,
 UnitVectorType * ZoneOrientationVectorIn,
 XmlBoolean * ElongatedZoneIn)
{
  Dimensionality = DimensionalityIn;
  ZoneOrientationVector = ZoneOrientationVectorIn;
  ElongatedZone = ElongatedZoneIn;
}

PositionDiametricalZoneType::~PositionDiametricalZoneType()
{
  #ifndef NODESTRUCT
  delete Dimensionality;
  delete ZoneOrientationVector;
  delete ElongatedZone;
  #endif
}

void PositionDiametricalZoneType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Dimensionality)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Dimensionality");
      Dimensionality->printSelf(outFile);
      fprintf(outFile, "</Dimensionality>\n");
    }
  if (ZoneOrientationVector)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ZoneOrientationVector");
      ZoneOrientationVector->printSelf(outFile);
      fprintf(outFile, "</ZoneOrientationVector>\n");
    }
  if (ElongatedZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ElongatedZone");
      ElongatedZone->printSelf(outFile);
      fprintf(outFile, "</ElongatedZone>\n");
    }
  doSpaces(-INDENT, outFile);
}

DimensionCountEnumType * PositionDiametricalZoneType::getDimensionality()
{return Dimensionality;}

void PositionDiametricalZoneType::setDimensionality(DimensionCountEnumType * DimensionalityIn)
{Dimensionality = DimensionalityIn;}

UnitVectorType * PositionDiametricalZoneType::getZoneOrientationVector()
{return ZoneOrientationVector;}

void PositionDiametricalZoneType::setZoneOrientationVector(UnitVectorType * ZoneOrientationVectorIn)
{ZoneOrientationVector = ZoneOrientationVectorIn;}

XmlBoolean * PositionDiametricalZoneType::getElongatedZone()
{return ElongatedZone;}

void PositionDiametricalZoneType::setElongatedZone(XmlBoolean * ElongatedZoneIn)
{ElongatedZone = ElongatedZoneIn;}

/* ***************************************************************** */

/* class PositionNonDiametricalZoneType

*/

PositionNonDiametricalZoneType::PositionNonDiametricalZoneType()
{
  Dimensionality = 0;
  ZoneOrientationVector = 0;
  BoundaryZone = 0;
  ZoneOrientationEnum = 0;
  CoordinateSystemId = 0;
}

PositionNonDiametricalZoneType::PositionNonDiametricalZoneType(
 DimensionCountEnumType * DimensionalityIn,
 UnitVectorType * ZoneOrientationVectorIn,
 XmlBoolean * BoundaryZoneIn,
 ZoneOrientationEnumType * ZoneOrientationEnumIn,
 QIFReferenceFullType * CoordinateSystemIdIn)
{
  Dimensionality = DimensionalityIn;
  ZoneOrientationVector = ZoneOrientationVectorIn;
  BoundaryZone = BoundaryZoneIn;
  ZoneOrientationEnum = ZoneOrientationEnumIn;
  CoordinateSystemId = CoordinateSystemIdIn;
}

PositionNonDiametricalZoneType::~PositionNonDiametricalZoneType()
{
  #ifndef NODESTRUCT
  delete Dimensionality;
  delete ZoneOrientationVector;
  delete BoundaryZone;
  delete ZoneOrientationEnum;
  delete CoordinateSystemId;
  #endif
}

void PositionNonDiametricalZoneType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Dimensionality)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Dimensionality");
      Dimensionality->printSelf(outFile);
      fprintf(outFile, "</Dimensionality>\n");
    }
  if (ZoneOrientationVector)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ZoneOrientationVector");
      ZoneOrientationVector->printSelf(outFile);
      fprintf(outFile, "</ZoneOrientationVector>\n");
    }
  if (BoundaryZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BoundaryZone");
      BoundaryZone->printSelf(outFile);
      fprintf(outFile, "</BoundaryZone>\n");
    }
  if (ZoneOrientationEnum)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ZoneOrientationEnum");
      ZoneOrientationEnum->printSelf(outFile);
      fprintf(outFile, "</ZoneOrientationEnum>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  doSpaces(-INDENT, outFile);
}

DimensionCountEnumType * PositionNonDiametricalZoneType::getDimensionality()
{return Dimensionality;}

void PositionNonDiametricalZoneType::setDimensionality(DimensionCountEnumType * DimensionalityIn)
{Dimensionality = DimensionalityIn;}

UnitVectorType * PositionNonDiametricalZoneType::getZoneOrientationVector()
{return ZoneOrientationVector;}

void PositionNonDiametricalZoneType::setZoneOrientationVector(UnitVectorType * ZoneOrientationVectorIn)
{ZoneOrientationVector = ZoneOrientationVectorIn;}

XmlBoolean * PositionNonDiametricalZoneType::getBoundaryZone()
{return BoundaryZone;}

void PositionNonDiametricalZoneType::setBoundaryZone(XmlBoolean * BoundaryZoneIn)
{BoundaryZone = BoundaryZoneIn;}

ZoneOrientationEnumType * PositionNonDiametricalZoneType::getZoneOrientationEnum()
{return ZoneOrientationEnum;}

void PositionNonDiametricalZoneType::setZoneOrientationEnum(ZoneOrientationEnumType * ZoneOrientationEnumIn)
{ZoneOrientationEnum = ZoneOrientationEnumIn;}

QIFReferenceFullType * PositionNonDiametricalZoneType::getCoordinateSystemId()
{return CoordinateSystemId;}

void PositionNonDiametricalZoneType::setCoordinateSystemId(QIFReferenceFullType * CoordinateSystemIdIn)
{CoordinateSystemId = CoordinateSystemIdIn;}

/* ***************************************************************** */

/* class PositionSphericalZoneType

*/

PositionSphericalZoneType::PositionSphericalZoneType()
{
  Dimensionality = 0;
}

PositionSphericalZoneType::PositionSphericalZoneType(
 DimensionCountEnumType * DimensionalityIn)
{
  Dimensionality = DimensionalityIn;
}

PositionSphericalZoneType::~PositionSphericalZoneType()
{
  #ifndef NODESTRUCT
  delete Dimensionality;
  #endif
}

void PositionSphericalZoneType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Dimensionality)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Dimensionality");
      Dimensionality->printSelf(outFile);
      fprintf(outFile, "</Dimensionality>\n");
    }
  doSpaces(-INDENT, outFile);
}

DimensionCountEnumType * PositionSphericalZoneType::getDimensionality()
{return Dimensionality;}

void PositionSphericalZoneType::setDimensionality(DimensionCountEnumType * DimensionalityIn)
{Dimensionality = DimensionalityIn;}

/* ***************************************************************** */

/* class PositionZoneShapeType

*/

PositionZoneShapeType::PositionZoneShapeType()
{
  PositionZoneShapeTypePair = 0;
}

PositionZoneShapeType::PositionZoneShapeType(
 PositionZoneShapeTypeChoicePair * PositionZoneShapeTypePairIn)
{
  PositionZoneShapeTypePair = PositionZoneShapeTypePairIn;
}

PositionZoneShapeType::~PositionZoneShapeType()
{
  #ifndef NODESTRUCT
  delete PositionZoneShapeTypePair;
  #endif
}

void PositionZoneShapeType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  PositionZoneShapeTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

PositionZoneShapeTypeChoicePair * PositionZoneShapeType::getPositionZoneShapeTypePair()
{return PositionZoneShapeTypePair;}

void PositionZoneShapeType::setPositionZoneShapeTypePair(PositionZoneShapeTypeChoicePair * PositionZoneShapeTypePairIn)
{PositionZoneShapeTypePair = PositionZoneShapeTypePairIn;}
PositionZoneShapeTypeChoicePair::PositionZoneShapeTypeChoicePair() {}

PositionZoneShapeTypeChoicePair::PositionZoneShapeTypeChoicePair(
 whichOne PositionZoneShapeTypeTypeIn,
 PositionZoneShapeTypeVal PositionZoneShapeTypeValueIn)
{
  PositionZoneShapeTypeType = PositionZoneShapeTypeTypeIn;
  PositionZoneShapeTypeValue = PositionZoneShapeTypeValueIn;
}

PositionZoneShapeTypeChoicePair::~PositionZoneShapeTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (PositionZoneShapeTypeType == SphericalZoneE)
    delete PositionZoneShapeTypeValue.SphericalZone;
  else if (PositionZoneShapeTypeType == DiametricalZoneE)
    delete PositionZoneShapeTypeValue.DiametricalZone;
  else if (PositionZoneShapeTypeType == NonDiametricalZoneE)
    delete PositionZoneShapeTypeValue.NonDiametricalZone;
  #endif
}

void PositionZoneShapeTypeChoicePair::printSelf(FILE * outFile)
{
  if (PositionZoneShapeTypeType == SphericalZoneE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SphericalZone");
      PositionZoneShapeTypeValue.SphericalZone->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SphericalZone>\n");
    }
  else if (PositionZoneShapeTypeType == DiametricalZoneE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DiametricalZone");
      PositionZoneShapeTypeValue.DiametricalZone->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DiametricalZone>\n");
    }
  else if (PositionZoneShapeTypeType == NonDiametricalZoneE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonDiametricalZone");
      PositionZoneShapeTypeValue.NonDiametricalZone->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NonDiametricalZone>\n");
    }
}

/* ***************************************************************** */

/* class PressureCharacteristicDefinitionBaseType

*/

PressureCharacteristicDefinitionBaseType::PressureCharacteristicDefinitionBaseType() :
  CharacteristicDefinitionBaseType()
{
  PressureCharacteristicDefinitionBaseTypePair = 0;
}

PressureCharacteristicDefinitionBaseType::PressureCharacteristicDefinitionBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 PressureCharacteristicDefinitionBaseTypeChoicePair * PressureCharacteristicDefinitionBaseTypePairIn) :
  CharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
  PressureCharacteristicDefinitionBaseTypePair = PressureCharacteristicDefinitionBaseTypePairIn;
}

PressureCharacteristicDefinitionBaseType::PressureCharacteristicDefinitionBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 PressureCharacteristicDefinitionBaseTypeChoicePair * PressureCharacteristicDefinitionBaseTypePairIn) :
  CharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
  PressureCharacteristicDefinitionBaseTypePair = PressureCharacteristicDefinitionBaseTypePairIn;
}

PressureCharacteristicDefinitionBaseType::~PressureCharacteristicDefinitionBaseType()
{
  #ifndef NODESTRUCT
  delete PressureCharacteristicDefinitionBaseTypePair;
  #endif
}

void PressureCharacteristicDefinitionBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  PressureCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}
PressureCharacteristicDefinitionBaseTypeChoicePair * PressureCharacteristicDefinitionBaseType::getPressureCharacteristicDefinitionBaseTypeChoicePair()
{return PressureCharacteristicDefinitionBaseTypePair;}

void PressureCharacteristicDefinitionBaseType::setPressureCharacteristicDefinitionBaseTypeChoicePair(PressureCharacteristicDefinitionBaseTypeChoicePair * PressureCharacteristicDefinitionBaseTypePairIn)
{PressureCharacteristicDefinitionBaseTypePair = PressureCharacteristicDefinitionBaseTypePairIn;}

/* ***************************************************************** */

PressureCharacteristicDefinitionBaseTypeChoicePair::PressureCharacteristicDefinitionBaseTypeChoicePair() {}

PressureCharacteristicDefinitionBaseTypeChoicePair::PressureCharacteristicDefinitionBaseTypeChoicePair(
 whichOne PressureCharacteristicDefinitionBaseTypeTypeIn,
 PressureCharacteristicDefinitionBaseTypeVal PressureCharacteristicDefinitionBaseTypeValueIn)
{
  PressureCharacteristicDefinitionBaseTypeType = PressureCharacteristicDefinitionBaseTypeTypeIn;
  PressureCharacteristicDefinitionBaseTypeValue = PressureCharacteristicDefinitionBaseTypeValueIn;
}

PressureCharacteristicDefinitionBaseTypeChoicePair::~PressureCharacteristicDefinitionBaseTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (PressureCharacteristicDefinitionBaseTypeType == ToleranceE)
    delete PressureCharacteristicDefinitionBaseTypeValue.Tolerance;
  else if (PressureCharacteristicDefinitionBaseTypeType == NonToleranceE)
    delete PressureCharacteristicDefinitionBaseTypeValue.NonTolerance;
  #endif
}

void PressureCharacteristicDefinitionBaseTypeChoicePair::printSelf(FILE * outFile)
{
  if (PressureCharacteristicDefinitionBaseTypeType == ToleranceE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Tolerance");
      PressureCharacteristicDefinitionBaseTypeValue.Tolerance->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Tolerance>\n");
    }
  else if (PressureCharacteristicDefinitionBaseTypeType == NonToleranceE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonTolerance");
      PressureCharacteristicDefinitionBaseTypeValue.NonTolerance->printSelf(outFile);
      fprintf(outFile, "</NonTolerance>\n");
    }
}

bool PressureCharacteristicDefinitionBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PressureCharacteristicDefinitionBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PressureCharacteristicDefinitionBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PressureCharacteristicDefinitionBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PressureCharacteristicDefinitionBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class PressureCharacteristicItemBaseType

*/

PressureCharacteristicItemBaseType::PressureCharacteristicItemBaseType() :
  CharacteristicItemBaseType()
{
}

PressureCharacteristicItemBaseType::PressureCharacteristicItemBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  CharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

PressureCharacteristicItemBaseType::PressureCharacteristicItemBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  CharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

PressureCharacteristicItemBaseType::~PressureCharacteristicItemBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void PressureCharacteristicItemBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool PressureCharacteristicItemBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PressureCharacteristicItemBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PressureCharacteristicItemBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PressureCharacteristicItemBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PressureCharacteristicItemBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class PressureCharacteristicMeasurementBaseType

*/

PressureCharacteristicMeasurementBaseType::PressureCharacteristicMeasurementBaseType() :
  CharacteristicMeasurementBaseType()
{
  Value = 0;
  MaxValue = 0;
  MinValue = 0;
}

PressureCharacteristicMeasurementBaseType::PressureCharacteristicMeasurementBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredPressureValueType * ValueIn,
 MeasuredPressureValueType * MaxValueIn,
 MeasuredPressureValueType * MinValueIn) :
  CharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  Value = ValueIn;
  MaxValue = MaxValueIn;
  MinValue = MinValueIn;
}

PressureCharacteristicMeasurementBaseType::PressureCharacteristicMeasurementBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredPressureValueType * ValueIn,
 MeasuredPressureValueType * MaxValueIn,
 MeasuredPressureValueType * MinValueIn) :
  CharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  Value = ValueIn;
  MaxValue = MaxValueIn;
  MinValue = MinValueIn;
}

PressureCharacteristicMeasurementBaseType::~PressureCharacteristicMeasurementBaseType()
{
  #ifndef NODESTRUCT
  delete Value;
  delete MaxValue;
  delete MinValue;
  #endif
}

void PressureCharacteristicMeasurementBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool PressureCharacteristicMeasurementBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PressureCharacteristicMeasurementBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PressureCharacteristicMeasurementBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PressureCharacteristicMeasurementBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PressureCharacteristicMeasurementBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredPressureValueType * PressureCharacteristicMeasurementBaseType::getValue()
{return Value;}

void PressureCharacteristicMeasurementBaseType::setValue(MeasuredPressureValueType * ValueIn)
{Value = ValueIn;}

MeasuredPressureValueType * PressureCharacteristicMeasurementBaseType::getMaxValue()
{return MaxValue;}

void PressureCharacteristicMeasurementBaseType::setMaxValue(MeasuredPressureValueType * MaxValueIn)
{MaxValue = MaxValueIn;}

MeasuredPressureValueType * PressureCharacteristicMeasurementBaseType::getMinValue()
{return MinValue;}

void PressureCharacteristicMeasurementBaseType::setMinValue(MeasuredPressureValueType * MinValueIn)
{MinValue = MinValueIn;}

/* ***************************************************************** */

/* class PressureCharacteristicNominalBaseType

*/

PressureCharacteristicNominalBaseType::PressureCharacteristicNominalBaseType() :
  CharacteristicNominalBaseType()
{
  TargetValue = 0;
}

PressureCharacteristicNominalBaseType::PressureCharacteristicNominalBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 PressureValueType * TargetValueIn) :
  CharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  TargetValue = TargetValueIn;
}

PressureCharacteristicNominalBaseType::PressureCharacteristicNominalBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 PressureValueType * TargetValueIn) :
  CharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  TargetValue = TargetValueIn;
}

PressureCharacteristicNominalBaseType::~PressureCharacteristicNominalBaseType()
{
  #ifndef NODESTRUCT
  delete TargetValue;
  #endif
}

void PressureCharacteristicNominalBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool PressureCharacteristicNominalBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PressureCharacteristicNominalBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PressureCharacteristicNominalBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PressureCharacteristicNominalBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PressureCharacteristicNominalBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

PressureValueType * PressureCharacteristicNominalBaseType::getTargetValue()
{return TargetValue;}

void PressureCharacteristicNominalBaseType::setTargetValue(PressureValueType * TargetValueIn)
{TargetValue = TargetValueIn;}

/* ***************************************************************** */

/* class ProfileCharacteristicDefinitionBaseType

*/

ProfileCharacteristicDefinitionBaseType::ProfileCharacteristicDefinitionBaseType() :
  GeometricCharacteristicDefinitionBaseType()
{
  ToleranceValue = 0;
  ToleranceDualValue = 0;
  ProfileCharacte_1056 = 0;
  OffsetZone = 0;
  VariableAngle = 0;
  SecondCompositeSegmentProfileDefinition = 0;
  ThirdCompositeSegmentProfileDefinition = 0;
  FourthCompositeSegmentProfileDefinition = 0;
  DatumReferenceFrameId = 0;
  OrientationOnly = 0;
}

ProfileCharacteristicDefinitionBaseType::ProfileCharacteristicDefinitionBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 ProfileCharacte_1056_Type * ProfileCharacte_1056In,
 XmlBoolean * OffsetZoneIn,
 XmlBoolean * VariableAngleIn,
 CompositeSegmentProfileDefinitionType * SecondCompositeSegmentProfileDefinitionIn,
 CompositeSegmentProfileDefinitionType * ThirdCompositeSegmentProfileDefinitionIn,
 CompositeSegmentProfileDefinitionType * FourthCompositeSegmentProfileDefinitionIn,
 QIFReferenceFullType * DatumReferenceFrameIdIn,
 XmlBoolean * OrientationOnlyIn) :
  GeometricCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn)
{
  ToleranceValue = ToleranceValueIn;
  ToleranceDualValue = ToleranceDualValueIn;
  ProfileCharacte_1056 = ProfileCharacte_1056In;
  OffsetZone = OffsetZoneIn;
  VariableAngle = VariableAngleIn;
  SecondCompositeSegmentProfileDefinition = SecondCompositeSegmentProfileDefinitionIn;
  ThirdCompositeSegmentProfileDefinition = ThirdCompositeSegmentProfileDefinitionIn;
  FourthCompositeSegmentProfileDefinition = FourthCompositeSegmentProfileDefinitionIn;
  DatumReferenceFrameId = DatumReferenceFrameIdIn;
  OrientationOnly = OrientationOnlyIn;
}

ProfileCharacteristicDefinitionBaseType::ProfileCharacteristicDefinitionBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 ProfileCharacte_1056_Type * ProfileCharacte_1056In,
 XmlBoolean * OffsetZoneIn,
 XmlBoolean * VariableAngleIn,
 CompositeSegmentProfileDefinitionType * SecondCompositeSegmentProfileDefinitionIn,
 CompositeSegmentProfileDefinitionType * ThirdCompositeSegmentProfileDefinitionIn,
 CompositeSegmentProfileDefinitionType * FourthCompositeSegmentProfileDefinitionIn,
 QIFReferenceFullType * DatumReferenceFrameIdIn,
 XmlBoolean * OrientationOnlyIn) :
  GeometricCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn)
{
  ToleranceValue = ToleranceValueIn;
  ToleranceDualValue = ToleranceDualValueIn;
  ProfileCharacte_1056 = ProfileCharacte_1056In;
  OffsetZone = OffsetZoneIn;
  VariableAngle = VariableAngleIn;
  SecondCompositeSegmentProfileDefinition = SecondCompositeSegmentProfileDefinitionIn;
  ThirdCompositeSegmentProfileDefinition = ThirdCompositeSegmentProfileDefinitionIn;
  FourthCompositeSegmentProfileDefinition = FourthCompositeSegmentProfileDefinitionIn;
  DatumReferenceFrameId = DatumReferenceFrameIdIn;
  OrientationOnly = OrientationOnlyIn;
}

ProfileCharacteristicDefinitionBaseType::~ProfileCharacteristicDefinitionBaseType()
{
  #ifndef NODESTRUCT
  delete ToleranceValue;
  delete ToleranceDualValue;
  delete ProfileCharacte_1056;
  delete OffsetZone;
  delete VariableAngle;
  delete SecondCompositeSegmentProfileDefinition;
  delete ThirdCompositeSegmentProfileDefinition;
  delete FourthCompositeSegmentProfileDefinition;
  delete DatumReferenceFrameId;
  delete OrientationOnly;
  #endif
}

void ProfileCharacteristicDefinitionBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (GeometricCharac_1050)
    {
  GeometricCharac_1050->printSelf(outFile);
    }
  if (DirectionFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DirectionFeature");
      DirectionFeature->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DirectionFeature>\n");
    }
  if (CollectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CollectionPlane");
      CollectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CollectionPlane>\n");
    }
  if (IntersectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IntersectionPlane");
      IntersectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</IntersectionPlane>\n");
    }
  if (OrientationPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OrientationPlane");
      OrientationPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OrientationPlane>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ToleranceValue");
  ToleranceValue->printSelf(outFile);
  fprintf(outFile, "</ToleranceValue>\n");
  if (ToleranceDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceDualValue");
      ToleranceDualValue->printSelf(outFile);
      fprintf(outFile, "</ToleranceDualValue>\n");
    }
  if (ProfileCharacte_1056)
    {
  ProfileCharacte_1056->printSelf(outFile);
    }
  if (OffsetZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OffsetZone");
      OffsetZone->printSelf(outFile);
      fprintf(outFile, "</OffsetZone>\n");
    }
  if (VariableAngle)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VariableAngle");
      VariableAngle->printSelf(outFile);
      fprintf(outFile, "</VariableAngle>\n");
    }
  if (SecondCompositeSegmentProfileDefinition)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SecondCompositeSegmentProfileDefinition");
      SecondCompositeSegmentProfileDefinition->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SecondCompositeSegmentProfileDefinition>\n");
    }
  if (ThirdCompositeSegmentProfileDefinition)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ThirdCompositeSegmentProfileDefinition");
      ThirdCompositeSegmentProfileDefinition->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ThirdCompositeSegmentProfileDefinition>\n");
    }
  if (FourthCompositeSegmentProfileDefinition)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FourthCompositeSegmentProfileDefinition");
      FourthCompositeSegmentProfileDefinition->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FourthCompositeSegmentProfileDefinition>\n");
    }
  if (DatumReferenceFrameId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumReferenceFrameId");
      DatumReferenceFrameId->printSelf(outFile);
      fprintf(outFile, "</DatumReferenceFrameId>\n");
    }
  if (OrientationOnly)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OrientationOnly");
      OrientationOnly->printSelf(outFile);
      fprintf(outFile, "</OrientationOnly>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ProfileCharacteristicDefinitionBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ProfileCharacteristicDefinitionBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ProfileCharacteristicDefinitionBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ProfileCharacteristicDefinitionBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ProfileCharacteristicDefinitionBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LinearValueType * ProfileCharacteristicDefinitionBaseType::getToleranceValue()
{return ToleranceValue;}

void ProfileCharacteristicDefinitionBaseType::setToleranceValue(LinearValueType * ToleranceValueIn)
{ToleranceValue = ToleranceValueIn;}

LinearDualValueType * ProfileCharacteristicDefinitionBaseType::getToleranceDualValue()
{return ToleranceDualValue;}

void ProfileCharacteristicDefinitionBaseType::setToleranceDualValue(LinearDualValueType * ToleranceDualValueIn)
{ToleranceDualValue = ToleranceDualValueIn;}

ProfileCharacte_1056_Type * ProfileCharacteristicDefinitionBaseType::getProfileCharacte_1056()
{return ProfileCharacte_1056;}

void ProfileCharacteristicDefinitionBaseType::setProfileCharacte_1056(ProfileCharacte_1056_Type * ProfileCharacte_1056In)
{ProfileCharacte_1056 = ProfileCharacte_1056In;}

XmlBoolean * ProfileCharacteristicDefinitionBaseType::getOffsetZone()
{return OffsetZone;}

void ProfileCharacteristicDefinitionBaseType::setOffsetZone(XmlBoolean * OffsetZoneIn)
{OffsetZone = OffsetZoneIn;}

XmlBoolean * ProfileCharacteristicDefinitionBaseType::getVariableAngle()
{return VariableAngle;}

void ProfileCharacteristicDefinitionBaseType::setVariableAngle(XmlBoolean * VariableAngleIn)
{VariableAngle = VariableAngleIn;}

CompositeSegmentProfileDefinitionType * ProfileCharacteristicDefinitionBaseType::getSecondCompositeSegmentProfileDefinition()
{return SecondCompositeSegmentProfileDefinition;}

void ProfileCharacteristicDefinitionBaseType::setSecondCompositeSegmentProfileDefinition(CompositeSegmentProfileDefinitionType * SecondCompositeSegmentProfileDefinitionIn)
{SecondCompositeSegmentProfileDefinition = SecondCompositeSegmentProfileDefinitionIn;}

CompositeSegmentProfileDefinitionType * ProfileCharacteristicDefinitionBaseType::getThirdCompositeSegmentProfileDefinition()
{return ThirdCompositeSegmentProfileDefinition;}

void ProfileCharacteristicDefinitionBaseType::setThirdCompositeSegmentProfileDefinition(CompositeSegmentProfileDefinitionType * ThirdCompositeSegmentProfileDefinitionIn)
{ThirdCompositeSegmentProfileDefinition = ThirdCompositeSegmentProfileDefinitionIn;}

CompositeSegmentProfileDefinitionType * ProfileCharacteristicDefinitionBaseType::getFourthCompositeSegmentProfileDefinition()
{return FourthCompositeSegmentProfileDefinition;}

void ProfileCharacteristicDefinitionBaseType::setFourthCompositeSegmentProfileDefinition(CompositeSegmentProfileDefinitionType * FourthCompositeSegmentProfileDefinitionIn)
{FourthCompositeSegmentProfileDefinition = FourthCompositeSegmentProfileDefinitionIn;}

QIFReferenceFullType * ProfileCharacteristicDefinitionBaseType::getDatumReferenceFrameId()
{return DatumReferenceFrameId;}

void ProfileCharacteristicDefinitionBaseType::setDatumReferenceFrameId(QIFReferenceFullType * DatumReferenceFrameIdIn)
{DatumReferenceFrameId = DatumReferenceFrameIdIn;}

XmlBoolean * ProfileCharacteristicDefinitionBaseType::getOrientationOnly()
{return OrientationOnly;}

void ProfileCharacteristicDefinitionBaseType::setOrientationOnly(XmlBoolean * OrientationOnlyIn)
{OrientationOnly = OrientationOnlyIn;}

/* ***************************************************************** */

/* class ProfileCharacteristicItemBaseType

*/

ProfileCharacteristicItemBaseType::ProfileCharacteristicItemBaseType() :
  GeometricCharacteristicItemBaseType()
{
}

ProfileCharacteristicItemBaseType::ProfileCharacteristicItemBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  GeometricCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

ProfileCharacteristicItemBaseType::ProfileCharacteristicItemBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  GeometricCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

ProfileCharacteristicItemBaseType::~ProfileCharacteristicItemBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void ProfileCharacteristicItemBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool ProfileCharacteristicItemBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ProfileCharacteristicItemBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ProfileCharacteristicItemBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ProfileCharacteristicItemBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ProfileCharacteristicItemBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class ProfileCharacteristicMeasurementBaseType

*/

ProfileCharacteristicMeasurementBaseType::ProfileCharacteristicMeasurementBaseType() :
  GeometricCharacteristicMeasurementBaseType()
{
  WorstPositiveDeviation = 0;
  WorstNegativeDeviation = 0;
  PointDeviations = 0;
  DatumsOk = 0;
  DRFTransformActualId = 0;
  SecondCompositeSegmentProfileMeasurement = 0;
  ThirdCompositeSegmentProfileMeasurement = 0;
  FourthCompositeSegmentProfileMeasurement = 0;
}

ProfileCharacteristicMeasurementBaseType::ProfileCharacteristicMeasurementBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 LinearValueType * WorstPositiveDeviationIn,
 LinearValueType * WorstNegativeDeviationIn,
 PointDeviationsType * PointDeviationsIn,
 XmlBoolean * DatumsOkIn,
 QIFReferenceType * DRFTransformActualIdIn,
 CompositeSegmentProfileMeasurementType * SecondCompositeSegmentProfileMeasurementIn,
 CompositeSegmentProfileMeasurementType * ThirdCompositeSegmentProfileMeasurementIn,
 CompositeSegmentProfileMeasurementType * FourthCompositeSegmentProfileMeasurementIn) :
  GeometricCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
  WorstPositiveDeviation = WorstPositiveDeviationIn;
  WorstNegativeDeviation = WorstNegativeDeviationIn;
  PointDeviations = PointDeviationsIn;
  DatumsOk = DatumsOkIn;
  DRFTransformActualId = DRFTransformActualIdIn;
  SecondCompositeSegmentProfileMeasurement = SecondCompositeSegmentProfileMeasurementIn;
  ThirdCompositeSegmentProfileMeasurement = ThirdCompositeSegmentProfileMeasurementIn;
  FourthCompositeSegmentProfileMeasurement = FourthCompositeSegmentProfileMeasurementIn;
}

ProfileCharacteristicMeasurementBaseType::ProfileCharacteristicMeasurementBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 LinearValueType * WorstPositiveDeviationIn,
 LinearValueType * WorstNegativeDeviationIn,
 PointDeviationsType * PointDeviationsIn,
 XmlBoolean * DatumsOkIn,
 QIFReferenceType * DRFTransformActualIdIn,
 CompositeSegmentProfileMeasurementType * SecondCompositeSegmentProfileMeasurementIn,
 CompositeSegmentProfileMeasurementType * ThirdCompositeSegmentProfileMeasurementIn,
 CompositeSegmentProfileMeasurementType * FourthCompositeSegmentProfileMeasurementIn) :
  GeometricCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
  WorstPositiveDeviation = WorstPositiveDeviationIn;
  WorstNegativeDeviation = WorstNegativeDeviationIn;
  PointDeviations = PointDeviationsIn;
  DatumsOk = DatumsOkIn;
  DRFTransformActualId = DRFTransformActualIdIn;
  SecondCompositeSegmentProfileMeasurement = SecondCompositeSegmentProfileMeasurementIn;
  ThirdCompositeSegmentProfileMeasurement = ThirdCompositeSegmentProfileMeasurementIn;
  FourthCompositeSegmentProfileMeasurement = FourthCompositeSegmentProfileMeasurementIn;
}

ProfileCharacteristicMeasurementBaseType::~ProfileCharacteristicMeasurementBaseType()
{
  #ifndef NODESTRUCT
  delete WorstPositiveDeviation;
  delete WorstNegativeDeviation;
  delete PointDeviations;
  delete DatumsOk;
  delete DRFTransformActualId;
  delete SecondCompositeSegmentProfileMeasurement;
  delete ThirdCompositeSegmentProfileMeasurement;
  delete FourthCompositeSegmentProfileMeasurement;
  #endif
}

void ProfileCharacteristicMeasurementBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  if (WorstPositiveDeviation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WorstPositiveDeviation");
      WorstPositiveDeviation->printSelf(outFile);
      fprintf(outFile, "</WorstPositiveDeviation>\n");
    }
  if (WorstNegativeDeviation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WorstNegativeDeviation");
      WorstNegativeDeviation->printSelf(outFile);
      fprintf(outFile, "</WorstNegativeDeviation>\n");
    }
  if (PointDeviations)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointDeviations");
      PointDeviations->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointDeviations>\n");
    }
  if (DatumsOk)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumsOk");
      DatumsOk->printSelf(outFile);
      fprintf(outFile, "</DatumsOk>\n");
    }
  if (DRFTransformActualId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DRFTransformActualId");
      DRFTransformActualId->printSelf(outFile);
      fprintf(outFile, "</DRFTransformActualId>\n");
    }
  if (SecondCompositeSegmentProfileMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SecondCompositeSegmentProfileMeasurement");
      SecondCompositeSegmentProfileMeasurement->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SecondCompositeSegmentProfileMeasurement>\n");
    }
  if (ThirdCompositeSegmentProfileMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ThirdCompositeSegmentProfileMeasurement");
      ThirdCompositeSegmentProfileMeasurement->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ThirdCompositeSegmentProfileMeasurement>\n");
    }
  if (FourthCompositeSegmentProfileMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FourthCompositeSegmentProfileMeasurement");
      FourthCompositeSegmentProfileMeasurement->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FourthCompositeSegmentProfileMeasurement>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ProfileCharacteristicMeasurementBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ProfileCharacteristicMeasurementBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ProfileCharacteristicMeasurementBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ProfileCharacteristicMeasurementBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ProfileCharacteristicMeasurementBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LinearValueType * ProfileCharacteristicMeasurementBaseType::getWorstPositiveDeviation()
{return WorstPositiveDeviation;}

void ProfileCharacteristicMeasurementBaseType::setWorstPositiveDeviation(LinearValueType * WorstPositiveDeviationIn)
{WorstPositiveDeviation = WorstPositiveDeviationIn;}

LinearValueType * ProfileCharacteristicMeasurementBaseType::getWorstNegativeDeviation()
{return WorstNegativeDeviation;}

void ProfileCharacteristicMeasurementBaseType::setWorstNegativeDeviation(LinearValueType * WorstNegativeDeviationIn)
{WorstNegativeDeviation = WorstNegativeDeviationIn;}

PointDeviationsType * ProfileCharacteristicMeasurementBaseType::getPointDeviations()
{return PointDeviations;}

void ProfileCharacteristicMeasurementBaseType::setPointDeviations(PointDeviationsType * PointDeviationsIn)
{PointDeviations = PointDeviationsIn;}

XmlBoolean * ProfileCharacteristicMeasurementBaseType::getDatumsOk()
{return DatumsOk;}

void ProfileCharacteristicMeasurementBaseType::setDatumsOk(XmlBoolean * DatumsOkIn)
{DatumsOk = DatumsOkIn;}

QIFReferenceType * ProfileCharacteristicMeasurementBaseType::getDRFTransformActualId()
{return DRFTransformActualId;}

void ProfileCharacteristicMeasurementBaseType::setDRFTransformActualId(QIFReferenceType * DRFTransformActualIdIn)
{DRFTransformActualId = DRFTransformActualIdIn;}

CompositeSegmentProfileMeasurementType * ProfileCharacteristicMeasurementBaseType::getSecondCompositeSegmentProfileMeasurement()
{return SecondCompositeSegmentProfileMeasurement;}

void ProfileCharacteristicMeasurementBaseType::setSecondCompositeSegmentProfileMeasurement(CompositeSegmentProfileMeasurementType * SecondCompositeSegmentProfileMeasurementIn)
{SecondCompositeSegmentProfileMeasurement = SecondCompositeSegmentProfileMeasurementIn;}

CompositeSegmentProfileMeasurementType * ProfileCharacteristicMeasurementBaseType::getThirdCompositeSegmentProfileMeasurement()
{return ThirdCompositeSegmentProfileMeasurement;}

void ProfileCharacteristicMeasurementBaseType::setThirdCompositeSegmentProfileMeasurement(CompositeSegmentProfileMeasurementType * ThirdCompositeSegmentProfileMeasurementIn)
{ThirdCompositeSegmentProfileMeasurement = ThirdCompositeSegmentProfileMeasurementIn;}

CompositeSegmentProfileMeasurementType * ProfileCharacteristicMeasurementBaseType::getFourthCompositeSegmentProfileMeasurement()
{return FourthCompositeSegmentProfileMeasurement;}

void ProfileCharacteristicMeasurementBaseType::setFourthCompositeSegmentProfileMeasurement(CompositeSegmentProfileMeasurementType * FourthCompositeSegmentProfileMeasurementIn)
{FourthCompositeSegmentProfileMeasurement = FourthCompositeSegmentProfileMeasurementIn;}

/* ***************************************************************** */

/* class ProfileCharacteristicNominalBaseType

*/

ProfileCharacteristicNominalBaseType::ProfileCharacteristicNominalBaseType() :
  GeometricCharacteristicNominalBaseType()
{
  TargetValue = 0;
}

ProfileCharacteristicNominalBaseType::ProfileCharacteristicNominalBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn) :
  GeometricCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  TargetValue = TargetValueIn;
}

ProfileCharacteristicNominalBaseType::ProfileCharacteristicNominalBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn) :
  GeometricCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  TargetValue = TargetValueIn;
}

ProfileCharacteristicNominalBaseType::~ProfileCharacteristicNominalBaseType()
{
  #ifndef NODESTRUCT
  delete TargetValue;
  #endif
}

void ProfileCharacteristicNominalBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ProfileCharacteristicNominalBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ProfileCharacteristicNominalBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ProfileCharacteristicNominalBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ProfileCharacteristicNominalBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ProfileCharacteristicNominalBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LinearValueType * ProfileCharacteristicNominalBaseType::getTargetValue()
{return TargetValue;}

void ProfileCharacteristicNominalBaseType::setTargetValue(LinearValueType * TargetValueIn)
{TargetValue = TargetValueIn;}

/* ***************************************************************** */

/* class RadiusCharacteristicDefinitionType

*/

RadiusCharacteristicDefinitionType::RadiusCharacteristicDefinitionType() :
  LinearCharacteristicDefinitionBaseType()
{
  ControlledRadius = 0;
}

RadiusCharacteristicDefinitionType::RadiusCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseTypePairIn,
 XmlBoolean * ControlledRadiusIn) :
  LinearCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    LinearCharacteristicDefinitionBaseTypePairIn)
{
  ControlledRadius = ControlledRadiusIn;
}

RadiusCharacteristicDefinitionType::RadiusCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseTypePairIn,
 XmlBoolean * ControlledRadiusIn) :
  LinearCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    LinearCharacteristicDefinitionBaseTypePairIn)
{
  ControlledRadius = ControlledRadiusIn;
}

RadiusCharacteristicDefinitionType::~RadiusCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  delete ControlledRadius;
  #endif
}

void RadiusCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (DimensionType)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionType");
      DimensionType->printSelf(outFile);
      fprintf(outFile, "</DimensionType>\n");
    }
  if (DimensionModifiers)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionModifiers");
      DimensionModifiers->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DimensionModifiers>\n");
    }
  LinearCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  if (ControlledRadius)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ControlledRadius");
      ControlledRadius->printSelf(outFile);
      fprintf(outFile, "</ControlledRadius>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool RadiusCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in RadiusCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in RadiusCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in RadiusCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in RadiusCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

XmlBoolean * RadiusCharacteristicDefinitionType::getControlledRadius()
{return ControlledRadius;}

void RadiusCharacteristicDefinitionType::setControlledRadius(XmlBoolean * ControlledRadiusIn)
{ControlledRadius = ControlledRadiusIn;}

/* ***************************************************************** */

/* class RadiusCharacteristicItemType

*/

RadiusCharacteristicItemType::RadiusCharacteristicItemType() :
  LinearCharacteristicItemBaseType()
{
}

RadiusCharacteristicItemType::RadiusCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LinearCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

RadiusCharacteristicItemType::RadiusCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LinearCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

RadiusCharacteristicItemType::~RadiusCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void RadiusCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool RadiusCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in RadiusCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in RadiusCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in RadiusCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in RadiusCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class RadiusCharacteristicMeasurementType

*/

RadiusCharacteristicMeasurementType::RadiusCharacteristicMeasurementType() :
  LinearCharacteristicMeasurementBaseType()
{
}

RadiusCharacteristicMeasurementType::RadiusCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  LinearCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

RadiusCharacteristicMeasurementType::RadiusCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  LinearCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

RadiusCharacteristicMeasurementType::~RadiusCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void RadiusCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool RadiusCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in RadiusCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in RadiusCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in RadiusCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in RadiusCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class RadiusCharacteristicNominalType

*/

RadiusCharacteristicNominalType::RadiusCharacteristicNominalType() :
  LinearCharacteristicNominalBaseType()
{
}

RadiusCharacteristicNominalType::RadiusCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn) :
  LinearCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn,
    TargetDualValueIn)
{
}

RadiusCharacteristicNominalType::RadiusCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn) :
  LinearCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn,
    TargetDualValueIn)
{
}

RadiusCharacteristicNominalType::~RadiusCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void RadiusCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  if (TargetDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetDualValue");
      TargetDualValue->printSelf(outFile);
      fprintf(outFile, "</TargetDualValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool RadiusCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in RadiusCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in RadiusCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in RadiusCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in RadiusCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class ReferenceFeatureAssociationSpecificationElementEnumType

*/

ReferenceFeatureAssociationSpecificationElementEnumType::ReferenceFeatureAssociationSpecificationElementEnumType() :
  XmlNMTOKEN()
{
}

ReferenceFeatureAssociationSpecificationElementEnumType::ReferenceFeatureAssociationSpecificationElementEnumType(
 const char * valIn) :
  XmlNMTOKEN(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "C") &&
           strcmp(val.c_str(), "CE") &&
           strcmp(val.c_str(), "CI") &&
           strcmp(val.c_str(), "G") &&
           strcmp(val.c_str(), "GE") &&
           strcmp(val.c_str(), "GI") &&
           strcmp(val.c_str(), "N") &&
           strcmp(val.c_str(), "X"));
}

ReferenceFeatureAssociationSpecificationElementEnumType::~ReferenceFeatureAssociationSpecificationElementEnumType() {}

bool ReferenceFeatureAssociationSpecificationElementEnumType::ReferenceFeatureAssociationSpecificationElementEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "C") &&
          strcmp(val.c_str(), "CE") &&
          strcmp(val.c_str(), "CI") &&
          strcmp(val.c_str(), "G") &&
          strcmp(val.c_str(), "GE") &&
          strcmp(val.c_str(), "GI") &&
          strcmp(val.c_str(), "N") &&
          strcmp(val.c_str(), "X"));
}

void ReferenceFeatureAssociationSpecificationElementEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "ReferenceFeatureAssociationSpecificationElementEnumType");
}

void ReferenceFeatureAssociationSpecificationElementEnumType::printSelf(FILE * outFile)
{
  if (ReferenceFeatureAssociationSpecificationElementEnumTypeIsBad())
    {
      fprintf(stderr, "bad ReferenceFeatureAssociationSpecificationElementEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::printSelf(outFile);
}

void ReferenceFeatureAssociationSpecificationElementEnumType::oPrintSelf(FILE * outFile)
{
  if (ReferenceFeatureAssociationSpecificationElementEnumTypeIsBad())
    {
      fprintf(stderr, "bad ReferenceFeatureAssociationSpecificationElementEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class ReferenceFeatureAssociationSpecificationElementType

*/

ReferenceFeatureAssociationSpecificationElementType::ReferenceFeatureAssociationSpecificationElementType()
{
  Filter = 0;
  Association = 0;
  Parameter = 0;
}

ReferenceFeatureAssociationSpecificationElementType::ReferenceFeatureAssociationSpecificationElementType(
 FilterType * FilterIn,
 ReferenceFeatureAssociationSpecificationElementEnumType * AssociationIn,
 ReferenceFeatureAssociationSpecificationParameterEnumType * ParameterIn)
{
  Filter = FilterIn;
  Association = AssociationIn;
  Parameter = ParameterIn;
}

ReferenceFeatureAssociationSpecificationElementType::~ReferenceFeatureAssociationSpecificationElementType()
{
  #ifndef NODESTRUCT
  delete Filter;
  delete Association;
  delete Parameter;
  #endif
}

void ReferenceFeatureAssociationSpecificationElementType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Filter)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Filter");
      Filter->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Filter>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Association");
  Association->printSelf(outFile);
  fprintf(outFile, "</Association>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Parameter");
  Parameter->printSelf(outFile);
  fprintf(outFile, "</Parameter>\n");
  doSpaces(-INDENT, outFile);
}

FilterType * ReferenceFeatureAssociationSpecificationElementType::getFilter()
{return Filter;}

void ReferenceFeatureAssociationSpecificationElementType::setFilter(FilterType * FilterIn)
{Filter = FilterIn;}

ReferenceFeatureAssociationSpecificationElementEnumType * ReferenceFeatureAssociationSpecificationElementType::getAssociation()
{return Association;}

void ReferenceFeatureAssociationSpecificationElementType::setAssociation(ReferenceFeatureAssociationSpecificationElementEnumType * AssociationIn)
{Association = AssociationIn;}

ReferenceFeatureAssociationSpecificationParameterEnumType * ReferenceFeatureAssociationSpecificationElementType::getParameter()
{return Parameter;}

void ReferenceFeatureAssociationSpecificationElementType::setParameter(ReferenceFeatureAssociationSpecificationParameterEnumType * ParameterIn)
{Parameter = ParameterIn;}

/* ***************************************************************** */

/* class ReferenceFeatureAssociationSpecificationParameterEnumType

*/

ReferenceFeatureAssociationSpecificationParameterEnumType::ReferenceFeatureAssociationSpecificationParameterEnumType() :
  XmlNMTOKEN()
{
}

ReferenceFeatureAssociationSpecificationParameterEnumType::ReferenceFeatureAssociationSpecificationParameterEnumType(
 const char * valIn) :
  XmlNMTOKEN(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "P") &&
           strcmp(val.c_str(), "V") &&
           strcmp(val.c_str(), "T") &&
           strcmp(val.c_str(), "Q"));
}

ReferenceFeatureAssociationSpecificationParameterEnumType::~ReferenceFeatureAssociationSpecificationParameterEnumType() {}

bool ReferenceFeatureAssociationSpecificationParameterEnumType::ReferenceFeatureAssociationSpecificationParameterEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "P") &&
          strcmp(val.c_str(), "V") &&
          strcmp(val.c_str(), "T") &&
          strcmp(val.c_str(), "Q"));
}

void ReferenceFeatureAssociationSpecificationParameterEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "ReferenceFeatureAssociationSpecificationParameterEnumType");
}

void ReferenceFeatureAssociationSpecificationParameterEnumType::printSelf(FILE * outFile)
{
  if (ReferenceFeatureAssociationSpecificationParameterEnumTypeIsBad())
    {
      fprintf(stderr, "bad ReferenceFeatureAssociationSpecificationParameterEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::printSelf(outFile);
}

void ReferenceFeatureAssociationSpecificationParameterEnumType::oPrintSelf(FILE * outFile)
{
  if (ReferenceFeatureAssociationSpecificationParameterEnumTypeIsBad())
    {
      fprintf(stderr, "bad ReferenceFeatureAssociationSpecificationParameterEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class RoughnessApplicabilityEnumType

*/

RoughnessApplicabilityEnumType::RoughnessApplicabilityEnumType() :
  XmlNMTOKEN()
{
}

RoughnessApplicabilityEnumType::RoughnessApplicabilityEnumType(
 const char * valIn) :
  XmlNMTOKEN(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "UNSUPPORTED") &&
           strcmp(val.c_str(), "SPECIFIED_SURFACE_ONLY") &&
           strcmp(val.c_str(), "ALL_PART_SURFACES") &&
           strcmp(val.c_str(), "BASIC_SURFACE"));
}

RoughnessApplicabilityEnumType::~RoughnessApplicabilityEnumType() {}

bool RoughnessApplicabilityEnumType::RoughnessApplicabilityEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "UNSUPPORTED") &&
          strcmp(val.c_str(), "SPECIFIED_SURFACE_ONLY") &&
          strcmp(val.c_str(), "ALL_PART_SURFACES") &&
          strcmp(val.c_str(), "BASIC_SURFACE"));
}

void RoughnessApplicabilityEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "RoughnessApplicabilityEnumType");
}

void RoughnessApplicabilityEnumType::printSelf(FILE * outFile)
{
  if (RoughnessApplicabilityEnumTypeIsBad())
    {
      fprintf(stderr, "bad RoughnessApplicabilityEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::printSelf(outFile);
}

void RoughnessApplicabilityEnumType::oPrintSelf(FILE * outFile)
{
  if (RoughnessApplicabilityEnumTypeIsBad())
    {
      fprintf(stderr, "bad RoughnessApplicabilityEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class RoughnessLayEnumType

*/

RoughnessLayEnumType::RoughnessLayEnumType() :
  XmlNMTOKEN()
{
}

RoughnessLayEnumType::RoughnessLayEnumType(
 const char * valIn) :
  XmlNMTOKEN(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "PARALLEL") &&
           strcmp(val.c_str(), "PERPENDICULAR") &&
           strcmp(val.c_str(), "CROSS_HATCH") &&
           strcmp(val.c_str(), "MULTI_DIRECTIONAL") &&
           strcmp(val.c_str(), "CIRCULAR") &&
           strcmp(val.c_str(), "RADIAL") &&
           strcmp(val.c_str(), "PARTICULATE"));
}

RoughnessLayEnumType::~RoughnessLayEnumType() {}

bool RoughnessLayEnumType::RoughnessLayEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "PARALLEL") &&
          strcmp(val.c_str(), "PERPENDICULAR") &&
          strcmp(val.c_str(), "CROSS_HATCH") &&
          strcmp(val.c_str(), "MULTI_DIRECTIONAL") &&
          strcmp(val.c_str(), "CIRCULAR") &&
          strcmp(val.c_str(), "RADIAL") &&
          strcmp(val.c_str(), "PARTICULATE"));
}

void RoughnessLayEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "RoughnessLayEnumType");
}

void RoughnessLayEnumType::printSelf(FILE * outFile)
{
  if (RoughnessLayEnumTypeIsBad())
    {
      fprintf(stderr, "bad RoughnessLayEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::printSelf(outFile);
}

void RoughnessLayEnumType::oPrintSelf(FILE * outFile)
{
  if (RoughnessLayEnumTypeIsBad())
    {
      fprintf(stderr, "bad RoughnessLayEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class RoughnessObtentionEnumType

*/

RoughnessObtentionEnumType::RoughnessObtentionEnumType() :
  XmlNMTOKEN()
{
}

RoughnessObtentionEnumType::RoughnessObtentionEnumType(
 const char * valIn) :
  XmlNMTOKEN(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "UNDEFINED") &&
           strcmp(val.c_str(), "UNSUPPORTED") &&
           strcmp(val.c_str(), "MACHINING_MANDATORY") &&
           strcmp(val.c_str(), "MACHINING_FORBIDDEN"));
}

RoughnessObtentionEnumType::~RoughnessObtentionEnumType() {}

bool RoughnessObtentionEnumType::RoughnessObtentionEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "UNDEFINED") &&
          strcmp(val.c_str(), "UNSUPPORTED") &&
          strcmp(val.c_str(), "MACHINING_MANDATORY") &&
          strcmp(val.c_str(), "MACHINING_FORBIDDEN"));
}

void RoughnessObtentionEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "RoughnessObtentionEnumType");
}

void RoughnessObtentionEnumType::printSelf(FILE * outFile)
{
  if (RoughnessObtentionEnumTypeIsBad())
    {
      fprintf(stderr, "bad RoughnessObtentionEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::printSelf(outFile);
}

void RoughnessObtentionEnumType::oPrintSelf(FILE * outFile)
{
  if (RoughnessObtentionEnumTypeIsBad())
    {
      fprintf(stderr, "bad RoughnessObtentionEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class RunoutCharacteristicDefinitionBaseType

*/

RunoutCharacteristicDefinitionBaseType::RunoutCharacteristicDefinitionBaseType() :
  GeometricCharacteristicDefinitionBaseType()
{
  ToleranceValue = 0;
  ToleranceDualValue = 0;
  DatumReferenceFrameId = 0;
}

RunoutCharacteristicDefinitionBaseType::RunoutCharacteristicDefinitionBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 QIFReferenceFullType * DatumReferenceFrameIdIn) :
  GeometricCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn)
{
  ToleranceValue = ToleranceValueIn;
  ToleranceDualValue = ToleranceDualValueIn;
  DatumReferenceFrameId = DatumReferenceFrameIdIn;
}

RunoutCharacteristicDefinitionBaseType::RunoutCharacteristicDefinitionBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 QIFReferenceFullType * DatumReferenceFrameIdIn) :
  GeometricCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn)
{
  ToleranceValue = ToleranceValueIn;
  ToleranceDualValue = ToleranceDualValueIn;
  DatumReferenceFrameId = DatumReferenceFrameIdIn;
}

RunoutCharacteristicDefinitionBaseType::~RunoutCharacteristicDefinitionBaseType()
{
  #ifndef NODESTRUCT
  delete ToleranceValue;
  delete ToleranceDualValue;
  delete DatumReferenceFrameId;
  #endif
}

void RunoutCharacteristicDefinitionBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (GeometricCharac_1050)
    {
  GeometricCharac_1050->printSelf(outFile);
    }
  if (DirectionFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DirectionFeature");
      DirectionFeature->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DirectionFeature>\n");
    }
  if (CollectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CollectionPlane");
      CollectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CollectionPlane>\n");
    }
  if (IntersectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IntersectionPlane");
      IntersectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</IntersectionPlane>\n");
    }
  if (OrientationPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OrientationPlane");
      OrientationPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OrientationPlane>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ToleranceValue");
  ToleranceValue->printSelf(outFile);
  fprintf(outFile, "</ToleranceValue>\n");
  if (ToleranceDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceDualValue");
      ToleranceDualValue->printSelf(outFile);
      fprintf(outFile, "</ToleranceDualValue>\n");
    }
  if (DatumReferenceFrameId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumReferenceFrameId");
      DatumReferenceFrameId->printSelf(outFile);
      fprintf(outFile, "</DatumReferenceFrameId>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool RunoutCharacteristicDefinitionBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in RunoutCharacteristicDefinitionBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in RunoutCharacteristicDefinitionBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in RunoutCharacteristicDefinitionBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in RunoutCharacteristicDefinitionBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LinearValueType * RunoutCharacteristicDefinitionBaseType::getToleranceValue()
{return ToleranceValue;}

void RunoutCharacteristicDefinitionBaseType::setToleranceValue(LinearValueType * ToleranceValueIn)
{ToleranceValue = ToleranceValueIn;}

LinearDualValueType * RunoutCharacteristicDefinitionBaseType::getToleranceDualValue()
{return ToleranceDualValue;}

void RunoutCharacteristicDefinitionBaseType::setToleranceDualValue(LinearDualValueType * ToleranceDualValueIn)
{ToleranceDualValue = ToleranceDualValueIn;}

QIFReferenceFullType * RunoutCharacteristicDefinitionBaseType::getDatumReferenceFrameId()
{return DatumReferenceFrameId;}

void RunoutCharacteristicDefinitionBaseType::setDatumReferenceFrameId(QIFReferenceFullType * DatumReferenceFrameIdIn)
{DatumReferenceFrameId = DatumReferenceFrameIdIn;}

/* ***************************************************************** */

/* class RunoutCharacteristicItemBaseType

*/

RunoutCharacteristicItemBaseType::RunoutCharacteristicItemBaseType() :
  GeometricCharacteristicItemBaseType()
{
}

RunoutCharacteristicItemBaseType::RunoutCharacteristicItemBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  GeometricCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

RunoutCharacteristicItemBaseType::RunoutCharacteristicItemBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  GeometricCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

RunoutCharacteristicItemBaseType::~RunoutCharacteristicItemBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void RunoutCharacteristicItemBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool RunoutCharacteristicItemBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in RunoutCharacteristicItemBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in RunoutCharacteristicItemBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in RunoutCharacteristicItemBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in RunoutCharacteristicItemBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class RunoutCharacteristicMeasurementBaseType

*/

RunoutCharacteristicMeasurementBaseType::RunoutCharacteristicMeasurementBaseType() :
  GeometricCharacteristicMeasurementBaseType()
{
  DatumsOk = 0;
}

RunoutCharacteristicMeasurementBaseType::RunoutCharacteristicMeasurementBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 XmlBoolean * DatumsOkIn) :
  GeometricCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
  DatumsOk = DatumsOkIn;
}

RunoutCharacteristicMeasurementBaseType::RunoutCharacteristicMeasurementBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 XmlBoolean * DatumsOkIn) :
  GeometricCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
  DatumsOk = DatumsOkIn;
}

RunoutCharacteristicMeasurementBaseType::~RunoutCharacteristicMeasurementBaseType()
{
  #ifndef NODESTRUCT
  delete DatumsOk;
  #endif
}

void RunoutCharacteristicMeasurementBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  if (DatumsOk)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumsOk");
      DatumsOk->printSelf(outFile);
      fprintf(outFile, "</DatumsOk>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool RunoutCharacteristicMeasurementBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in RunoutCharacteristicMeasurementBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in RunoutCharacteristicMeasurementBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in RunoutCharacteristicMeasurementBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in RunoutCharacteristicMeasurementBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

XmlBoolean * RunoutCharacteristicMeasurementBaseType::getDatumsOk()
{return DatumsOk;}

void RunoutCharacteristicMeasurementBaseType::setDatumsOk(XmlBoolean * DatumsOkIn)
{DatumsOk = DatumsOkIn;}

/* ***************************************************************** */

/* class RunoutCharacteristicNominalBaseType

*/

RunoutCharacteristicNominalBaseType::RunoutCharacteristicNominalBaseType() :
  GeometricCharacteristicNominalBaseType()
{
}

RunoutCharacteristicNominalBaseType::RunoutCharacteristicNominalBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  GeometricCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

RunoutCharacteristicNominalBaseType::RunoutCharacteristicNominalBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  GeometricCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

RunoutCharacteristicNominalBaseType::~RunoutCharacteristicNominalBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void RunoutCharacteristicNominalBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool RunoutCharacteristicNominalBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in RunoutCharacteristicNominalBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in RunoutCharacteristicNominalBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in RunoutCharacteristicNominalBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in RunoutCharacteristicNominalBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class SimultaneousRequirementEnumType

*/

SimultaneousRequirementEnumType::SimultaneousRequirementEnumType() :
  XmlNMTOKEN()
{
}

SimultaneousRequirementEnumType::SimultaneousRequirementEnumType(
 const char * valIn) :
  XmlNMTOKEN(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "SEP_REQ") &&
           strcmp(val.c_str(), "SIM_REQ"));
}

SimultaneousRequirementEnumType::~SimultaneousRequirementEnumType() {}

bool SimultaneousRequirementEnumType::SimultaneousRequirementEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "SEP_REQ") &&
          strcmp(val.c_str(), "SIM_REQ"));
}

void SimultaneousRequirementEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "SimultaneousRequirementEnumType");
}

void SimultaneousRequirementEnumType::printSelf(FILE * outFile)
{
  if (SimultaneousRequirementEnumTypeIsBad())
    {
      fprintf(stderr, "bad SimultaneousRequirementEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::printSelf(outFile);
}

void SimultaneousRequirementEnumType::oPrintSelf(FILE * outFile)
{
  if (SimultaneousRequirementEnumTypeIsBad())
    {
      fprintf(stderr, "bad SimultaneousRequirementEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class SimultaneousRequirementGroupType

*/

SimultaneousRequirementGroupType::SimultaneousRequirementGroupType()
{
  CharacteristicNominalIds = 0;
  Requirement = 0;
  CompositeLevel = 0;
}

SimultaneousRequirementGroupType::SimultaneousRequirementGroupType(
 ArrayReferenceType * CharacteristicNominalIdsIn,
 SimultaneousRequirementEnumType * RequirementIn,
 CompositeSegmentLowerLevelEnumType * CompositeLevelIn)
{
  CharacteristicNominalIds = CharacteristicNominalIdsIn;
  Requirement = RequirementIn;
  CompositeLevel = CompositeLevelIn;
}

SimultaneousRequirementGroupType::~SimultaneousRequirementGroupType()
{
  #ifndef NODESTRUCT
  delete CharacteristicNominalIds;
  delete Requirement;
  delete CompositeLevel;
  #endif
}

void SimultaneousRequirementGroupType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalIds");
  CharacteristicNominalIds->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</CharacteristicNominalIds>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Requirement");
  Requirement->printSelf(outFile);
  fprintf(outFile, "</Requirement>\n");
  if (CompositeLevel)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CompositeLevel");
      CompositeLevel->printSelf(outFile);
      fprintf(outFile, "</CompositeLevel>\n");
    }
  doSpaces(-INDENT, outFile);
}

ArrayReferenceType * SimultaneousRequirementGroupType::getCharacteristicNominalIds()
{return CharacteristicNominalIds;}

void SimultaneousRequirementGroupType::setCharacteristicNominalIds(ArrayReferenceType * CharacteristicNominalIdsIn)
{CharacteristicNominalIds = CharacteristicNominalIdsIn;}

SimultaneousRequirementEnumType * SimultaneousRequirementGroupType::getRequirement()
{return Requirement;}

void SimultaneousRequirementGroupType::setRequirement(SimultaneousRequirementEnumType * RequirementIn)
{Requirement = RequirementIn;}

CompositeSegmentLowerLevelEnumType * SimultaneousRequirementGroupType::getCompositeLevel()
{return CompositeLevel;}

void SimultaneousRequirementGroupType::setCompositeLevel(CompositeSegmentLowerLevelEnumType * CompositeLevelIn)
{CompositeLevel = CompositeLevelIn;}

/* ***************************************************************** */

/* class SimultaneousRequirementGroupTypeLisd

*/

SimultaneousRequirementGroupTypeLisd::SimultaneousRequirementGroupTypeLisd() {}

SimultaneousRequirementGroupTypeLisd::SimultaneousRequirementGroupTypeLisd(SimultaneousRequirementGroupType * aSimultaneousRequirementGroupType)
{
  push_back(aSimultaneousRequirementGroupType);
}

SimultaneousRequirementGroupTypeLisd::~SimultaneousRequirementGroupTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<SimultaneousRequirementGroupType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void SimultaneousRequirementGroupTypeLisd::printSelf(FILE * outFile)
{
  std::list<SimultaneousRequirementGroupType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class SimultaneousRequirementGroupsType

*/

SimultaneousRequirementGroupsType::SimultaneousRequirementGroupsType()
{
  n = 0;
  SimultaneousRequirementGroup = 0;
}

SimultaneousRequirementGroupsType::SimultaneousRequirementGroupsType(
 SimultaneousRequirementGroupTypeLisd * SimultaneousRequirementGroupIn)
{
  n = 0;
  SimultaneousRequirementGroup = SimultaneousRequirementGroupIn;
}

SimultaneousRequirementGroupsType::SimultaneousRequirementGroupsType(
 NaturalType * nIn,
 SimultaneousRequirementGroupTypeLisd * SimultaneousRequirementGroupIn)
{
  n = nIn;
  SimultaneousRequirementGroup = SimultaneousRequirementGroupIn;
}

SimultaneousRequirementGroupsType::~SimultaneousRequirementGroupsType()
{
  #ifndef NODESTRUCT
  delete n;
  delete SimultaneousRequirementGroup;
  #endif
}

void SimultaneousRequirementGroupsType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!SimultaneousRequirementGroup)
      {
        fprintf(stderr, "SimultaneousRequirementGroup list is missing\n");
        exit(1);
      }
    if (SimultaneousRequirementGroup->size() == 0)
      {
        fprintf(stderr, "SimultaneousRequirementGroup list is empty\n");
        exit(1);
      }
    if (SimultaneousRequirementGroup->size() < 1)
      {
        fprintf(stderr,
                "size of SimultaneousRequirementGroup list (%d) less than minimum required (1)\n",
                (int)SimultaneousRequirementGroup->size());
        exit(1);
      }
    std::list<SimultaneousRequirementGroupType *>::iterator iter;
    for (iter = SimultaneousRequirementGroup->begin();
         iter != SimultaneousRequirementGroup->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<SimultaneousRequirementGroup");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</SimultaneousRequirementGroup>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool SimultaneousRequirementGroupsType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in SimultaneousRequirementGroupsType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in SimultaneousRequirementGroupsType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SimultaneousRequirementGroupsType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in SimultaneousRequirementGroupsType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * SimultaneousRequirementGroupsType::getn()
{return n;}

void SimultaneousRequirementGroupsType::setn(NaturalType * nIn)
{n = nIn;}

SimultaneousRequirementGroupTypeLisd * SimultaneousRequirementGroupsType::getSimultaneousRequirementGroup()
{return SimultaneousRequirementGroup;}

void SimultaneousRequirementGroupsType::setSimultaneousRequirementGroup(SimultaneousRequirementGroupTypeLisd * SimultaneousRequirementGroupIn)
{SimultaneousRequirementGroup = SimultaneousRequirementGroupIn;}

/* ***************************************************************** */

/* class SingleNestingIndexFilterSymbolEnumType

*/

SingleNestingIndexFilterSymbolEnumType::SingleNestingIndexFilterSymbolEnumType() :
  XmlNMTOKEN()
{
}

SingleNestingIndexFilterSymbolEnumType::SingleNestingIndexFilterSymbolEnumType(
 const char * valIn) :
  XmlNMTOKEN(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "AB") &&
           strcmp(val.c_str(), "AD") &&
           strcmp(val.c_str(), "AH") &&
           strcmp(val.c_str(), "CB") &&
           strcmp(val.c_str(), "CD") &&
           strcmp(val.c_str(), "CH") &&
           strcmp(val.c_str(), "H") &&
           strcmp(val.c_str(), "OB") &&
           strcmp(val.c_str(), "OH") &&
           strcmp(val.c_str(), "OS"));
}

SingleNestingIndexFilterSymbolEnumType::~SingleNestingIndexFilterSymbolEnumType() {}

bool SingleNestingIndexFilterSymbolEnumType::SingleNestingIndexFilterSymbolEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "AB") &&
          strcmp(val.c_str(), "AD") &&
          strcmp(val.c_str(), "AH") &&
          strcmp(val.c_str(), "CB") &&
          strcmp(val.c_str(), "CD") &&
          strcmp(val.c_str(), "CH") &&
          strcmp(val.c_str(), "H") &&
          strcmp(val.c_str(), "OB") &&
          strcmp(val.c_str(), "OH") &&
          strcmp(val.c_str(), "OS"));
}

void SingleNestingIndexFilterSymbolEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "SingleNestingIndexFilterSymbolEnumType");
}

void SingleNestingIndexFilterSymbolEnumType::printSelf(FILE * outFile)
{
  if (SingleNestingIndexFilterSymbolEnumTypeIsBad())
    {
      fprintf(stderr, "bad SingleNestingIndexFilterSymbolEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::printSelf(outFile);
}

void SingleNestingIndexFilterSymbolEnumType::oPrintSelf(FILE * outFile)
{
  if (SingleNestingIndexFilterSymbolEnumTypeIsBad())
    {
      fprintf(stderr, "bad SingleNestingIndexFilterSymbolEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class SingleNestingIndexFilterType

*/

SingleNestingIndexFilterType::SingleNestingIndexFilterType()
{
  Symbol = 0;
  NestingIndex = 0;
  SecondDirectionNestingIndex = 0;
}

SingleNestingIndexFilterType::SingleNestingIndexFilterType(
 SingleNestingIndexFilterSymbolEnumType * SymbolIn,
 LinearValueType * NestingIndexIn,
 LinearValueType * SecondDirectionNestingIndexIn)
{
  Symbol = SymbolIn;
  NestingIndex = NestingIndexIn;
  SecondDirectionNestingIndex = SecondDirectionNestingIndexIn;
}

SingleNestingIndexFilterType::~SingleNestingIndexFilterType()
{
  #ifndef NODESTRUCT
  delete Symbol;
  delete NestingIndex;
  delete SecondDirectionNestingIndex;
  #endif
}

void SingleNestingIndexFilterType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Symbol");
  Symbol->printSelf(outFile);
  fprintf(outFile, "</Symbol>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<NestingIndex");
  NestingIndex->printSelf(outFile);
  fprintf(outFile, "</NestingIndex>\n");
  if (SecondDirectionNestingIndex)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SecondDirectionNestingIndex");
      SecondDirectionNestingIndex->printSelf(outFile);
      fprintf(outFile, "</SecondDirectionNestingIndex>\n");
    }
  doSpaces(-INDENT, outFile);
}

SingleNestingIndexFilterSymbolEnumType * SingleNestingIndexFilterType::getSymbol()
{return Symbol;}

void SingleNestingIndexFilterType::setSymbol(SingleNestingIndexFilterSymbolEnumType * SymbolIn)
{Symbol = SymbolIn;}

LinearValueType * SingleNestingIndexFilterType::getNestingIndex()
{return NestingIndex;}

void SingleNestingIndexFilterType::setNestingIndex(LinearValueType * NestingIndexIn)
{NestingIndex = NestingIndexIn;}

LinearValueType * SingleNestingIndexFilterType::getSecondDirectionNestingIndex()
{return SecondDirectionNestingIndex;}

void SingleNestingIndexFilterType::setSecondDirectionNestingIndex(LinearValueType * SecondDirectionNestingIndexIn)
{SecondDirectionNestingIndex = SecondDirectionNestingIndexIn;}

/* ***************************************************************** */

/* class SpeedCharacteristicDefinitionBaseType

*/

SpeedCharacteristicDefinitionBaseType::SpeedCharacteristicDefinitionBaseType() :
  CharacteristicDefinitionBaseType()
{
  SpeedCharacteristicDefinitionBaseTypePair = 0;
}

SpeedCharacteristicDefinitionBaseType::SpeedCharacteristicDefinitionBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 SpeedCharacteristicDefinitionBaseTypeChoicePair * SpeedCharacteristicDefinitionBaseTypePairIn) :
  CharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
  SpeedCharacteristicDefinitionBaseTypePair = SpeedCharacteristicDefinitionBaseTypePairIn;
}

SpeedCharacteristicDefinitionBaseType::SpeedCharacteristicDefinitionBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 SpeedCharacteristicDefinitionBaseTypeChoicePair * SpeedCharacteristicDefinitionBaseTypePairIn) :
  CharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
  SpeedCharacteristicDefinitionBaseTypePair = SpeedCharacteristicDefinitionBaseTypePairIn;
}

SpeedCharacteristicDefinitionBaseType::~SpeedCharacteristicDefinitionBaseType()
{
  #ifndef NODESTRUCT
  delete SpeedCharacteristicDefinitionBaseTypePair;
  #endif
}

void SpeedCharacteristicDefinitionBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  SpeedCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}
SpeedCharacteristicDefinitionBaseTypeChoicePair * SpeedCharacteristicDefinitionBaseType::getSpeedCharacteristicDefinitionBaseTypeChoicePair()
{return SpeedCharacteristicDefinitionBaseTypePair;}

void SpeedCharacteristicDefinitionBaseType::setSpeedCharacteristicDefinitionBaseTypeChoicePair(SpeedCharacteristicDefinitionBaseTypeChoicePair * SpeedCharacteristicDefinitionBaseTypePairIn)
{SpeedCharacteristicDefinitionBaseTypePair = SpeedCharacteristicDefinitionBaseTypePairIn;}

/* ***************************************************************** */

SpeedCharacteristicDefinitionBaseTypeChoicePair::SpeedCharacteristicDefinitionBaseTypeChoicePair() {}

SpeedCharacteristicDefinitionBaseTypeChoicePair::SpeedCharacteristicDefinitionBaseTypeChoicePair(
 whichOne SpeedCharacteristicDefinitionBaseTypeTypeIn,
 SpeedCharacteristicDefinitionBaseTypeVal SpeedCharacteristicDefinitionBaseTypeValueIn)
{
  SpeedCharacteristicDefinitionBaseTypeType = SpeedCharacteristicDefinitionBaseTypeTypeIn;
  SpeedCharacteristicDefinitionBaseTypeValue = SpeedCharacteristicDefinitionBaseTypeValueIn;
}

SpeedCharacteristicDefinitionBaseTypeChoicePair::~SpeedCharacteristicDefinitionBaseTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (SpeedCharacteristicDefinitionBaseTypeType == ToleranceE)
    delete SpeedCharacteristicDefinitionBaseTypeValue.Tolerance;
  else if (SpeedCharacteristicDefinitionBaseTypeType == NonToleranceE)
    delete SpeedCharacteristicDefinitionBaseTypeValue.NonTolerance;
  #endif
}

void SpeedCharacteristicDefinitionBaseTypeChoicePair::printSelf(FILE * outFile)
{
  if (SpeedCharacteristicDefinitionBaseTypeType == ToleranceE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Tolerance");
      SpeedCharacteristicDefinitionBaseTypeValue.Tolerance->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Tolerance>\n");
    }
  else if (SpeedCharacteristicDefinitionBaseTypeType == NonToleranceE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonTolerance");
      SpeedCharacteristicDefinitionBaseTypeValue.NonTolerance->printSelf(outFile);
      fprintf(outFile, "</NonTolerance>\n");
    }
}

bool SpeedCharacteristicDefinitionBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SpeedCharacteristicDefinitionBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SpeedCharacteristicDefinitionBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SpeedCharacteristicDefinitionBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SpeedCharacteristicDefinitionBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class SpeedCharacteristicItemBaseType

*/

SpeedCharacteristicItemBaseType::SpeedCharacteristicItemBaseType() :
  CharacteristicItemBaseType()
{
}

SpeedCharacteristicItemBaseType::SpeedCharacteristicItemBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  CharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

SpeedCharacteristicItemBaseType::SpeedCharacteristicItemBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  CharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

SpeedCharacteristicItemBaseType::~SpeedCharacteristicItemBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void SpeedCharacteristicItemBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool SpeedCharacteristicItemBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SpeedCharacteristicItemBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SpeedCharacteristicItemBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SpeedCharacteristicItemBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SpeedCharacteristicItemBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class SpeedCharacteristicMeasurementBaseType

*/

SpeedCharacteristicMeasurementBaseType::SpeedCharacteristicMeasurementBaseType() :
  CharacteristicMeasurementBaseType()
{
  Value = 0;
  MaxValue = 0;
  MinValue = 0;
}

SpeedCharacteristicMeasurementBaseType::SpeedCharacteristicMeasurementBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredSpeedValueType * ValueIn,
 MeasuredSpeedValueType * MaxValueIn,
 MeasuredSpeedValueType * MinValueIn) :
  CharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  Value = ValueIn;
  MaxValue = MaxValueIn;
  MinValue = MinValueIn;
}

SpeedCharacteristicMeasurementBaseType::SpeedCharacteristicMeasurementBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredSpeedValueType * ValueIn,
 MeasuredSpeedValueType * MaxValueIn,
 MeasuredSpeedValueType * MinValueIn) :
  CharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  Value = ValueIn;
  MaxValue = MaxValueIn;
  MinValue = MinValueIn;
}

SpeedCharacteristicMeasurementBaseType::~SpeedCharacteristicMeasurementBaseType()
{
  #ifndef NODESTRUCT
  delete Value;
  delete MaxValue;
  delete MinValue;
  #endif
}

void SpeedCharacteristicMeasurementBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SpeedCharacteristicMeasurementBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SpeedCharacteristicMeasurementBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SpeedCharacteristicMeasurementBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SpeedCharacteristicMeasurementBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SpeedCharacteristicMeasurementBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredSpeedValueType * SpeedCharacteristicMeasurementBaseType::getValue()
{return Value;}

void SpeedCharacteristicMeasurementBaseType::setValue(MeasuredSpeedValueType * ValueIn)
{Value = ValueIn;}

MeasuredSpeedValueType * SpeedCharacteristicMeasurementBaseType::getMaxValue()
{return MaxValue;}

void SpeedCharacteristicMeasurementBaseType::setMaxValue(MeasuredSpeedValueType * MaxValueIn)
{MaxValue = MaxValueIn;}

MeasuredSpeedValueType * SpeedCharacteristicMeasurementBaseType::getMinValue()
{return MinValue;}

void SpeedCharacteristicMeasurementBaseType::setMinValue(MeasuredSpeedValueType * MinValueIn)
{MinValue = MinValueIn;}

/* ***************************************************************** */

/* class SpeedCharacteristicNominalBaseType

*/

SpeedCharacteristicNominalBaseType::SpeedCharacteristicNominalBaseType() :
  CharacteristicNominalBaseType()
{
  TargetValue = 0;
}

SpeedCharacteristicNominalBaseType::SpeedCharacteristicNominalBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 SpeedValueType * TargetValueIn) :
  CharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  TargetValue = TargetValueIn;
}

SpeedCharacteristicNominalBaseType::SpeedCharacteristicNominalBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 SpeedValueType * TargetValueIn) :
  CharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  TargetValue = TargetValueIn;
}

SpeedCharacteristicNominalBaseType::~SpeedCharacteristicNominalBaseType()
{
  #ifndef NODESTRUCT
  delete TargetValue;
  #endif
}

void SpeedCharacteristicNominalBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SpeedCharacteristicNominalBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SpeedCharacteristicNominalBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SpeedCharacteristicNominalBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SpeedCharacteristicNominalBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SpeedCharacteristicNominalBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

SpeedValueType * SpeedCharacteristicNominalBaseType::getTargetValue()
{return TargetValue;}

void SpeedCharacteristicNominalBaseType::setTargetValue(SpeedValueType * TargetValueIn)
{TargetValue = TargetValueIn;}

/* ***************************************************************** */

/* class SphericalDiameterCharacteristicDefinitionType

*/

SphericalDiameterCharacteristicDefinitionType::SphericalDiameterCharacteristicDefinitionType() :
  LinearCharacteristicDefinitionBaseType()
{
}

SphericalDiameterCharacteristicDefinitionType::SphericalDiameterCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseTypePairIn) :
  LinearCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    LinearCharacteristicDefinitionBaseTypePairIn)
{
}

SphericalDiameterCharacteristicDefinitionType::SphericalDiameterCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseTypePairIn) :
  LinearCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    LinearCharacteristicDefinitionBaseTypePairIn)
{
}

SphericalDiameterCharacteristicDefinitionType::~SphericalDiameterCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void SphericalDiameterCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (DimensionType)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionType");
      DimensionType->printSelf(outFile);
      fprintf(outFile, "</DimensionType>\n");
    }
  if (DimensionModifiers)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionModifiers");
      DimensionModifiers->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DimensionModifiers>\n");
    }
  LinearCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

bool SphericalDiameterCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SphericalDiameterCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SphericalDiameterCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SphericalDiameterCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SphericalDiameterCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class SphericalDiameterCharacteristicItemType

*/

SphericalDiameterCharacteristicItemType::SphericalDiameterCharacteristicItemType() :
  LinearCharacteristicItemBaseType()
{
}

SphericalDiameterCharacteristicItemType::SphericalDiameterCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LinearCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

SphericalDiameterCharacteristicItemType::SphericalDiameterCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LinearCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

SphericalDiameterCharacteristicItemType::~SphericalDiameterCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void SphericalDiameterCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool SphericalDiameterCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SphericalDiameterCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SphericalDiameterCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SphericalDiameterCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SphericalDiameterCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class SphericalDiameterCharacteristicMeasurementType

*/

SphericalDiameterCharacteristicMeasurementType::SphericalDiameterCharacteristicMeasurementType() :
  LinearCharacteristicMeasurementBaseType()
{
}

SphericalDiameterCharacteristicMeasurementType::SphericalDiameterCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  LinearCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

SphericalDiameterCharacteristicMeasurementType::SphericalDiameterCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  LinearCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

SphericalDiameterCharacteristicMeasurementType::~SphericalDiameterCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void SphericalDiameterCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SphericalDiameterCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SphericalDiameterCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SphericalDiameterCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SphericalDiameterCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SphericalDiameterCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class SphericalDiameterCharacteristicNominalType

*/

SphericalDiameterCharacteristicNominalType::SphericalDiameterCharacteristicNominalType() :
  LinearCharacteristicNominalBaseType()
{
}

SphericalDiameterCharacteristicNominalType::SphericalDiameterCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn) :
  LinearCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn,
    TargetDualValueIn)
{
}

SphericalDiameterCharacteristicNominalType::SphericalDiameterCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn) :
  LinearCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn,
    TargetDualValueIn)
{
}

SphericalDiameterCharacteristicNominalType::~SphericalDiameterCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void SphericalDiameterCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  if (TargetDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetDualValue");
      TargetDualValue->printSelf(outFile);
      fprintf(outFile, "</TargetDualValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SphericalDiameterCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SphericalDiameterCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SphericalDiameterCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SphericalDiameterCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SphericalDiameterCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class SphericalRadiusCharacteristicDefinitionType

*/

SphericalRadiusCharacteristicDefinitionType::SphericalRadiusCharacteristicDefinitionType() :
  LinearCharacteristicDefinitionBaseType()
{
}

SphericalRadiusCharacteristicDefinitionType::SphericalRadiusCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseTypePairIn) :
  LinearCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    LinearCharacteristicDefinitionBaseTypePairIn)
{
}

SphericalRadiusCharacteristicDefinitionType::SphericalRadiusCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseTypePairIn) :
  LinearCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    LinearCharacteristicDefinitionBaseTypePairIn)
{
}

SphericalRadiusCharacteristicDefinitionType::~SphericalRadiusCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void SphericalRadiusCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (DimensionType)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionType");
      DimensionType->printSelf(outFile);
      fprintf(outFile, "</DimensionType>\n");
    }
  if (DimensionModifiers)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionModifiers");
      DimensionModifiers->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DimensionModifiers>\n");
    }
  LinearCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

bool SphericalRadiusCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SphericalRadiusCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SphericalRadiusCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SphericalRadiusCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SphericalRadiusCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class SphericalRadiusCharacteristicItemType

*/

SphericalRadiusCharacteristicItemType::SphericalRadiusCharacteristicItemType() :
  LinearCharacteristicItemBaseType()
{
}

SphericalRadiusCharacteristicItemType::SphericalRadiusCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LinearCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

SphericalRadiusCharacteristicItemType::SphericalRadiusCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LinearCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

SphericalRadiusCharacteristicItemType::~SphericalRadiusCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void SphericalRadiusCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool SphericalRadiusCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SphericalRadiusCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SphericalRadiusCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SphericalRadiusCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SphericalRadiusCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class SphericalRadiusCharacteristicMeasurementType

*/

SphericalRadiusCharacteristicMeasurementType::SphericalRadiusCharacteristicMeasurementType() :
  LinearCharacteristicMeasurementBaseType()
{
}

SphericalRadiusCharacteristicMeasurementType::SphericalRadiusCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  LinearCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

SphericalRadiusCharacteristicMeasurementType::SphericalRadiusCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  LinearCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

SphericalRadiusCharacteristicMeasurementType::~SphericalRadiusCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void SphericalRadiusCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SphericalRadiusCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SphericalRadiusCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SphericalRadiusCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SphericalRadiusCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SphericalRadiusCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class SphericalRadiusCharacteristicNominalType

*/

SphericalRadiusCharacteristicNominalType::SphericalRadiusCharacteristicNominalType() :
  LinearCharacteristicNominalBaseType()
{
}

SphericalRadiusCharacteristicNominalType::SphericalRadiusCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn) :
  LinearCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn,
    TargetDualValueIn)
{
}

SphericalRadiusCharacteristicNominalType::SphericalRadiusCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn) :
  LinearCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn,
    TargetDualValueIn)
{
}

SphericalRadiusCharacteristicNominalType::~SphericalRadiusCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void SphericalRadiusCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  if (TargetDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetDualValue");
      TargetDualValue->printSelf(outFile);
      fprintf(outFile, "</TargetDualValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SphericalRadiusCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SphericalRadiusCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SphericalRadiusCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SphericalRadiusCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SphericalRadiusCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class SphericityCharacteristicDefinitionType

*/

SphericityCharacteristicDefinitionType::SphericityCharacteristicDefinitionType() :
  FormCharacteristicDefinitionBaseType()
{
  ToleranceValue = 0;
  ToleranceDualValue = 0;
}

SphericityCharacteristicDefinitionType::SphericityCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn) :
  FormCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn)
{
  ToleranceValue = ToleranceValueIn;
  ToleranceDualValue = ToleranceDualValueIn;
}

SphericityCharacteristicDefinitionType::SphericityCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn) :
  FormCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn)
{
  ToleranceValue = ToleranceValueIn;
  ToleranceDualValue = ToleranceDualValueIn;
}

SphericityCharacteristicDefinitionType::~SphericityCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  delete ToleranceValue;
  delete ToleranceDualValue;
  #endif
}

void SphericityCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (GeometricCharac_1050)
    {
  GeometricCharac_1050->printSelf(outFile);
    }
  if (DirectionFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DirectionFeature");
      DirectionFeature->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DirectionFeature>\n");
    }
  if (CollectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CollectionPlane");
      CollectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CollectionPlane>\n");
    }
  if (IntersectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IntersectionPlane");
      IntersectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</IntersectionPlane>\n");
    }
  if (OrientationPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OrientationPlane");
      OrientationPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OrientationPlane>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ToleranceValue");
  ToleranceValue->printSelf(outFile);
  fprintf(outFile, "</ToleranceValue>\n");
  if (ToleranceDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceDualValue");
      ToleranceDualValue->printSelf(outFile);
      fprintf(outFile, "</ToleranceDualValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SphericityCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SphericityCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SphericityCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SphericityCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SphericityCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LinearValueType * SphericityCharacteristicDefinitionType::getToleranceValue()
{return ToleranceValue;}

void SphericityCharacteristicDefinitionType::setToleranceValue(LinearValueType * ToleranceValueIn)
{ToleranceValue = ToleranceValueIn;}

LinearDualValueType * SphericityCharacteristicDefinitionType::getToleranceDualValue()
{return ToleranceDualValue;}

void SphericityCharacteristicDefinitionType::setToleranceDualValue(LinearDualValueType * ToleranceDualValueIn)
{ToleranceDualValue = ToleranceDualValueIn;}

/* ***************************************************************** */

/* class SphericityCharacteristicItemType

*/

SphericityCharacteristicItemType::SphericityCharacteristicItemType() :
  FormCharacteristicItemBaseType()
{
}

SphericityCharacteristicItemType::SphericityCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  FormCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

SphericityCharacteristicItemType::SphericityCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  FormCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

SphericityCharacteristicItemType::~SphericityCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void SphericityCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool SphericityCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SphericityCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SphericityCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SphericityCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SphericityCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class SphericityCharacteristicMeasurementType

*/

SphericityCharacteristicMeasurementType::SphericityCharacteristicMeasurementType() :
  FormCharacteristicMeasurementBaseType()
{
  SphericityChara_1057 = 0;
}

SphericityCharacteristicMeasurementType::SphericityCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 SphericityChara_1057_Type * SphericityChara_1057In) :
  FormCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
  SphericityChara_1057 = SphericityChara_1057In;
}

SphericityCharacteristicMeasurementType::SphericityCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 SphericityChara_1057_Type * SphericityChara_1057In) :
  FormCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
  SphericityChara_1057 = SphericityChara_1057In;
}

SphericityCharacteristicMeasurementType::~SphericityCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  delete SphericityChara_1057;
  #endif
}

void SphericityCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  if (SphericityChara_1057)
    {
      SphericityChara_1057->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool SphericityCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SphericityCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SphericityCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SphericityCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SphericityCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

SphericityChara_1057_Type * SphericityCharacteristicMeasurementType::getSphericityChara_1057()
{return SphericityChara_1057;}

void SphericityCharacteristicMeasurementType::setSphericityChara_1057(SphericityChara_1057_Type * SphericityChara_1057In)
{SphericityChara_1057 = SphericityChara_1057In;}

/* ***************************************************************** */

/* class SphericityCharacteristicNominalType

*/

SphericityCharacteristicNominalType::SphericityCharacteristicNominalType() :
  FormCharacteristicNominalBaseType()
{
}

SphericityCharacteristicNominalType::SphericityCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  FormCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

SphericityCharacteristicNominalType::SphericityCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  FormCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

SphericityCharacteristicNominalType::~SphericityCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void SphericityCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SphericityCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SphericityCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SphericityCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SphericityCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SphericityCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class SquareCharacteristicDefinitionType

*/

SquareCharacteristicDefinitionType::SquareCharacteristicDefinitionType() :
  LinearCharacteristicDefinitionBaseType()
{
}

SquareCharacteristicDefinitionType::SquareCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseTypePairIn) :
  LinearCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    LinearCharacteristicDefinitionBaseTypePairIn)
{
}

SquareCharacteristicDefinitionType::SquareCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseTypePairIn) :
  LinearCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    LinearCharacteristicDefinitionBaseTypePairIn)
{
}

SquareCharacteristicDefinitionType::~SquareCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void SquareCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (DimensionType)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionType");
      DimensionType->printSelf(outFile);
      fprintf(outFile, "</DimensionType>\n");
    }
  if (DimensionModifiers)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionModifiers");
      DimensionModifiers->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DimensionModifiers>\n");
    }
  LinearCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

bool SquareCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SquareCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SquareCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SquareCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SquareCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class SquareCharacteristicItemType

*/

SquareCharacteristicItemType::SquareCharacteristicItemType() :
  LinearCharacteristicItemBaseType()
{
}

SquareCharacteristicItemType::SquareCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LinearCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

SquareCharacteristicItemType::SquareCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LinearCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

SquareCharacteristicItemType::~SquareCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void SquareCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool SquareCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SquareCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SquareCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SquareCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SquareCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class SquareCharacteristicMeasurementType

*/

SquareCharacteristicMeasurementType::SquareCharacteristicMeasurementType() :
  LinearCharacteristicMeasurementBaseType()
{
}

SquareCharacteristicMeasurementType::SquareCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  LinearCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

SquareCharacteristicMeasurementType::SquareCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  LinearCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

SquareCharacteristicMeasurementType::~SquareCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void SquareCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SquareCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SquareCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SquareCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SquareCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SquareCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class SquareCharacteristicNominalType

*/

SquareCharacteristicNominalType::SquareCharacteristicNominalType() :
  LinearCharacteristicNominalBaseType()
{
}

SquareCharacteristicNominalType::SquareCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn) :
  LinearCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn,
    TargetDualValueIn)
{
}

SquareCharacteristicNominalType::SquareCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn) :
  LinearCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn,
    TargetDualValueIn)
{
}

SquareCharacteristicNominalType::~SquareCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void SquareCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  if (TargetDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetDualValue");
      TargetDualValue->printSelf(outFile);
      fprintf(outFile, "</TargetDualValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SquareCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SquareCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SquareCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SquareCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SquareCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class StraightnessCharacteristicDefinitionType

*/

StraightnessCharacteristicDefinitionType::StraightnessCharacteristicDefinitionType() :
  FormCharacteristicDefinitionBaseType()
{
  StraightnessCha_1058 = 0;
  MaterialCondition = 0;
  SizeCharacteristicDefinitionId = 0;
  ZoneShape = 0;
  MaximumToleranceValue = 0;
}

StraightnessCharacteristicDefinitionType::StraightnessCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 StraightnessCha_1058_Type * StraightnessCha_1058In,
 MaterialModifierEnumType * MaterialConditionIn,
 QIFReferenceType * SizeCharacteristicDefinitionIdIn,
 StraightnessZoneShapeType * ZoneShapeIn,
 LinearValueType * MaximumToleranceValueIn) :
  FormCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn)
{
  StraightnessCha_1058 = StraightnessCha_1058In;
  MaterialCondition = MaterialConditionIn;
  SizeCharacteristicDefinitionId = SizeCharacteristicDefinitionIdIn;
  ZoneShape = ZoneShapeIn;
  MaximumToleranceValue = MaximumToleranceValueIn;
}

StraightnessCharacteristicDefinitionType::StraightnessCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 StraightnessCha_1058_Type * StraightnessCha_1058In,
 MaterialModifierEnumType * MaterialConditionIn,
 QIFReferenceType * SizeCharacteristicDefinitionIdIn,
 StraightnessZoneShapeType * ZoneShapeIn,
 LinearValueType * MaximumToleranceValueIn) :
  FormCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn)
{
  StraightnessCha_1058 = StraightnessCha_1058In;
  MaterialCondition = MaterialConditionIn;
  SizeCharacteristicDefinitionId = SizeCharacteristicDefinitionIdIn;
  ZoneShape = ZoneShapeIn;
  MaximumToleranceValue = MaximumToleranceValueIn;
}

StraightnessCharacteristicDefinitionType::~StraightnessCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  delete StraightnessCha_1058;
  delete MaterialCondition;
  delete SizeCharacteristicDefinitionId;
  delete ZoneShape;
  delete MaximumToleranceValue;
  #endif
}

void StraightnessCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (GeometricCharac_1050)
    {
  GeometricCharac_1050->printSelf(outFile);
    }
  if (DirectionFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DirectionFeature");
      DirectionFeature->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DirectionFeature>\n");
    }
  if (CollectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CollectionPlane");
      CollectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CollectionPlane>\n");
    }
  if (IntersectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IntersectionPlane");
      IntersectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</IntersectionPlane>\n");
    }
  if (OrientationPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OrientationPlane");
      OrientationPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OrientationPlane>\n");
    }
  StraightnessCha_1058->printSelf(outFile);
  if (MaterialCondition)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaterialCondition");
      MaterialCondition->printSelf(outFile);
      fprintf(outFile, "</MaterialCondition>\n");
    }
  if (SizeCharacteristicDefinitionId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SizeCharacteristicDefinitionId");
      SizeCharacteristicDefinitionId->printSelf(outFile);
      fprintf(outFile, "</SizeCharacteristicDefinitionId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ZoneShape");
  ZoneShape->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ZoneShape>\n");
  if (MaximumToleranceValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaximumToleranceValue");
      MaximumToleranceValue->printSelf(outFile);
      fprintf(outFile, "</MaximumToleranceValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool StraightnessCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in StraightnessCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in StraightnessCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in StraightnessCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in StraightnessCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

StraightnessCha_1058_Type * StraightnessCharacteristicDefinitionType::getStraightnessCha_1058()
{return StraightnessCha_1058;}

void StraightnessCharacteristicDefinitionType::setStraightnessCha_1058(StraightnessCha_1058_Type * StraightnessCha_1058In)
{StraightnessCha_1058 = StraightnessCha_1058In;}

MaterialModifierEnumType * StraightnessCharacteristicDefinitionType::getMaterialCondition()
{return MaterialCondition;}

void StraightnessCharacteristicDefinitionType::setMaterialCondition(MaterialModifierEnumType * MaterialConditionIn)
{MaterialCondition = MaterialConditionIn;}

QIFReferenceType * StraightnessCharacteristicDefinitionType::getSizeCharacteristicDefinitionId()
{return SizeCharacteristicDefinitionId;}

void StraightnessCharacteristicDefinitionType::setSizeCharacteristicDefinitionId(QIFReferenceType * SizeCharacteristicDefinitionIdIn)
{SizeCharacteristicDefinitionId = SizeCharacteristicDefinitionIdIn;}

StraightnessZoneShapeType * StraightnessCharacteristicDefinitionType::getZoneShape()
{return ZoneShape;}

void StraightnessCharacteristicDefinitionType::setZoneShape(StraightnessZoneShapeType * ZoneShapeIn)
{ZoneShape = ZoneShapeIn;}

LinearValueType * StraightnessCharacteristicDefinitionType::getMaximumToleranceValue()
{return MaximumToleranceValue;}

void StraightnessCharacteristicDefinitionType::setMaximumToleranceValue(LinearValueType * MaximumToleranceValueIn)
{MaximumToleranceValue = MaximumToleranceValueIn;}

/* ***************************************************************** */

/* class StraightnessCharacteristicItemType

*/

StraightnessCharacteristicItemType::StraightnessCharacteristicItemType() :
  FormCharacteristicItemBaseType()
{
}

StraightnessCharacteristicItemType::StraightnessCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  FormCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

StraightnessCharacteristicItemType::StraightnessCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  FormCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

StraightnessCharacteristicItemType::~StraightnessCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void StraightnessCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool StraightnessCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in StraightnessCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in StraightnessCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in StraightnessCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in StraightnessCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class StraightnessCharacteristicMeasurementType

*/

StraightnessCharacteristicMeasurementType::StraightnessCharacteristicMeasurementType() :
  FormCharacteristicMeasurementBaseType()
{
  Bonus = 0;
  MaxStraightness = 0;
  ZoneOrientation = 0;
  ZoneLine = 0;
}

StraightnessCharacteristicMeasurementType::StraightnessCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 MeasuredLinearValueType * BonusIn,
 MeasuredLinearValueType * MaxStraightnessIn,
 MeasuredUnitVectorType * ZoneOrientationIn,
 MeasuredZoneAxisType * ZoneLineIn) :
  FormCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
  Bonus = BonusIn;
  MaxStraightness = MaxStraightnessIn;
  ZoneOrientation = ZoneOrientationIn;
  ZoneLine = ZoneLineIn;
}

StraightnessCharacteristicMeasurementType::StraightnessCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 MeasuredLinearValueType * BonusIn,
 MeasuredLinearValueType * MaxStraightnessIn,
 MeasuredUnitVectorType * ZoneOrientationIn,
 MeasuredZoneAxisType * ZoneLineIn) :
  FormCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
  Bonus = BonusIn;
  MaxStraightness = MaxStraightnessIn;
  ZoneOrientation = ZoneOrientationIn;
  ZoneLine = ZoneLineIn;
}

StraightnessCharacteristicMeasurementType::~StraightnessCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  delete Bonus;
  delete MaxStraightness;
  delete ZoneOrientation;
  delete ZoneLine;
  #endif
}

void StraightnessCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  if (Bonus)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Bonus");
      Bonus->printSelf(outFile);
      fprintf(outFile, "</Bonus>\n");
    }
  if (MaxStraightness)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxStraightness");
      MaxStraightness->printSelf(outFile);
      fprintf(outFile, "</MaxStraightness>\n");
    }
  if (ZoneOrientation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ZoneOrientation");
      ZoneOrientation->printSelf(outFile);
      fprintf(outFile, "</ZoneOrientation>\n");
    }
  if (ZoneLine)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ZoneLine");
      ZoneLine->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ZoneLine>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool StraightnessCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in StraightnessCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in StraightnessCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in StraightnessCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in StraightnessCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredLinearValueType * StraightnessCharacteristicMeasurementType::getBonus()
{return Bonus;}

void StraightnessCharacteristicMeasurementType::setBonus(MeasuredLinearValueType * BonusIn)
{Bonus = BonusIn;}

MeasuredLinearValueType * StraightnessCharacteristicMeasurementType::getMaxStraightness()
{return MaxStraightness;}

void StraightnessCharacteristicMeasurementType::setMaxStraightness(MeasuredLinearValueType * MaxStraightnessIn)
{MaxStraightness = MaxStraightnessIn;}

MeasuredUnitVectorType * StraightnessCharacteristicMeasurementType::getZoneOrientation()
{return ZoneOrientation;}

void StraightnessCharacteristicMeasurementType::setZoneOrientation(MeasuredUnitVectorType * ZoneOrientationIn)
{ZoneOrientation = ZoneOrientationIn;}

MeasuredZoneAxisType * StraightnessCharacteristicMeasurementType::getZoneLine()
{return ZoneLine;}

void StraightnessCharacteristicMeasurementType::setZoneLine(MeasuredZoneAxisType * ZoneLineIn)
{ZoneLine = ZoneLineIn;}

/* ***************************************************************** */

/* class StraightnessCharacteristicNominalType

*/

StraightnessCharacteristicNominalType::StraightnessCharacteristicNominalType() :
  FormCharacteristicNominalBaseType()
{
  DirectionCurveId = 0;
}

StraightnessCharacteristicNominalType::StraightnessCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 QIFReferenceFullType * DirectionCurveIdIn) :
  FormCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  DirectionCurveId = DirectionCurveIdIn;
}

StraightnessCharacteristicNominalType::StraightnessCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 QIFReferenceFullType * DirectionCurveIdIn) :
  FormCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  DirectionCurveId = DirectionCurveIdIn;
}

StraightnessCharacteristicNominalType::~StraightnessCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  delete DirectionCurveId;
  #endif
}

void StraightnessCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (DirectionCurveId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DirectionCurveId");
      DirectionCurveId->printSelf(outFile);
      fprintf(outFile, "</DirectionCurveId>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool StraightnessCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in StraightnessCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in StraightnessCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in StraightnessCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in StraightnessCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

QIFReferenceFullType * StraightnessCharacteristicNominalType::getDirectionCurveId()
{return DirectionCurveId;}

void StraightnessCharacteristicNominalType::setDirectionCurveId(QIFReferenceFullType * DirectionCurveIdIn)
{DirectionCurveId = DirectionCurveIdIn;}

/* ***************************************************************** */

/* class StraightnessDiametricalZoneType

*/

StraightnessDiametricalZoneType::StraightnessDiametricalZoneType()
{}

StraightnessDiametricalZoneType::~StraightnessDiametricalZoneType() {}

void StraightnessDiametricalZoneType::printSelf(FILE * outFile)
{
  fprintf(outFile, "/>\n");
}

/* ***************************************************************** */

/* class StraightnessNonDiametricalZoneType

*/

StraightnessNonDiametricalZoneType::StraightnessNonDiametricalZoneType()
{
  ZoneOrientationVector = 0;
}

StraightnessNonDiametricalZoneType::StraightnessNonDiametricalZoneType(
 UnitVectorType * ZoneOrientationVectorIn)
{
  ZoneOrientationVector = ZoneOrientationVectorIn;
}

StraightnessNonDiametricalZoneType::~StraightnessNonDiametricalZoneType()
{
  #ifndef NODESTRUCT
  delete ZoneOrientationVector;
  #endif
}

void StraightnessNonDiametricalZoneType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (ZoneOrientationVector)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ZoneOrientationVector");
      ZoneOrientationVector->printSelf(outFile);
      fprintf(outFile, "</ZoneOrientationVector>\n");
    }
  doSpaces(-INDENT, outFile);
}

UnitVectorType * StraightnessNonDiametricalZoneType::getZoneOrientationVector()
{return ZoneOrientationVector;}

void StraightnessNonDiametricalZoneType::setZoneOrientationVector(UnitVectorType * ZoneOrientationVectorIn)
{ZoneOrientationVector = ZoneOrientationVectorIn;}

/* ***************************************************************** */

/* class StraightnessZoneShapeType

*/

StraightnessZoneShapeType::StraightnessZoneShapeType()
{
  StraightnessZoneShapeTypePair = 0;
}

StraightnessZoneShapeType::StraightnessZoneShapeType(
 StraightnessZoneShapeTypeChoicePair * StraightnessZoneShapeTypePairIn)
{
  StraightnessZoneShapeTypePair = StraightnessZoneShapeTypePairIn;
}

StraightnessZoneShapeType::~StraightnessZoneShapeType()
{
  #ifndef NODESTRUCT
  delete StraightnessZoneShapeTypePair;
  #endif
}

void StraightnessZoneShapeType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  StraightnessZoneShapeTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

StraightnessZoneShapeTypeChoicePair * StraightnessZoneShapeType::getStraightnessZoneShapeTypePair()
{return StraightnessZoneShapeTypePair;}

void StraightnessZoneShapeType::setStraightnessZoneShapeTypePair(StraightnessZoneShapeTypeChoicePair * StraightnessZoneShapeTypePairIn)
{StraightnessZoneShapeTypePair = StraightnessZoneShapeTypePairIn;}
StraightnessZoneShapeTypeChoicePair::StraightnessZoneShapeTypeChoicePair() {}

StraightnessZoneShapeTypeChoicePair::StraightnessZoneShapeTypeChoicePair(
 whichOne StraightnessZoneShapeTypeTypeIn,
 StraightnessZoneShapeTypeVal StraightnessZoneShapeTypeValueIn)
{
  StraightnessZoneShapeTypeType = StraightnessZoneShapeTypeTypeIn;
  StraightnessZoneShapeTypeValue = StraightnessZoneShapeTypeValueIn;
}

StraightnessZoneShapeTypeChoicePair::~StraightnessZoneShapeTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (StraightnessZoneShapeTypeType == DiametricalZoneE)
    delete StraightnessZoneShapeTypeValue.DiametricalZone;
  else if (StraightnessZoneShapeTypeType == NonDiametricalZoneE)
    delete StraightnessZoneShapeTypeValue.NonDiametricalZone;
  #endif
}

void StraightnessZoneShapeTypeChoicePair::printSelf(FILE * outFile)
{
  if (StraightnessZoneShapeTypeType == DiametricalZoneE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DiametricalZone");
      StraightnessZoneShapeTypeValue.DiametricalZone->printSelf(outFile);
    }
  else if (StraightnessZoneShapeTypeType == NonDiametricalZoneE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonDiametricalZone");
      StraightnessZoneShapeTypeValue.NonDiametricalZone->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NonDiametricalZone>\n");
    }
}

/* ***************************************************************** */

/* class StringValuesType

*/

StringValuesType::StringValuesType()
{
  n = 0;
  StringValue = 0;
}

StringValuesType::StringValuesType(
 XmlStringLisd * StringValueIn)
{
  n = 0;
  StringValue = StringValueIn;
}

StringValuesType::StringValuesType(
 NaturalType * nIn,
 XmlStringLisd * StringValueIn)
{
  n = nIn;
  StringValue = StringValueIn;
}

StringValuesType::~StringValuesType()
{
  #ifndef NODESTRUCT
  delete n;
  delete StringValue;
  #endif
}

void StringValuesType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!StringValue)
      {
        fprintf(stderr, "StringValue list is missing\n");
        exit(1);
      }
    if (StringValue->size() == 0)
      {
        fprintf(stderr, "StringValue list is empty\n");
        exit(1);
      }
    if (StringValue->size() < 1)
      {
        fprintf(stderr,
                "size of StringValue list (%d) less than minimum required (1)\n",
                (int)StringValue->size());
        exit(1);
      }
    std::list<XmlString *>::iterator iter;
    for (iter = StringValue->begin();
         iter != StringValue->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<StringValue");
        (*iter)->printSelf(outFile);
        fprintf(outFile, "</StringValue>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool StringValuesType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in StringValuesType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in StringValuesType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in StringValuesType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in StringValuesType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * StringValuesType::getn()
{return n;}

void StringValuesType::setn(NaturalType * nIn)
{n = nIn;}

XmlStringLisd * StringValuesType::getStringValue()
{return StringValue;}

void StringValuesType::setStringValue(XmlStringLisd * StringValueIn)
{StringValue = StringValueIn;}

/* ***************************************************************** */

/* class SurfaceProfileCharacteristicDefinitionType

*/

SurfaceProfileCharacteristicDefinitionType::SurfaceProfileCharacteristicDefinitionType() :
  ProfileCharacteristicDefinitionBaseType()
{
  Extent = 0;
}

SurfaceProfileCharacteristicDefinitionType::SurfaceProfileCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 ProfileCharacte_1056_Type * ProfileCharacte_1056In,
 XmlBoolean * OffsetZoneIn,
 XmlBoolean * VariableAngleIn,
 CompositeSegmentProfileDefinitionType * SecondCompositeSegmentProfileDefinitionIn,
 CompositeSegmentProfileDefinitionType * ThirdCompositeSegmentProfileDefinitionIn,
 CompositeSegmentProfileDefinitionType * FourthCompositeSegmentProfileDefinitionIn,
 QIFReferenceFullType * DatumReferenceFrameIdIn,
 XmlBoolean * OrientationOnlyIn,
 ExtentType * ExtentIn) :
  ProfileCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn,
    ToleranceValueIn,
    ToleranceDualValueIn,
    ProfileCharacte_1056In,
    OffsetZoneIn,
    VariableAngleIn,
    SecondCompositeSegmentProfileDefinitionIn,
    ThirdCompositeSegmentProfileDefinitionIn,
    FourthCompositeSegmentProfileDefinitionIn,
    DatumReferenceFrameIdIn,
    OrientationOnlyIn)
{
  Extent = ExtentIn;
}

SurfaceProfileCharacteristicDefinitionType::SurfaceProfileCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 ProfileCharacte_1056_Type * ProfileCharacte_1056In,
 XmlBoolean * OffsetZoneIn,
 XmlBoolean * VariableAngleIn,
 CompositeSegmentProfileDefinitionType * SecondCompositeSegmentProfileDefinitionIn,
 CompositeSegmentProfileDefinitionType * ThirdCompositeSegmentProfileDefinitionIn,
 CompositeSegmentProfileDefinitionType * FourthCompositeSegmentProfileDefinitionIn,
 QIFReferenceFullType * DatumReferenceFrameIdIn,
 XmlBoolean * OrientationOnlyIn,
 ExtentType * ExtentIn) :
  ProfileCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn,
    ToleranceValueIn,
    ToleranceDualValueIn,
    ProfileCharacte_1056In,
    OffsetZoneIn,
    VariableAngleIn,
    SecondCompositeSegmentProfileDefinitionIn,
    ThirdCompositeSegmentProfileDefinitionIn,
    FourthCompositeSegmentProfileDefinitionIn,
    DatumReferenceFrameIdIn,
    OrientationOnlyIn)
{
  Extent = ExtentIn;
}

SurfaceProfileCharacteristicDefinitionType::~SurfaceProfileCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  delete Extent;
  #endif
}

void SurfaceProfileCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (GeometricCharac_1050)
    {
  GeometricCharac_1050->printSelf(outFile);
    }
  if (DirectionFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DirectionFeature");
      DirectionFeature->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DirectionFeature>\n");
    }
  if (CollectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CollectionPlane");
      CollectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CollectionPlane>\n");
    }
  if (IntersectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IntersectionPlane");
      IntersectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</IntersectionPlane>\n");
    }
  if (OrientationPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OrientationPlane");
      OrientationPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OrientationPlane>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ToleranceValue");
  ToleranceValue->printSelf(outFile);
  fprintf(outFile, "</ToleranceValue>\n");
  if (ToleranceDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceDualValue");
      ToleranceDualValue->printSelf(outFile);
      fprintf(outFile, "</ToleranceDualValue>\n");
    }
  if (ProfileCharacte_1056)
    {
  ProfileCharacte_1056->printSelf(outFile);
    }
  if (OffsetZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OffsetZone");
      OffsetZone->printSelf(outFile);
      fprintf(outFile, "</OffsetZone>\n");
    }
  if (VariableAngle)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VariableAngle");
      VariableAngle->printSelf(outFile);
      fprintf(outFile, "</VariableAngle>\n");
    }
  if (SecondCompositeSegmentProfileDefinition)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SecondCompositeSegmentProfileDefinition");
      SecondCompositeSegmentProfileDefinition->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SecondCompositeSegmentProfileDefinition>\n");
    }
  if (ThirdCompositeSegmentProfileDefinition)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ThirdCompositeSegmentProfileDefinition");
      ThirdCompositeSegmentProfileDefinition->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ThirdCompositeSegmentProfileDefinition>\n");
    }
  if (FourthCompositeSegmentProfileDefinition)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FourthCompositeSegmentProfileDefinition");
      FourthCompositeSegmentProfileDefinition->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FourthCompositeSegmentProfileDefinition>\n");
    }
  if (DatumReferenceFrameId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumReferenceFrameId");
      DatumReferenceFrameId->printSelf(outFile);
      fprintf(outFile, "</DatumReferenceFrameId>\n");
    }
  if (OrientationOnly)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OrientationOnly");
      OrientationOnly->printSelf(outFile);
      fprintf(outFile, "</OrientationOnly>\n");
    }
  if (Extent)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Extent");
      Extent->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Extent>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SurfaceProfileCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SurfaceProfileCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SurfaceProfileCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SurfaceProfileCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SurfaceProfileCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

ExtentType * SurfaceProfileCharacteristicDefinitionType::getExtent()
{return Extent;}

void SurfaceProfileCharacteristicDefinitionType::setExtent(ExtentType * ExtentIn)
{Extent = ExtentIn;}

/* ***************************************************************** */

/* class SurfaceProfileCharacteristicItemType

*/

SurfaceProfileCharacteristicItemType::SurfaceProfileCharacteristicItemType() :
  ProfileCharacteristicItemBaseType()
{
}

SurfaceProfileCharacteristicItemType::SurfaceProfileCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  ProfileCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

SurfaceProfileCharacteristicItemType::SurfaceProfileCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  ProfileCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

SurfaceProfileCharacteristicItemType::~SurfaceProfileCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void SurfaceProfileCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool SurfaceProfileCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SurfaceProfileCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SurfaceProfileCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SurfaceProfileCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SurfaceProfileCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class SurfaceProfileCharacteristicMeasurementType

*/

SurfaceProfileCharacteristicMeasurementType::SurfaceProfileCharacteristicMeasurementType() :
  ProfileCharacteristicMeasurementBaseType()
{
}

SurfaceProfileCharacteristicMeasurementType::SurfaceProfileCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 LinearValueType * WorstPositiveDeviationIn,
 LinearValueType * WorstNegativeDeviationIn,
 PointDeviationsType * PointDeviationsIn,
 XmlBoolean * DatumsOkIn,
 QIFReferenceType * DRFTransformActualIdIn,
 CompositeSegmentProfileMeasurementType * SecondCompositeSegmentProfileMeasurementIn,
 CompositeSegmentProfileMeasurementType * ThirdCompositeSegmentProfileMeasurementIn,
 CompositeSegmentProfileMeasurementType * FourthCompositeSegmentProfileMeasurementIn) :
  ProfileCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn,
    WorstPositiveDeviationIn,
    WorstNegativeDeviationIn,
    PointDeviationsIn,
    DatumsOkIn,
    DRFTransformActualIdIn,
    SecondCompositeSegmentProfileMeasurementIn,
    ThirdCompositeSegmentProfileMeasurementIn,
    FourthCompositeSegmentProfileMeasurementIn)
{
}

SurfaceProfileCharacteristicMeasurementType::SurfaceProfileCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 LinearValueType * WorstPositiveDeviationIn,
 LinearValueType * WorstNegativeDeviationIn,
 PointDeviationsType * PointDeviationsIn,
 XmlBoolean * DatumsOkIn,
 QIFReferenceType * DRFTransformActualIdIn,
 CompositeSegmentProfileMeasurementType * SecondCompositeSegmentProfileMeasurementIn,
 CompositeSegmentProfileMeasurementType * ThirdCompositeSegmentProfileMeasurementIn,
 CompositeSegmentProfileMeasurementType * FourthCompositeSegmentProfileMeasurementIn) :
  ProfileCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn,
    WorstPositiveDeviationIn,
    WorstNegativeDeviationIn,
    PointDeviationsIn,
    DatumsOkIn,
    DRFTransformActualIdIn,
    SecondCompositeSegmentProfileMeasurementIn,
    ThirdCompositeSegmentProfileMeasurementIn,
    FourthCompositeSegmentProfileMeasurementIn)
{
}

SurfaceProfileCharacteristicMeasurementType::~SurfaceProfileCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void SurfaceProfileCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  if (WorstPositiveDeviation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WorstPositiveDeviation");
      WorstPositiveDeviation->printSelf(outFile);
      fprintf(outFile, "</WorstPositiveDeviation>\n");
    }
  if (WorstNegativeDeviation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WorstNegativeDeviation");
      WorstNegativeDeviation->printSelf(outFile);
      fprintf(outFile, "</WorstNegativeDeviation>\n");
    }
  if (PointDeviations)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointDeviations");
      PointDeviations->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointDeviations>\n");
    }
  if (DatumsOk)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumsOk");
      DatumsOk->printSelf(outFile);
      fprintf(outFile, "</DatumsOk>\n");
    }
  if (DRFTransformActualId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DRFTransformActualId");
      DRFTransformActualId->printSelf(outFile);
      fprintf(outFile, "</DRFTransformActualId>\n");
    }
  if (SecondCompositeSegmentProfileMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SecondCompositeSegmentProfileMeasurement");
      SecondCompositeSegmentProfileMeasurement->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SecondCompositeSegmentProfileMeasurement>\n");
    }
  if (ThirdCompositeSegmentProfileMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ThirdCompositeSegmentProfileMeasurement");
      ThirdCompositeSegmentProfileMeasurement->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ThirdCompositeSegmentProfileMeasurement>\n");
    }
  if (FourthCompositeSegmentProfileMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FourthCompositeSegmentProfileMeasurement");
      FourthCompositeSegmentProfileMeasurement->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FourthCompositeSegmentProfileMeasurement>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SurfaceProfileCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SurfaceProfileCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SurfaceProfileCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SurfaceProfileCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SurfaceProfileCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class SurfaceProfileCharacteristicNominalType

*/

SurfaceProfileCharacteristicNominalType::SurfaceProfileCharacteristicNominalType() :
  ProfileCharacteristicNominalBaseType()
{
}

SurfaceProfileCharacteristicNominalType::SurfaceProfileCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn) :
  ProfileCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn)
{
}

SurfaceProfileCharacteristicNominalType::SurfaceProfileCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn) :
  ProfileCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn)
{
}

SurfaceProfileCharacteristicNominalType::~SurfaceProfileCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void SurfaceProfileCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SurfaceProfileCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SurfaceProfileCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SurfaceProfileCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SurfaceProfileCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SurfaceProfileCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class SurfaceProfileNonUniformCharacteristicDefinitionType

*/

SurfaceProfileNonUniformCharacteristicDefinitionType::SurfaceProfileNonUniformCharacteristicDefinitionType() :
  ProfileCharacteristicDefinitionBaseType()
{
  ToPointToleranceValue = 0;
  SurfaceProfileN_1059 = 0;
}

SurfaceProfileNonUniformCharacteristicDefinitionType::SurfaceProfileNonUniformCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 ProfileCharacte_1056_Type * ProfileCharacte_1056In,
 XmlBoolean * OffsetZoneIn,
 XmlBoolean * VariableAngleIn,
 CompositeSegmentProfileDefinitionType * SecondCompositeSegmentProfileDefinitionIn,
 CompositeSegmentProfileDefinitionType * ThirdCompositeSegmentProfileDefinitionIn,
 CompositeSegmentProfileDefinitionType * FourthCompositeSegmentProfileDefinitionIn,
 QIFReferenceFullType * DatumReferenceFrameIdIn,
 XmlBoolean * OrientationOnlyIn,
 LinearValueType * ToPointToleranceValueIn,
 SurfaceProfileN_1059_Type * SurfaceProfileN_1059In) :
  ProfileCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn,
    ToleranceValueIn,
    ToleranceDualValueIn,
    ProfileCharacte_1056In,
    OffsetZoneIn,
    VariableAngleIn,
    SecondCompositeSegmentProfileDefinitionIn,
    ThirdCompositeSegmentProfileDefinitionIn,
    FourthCompositeSegmentProfileDefinitionIn,
    DatumReferenceFrameIdIn,
    OrientationOnlyIn)
{
  ToPointToleranceValue = ToPointToleranceValueIn;
  SurfaceProfileN_1059 = SurfaceProfileN_1059In;
}

SurfaceProfileNonUniformCharacteristicDefinitionType::SurfaceProfileNonUniformCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 ProfileCharacte_1056_Type * ProfileCharacte_1056In,
 XmlBoolean * OffsetZoneIn,
 XmlBoolean * VariableAngleIn,
 CompositeSegmentProfileDefinitionType * SecondCompositeSegmentProfileDefinitionIn,
 CompositeSegmentProfileDefinitionType * ThirdCompositeSegmentProfileDefinitionIn,
 CompositeSegmentProfileDefinitionType * FourthCompositeSegmentProfileDefinitionIn,
 QIFReferenceFullType * DatumReferenceFrameIdIn,
 XmlBoolean * OrientationOnlyIn,
 LinearValueType * ToPointToleranceValueIn,
 SurfaceProfileN_1059_Type * SurfaceProfileN_1059In) :
  ProfileCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn,
    ToleranceValueIn,
    ToleranceDualValueIn,
    ProfileCharacte_1056In,
    OffsetZoneIn,
    VariableAngleIn,
    SecondCompositeSegmentProfileDefinitionIn,
    ThirdCompositeSegmentProfileDefinitionIn,
    FourthCompositeSegmentProfileDefinitionIn,
    DatumReferenceFrameIdIn,
    OrientationOnlyIn)
{
  ToPointToleranceValue = ToPointToleranceValueIn;
  SurfaceProfileN_1059 = SurfaceProfileN_1059In;
}

SurfaceProfileNonUniformCharacteristicDefinitionType::~SurfaceProfileNonUniformCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  delete ToPointToleranceValue;
  delete SurfaceProfileN_1059;
  #endif
}

void SurfaceProfileNonUniformCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (GeometricCharac_1050)
    {
  GeometricCharac_1050->printSelf(outFile);
    }
  if (DirectionFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DirectionFeature");
      DirectionFeature->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DirectionFeature>\n");
    }
  if (CollectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CollectionPlane");
      CollectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CollectionPlane>\n");
    }
  if (IntersectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IntersectionPlane");
      IntersectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</IntersectionPlane>\n");
    }
  if (OrientationPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OrientationPlane");
      OrientationPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OrientationPlane>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ToleranceValue");
  ToleranceValue->printSelf(outFile);
  fprintf(outFile, "</ToleranceValue>\n");
  if (ToleranceDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceDualValue");
      ToleranceDualValue->printSelf(outFile);
      fprintf(outFile, "</ToleranceDualValue>\n");
    }
  if (ProfileCharacte_1056)
    {
  ProfileCharacte_1056->printSelf(outFile);
    }
  if (OffsetZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OffsetZone");
      OffsetZone->printSelf(outFile);
      fprintf(outFile, "</OffsetZone>\n");
    }
  if (VariableAngle)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VariableAngle");
      VariableAngle->printSelf(outFile);
      fprintf(outFile, "</VariableAngle>\n");
    }
  if (SecondCompositeSegmentProfileDefinition)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SecondCompositeSegmentProfileDefinition");
      SecondCompositeSegmentProfileDefinition->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SecondCompositeSegmentProfileDefinition>\n");
    }
  if (ThirdCompositeSegmentProfileDefinition)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ThirdCompositeSegmentProfileDefinition");
      ThirdCompositeSegmentProfileDefinition->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ThirdCompositeSegmentProfileDefinition>\n");
    }
  if (FourthCompositeSegmentProfileDefinition)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FourthCompositeSegmentProfileDefinition");
      FourthCompositeSegmentProfileDefinition->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FourthCompositeSegmentProfileDefinition>\n");
    }
  if (DatumReferenceFrameId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumReferenceFrameId");
      DatumReferenceFrameId->printSelf(outFile);
      fprintf(outFile, "</DatumReferenceFrameId>\n");
    }
  if (OrientationOnly)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OrientationOnly");
      OrientationOnly->printSelf(outFile);
      fprintf(outFile, "</OrientationOnly>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ToPointToleranceValue");
  ToPointToleranceValue->printSelf(outFile);
  fprintf(outFile, "</ToPointToleranceValue>\n");
  if (SurfaceProfileN_1059)
    {
  SurfaceProfileN_1059->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool SurfaceProfileNonUniformCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SurfaceProfileNonUniformCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SurfaceProfileNonUniformCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SurfaceProfileNonUniformCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SurfaceProfileNonUniformCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LinearValueType * SurfaceProfileNonUniformCharacteristicDefinitionType::getToPointToleranceValue()
{return ToPointToleranceValue;}

void SurfaceProfileNonUniformCharacteristicDefinitionType::setToPointToleranceValue(LinearValueType * ToPointToleranceValueIn)
{ToPointToleranceValue = ToPointToleranceValueIn;}

SurfaceProfileN_1059_Type * SurfaceProfileNonUniformCharacteristicDefinitionType::getSurfaceProfileN_1059()
{return SurfaceProfileN_1059;}

void SurfaceProfileNonUniformCharacteristicDefinitionType::setSurfaceProfileN_1059(SurfaceProfileN_1059_Type * SurfaceProfileN_1059In)
{SurfaceProfileN_1059 = SurfaceProfileN_1059In;}

/* ***************************************************************** */

/* class SurfaceProfileNonUniformCharacteristicItemType

*/

SurfaceProfileNonUniformCharacteristicItemType::SurfaceProfileNonUniformCharacteristicItemType() :
  ProfileCharacteristicItemBaseType()
{
}

SurfaceProfileNonUniformCharacteristicItemType::SurfaceProfileNonUniformCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  ProfileCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

SurfaceProfileNonUniformCharacteristicItemType::SurfaceProfileNonUniformCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  ProfileCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

SurfaceProfileNonUniformCharacteristicItemType::~SurfaceProfileNonUniformCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void SurfaceProfileNonUniformCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool SurfaceProfileNonUniformCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SurfaceProfileNonUniformCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SurfaceProfileNonUniformCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SurfaceProfileNonUniformCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SurfaceProfileNonUniformCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class SurfaceProfileNonUniformCharacteristicMeasurementType

*/

SurfaceProfileNonUniformCharacteristicMeasurementType::SurfaceProfileNonUniformCharacteristicMeasurementType() :
  ProfileCharacteristicMeasurementBaseType()
{
}

SurfaceProfileNonUniformCharacteristicMeasurementType::SurfaceProfileNonUniformCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 LinearValueType * WorstPositiveDeviationIn,
 LinearValueType * WorstNegativeDeviationIn,
 PointDeviationsType * PointDeviationsIn,
 XmlBoolean * DatumsOkIn,
 QIFReferenceType * DRFTransformActualIdIn,
 CompositeSegmentProfileMeasurementType * SecondCompositeSegmentProfileMeasurementIn,
 CompositeSegmentProfileMeasurementType * ThirdCompositeSegmentProfileMeasurementIn,
 CompositeSegmentProfileMeasurementType * FourthCompositeSegmentProfileMeasurementIn) :
  ProfileCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn,
    WorstPositiveDeviationIn,
    WorstNegativeDeviationIn,
    PointDeviationsIn,
    DatumsOkIn,
    DRFTransformActualIdIn,
    SecondCompositeSegmentProfileMeasurementIn,
    ThirdCompositeSegmentProfileMeasurementIn,
    FourthCompositeSegmentProfileMeasurementIn)
{
}

SurfaceProfileNonUniformCharacteristicMeasurementType::SurfaceProfileNonUniformCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 LinearValueType * WorstPositiveDeviationIn,
 LinearValueType * WorstNegativeDeviationIn,
 PointDeviationsType * PointDeviationsIn,
 XmlBoolean * DatumsOkIn,
 QIFReferenceType * DRFTransformActualIdIn,
 CompositeSegmentProfileMeasurementType * SecondCompositeSegmentProfileMeasurementIn,
 CompositeSegmentProfileMeasurementType * ThirdCompositeSegmentProfileMeasurementIn,
 CompositeSegmentProfileMeasurementType * FourthCompositeSegmentProfileMeasurementIn) :
  ProfileCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn,
    WorstPositiveDeviationIn,
    WorstNegativeDeviationIn,
    PointDeviationsIn,
    DatumsOkIn,
    DRFTransformActualIdIn,
    SecondCompositeSegmentProfileMeasurementIn,
    ThirdCompositeSegmentProfileMeasurementIn,
    FourthCompositeSegmentProfileMeasurementIn)
{
}

SurfaceProfileNonUniformCharacteristicMeasurementType::~SurfaceProfileNonUniformCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void SurfaceProfileNonUniformCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  if (WorstPositiveDeviation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WorstPositiveDeviation");
      WorstPositiveDeviation->printSelf(outFile);
      fprintf(outFile, "</WorstPositiveDeviation>\n");
    }
  if (WorstNegativeDeviation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WorstNegativeDeviation");
      WorstNegativeDeviation->printSelf(outFile);
      fprintf(outFile, "</WorstNegativeDeviation>\n");
    }
  if (PointDeviations)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointDeviations");
      PointDeviations->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointDeviations>\n");
    }
  if (DatumsOk)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumsOk");
      DatumsOk->printSelf(outFile);
      fprintf(outFile, "</DatumsOk>\n");
    }
  if (DRFTransformActualId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DRFTransformActualId");
      DRFTransformActualId->printSelf(outFile);
      fprintf(outFile, "</DRFTransformActualId>\n");
    }
  if (SecondCompositeSegmentProfileMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SecondCompositeSegmentProfileMeasurement");
      SecondCompositeSegmentProfileMeasurement->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SecondCompositeSegmentProfileMeasurement>\n");
    }
  if (ThirdCompositeSegmentProfileMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ThirdCompositeSegmentProfileMeasurement");
      ThirdCompositeSegmentProfileMeasurement->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ThirdCompositeSegmentProfileMeasurement>\n");
    }
  if (FourthCompositeSegmentProfileMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FourthCompositeSegmentProfileMeasurement");
      FourthCompositeSegmentProfileMeasurement->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FourthCompositeSegmentProfileMeasurement>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SurfaceProfileNonUniformCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SurfaceProfileNonUniformCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SurfaceProfileNonUniformCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SurfaceProfileNonUniformCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SurfaceProfileNonUniformCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class SurfaceProfileNonUniformCharacteristicNominalType

*/

SurfaceProfileNonUniformCharacteristicNominalType::SurfaceProfileNonUniformCharacteristicNominalType() :
  ProfileCharacteristicNominalBaseType()
{
}

SurfaceProfileNonUniformCharacteristicNominalType::SurfaceProfileNonUniformCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn) :
  ProfileCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn)
{
}

SurfaceProfileNonUniformCharacteristicNominalType::SurfaceProfileNonUniformCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn) :
  ProfileCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn)
{
}

SurfaceProfileNonUniformCharacteristicNominalType::~SurfaceProfileNonUniformCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void SurfaceProfileNonUniformCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SurfaceProfileNonUniformCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SurfaceProfileNonUniformCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SurfaceProfileNonUniformCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SurfaceProfileNonUniformCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SurfaceProfileNonUniformCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class SurfaceTextureCharacteristicDefinitionType

*/

SurfaceTextureCharacteristicDefinitionType::SurfaceTextureCharacteristicDefinitionType() :
  CharacteristicDefinitionBaseType()
{
  RoughnessAverage = 0;
}

SurfaceTextureCharacteristicDefinitionType::SurfaceTextureCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 LinearValueType * RoughnessAverageIn) :
  CharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
  RoughnessAverage = RoughnessAverageIn;
}

SurfaceTextureCharacteristicDefinitionType::SurfaceTextureCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 LinearValueType * RoughnessAverageIn) :
  CharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
  RoughnessAverage = RoughnessAverageIn;
}

SurfaceTextureCharacteristicDefinitionType::~SurfaceTextureCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  delete RoughnessAverage;
  #endif
}

void SurfaceTextureCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<RoughnessAverage");
  RoughnessAverage->printSelf(outFile);
  fprintf(outFile, "</RoughnessAverage>\n");
  doSpaces(-INDENT, outFile);
}

bool SurfaceTextureCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SurfaceTextureCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SurfaceTextureCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SurfaceTextureCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SurfaceTextureCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LinearValueType * SurfaceTextureCharacteristicDefinitionType::getRoughnessAverage()
{return RoughnessAverage;}

void SurfaceTextureCharacteristicDefinitionType::setRoughnessAverage(LinearValueType * RoughnessAverageIn)
{RoughnessAverage = RoughnessAverageIn;}

/* ***************************************************************** */

/* class SurfaceTextureCharacteristicItemType

*/

SurfaceTextureCharacteristicItemType::SurfaceTextureCharacteristicItemType() :
  CharacteristicItemBaseType()
{
}

SurfaceTextureCharacteristicItemType::SurfaceTextureCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  CharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

SurfaceTextureCharacteristicItemType::SurfaceTextureCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  CharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

SurfaceTextureCharacteristicItemType::~SurfaceTextureCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void SurfaceTextureCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool SurfaceTextureCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SurfaceTextureCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SurfaceTextureCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SurfaceTextureCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SurfaceTextureCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class SurfaceTextureCharacteristicMeasurementType

*/

SurfaceTextureCharacteristicMeasurementType::SurfaceTextureCharacteristicMeasurementType() :
  CharacteristicMeasurementBaseType()
{
  RoughnessAverageValue = 0;
}

SurfaceTextureCharacteristicMeasurementType::SurfaceTextureCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * RoughnessAverageValueIn) :
  CharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  RoughnessAverageValue = RoughnessAverageValueIn;
}

SurfaceTextureCharacteristicMeasurementType::SurfaceTextureCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * RoughnessAverageValueIn) :
  CharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  RoughnessAverageValue = RoughnessAverageValueIn;
}

SurfaceTextureCharacteristicMeasurementType::~SurfaceTextureCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  delete RoughnessAverageValue;
  #endif
}

void SurfaceTextureCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (RoughnessAverageValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<RoughnessAverageValue");
      RoughnessAverageValue->printSelf(outFile);
      fprintf(outFile, "</RoughnessAverageValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SurfaceTextureCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SurfaceTextureCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SurfaceTextureCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SurfaceTextureCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SurfaceTextureCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredLinearValueType * SurfaceTextureCharacteristicMeasurementType::getRoughnessAverageValue()
{return RoughnessAverageValue;}

void SurfaceTextureCharacteristicMeasurementType::setRoughnessAverageValue(MeasuredLinearValueType * RoughnessAverageValueIn)
{RoughnessAverageValue = RoughnessAverageValueIn;}

/* ***************************************************************** */

/* class SurfaceTextureCharacteristicNominalType

*/

SurfaceTextureCharacteristicNominalType::SurfaceTextureCharacteristicNominalType() :
  CharacteristicNominalBaseType()
{
  Obtention = 0;
  Applicability = 0;
  MinimumMaterialRemoval = 0;
  ProductionMethod = 0;
  Cutoff = 0;
  SecondaryRoughnessParameter = 0;
  DirectionOfLay = 0;
  OtherSurfaceParameter = 0;
}

SurfaceTextureCharacteristicNominalType::SurfaceTextureCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 RoughnessObtentionEnumType * ObtentionIn,
 RoughnessApplicabilityEnumType * ApplicabilityIn,
 XmlToken * MinimumMaterialRemovalIn,
 XmlToken * ProductionMethodIn,
 LinearValueType * CutoffIn,
 LinearValueType * SecondaryRoughnessParameterIn,
 RoughnessLayEnumType * DirectionOfLayIn,
 XmlToken * OtherSurfaceParameterIn) :
  CharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  Obtention = ObtentionIn;
  Applicability = ApplicabilityIn;
  MinimumMaterialRemoval = MinimumMaterialRemovalIn;
  ProductionMethod = ProductionMethodIn;
  Cutoff = CutoffIn;
  SecondaryRoughnessParameter = SecondaryRoughnessParameterIn;
  DirectionOfLay = DirectionOfLayIn;
  OtherSurfaceParameter = OtherSurfaceParameterIn;
}

SurfaceTextureCharacteristicNominalType::SurfaceTextureCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 RoughnessObtentionEnumType * ObtentionIn,
 RoughnessApplicabilityEnumType * ApplicabilityIn,
 XmlToken * MinimumMaterialRemovalIn,
 XmlToken * ProductionMethodIn,
 LinearValueType * CutoffIn,
 LinearValueType * SecondaryRoughnessParameterIn,
 RoughnessLayEnumType * DirectionOfLayIn,
 XmlToken * OtherSurfaceParameterIn) :
  CharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  Obtention = ObtentionIn;
  Applicability = ApplicabilityIn;
  MinimumMaterialRemoval = MinimumMaterialRemovalIn;
  ProductionMethod = ProductionMethodIn;
  Cutoff = CutoffIn;
  SecondaryRoughnessParameter = SecondaryRoughnessParameterIn;
  DirectionOfLay = DirectionOfLayIn;
  OtherSurfaceParameter = OtherSurfaceParameterIn;
}

SurfaceTextureCharacteristicNominalType::~SurfaceTextureCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  delete Obtention;
  delete Applicability;
  delete MinimumMaterialRemoval;
  delete ProductionMethod;
  delete Cutoff;
  delete SecondaryRoughnessParameter;
  delete DirectionOfLay;
  delete OtherSurfaceParameter;
  #endif
}

void SurfaceTextureCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (Obtention)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Obtention");
      Obtention->printSelf(outFile);
      fprintf(outFile, "</Obtention>\n");
    }
  if (Applicability)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Applicability");
      Applicability->printSelf(outFile);
      fprintf(outFile, "</Applicability>\n");
    }
  if (MinimumMaterialRemoval)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinimumMaterialRemoval");
      MinimumMaterialRemoval->printSelf(outFile);
      fprintf(outFile, "</MinimumMaterialRemoval>\n");
    }
  if (ProductionMethod)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProductionMethod");
      ProductionMethod->printSelf(outFile);
      fprintf(outFile, "</ProductionMethod>\n");
    }
  if (Cutoff)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Cutoff");
      Cutoff->printSelf(outFile);
      fprintf(outFile, "</Cutoff>\n");
    }
  if (SecondaryRoughnessParameter)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SecondaryRoughnessParameter");
      SecondaryRoughnessParameter->printSelf(outFile);
      fprintf(outFile, "</SecondaryRoughnessParameter>\n");
    }
  if (DirectionOfLay)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DirectionOfLay");
      DirectionOfLay->printSelf(outFile);
      fprintf(outFile, "</DirectionOfLay>\n");
    }
  if (OtherSurfaceParameter)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OtherSurfaceParameter");
      OtherSurfaceParameter->printSelf(outFile);
      fprintf(outFile, "</OtherSurfaceParameter>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SurfaceTextureCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SurfaceTextureCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SurfaceTextureCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SurfaceTextureCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SurfaceTextureCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

RoughnessObtentionEnumType * SurfaceTextureCharacteristicNominalType::getObtention()
{return Obtention;}

void SurfaceTextureCharacteristicNominalType::setObtention(RoughnessObtentionEnumType * ObtentionIn)
{Obtention = ObtentionIn;}

RoughnessApplicabilityEnumType * SurfaceTextureCharacteristicNominalType::getApplicability()
{return Applicability;}

void SurfaceTextureCharacteristicNominalType::setApplicability(RoughnessApplicabilityEnumType * ApplicabilityIn)
{Applicability = ApplicabilityIn;}

XmlToken * SurfaceTextureCharacteristicNominalType::getMinimumMaterialRemoval()
{return MinimumMaterialRemoval;}

void SurfaceTextureCharacteristicNominalType::setMinimumMaterialRemoval(XmlToken * MinimumMaterialRemovalIn)
{MinimumMaterialRemoval = MinimumMaterialRemovalIn;}

XmlToken * SurfaceTextureCharacteristicNominalType::getProductionMethod()
{return ProductionMethod;}

void SurfaceTextureCharacteristicNominalType::setProductionMethod(XmlToken * ProductionMethodIn)
{ProductionMethod = ProductionMethodIn;}

LinearValueType * SurfaceTextureCharacteristicNominalType::getCutoff()
{return Cutoff;}

void SurfaceTextureCharacteristicNominalType::setCutoff(LinearValueType * CutoffIn)
{Cutoff = CutoffIn;}

LinearValueType * SurfaceTextureCharacteristicNominalType::getSecondaryRoughnessParameter()
{return SecondaryRoughnessParameter;}

void SurfaceTextureCharacteristicNominalType::setSecondaryRoughnessParameter(LinearValueType * SecondaryRoughnessParameterIn)
{SecondaryRoughnessParameter = SecondaryRoughnessParameterIn;}

RoughnessLayEnumType * SurfaceTextureCharacteristicNominalType::getDirectionOfLay()
{return DirectionOfLay;}

void SurfaceTextureCharacteristicNominalType::setDirectionOfLay(RoughnessLayEnumType * DirectionOfLayIn)
{DirectionOfLay = DirectionOfLayIn;}

XmlToken * SurfaceTextureCharacteristicNominalType::getOtherSurfaceParameter()
{return OtherSurfaceParameter;}

void SurfaceTextureCharacteristicNominalType::setOtherSurfaceParameter(XmlToken * OtherSurfaceParameterIn)
{OtherSurfaceParameter = OtherSurfaceParameterIn;}

/* ***************************************************************** */

/* class SymmetryCharacteristicDefinitionType

*/

SymmetryCharacteristicDefinitionType::SymmetryCharacteristicDefinitionType() :
  LocationCharacteristicDefinitionBaseType()
{
  SecondCompositeSegmentSymmetryDefinition = 0;
  ThirdCompositeSegmentSymmetryDefinition = 0;
}

SymmetryCharacteristicDefinitionType::SymmetryCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 QIFReferenceFullType * DatumReferenceFrameIdIn,
 CompositeSegmentSymmetryDefinitionType * SecondCompositeSegmentSymmetryDefinitionIn,
 CompositeSegmentSymmetryDefinitionType * ThirdCompositeSegmentSymmetryDefinitionIn) :
  LocationCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn,
    ToleranceValueIn,
    ToleranceDualValueIn,
    DatumReferenceFrameIdIn)
{
  SecondCompositeSegmentSymmetryDefinition = SecondCompositeSegmentSymmetryDefinitionIn;
  ThirdCompositeSegmentSymmetryDefinition = ThirdCompositeSegmentSymmetryDefinitionIn;
}

SymmetryCharacteristicDefinitionType::SymmetryCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 QIFReferenceFullType * DatumReferenceFrameIdIn,
 CompositeSegmentSymmetryDefinitionType * SecondCompositeSegmentSymmetryDefinitionIn,
 CompositeSegmentSymmetryDefinitionType * ThirdCompositeSegmentSymmetryDefinitionIn) :
  LocationCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn,
    ToleranceValueIn,
    ToleranceDualValueIn,
    DatumReferenceFrameIdIn)
{
  SecondCompositeSegmentSymmetryDefinition = SecondCompositeSegmentSymmetryDefinitionIn;
  ThirdCompositeSegmentSymmetryDefinition = ThirdCompositeSegmentSymmetryDefinitionIn;
}

SymmetryCharacteristicDefinitionType::~SymmetryCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  delete SecondCompositeSegmentSymmetryDefinition;
  delete ThirdCompositeSegmentSymmetryDefinition;
  #endif
}

void SymmetryCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (GeometricCharac_1050)
    {
  GeometricCharac_1050->printSelf(outFile);
    }
  if (DirectionFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DirectionFeature");
      DirectionFeature->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DirectionFeature>\n");
    }
  if (CollectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CollectionPlane");
      CollectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CollectionPlane>\n");
    }
  if (IntersectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IntersectionPlane");
      IntersectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</IntersectionPlane>\n");
    }
  if (OrientationPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OrientationPlane");
      OrientationPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OrientationPlane>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ToleranceValue");
  ToleranceValue->printSelf(outFile);
  fprintf(outFile, "</ToleranceValue>\n");
  if (ToleranceDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceDualValue");
      ToleranceDualValue->printSelf(outFile);
      fprintf(outFile, "</ToleranceDualValue>\n");
    }
  if (DatumReferenceFrameId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumReferenceFrameId");
      DatumReferenceFrameId->printSelf(outFile);
      fprintf(outFile, "</DatumReferenceFrameId>\n");
    }
  if (SecondCompositeSegmentSymmetryDefinition)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SecondCompositeSegmentSymmetryDefinition");
      SecondCompositeSegmentSymmetryDefinition->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SecondCompositeSegmentSymmetryDefinition>\n");
    }
  if (ThirdCompositeSegmentSymmetryDefinition)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ThirdCompositeSegmentSymmetryDefinition");
      ThirdCompositeSegmentSymmetryDefinition->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ThirdCompositeSegmentSymmetryDefinition>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SymmetryCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SymmetryCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SymmetryCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SymmetryCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SymmetryCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

CompositeSegmentSymmetryDefinitionType * SymmetryCharacteristicDefinitionType::getSecondCompositeSegmentSymmetryDefinition()
{return SecondCompositeSegmentSymmetryDefinition;}

void SymmetryCharacteristicDefinitionType::setSecondCompositeSegmentSymmetryDefinition(CompositeSegmentSymmetryDefinitionType * SecondCompositeSegmentSymmetryDefinitionIn)
{SecondCompositeSegmentSymmetryDefinition = SecondCompositeSegmentSymmetryDefinitionIn;}

CompositeSegmentSymmetryDefinitionType * SymmetryCharacteristicDefinitionType::getThirdCompositeSegmentSymmetryDefinition()
{return ThirdCompositeSegmentSymmetryDefinition;}

void SymmetryCharacteristicDefinitionType::setThirdCompositeSegmentSymmetryDefinition(CompositeSegmentSymmetryDefinitionType * ThirdCompositeSegmentSymmetryDefinitionIn)
{ThirdCompositeSegmentSymmetryDefinition = ThirdCompositeSegmentSymmetryDefinitionIn;}

/* ***************************************************************** */

/* class SymmetryCharacteristicItemType

*/

SymmetryCharacteristicItemType::SymmetryCharacteristicItemType() :
  LocationCharacteristicItemBaseType()
{
}

SymmetryCharacteristicItemType::SymmetryCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LocationCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

SymmetryCharacteristicItemType::SymmetryCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LocationCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

SymmetryCharacteristicItemType::~SymmetryCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void SymmetryCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool SymmetryCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SymmetryCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SymmetryCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SymmetryCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SymmetryCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class SymmetryCharacteristicMeasurementType

*/

SymmetryCharacteristicMeasurementType::SymmetryCharacteristicMeasurementType() :
  LocationCharacteristicMeasurementBaseType()
{
  SecondCompositeSegmentSymmetryMeasurement = 0;
  ThirdCompositeSegmentSymmetryMeasurement = 0;
}

SymmetryCharacteristicMeasurementType::SymmetryCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 ZoneDataSetType * ZoneDataSetIn,
 XmlBoolean * DatumsOkIn,
 CompositeSegmentSymmetryMeasurementType * SecondCompositeSegmentSymmetryMeasurementIn,
 CompositeSegmentSymmetryMeasurementType * ThirdCompositeSegmentSymmetryMeasurementIn) :
  LocationCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn,
    ZoneDataSetIn,
    DatumsOkIn)
{
  SecondCompositeSegmentSymmetryMeasurement = SecondCompositeSegmentSymmetryMeasurementIn;
  ThirdCompositeSegmentSymmetryMeasurement = ThirdCompositeSegmentSymmetryMeasurementIn;
}

SymmetryCharacteristicMeasurementType::SymmetryCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 ZoneDataSetType * ZoneDataSetIn,
 XmlBoolean * DatumsOkIn,
 CompositeSegmentSymmetryMeasurementType * SecondCompositeSegmentSymmetryMeasurementIn,
 CompositeSegmentSymmetryMeasurementType * ThirdCompositeSegmentSymmetryMeasurementIn) :
  LocationCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn,
    ZoneDataSetIn,
    DatumsOkIn)
{
  SecondCompositeSegmentSymmetryMeasurement = SecondCompositeSegmentSymmetryMeasurementIn;
  ThirdCompositeSegmentSymmetryMeasurement = ThirdCompositeSegmentSymmetryMeasurementIn;
}

SymmetryCharacteristicMeasurementType::~SymmetryCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  delete SecondCompositeSegmentSymmetryMeasurement;
  delete ThirdCompositeSegmentSymmetryMeasurement;
  #endif
}

void SymmetryCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  if (ZoneDataSet)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ZoneDataSet");
      ZoneDataSet->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ZoneDataSet>\n");
    }
  if (DatumsOk)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumsOk");
      DatumsOk->printSelf(outFile);
      fprintf(outFile, "</DatumsOk>\n");
    }
  if (SecondCompositeSegmentSymmetryMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SecondCompositeSegmentSymmetryMeasurement");
      SecondCompositeSegmentSymmetryMeasurement->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SecondCompositeSegmentSymmetryMeasurement>\n");
    }
  if (ThirdCompositeSegmentSymmetryMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ThirdCompositeSegmentSymmetryMeasurement");
      ThirdCompositeSegmentSymmetryMeasurement->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ThirdCompositeSegmentSymmetryMeasurement>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SymmetryCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SymmetryCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SymmetryCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SymmetryCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SymmetryCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

CompositeSegmentSymmetryMeasurementType * SymmetryCharacteristicMeasurementType::getSecondCompositeSegmentSymmetryMeasurement()
{return SecondCompositeSegmentSymmetryMeasurement;}

void SymmetryCharacteristicMeasurementType::setSecondCompositeSegmentSymmetryMeasurement(CompositeSegmentSymmetryMeasurementType * SecondCompositeSegmentSymmetryMeasurementIn)
{SecondCompositeSegmentSymmetryMeasurement = SecondCompositeSegmentSymmetryMeasurementIn;}

CompositeSegmentSymmetryMeasurementType * SymmetryCharacteristicMeasurementType::getThirdCompositeSegmentSymmetryMeasurement()
{return ThirdCompositeSegmentSymmetryMeasurement;}

void SymmetryCharacteristicMeasurementType::setThirdCompositeSegmentSymmetryMeasurement(CompositeSegmentSymmetryMeasurementType * ThirdCompositeSegmentSymmetryMeasurementIn)
{ThirdCompositeSegmentSymmetryMeasurement = ThirdCompositeSegmentSymmetryMeasurementIn;}

/* ***************************************************************** */

/* class SymmetryCharacteristicNominalType

*/

SymmetryCharacteristicNominalType::SymmetryCharacteristicNominalType() :
  LocationCharacteristicNominalBaseType()
{
}

SymmetryCharacteristicNominalType::SymmetryCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  LocationCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

SymmetryCharacteristicNominalType::SymmetryCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  LocationCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

SymmetryCharacteristicNominalType::~SymmetryCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void SymmetryCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SymmetryCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SymmetryCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SymmetryCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SymmetryCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SymmetryCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class TemperatureCharacteristicDefinitionBaseType

*/

TemperatureCharacteristicDefinitionBaseType::TemperatureCharacteristicDefinitionBaseType() :
  CharacteristicDefinitionBaseType()
{
  TemperatureCharacteristicDefinitionBaseTypePair = 0;
}

TemperatureCharacteristicDefinitionBaseType::TemperatureCharacteristicDefinitionBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 TemperatureCharacteristicDefinitionBaseTypeChoicePair * TemperatureCharacteristicDefinitionBaseTypePairIn) :
  CharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
  TemperatureCharacteristicDefinitionBaseTypePair = TemperatureCharacteristicDefinitionBaseTypePairIn;
}

TemperatureCharacteristicDefinitionBaseType::TemperatureCharacteristicDefinitionBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 TemperatureCharacteristicDefinitionBaseTypeChoicePair * TemperatureCharacteristicDefinitionBaseTypePairIn) :
  CharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
  TemperatureCharacteristicDefinitionBaseTypePair = TemperatureCharacteristicDefinitionBaseTypePairIn;
}

TemperatureCharacteristicDefinitionBaseType::~TemperatureCharacteristicDefinitionBaseType()
{
  #ifndef NODESTRUCT
  delete TemperatureCharacteristicDefinitionBaseTypePair;
  #endif
}

void TemperatureCharacteristicDefinitionBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  TemperatureCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}
TemperatureCharacteristicDefinitionBaseTypeChoicePair * TemperatureCharacteristicDefinitionBaseType::getTemperatureCharacteristicDefinitionBaseTypeChoicePair()
{return TemperatureCharacteristicDefinitionBaseTypePair;}

void TemperatureCharacteristicDefinitionBaseType::setTemperatureCharacteristicDefinitionBaseTypeChoicePair(TemperatureCharacteristicDefinitionBaseTypeChoicePair * TemperatureCharacteristicDefinitionBaseTypePairIn)
{TemperatureCharacteristicDefinitionBaseTypePair = TemperatureCharacteristicDefinitionBaseTypePairIn;}

/* ***************************************************************** */

TemperatureCharacteristicDefinitionBaseTypeChoicePair::TemperatureCharacteristicDefinitionBaseTypeChoicePair() {}

TemperatureCharacteristicDefinitionBaseTypeChoicePair::TemperatureCharacteristicDefinitionBaseTypeChoicePair(
 whichOne TemperatureCharacteristicDefinitionBaseTypeTypeIn,
 TemperatureCharacteristicDefinitionBaseTypeVal TemperatureCharacteristicDefinitionBaseTypeValueIn)
{
  TemperatureCharacteristicDefinitionBaseTypeType = TemperatureCharacteristicDefinitionBaseTypeTypeIn;
  TemperatureCharacteristicDefinitionBaseTypeValue = TemperatureCharacteristicDefinitionBaseTypeValueIn;
}

TemperatureCharacteristicDefinitionBaseTypeChoicePair::~TemperatureCharacteristicDefinitionBaseTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (TemperatureCharacteristicDefinitionBaseTypeType == ToleranceE)
    delete TemperatureCharacteristicDefinitionBaseTypeValue.Tolerance;
  else if (TemperatureCharacteristicDefinitionBaseTypeType == NonToleranceE)
    delete TemperatureCharacteristicDefinitionBaseTypeValue.NonTolerance;
  #endif
}

void TemperatureCharacteristicDefinitionBaseTypeChoicePair::printSelf(FILE * outFile)
{
  if (TemperatureCharacteristicDefinitionBaseTypeType == ToleranceE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Tolerance");
      TemperatureCharacteristicDefinitionBaseTypeValue.Tolerance->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Tolerance>\n");
    }
  else if (TemperatureCharacteristicDefinitionBaseTypeType == NonToleranceE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonTolerance");
      TemperatureCharacteristicDefinitionBaseTypeValue.NonTolerance->printSelf(outFile);
      fprintf(outFile, "</NonTolerance>\n");
    }
}

bool TemperatureCharacteristicDefinitionBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in TemperatureCharacteristicDefinitionBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in TemperatureCharacteristicDefinitionBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in TemperatureCharacteristicDefinitionBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in TemperatureCharacteristicDefinitionBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class TemperatureCharacteristicItemBaseType

*/

TemperatureCharacteristicItemBaseType::TemperatureCharacteristicItemBaseType() :
  CharacteristicItemBaseType()
{
}

TemperatureCharacteristicItemBaseType::TemperatureCharacteristicItemBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  CharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

TemperatureCharacteristicItemBaseType::TemperatureCharacteristicItemBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  CharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

TemperatureCharacteristicItemBaseType::~TemperatureCharacteristicItemBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void TemperatureCharacteristicItemBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool TemperatureCharacteristicItemBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in TemperatureCharacteristicItemBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in TemperatureCharacteristicItemBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in TemperatureCharacteristicItemBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in TemperatureCharacteristicItemBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class TemperatureCharacteristicMeasurementBaseType

*/

TemperatureCharacteristicMeasurementBaseType::TemperatureCharacteristicMeasurementBaseType() :
  CharacteristicMeasurementBaseType()
{
  Value = 0;
  MaxValue = 0;
  MinValue = 0;
}

TemperatureCharacteristicMeasurementBaseType::TemperatureCharacteristicMeasurementBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredTemperatureValueType * ValueIn,
 MeasuredTemperatureValueType * MaxValueIn,
 MeasuredTemperatureValueType * MinValueIn) :
  CharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  Value = ValueIn;
  MaxValue = MaxValueIn;
  MinValue = MinValueIn;
}

TemperatureCharacteristicMeasurementBaseType::TemperatureCharacteristicMeasurementBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredTemperatureValueType * ValueIn,
 MeasuredTemperatureValueType * MaxValueIn,
 MeasuredTemperatureValueType * MinValueIn) :
  CharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  Value = ValueIn;
  MaxValue = MaxValueIn;
  MinValue = MinValueIn;
}

TemperatureCharacteristicMeasurementBaseType::~TemperatureCharacteristicMeasurementBaseType()
{
  #ifndef NODESTRUCT
  delete Value;
  delete MaxValue;
  delete MinValue;
  #endif
}

void TemperatureCharacteristicMeasurementBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool TemperatureCharacteristicMeasurementBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in TemperatureCharacteristicMeasurementBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in TemperatureCharacteristicMeasurementBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in TemperatureCharacteristicMeasurementBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in TemperatureCharacteristicMeasurementBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredTemperatureValueType * TemperatureCharacteristicMeasurementBaseType::getValue()
{return Value;}

void TemperatureCharacteristicMeasurementBaseType::setValue(MeasuredTemperatureValueType * ValueIn)
{Value = ValueIn;}

MeasuredTemperatureValueType * TemperatureCharacteristicMeasurementBaseType::getMaxValue()
{return MaxValue;}

void TemperatureCharacteristicMeasurementBaseType::setMaxValue(MeasuredTemperatureValueType * MaxValueIn)
{MaxValue = MaxValueIn;}

MeasuredTemperatureValueType * TemperatureCharacteristicMeasurementBaseType::getMinValue()
{return MinValue;}

void TemperatureCharacteristicMeasurementBaseType::setMinValue(MeasuredTemperatureValueType * MinValueIn)
{MinValue = MinValueIn;}

/* ***************************************************************** */

/* class TemperatureCharacteristicNominalBaseType

*/

TemperatureCharacteristicNominalBaseType::TemperatureCharacteristicNominalBaseType() :
  CharacteristicNominalBaseType()
{
  TargetValue = 0;
}

TemperatureCharacteristicNominalBaseType::TemperatureCharacteristicNominalBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 TemperatureValueType * TargetValueIn) :
  CharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  TargetValue = TargetValueIn;
}

TemperatureCharacteristicNominalBaseType::TemperatureCharacteristicNominalBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 TemperatureValueType * TargetValueIn) :
  CharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  TargetValue = TargetValueIn;
}

TemperatureCharacteristicNominalBaseType::~TemperatureCharacteristicNominalBaseType()
{
  #ifndef NODESTRUCT
  delete TargetValue;
  #endif
}

void TemperatureCharacteristicNominalBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool TemperatureCharacteristicNominalBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in TemperatureCharacteristicNominalBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in TemperatureCharacteristicNominalBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in TemperatureCharacteristicNominalBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in TemperatureCharacteristicNominalBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

TemperatureValueType * TemperatureCharacteristicNominalBaseType::getTargetValue()
{return TargetValue;}

void TemperatureCharacteristicNominalBaseType::setTargetValue(TemperatureValueType * TargetValueIn)
{TargetValue = TargetValueIn;}

/* ***************************************************************** */

/* class ThicknessCharacteristicDefinitionType

*/

ThicknessCharacteristicDefinitionType::ThicknessCharacteristicDefinitionType() :
  LinearCharacteristicDefinitionBaseType()
{
}

ThicknessCharacteristicDefinitionType::ThicknessCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseTypePairIn) :
  LinearCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    LinearCharacteristicDefinitionBaseTypePairIn)
{
}

ThicknessCharacteristicDefinitionType::ThicknessCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseTypePairIn) :
  LinearCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    LinearCharacteristicDefinitionBaseTypePairIn)
{
}

ThicknessCharacteristicDefinitionType::~ThicknessCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void ThicknessCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (DimensionType)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionType");
      DimensionType->printSelf(outFile);
      fprintf(outFile, "</DimensionType>\n");
    }
  if (DimensionModifiers)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionModifiers");
      DimensionModifiers->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DimensionModifiers>\n");
    }
  LinearCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

bool ThicknessCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ThicknessCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ThicknessCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ThicknessCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ThicknessCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class ThicknessCharacteristicItemType

*/

ThicknessCharacteristicItemType::ThicknessCharacteristicItemType() :
  LinearCharacteristicItemBaseType()
{
}

ThicknessCharacteristicItemType::ThicknessCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LinearCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

ThicknessCharacteristicItemType::ThicknessCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LinearCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

ThicknessCharacteristicItemType::~ThicknessCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void ThicknessCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool ThicknessCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ThicknessCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ThicknessCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ThicknessCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ThicknessCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class ThicknessCharacteristicMeasurementType

*/

ThicknessCharacteristicMeasurementType::ThicknessCharacteristicMeasurementType() :
  LinearCharacteristicMeasurementBaseType()
{
}

ThicknessCharacteristicMeasurementType::ThicknessCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  LinearCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

ThicknessCharacteristicMeasurementType::ThicknessCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  LinearCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

ThicknessCharacteristicMeasurementType::~ThicknessCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void ThicknessCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ThicknessCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ThicknessCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ThicknessCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ThicknessCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ThicknessCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class ThicknessCharacteristicNominalType

*/

ThicknessCharacteristicNominalType::ThicknessCharacteristicNominalType() :
  LinearCharacteristicNominalBaseType()
{
}

ThicknessCharacteristicNominalType::ThicknessCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn) :
  LinearCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn,
    TargetDualValueIn)
{
}

ThicknessCharacteristicNominalType::ThicknessCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn) :
  LinearCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn,
    TargetDualValueIn)
{
}

ThicknessCharacteristicNominalType::~ThicknessCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void ThicknessCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  if (TargetDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetDualValue");
      TargetDualValue->printSelf(outFile);
      fprintf(outFile, "</TargetDualValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ThicknessCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ThicknessCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ThicknessCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ThicknessCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ThicknessCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class ThreadCharacteristicDefinitionType

*/

ThreadCharacteristicDefinitionType::ThreadCharacteristicDefinitionType() :
  CharacteristicDefinitionBaseType()
{
  ThreadSpecificationId = 0;
}

ThreadCharacteristicDefinitionType::ThreadCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 QIFReferenceType * ThreadSpecificationIdIn) :
  CharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
  ThreadSpecificationId = ThreadSpecificationIdIn;
}

ThreadCharacteristicDefinitionType::ThreadCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 QIFReferenceType * ThreadSpecificationIdIn) :
  CharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
  ThreadSpecificationId = ThreadSpecificationIdIn;
}

ThreadCharacteristicDefinitionType::~ThreadCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  delete ThreadSpecificationId;
  #endif
}

void ThreadCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ThreadSpecificationId");
  ThreadSpecificationId->printSelf(outFile);
  fprintf(outFile, "</ThreadSpecificationId>\n");
  doSpaces(-INDENT, outFile);
}

bool ThreadCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ThreadCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ThreadCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ThreadCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ThreadCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

QIFReferenceType * ThreadCharacteristicDefinitionType::getThreadSpecificationId()
{return ThreadSpecificationId;}

void ThreadCharacteristicDefinitionType::setThreadSpecificationId(QIFReferenceType * ThreadSpecificationIdIn)
{ThreadSpecificationId = ThreadSpecificationIdIn;}

/* ***************************************************************** */

/* class ThreadCharacteristicItemType

*/

ThreadCharacteristicItemType::ThreadCharacteristicItemType() :
  CharacteristicItemBaseType()
{
}

ThreadCharacteristicItemType::ThreadCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  CharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

ThreadCharacteristicItemType::ThreadCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  CharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

ThreadCharacteristicItemType::~ThreadCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void ThreadCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool ThreadCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ThreadCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ThreadCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ThreadCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ThreadCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class ThreadCharacteristicMeasurementType

*/

ThreadCharacteristicMeasurementType::ThreadCharacteristicMeasurementType() :
  CharacteristicMeasurementBaseType()
{
  PitchDiameter = 0;
  FunctionalSize = 0;
}

ThreadCharacteristicMeasurementType::ThreadCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * PitchDiameterIn,
 MeasuredLinearValueType * FunctionalSizeIn) :
  CharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  PitchDiameter = PitchDiameterIn;
  FunctionalSize = FunctionalSizeIn;
}

ThreadCharacteristicMeasurementType::ThreadCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * PitchDiameterIn,
 MeasuredLinearValueType * FunctionalSizeIn) :
  CharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  PitchDiameter = PitchDiameterIn;
  FunctionalSize = FunctionalSizeIn;
}

ThreadCharacteristicMeasurementType::~ThreadCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  delete PitchDiameter;
  delete FunctionalSize;
  #endif
}

void ThreadCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (PitchDiameter)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PitchDiameter");
      PitchDiameter->printSelf(outFile);
      fprintf(outFile, "</PitchDiameter>\n");
    }
  if (FunctionalSize)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FunctionalSize");
      FunctionalSize->printSelf(outFile);
      fprintf(outFile, "</FunctionalSize>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ThreadCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ThreadCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ThreadCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ThreadCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ThreadCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredLinearValueType * ThreadCharacteristicMeasurementType::getPitchDiameter()
{return PitchDiameter;}

void ThreadCharacteristicMeasurementType::setPitchDiameter(MeasuredLinearValueType * PitchDiameterIn)
{PitchDiameter = PitchDiameterIn;}

MeasuredLinearValueType * ThreadCharacteristicMeasurementType::getFunctionalSize()
{return FunctionalSize;}

void ThreadCharacteristicMeasurementType::setFunctionalSize(MeasuredLinearValueType * FunctionalSizeIn)
{FunctionalSize = FunctionalSizeIn;}

/* ***************************************************************** */

/* class ThreadCharacteristicNominalType

*/

ThreadCharacteristicNominalType::ThreadCharacteristicNominalType() :
  CharacteristicNominalBaseType()
{
}

ThreadCharacteristicNominalType::ThreadCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  CharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

ThreadCharacteristicNominalType::ThreadCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  CharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

ThreadCharacteristicNominalType::~ThreadCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void ThreadCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ThreadCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ThreadCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ThreadCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ThreadCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ThreadCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class TimeCharacteristicDefinitionBaseType

*/

TimeCharacteristicDefinitionBaseType::TimeCharacteristicDefinitionBaseType() :
  CharacteristicDefinitionBaseType()
{
  TimeCharacteristicDefinitionBaseTypePair = 0;
}

TimeCharacteristicDefinitionBaseType::TimeCharacteristicDefinitionBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 TimeCharacteristicDefinitionBaseTypeChoicePair * TimeCharacteristicDefinitionBaseTypePairIn) :
  CharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
  TimeCharacteristicDefinitionBaseTypePair = TimeCharacteristicDefinitionBaseTypePairIn;
}

TimeCharacteristicDefinitionBaseType::TimeCharacteristicDefinitionBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 TimeCharacteristicDefinitionBaseTypeChoicePair * TimeCharacteristicDefinitionBaseTypePairIn) :
  CharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
  TimeCharacteristicDefinitionBaseTypePair = TimeCharacteristicDefinitionBaseTypePairIn;
}

TimeCharacteristicDefinitionBaseType::~TimeCharacteristicDefinitionBaseType()
{
  #ifndef NODESTRUCT
  delete TimeCharacteristicDefinitionBaseTypePair;
  #endif
}

void TimeCharacteristicDefinitionBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  TimeCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}
TimeCharacteristicDefinitionBaseTypeChoicePair * TimeCharacteristicDefinitionBaseType::getTimeCharacteristicDefinitionBaseTypeChoicePair()
{return TimeCharacteristicDefinitionBaseTypePair;}

void TimeCharacteristicDefinitionBaseType::setTimeCharacteristicDefinitionBaseTypeChoicePair(TimeCharacteristicDefinitionBaseTypeChoicePair * TimeCharacteristicDefinitionBaseTypePairIn)
{TimeCharacteristicDefinitionBaseTypePair = TimeCharacteristicDefinitionBaseTypePairIn;}

/* ***************************************************************** */

TimeCharacteristicDefinitionBaseTypeChoicePair::TimeCharacteristicDefinitionBaseTypeChoicePair() {}

TimeCharacteristicDefinitionBaseTypeChoicePair::TimeCharacteristicDefinitionBaseTypeChoicePair(
 whichOne TimeCharacteristicDefinitionBaseTypeTypeIn,
 TimeCharacteristicDefinitionBaseTypeVal TimeCharacteristicDefinitionBaseTypeValueIn)
{
  TimeCharacteristicDefinitionBaseTypeType = TimeCharacteristicDefinitionBaseTypeTypeIn;
  TimeCharacteristicDefinitionBaseTypeValue = TimeCharacteristicDefinitionBaseTypeValueIn;
}

TimeCharacteristicDefinitionBaseTypeChoicePair::~TimeCharacteristicDefinitionBaseTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (TimeCharacteristicDefinitionBaseTypeType == ToleranceE)
    delete TimeCharacteristicDefinitionBaseTypeValue.Tolerance;
  else if (TimeCharacteristicDefinitionBaseTypeType == NonToleranceE)
    delete TimeCharacteristicDefinitionBaseTypeValue.NonTolerance;
  #endif
}

void TimeCharacteristicDefinitionBaseTypeChoicePair::printSelf(FILE * outFile)
{
  if (TimeCharacteristicDefinitionBaseTypeType == ToleranceE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Tolerance");
      TimeCharacteristicDefinitionBaseTypeValue.Tolerance->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Tolerance>\n");
    }
  else if (TimeCharacteristicDefinitionBaseTypeType == NonToleranceE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonTolerance");
      TimeCharacteristicDefinitionBaseTypeValue.NonTolerance->printSelf(outFile);
      fprintf(outFile, "</NonTolerance>\n");
    }
}

bool TimeCharacteristicDefinitionBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in TimeCharacteristicDefinitionBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in TimeCharacteristicDefinitionBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in TimeCharacteristicDefinitionBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in TimeCharacteristicDefinitionBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class TimeCharacteristicItemBaseType

*/

TimeCharacteristicItemBaseType::TimeCharacteristicItemBaseType() :
  CharacteristicItemBaseType()
{
}

TimeCharacteristicItemBaseType::TimeCharacteristicItemBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  CharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

TimeCharacteristicItemBaseType::TimeCharacteristicItemBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  CharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

TimeCharacteristicItemBaseType::~TimeCharacteristicItemBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void TimeCharacteristicItemBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool TimeCharacteristicItemBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in TimeCharacteristicItemBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in TimeCharacteristicItemBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in TimeCharacteristicItemBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in TimeCharacteristicItemBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class TimeCharacteristicMeasurementBaseType

*/

TimeCharacteristicMeasurementBaseType::TimeCharacteristicMeasurementBaseType() :
  CharacteristicMeasurementBaseType()
{
  Value = 0;
  MaxValue = 0;
  MinValue = 0;
}

TimeCharacteristicMeasurementBaseType::TimeCharacteristicMeasurementBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredTimeValueType * ValueIn,
 MeasuredTimeValueType * MaxValueIn,
 MeasuredTimeValueType * MinValueIn) :
  CharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  Value = ValueIn;
  MaxValue = MaxValueIn;
  MinValue = MinValueIn;
}

TimeCharacteristicMeasurementBaseType::TimeCharacteristicMeasurementBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredTimeValueType * ValueIn,
 MeasuredTimeValueType * MaxValueIn,
 MeasuredTimeValueType * MinValueIn) :
  CharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  Value = ValueIn;
  MaxValue = MaxValueIn;
  MinValue = MinValueIn;
}

TimeCharacteristicMeasurementBaseType::~TimeCharacteristicMeasurementBaseType()
{
  #ifndef NODESTRUCT
  delete Value;
  delete MaxValue;
  delete MinValue;
  #endif
}

void TimeCharacteristicMeasurementBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool TimeCharacteristicMeasurementBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in TimeCharacteristicMeasurementBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in TimeCharacteristicMeasurementBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in TimeCharacteristicMeasurementBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in TimeCharacteristicMeasurementBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredTimeValueType * TimeCharacteristicMeasurementBaseType::getValue()
{return Value;}

void TimeCharacteristicMeasurementBaseType::setValue(MeasuredTimeValueType * ValueIn)
{Value = ValueIn;}

MeasuredTimeValueType * TimeCharacteristicMeasurementBaseType::getMaxValue()
{return MaxValue;}

void TimeCharacteristicMeasurementBaseType::setMaxValue(MeasuredTimeValueType * MaxValueIn)
{MaxValue = MaxValueIn;}

MeasuredTimeValueType * TimeCharacteristicMeasurementBaseType::getMinValue()
{return MinValue;}

void TimeCharacteristicMeasurementBaseType::setMinValue(MeasuredTimeValueType * MinValueIn)
{MinValue = MinValueIn;}

/* ***************************************************************** */

/* class TimeCharacteristicNominalBaseType

*/

TimeCharacteristicNominalBaseType::TimeCharacteristicNominalBaseType() :
  CharacteristicNominalBaseType()
{
  TargetValue = 0;
}

TimeCharacteristicNominalBaseType::TimeCharacteristicNominalBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 TimeValueType * TargetValueIn) :
  CharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  TargetValue = TargetValueIn;
}

TimeCharacteristicNominalBaseType::TimeCharacteristicNominalBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 TimeValueType * TargetValueIn) :
  CharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  TargetValue = TargetValueIn;
}

TimeCharacteristicNominalBaseType::~TimeCharacteristicNominalBaseType()
{
  #ifndef NODESTRUCT
  delete TargetValue;
  #endif
}

void TimeCharacteristicNominalBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool TimeCharacteristicNominalBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in TimeCharacteristicNominalBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in TimeCharacteristicNominalBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in TimeCharacteristicNominalBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in TimeCharacteristicNominalBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

TimeValueType * TimeCharacteristicNominalBaseType::getTargetValue()
{return TargetValue;}

void TimeCharacteristicNominalBaseType::setTargetValue(TimeValueType * TargetValueIn)
{TargetValue = TargetValueIn;}

/* ***************************************************************** */

/* class ToleranceDefinitionsType

*/

ToleranceDefinitionsType::ToleranceDefinitionsType()
{
  n = 0;
  ToleranceDefinitionsTypePairs = 0;
}

ToleranceDefinitionsType::ToleranceDefinitionsType(
 ToleranceDefinitionsTypeChoicePairLisd * ToleranceDefinitionsTypePairsIn)
{
  n = 0;
  ToleranceDefinitionsTypePairs = ToleranceDefinitionsTypePairsIn;
}

ToleranceDefinitionsType::ToleranceDefinitionsType(
 NaturalType * nIn,
 ToleranceDefinitionsTypeChoicePairLisd * ToleranceDefinitionsTypePairsIn)
{
  n = nIn;
  ToleranceDefinitionsTypePairs = ToleranceDefinitionsTypePairsIn;
}

ToleranceDefinitionsType::~ToleranceDefinitionsType()
{
  #ifndef NODESTRUCT
  delete n;
  delete ToleranceDefinitionsTypePairs;
  #endif
}

void ToleranceDefinitionsType::printSelf(FILE * outFile)
{
  std::list<ToleranceDefinitionsTypeChoicePair *>::iterator iter;
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  for (iter = ToleranceDefinitionsTypePairs->begin();
       iter != ToleranceDefinitionsTypePairs->end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

ToleranceDefinitionsTypeChoicePairLisd * ToleranceDefinitionsType::getToleranceDefinitionsTypePairs()
{return ToleranceDefinitionsTypePairs;}

void ToleranceDefinitionsType::setToleranceDefinitionsTypePairs(ToleranceDefinitionsTypeChoicePairLisd * ToleranceDefinitionsTypePairsIn)
{ToleranceDefinitionsTypePairs = ToleranceDefinitionsTypePairsIn;}
ToleranceDefinitionsTypeChoicePair::ToleranceDefinitionsTypeChoicePair() {}

ToleranceDefinitionsTypeChoicePair::ToleranceDefinitionsTypeChoicePair(
 whichOne ToleranceDefinitionsTypeTypeIn,
 ToleranceDefinitionsTypeVal ToleranceDefinitionsTypeValueIn)
{
  ToleranceDefinitionsTypeType = ToleranceDefinitionsTypeTypeIn;
  ToleranceDefinitionsTypeValue = ToleranceDefinitionsTypeValueIn;
}

ToleranceDefinitionsTypeChoicePair::~ToleranceDefinitionsTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (ToleranceDefinitionsTypeType == LinearToleranceE)
    delete ToleranceDefinitionsTypeValue.LinearTolerance;
  else if (ToleranceDefinitionsTypeType == AngularToleranceE)
    delete ToleranceDefinitionsTypeValue.AngularTolerance;
  #endif
}

void ToleranceDefinitionsTypeChoicePair::printSelf(FILE * outFile)
{
  if (ToleranceDefinitionsTypeType == LinearToleranceE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LinearTolerance");
      ToleranceDefinitionsTypeValue.LinearTolerance->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LinearTolerance>\n");
    }
  else if (ToleranceDefinitionsTypeType == AngularToleranceE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AngularTolerance");
      ToleranceDefinitionsTypeValue.AngularTolerance->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</AngularTolerance>\n");
    }
}

bool ToleranceDefinitionsType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in ToleranceDefinitionsType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in ToleranceDefinitionsType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ToleranceDefinitionsType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in ToleranceDefinitionsType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * ToleranceDefinitionsType::getn()
{return n;}

void ToleranceDefinitionsType::setn(NaturalType * nIn)
{n = nIn;}

/* ***************************************************************** */

/* class ToleranceDefinitionsTypeChoicePairLisd

*/

ToleranceDefinitionsTypeChoicePairLisd::ToleranceDefinitionsTypeChoicePairLisd() {}

ToleranceDefinitionsTypeChoicePairLisd::ToleranceDefinitionsTypeChoicePairLisd(ToleranceDefinitionsTypeChoicePair * aToleranceDefinitionsTypeChoicePair)
{
  push_back(aToleranceDefinitionsTypeChoicePair);
}

ToleranceDefinitionsTypeChoicePairLisd::~ToleranceDefinitionsTypeChoicePairLisd()
{
  #ifndef NODESTRUCT
  std::list<ToleranceDefinitionsTypeChoicePair *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void ToleranceDefinitionsTypeChoicePairLisd::printSelf(FILE * outFile)
{
  std::list<ToleranceDefinitionsTypeChoicePair *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class ToroidicityCharacteristicDefinitionType

*/

ToroidicityCharacteristicDefinitionType::ToroidicityCharacteristicDefinitionType() :
  FormCharacteristicDefinitionBaseType()
{
  ToleranceValue = 0;
  ToleranceDualValue = 0;
}

ToroidicityCharacteristicDefinitionType::ToroidicityCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn) :
  FormCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn)
{
  ToleranceValue = ToleranceValueIn;
  ToleranceDualValue = ToleranceDualValueIn;
}

ToroidicityCharacteristicDefinitionType::ToroidicityCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn) :
  FormCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn)
{
  ToleranceValue = ToleranceValueIn;
  ToleranceDualValue = ToleranceDualValueIn;
}

ToroidicityCharacteristicDefinitionType::~ToroidicityCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  delete ToleranceValue;
  delete ToleranceDualValue;
  #endif
}

void ToroidicityCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (GeometricCharac_1050)
    {
  GeometricCharac_1050->printSelf(outFile);
    }
  if (DirectionFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DirectionFeature");
      DirectionFeature->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DirectionFeature>\n");
    }
  if (CollectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CollectionPlane");
      CollectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CollectionPlane>\n");
    }
  if (IntersectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IntersectionPlane");
      IntersectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</IntersectionPlane>\n");
    }
  if (OrientationPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OrientationPlane");
      OrientationPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OrientationPlane>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ToleranceValue");
  ToleranceValue->printSelf(outFile);
  fprintf(outFile, "</ToleranceValue>\n");
  if (ToleranceDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceDualValue");
      ToleranceDualValue->printSelf(outFile);
      fprintf(outFile, "</ToleranceDualValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ToroidicityCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ToroidicityCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ToroidicityCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ToroidicityCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ToroidicityCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LinearValueType * ToroidicityCharacteristicDefinitionType::getToleranceValue()
{return ToleranceValue;}

void ToroidicityCharacteristicDefinitionType::setToleranceValue(LinearValueType * ToleranceValueIn)
{ToleranceValue = ToleranceValueIn;}

LinearDualValueType * ToroidicityCharacteristicDefinitionType::getToleranceDualValue()
{return ToleranceDualValue;}

void ToroidicityCharacteristicDefinitionType::setToleranceDualValue(LinearDualValueType * ToleranceDualValueIn)
{ToleranceDualValue = ToleranceDualValueIn;}

/* ***************************************************************** */

/* class ToroidicityCharacteristicItemType

*/

ToroidicityCharacteristicItemType::ToroidicityCharacteristicItemType() :
  FormCharacteristicItemBaseType()
{
}

ToroidicityCharacteristicItemType::ToroidicityCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  FormCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

ToroidicityCharacteristicItemType::ToroidicityCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  FormCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

ToroidicityCharacteristicItemType::~ToroidicityCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void ToroidicityCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool ToroidicityCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ToroidicityCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ToroidicityCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ToroidicityCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ToroidicityCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class ToroidicityCharacteristicMeasurementType

*/

ToroidicityCharacteristicMeasurementType::ToroidicityCharacteristicMeasurementType() :
  FormCharacteristicMeasurementBaseType()
{
}

ToroidicityCharacteristicMeasurementType::ToroidicityCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  FormCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

ToroidicityCharacteristicMeasurementType::ToroidicityCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  FormCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

ToroidicityCharacteristicMeasurementType::~ToroidicityCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void ToroidicityCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ToroidicityCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ToroidicityCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ToroidicityCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ToroidicityCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ToroidicityCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class ToroidicityCharacteristicNominalType

*/

ToroidicityCharacteristicNominalType::ToroidicityCharacteristicNominalType() :
  FormCharacteristicNominalBaseType()
{
}

ToroidicityCharacteristicNominalType::ToroidicityCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  FormCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

ToroidicityCharacteristicNominalType::ToroidicityCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  FormCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

ToroidicityCharacteristicNominalType::~ToroidicityCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void ToroidicityCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ToroidicityCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ToroidicityCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ToroidicityCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ToroidicityCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ToroidicityCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class TotalRunoutCharacteristicDefinitionType

*/

TotalRunoutCharacteristicDefinitionType::TotalRunoutCharacteristicDefinitionType() :
  RunoutCharacteristicDefinitionBaseType()
{
}

TotalRunoutCharacteristicDefinitionType::TotalRunoutCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 QIFReferenceFullType * DatumReferenceFrameIdIn) :
  RunoutCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn,
    ToleranceValueIn,
    ToleranceDualValueIn,
    DatumReferenceFrameIdIn)
{
}

TotalRunoutCharacteristicDefinitionType::TotalRunoutCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 GeometricCharac_1050_Type * GeometricCharac_1050In,
 DirectionFeatureType * DirectionFeatureIn,
 CollectionPlaneType * CollectionPlaneIn,
 IntersectionPlaneType * IntersectionPlaneIn,
 OrientationPlaneType * OrientationPlaneIn,
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 QIFReferenceFullType * DatumReferenceFrameIdIn) :
  RunoutCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    GeometricCharac_1050In,
    DirectionFeatureIn,
    CollectionPlaneIn,
    IntersectionPlaneIn,
    OrientationPlaneIn,
    ToleranceValueIn,
    ToleranceDualValueIn,
    DatumReferenceFrameIdIn)
{
}

TotalRunoutCharacteristicDefinitionType::~TotalRunoutCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void TotalRunoutCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (GeometricCharac_1050)
    {
  GeometricCharac_1050->printSelf(outFile);
    }
  if (DirectionFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DirectionFeature");
      DirectionFeature->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DirectionFeature>\n");
    }
  if (CollectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CollectionPlane");
      CollectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CollectionPlane>\n");
    }
  if (IntersectionPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IntersectionPlane");
      IntersectionPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</IntersectionPlane>\n");
    }
  if (OrientationPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OrientationPlane");
      OrientationPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OrientationPlane>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ToleranceValue");
  ToleranceValue->printSelf(outFile);
  fprintf(outFile, "</ToleranceValue>\n");
  if (ToleranceDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceDualValue");
      ToleranceDualValue->printSelf(outFile);
      fprintf(outFile, "</ToleranceDualValue>\n");
    }
  if (DatumReferenceFrameId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumReferenceFrameId");
      DatumReferenceFrameId->printSelf(outFile);
      fprintf(outFile, "</DatumReferenceFrameId>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool TotalRunoutCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in TotalRunoutCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in TotalRunoutCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in TotalRunoutCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in TotalRunoutCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class TotalRunoutCharacteristicItemType

*/

TotalRunoutCharacteristicItemType::TotalRunoutCharacteristicItemType() :
  RunoutCharacteristicItemBaseType()
{
}

TotalRunoutCharacteristicItemType::TotalRunoutCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  RunoutCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

TotalRunoutCharacteristicItemType::TotalRunoutCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  RunoutCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

TotalRunoutCharacteristicItemType::~TotalRunoutCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void TotalRunoutCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool TotalRunoutCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in TotalRunoutCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in TotalRunoutCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in TotalRunoutCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in TotalRunoutCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class TotalRunoutCharacteristicMeasurementType

*/

TotalRunoutCharacteristicMeasurementType::TotalRunoutCharacteristicMeasurementType() :
  RunoutCharacteristicMeasurementBaseType()
{
}

TotalRunoutCharacteristicMeasurementType::TotalRunoutCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 XmlBoolean * DatumsOkIn) :
  RunoutCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn,
    DatumsOkIn)
{
}

TotalRunoutCharacteristicMeasurementType::TotalRunoutCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn,
 XmlBoolean * DatumsOkIn) :
  RunoutCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn,
    DatumsOkIn)
{
}

TotalRunoutCharacteristicMeasurementType::~TotalRunoutCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void TotalRunoutCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  if (DatumsOk)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumsOk");
      DatumsOk->printSelf(outFile);
      fprintf(outFile, "</DatumsOk>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool TotalRunoutCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in TotalRunoutCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in TotalRunoutCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in TotalRunoutCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in TotalRunoutCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class TotalRunoutCharacteristicNominalType

*/

TotalRunoutCharacteristicNominalType::TotalRunoutCharacteristicNominalType() :
  RunoutCharacteristicNominalBaseType()
{
}

TotalRunoutCharacteristicNominalType::TotalRunoutCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  RunoutCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

TotalRunoutCharacteristicNominalType::TotalRunoutCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn) :
  RunoutCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
}

TotalRunoutCharacteristicNominalType::~TotalRunoutCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void TotalRunoutCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool TotalRunoutCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in TotalRunoutCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in TotalRunoutCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in TotalRunoutCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in TotalRunoutCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class UserDefinedAngularCharacteristicDefinitionType

*/

UserDefinedAngularCharacteristicDefinitionType::UserDefinedAngularCharacteristicDefinitionType() :
  AngularCharacteristicDefinitionBaseType()
{
  WhatToMeasure = 0;
}

UserDefinedAngularCharacteristicDefinitionType::UserDefinedAngularCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 AngularCharacteristicDefinitionBaseTypeChoicePair * AngularCharacteristicDefinitionBaseTypePairIn,
 XmlString * WhatToMeasureIn) :
  AngularCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    AngularCharacteristicDefinitionBaseTypePairIn)
{
  WhatToMeasure = WhatToMeasureIn;
}

UserDefinedAngularCharacteristicDefinitionType::UserDefinedAngularCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 AngularCharacteristicDefinitionBaseTypeChoicePair * AngularCharacteristicDefinitionBaseTypePairIn,
 XmlString * WhatToMeasureIn) :
  AngularCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    AngularCharacteristicDefinitionBaseTypePairIn)
{
  WhatToMeasure = WhatToMeasureIn;
}

UserDefinedAngularCharacteristicDefinitionType::~UserDefinedAngularCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  delete WhatToMeasure;
  #endif
}

void UserDefinedAngularCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (DimensionType)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionType");
      DimensionType->printSelf(outFile);
      fprintf(outFile, "</DimensionType>\n");
    }
  if (DimensionModifiers)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionModifiers");
      DimensionModifiers->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DimensionModifiers>\n");
    }
  AngularCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<WhatToMeasure");
  WhatToMeasure->printSelf(outFile);
  fprintf(outFile, "</WhatToMeasure>\n");
  doSpaces(-INDENT, outFile);
}

bool UserDefinedAngularCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedAngularCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedAngularCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedAngularCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedAngularCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

XmlString * UserDefinedAngularCharacteristicDefinitionType::getWhatToMeasure()
{return WhatToMeasure;}

void UserDefinedAngularCharacteristicDefinitionType::setWhatToMeasure(XmlString * WhatToMeasureIn)
{WhatToMeasure = WhatToMeasureIn;}

/* ***************************************************************** */

/* class UserDefinedAngularCharacteristicItemType

*/

UserDefinedAngularCharacteristicItemType::UserDefinedAngularCharacteristicItemType() :
  AngularCharacteristicItemBaseType()
{
}

UserDefinedAngularCharacteristicItemType::UserDefinedAngularCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  AngularCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

UserDefinedAngularCharacteristicItemType::UserDefinedAngularCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  AngularCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

UserDefinedAngularCharacteristicItemType::~UserDefinedAngularCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void UserDefinedAngularCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool UserDefinedAngularCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedAngularCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedAngularCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedAngularCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedAngularCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class UserDefinedAngularCharacteristicMeasurementType

*/

UserDefinedAngularCharacteristicMeasurementType::UserDefinedAngularCharacteristicMeasurementType() :
  AngularCharacteristicMeasurementBaseType()
{
}

UserDefinedAngularCharacteristicMeasurementType::UserDefinedAngularCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredAngularValueType * ValueIn,
 MeasuredAngularValueType * MaxValueIn,
 MeasuredAngularValueType * MinValueIn) :
  AngularCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

UserDefinedAngularCharacteristicMeasurementType::UserDefinedAngularCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredAngularValueType * ValueIn,
 MeasuredAngularValueType * MaxValueIn,
 MeasuredAngularValueType * MinValueIn) :
  AngularCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

UserDefinedAngularCharacteristicMeasurementType::~UserDefinedAngularCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void UserDefinedAngularCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool UserDefinedAngularCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedAngularCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedAngularCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedAngularCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedAngularCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class UserDefinedAngularCharacteristicNominalType

*/

UserDefinedAngularCharacteristicNominalType::UserDefinedAngularCharacteristicNominalType() :
  AngularCharacteristicNominalBaseType()
{
}

UserDefinedAngularCharacteristicNominalType::UserDefinedAngularCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 AngularValueType * TargetValueIn) :
  AngularCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn)
{
}

UserDefinedAngularCharacteristicNominalType::UserDefinedAngularCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 AngularValueType * TargetValueIn) :
  AngularCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn)
{
}

UserDefinedAngularCharacteristicNominalType::~UserDefinedAngularCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void UserDefinedAngularCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool UserDefinedAngularCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedAngularCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedAngularCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedAngularCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedAngularCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class UserDefinedAreaCharacteristicDefinitionType

*/

UserDefinedAreaCharacteristicDefinitionType::UserDefinedAreaCharacteristicDefinitionType() :
  AreaCharacteristicDefinitionBaseType()
{
  WhatToMeasure = 0;
}

UserDefinedAreaCharacteristicDefinitionType::UserDefinedAreaCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 AreaCharacteristicDefinitionBaseTypeChoicePair * AreaCharacteristicDefinitionBaseTypePairIn,
 XmlString * WhatToMeasureIn) :
  AreaCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    AreaCharacteristicDefinitionBaseTypePairIn)
{
  WhatToMeasure = WhatToMeasureIn;
}

UserDefinedAreaCharacteristicDefinitionType::UserDefinedAreaCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 AreaCharacteristicDefinitionBaseTypeChoicePair * AreaCharacteristicDefinitionBaseTypePairIn,
 XmlString * WhatToMeasureIn) :
  AreaCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    AreaCharacteristicDefinitionBaseTypePairIn)
{
  WhatToMeasure = WhatToMeasureIn;
}

UserDefinedAreaCharacteristicDefinitionType::~UserDefinedAreaCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  delete WhatToMeasure;
  #endif
}

void UserDefinedAreaCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  AreaCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<WhatToMeasure");
  WhatToMeasure->printSelf(outFile);
  fprintf(outFile, "</WhatToMeasure>\n");
  doSpaces(-INDENT, outFile);
}

bool UserDefinedAreaCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedAreaCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedAreaCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedAreaCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedAreaCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

XmlString * UserDefinedAreaCharacteristicDefinitionType::getWhatToMeasure()
{return WhatToMeasure;}

void UserDefinedAreaCharacteristicDefinitionType::setWhatToMeasure(XmlString * WhatToMeasureIn)
{WhatToMeasure = WhatToMeasureIn;}

/* ***************************************************************** */

/* class UserDefinedAreaCharacteristicItemType

*/

UserDefinedAreaCharacteristicItemType::UserDefinedAreaCharacteristicItemType() :
  AreaCharacteristicItemBaseType()
{
}

UserDefinedAreaCharacteristicItemType::UserDefinedAreaCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  AreaCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

UserDefinedAreaCharacteristicItemType::UserDefinedAreaCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  AreaCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

UserDefinedAreaCharacteristicItemType::~UserDefinedAreaCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void UserDefinedAreaCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool UserDefinedAreaCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedAreaCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedAreaCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedAreaCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedAreaCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class UserDefinedAreaCharacteristicMeasurementType

*/

UserDefinedAreaCharacteristicMeasurementType::UserDefinedAreaCharacteristicMeasurementType() :
  AreaCharacteristicMeasurementBaseType()
{
}

UserDefinedAreaCharacteristicMeasurementType::UserDefinedAreaCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredAreaValueType * ValueIn,
 MeasuredAreaValueType * MaxValueIn,
 MeasuredAreaValueType * MinValueIn) :
  AreaCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

UserDefinedAreaCharacteristicMeasurementType::UserDefinedAreaCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredAreaValueType * ValueIn,
 MeasuredAreaValueType * MaxValueIn,
 MeasuredAreaValueType * MinValueIn) :
  AreaCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

UserDefinedAreaCharacteristicMeasurementType::~UserDefinedAreaCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void UserDefinedAreaCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool UserDefinedAreaCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedAreaCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedAreaCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedAreaCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedAreaCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class UserDefinedAreaCharacteristicNominalType

*/

UserDefinedAreaCharacteristicNominalType::UserDefinedAreaCharacteristicNominalType() :
  AreaCharacteristicNominalBaseType()
{
}

UserDefinedAreaCharacteristicNominalType::UserDefinedAreaCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 AreaValueType * TargetValueIn) :
  AreaCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn)
{
}

UserDefinedAreaCharacteristicNominalType::UserDefinedAreaCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 AreaValueType * TargetValueIn) :
  AreaCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn)
{
}

UserDefinedAreaCharacteristicNominalType::~UserDefinedAreaCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void UserDefinedAreaCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool UserDefinedAreaCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedAreaCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedAreaCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedAreaCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedAreaCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class UserDefinedAttributeCharacteristicDefinitionType

*/

UserDefinedAttributeCharacteristicDefinitionType::UserDefinedAttributeCharacteristicDefinitionType() :
  CharacteristicDefinitionBaseType()
{
  WhatToMeasure = 0;
}

UserDefinedAttributeCharacteristicDefinitionType::UserDefinedAttributeCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 XmlString * WhatToMeasureIn) :
  CharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
  WhatToMeasure = WhatToMeasureIn;
}

UserDefinedAttributeCharacteristicDefinitionType::UserDefinedAttributeCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 XmlString * WhatToMeasureIn) :
  CharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
  WhatToMeasure = WhatToMeasureIn;
}

UserDefinedAttributeCharacteristicDefinitionType::~UserDefinedAttributeCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  delete WhatToMeasure;
  #endif
}

void UserDefinedAttributeCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<WhatToMeasure");
  WhatToMeasure->printSelf(outFile);
  fprintf(outFile, "</WhatToMeasure>\n");
  doSpaces(-INDENT, outFile);
}

bool UserDefinedAttributeCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedAttributeCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedAttributeCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedAttributeCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedAttributeCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

XmlString * UserDefinedAttributeCharacteristicDefinitionType::getWhatToMeasure()
{return WhatToMeasure;}

void UserDefinedAttributeCharacteristicDefinitionType::setWhatToMeasure(XmlString * WhatToMeasureIn)
{WhatToMeasure = WhatToMeasureIn;}

/* ***************************************************************** */

/* class UserDefinedAttributeCharacteristicItemType

*/

UserDefinedAttributeCharacteristicItemType::UserDefinedAttributeCharacteristicItemType() :
  CharacteristicItemBaseType()
{
}

UserDefinedAttributeCharacteristicItemType::UserDefinedAttributeCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  CharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

UserDefinedAttributeCharacteristicItemType::UserDefinedAttributeCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  CharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

UserDefinedAttributeCharacteristicItemType::~UserDefinedAttributeCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void UserDefinedAttributeCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool UserDefinedAttributeCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedAttributeCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedAttributeCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedAttributeCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedAttributeCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class UserDefinedAttributeCharacteristicMeasurementType

*/

UserDefinedAttributeCharacteristicMeasurementType::UserDefinedAttributeCharacteristicMeasurementType() :
  CharacteristicMeasurementBaseType()
{
  Value = 0;
}

UserDefinedAttributeCharacteristicMeasurementType::UserDefinedAttributeCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 XmlString * ValueIn) :
  CharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  Value = ValueIn;
}

UserDefinedAttributeCharacteristicMeasurementType::UserDefinedAttributeCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 XmlString * ValueIn) :
  CharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  Value = ValueIn;
}

UserDefinedAttributeCharacteristicMeasurementType::~UserDefinedAttributeCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  delete Value;
  #endif
}

void UserDefinedAttributeCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool UserDefinedAttributeCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedAttributeCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedAttributeCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedAttributeCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedAttributeCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

XmlString * UserDefinedAttributeCharacteristicMeasurementType::getValue()
{return Value;}

void UserDefinedAttributeCharacteristicMeasurementType::setValue(XmlString * ValueIn)
{Value = ValueIn;}

/* ***************************************************************** */

/* class UserDefinedAttributeCharacteristicNominalType

*/

UserDefinedAttributeCharacteristicNominalType::UserDefinedAttributeCharacteristicNominalType() :
  CharacteristicNominalBaseType()
{
  PassValues = 0;
  FailValues = 0;
}

UserDefinedAttributeCharacteristicNominalType::UserDefinedAttributeCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 StringValuesType * PassValuesIn,
 StringValuesType * FailValuesIn) :
  CharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  PassValues = PassValuesIn;
  FailValues = FailValuesIn;
}

UserDefinedAttributeCharacteristicNominalType::UserDefinedAttributeCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 StringValuesType * PassValuesIn,
 StringValuesType * FailValuesIn) :
  CharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  PassValues = PassValuesIn;
  FailValues = FailValuesIn;
}

UserDefinedAttributeCharacteristicNominalType::~UserDefinedAttributeCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  delete PassValues;
  delete FailValues;
  #endif
}

void UserDefinedAttributeCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (PassValues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PassValues");
      PassValues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PassValues>\n");
    }
  if (FailValues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FailValues");
      FailValues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FailValues>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool UserDefinedAttributeCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedAttributeCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedAttributeCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedAttributeCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedAttributeCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

StringValuesType * UserDefinedAttributeCharacteristicNominalType::getPassValues()
{return PassValues;}

void UserDefinedAttributeCharacteristicNominalType::setPassValues(StringValuesType * PassValuesIn)
{PassValues = PassValuesIn;}

StringValuesType * UserDefinedAttributeCharacteristicNominalType::getFailValues()
{return FailValues;}

void UserDefinedAttributeCharacteristicNominalType::setFailValues(StringValuesType * FailValuesIn)
{FailValues = FailValuesIn;}

/* ***************************************************************** */

/* class UserDefinedForceCharacteristicDefinitionType

*/

UserDefinedForceCharacteristicDefinitionType::UserDefinedForceCharacteristicDefinitionType() :
  ForceCharacteristicDefinitionBaseType()
{
  WhatToMeasure = 0;
}

UserDefinedForceCharacteristicDefinitionType::UserDefinedForceCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 ForceCharacteristicDefinitionBaseTypeChoicePair * ForceCharacteristicDefinitionBaseTypePairIn,
 XmlString * WhatToMeasureIn) :
  ForceCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    ForceCharacteristicDefinitionBaseTypePairIn)
{
  WhatToMeasure = WhatToMeasureIn;
}

UserDefinedForceCharacteristicDefinitionType::UserDefinedForceCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 ForceCharacteristicDefinitionBaseTypeChoicePair * ForceCharacteristicDefinitionBaseTypePairIn,
 XmlString * WhatToMeasureIn) :
  ForceCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    ForceCharacteristicDefinitionBaseTypePairIn)
{
  WhatToMeasure = WhatToMeasureIn;
}

UserDefinedForceCharacteristicDefinitionType::~UserDefinedForceCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  delete WhatToMeasure;
  #endif
}

void UserDefinedForceCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  ForceCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<WhatToMeasure");
  WhatToMeasure->printSelf(outFile);
  fprintf(outFile, "</WhatToMeasure>\n");
  doSpaces(-INDENT, outFile);
}

bool UserDefinedForceCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedForceCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedForceCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedForceCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedForceCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

XmlString * UserDefinedForceCharacteristicDefinitionType::getWhatToMeasure()
{return WhatToMeasure;}

void UserDefinedForceCharacteristicDefinitionType::setWhatToMeasure(XmlString * WhatToMeasureIn)
{WhatToMeasure = WhatToMeasureIn;}

/* ***************************************************************** */

/* class UserDefinedForceCharacteristicItemType

*/

UserDefinedForceCharacteristicItemType::UserDefinedForceCharacteristicItemType() :
  ForceCharacteristicItemBaseType()
{
}

UserDefinedForceCharacteristicItemType::UserDefinedForceCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  ForceCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

UserDefinedForceCharacteristicItemType::UserDefinedForceCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  ForceCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

UserDefinedForceCharacteristicItemType::~UserDefinedForceCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void UserDefinedForceCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool UserDefinedForceCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedForceCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedForceCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedForceCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedForceCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class UserDefinedForceCharacteristicMeasurementType

*/

UserDefinedForceCharacteristicMeasurementType::UserDefinedForceCharacteristicMeasurementType() :
  ForceCharacteristicMeasurementBaseType()
{
}

UserDefinedForceCharacteristicMeasurementType::UserDefinedForceCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredForceValueType * ValueIn,
 MeasuredForceValueType * MaxValueIn,
 MeasuredForceValueType * MinValueIn) :
  ForceCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

UserDefinedForceCharacteristicMeasurementType::UserDefinedForceCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredForceValueType * ValueIn,
 MeasuredForceValueType * MaxValueIn,
 MeasuredForceValueType * MinValueIn) :
  ForceCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

UserDefinedForceCharacteristicMeasurementType::~UserDefinedForceCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void UserDefinedForceCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool UserDefinedForceCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedForceCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedForceCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedForceCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedForceCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class UserDefinedForceCharacteristicNominalType

*/

UserDefinedForceCharacteristicNominalType::UserDefinedForceCharacteristicNominalType() :
  ForceCharacteristicNominalBaseType()
{
}

UserDefinedForceCharacteristicNominalType::UserDefinedForceCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ForceValueType * TargetValueIn) :
  ForceCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn)
{
}

UserDefinedForceCharacteristicNominalType::UserDefinedForceCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ForceValueType * TargetValueIn) :
  ForceCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn)
{
}

UserDefinedForceCharacteristicNominalType::~UserDefinedForceCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void UserDefinedForceCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool UserDefinedForceCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedForceCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedForceCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedForceCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedForceCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class UserDefinedLinearCharacteristicDefinitionType

*/

UserDefinedLinearCharacteristicDefinitionType::UserDefinedLinearCharacteristicDefinitionType() :
  LinearCharacteristicDefinitionBaseType()
{
  WhatToMeasure = 0;
}

UserDefinedLinearCharacteristicDefinitionType::UserDefinedLinearCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseTypePairIn,
 XmlString * WhatToMeasureIn) :
  LinearCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    LinearCharacteristicDefinitionBaseTypePairIn)
{
  WhatToMeasure = WhatToMeasureIn;
}

UserDefinedLinearCharacteristicDefinitionType::UserDefinedLinearCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseTypePairIn,
 XmlString * WhatToMeasureIn) :
  LinearCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    LinearCharacteristicDefinitionBaseTypePairIn)
{
  WhatToMeasure = WhatToMeasureIn;
}

UserDefinedLinearCharacteristicDefinitionType::~UserDefinedLinearCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  delete WhatToMeasure;
  #endif
}

void UserDefinedLinearCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (DimensionType)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionType");
      DimensionType->printSelf(outFile);
      fprintf(outFile, "</DimensionType>\n");
    }
  if (DimensionModifiers)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionModifiers");
      DimensionModifiers->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DimensionModifiers>\n");
    }
  LinearCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<WhatToMeasure");
  WhatToMeasure->printSelf(outFile);
  fprintf(outFile, "</WhatToMeasure>\n");
  doSpaces(-INDENT, outFile);
}

bool UserDefinedLinearCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedLinearCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedLinearCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedLinearCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedLinearCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

XmlString * UserDefinedLinearCharacteristicDefinitionType::getWhatToMeasure()
{return WhatToMeasure;}

void UserDefinedLinearCharacteristicDefinitionType::setWhatToMeasure(XmlString * WhatToMeasureIn)
{WhatToMeasure = WhatToMeasureIn;}

/* ***************************************************************** */

/* class UserDefinedLinearCharacteristicItemType

*/

UserDefinedLinearCharacteristicItemType::UserDefinedLinearCharacteristicItemType() :
  LinearCharacteristicItemBaseType()
{
}

UserDefinedLinearCharacteristicItemType::UserDefinedLinearCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LinearCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

UserDefinedLinearCharacteristicItemType::UserDefinedLinearCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LinearCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

UserDefinedLinearCharacteristicItemType::~UserDefinedLinearCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void UserDefinedLinearCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool UserDefinedLinearCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedLinearCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedLinearCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedLinearCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedLinearCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class UserDefinedLinearCharacteristicMeasurementType

*/

UserDefinedLinearCharacteristicMeasurementType::UserDefinedLinearCharacteristicMeasurementType() :
  LinearCharacteristicMeasurementBaseType()
{
}

UserDefinedLinearCharacteristicMeasurementType::UserDefinedLinearCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  LinearCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

UserDefinedLinearCharacteristicMeasurementType::UserDefinedLinearCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  LinearCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

UserDefinedLinearCharacteristicMeasurementType::~UserDefinedLinearCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void UserDefinedLinearCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool UserDefinedLinearCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedLinearCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedLinearCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedLinearCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedLinearCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class UserDefinedLinearCharacteristicNominalType

*/

UserDefinedLinearCharacteristicNominalType::UserDefinedLinearCharacteristicNominalType() :
  LinearCharacteristicNominalBaseType()
{
}

UserDefinedLinearCharacteristicNominalType::UserDefinedLinearCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn) :
  LinearCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn,
    TargetDualValueIn)
{
}

UserDefinedLinearCharacteristicNominalType::UserDefinedLinearCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn) :
  LinearCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn,
    TargetDualValueIn)
{
}

UserDefinedLinearCharacteristicNominalType::~UserDefinedLinearCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void UserDefinedLinearCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  if (TargetDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetDualValue");
      TargetDualValue->printSelf(outFile);
      fprintf(outFile, "</TargetDualValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool UserDefinedLinearCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedLinearCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedLinearCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedLinearCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedLinearCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class UserDefinedMassCharacteristicDefinitionType

*/

UserDefinedMassCharacteristicDefinitionType::UserDefinedMassCharacteristicDefinitionType() :
  MassCharacteristicDefinitionBaseType()
{
  WhatToMeasure = 0;
}

UserDefinedMassCharacteristicDefinitionType::UserDefinedMassCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 MassCharacteristicDefinitionBaseTypeChoicePair * MassCharacteristicDefinitionBaseTypePairIn,
 XmlString * WhatToMeasureIn) :
  MassCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    MassCharacteristicDefinitionBaseTypePairIn)
{
  WhatToMeasure = WhatToMeasureIn;
}

UserDefinedMassCharacteristicDefinitionType::UserDefinedMassCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 MassCharacteristicDefinitionBaseTypeChoicePair * MassCharacteristicDefinitionBaseTypePairIn,
 XmlString * WhatToMeasureIn) :
  MassCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    MassCharacteristicDefinitionBaseTypePairIn)
{
  WhatToMeasure = WhatToMeasureIn;
}

UserDefinedMassCharacteristicDefinitionType::~UserDefinedMassCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  delete WhatToMeasure;
  #endif
}

void UserDefinedMassCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  MassCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<WhatToMeasure");
  WhatToMeasure->printSelf(outFile);
  fprintf(outFile, "</WhatToMeasure>\n");
  doSpaces(-INDENT, outFile);
}

bool UserDefinedMassCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedMassCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedMassCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedMassCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedMassCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

XmlString * UserDefinedMassCharacteristicDefinitionType::getWhatToMeasure()
{return WhatToMeasure;}

void UserDefinedMassCharacteristicDefinitionType::setWhatToMeasure(XmlString * WhatToMeasureIn)
{WhatToMeasure = WhatToMeasureIn;}

/* ***************************************************************** */

/* class UserDefinedMassCharacteristicItemType

*/

UserDefinedMassCharacteristicItemType::UserDefinedMassCharacteristicItemType() :
  MassCharacteristicItemBaseType()
{
}

UserDefinedMassCharacteristicItemType::UserDefinedMassCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  MassCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

UserDefinedMassCharacteristicItemType::UserDefinedMassCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  MassCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

UserDefinedMassCharacteristicItemType::~UserDefinedMassCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void UserDefinedMassCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool UserDefinedMassCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedMassCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedMassCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedMassCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedMassCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class UserDefinedMassCharacteristicMeasurementType

*/

UserDefinedMassCharacteristicMeasurementType::UserDefinedMassCharacteristicMeasurementType() :
  MassCharacteristicMeasurementBaseType()
{
}

UserDefinedMassCharacteristicMeasurementType::UserDefinedMassCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredMassValueType * ValueIn,
 MeasuredMassValueType * MaxValueIn,
 MeasuredMassValueType * MinValueIn) :
  MassCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

UserDefinedMassCharacteristicMeasurementType::UserDefinedMassCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredMassValueType * ValueIn,
 MeasuredMassValueType * MaxValueIn,
 MeasuredMassValueType * MinValueIn) :
  MassCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

UserDefinedMassCharacteristicMeasurementType::~UserDefinedMassCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void UserDefinedMassCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool UserDefinedMassCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedMassCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedMassCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedMassCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedMassCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class UserDefinedMassCharacteristicNominalType

*/

UserDefinedMassCharacteristicNominalType::UserDefinedMassCharacteristicNominalType() :
  MassCharacteristicNominalBaseType()
{
}

UserDefinedMassCharacteristicNominalType::UserDefinedMassCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 MassValueType * TargetValueIn) :
  MassCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn)
{
}

UserDefinedMassCharacteristicNominalType::UserDefinedMassCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 MassValueType * TargetValueIn) :
  MassCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn)
{
}

UserDefinedMassCharacteristicNominalType::~UserDefinedMassCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void UserDefinedMassCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool UserDefinedMassCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedMassCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedMassCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedMassCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedMassCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class UserDefinedPressureCharacteristicDefinitionType

*/

UserDefinedPressureCharacteristicDefinitionType::UserDefinedPressureCharacteristicDefinitionType() :
  PressureCharacteristicDefinitionBaseType()
{
  WhatToMeasure = 0;
}

UserDefinedPressureCharacteristicDefinitionType::UserDefinedPressureCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 PressureCharacteristicDefinitionBaseTypeChoicePair * PressureCharacteristicDefinitionBaseTypePairIn,
 XmlString * WhatToMeasureIn) :
  PressureCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    PressureCharacteristicDefinitionBaseTypePairIn)
{
  WhatToMeasure = WhatToMeasureIn;
}

UserDefinedPressureCharacteristicDefinitionType::UserDefinedPressureCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 PressureCharacteristicDefinitionBaseTypeChoicePair * PressureCharacteristicDefinitionBaseTypePairIn,
 XmlString * WhatToMeasureIn) :
  PressureCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    PressureCharacteristicDefinitionBaseTypePairIn)
{
  WhatToMeasure = WhatToMeasureIn;
}

UserDefinedPressureCharacteristicDefinitionType::~UserDefinedPressureCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  delete WhatToMeasure;
  #endif
}

void UserDefinedPressureCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  PressureCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<WhatToMeasure");
  WhatToMeasure->printSelf(outFile);
  fprintf(outFile, "</WhatToMeasure>\n");
  doSpaces(-INDENT, outFile);
}

bool UserDefinedPressureCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedPressureCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedPressureCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedPressureCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedPressureCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

XmlString * UserDefinedPressureCharacteristicDefinitionType::getWhatToMeasure()
{return WhatToMeasure;}

void UserDefinedPressureCharacteristicDefinitionType::setWhatToMeasure(XmlString * WhatToMeasureIn)
{WhatToMeasure = WhatToMeasureIn;}

/* ***************************************************************** */

/* class UserDefinedPressureCharacteristicItemType

*/

UserDefinedPressureCharacteristicItemType::UserDefinedPressureCharacteristicItemType() :
  PressureCharacteristicItemBaseType()
{
}

UserDefinedPressureCharacteristicItemType::UserDefinedPressureCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  PressureCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

UserDefinedPressureCharacteristicItemType::UserDefinedPressureCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  PressureCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

UserDefinedPressureCharacteristicItemType::~UserDefinedPressureCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void UserDefinedPressureCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool UserDefinedPressureCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedPressureCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedPressureCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedPressureCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedPressureCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class UserDefinedPressureCharacteristicMeasurementType

*/

UserDefinedPressureCharacteristicMeasurementType::UserDefinedPressureCharacteristicMeasurementType() :
  PressureCharacteristicMeasurementBaseType()
{
}

UserDefinedPressureCharacteristicMeasurementType::UserDefinedPressureCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredPressureValueType * ValueIn,
 MeasuredPressureValueType * MaxValueIn,
 MeasuredPressureValueType * MinValueIn) :
  PressureCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

UserDefinedPressureCharacteristicMeasurementType::UserDefinedPressureCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredPressureValueType * ValueIn,
 MeasuredPressureValueType * MaxValueIn,
 MeasuredPressureValueType * MinValueIn) :
  PressureCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

UserDefinedPressureCharacteristicMeasurementType::~UserDefinedPressureCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void UserDefinedPressureCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool UserDefinedPressureCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedPressureCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedPressureCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedPressureCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedPressureCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class UserDefinedPressureCharacteristicNominalType

*/

UserDefinedPressureCharacteristicNominalType::UserDefinedPressureCharacteristicNominalType() :
  PressureCharacteristicNominalBaseType()
{
}

UserDefinedPressureCharacteristicNominalType::UserDefinedPressureCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 PressureValueType * TargetValueIn) :
  PressureCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn)
{
}

UserDefinedPressureCharacteristicNominalType::UserDefinedPressureCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 PressureValueType * TargetValueIn) :
  PressureCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn)
{
}

UserDefinedPressureCharacteristicNominalType::~UserDefinedPressureCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void UserDefinedPressureCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool UserDefinedPressureCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedPressureCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedPressureCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedPressureCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedPressureCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class UserDefinedSpeedCharacteristicDefinitionType

*/

UserDefinedSpeedCharacteristicDefinitionType::UserDefinedSpeedCharacteristicDefinitionType() :
  SpeedCharacteristicDefinitionBaseType()
{
  WhatToMeasure = 0;
}

UserDefinedSpeedCharacteristicDefinitionType::UserDefinedSpeedCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 SpeedCharacteristicDefinitionBaseTypeChoicePair * SpeedCharacteristicDefinitionBaseTypePairIn,
 XmlString * WhatToMeasureIn) :
  SpeedCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    SpeedCharacteristicDefinitionBaseTypePairIn)
{
  WhatToMeasure = WhatToMeasureIn;
}

UserDefinedSpeedCharacteristicDefinitionType::UserDefinedSpeedCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 SpeedCharacteristicDefinitionBaseTypeChoicePair * SpeedCharacteristicDefinitionBaseTypePairIn,
 XmlString * WhatToMeasureIn) :
  SpeedCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    SpeedCharacteristicDefinitionBaseTypePairIn)
{
  WhatToMeasure = WhatToMeasureIn;
}

UserDefinedSpeedCharacteristicDefinitionType::~UserDefinedSpeedCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  delete WhatToMeasure;
  #endif
}

void UserDefinedSpeedCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  SpeedCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<WhatToMeasure");
  WhatToMeasure->printSelf(outFile);
  fprintf(outFile, "</WhatToMeasure>\n");
  doSpaces(-INDENT, outFile);
}

bool UserDefinedSpeedCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedSpeedCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedSpeedCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedSpeedCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedSpeedCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

XmlString * UserDefinedSpeedCharacteristicDefinitionType::getWhatToMeasure()
{return WhatToMeasure;}

void UserDefinedSpeedCharacteristicDefinitionType::setWhatToMeasure(XmlString * WhatToMeasureIn)
{WhatToMeasure = WhatToMeasureIn;}

/* ***************************************************************** */

/* class UserDefinedSpeedCharacteristicItemType

*/

UserDefinedSpeedCharacteristicItemType::UserDefinedSpeedCharacteristicItemType() :
  SpeedCharacteristicItemBaseType()
{
}

UserDefinedSpeedCharacteristicItemType::UserDefinedSpeedCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  SpeedCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

UserDefinedSpeedCharacteristicItemType::UserDefinedSpeedCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  SpeedCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

UserDefinedSpeedCharacteristicItemType::~UserDefinedSpeedCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void UserDefinedSpeedCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool UserDefinedSpeedCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedSpeedCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedSpeedCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedSpeedCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedSpeedCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class UserDefinedSpeedCharacteristicMeasurementType

*/

UserDefinedSpeedCharacteristicMeasurementType::UserDefinedSpeedCharacteristicMeasurementType() :
  SpeedCharacteristicMeasurementBaseType()
{
}

UserDefinedSpeedCharacteristicMeasurementType::UserDefinedSpeedCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredSpeedValueType * ValueIn,
 MeasuredSpeedValueType * MaxValueIn,
 MeasuredSpeedValueType * MinValueIn) :
  SpeedCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

UserDefinedSpeedCharacteristicMeasurementType::UserDefinedSpeedCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredSpeedValueType * ValueIn,
 MeasuredSpeedValueType * MaxValueIn,
 MeasuredSpeedValueType * MinValueIn) :
  SpeedCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

UserDefinedSpeedCharacteristicMeasurementType::~UserDefinedSpeedCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void UserDefinedSpeedCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool UserDefinedSpeedCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedSpeedCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedSpeedCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedSpeedCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedSpeedCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class UserDefinedSpeedCharacteristicNominalType

*/

UserDefinedSpeedCharacteristicNominalType::UserDefinedSpeedCharacteristicNominalType() :
  SpeedCharacteristicNominalBaseType()
{
}

UserDefinedSpeedCharacteristicNominalType::UserDefinedSpeedCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 SpeedValueType * TargetValueIn) :
  SpeedCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn)
{
}

UserDefinedSpeedCharacteristicNominalType::UserDefinedSpeedCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 SpeedValueType * TargetValueIn) :
  SpeedCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn)
{
}

UserDefinedSpeedCharacteristicNominalType::~UserDefinedSpeedCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void UserDefinedSpeedCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool UserDefinedSpeedCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedSpeedCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedSpeedCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedSpeedCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedSpeedCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class UserDefinedTemperatureCharacteristicDefinitionType

*/

UserDefinedTemperatureCharacteristicDefinitionType::UserDefinedTemperatureCharacteristicDefinitionType() :
  TemperatureCharacteristicDefinitionBaseType()
{
  WhatToMeasure = 0;
}

UserDefinedTemperatureCharacteristicDefinitionType::UserDefinedTemperatureCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 TemperatureCharacteristicDefinitionBaseTypeChoicePair * TemperatureCharacteristicDefinitionBaseTypePairIn,
 XmlString * WhatToMeasureIn) :
  TemperatureCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    TemperatureCharacteristicDefinitionBaseTypePairIn)
{
  WhatToMeasure = WhatToMeasureIn;
}

UserDefinedTemperatureCharacteristicDefinitionType::UserDefinedTemperatureCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 TemperatureCharacteristicDefinitionBaseTypeChoicePair * TemperatureCharacteristicDefinitionBaseTypePairIn,
 XmlString * WhatToMeasureIn) :
  TemperatureCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    TemperatureCharacteristicDefinitionBaseTypePairIn)
{
  WhatToMeasure = WhatToMeasureIn;
}

UserDefinedTemperatureCharacteristicDefinitionType::~UserDefinedTemperatureCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  delete WhatToMeasure;
  #endif
}

void UserDefinedTemperatureCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  TemperatureCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<WhatToMeasure");
  WhatToMeasure->printSelf(outFile);
  fprintf(outFile, "</WhatToMeasure>\n");
  doSpaces(-INDENT, outFile);
}

bool UserDefinedTemperatureCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedTemperatureCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedTemperatureCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedTemperatureCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedTemperatureCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

XmlString * UserDefinedTemperatureCharacteristicDefinitionType::getWhatToMeasure()
{return WhatToMeasure;}

void UserDefinedTemperatureCharacteristicDefinitionType::setWhatToMeasure(XmlString * WhatToMeasureIn)
{WhatToMeasure = WhatToMeasureIn;}

/* ***************************************************************** */

/* class UserDefinedTemperatureCharacteristicItemType

*/

UserDefinedTemperatureCharacteristicItemType::UserDefinedTemperatureCharacteristicItemType() :
  TemperatureCharacteristicItemBaseType()
{
}

UserDefinedTemperatureCharacteristicItemType::UserDefinedTemperatureCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  TemperatureCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

UserDefinedTemperatureCharacteristicItemType::UserDefinedTemperatureCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  TemperatureCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

UserDefinedTemperatureCharacteristicItemType::~UserDefinedTemperatureCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void UserDefinedTemperatureCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool UserDefinedTemperatureCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedTemperatureCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedTemperatureCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedTemperatureCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedTemperatureCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class UserDefinedTemperatureCharacteristicMeasurementType

*/

UserDefinedTemperatureCharacteristicMeasurementType::UserDefinedTemperatureCharacteristicMeasurementType() :
  TemperatureCharacteristicMeasurementBaseType()
{
}

UserDefinedTemperatureCharacteristicMeasurementType::UserDefinedTemperatureCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredTemperatureValueType * ValueIn,
 MeasuredTemperatureValueType * MaxValueIn,
 MeasuredTemperatureValueType * MinValueIn) :
  TemperatureCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

UserDefinedTemperatureCharacteristicMeasurementType::UserDefinedTemperatureCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredTemperatureValueType * ValueIn,
 MeasuredTemperatureValueType * MaxValueIn,
 MeasuredTemperatureValueType * MinValueIn) :
  TemperatureCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

UserDefinedTemperatureCharacteristicMeasurementType::~UserDefinedTemperatureCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void UserDefinedTemperatureCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool UserDefinedTemperatureCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedTemperatureCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedTemperatureCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedTemperatureCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedTemperatureCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class UserDefinedTemperatureCharacteristicNominalType

*/

UserDefinedTemperatureCharacteristicNominalType::UserDefinedTemperatureCharacteristicNominalType() :
  TemperatureCharacteristicNominalBaseType()
{
}

UserDefinedTemperatureCharacteristicNominalType::UserDefinedTemperatureCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 TemperatureValueType * TargetValueIn) :
  TemperatureCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn)
{
}

UserDefinedTemperatureCharacteristicNominalType::UserDefinedTemperatureCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 TemperatureValueType * TargetValueIn) :
  TemperatureCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn)
{
}

UserDefinedTemperatureCharacteristicNominalType::~UserDefinedTemperatureCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void UserDefinedTemperatureCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool UserDefinedTemperatureCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedTemperatureCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedTemperatureCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedTemperatureCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedTemperatureCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class UserDefinedTimeCharacteristicDefinitionType

*/

UserDefinedTimeCharacteristicDefinitionType::UserDefinedTimeCharacteristicDefinitionType() :
  TimeCharacteristicDefinitionBaseType()
{
  WhatToMeasure = 0;
}

UserDefinedTimeCharacteristicDefinitionType::UserDefinedTimeCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 TimeCharacteristicDefinitionBaseTypeChoicePair * TimeCharacteristicDefinitionBaseTypePairIn,
 XmlString * WhatToMeasureIn) :
  TimeCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    TimeCharacteristicDefinitionBaseTypePairIn)
{
  WhatToMeasure = WhatToMeasureIn;
}

UserDefinedTimeCharacteristicDefinitionType::UserDefinedTimeCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 TimeCharacteristicDefinitionBaseTypeChoicePair * TimeCharacteristicDefinitionBaseTypePairIn,
 XmlString * WhatToMeasureIn) :
  TimeCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    TimeCharacteristicDefinitionBaseTypePairIn)
{
  WhatToMeasure = WhatToMeasureIn;
}

UserDefinedTimeCharacteristicDefinitionType::~UserDefinedTimeCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  delete WhatToMeasure;
  #endif
}

void UserDefinedTimeCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  TimeCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<WhatToMeasure");
  WhatToMeasure->printSelf(outFile);
  fprintf(outFile, "</WhatToMeasure>\n");
  doSpaces(-INDENT, outFile);
}

bool UserDefinedTimeCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedTimeCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedTimeCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedTimeCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedTimeCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

XmlString * UserDefinedTimeCharacteristicDefinitionType::getWhatToMeasure()
{return WhatToMeasure;}

void UserDefinedTimeCharacteristicDefinitionType::setWhatToMeasure(XmlString * WhatToMeasureIn)
{WhatToMeasure = WhatToMeasureIn;}

/* ***************************************************************** */

/* class UserDefinedTimeCharacteristicItemType

*/

UserDefinedTimeCharacteristicItemType::UserDefinedTimeCharacteristicItemType() :
  TimeCharacteristicItemBaseType()
{
}

UserDefinedTimeCharacteristicItemType::UserDefinedTimeCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  TimeCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

UserDefinedTimeCharacteristicItemType::UserDefinedTimeCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  TimeCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

UserDefinedTimeCharacteristicItemType::~UserDefinedTimeCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void UserDefinedTimeCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool UserDefinedTimeCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedTimeCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedTimeCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedTimeCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedTimeCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class UserDefinedTimeCharacteristicMeasurementType

*/

UserDefinedTimeCharacteristicMeasurementType::UserDefinedTimeCharacteristicMeasurementType() :
  TimeCharacteristicMeasurementBaseType()
{
}

UserDefinedTimeCharacteristicMeasurementType::UserDefinedTimeCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredTimeValueType * ValueIn,
 MeasuredTimeValueType * MaxValueIn,
 MeasuredTimeValueType * MinValueIn) :
  TimeCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

UserDefinedTimeCharacteristicMeasurementType::UserDefinedTimeCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredTimeValueType * ValueIn,
 MeasuredTimeValueType * MaxValueIn,
 MeasuredTimeValueType * MinValueIn) :
  TimeCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

UserDefinedTimeCharacteristicMeasurementType::~UserDefinedTimeCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void UserDefinedTimeCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool UserDefinedTimeCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedTimeCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedTimeCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedTimeCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedTimeCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class UserDefinedTimeCharacteristicNominalType

*/

UserDefinedTimeCharacteristicNominalType::UserDefinedTimeCharacteristicNominalType() :
  TimeCharacteristicNominalBaseType()
{
}

UserDefinedTimeCharacteristicNominalType::UserDefinedTimeCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 TimeValueType * TargetValueIn) :
  TimeCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn)
{
}

UserDefinedTimeCharacteristicNominalType::UserDefinedTimeCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 TimeValueType * TargetValueIn) :
  TimeCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn)
{
}

UserDefinedTimeCharacteristicNominalType::~UserDefinedTimeCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void UserDefinedTimeCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool UserDefinedTimeCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedTimeCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedTimeCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedTimeCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedTimeCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class UserDefinedUnitCharacteristicDefinitionType

*/

UserDefinedUnitCharacteristicDefinitionType::UserDefinedUnitCharacteristicDefinitionType() :
  CharacteristicDefinitionBaseType()
{
}

UserDefinedUnitCharacteristicDefinitionType::UserDefinedUnitCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  CharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

UserDefinedUnitCharacteristicDefinitionType::UserDefinedUnitCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  CharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

UserDefinedUnitCharacteristicDefinitionType::~UserDefinedUnitCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void UserDefinedUnitCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool UserDefinedUnitCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedUnitCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedUnitCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedUnitCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedUnitCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class UserDefinedUnitCharacteristicItemType

*/

UserDefinedUnitCharacteristicItemType::UserDefinedUnitCharacteristicItemType() :
  CharacteristicItemBaseType()
{
}

UserDefinedUnitCharacteristicItemType::UserDefinedUnitCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  CharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

UserDefinedUnitCharacteristicItemType::UserDefinedUnitCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  CharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

UserDefinedUnitCharacteristicItemType::~UserDefinedUnitCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void UserDefinedUnitCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool UserDefinedUnitCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedUnitCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedUnitCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedUnitCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedUnitCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class UserDefinedUnitCharacteristicMeasurementType

*/

UserDefinedUnitCharacteristicMeasurementType::UserDefinedUnitCharacteristicMeasurementType() :
  CharacteristicMeasurementBaseType()
{
  Value = 0;
  MaxValue = 0;
  MinValue = 0;
}

UserDefinedUnitCharacteristicMeasurementType::UserDefinedUnitCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredUserDefinedUnitValueType * ValueIn,
 MeasuredUserDefinedUnitValueType * MaxValueIn,
 MeasuredUserDefinedUnitValueType * MinValueIn) :
  CharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  Value = ValueIn;
  MaxValue = MaxValueIn;
  MinValue = MinValueIn;
}

UserDefinedUnitCharacteristicMeasurementType::UserDefinedUnitCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredUserDefinedUnitValueType * ValueIn,
 MeasuredUserDefinedUnitValueType * MaxValueIn,
 MeasuredUserDefinedUnitValueType * MinValueIn) :
  CharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  Value = ValueIn;
  MaxValue = MaxValueIn;
  MinValue = MinValueIn;
}

UserDefinedUnitCharacteristicMeasurementType::~UserDefinedUnitCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  delete Value;
  delete MaxValue;
  delete MinValue;
  #endif
}

void UserDefinedUnitCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool UserDefinedUnitCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedUnitCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedUnitCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedUnitCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedUnitCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredUserDefinedUnitValueType * UserDefinedUnitCharacteristicMeasurementType::getValue()
{return Value;}

void UserDefinedUnitCharacteristicMeasurementType::setValue(MeasuredUserDefinedUnitValueType * ValueIn)
{Value = ValueIn;}

MeasuredUserDefinedUnitValueType * UserDefinedUnitCharacteristicMeasurementType::getMaxValue()
{return MaxValue;}

void UserDefinedUnitCharacteristicMeasurementType::setMaxValue(MeasuredUserDefinedUnitValueType * MaxValueIn)
{MaxValue = MaxValueIn;}

MeasuredUserDefinedUnitValueType * UserDefinedUnitCharacteristicMeasurementType::getMinValue()
{return MinValue;}

void UserDefinedUnitCharacteristicMeasurementType::setMinValue(MeasuredUserDefinedUnitValueType * MinValueIn)
{MinValue = MinValueIn;}

/* ***************************************************************** */

/* class UserDefinedUnitCharacteristicNominalType

*/

UserDefinedUnitCharacteristicNominalType::UserDefinedUnitCharacteristicNominalType() :
  CharacteristicNominalBaseType()
{
  TargetValue = 0;
  UserDefinedUnit_1060 = 0;
  DefinedAsLimit = 0;
}

UserDefinedUnitCharacteristicNominalType::UserDefinedUnitCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 UserDefinedUnitValueType * TargetValueIn,
 UserDefinedUnit_1060_Type * UserDefinedUnit_1060In,
 XmlBoolean * DefinedAsLimitIn) :
  CharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  TargetValue = TargetValueIn;
  UserDefinedUnit_1060 = UserDefinedUnit_1060In;
  DefinedAsLimit = DefinedAsLimitIn;
}

UserDefinedUnitCharacteristicNominalType::UserDefinedUnitCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 UserDefinedUnitValueType * TargetValueIn,
 UserDefinedUnit_1060_Type * UserDefinedUnit_1060In,
 XmlBoolean * DefinedAsLimitIn) :
  CharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  TargetValue = TargetValueIn;
  UserDefinedUnit_1060 = UserDefinedUnit_1060In;
  DefinedAsLimit = DefinedAsLimitIn;
}

UserDefinedUnitCharacteristicNominalType::~UserDefinedUnitCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  delete TargetValue;
  delete UserDefinedUnit_1060;
  delete DefinedAsLimit;
  #endif
}

void UserDefinedUnitCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<TargetValue");
  TargetValue->printSelf(outFile);
  fprintf(outFile, "</TargetValue>\n");
  UserDefinedUnit_1060->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<DefinedAsLimit");
  DefinedAsLimit->printSelf(outFile);
  fprintf(outFile, "</DefinedAsLimit>\n");
  doSpaces(-INDENT, outFile);
}

bool UserDefinedUnitCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UserDefinedUnitCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UserDefinedUnitCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UserDefinedUnitCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UserDefinedUnitCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

UserDefinedUnitValueType * UserDefinedUnitCharacteristicNominalType::getTargetValue()
{return TargetValue;}

void UserDefinedUnitCharacteristicNominalType::setTargetValue(UserDefinedUnitValueType * TargetValueIn)
{TargetValue = TargetValueIn;}

UserDefinedUnit_1060_Type * UserDefinedUnitCharacteristicNominalType::getUserDefinedUnit_1060()
{return UserDefinedUnit_1060;}

void UserDefinedUnitCharacteristicNominalType::setUserDefinedUnit_1060(UserDefinedUnit_1060_Type * UserDefinedUnit_1060In)
{UserDefinedUnit_1060 = UserDefinedUnit_1060In;}

XmlBoolean * UserDefinedUnitCharacteristicNominalType::getDefinedAsLimit()
{return DefinedAsLimit;}

void UserDefinedUnitCharacteristicNominalType::setDefinedAsLimit(XmlBoolean * DefinedAsLimitIn)
{DefinedAsLimit = DefinedAsLimitIn;}

/* ***************************************************************** */

/* class WeldBevelCharacteristicDefinitionType

*/

WeldBevelCharacteristicDefinitionType::WeldBevelCharacteristicDefinitionType() :
  WeldCharacteristicDefinitionBaseType()
{
}

WeldBevelCharacteristicDefinitionType::WeldBevelCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  WeldCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

WeldBevelCharacteristicDefinitionType::WeldBevelCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  WeldCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

WeldBevelCharacteristicDefinitionType::~WeldBevelCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldBevelCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool WeldBevelCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldBevelCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldBevelCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldBevelCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldBevelCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldBevelCharacteristicItemType

*/

WeldBevelCharacteristicItemType::WeldBevelCharacteristicItemType() :
  WeldCharacteristicItemBaseType()
{
}

WeldBevelCharacteristicItemType::WeldBevelCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  WeldCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WeldBevelCharacteristicItemType::WeldBevelCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  WeldCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WeldBevelCharacteristicItemType::~WeldBevelCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldBevelCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WeldBevelCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldBevelCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldBevelCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldBevelCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldBevelCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldBevelCharacteristicMeasurementType

*/

WeldBevelCharacteristicMeasurementType::WeldBevelCharacteristicMeasurementType() :
  WeldGrooveCharacteristicMeasurementType()
{
}

WeldBevelCharacteristicMeasurementType::WeldBevelCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 WeldGrooveCharacteristicMeasurementTypeChoicePair * WeldGrooveCharacteristicMeasurementTypePairIn) :
  WeldGrooveCharacteristicMeasurementType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    WeldGrooveCharacteristicMeasurementTypePairIn)
{
}

WeldBevelCharacteristicMeasurementType::WeldBevelCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 WeldGrooveCharacteristicMeasurementTypeChoicePair * WeldGrooveCharacteristicMeasurementTypePairIn) :
  WeldGrooveCharacteristicMeasurementType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    WeldGrooveCharacteristicMeasurementTypePairIn)
{
}

WeldBevelCharacteristicMeasurementType::~WeldBevelCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldBevelCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (WeldGrooveCharacteristicMeasurementTypePair)
    {
      WeldGrooveCharacteristicMeasurementTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WeldBevelCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldBevelCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldBevelCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldBevelCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldBevelCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldBevelCharacteristicNominalType

*/

WeldBevelCharacteristicNominalType::WeldBevelCharacteristicNominalType() :
  WeldGrooveCharacteristicNominalType()
{
}

WeldBevelCharacteristicNominalType::WeldBevelCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 WeldGrooveCharacteristicNominalTypeChoicePair * WeldGrooveCharacteristicNominalTypePairIn) :
  WeldGrooveCharacteristicNominalType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn,
    WeldGrooveCharacteristicNominalTypePairIn)
{
}

WeldBevelCharacteristicNominalType::WeldBevelCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 WeldGrooveCharacteristicNominalTypeChoicePair * WeldGrooveCharacteristicNominalTypePairIn) :
  WeldGrooveCharacteristicNominalType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn,
    WeldGrooveCharacteristicNominalTypePairIn)
{
}

WeldBevelCharacteristicNominalType::~WeldBevelCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldBevelCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (AllAround)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AllAround");
      AllAround->printSelf(outFile);
      fprintf(outFile, "</AllAround>\n");
    }
  if (Field)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Field");
      Field->printSelf(outFile);
      fprintf(outFile, "</Field>\n");
    }
  if (Specification)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Specification");
      Specification->printSelf(outFile);
      fprintf(outFile, "</Specification>\n");
    }
  if (WeldingProcess)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldingProcess");
      WeldingProcess->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldingProcess>\n");
    }
  if (NonDestructiveTesting)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonDestructiveTesting");
      NonDestructiveTesting->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NonDestructiveTesting>\n");
    }
  if (WeldGrooveCharacteristicNominalTypePair)
    {
      WeldGrooveCharacteristicNominalTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WeldBevelCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldBevelCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldBevelCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldBevelCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldBevelCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldCharacteristicDefinitionBaseType

*/

WeldCharacteristicDefinitionBaseType::WeldCharacteristicDefinitionBaseType() :
  CharacteristicDefinitionBaseType()
{
}

WeldCharacteristicDefinitionBaseType::WeldCharacteristicDefinitionBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  CharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

WeldCharacteristicDefinitionBaseType::WeldCharacteristicDefinitionBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  CharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

WeldCharacteristicDefinitionBaseType::~WeldCharacteristicDefinitionBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldCharacteristicDefinitionBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool WeldCharacteristicDefinitionBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldCharacteristicDefinitionBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldCharacteristicDefinitionBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldCharacteristicDefinitionBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldCharacteristicDefinitionBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldCharacteristicItemBaseType

*/

WeldCharacteristicItemBaseType::WeldCharacteristicItemBaseType() :
  CharacteristicItemBaseType()
{
}

WeldCharacteristicItemBaseType::WeldCharacteristicItemBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  CharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WeldCharacteristicItemBaseType::WeldCharacteristicItemBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  CharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WeldCharacteristicItemBaseType::~WeldCharacteristicItemBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldCharacteristicItemBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WeldCharacteristicItemBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldCharacteristicItemBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldCharacteristicItemBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldCharacteristicItemBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldCharacteristicItemBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldCharacteristicMeasurementBaseType

*/

WeldCharacteristicMeasurementBaseType::WeldCharacteristicMeasurementBaseType() :
  CharacteristicMeasurementBaseType()
{
}

WeldCharacteristicMeasurementBaseType::WeldCharacteristicMeasurementBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn) :
  CharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
}

WeldCharacteristicMeasurementBaseType::WeldCharacteristicMeasurementBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn) :
  CharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
}

WeldCharacteristicMeasurementBaseType::~WeldCharacteristicMeasurementBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldCharacteristicMeasurementBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool WeldCharacteristicMeasurementBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldCharacteristicMeasurementBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldCharacteristicMeasurementBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldCharacteristicMeasurementBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldCharacteristicMeasurementBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldCharacteristicNominalBaseType

*/

WeldCharacteristicNominalBaseType::WeldCharacteristicNominalBaseType() :
  CharacteristicNominalBaseType()
{
  AllAround = 0;
  Field = 0;
  Specification = 0;
  WeldingProcess = 0;
  NonDestructiveTesting = 0;
}

WeldCharacteristicNominalBaseType::WeldCharacteristicNominalBaseType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn) :
  CharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  AllAround = AllAroundIn;
  Field = FieldIn;
  Specification = SpecificationIn;
  WeldingProcess = WeldingProcessIn;
  NonDestructiveTesting = NonDestructiveTestingIn;
}

WeldCharacteristicNominalBaseType::WeldCharacteristicNominalBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn) :
  CharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn)
{
  AllAround = AllAroundIn;
  Field = FieldIn;
  Specification = SpecificationIn;
  WeldingProcess = WeldingProcessIn;
  NonDestructiveTesting = NonDestructiveTestingIn;
}

WeldCharacteristicNominalBaseType::~WeldCharacteristicNominalBaseType()
{
  #ifndef NODESTRUCT
  delete AllAround;
  delete Field;
  delete Specification;
  delete WeldingProcess;
  delete NonDestructiveTesting;
  #endif
}

void WeldCharacteristicNominalBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (AllAround)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AllAround");
      AllAround->printSelf(outFile);
      fprintf(outFile, "</AllAround>\n");
    }
  if (Field)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Field");
      Field->printSelf(outFile);
      fprintf(outFile, "</Field>\n");
    }
  if (Specification)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Specification");
      Specification->printSelf(outFile);
      fprintf(outFile, "</Specification>\n");
    }
  if (WeldingProcess)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldingProcess");
      WeldingProcess->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldingProcess>\n");
    }
  if (NonDestructiveTesting)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonDestructiveTesting");
      NonDestructiveTesting->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NonDestructiveTesting>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool WeldCharacteristicNominalBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldCharacteristicNominalBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldCharacteristicNominalBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldCharacteristicNominalBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldCharacteristicNominalBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

XmlBoolean * WeldCharacteristicNominalBaseType::getAllAround()
{return AllAround;}

void WeldCharacteristicNominalBaseType::setAllAround(XmlBoolean * AllAroundIn)
{AllAround = AllAroundIn;}

XmlBoolean * WeldCharacteristicNominalBaseType::getField()
{return Field;}

void WeldCharacteristicNominalBaseType::setField(XmlBoolean * FieldIn)
{Field = FieldIn;}

XmlToken * WeldCharacteristicNominalBaseType::getSpecification()
{return Specification;}

void WeldCharacteristicNominalBaseType::setSpecification(XmlToken * SpecificationIn)
{Specification = SpecificationIn;}

WeldingProcessType * WeldCharacteristicNominalBaseType::getWeldingProcess()
{return WeldingProcess;}

void WeldCharacteristicNominalBaseType::setWeldingProcess(WeldingProcessType * WeldingProcessIn)
{WeldingProcess = WeldingProcessIn;}

ArrayNonDestructiveTestingType * WeldCharacteristicNominalBaseType::getNonDestructiveTesting()
{return NonDestructiveTesting;}

void WeldCharacteristicNominalBaseType::setNonDestructiveTesting(ArrayNonDestructiveTestingType * NonDestructiveTestingIn)
{NonDestructiveTesting = NonDestructiveTestingIn;}

/* ***************************************************************** */

/* class WeldCompoundCharacteristicDefinitionType

*/

WeldCompoundCharacteristicDefinitionType::WeldCompoundCharacteristicDefinitionType() :
  WeldCharacteristicDefinitionBaseType()
{
  WeldCharacteristicDefinitionIds = 0;
}

WeldCompoundCharacteristicDefinitionType::WeldCompoundCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 ArrayReferenceFullType * WeldCharacteristicDefinitionIdsIn) :
  WeldCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
  WeldCharacteristicDefinitionIds = WeldCharacteristicDefinitionIdsIn;
}

WeldCompoundCharacteristicDefinitionType::WeldCompoundCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 ArrayReferenceFullType * WeldCharacteristicDefinitionIdsIn) :
  WeldCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
  WeldCharacteristicDefinitionIds = WeldCharacteristicDefinitionIdsIn;
}

WeldCompoundCharacteristicDefinitionType::~WeldCompoundCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  delete WeldCharacteristicDefinitionIds;
  #endif
}

void WeldCompoundCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<WeldCharacteristicDefinitionIds");
  WeldCharacteristicDefinitionIds->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</WeldCharacteristicDefinitionIds>\n");
  doSpaces(-INDENT, outFile);
}

bool WeldCompoundCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldCompoundCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldCompoundCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldCompoundCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldCompoundCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

ArrayReferenceFullType * WeldCompoundCharacteristicDefinitionType::getWeldCharacteristicDefinitionIds()
{return WeldCharacteristicDefinitionIds;}

void WeldCompoundCharacteristicDefinitionType::setWeldCharacteristicDefinitionIds(ArrayReferenceFullType * WeldCharacteristicDefinitionIdsIn)
{WeldCharacteristicDefinitionIds = WeldCharacteristicDefinitionIdsIn;}

/* ***************************************************************** */

/* class WeldCompoundCharacteristicItemType

*/

WeldCompoundCharacteristicItemType::WeldCompoundCharacteristicItemType() :
  WeldCharacteristicItemBaseType()
{
  WeldCharacteristicItemIds = 0;
}

WeldCompoundCharacteristicItemType::WeldCompoundCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 ArrayReferenceType * WeldCharacteristicItemIdsIn) :
  WeldCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
  WeldCharacteristicItemIds = WeldCharacteristicItemIdsIn;
}

WeldCompoundCharacteristicItemType::WeldCompoundCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 ArrayReferenceType * WeldCharacteristicItemIdsIn) :
  WeldCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
  WeldCharacteristicItemIds = WeldCharacteristicItemIdsIn;
}

WeldCompoundCharacteristicItemType::~WeldCompoundCharacteristicItemType()
{
  #ifndef NODESTRUCT
  delete WeldCharacteristicItemIds;
  #endif
}

void WeldCompoundCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<WeldCharacteristicItemIds");
  WeldCharacteristicItemIds->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</WeldCharacteristicItemIds>\n");
  doSpaces(-INDENT, outFile);
}

bool WeldCompoundCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldCompoundCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldCompoundCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldCompoundCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldCompoundCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

ArrayReferenceType * WeldCompoundCharacteristicItemType::getWeldCharacteristicItemIds()
{return WeldCharacteristicItemIds;}

void WeldCompoundCharacteristicItemType::setWeldCharacteristicItemIds(ArrayReferenceType * WeldCharacteristicItemIdsIn)
{WeldCharacteristicItemIds = WeldCharacteristicItemIdsIn;}

/* ***************************************************************** */

/* class WeldCompoundCharacteristicMeasurementType

*/

WeldCompoundCharacteristicMeasurementType::WeldCompoundCharacteristicMeasurementType() :
  WeldCharacteristicMeasurementBaseType()
{
  WeldCharacteristicMeasurementIds = 0;
}

WeldCompoundCharacteristicMeasurementType::WeldCompoundCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 ArrayReferenceType * WeldCharacteristicMeasurementIdsIn) :
  WeldCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  WeldCharacteristicMeasurementIds = WeldCharacteristicMeasurementIdsIn;
}

WeldCompoundCharacteristicMeasurementType::WeldCompoundCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 ArrayReferenceType * WeldCharacteristicMeasurementIdsIn) :
  WeldCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  WeldCharacteristicMeasurementIds = WeldCharacteristicMeasurementIdsIn;
}

WeldCompoundCharacteristicMeasurementType::~WeldCompoundCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  delete WeldCharacteristicMeasurementIds;
  #endif
}

void WeldCompoundCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<WeldCharacteristicMeasurementIds");
  WeldCharacteristicMeasurementIds->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</WeldCharacteristicMeasurementIds>\n");
  doSpaces(-INDENT, outFile);
}

bool WeldCompoundCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldCompoundCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldCompoundCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldCompoundCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldCompoundCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

ArrayReferenceType * WeldCompoundCharacteristicMeasurementType::getWeldCharacteristicMeasurementIds()
{return WeldCharacteristicMeasurementIds;}

void WeldCompoundCharacteristicMeasurementType::setWeldCharacteristicMeasurementIds(ArrayReferenceType * WeldCharacteristicMeasurementIdsIn)
{WeldCharacteristicMeasurementIds = WeldCharacteristicMeasurementIdsIn;}

/* ***************************************************************** */

/* class WeldCompoundCharacteristicNominalType

*/

WeldCompoundCharacteristicNominalType::WeldCompoundCharacteristicNominalType() :
  WeldCharacteristicNominalBaseType()
{
  WeldCharacteristicNominalIds = 0;
}

WeldCompoundCharacteristicNominalType::WeldCompoundCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 ArrayReferenceFullType * WeldCharacteristicNominalIdsIn) :
  WeldCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn)
{
  WeldCharacteristicNominalIds = WeldCharacteristicNominalIdsIn;
}

WeldCompoundCharacteristicNominalType::WeldCompoundCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 ArrayReferenceFullType * WeldCharacteristicNominalIdsIn) :
  WeldCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn)
{
  WeldCharacteristicNominalIds = WeldCharacteristicNominalIdsIn;
}

WeldCompoundCharacteristicNominalType::~WeldCompoundCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  delete WeldCharacteristicNominalIds;
  #endif
}

void WeldCompoundCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (AllAround)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AllAround");
      AllAround->printSelf(outFile);
      fprintf(outFile, "</AllAround>\n");
    }
  if (Field)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Field");
      Field->printSelf(outFile);
      fprintf(outFile, "</Field>\n");
    }
  if (Specification)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Specification");
      Specification->printSelf(outFile);
      fprintf(outFile, "</Specification>\n");
    }
  if (WeldingProcess)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldingProcess");
      WeldingProcess->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldingProcess>\n");
    }
  if (NonDestructiveTesting)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonDestructiveTesting");
      NonDestructiveTesting->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NonDestructiveTesting>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<WeldCharacteristicNominalIds");
  WeldCharacteristicNominalIds->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</WeldCharacteristicNominalIds>\n");
  doSpaces(-INDENT, outFile);
}

bool WeldCompoundCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldCompoundCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldCompoundCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldCompoundCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldCompoundCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

ArrayReferenceFullType * WeldCompoundCharacteristicNominalType::getWeldCharacteristicNominalIds()
{return WeldCharacteristicNominalIds;}

void WeldCompoundCharacteristicNominalType::setWeldCharacteristicNominalIds(ArrayReferenceFullType * WeldCharacteristicNominalIdsIn)
{WeldCharacteristicNominalIds = WeldCharacteristicNominalIdsIn;}

/* ***************************************************************** */

/* class WeldContourSymbolEnumType

*/

WeldContourSymbolEnumType::WeldContourSymbolEnumType() :
  XmlString()
{
}

WeldContourSymbolEnumType::WeldContourSymbolEnumType(
 const char * valIn) :
  XmlString(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "WELD_CONTOUR_FLAT") &&
           strcmp(val.c_str(), "WELD_CONTOUR_FLAT_ANGLED") &&
           strcmp(val.c_str(), "WELD_CONTOUR_CONCAVE") &&
           strcmp(val.c_str(), "WELD_CONTOUR_CONCAVE_ANGLED") &&
           strcmp(val.c_str(), "WELD_CONTOUR_CONVEX") &&
           strcmp(val.c_str(), "WELD_CONTOUR_CONVEX_ANGLED"));
}

WeldContourSymbolEnumType::~WeldContourSymbolEnumType() {}

bool WeldContourSymbolEnumType::WeldContourSymbolEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "WELD_CONTOUR_FLAT") &&
          strcmp(val.c_str(), "WELD_CONTOUR_FLAT_ANGLED") &&
          strcmp(val.c_str(), "WELD_CONTOUR_CONCAVE") &&
          strcmp(val.c_str(), "WELD_CONTOUR_CONCAVE_ANGLED") &&
          strcmp(val.c_str(), "WELD_CONTOUR_CONVEX") &&
          strcmp(val.c_str(), "WELD_CONTOUR_CONVEX_ANGLED"));
}

void WeldContourSymbolEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "WeldContourSymbolEnumType");
}

void WeldContourSymbolEnumType::printSelf(FILE * outFile)
{
  if (WeldContourSymbolEnumTypeIsBad())
    {
      fprintf(stderr, "bad WeldContourSymbolEnumType value, ");
      XmlString::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlString::printSelf(outFile);
}

void WeldContourSymbolEnumType::oPrintSelf(FILE * outFile)
{
  if (WeldContourSymbolEnumTypeIsBad())
    {
      fprintf(stderr, "bad WeldContourSymbolEnumType value, ");
      XmlString::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlString::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class WeldEdgeCharacteristicDefinitionType

*/

WeldEdgeCharacteristicDefinitionType::WeldEdgeCharacteristicDefinitionType() :
  WeldCharacteristicDefinitionBaseType()
{
}

WeldEdgeCharacteristicDefinitionType::WeldEdgeCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  WeldCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

WeldEdgeCharacteristicDefinitionType::WeldEdgeCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  WeldCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

WeldEdgeCharacteristicDefinitionType::~WeldEdgeCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldEdgeCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool WeldEdgeCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldEdgeCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldEdgeCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldEdgeCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldEdgeCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldEdgeCharacteristicItemType

*/

WeldEdgeCharacteristicItemType::WeldEdgeCharacteristicItemType() :
  WeldCharacteristicItemBaseType()
{
}

WeldEdgeCharacteristicItemType::WeldEdgeCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  WeldCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WeldEdgeCharacteristicItemType::WeldEdgeCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  WeldCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WeldEdgeCharacteristicItemType::~WeldEdgeCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldEdgeCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WeldEdgeCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldEdgeCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldEdgeCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldEdgeCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldEdgeCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldEdgeCharacteristicMeasurementType

*/

WeldEdgeCharacteristicMeasurementType::WeldEdgeCharacteristicMeasurementType() :
  WeldCharacteristicMeasurementBaseType()
{
  LocationSignificance = 0;
  SideParameters = 0;
}

WeldEdgeCharacteristicMeasurementType::WeldEdgeCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 LocationSignificanceOneSidesEnumType * LocationSignificanceIn,
 WeldOneSideParametersExtendSizeType * SideParametersIn) :
  WeldCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  LocationSignificance = LocationSignificanceIn;
  SideParameters = SideParametersIn;
}

WeldEdgeCharacteristicMeasurementType::WeldEdgeCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 LocationSignificanceOneSidesEnumType * LocationSignificanceIn,
 WeldOneSideParametersExtendSizeType * SideParametersIn) :
  WeldCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  LocationSignificance = LocationSignificanceIn;
  SideParameters = SideParametersIn;
}

WeldEdgeCharacteristicMeasurementType::~WeldEdgeCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  delete LocationSignificance;
  delete SideParameters;
  #endif
}

void WeldEdgeCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<LocationSignificance");
  LocationSignificance->printSelf(outFile);
  fprintf(outFile, "</LocationSignificance>\n");
  if (SideParameters)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SideParameters");
      SideParameters->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SideParameters>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool WeldEdgeCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldEdgeCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldEdgeCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldEdgeCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldEdgeCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LocationSignificanceOneSidesEnumType * WeldEdgeCharacteristicMeasurementType::getLocationSignificance()
{return LocationSignificance;}

void WeldEdgeCharacteristicMeasurementType::setLocationSignificance(LocationSignificanceOneSidesEnumType * LocationSignificanceIn)
{LocationSignificance = LocationSignificanceIn;}

WeldOneSideParametersExtendSizeType * WeldEdgeCharacteristicMeasurementType::getSideParameters()
{return SideParameters;}

void WeldEdgeCharacteristicMeasurementType::setSideParameters(WeldOneSideParametersExtendSizeType * SideParametersIn)
{SideParameters = SideParametersIn;}

/* ***************************************************************** */

/* class WeldEdgeCharacteristicNominalType

*/

WeldEdgeCharacteristicNominalType::WeldEdgeCharacteristicNominalType() :
  WeldCharacteristicNominalBaseType()
{
  LocationSignificance = 0;
  SideParameters = 0;
}

WeldEdgeCharacteristicNominalType::WeldEdgeCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 LocationSignificanceOneSidesEnumType * LocationSignificanceIn,
 WeldOneSideParametersExtendSizeType * SideParametersIn) :
  WeldCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn)
{
  LocationSignificance = LocationSignificanceIn;
  SideParameters = SideParametersIn;
}

WeldEdgeCharacteristicNominalType::WeldEdgeCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 LocationSignificanceOneSidesEnumType * LocationSignificanceIn,
 WeldOneSideParametersExtendSizeType * SideParametersIn) :
  WeldCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn)
{
  LocationSignificance = LocationSignificanceIn;
  SideParameters = SideParametersIn;
}

WeldEdgeCharacteristicNominalType::~WeldEdgeCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  delete LocationSignificance;
  delete SideParameters;
  #endif
}

void WeldEdgeCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (AllAround)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AllAround");
      AllAround->printSelf(outFile);
      fprintf(outFile, "</AllAround>\n");
    }
  if (Field)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Field");
      Field->printSelf(outFile);
      fprintf(outFile, "</Field>\n");
    }
  if (Specification)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Specification");
      Specification->printSelf(outFile);
      fprintf(outFile, "</Specification>\n");
    }
  if (WeldingProcess)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldingProcess");
      WeldingProcess->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldingProcess>\n");
    }
  if (NonDestructiveTesting)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonDestructiveTesting");
      NonDestructiveTesting->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NonDestructiveTesting>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<LocationSignificance");
  LocationSignificance->printSelf(outFile);
  fprintf(outFile, "</LocationSignificance>\n");
  if (SideParameters)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SideParameters");
      SideParameters->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SideParameters>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool WeldEdgeCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldEdgeCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldEdgeCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldEdgeCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldEdgeCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LocationSignificanceOneSidesEnumType * WeldEdgeCharacteristicNominalType::getLocationSignificance()
{return LocationSignificance;}

void WeldEdgeCharacteristicNominalType::setLocationSignificance(LocationSignificanceOneSidesEnumType * LocationSignificanceIn)
{LocationSignificance = LocationSignificanceIn;}

WeldOneSideParametersExtendSizeType * WeldEdgeCharacteristicNominalType::getSideParameters()
{return SideParameters;}

void WeldEdgeCharacteristicNominalType::setSideParameters(WeldOneSideParametersExtendSizeType * SideParametersIn)
{SideParameters = SideParametersIn;}

/* ***************************************************************** */

/* class WeldFilletBothSidesType

*/

WeldFilletBothSidesType::WeldFilletBothSidesType()
{
  ArrowSide = 0;
  OtherSide = 0;
  Staggered = 0;
}

WeldFilletBothSidesType::WeldFilletBothSidesType(
 WeldFilletOneSideInBothSidesType * ArrowSideIn,
 WeldFilletOneSideInBothSidesType * OtherSideIn,
 XmlBoolean * StaggeredIn)
{
  ArrowSide = ArrowSideIn;
  OtherSide = OtherSideIn;
  Staggered = StaggeredIn;
}

WeldFilletBothSidesType::~WeldFilletBothSidesType()
{
  #ifndef NODESTRUCT
  delete ArrowSide;
  delete OtherSide;
  delete Staggered;
  #endif
}

void WeldFilletBothSidesType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (ArrowSide)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ArrowSide");
      ArrowSide->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ArrowSide>\n");
    }
  if (OtherSide)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OtherSide");
      OtherSide->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OtherSide>\n");
    }
  if (Staggered)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Staggered");
      Staggered->printSelf(outFile);
      fprintf(outFile, "</Staggered>\n");
    }
  doSpaces(-INDENT, outFile);
}

WeldFilletOneSideInBothSidesType * WeldFilletBothSidesType::getArrowSide()
{return ArrowSide;}

void WeldFilletBothSidesType::setArrowSide(WeldFilletOneSideInBothSidesType * ArrowSideIn)
{ArrowSide = ArrowSideIn;}

WeldFilletOneSideInBothSidesType * WeldFilletBothSidesType::getOtherSide()
{return OtherSide;}

void WeldFilletBothSidesType::setOtherSide(WeldFilletOneSideInBothSidesType * OtherSideIn)
{OtherSide = OtherSideIn;}

XmlBoolean * WeldFilletBothSidesType::getStaggered()
{return Staggered;}

void WeldFilletBothSidesType::setStaggered(XmlBoolean * StaggeredIn)
{Staggered = StaggeredIn;}

/* ***************************************************************** */

/* class WeldFilletCharacteristicDefinitionType

*/

WeldFilletCharacteristicDefinitionType::WeldFilletCharacteristicDefinitionType() :
  WeldCharacteristicDefinitionBaseType()
{
}

WeldFilletCharacteristicDefinitionType::WeldFilletCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  WeldCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

WeldFilletCharacteristicDefinitionType::WeldFilletCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  WeldCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

WeldFilletCharacteristicDefinitionType::~WeldFilletCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldFilletCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool WeldFilletCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldFilletCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldFilletCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldFilletCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldFilletCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldFilletCharacteristicItemType

*/

WeldFilletCharacteristicItemType::WeldFilletCharacteristicItemType() :
  WeldCharacteristicItemBaseType()
{
}

WeldFilletCharacteristicItemType::WeldFilletCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  WeldCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WeldFilletCharacteristicItemType::WeldFilletCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  WeldCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WeldFilletCharacteristicItemType::~WeldFilletCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldFilletCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WeldFilletCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldFilletCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldFilletCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldFilletCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldFilletCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldFilletCharacteristicMeasurementType

*/

WeldFilletCharacteristicMeasurementType::WeldFilletCharacteristicMeasurementType() :
  WeldCharacteristicMeasurementBaseType()
{
  LocationSignificance = 0;
  WeldFilletChara_1061 = 0;
}

WeldFilletCharacteristicMeasurementType::WeldFilletCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 LocationSignificanceAllEnumType * LocationSignificanceIn,
 WeldFilletChara_1061_Type * WeldFilletChara_1061In) :
  WeldCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  LocationSignificance = LocationSignificanceIn;
  WeldFilletChara_1061 = WeldFilletChara_1061In;
}

WeldFilletCharacteristicMeasurementType::WeldFilletCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 LocationSignificanceAllEnumType * LocationSignificanceIn,
 WeldFilletChara_1061_Type * WeldFilletChara_1061In) :
  WeldCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  LocationSignificance = LocationSignificanceIn;
  WeldFilletChara_1061 = WeldFilletChara_1061In;
}

WeldFilletCharacteristicMeasurementType::~WeldFilletCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  delete LocationSignificance;
  delete WeldFilletChara_1061;
  #endif
}

void WeldFilletCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<LocationSignificance");
  LocationSignificance->printSelf(outFile);
  fprintf(outFile, "</LocationSignificance>\n");
  if (WeldFilletChara_1061)
    {
  WeldFilletChara_1061->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WeldFilletCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldFilletCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldFilletCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldFilletCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldFilletCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LocationSignificanceAllEnumType * WeldFilletCharacteristicMeasurementType::getLocationSignificance()
{return LocationSignificance;}

void WeldFilletCharacteristicMeasurementType::setLocationSignificance(LocationSignificanceAllEnumType * LocationSignificanceIn)
{LocationSignificance = LocationSignificanceIn;}

WeldFilletChara_1061_Type * WeldFilletCharacteristicMeasurementType::getWeldFilletChara_1061()
{return WeldFilletChara_1061;}

void WeldFilletCharacteristicMeasurementType::setWeldFilletChara_1061(WeldFilletChara_1061_Type * WeldFilletChara_1061In)
{WeldFilletChara_1061 = WeldFilletChara_1061In;}

/* ***************************************************************** */

/* class WeldFilletCharacteristicNominalType

*/

WeldFilletCharacteristicNominalType::WeldFilletCharacteristicNominalType() :
  WeldCharacteristicNominalBaseType()
{
  LocationSignificance = 0;
  WeldFilletChara_1062 = 0;
}

WeldFilletCharacteristicNominalType::WeldFilletCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 LocationSignificanceAllEnumType * LocationSignificanceIn,
 WeldFilletChara_1062_Type * WeldFilletChara_1062In) :
  WeldCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn)
{
  LocationSignificance = LocationSignificanceIn;
  WeldFilletChara_1062 = WeldFilletChara_1062In;
}

WeldFilletCharacteristicNominalType::WeldFilletCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 LocationSignificanceAllEnumType * LocationSignificanceIn,
 WeldFilletChara_1062_Type * WeldFilletChara_1062In) :
  WeldCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn)
{
  LocationSignificance = LocationSignificanceIn;
  WeldFilletChara_1062 = WeldFilletChara_1062In;
}

WeldFilletCharacteristicNominalType::~WeldFilletCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  delete LocationSignificance;
  delete WeldFilletChara_1062;
  #endif
}

void WeldFilletCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (AllAround)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AllAround");
      AllAround->printSelf(outFile);
      fprintf(outFile, "</AllAround>\n");
    }
  if (Field)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Field");
      Field->printSelf(outFile);
      fprintf(outFile, "</Field>\n");
    }
  if (Specification)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Specification");
      Specification->printSelf(outFile);
      fprintf(outFile, "</Specification>\n");
    }
  if (WeldingProcess)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldingProcess");
      WeldingProcess->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldingProcess>\n");
    }
  if (NonDestructiveTesting)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonDestructiveTesting");
      NonDestructiveTesting->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NonDestructiveTesting>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<LocationSignificance");
  LocationSignificance->printSelf(outFile);
  fprintf(outFile, "</LocationSignificance>\n");
  if (WeldFilletChara_1062)
    {
  WeldFilletChara_1062->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WeldFilletCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldFilletCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldFilletCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldFilletCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldFilletCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LocationSignificanceAllEnumType * WeldFilletCharacteristicNominalType::getLocationSignificance()
{return LocationSignificance;}

void WeldFilletCharacteristicNominalType::setLocationSignificance(LocationSignificanceAllEnumType * LocationSignificanceIn)
{LocationSignificance = LocationSignificanceIn;}

WeldFilletChara_1062_Type * WeldFilletCharacteristicNominalType::getWeldFilletChara_1062()
{return WeldFilletChara_1062;}

void WeldFilletCharacteristicNominalType::setWeldFilletChara_1062(WeldFilletChara_1062_Type * WeldFilletChara_1062In)
{WeldFilletChara_1062 = WeldFilletChara_1062In;}

/* ***************************************************************** */

/* class WeldFilletEqualLegLengthType

*/

WeldFilletEqualLegLengthType::WeldFilletEqualLegLengthType()
{
  Size = 0;
  LengthOfEachWeld = 0;
  Pitch = 0;
}

WeldFilletEqualLegLengthType::WeldFilletEqualLegLengthType(
 FractionType * SizeIn,
 LinearValueType * LengthOfEachWeldIn,
 LinearValueType * PitchIn)
{
  Size = SizeIn;
  LengthOfEachWeld = LengthOfEachWeldIn;
  Pitch = PitchIn;
}

WeldFilletEqualLegLengthType::~WeldFilletEqualLegLengthType()
{
  #ifndef NODESTRUCT
  delete Size;
  delete LengthOfEachWeld;
  delete Pitch;
  #endif
}

void WeldFilletEqualLegLengthType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (LengthOfEachWeld)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LengthOfEachWeld");
      LengthOfEachWeld->printSelf(outFile);
      fprintf(outFile, "</LengthOfEachWeld>\n");
    }
  if (Pitch)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Pitch");
      Pitch->printSelf(outFile);
      fprintf(outFile, "</Pitch>\n");
    }
  doSpaces(-INDENT, outFile);
}

FractionType * WeldFilletEqualLegLengthType::getSize()
{return Size;}

void WeldFilletEqualLegLengthType::setSize(FractionType * SizeIn)
{Size = SizeIn;}

LinearValueType * WeldFilletEqualLegLengthType::getLengthOfEachWeld()
{return LengthOfEachWeld;}

void WeldFilletEqualLegLengthType::setLengthOfEachWeld(LinearValueType * LengthOfEachWeldIn)
{LengthOfEachWeld = LengthOfEachWeldIn;}

LinearValueType * WeldFilletEqualLegLengthType::getPitch()
{return Pitch;}

void WeldFilletEqualLegLengthType::setPitch(LinearValueType * PitchIn)
{Pitch = PitchIn;}

/* ***************************************************************** */

/* class WeldFilletOneSideInBothSidesType

*/

WeldFilletOneSideInBothSidesType::WeldFilletOneSideInBothSidesType() :
  WeldOneSideParametersExtendSizeType()
{
  LengthOfEachWeld = 0;
  Pitch = 0;
}

WeldFilletOneSideInBothSidesType::WeldFilletOneSideInBothSidesType(
 WeldFinishingType * FinishingIn,
 FractionType * SizeIn,
 LinearValueType * LengthOfEachWeldIn,
 LinearValueType * PitchIn) :
  WeldOneSideParametersExtendSizeType(
    FinishingIn,
    SizeIn)
{
  LengthOfEachWeld = LengthOfEachWeldIn;
  Pitch = PitchIn;
}

WeldFilletOneSideInBothSidesType::~WeldFilletOneSideInBothSidesType()
{
  #ifndef NODESTRUCT
  delete LengthOfEachWeld;
  delete Pitch;
  #endif
}

void WeldFilletOneSideInBothSidesType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Finishing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Finishing");
      Finishing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Finishing>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (LengthOfEachWeld)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LengthOfEachWeld");
      LengthOfEachWeld->printSelf(outFile);
      fprintf(outFile, "</LengthOfEachWeld>\n");
    }
  if (Pitch)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Pitch");
      Pitch->printSelf(outFile);
      fprintf(outFile, "</Pitch>\n");
    }
  doSpaces(-INDENT, outFile);
}

LinearValueType * WeldFilletOneSideInBothSidesType::getLengthOfEachWeld()
{return LengthOfEachWeld;}

void WeldFilletOneSideInBothSidesType::setLengthOfEachWeld(LinearValueType * LengthOfEachWeldIn)
{LengthOfEachWeld = LengthOfEachWeldIn;}

LinearValueType * WeldFilletOneSideInBothSidesType::getPitch()
{return Pitch;}

void WeldFilletOneSideInBothSidesType::setPitch(LinearValueType * PitchIn)
{Pitch = PitchIn;}

/* ***************************************************************** */

/* class WeldFilletOneSideType

*/

WeldFilletOneSideType::WeldFilletOneSideType() :
  WeldOneSideParametersBaseType()
{
  WeldFilletOneSideTypePair = 0;
}

WeldFilletOneSideType::WeldFilletOneSideType(
 WeldFinishingType * FinishingIn,
 WeldFilletOneSideTypeChoicePair * WeldFilletOneSideTypePairIn) :
  WeldOneSideParametersBaseType(
    FinishingIn)
{
  WeldFilletOneSideTypePair = WeldFilletOneSideTypePairIn;
}

WeldFilletOneSideType::~WeldFilletOneSideType()
{
  #ifndef NODESTRUCT
  delete WeldFilletOneSideTypePair;
  #endif
}

void WeldFilletOneSideType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Finishing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Finishing");
      Finishing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Finishing>\n");
    }
  if (WeldFilletOneSideTypePair)
    {
      WeldFilletOneSideTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}
WeldFilletOneSideTypeChoicePair * WeldFilletOneSideType::getWeldFilletOneSideTypeChoicePair()
{return WeldFilletOneSideTypePair;}

void WeldFilletOneSideType::setWeldFilletOneSideTypeChoicePair(WeldFilletOneSideTypeChoicePair * WeldFilletOneSideTypePairIn)
{WeldFilletOneSideTypePair = WeldFilletOneSideTypePairIn;}

/* ***************************************************************** */

WeldFilletOneSideTypeChoicePair::WeldFilletOneSideTypeChoicePair() {}

WeldFilletOneSideTypeChoicePair::WeldFilletOneSideTypeChoicePair(
 whichOne WeldFilletOneSideTypeTypeIn,
 WeldFilletOneSideTypeVal WeldFilletOneSideTypeValueIn)
{
  WeldFilletOneSideTypeType = WeldFilletOneSideTypeTypeIn;
  WeldFilletOneSideTypeValue = WeldFilletOneSideTypeValueIn;
}

WeldFilletOneSideTypeChoicePair::~WeldFilletOneSideTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (WeldFilletOneSideTypeType == EqualLegLengthE)
    delete WeldFilletOneSideTypeValue.EqualLegLength;
  else if (WeldFilletOneSideTypeType == UnEqualLegLengthE)
    delete WeldFilletOneSideTypeValue.UnEqualLegLength;
  #endif
}

void WeldFilletOneSideTypeChoicePair::printSelf(FILE * outFile)
{
  if (WeldFilletOneSideTypeType == EqualLegLengthE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EqualLegLength");
      WeldFilletOneSideTypeValue.EqualLegLength->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EqualLegLength>\n");
    }
  else if (WeldFilletOneSideTypeType == UnEqualLegLengthE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnEqualLegLength");
      WeldFilletOneSideTypeValue.UnEqualLegLength->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</UnEqualLegLength>\n");
    }
}

/* ***************************************************************** */

/* class WeldFilletUnequalLegLengthType

*/

WeldFilletUnequalLegLengthType::WeldFilletUnequalLegLengthType()
{
  FirstLegLength = 0;
  SecondLegLength = 0;
}

WeldFilletUnequalLegLengthType::WeldFilletUnequalLegLengthType(
 FractionType * FirstLegLengthIn,
 FractionType * SecondLegLengthIn)
{
  FirstLegLength = FirstLegLengthIn;
  SecondLegLength = SecondLegLengthIn;
}

WeldFilletUnequalLegLengthType::~WeldFilletUnequalLegLengthType()
{
  #ifndef NODESTRUCT
  delete FirstLegLength;
  delete SecondLegLength;
  #endif
}

void WeldFilletUnequalLegLengthType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<FirstLegLength");
  FirstLegLength->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</FirstLegLength>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<SecondLegLength");
  SecondLegLength->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</SecondLegLength>\n");
  doSpaces(-INDENT, outFile);
}

FractionType * WeldFilletUnequalLegLengthType::getFirstLegLength()
{return FirstLegLength;}

void WeldFilletUnequalLegLengthType::setFirstLegLength(FractionType * FirstLegLengthIn)
{FirstLegLength = FirstLegLengthIn;}

FractionType * WeldFilletUnequalLegLengthType::getSecondLegLength()
{return SecondLegLength;}

void WeldFilletUnequalLegLengthType::setSecondLegLength(FractionType * SecondLegLengthIn)
{SecondLegLength = SecondLegLengthIn;}

/* ***************************************************************** */

/* class WeldFinishingDesignatorEnumType

*/

WeldFinishingDesignatorEnumType::WeldFinishingDesignatorEnumType() :
  XmlString()
{
}

WeldFinishingDesignatorEnumType::WeldFinishingDesignatorEnumType(
 const char * valIn) :
  XmlString(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "MACHINING") &&
           strcmp(val.c_str(), "GRINDING") &&
           strcmp(val.c_str(), "CHIPPING") &&
           strcmp(val.c_str(), "HAMMERING") &&
           strcmp(val.c_str(), "ROLLING") &&
           strcmp(val.c_str(), "UNSPECIFIED"));
}

WeldFinishingDesignatorEnumType::~WeldFinishingDesignatorEnumType() {}

bool WeldFinishingDesignatorEnumType::WeldFinishingDesignatorEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "MACHINING") &&
          strcmp(val.c_str(), "GRINDING") &&
          strcmp(val.c_str(), "CHIPPING") &&
          strcmp(val.c_str(), "HAMMERING") &&
          strcmp(val.c_str(), "ROLLING") &&
          strcmp(val.c_str(), "UNSPECIFIED"));
}

void WeldFinishingDesignatorEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "WeldFinishingDesignatorEnumType");
}

void WeldFinishingDesignatorEnumType::printSelf(FILE * outFile)
{
  if (WeldFinishingDesignatorEnumTypeIsBad())
    {
      fprintf(stderr, "bad WeldFinishingDesignatorEnumType value, ");
      XmlString::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlString::printSelf(outFile);
}

void WeldFinishingDesignatorEnumType::oPrintSelf(FILE * outFile)
{
  if (WeldFinishingDesignatorEnumTypeIsBad())
    {
      fprintf(stderr, "bad WeldFinishingDesignatorEnumType value, ");
      XmlString::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlString::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class WeldFinishingType

*/

WeldFinishingType::WeldFinishingType()
{
  ContourSymbol = 0;
  FinishingDesignator = 0;
}

WeldFinishingType::WeldFinishingType(
 WeldContourSymbolEnumType * ContourSymbolIn,
 WeldFinishingDesignatorEnumType * FinishingDesignatorIn)
{
  ContourSymbol = ContourSymbolIn;
  FinishingDesignator = FinishingDesignatorIn;
}

WeldFinishingType::~WeldFinishingType()
{
  #ifndef NODESTRUCT
  delete ContourSymbol;
  delete FinishingDesignator;
  #endif
}

void WeldFinishingType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<ContourSymbol");
  ContourSymbol->printSelf(outFile);
  fprintf(outFile, "</ContourSymbol>\n");
  if (FinishingDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FinishingDesignator");
      FinishingDesignator->printSelf(outFile);
      fprintf(outFile, "</FinishingDesignator>\n");
    }
  doSpaces(-INDENT, outFile);
}

WeldContourSymbolEnumType * WeldFinishingType::getContourSymbol()
{return ContourSymbol;}

void WeldFinishingType::setContourSymbol(WeldContourSymbolEnumType * ContourSymbolIn)
{ContourSymbol = ContourSymbolIn;}

WeldFinishingDesignatorEnumType * WeldFinishingType::getFinishingDesignator()
{return FinishingDesignator;}

void WeldFinishingType::setFinishingDesignator(WeldFinishingDesignatorEnumType * FinishingDesignatorIn)
{FinishingDesignator = FinishingDesignatorIn;}

/* ***************************************************************** */

/* class WeldFlareBevelCharacteristicDefinitionType

*/

WeldFlareBevelCharacteristicDefinitionType::WeldFlareBevelCharacteristicDefinitionType() :
  WeldCharacteristicDefinitionBaseType()
{
}

WeldFlareBevelCharacteristicDefinitionType::WeldFlareBevelCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  WeldCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

WeldFlareBevelCharacteristicDefinitionType::WeldFlareBevelCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  WeldCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

WeldFlareBevelCharacteristicDefinitionType::~WeldFlareBevelCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldFlareBevelCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool WeldFlareBevelCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldFlareBevelCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldFlareBevelCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldFlareBevelCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldFlareBevelCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldFlareBevelCharacteristicItemType

*/

WeldFlareBevelCharacteristicItemType::WeldFlareBevelCharacteristicItemType() :
  WeldCharacteristicItemBaseType()
{
}

WeldFlareBevelCharacteristicItemType::WeldFlareBevelCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  WeldCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WeldFlareBevelCharacteristicItemType::WeldFlareBevelCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  WeldCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WeldFlareBevelCharacteristicItemType::~WeldFlareBevelCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldFlareBevelCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WeldFlareBevelCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldFlareBevelCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldFlareBevelCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldFlareBevelCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldFlareBevelCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldFlareBevelCharacteristicMeasurementType

*/

WeldFlareBevelCharacteristicMeasurementType::WeldFlareBevelCharacteristicMeasurementType() :
  WeldGrooveCharacteristicMeasurementType()
{
}

WeldFlareBevelCharacteristicMeasurementType::WeldFlareBevelCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 WeldGrooveCharacteristicMeasurementTypeChoicePair * WeldGrooveCharacteristicMeasurementTypePairIn) :
  WeldGrooveCharacteristicMeasurementType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    WeldGrooveCharacteristicMeasurementTypePairIn)
{
}

WeldFlareBevelCharacteristicMeasurementType::WeldFlareBevelCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 WeldGrooveCharacteristicMeasurementTypeChoicePair * WeldGrooveCharacteristicMeasurementTypePairIn) :
  WeldGrooveCharacteristicMeasurementType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    WeldGrooveCharacteristicMeasurementTypePairIn)
{
}

WeldFlareBevelCharacteristicMeasurementType::~WeldFlareBevelCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldFlareBevelCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (WeldGrooveCharacteristicMeasurementTypePair)
    {
      WeldGrooveCharacteristicMeasurementTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WeldFlareBevelCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldFlareBevelCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldFlareBevelCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldFlareBevelCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldFlareBevelCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldFlareBevelCharacteristicNominalType

*/

WeldFlareBevelCharacteristicNominalType::WeldFlareBevelCharacteristicNominalType() :
  WeldGrooveCharacteristicNominalType()
{
}

WeldFlareBevelCharacteristicNominalType::WeldFlareBevelCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 WeldGrooveCharacteristicNominalTypeChoicePair * WeldGrooveCharacteristicNominalTypePairIn) :
  WeldGrooveCharacteristicNominalType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn,
    WeldGrooveCharacteristicNominalTypePairIn)
{
}

WeldFlareBevelCharacteristicNominalType::WeldFlareBevelCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 WeldGrooveCharacteristicNominalTypeChoicePair * WeldGrooveCharacteristicNominalTypePairIn) :
  WeldGrooveCharacteristicNominalType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn,
    WeldGrooveCharacteristicNominalTypePairIn)
{
}

WeldFlareBevelCharacteristicNominalType::~WeldFlareBevelCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldFlareBevelCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (AllAround)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AllAround");
      AllAround->printSelf(outFile);
      fprintf(outFile, "</AllAround>\n");
    }
  if (Field)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Field");
      Field->printSelf(outFile);
      fprintf(outFile, "</Field>\n");
    }
  if (Specification)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Specification");
      Specification->printSelf(outFile);
      fprintf(outFile, "</Specification>\n");
    }
  if (WeldingProcess)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldingProcess");
      WeldingProcess->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldingProcess>\n");
    }
  if (NonDestructiveTesting)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonDestructiveTesting");
      NonDestructiveTesting->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NonDestructiveTesting>\n");
    }
  if (WeldGrooveCharacteristicNominalTypePair)
    {
      WeldGrooveCharacteristicNominalTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WeldFlareBevelCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldFlareBevelCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldFlareBevelCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldFlareBevelCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldFlareBevelCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldFlareVCharacteristicDefinitionType

*/

WeldFlareVCharacteristicDefinitionType::WeldFlareVCharacteristicDefinitionType() :
  WeldCharacteristicDefinitionBaseType()
{
}

WeldFlareVCharacteristicDefinitionType::WeldFlareVCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  WeldCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

WeldFlareVCharacteristicDefinitionType::WeldFlareVCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  WeldCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

WeldFlareVCharacteristicDefinitionType::~WeldFlareVCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldFlareVCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool WeldFlareVCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldFlareVCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldFlareVCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldFlareVCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldFlareVCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldFlareVCharacteristicItemType

*/

WeldFlareVCharacteristicItemType::WeldFlareVCharacteristicItemType() :
  WeldCharacteristicItemBaseType()
{
}

WeldFlareVCharacteristicItemType::WeldFlareVCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  WeldCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WeldFlareVCharacteristicItemType::WeldFlareVCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  WeldCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WeldFlareVCharacteristicItemType::~WeldFlareVCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldFlareVCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WeldFlareVCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldFlareVCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldFlareVCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldFlareVCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldFlareVCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldFlareVCharacteristicMeasurementType

*/

WeldFlareVCharacteristicMeasurementType::WeldFlareVCharacteristicMeasurementType() :
  WeldGrooveCharacteristicMeasurementType()
{
}

WeldFlareVCharacteristicMeasurementType::WeldFlareVCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 WeldGrooveCharacteristicMeasurementTypeChoicePair * WeldGrooveCharacteristicMeasurementTypePairIn) :
  WeldGrooveCharacteristicMeasurementType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    WeldGrooveCharacteristicMeasurementTypePairIn)
{
}

WeldFlareVCharacteristicMeasurementType::WeldFlareVCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 WeldGrooveCharacteristicMeasurementTypeChoicePair * WeldGrooveCharacteristicMeasurementTypePairIn) :
  WeldGrooveCharacteristicMeasurementType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    WeldGrooveCharacteristicMeasurementTypePairIn)
{
}

WeldFlareVCharacteristicMeasurementType::~WeldFlareVCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldFlareVCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (WeldGrooveCharacteristicMeasurementTypePair)
    {
      WeldGrooveCharacteristicMeasurementTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WeldFlareVCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldFlareVCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldFlareVCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldFlareVCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldFlareVCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldFlareVCharacteristicNominalType

*/

WeldFlareVCharacteristicNominalType::WeldFlareVCharacteristicNominalType() :
  WeldGrooveCharacteristicNominalType()
{
}

WeldFlareVCharacteristicNominalType::WeldFlareVCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 WeldGrooveCharacteristicNominalTypeChoicePair * WeldGrooveCharacteristicNominalTypePairIn) :
  WeldGrooveCharacteristicNominalType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn,
    WeldGrooveCharacteristicNominalTypePairIn)
{
}

WeldFlareVCharacteristicNominalType::WeldFlareVCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 WeldGrooveCharacteristicNominalTypeChoicePair * WeldGrooveCharacteristicNominalTypePairIn) :
  WeldGrooveCharacteristicNominalType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn,
    WeldGrooveCharacteristicNominalTypePairIn)
{
}

WeldFlareVCharacteristicNominalType::~WeldFlareVCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldFlareVCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (AllAround)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AllAround");
      AllAround->printSelf(outFile);
      fprintf(outFile, "</AllAround>\n");
    }
  if (Field)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Field");
      Field->printSelf(outFile);
      fprintf(outFile, "</Field>\n");
    }
  if (Specification)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Specification");
      Specification->printSelf(outFile);
      fprintf(outFile, "</Specification>\n");
    }
  if (WeldingProcess)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldingProcess");
      WeldingProcess->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldingProcess>\n");
    }
  if (NonDestructiveTesting)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonDestructiveTesting");
      NonDestructiveTesting->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NonDestructiveTesting>\n");
    }
  if (WeldGrooveCharacteristicNominalTypePair)
    {
      WeldGrooveCharacteristicNominalTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WeldFlareVCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldFlareVCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldFlareVCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldFlareVCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldFlareVCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldGrooveBothSidesBaseType

*/

WeldGrooveBothSidesBaseType::WeldGrooveBothSidesBaseType()
{
  ArrowSideParameters = 0;
  OtherSideParameters = 0;
}

WeldGrooveBothSidesBaseType::WeldGrooveBothSidesBaseType(
 WeldGrooveOneSideParametersType * ArrowSideParametersIn,
 WeldGrooveOneSideParametersType * OtherSideParametersIn)
{
  ArrowSideParameters = ArrowSideParametersIn;
  OtherSideParameters = OtherSideParametersIn;
}

WeldGrooveBothSidesBaseType::~WeldGrooveBothSidesBaseType()
{
  #ifndef NODESTRUCT
  delete ArrowSideParameters;
  delete OtherSideParameters;
  #endif
}

void WeldGrooveBothSidesBaseType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (ArrowSideParameters)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ArrowSideParameters");
      ArrowSideParameters->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ArrowSideParameters>\n");
    }
  if (OtherSideParameters)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OtherSideParameters");
      OtherSideParameters->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OtherSideParameters>\n");
    }
  doSpaces(-INDENT, outFile);
}

WeldGrooveOneSideParametersType * WeldGrooveBothSidesBaseType::getArrowSideParameters()
{return ArrowSideParameters;}

void WeldGrooveBothSidesBaseType::setArrowSideParameters(WeldGrooveOneSideParametersType * ArrowSideParametersIn)
{ArrowSideParameters = ArrowSideParametersIn;}

WeldGrooveOneSideParametersType * WeldGrooveBothSidesBaseType::getOtherSideParameters()
{return OtherSideParameters;}

void WeldGrooveBothSidesBaseType::setOtherSideParameters(WeldGrooveOneSideParametersType * OtherSideParametersIn)
{OtherSideParameters = OtherSideParametersIn;}

/* ***************************************************************** */

/* class WeldGrooveBothSidesExtendedType

*/

WeldGrooveBothSidesExtendedType::WeldGrooveBothSidesExtendedType() :
  WeldGrooveBothSidesBaseType()
{
  Spacer = 0;
}

WeldGrooveBothSidesExtendedType::WeldGrooveBothSidesExtendedType(
 WeldGrooveOneSideParametersType * ArrowSideParametersIn,
 WeldGrooveOneSideParametersType * OtherSideParametersIn,
 XmlBoolean * SpacerIn) :
  WeldGrooveBothSidesBaseType(
    ArrowSideParametersIn,
    OtherSideParametersIn)
{
  Spacer = SpacerIn;
}

WeldGrooveBothSidesExtendedType::~WeldGrooveBothSidesExtendedType()
{
  #ifndef NODESTRUCT
  delete Spacer;
  #endif
}

void WeldGrooveBothSidesExtendedType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (ArrowSideParameters)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ArrowSideParameters");
      ArrowSideParameters->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ArrowSideParameters>\n");
    }
  if (OtherSideParameters)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OtherSideParameters");
      OtherSideParameters->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OtherSideParameters>\n");
    }
  if (Spacer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Spacer");
      Spacer->printSelf(outFile);
      fprintf(outFile, "</Spacer>\n");
    }
  doSpaces(-INDENT, outFile);
}

XmlBoolean * WeldGrooveBothSidesExtendedType::getSpacer()
{return Spacer;}

void WeldGrooveBothSidesExtendedType::setSpacer(XmlBoolean * SpacerIn)
{Spacer = SpacerIn;}

/* ***************************************************************** */

/* class WeldGrooveCharacteristicMeasurementType

*/

WeldGrooveCharacteristicMeasurementType::WeldGrooveCharacteristicMeasurementType() :
  WeldCharacteristicMeasurementBaseType()
{
  WeldGrooveCharacteristicMeasurementTypePair = 0;
}

WeldGrooveCharacteristicMeasurementType::WeldGrooveCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 WeldGrooveCharacteristicMeasurementTypeChoicePair * WeldGrooveCharacteristicMeasurementTypePairIn) :
  WeldCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  WeldGrooveCharacteristicMeasurementTypePair = WeldGrooveCharacteristicMeasurementTypePairIn;
}

WeldGrooveCharacteristicMeasurementType::WeldGrooveCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 WeldGrooveCharacteristicMeasurementTypeChoicePair * WeldGrooveCharacteristicMeasurementTypePairIn) :
  WeldCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  WeldGrooveCharacteristicMeasurementTypePair = WeldGrooveCharacteristicMeasurementTypePairIn;
}

WeldGrooveCharacteristicMeasurementType::~WeldGrooveCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  delete WeldGrooveCharacteristicMeasurementTypePair;
  #endif
}

void WeldGrooveCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (WeldGrooveCharacteristicMeasurementTypePair)
    {
      WeldGrooveCharacteristicMeasurementTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}
WeldGrooveCharacteristicMeasurementTypeChoicePair * WeldGrooveCharacteristicMeasurementType::getWeldGrooveCharacteristicMeasurementTypeChoicePair()
{return WeldGrooveCharacteristicMeasurementTypePair;}

void WeldGrooveCharacteristicMeasurementType::setWeldGrooveCharacteristicMeasurementTypeChoicePair(WeldGrooveCharacteristicMeasurementTypeChoicePair * WeldGrooveCharacteristicMeasurementTypePairIn)
{WeldGrooveCharacteristicMeasurementTypePair = WeldGrooveCharacteristicMeasurementTypePairIn;}

/* ***************************************************************** */

WeldGrooveCharacteristicMeasurementTypeChoicePair::WeldGrooveCharacteristicMeasurementTypeChoicePair() {}

WeldGrooveCharacteristicMeasurementTypeChoicePair::WeldGrooveCharacteristicMeasurementTypeChoicePair(
 whichOne WeldGrooveCharacteristicMeasurementTypeTypeIn,
 WeldGrooveCharacteristicMeasurementTypeVal WeldGrooveCharacteristicMeasurementTypeValueIn)
{
  WeldGrooveCharacteristicMeasurementTypeType = WeldGrooveCharacteristicMeasurementTypeTypeIn;
  WeldGrooveCharacteristicMeasurementTypeValue = WeldGrooveCharacteristicMeasurementTypeValueIn;
}

WeldGrooveCharacteristicMeasurementTypeChoicePair::~WeldGrooveCharacteristicMeasurementTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (WeldGrooveCharacteristicMeasurementTypeType == OneSideE)
    delete WeldGrooveCharacteristicMeasurementTypeValue.OneSide;
  else if (WeldGrooveCharacteristicMeasurementTypeType == BothSidesE)
    delete WeldGrooveCharacteristicMeasurementTypeValue.BothSides;
  #endif
}

void WeldGrooveCharacteristicMeasurementTypeChoicePair::printSelf(FILE * outFile)
{
  if (WeldGrooveCharacteristicMeasurementTypeType == OneSideE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OneSide");
      WeldGrooveCharacteristicMeasurementTypeValue.OneSide->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OneSide>\n");
    }
  else if (WeldGrooveCharacteristicMeasurementTypeType == BothSidesE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BothSides");
      WeldGrooveCharacteristicMeasurementTypeValue.BothSides->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BothSides>\n");
    }
}

bool WeldGrooveCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldGrooveCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldGrooveCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldGrooveCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldGrooveCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldGrooveCharacteristicNominalType

*/

WeldGrooveCharacteristicNominalType::WeldGrooveCharacteristicNominalType() :
  WeldCharacteristicNominalBaseType()
{
  WeldGrooveCharacteristicNominalTypePair = 0;
}

WeldGrooveCharacteristicNominalType::WeldGrooveCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 WeldGrooveCharacteristicNominalTypeChoicePair * WeldGrooveCharacteristicNominalTypePairIn) :
  WeldCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn)
{
  WeldGrooveCharacteristicNominalTypePair = WeldGrooveCharacteristicNominalTypePairIn;
}

WeldGrooveCharacteristicNominalType::WeldGrooveCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 WeldGrooveCharacteristicNominalTypeChoicePair * WeldGrooveCharacteristicNominalTypePairIn) :
  WeldCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn)
{
  WeldGrooveCharacteristicNominalTypePair = WeldGrooveCharacteristicNominalTypePairIn;
}

WeldGrooveCharacteristicNominalType::~WeldGrooveCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  delete WeldGrooveCharacteristicNominalTypePair;
  #endif
}

void WeldGrooveCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (AllAround)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AllAround");
      AllAround->printSelf(outFile);
      fprintf(outFile, "</AllAround>\n");
    }
  if (Field)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Field");
      Field->printSelf(outFile);
      fprintf(outFile, "</Field>\n");
    }
  if (Specification)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Specification");
      Specification->printSelf(outFile);
      fprintf(outFile, "</Specification>\n");
    }
  if (WeldingProcess)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldingProcess");
      WeldingProcess->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldingProcess>\n");
    }
  if (NonDestructiveTesting)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonDestructiveTesting");
      NonDestructiveTesting->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NonDestructiveTesting>\n");
    }
  if (WeldGrooveCharacteristicNominalTypePair)
    {
      WeldGrooveCharacteristicNominalTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}
WeldGrooveCharacteristicNominalTypeChoicePair * WeldGrooveCharacteristicNominalType::getWeldGrooveCharacteristicNominalTypeChoicePair()
{return WeldGrooveCharacteristicNominalTypePair;}

void WeldGrooveCharacteristicNominalType::setWeldGrooveCharacteristicNominalTypeChoicePair(WeldGrooveCharacteristicNominalTypeChoicePair * WeldGrooveCharacteristicNominalTypePairIn)
{WeldGrooveCharacteristicNominalTypePair = WeldGrooveCharacteristicNominalTypePairIn;}

/* ***************************************************************** */

WeldGrooveCharacteristicNominalTypeChoicePair::WeldGrooveCharacteristicNominalTypeChoicePair() {}

WeldGrooveCharacteristicNominalTypeChoicePair::WeldGrooveCharacteristicNominalTypeChoicePair(
 whichOne WeldGrooveCharacteristicNominalTypeTypeIn,
 WeldGrooveCharacteristicNominalTypeVal WeldGrooveCharacteristicNominalTypeValueIn)
{
  WeldGrooveCharacteristicNominalTypeType = WeldGrooveCharacteristicNominalTypeTypeIn;
  WeldGrooveCharacteristicNominalTypeValue = WeldGrooveCharacteristicNominalTypeValueIn;
}

WeldGrooveCharacteristicNominalTypeChoicePair::~WeldGrooveCharacteristicNominalTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (WeldGrooveCharacteristicNominalTypeType == OneSideE)
    delete WeldGrooveCharacteristicNominalTypeValue.OneSide;
  else if (WeldGrooveCharacteristicNominalTypeType == BothSidesE)
    delete WeldGrooveCharacteristicNominalTypeValue.BothSides;
  #endif
}

void WeldGrooveCharacteristicNominalTypeChoicePair::printSelf(FILE * outFile)
{
  if (WeldGrooveCharacteristicNominalTypeType == OneSideE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OneSide");
      WeldGrooveCharacteristicNominalTypeValue.OneSide->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OneSide>\n");
    }
  else if (WeldGrooveCharacteristicNominalTypeType == BothSidesE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BothSides");
      WeldGrooveCharacteristicNominalTypeValue.BothSides->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BothSides>\n");
    }
}

bool WeldGrooveCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldGrooveCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldGrooveCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldGrooveCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldGrooveCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldGrooveOneSideParametersType

*/

WeldGrooveOneSideParametersType::WeldGrooveOneSideParametersType() :
  WeldOneSideParametersExtendSizeType()
{
  Groove = 0;
  Angle = 0;
  RootOpening = 0;
  Length = 0;
  Pitch = 0;
}

WeldGrooveOneSideParametersType::WeldGrooveOneSideParametersType(
 WeldFinishingType * FinishingIn,
 FractionType * SizeIn,
 FractionType * GrooveIn,
 AngularValueType * AngleIn,
 FractionType * RootOpeningIn,
 LinearValueType * LengthIn,
 LinearValueType * PitchIn) :
  WeldOneSideParametersExtendSizeType(
    FinishingIn,
    SizeIn)
{
  Groove = GrooveIn;
  Angle = AngleIn;
  RootOpening = RootOpeningIn;
  Length = LengthIn;
  Pitch = PitchIn;
}

WeldGrooveOneSideParametersType::~WeldGrooveOneSideParametersType()
{
  #ifndef NODESTRUCT
  delete Groove;
  delete Angle;
  delete RootOpening;
  delete Length;
  delete Pitch;
  #endif
}

void WeldGrooveOneSideParametersType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Finishing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Finishing");
      Finishing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Finishing>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (Groove)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Groove");
      Groove->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Groove>\n");
    }
  if (Angle)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Angle");
      Angle->printSelf(outFile);
      fprintf(outFile, "</Angle>\n");
    }
  if (RootOpening)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<RootOpening");
      RootOpening->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</RootOpening>\n");
    }
  if (Length)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Length");
      Length->printSelf(outFile);
      fprintf(outFile, "</Length>\n");
    }
  if (Pitch)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Pitch");
      Pitch->printSelf(outFile);
      fprintf(outFile, "</Pitch>\n");
    }
  doSpaces(-INDENT, outFile);
}

FractionType * WeldGrooveOneSideParametersType::getGroove()
{return Groove;}

void WeldGrooveOneSideParametersType::setGroove(FractionType * GrooveIn)
{Groove = GrooveIn;}

AngularValueType * WeldGrooveOneSideParametersType::getAngle()
{return Angle;}

void WeldGrooveOneSideParametersType::setAngle(AngularValueType * AngleIn)
{Angle = AngleIn;}

FractionType * WeldGrooveOneSideParametersType::getRootOpening()
{return RootOpening;}

void WeldGrooveOneSideParametersType::setRootOpening(FractionType * RootOpeningIn)
{RootOpening = RootOpeningIn;}

LinearValueType * WeldGrooveOneSideParametersType::getLength()
{return Length;}

void WeldGrooveOneSideParametersType::setLength(LinearValueType * LengthIn)
{Length = LengthIn;}

LinearValueType * WeldGrooveOneSideParametersType::getPitch()
{return Pitch;}

void WeldGrooveOneSideParametersType::setPitch(LinearValueType * PitchIn)
{Pitch = PitchIn;}

/* ***************************************************************** */

/* class WeldGrooveOneSideType

*/

WeldGrooveOneSideType::WeldGrooveOneSideType()
{
  LocationSignificance = 0;
  WeldGrooveOneSi_1063 = 0;
}

WeldGrooveOneSideType::WeldGrooveOneSideType(
 LocationSignificanceOneSidesEnumType * LocationSignificanceIn,
 WeldGrooveOneSi_1063_Type * WeldGrooveOneSi_1063In)
{
  LocationSignificance = LocationSignificanceIn;
  WeldGrooveOneSi_1063 = WeldGrooveOneSi_1063In;
}

WeldGrooveOneSideType::~WeldGrooveOneSideType()
{
  #ifndef NODESTRUCT
  delete LocationSignificance;
  delete WeldGrooveOneSi_1063;
  #endif
}

void WeldGrooveOneSideType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<LocationSignificance");
  LocationSignificance->printSelf(outFile);
  fprintf(outFile, "</LocationSignificance>\n");
  WeldGrooveOneSi_1063->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

LocationSignificanceOneSidesEnumType * WeldGrooveOneSideType::getLocationSignificance()
{return LocationSignificance;}

void WeldGrooveOneSideType::setLocationSignificance(LocationSignificanceOneSidesEnumType * LocationSignificanceIn)
{LocationSignificance = LocationSignificanceIn;}

WeldGrooveOneSi_1063_Type * WeldGrooveOneSideType::getWeldGrooveOneSi_1063()
{return WeldGrooveOneSi_1063;}

void WeldGrooveOneSideType::setWeldGrooveOneSi_1063(WeldGrooveOneSi_1063_Type * WeldGrooveOneSi_1063In)
{WeldGrooveOneSi_1063 = WeldGrooveOneSi_1063In;}

/* ***************************************************************** */

/* class WeldJCharacteristicDefinitionType

*/

WeldJCharacteristicDefinitionType::WeldJCharacteristicDefinitionType() :
  WeldCharacteristicDefinitionBaseType()
{
}

WeldJCharacteristicDefinitionType::WeldJCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  WeldCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

WeldJCharacteristicDefinitionType::WeldJCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  WeldCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

WeldJCharacteristicDefinitionType::~WeldJCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldJCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool WeldJCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldJCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldJCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldJCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldJCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldJCharacteristicItemType

*/

WeldJCharacteristicItemType::WeldJCharacteristicItemType() :
  WeldCharacteristicItemBaseType()
{
}

WeldJCharacteristicItemType::WeldJCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  WeldCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WeldJCharacteristicItemType::WeldJCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  WeldCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WeldJCharacteristicItemType::~WeldJCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldJCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WeldJCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldJCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldJCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldJCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldJCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldJCharacteristicMeasurementType

*/

WeldJCharacteristicMeasurementType::WeldJCharacteristicMeasurementType() :
  WeldGrooveCharacteristicMeasurementType()
{
}

WeldJCharacteristicMeasurementType::WeldJCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 WeldGrooveCharacteristicMeasurementTypeChoicePair * WeldGrooveCharacteristicMeasurementTypePairIn) :
  WeldGrooveCharacteristicMeasurementType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    WeldGrooveCharacteristicMeasurementTypePairIn)
{
}

WeldJCharacteristicMeasurementType::WeldJCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 WeldGrooveCharacteristicMeasurementTypeChoicePair * WeldGrooveCharacteristicMeasurementTypePairIn) :
  WeldGrooveCharacteristicMeasurementType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    WeldGrooveCharacteristicMeasurementTypePairIn)
{
}

WeldJCharacteristicMeasurementType::~WeldJCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldJCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (WeldGrooveCharacteristicMeasurementTypePair)
    {
      WeldGrooveCharacteristicMeasurementTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WeldJCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldJCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldJCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldJCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldJCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldJCharacteristicNominalType

*/

WeldJCharacteristicNominalType::WeldJCharacteristicNominalType() :
  WeldGrooveCharacteristicNominalType()
{
}

WeldJCharacteristicNominalType::WeldJCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 WeldGrooveCharacteristicNominalTypeChoicePair * WeldGrooveCharacteristicNominalTypePairIn) :
  WeldGrooveCharacteristicNominalType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn,
    WeldGrooveCharacteristicNominalTypePairIn)
{
}

WeldJCharacteristicNominalType::WeldJCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 WeldGrooveCharacteristicNominalTypeChoicePair * WeldGrooveCharacteristicNominalTypePairIn) :
  WeldGrooveCharacteristicNominalType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn,
    WeldGrooveCharacteristicNominalTypePairIn)
{
}

WeldJCharacteristicNominalType::~WeldJCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldJCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (AllAround)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AllAround");
      AllAround->printSelf(outFile);
      fprintf(outFile, "</AllAround>\n");
    }
  if (Field)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Field");
      Field->printSelf(outFile);
      fprintf(outFile, "</Field>\n");
    }
  if (Specification)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Specification");
      Specification->printSelf(outFile);
      fprintf(outFile, "</Specification>\n");
    }
  if (WeldingProcess)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldingProcess");
      WeldingProcess->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldingProcess>\n");
    }
  if (NonDestructiveTesting)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonDestructiveTesting");
      NonDestructiveTesting->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NonDestructiveTesting>\n");
    }
  if (WeldGrooveCharacteristicNominalTypePair)
    {
      WeldGrooveCharacteristicNominalTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WeldJCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldJCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldJCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldJCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldJCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldOneSideParametersBaseType

*/

WeldOneSideParametersBaseType::WeldOneSideParametersBaseType()
{
  Finishing = 0;
}

WeldOneSideParametersBaseType::WeldOneSideParametersBaseType(
 WeldFinishingType * FinishingIn)
{
  Finishing = FinishingIn;
}

WeldOneSideParametersBaseType::~WeldOneSideParametersBaseType()
{
  #ifndef NODESTRUCT
  delete Finishing;
  #endif
}

void WeldOneSideParametersBaseType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Finishing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Finishing");
      Finishing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Finishing>\n");
    }
  doSpaces(-INDENT, outFile);
}

WeldFinishingType * WeldOneSideParametersBaseType::getFinishing()
{return Finishing;}

void WeldOneSideParametersBaseType::setFinishing(WeldFinishingType * FinishingIn)
{Finishing = FinishingIn;}

/* ***************************************************************** */

/* class WeldOneSideParametersExtendSizeType

*/

WeldOneSideParametersExtendSizeType::WeldOneSideParametersExtendSizeType() :
  WeldOneSideParametersBaseType()
{
  Size = 0;
}

WeldOneSideParametersExtendSizeType::WeldOneSideParametersExtendSizeType(
 WeldFinishingType * FinishingIn,
 FractionType * SizeIn) :
  WeldOneSideParametersBaseType(
    FinishingIn)
{
  Size = SizeIn;
}

WeldOneSideParametersExtendSizeType::~WeldOneSideParametersExtendSizeType()
{
  #ifndef NODESTRUCT
  delete Size;
  #endif
}

void WeldOneSideParametersExtendSizeType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Finishing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Finishing");
      Finishing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Finishing>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  doSpaces(-INDENT, outFile);
}

FractionType * WeldOneSideParametersExtendSizeType::getSize()
{return Size;}

void WeldOneSideParametersExtendSizeType::setSize(FractionType * SizeIn)
{Size = SizeIn;}

/* ***************************************************************** */

/* class WeldOneSideParametersExtendType

*/

WeldOneSideParametersExtendType::WeldOneSideParametersExtendType() :
  WeldOneSideParametersExtendSizeType()
{
  Length = 0;
  Pitch = 0;
  WeldNumber = 0;
}

WeldOneSideParametersExtendType::WeldOneSideParametersExtendType(
 WeldFinishingType * FinishingIn,
 FractionType * SizeIn,
 LinearValueType * LengthIn,
 LinearValueType * PitchIn,
 NaturalType * WeldNumberIn) :
  WeldOneSideParametersExtendSizeType(
    FinishingIn,
    SizeIn)
{
  Length = LengthIn;
  Pitch = PitchIn;
  WeldNumber = WeldNumberIn;
}

WeldOneSideParametersExtendType::~WeldOneSideParametersExtendType()
{
  #ifndef NODESTRUCT
  delete Length;
  delete Pitch;
  delete WeldNumber;
  #endif
}

void WeldOneSideParametersExtendType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Finishing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Finishing");
      Finishing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Finishing>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (Length)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Length");
      Length->printSelf(outFile);
      fprintf(outFile, "</Length>\n");
    }
  if (Pitch)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Pitch");
      Pitch->printSelf(outFile);
      fprintf(outFile, "</Pitch>\n");
    }
  if (WeldNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldNumber");
      WeldNumber->printSelf(outFile);
      fprintf(outFile, "</WeldNumber>\n");
    }
  doSpaces(-INDENT, outFile);
}

LinearValueType * WeldOneSideParametersExtendType::getLength()
{return Length;}

void WeldOneSideParametersExtendType::setLength(LinearValueType * LengthIn)
{Length = LengthIn;}

LinearValueType * WeldOneSideParametersExtendType::getPitch()
{return Pitch;}

void WeldOneSideParametersExtendType::setPitch(LinearValueType * PitchIn)
{Pitch = PitchIn;}

NaturalType * WeldOneSideParametersExtendType::getWeldNumber()
{return WeldNumber;}

void WeldOneSideParametersExtendType::setWeldNumber(NaturalType * WeldNumberIn)
{WeldNumber = WeldNumberIn;}

/* ***************************************************************** */

/* class WeldPlugCharacteristicDefinitionType

*/

WeldPlugCharacteristicDefinitionType::WeldPlugCharacteristicDefinitionType() :
  WeldCharacteristicDefinitionBaseType()
{
}

WeldPlugCharacteristicDefinitionType::WeldPlugCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  WeldCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

WeldPlugCharacteristicDefinitionType::WeldPlugCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  WeldCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

WeldPlugCharacteristicDefinitionType::~WeldPlugCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldPlugCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool WeldPlugCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldPlugCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldPlugCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldPlugCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldPlugCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldPlugCharacteristicItemType

*/

WeldPlugCharacteristicItemType::WeldPlugCharacteristicItemType() :
  WeldCharacteristicItemBaseType()
{
}

WeldPlugCharacteristicItemType::WeldPlugCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  WeldCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WeldPlugCharacteristicItemType::WeldPlugCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  WeldCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WeldPlugCharacteristicItemType::~WeldPlugCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldPlugCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WeldPlugCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldPlugCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldPlugCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldPlugCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldPlugCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldPlugCharacteristicMeasurementType

*/

WeldPlugCharacteristicMeasurementType::WeldPlugCharacteristicMeasurementType() :
  WeldCharacteristicMeasurementBaseType()
{
  LocationSignificance = 0;
  SideParameters = 0;
}

WeldPlugCharacteristicMeasurementType::WeldPlugCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 LocationSignificanceOneSidesEnumType * LocationSignificanceIn,
 WeldPlugOneSideParametersType * SideParametersIn) :
  WeldCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  LocationSignificance = LocationSignificanceIn;
  SideParameters = SideParametersIn;
}

WeldPlugCharacteristicMeasurementType::WeldPlugCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 LocationSignificanceOneSidesEnumType * LocationSignificanceIn,
 WeldPlugOneSideParametersType * SideParametersIn) :
  WeldCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  LocationSignificance = LocationSignificanceIn;
  SideParameters = SideParametersIn;
}

WeldPlugCharacteristicMeasurementType::~WeldPlugCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  delete LocationSignificance;
  delete SideParameters;
  #endif
}

void WeldPlugCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<LocationSignificance");
  LocationSignificance->printSelf(outFile);
  fprintf(outFile, "</LocationSignificance>\n");
  if (SideParameters)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SideParameters");
      SideParameters->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SideParameters>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool WeldPlugCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldPlugCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldPlugCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldPlugCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldPlugCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LocationSignificanceOneSidesEnumType * WeldPlugCharacteristicMeasurementType::getLocationSignificance()
{return LocationSignificance;}

void WeldPlugCharacteristicMeasurementType::setLocationSignificance(LocationSignificanceOneSidesEnumType * LocationSignificanceIn)
{LocationSignificance = LocationSignificanceIn;}

WeldPlugOneSideParametersType * WeldPlugCharacteristicMeasurementType::getSideParameters()
{return SideParameters;}

void WeldPlugCharacteristicMeasurementType::setSideParameters(WeldPlugOneSideParametersType * SideParametersIn)
{SideParameters = SideParametersIn;}

/* ***************************************************************** */

/* class WeldPlugCharacteristicNominalType

*/

WeldPlugCharacteristicNominalType::WeldPlugCharacteristicNominalType() :
  WeldCharacteristicNominalBaseType()
{
  LocationSignificance = 0;
  SideParameters = 0;
}

WeldPlugCharacteristicNominalType::WeldPlugCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 LocationSignificanceOneSidesEnumType * LocationSignificanceIn,
 WeldPlugOneSideParametersType * SideParametersIn) :
  WeldCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn)
{
  LocationSignificance = LocationSignificanceIn;
  SideParameters = SideParametersIn;
}

WeldPlugCharacteristicNominalType::WeldPlugCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 LocationSignificanceOneSidesEnumType * LocationSignificanceIn,
 WeldPlugOneSideParametersType * SideParametersIn) :
  WeldCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn)
{
  LocationSignificance = LocationSignificanceIn;
  SideParameters = SideParametersIn;
}

WeldPlugCharacteristicNominalType::~WeldPlugCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  delete LocationSignificance;
  delete SideParameters;
  #endif
}

void WeldPlugCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (AllAround)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AllAround");
      AllAround->printSelf(outFile);
      fprintf(outFile, "</AllAround>\n");
    }
  if (Field)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Field");
      Field->printSelf(outFile);
      fprintf(outFile, "</Field>\n");
    }
  if (Specification)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Specification");
      Specification->printSelf(outFile);
      fprintf(outFile, "</Specification>\n");
    }
  if (WeldingProcess)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldingProcess");
      WeldingProcess->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldingProcess>\n");
    }
  if (NonDestructiveTesting)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonDestructiveTesting");
      NonDestructiveTesting->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NonDestructiveTesting>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<LocationSignificance");
  LocationSignificance->printSelf(outFile);
  fprintf(outFile, "</LocationSignificance>\n");
  if (SideParameters)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SideParameters");
      SideParameters->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SideParameters>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool WeldPlugCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldPlugCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldPlugCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldPlugCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldPlugCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LocationSignificanceOneSidesEnumType * WeldPlugCharacteristicNominalType::getLocationSignificance()
{return LocationSignificance;}

void WeldPlugCharacteristicNominalType::setLocationSignificance(LocationSignificanceOneSidesEnumType * LocationSignificanceIn)
{LocationSignificance = LocationSignificanceIn;}

WeldPlugOneSideParametersType * WeldPlugCharacteristicNominalType::getSideParameters()
{return SideParameters;}

void WeldPlugCharacteristicNominalType::setSideParameters(WeldPlugOneSideParametersType * SideParametersIn)
{SideParameters = SideParametersIn;}

/* ***************************************************************** */

/* class WeldPlugOneSideParametersType

*/

WeldPlugOneSideParametersType::WeldPlugOneSideParametersType() :
  WeldOneSideParametersExtendType()
{
  Angle = 0;
  Depth = 0;
}

WeldPlugOneSideParametersType::WeldPlugOneSideParametersType(
 WeldFinishingType * FinishingIn,
 FractionType * SizeIn,
 LinearValueType * LengthIn,
 LinearValueType * PitchIn,
 NaturalType * WeldNumberIn,
 AngularValueType * AngleIn,
 FractionType * DepthIn) :
  WeldOneSideParametersExtendType(
    FinishingIn,
    SizeIn,
    LengthIn,
    PitchIn,
    WeldNumberIn)
{
  Angle = AngleIn;
  Depth = DepthIn;
}

WeldPlugOneSideParametersType::~WeldPlugOneSideParametersType()
{
  #ifndef NODESTRUCT
  delete Angle;
  delete Depth;
  #endif
}

void WeldPlugOneSideParametersType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Finishing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Finishing");
      Finishing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Finishing>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (Length)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Length");
      Length->printSelf(outFile);
      fprintf(outFile, "</Length>\n");
    }
  if (Pitch)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Pitch");
      Pitch->printSelf(outFile);
      fprintf(outFile, "</Pitch>\n");
    }
  if (WeldNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldNumber");
      WeldNumber->printSelf(outFile);
      fprintf(outFile, "</WeldNumber>\n");
    }
  if (Angle)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Angle");
      Angle->printSelf(outFile);
      fprintf(outFile, "</Angle>\n");
    }
  if (Depth)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Depth");
      Depth->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Depth>\n");
    }
  doSpaces(-INDENT, outFile);
}

AngularValueType * WeldPlugOneSideParametersType::getAngle()
{return Angle;}

void WeldPlugOneSideParametersType::setAngle(AngularValueType * AngleIn)
{Angle = AngleIn;}

FractionType * WeldPlugOneSideParametersType::getDepth()
{return Depth;}

void WeldPlugOneSideParametersType::setDepth(FractionType * DepthIn)
{Depth = DepthIn;}

/* ***************************************************************** */

/* class WeldScarfCharacteristicDefinitionType

*/

WeldScarfCharacteristicDefinitionType::WeldScarfCharacteristicDefinitionType() :
  WeldCharacteristicDefinitionBaseType()
{
}

WeldScarfCharacteristicDefinitionType::WeldScarfCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  WeldCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

WeldScarfCharacteristicDefinitionType::WeldScarfCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  WeldCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

WeldScarfCharacteristicDefinitionType::~WeldScarfCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldScarfCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool WeldScarfCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldScarfCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldScarfCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldScarfCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldScarfCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldScarfCharacteristicItemType

*/

WeldScarfCharacteristicItemType::WeldScarfCharacteristicItemType() :
  WeldCharacteristicItemBaseType()
{
}

WeldScarfCharacteristicItemType::WeldScarfCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  WeldCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WeldScarfCharacteristicItemType::WeldScarfCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  WeldCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WeldScarfCharacteristicItemType::~WeldScarfCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldScarfCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WeldScarfCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldScarfCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldScarfCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldScarfCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldScarfCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldScarfCharacteristicMeasurementType

*/

WeldScarfCharacteristicMeasurementType::WeldScarfCharacteristicMeasurementType() :
  WeldGrooveCharacteristicMeasurementType()
{
}

WeldScarfCharacteristicMeasurementType::WeldScarfCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 WeldGrooveCharacteristicMeasurementTypeChoicePair * WeldGrooveCharacteristicMeasurementTypePairIn) :
  WeldGrooveCharacteristicMeasurementType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    WeldGrooveCharacteristicMeasurementTypePairIn)
{
}

WeldScarfCharacteristicMeasurementType::WeldScarfCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 WeldGrooveCharacteristicMeasurementTypeChoicePair * WeldGrooveCharacteristicMeasurementTypePairIn) :
  WeldGrooveCharacteristicMeasurementType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    WeldGrooveCharacteristicMeasurementTypePairIn)
{
}

WeldScarfCharacteristicMeasurementType::~WeldScarfCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldScarfCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (WeldGrooveCharacteristicMeasurementTypePair)
    {
      WeldGrooveCharacteristicMeasurementTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WeldScarfCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldScarfCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldScarfCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldScarfCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldScarfCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldScarfCharacteristicNominalType

*/

WeldScarfCharacteristicNominalType::WeldScarfCharacteristicNominalType() :
  WeldGrooveCharacteristicNominalType()
{
}

WeldScarfCharacteristicNominalType::WeldScarfCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 WeldGrooveCharacteristicNominalTypeChoicePair * WeldGrooveCharacteristicNominalTypePairIn) :
  WeldGrooveCharacteristicNominalType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn,
    WeldGrooveCharacteristicNominalTypePairIn)
{
}

WeldScarfCharacteristicNominalType::WeldScarfCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 WeldGrooveCharacteristicNominalTypeChoicePair * WeldGrooveCharacteristicNominalTypePairIn) :
  WeldGrooveCharacteristicNominalType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn,
    WeldGrooveCharacteristicNominalTypePairIn)
{
}

WeldScarfCharacteristicNominalType::~WeldScarfCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldScarfCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (AllAround)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AllAround");
      AllAround->printSelf(outFile);
      fprintf(outFile, "</AllAround>\n");
    }
  if (Field)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Field");
      Field->printSelf(outFile);
      fprintf(outFile, "</Field>\n");
    }
  if (Specification)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Specification");
      Specification->printSelf(outFile);
      fprintf(outFile, "</Specification>\n");
    }
  if (WeldingProcess)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldingProcess");
      WeldingProcess->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldingProcess>\n");
    }
  if (NonDestructiveTesting)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonDestructiveTesting");
      NonDestructiveTesting->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NonDestructiveTesting>\n");
    }
  if (WeldGrooveCharacteristicNominalTypePair)
    {
      WeldGrooveCharacteristicNominalTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WeldScarfCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldScarfCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldScarfCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldScarfCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldScarfCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldSeamCharacteristicDefinitionType

*/

WeldSeamCharacteristicDefinitionType::WeldSeamCharacteristicDefinitionType() :
  WeldCharacteristicDefinitionBaseType()
{
}

WeldSeamCharacteristicDefinitionType::WeldSeamCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  WeldCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

WeldSeamCharacteristicDefinitionType::WeldSeamCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  WeldCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

WeldSeamCharacteristicDefinitionType::~WeldSeamCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldSeamCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool WeldSeamCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldSeamCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldSeamCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldSeamCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldSeamCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldSeamCharacteristicItemType

*/

WeldSeamCharacteristicItemType::WeldSeamCharacteristicItemType() :
  WeldCharacteristicItemBaseType()
{
}

WeldSeamCharacteristicItemType::WeldSeamCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  WeldCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WeldSeamCharacteristicItemType::WeldSeamCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  WeldCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WeldSeamCharacteristicItemType::~WeldSeamCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldSeamCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WeldSeamCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldSeamCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldSeamCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldSeamCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldSeamCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldSeamCharacteristicMeasurementType

*/

WeldSeamCharacteristicMeasurementType::WeldSeamCharacteristicMeasurementType() :
  WeldCharacteristicMeasurementBaseType()
{
  LocationSignificance = 0;
  SideParameters = 0;
}

WeldSeamCharacteristicMeasurementType::WeldSeamCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 LocationSignificanceSpotSeamEnumType * LocationSignificanceIn,
 WeldOneSideParametersExtendType * SideParametersIn) :
  WeldCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  LocationSignificance = LocationSignificanceIn;
  SideParameters = SideParametersIn;
}

WeldSeamCharacteristicMeasurementType::WeldSeamCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 LocationSignificanceSpotSeamEnumType * LocationSignificanceIn,
 WeldOneSideParametersExtendType * SideParametersIn) :
  WeldCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  LocationSignificance = LocationSignificanceIn;
  SideParameters = SideParametersIn;
}

WeldSeamCharacteristicMeasurementType::~WeldSeamCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  delete LocationSignificance;
  delete SideParameters;
  #endif
}

void WeldSeamCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<LocationSignificance");
  LocationSignificance->printSelf(outFile);
  fprintf(outFile, "</LocationSignificance>\n");
  if (SideParameters)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SideParameters");
      SideParameters->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SideParameters>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool WeldSeamCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldSeamCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldSeamCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldSeamCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldSeamCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LocationSignificanceSpotSeamEnumType * WeldSeamCharacteristicMeasurementType::getLocationSignificance()
{return LocationSignificance;}

void WeldSeamCharacteristicMeasurementType::setLocationSignificance(LocationSignificanceSpotSeamEnumType * LocationSignificanceIn)
{LocationSignificance = LocationSignificanceIn;}

WeldOneSideParametersExtendType * WeldSeamCharacteristicMeasurementType::getSideParameters()
{return SideParameters;}

void WeldSeamCharacteristicMeasurementType::setSideParameters(WeldOneSideParametersExtendType * SideParametersIn)
{SideParameters = SideParametersIn;}

/* ***************************************************************** */

/* class WeldSeamCharacteristicNominalType

*/

WeldSeamCharacteristicNominalType::WeldSeamCharacteristicNominalType() :
  WeldCharacteristicNominalBaseType()
{
  LocationSignificance = 0;
  SideParameters = 0;
}

WeldSeamCharacteristicNominalType::WeldSeamCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 LocationSignificanceSpotSeamEnumType * LocationSignificanceIn,
 WeldOneSideParametersExtendType * SideParametersIn) :
  WeldCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn)
{
  LocationSignificance = LocationSignificanceIn;
  SideParameters = SideParametersIn;
}

WeldSeamCharacteristicNominalType::WeldSeamCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 LocationSignificanceSpotSeamEnumType * LocationSignificanceIn,
 WeldOneSideParametersExtendType * SideParametersIn) :
  WeldCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn)
{
  LocationSignificance = LocationSignificanceIn;
  SideParameters = SideParametersIn;
}

WeldSeamCharacteristicNominalType::~WeldSeamCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  delete LocationSignificance;
  delete SideParameters;
  #endif
}

void WeldSeamCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (AllAround)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AllAround");
      AllAround->printSelf(outFile);
      fprintf(outFile, "</AllAround>\n");
    }
  if (Field)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Field");
      Field->printSelf(outFile);
      fprintf(outFile, "</Field>\n");
    }
  if (Specification)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Specification");
      Specification->printSelf(outFile);
      fprintf(outFile, "</Specification>\n");
    }
  if (WeldingProcess)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldingProcess");
      WeldingProcess->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldingProcess>\n");
    }
  if (NonDestructiveTesting)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonDestructiveTesting");
      NonDestructiveTesting->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NonDestructiveTesting>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<LocationSignificance");
  LocationSignificance->printSelf(outFile);
  fprintf(outFile, "</LocationSignificance>\n");
  if (SideParameters)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SideParameters");
      SideParameters->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SideParameters>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool WeldSeamCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldSeamCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldSeamCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldSeamCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldSeamCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LocationSignificanceSpotSeamEnumType * WeldSeamCharacteristicNominalType::getLocationSignificance()
{return LocationSignificance;}

void WeldSeamCharacteristicNominalType::setLocationSignificance(LocationSignificanceSpotSeamEnumType * LocationSignificanceIn)
{LocationSignificance = LocationSignificanceIn;}

WeldOneSideParametersExtendType * WeldSeamCharacteristicNominalType::getSideParameters()
{return SideParameters;}

void WeldSeamCharacteristicNominalType::setSideParameters(WeldOneSideParametersExtendType * SideParametersIn)
{SideParameters = SideParametersIn;}

/* ***************************************************************** */

/* class WeldSlotCharacteristicDefinitionType

*/

WeldSlotCharacteristicDefinitionType::WeldSlotCharacteristicDefinitionType() :
  WeldCharacteristicDefinitionBaseType()
{
}

WeldSlotCharacteristicDefinitionType::WeldSlotCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  WeldCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

WeldSlotCharacteristicDefinitionType::WeldSlotCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  WeldCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

WeldSlotCharacteristicDefinitionType::~WeldSlotCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldSlotCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool WeldSlotCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldSlotCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldSlotCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldSlotCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldSlotCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldSlotCharacteristicItemType

*/

WeldSlotCharacteristicItemType::WeldSlotCharacteristicItemType() :
  WeldCharacteristicItemBaseType()
{
}

WeldSlotCharacteristicItemType::WeldSlotCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  WeldCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WeldSlotCharacteristicItemType::WeldSlotCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  WeldCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WeldSlotCharacteristicItemType::~WeldSlotCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldSlotCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WeldSlotCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldSlotCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldSlotCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldSlotCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldSlotCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldSlotCharacteristicMeasurementType

*/

WeldSlotCharacteristicMeasurementType::WeldSlotCharacteristicMeasurementType() :
  WeldCharacteristicMeasurementBaseType()
{
  LocationSignificance = 0;
  SideParameters = 0;
}

WeldSlotCharacteristicMeasurementType::WeldSlotCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 LocationSignificanceOneSidesEnumType * LocationSignificanceIn,
 WeldPlugOneSideParametersType * SideParametersIn) :
  WeldCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  LocationSignificance = LocationSignificanceIn;
  SideParameters = SideParametersIn;
}

WeldSlotCharacteristicMeasurementType::WeldSlotCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 LocationSignificanceOneSidesEnumType * LocationSignificanceIn,
 WeldPlugOneSideParametersType * SideParametersIn) :
  WeldCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  LocationSignificance = LocationSignificanceIn;
  SideParameters = SideParametersIn;
}

WeldSlotCharacteristicMeasurementType::~WeldSlotCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  delete LocationSignificance;
  delete SideParameters;
  #endif
}

void WeldSlotCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<LocationSignificance");
  LocationSignificance->printSelf(outFile);
  fprintf(outFile, "</LocationSignificance>\n");
  if (SideParameters)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SideParameters");
      SideParameters->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SideParameters>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool WeldSlotCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldSlotCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldSlotCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldSlotCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldSlotCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LocationSignificanceOneSidesEnumType * WeldSlotCharacteristicMeasurementType::getLocationSignificance()
{return LocationSignificance;}

void WeldSlotCharacteristicMeasurementType::setLocationSignificance(LocationSignificanceOneSidesEnumType * LocationSignificanceIn)
{LocationSignificance = LocationSignificanceIn;}

WeldPlugOneSideParametersType * WeldSlotCharacteristicMeasurementType::getSideParameters()
{return SideParameters;}

void WeldSlotCharacteristicMeasurementType::setSideParameters(WeldPlugOneSideParametersType * SideParametersIn)
{SideParameters = SideParametersIn;}

/* ***************************************************************** */

/* class WeldSlotCharacteristicNominalType

*/

WeldSlotCharacteristicNominalType::WeldSlotCharacteristicNominalType() :
  WeldCharacteristicNominalBaseType()
{
  LocationSignificance = 0;
  SideParameters = 0;
}

WeldSlotCharacteristicNominalType::WeldSlotCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 LocationSignificanceOneSidesEnumType * LocationSignificanceIn,
 WeldPlugOneSideParametersType * SideParametersIn) :
  WeldCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn)
{
  LocationSignificance = LocationSignificanceIn;
  SideParameters = SideParametersIn;
}

WeldSlotCharacteristicNominalType::WeldSlotCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 LocationSignificanceOneSidesEnumType * LocationSignificanceIn,
 WeldPlugOneSideParametersType * SideParametersIn) :
  WeldCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn)
{
  LocationSignificance = LocationSignificanceIn;
  SideParameters = SideParametersIn;
}

WeldSlotCharacteristicNominalType::~WeldSlotCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  delete LocationSignificance;
  delete SideParameters;
  #endif
}

void WeldSlotCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (AllAround)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AllAround");
      AllAround->printSelf(outFile);
      fprintf(outFile, "</AllAround>\n");
    }
  if (Field)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Field");
      Field->printSelf(outFile);
      fprintf(outFile, "</Field>\n");
    }
  if (Specification)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Specification");
      Specification->printSelf(outFile);
      fprintf(outFile, "</Specification>\n");
    }
  if (WeldingProcess)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldingProcess");
      WeldingProcess->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldingProcess>\n");
    }
  if (NonDestructiveTesting)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonDestructiveTesting");
      NonDestructiveTesting->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NonDestructiveTesting>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<LocationSignificance");
  LocationSignificance->printSelf(outFile);
  fprintf(outFile, "</LocationSignificance>\n");
  if (SideParameters)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SideParameters");
      SideParameters->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SideParameters>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool WeldSlotCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldSlotCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldSlotCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldSlotCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldSlotCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LocationSignificanceOneSidesEnumType * WeldSlotCharacteristicNominalType::getLocationSignificance()
{return LocationSignificance;}

void WeldSlotCharacteristicNominalType::setLocationSignificance(LocationSignificanceOneSidesEnumType * LocationSignificanceIn)
{LocationSignificance = LocationSignificanceIn;}

WeldPlugOneSideParametersType * WeldSlotCharacteristicNominalType::getSideParameters()
{return SideParameters;}

void WeldSlotCharacteristicNominalType::setSideParameters(WeldPlugOneSideParametersType * SideParametersIn)
{SideParameters = SideParametersIn;}

/* ***************************************************************** */

/* class WeldSpotCharacteristicDefinitionType

*/

WeldSpotCharacteristicDefinitionType::WeldSpotCharacteristicDefinitionType() :
  WeldCharacteristicDefinitionBaseType()
{
}

WeldSpotCharacteristicDefinitionType::WeldSpotCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  WeldCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

WeldSpotCharacteristicDefinitionType::WeldSpotCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  WeldCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

WeldSpotCharacteristicDefinitionType::~WeldSpotCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldSpotCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool WeldSpotCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldSpotCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldSpotCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldSpotCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldSpotCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldSpotCharacteristicItemType

*/

WeldSpotCharacteristicItemType::WeldSpotCharacteristicItemType() :
  WeldCharacteristicItemBaseType()
{
}

WeldSpotCharacteristicItemType::WeldSpotCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  WeldCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WeldSpotCharacteristicItemType::WeldSpotCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  WeldCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WeldSpotCharacteristicItemType::~WeldSpotCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldSpotCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WeldSpotCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldSpotCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldSpotCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldSpotCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldSpotCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldSpotCharacteristicMeasurementType

*/

WeldSpotCharacteristicMeasurementType::WeldSpotCharacteristicMeasurementType() :
  WeldCharacteristicMeasurementBaseType()
{
  LocationSignificance = 0;
  SideParameters = 0;
  Projection = 0;
}

WeldSpotCharacteristicMeasurementType::WeldSpotCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 LocationSignificanceSpotSeamEnumType * LocationSignificanceIn,
 WeldSpotOneSideParametersType * SideParametersIn,
 XmlBoolean * ProjectionIn) :
  WeldCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  LocationSignificance = LocationSignificanceIn;
  SideParameters = SideParametersIn;
  Projection = ProjectionIn;
}

WeldSpotCharacteristicMeasurementType::WeldSpotCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 LocationSignificanceSpotSeamEnumType * LocationSignificanceIn,
 WeldSpotOneSideParametersType * SideParametersIn,
 XmlBoolean * ProjectionIn) :
  WeldCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  LocationSignificance = LocationSignificanceIn;
  SideParameters = SideParametersIn;
  Projection = ProjectionIn;
}

WeldSpotCharacteristicMeasurementType::~WeldSpotCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  delete LocationSignificance;
  delete SideParameters;
  delete Projection;
  #endif
}

void WeldSpotCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<LocationSignificance");
  LocationSignificance->printSelf(outFile);
  fprintf(outFile, "</LocationSignificance>\n");
  if (SideParameters)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SideParameters");
      SideParameters->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SideParameters>\n");
    }
  if (Projection)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Projection");
      Projection->printSelf(outFile);
      fprintf(outFile, "</Projection>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool WeldSpotCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldSpotCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldSpotCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldSpotCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldSpotCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LocationSignificanceSpotSeamEnumType * WeldSpotCharacteristicMeasurementType::getLocationSignificance()
{return LocationSignificance;}

void WeldSpotCharacteristicMeasurementType::setLocationSignificance(LocationSignificanceSpotSeamEnumType * LocationSignificanceIn)
{LocationSignificance = LocationSignificanceIn;}

WeldSpotOneSideParametersType * WeldSpotCharacteristicMeasurementType::getSideParameters()
{return SideParameters;}

void WeldSpotCharacteristicMeasurementType::setSideParameters(WeldSpotOneSideParametersType * SideParametersIn)
{SideParameters = SideParametersIn;}

XmlBoolean * WeldSpotCharacteristicMeasurementType::getProjection()
{return Projection;}

void WeldSpotCharacteristicMeasurementType::setProjection(XmlBoolean * ProjectionIn)
{Projection = ProjectionIn;}

/* ***************************************************************** */

/* class WeldSpotCharacteristicNominalType

*/

WeldSpotCharacteristicNominalType::WeldSpotCharacteristicNominalType() :
  WeldCharacteristicNominalBaseType()
{
  LocationSignificance = 0;
  SideParameters = 0;
  Projection = 0;
}

WeldSpotCharacteristicNominalType::WeldSpotCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 LocationSignificanceSpotSeamEnumType * LocationSignificanceIn,
 WeldSpotOneSideParametersType * SideParametersIn,
 XmlBoolean * ProjectionIn) :
  WeldCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn)
{
  LocationSignificance = LocationSignificanceIn;
  SideParameters = SideParametersIn;
  Projection = ProjectionIn;
}

WeldSpotCharacteristicNominalType::WeldSpotCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 LocationSignificanceSpotSeamEnumType * LocationSignificanceIn,
 WeldSpotOneSideParametersType * SideParametersIn,
 XmlBoolean * ProjectionIn) :
  WeldCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn)
{
  LocationSignificance = LocationSignificanceIn;
  SideParameters = SideParametersIn;
  Projection = ProjectionIn;
}

WeldSpotCharacteristicNominalType::~WeldSpotCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  delete LocationSignificance;
  delete SideParameters;
  delete Projection;
  #endif
}

void WeldSpotCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (AllAround)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AllAround");
      AllAround->printSelf(outFile);
      fprintf(outFile, "</AllAround>\n");
    }
  if (Field)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Field");
      Field->printSelf(outFile);
      fprintf(outFile, "</Field>\n");
    }
  if (Specification)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Specification");
      Specification->printSelf(outFile);
      fprintf(outFile, "</Specification>\n");
    }
  if (WeldingProcess)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldingProcess");
      WeldingProcess->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldingProcess>\n");
    }
  if (NonDestructiveTesting)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonDestructiveTesting");
      NonDestructiveTesting->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NonDestructiveTesting>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<LocationSignificance");
  LocationSignificance->printSelf(outFile);
  fprintf(outFile, "</LocationSignificance>\n");
  if (SideParameters)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SideParameters");
      SideParameters->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SideParameters>\n");
    }
  if (Projection)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Projection");
      Projection->printSelf(outFile);
      fprintf(outFile, "</Projection>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool WeldSpotCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldSpotCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldSpotCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldSpotCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldSpotCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LocationSignificanceSpotSeamEnumType * WeldSpotCharacteristicNominalType::getLocationSignificance()
{return LocationSignificance;}

void WeldSpotCharacteristicNominalType::setLocationSignificance(LocationSignificanceSpotSeamEnumType * LocationSignificanceIn)
{LocationSignificance = LocationSignificanceIn;}

WeldSpotOneSideParametersType * WeldSpotCharacteristicNominalType::getSideParameters()
{return SideParameters;}

void WeldSpotCharacteristicNominalType::setSideParameters(WeldSpotOneSideParametersType * SideParametersIn)
{SideParameters = SideParametersIn;}

XmlBoolean * WeldSpotCharacteristicNominalType::getProjection()
{return Projection;}

void WeldSpotCharacteristicNominalType::setProjection(XmlBoolean * ProjectionIn)
{Projection = ProjectionIn;}

/* ***************************************************************** */

/* class WeldSpotOneSideParametersType

*/

WeldSpotOneSideParametersType::WeldSpotOneSideParametersType() :
  WeldOneSideParametersExtendSizeType()
{
  Pitch = 0;
  WeldNumber = 0;
}

WeldSpotOneSideParametersType::WeldSpotOneSideParametersType(
 WeldFinishingType * FinishingIn,
 FractionType * SizeIn,
 LinearValueType * PitchIn,
 NaturalType * WeldNumberIn) :
  WeldOneSideParametersExtendSizeType(
    FinishingIn,
    SizeIn)
{
  Pitch = PitchIn;
  WeldNumber = WeldNumberIn;
}

WeldSpotOneSideParametersType::~WeldSpotOneSideParametersType()
{
  #ifndef NODESTRUCT
  delete Pitch;
  delete WeldNumber;
  #endif
}

void WeldSpotOneSideParametersType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Finishing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Finishing");
      Finishing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Finishing>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (Pitch)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Pitch");
      Pitch->printSelf(outFile);
      fprintf(outFile, "</Pitch>\n");
    }
  if (WeldNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldNumber");
      WeldNumber->printSelf(outFile);
      fprintf(outFile, "</WeldNumber>\n");
    }
  doSpaces(-INDENT, outFile);
}

LinearValueType * WeldSpotOneSideParametersType::getPitch()
{return Pitch;}

void WeldSpotOneSideParametersType::setPitch(LinearValueType * PitchIn)
{Pitch = PitchIn;}

NaturalType * WeldSpotOneSideParametersType::getWeldNumber()
{return WeldNumber;}

void WeldSpotOneSideParametersType::setWeldNumber(NaturalType * WeldNumberIn)
{WeldNumber = WeldNumberIn;}

/* ***************************************************************** */

/* class WeldSquareCharacteristicDefinitionType

*/

WeldSquareCharacteristicDefinitionType::WeldSquareCharacteristicDefinitionType() :
  WeldCharacteristicDefinitionBaseType()
{
}

WeldSquareCharacteristicDefinitionType::WeldSquareCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  WeldCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

WeldSquareCharacteristicDefinitionType::WeldSquareCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  WeldCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

WeldSquareCharacteristicDefinitionType::~WeldSquareCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldSquareCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool WeldSquareCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldSquareCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldSquareCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldSquareCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldSquareCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldSquareCharacteristicItemType

*/

WeldSquareCharacteristicItemType::WeldSquareCharacteristicItemType() :
  WeldCharacteristicItemBaseType()
{
}

WeldSquareCharacteristicItemType::WeldSquareCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  WeldCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WeldSquareCharacteristicItemType::WeldSquareCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  WeldCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WeldSquareCharacteristicItemType::~WeldSquareCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldSquareCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WeldSquareCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldSquareCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldSquareCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldSquareCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldSquareCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldSquareCharacteristicMeasurementType

*/

WeldSquareCharacteristicMeasurementType::WeldSquareCharacteristicMeasurementType() :
  WeldGrooveCharacteristicMeasurementType()
{
}

WeldSquareCharacteristicMeasurementType::WeldSquareCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 WeldGrooveCharacteristicMeasurementTypeChoicePair * WeldGrooveCharacteristicMeasurementTypePairIn) :
  WeldGrooveCharacteristicMeasurementType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    WeldGrooveCharacteristicMeasurementTypePairIn)
{
}

WeldSquareCharacteristicMeasurementType::WeldSquareCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 WeldGrooveCharacteristicMeasurementTypeChoicePair * WeldGrooveCharacteristicMeasurementTypePairIn) :
  WeldGrooveCharacteristicMeasurementType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    WeldGrooveCharacteristicMeasurementTypePairIn)
{
}

WeldSquareCharacteristicMeasurementType::~WeldSquareCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldSquareCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (WeldGrooveCharacteristicMeasurementTypePair)
    {
      WeldGrooveCharacteristicMeasurementTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WeldSquareCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldSquareCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldSquareCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldSquareCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldSquareCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldSquareCharacteristicNominalType

*/

WeldSquareCharacteristicNominalType::WeldSquareCharacteristicNominalType() :
  WeldGrooveCharacteristicNominalType()
{
}

WeldSquareCharacteristicNominalType::WeldSquareCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 WeldGrooveCharacteristicNominalTypeChoicePair * WeldGrooveCharacteristicNominalTypePairIn) :
  WeldGrooveCharacteristicNominalType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn,
    WeldGrooveCharacteristicNominalTypePairIn)
{
}

WeldSquareCharacteristicNominalType::WeldSquareCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 WeldGrooveCharacteristicNominalTypeChoicePair * WeldGrooveCharacteristicNominalTypePairIn) :
  WeldGrooveCharacteristicNominalType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn,
    WeldGrooveCharacteristicNominalTypePairIn)
{
}

WeldSquareCharacteristicNominalType::~WeldSquareCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldSquareCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (AllAround)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AllAround");
      AllAround->printSelf(outFile);
      fprintf(outFile, "</AllAround>\n");
    }
  if (Field)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Field");
      Field->printSelf(outFile);
      fprintf(outFile, "</Field>\n");
    }
  if (Specification)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Specification");
      Specification->printSelf(outFile);
      fprintf(outFile, "</Specification>\n");
    }
  if (WeldingProcess)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldingProcess");
      WeldingProcess->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldingProcess>\n");
    }
  if (NonDestructiveTesting)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonDestructiveTesting");
      NonDestructiveTesting->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NonDestructiveTesting>\n");
    }
  if (WeldGrooveCharacteristicNominalTypePair)
    {
      WeldGrooveCharacteristicNominalTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WeldSquareCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldSquareCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldSquareCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldSquareCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldSquareCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldStudCharacteristicDefinitionType

*/

WeldStudCharacteristicDefinitionType::WeldStudCharacteristicDefinitionType() :
  WeldCharacteristicDefinitionBaseType()
{
}

WeldStudCharacteristicDefinitionType::WeldStudCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  WeldCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

WeldStudCharacteristicDefinitionType::WeldStudCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  WeldCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

WeldStudCharacteristicDefinitionType::~WeldStudCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldStudCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool WeldStudCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldStudCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldStudCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldStudCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldStudCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldStudCharacteristicItemType

*/

WeldStudCharacteristicItemType::WeldStudCharacteristicItemType() :
  WeldCharacteristicItemBaseType()
{
}

WeldStudCharacteristicItemType::WeldStudCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  WeldCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WeldStudCharacteristicItemType::WeldStudCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  WeldCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WeldStudCharacteristicItemType::~WeldStudCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldStudCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WeldStudCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldStudCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldStudCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldStudCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldStudCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldStudCharacteristicMeasurementType

*/

WeldStudCharacteristicMeasurementType::WeldStudCharacteristicMeasurementType() :
  WeldCharacteristicMeasurementBaseType()
{
  ArrowSideParameters = 0;
}

WeldStudCharacteristicMeasurementType::WeldStudCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 WeldOneSideParametersExtendType * ArrowSideParametersIn) :
  WeldCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  ArrowSideParameters = ArrowSideParametersIn;
}

WeldStudCharacteristicMeasurementType::WeldStudCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 WeldOneSideParametersExtendType * ArrowSideParametersIn) :
  WeldCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  ArrowSideParameters = ArrowSideParametersIn;
}

WeldStudCharacteristicMeasurementType::~WeldStudCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  delete ArrowSideParameters;
  #endif
}

void WeldStudCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (ArrowSideParameters)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ArrowSideParameters");
      ArrowSideParameters->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ArrowSideParameters>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool WeldStudCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldStudCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldStudCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldStudCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldStudCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

WeldOneSideParametersExtendType * WeldStudCharacteristicMeasurementType::getArrowSideParameters()
{return ArrowSideParameters;}

void WeldStudCharacteristicMeasurementType::setArrowSideParameters(WeldOneSideParametersExtendType * ArrowSideParametersIn)
{ArrowSideParameters = ArrowSideParametersIn;}

/* ***************************************************************** */

/* class WeldStudCharacteristicNominalType

*/

WeldStudCharacteristicNominalType::WeldStudCharacteristicNominalType() :
  WeldCharacteristicNominalBaseType()
{
  ArrowSideParameters = 0;
}

WeldStudCharacteristicNominalType::WeldStudCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 WeldOneSideParametersExtendType * ArrowSideParametersIn) :
  WeldCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn)
{
  ArrowSideParameters = ArrowSideParametersIn;
}

WeldStudCharacteristicNominalType::WeldStudCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 WeldOneSideParametersExtendType * ArrowSideParametersIn) :
  WeldCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn)
{
  ArrowSideParameters = ArrowSideParametersIn;
}

WeldStudCharacteristicNominalType::~WeldStudCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  delete ArrowSideParameters;
  #endif
}

void WeldStudCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (AllAround)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AllAround");
      AllAround->printSelf(outFile);
      fprintf(outFile, "</AllAround>\n");
    }
  if (Field)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Field");
      Field->printSelf(outFile);
      fprintf(outFile, "</Field>\n");
    }
  if (Specification)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Specification");
      Specification->printSelf(outFile);
      fprintf(outFile, "</Specification>\n");
    }
  if (WeldingProcess)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldingProcess");
      WeldingProcess->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldingProcess>\n");
    }
  if (NonDestructiveTesting)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonDestructiveTesting");
      NonDestructiveTesting->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NonDestructiveTesting>\n");
    }
  if (ArrowSideParameters)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ArrowSideParameters");
      ArrowSideParameters->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ArrowSideParameters>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool WeldStudCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldStudCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldStudCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldStudCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldStudCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

WeldOneSideParametersExtendType * WeldStudCharacteristicNominalType::getArrowSideParameters()
{return ArrowSideParameters;}

void WeldStudCharacteristicNominalType::setArrowSideParameters(WeldOneSideParametersExtendType * ArrowSideParametersIn)
{ArrowSideParameters = ArrowSideParametersIn;}

/* ***************************************************************** */

/* class WeldSupplementarySymbolEnumType

*/

WeldSupplementarySymbolEnumType::WeldSupplementarySymbolEnumType() :
  XmlString()
{
}

WeldSupplementarySymbolEnumType::WeldSupplementarySymbolEnumType(
 const char * valIn) :
  XmlString(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "BACK_WELD") &&
           strcmp(val.c_str(), "MELT_THROUGH") &&
           strcmp(val.c_str(), "CONSUMABLE_INSERT") &&
           strcmp(val.c_str(), "REMOVABLE_BACKING"));
}

WeldSupplementarySymbolEnumType::~WeldSupplementarySymbolEnumType() {}

bool WeldSupplementarySymbolEnumType::WeldSupplementarySymbolEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "BACK_WELD") &&
          strcmp(val.c_str(), "MELT_THROUGH") &&
          strcmp(val.c_str(), "CONSUMABLE_INSERT") &&
          strcmp(val.c_str(), "REMOVABLE_BACKING"));
}

void WeldSupplementarySymbolEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "WeldSupplementarySymbolEnumType");
}

void WeldSupplementarySymbolEnumType::printSelf(FILE * outFile)
{
  if (WeldSupplementarySymbolEnumTypeIsBad())
    {
      fprintf(stderr, "bad WeldSupplementarySymbolEnumType value, ");
      XmlString::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlString::printSelf(outFile);
}

void WeldSupplementarySymbolEnumType::oPrintSelf(FILE * outFile)
{
  if (WeldSupplementarySymbolEnumTypeIsBad())
    {
      fprintf(stderr, "bad WeldSupplementarySymbolEnumType value, ");
      XmlString::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlString::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class WeldSurfacingCharacteristicDefinitionType

*/

WeldSurfacingCharacteristicDefinitionType::WeldSurfacingCharacteristicDefinitionType() :
  WeldCharacteristicDefinitionBaseType()
{
}

WeldSurfacingCharacteristicDefinitionType::WeldSurfacingCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  WeldCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

WeldSurfacingCharacteristicDefinitionType::WeldSurfacingCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  WeldCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

WeldSurfacingCharacteristicDefinitionType::~WeldSurfacingCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldSurfacingCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool WeldSurfacingCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldSurfacingCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldSurfacingCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldSurfacingCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldSurfacingCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldSurfacingCharacteristicItemType

*/

WeldSurfacingCharacteristicItemType::WeldSurfacingCharacteristicItemType() :
  WeldCharacteristicItemBaseType()
{
}

WeldSurfacingCharacteristicItemType::WeldSurfacingCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  WeldCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WeldSurfacingCharacteristicItemType::WeldSurfacingCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  WeldCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WeldSurfacingCharacteristicItemType::~WeldSurfacingCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldSurfacingCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WeldSurfacingCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldSurfacingCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldSurfacingCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldSurfacingCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldSurfacingCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldSurfacingCharacteristicMeasurementType

*/

WeldSurfacingCharacteristicMeasurementType::WeldSurfacingCharacteristicMeasurementType() :
  WeldCharacteristicMeasurementBaseType()
{
  ArrowSideParameters = 0;
}

WeldSurfacingCharacteristicMeasurementType::WeldSurfacingCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 WeldOneSideParametersExtendSizeType * ArrowSideParametersIn) :
  WeldCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  ArrowSideParameters = ArrowSideParametersIn;
}

WeldSurfacingCharacteristicMeasurementType::WeldSurfacingCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 WeldOneSideParametersExtendSizeType * ArrowSideParametersIn) :
  WeldCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn)
{
  ArrowSideParameters = ArrowSideParametersIn;
}

WeldSurfacingCharacteristicMeasurementType::~WeldSurfacingCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  delete ArrowSideParameters;
  #endif
}

void WeldSurfacingCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (ArrowSideParameters)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ArrowSideParameters");
      ArrowSideParameters->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ArrowSideParameters>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool WeldSurfacingCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldSurfacingCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldSurfacingCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldSurfacingCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldSurfacingCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

WeldOneSideParametersExtendSizeType * WeldSurfacingCharacteristicMeasurementType::getArrowSideParameters()
{return ArrowSideParameters;}

void WeldSurfacingCharacteristicMeasurementType::setArrowSideParameters(WeldOneSideParametersExtendSizeType * ArrowSideParametersIn)
{ArrowSideParameters = ArrowSideParametersIn;}

/* ***************************************************************** */

/* class WeldSurfacingCharacteristicNominalType

*/

WeldSurfacingCharacteristicNominalType::WeldSurfacingCharacteristicNominalType() :
  WeldCharacteristicNominalBaseType()
{
  ArrowSideParameters = 0;
}

WeldSurfacingCharacteristicNominalType::WeldSurfacingCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 WeldOneSideParametersExtendSizeType * ArrowSideParametersIn) :
  WeldCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn)
{
  ArrowSideParameters = ArrowSideParametersIn;
}

WeldSurfacingCharacteristicNominalType::WeldSurfacingCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 WeldOneSideParametersExtendSizeType * ArrowSideParametersIn) :
  WeldCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn)
{
  ArrowSideParameters = ArrowSideParametersIn;
}

WeldSurfacingCharacteristicNominalType::~WeldSurfacingCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  delete ArrowSideParameters;
  #endif
}

void WeldSurfacingCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (AllAround)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AllAround");
      AllAround->printSelf(outFile);
      fprintf(outFile, "</AllAround>\n");
    }
  if (Field)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Field");
      Field->printSelf(outFile);
      fprintf(outFile, "</Field>\n");
    }
  if (Specification)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Specification");
      Specification->printSelf(outFile);
      fprintf(outFile, "</Specification>\n");
    }
  if (WeldingProcess)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldingProcess");
      WeldingProcess->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldingProcess>\n");
    }
  if (NonDestructiveTesting)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonDestructiveTesting");
      NonDestructiveTesting->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NonDestructiveTesting>\n");
    }
  if (ArrowSideParameters)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ArrowSideParameters");
      ArrowSideParameters->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ArrowSideParameters>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool WeldSurfacingCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldSurfacingCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldSurfacingCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldSurfacingCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldSurfacingCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

WeldOneSideParametersExtendSizeType * WeldSurfacingCharacteristicNominalType::getArrowSideParameters()
{return ArrowSideParameters;}

void WeldSurfacingCharacteristicNominalType::setArrowSideParameters(WeldOneSideParametersExtendSizeType * ArrowSideParametersIn)
{ArrowSideParameters = ArrowSideParametersIn;}

/* ***************************************************************** */

/* class WeldUCharacteristicDefinitionType

*/

WeldUCharacteristicDefinitionType::WeldUCharacteristicDefinitionType() :
  WeldCharacteristicDefinitionBaseType()
{
}

WeldUCharacteristicDefinitionType::WeldUCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  WeldCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

WeldUCharacteristicDefinitionType::WeldUCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  WeldCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

WeldUCharacteristicDefinitionType::~WeldUCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldUCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool WeldUCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldUCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldUCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldUCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldUCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldUCharacteristicItemType

*/

WeldUCharacteristicItemType::WeldUCharacteristicItemType() :
  WeldCharacteristicItemBaseType()
{
}

WeldUCharacteristicItemType::WeldUCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  WeldCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WeldUCharacteristicItemType::WeldUCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  WeldCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WeldUCharacteristicItemType::~WeldUCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldUCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WeldUCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldUCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldUCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldUCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldUCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldUCharacteristicMeasurementType

*/

WeldUCharacteristicMeasurementType::WeldUCharacteristicMeasurementType() :
  WeldGrooveCharacteristicMeasurementType()
{
}

WeldUCharacteristicMeasurementType::WeldUCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 WeldGrooveCharacteristicMeasurementTypeChoicePair * WeldGrooveCharacteristicMeasurementTypePairIn) :
  WeldGrooveCharacteristicMeasurementType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    WeldGrooveCharacteristicMeasurementTypePairIn)
{
}

WeldUCharacteristicMeasurementType::WeldUCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 WeldGrooveCharacteristicMeasurementTypeChoicePair * WeldGrooveCharacteristicMeasurementTypePairIn) :
  WeldGrooveCharacteristicMeasurementType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    WeldGrooveCharacteristicMeasurementTypePairIn)
{
}

WeldUCharacteristicMeasurementType::~WeldUCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldUCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (WeldGrooveCharacteristicMeasurementTypePair)
    {
      WeldGrooveCharacteristicMeasurementTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WeldUCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldUCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldUCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldUCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldUCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldUCharacteristicNominalType

*/

WeldUCharacteristicNominalType::WeldUCharacteristicNominalType() :
  WeldGrooveCharacteristicNominalType()
{
}

WeldUCharacteristicNominalType::WeldUCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 WeldGrooveCharacteristicNominalTypeChoicePair * WeldGrooveCharacteristicNominalTypePairIn) :
  WeldGrooveCharacteristicNominalType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn,
    WeldGrooveCharacteristicNominalTypePairIn)
{
}

WeldUCharacteristicNominalType::WeldUCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 WeldGrooveCharacteristicNominalTypeChoicePair * WeldGrooveCharacteristicNominalTypePairIn) :
  WeldGrooveCharacteristicNominalType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn,
    WeldGrooveCharacteristicNominalTypePairIn)
{
}

WeldUCharacteristicNominalType::~WeldUCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldUCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (AllAround)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AllAround");
      AllAround->printSelf(outFile);
      fprintf(outFile, "</AllAround>\n");
    }
  if (Field)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Field");
      Field->printSelf(outFile);
      fprintf(outFile, "</Field>\n");
    }
  if (Specification)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Specification");
      Specification->printSelf(outFile);
      fprintf(outFile, "</Specification>\n");
    }
  if (WeldingProcess)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldingProcess");
      WeldingProcess->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldingProcess>\n");
    }
  if (NonDestructiveTesting)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonDestructiveTesting");
      NonDestructiveTesting->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NonDestructiveTesting>\n");
    }
  if (WeldGrooveCharacteristicNominalTypePair)
    {
      WeldGrooveCharacteristicNominalTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WeldUCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldUCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldUCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldUCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldUCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldVCharacteristicDefinitionType

*/

WeldVCharacteristicDefinitionType::WeldVCharacteristicDefinitionType() :
  WeldCharacteristicDefinitionBaseType()
{
}

WeldVCharacteristicDefinitionType::WeldVCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  WeldCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

WeldVCharacteristicDefinitionType::WeldVCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn) :
  WeldCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn)
{
}

WeldVCharacteristicDefinitionType::~WeldVCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldVCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool WeldVCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldVCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldVCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldVCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldVCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldVCharacteristicItemType

*/

WeldVCharacteristicItemType::WeldVCharacteristicItemType() :
  WeldCharacteristicItemBaseType()
{
}

WeldVCharacteristicItemType::WeldVCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  WeldCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WeldVCharacteristicItemType::WeldVCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  WeldCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WeldVCharacteristicItemType::~WeldVCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldVCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WeldVCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldVCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldVCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldVCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldVCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldVCharacteristicMeasurementType

*/

WeldVCharacteristicMeasurementType::WeldVCharacteristicMeasurementType() :
  WeldGrooveCharacteristicMeasurementType()
{
}

WeldVCharacteristicMeasurementType::WeldVCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 WeldGrooveCharacteristicMeasurementTypeChoicePair * WeldGrooveCharacteristicMeasurementTypePairIn) :
  WeldGrooveCharacteristicMeasurementType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    WeldGrooveCharacteristicMeasurementTypePairIn)
{
}

WeldVCharacteristicMeasurementType::WeldVCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 WeldGrooveCharacteristicMeasurementTypeChoicePair * WeldGrooveCharacteristicMeasurementTypePairIn) :
  WeldGrooveCharacteristicMeasurementType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    WeldGrooveCharacteristicMeasurementTypePairIn)
{
}

WeldVCharacteristicMeasurementType::~WeldVCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldVCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (WeldGrooveCharacteristicMeasurementTypePair)
    {
      WeldGrooveCharacteristicMeasurementTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WeldVCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldVCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldVCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldVCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldVCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldVCharacteristicNominalType

*/

WeldVCharacteristicNominalType::WeldVCharacteristicNominalType() :
  WeldGrooveCharacteristicNominalType()
{
}

WeldVCharacteristicNominalType::WeldVCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 WeldGrooveCharacteristicNominalTypeChoicePair * WeldGrooveCharacteristicNominalTypePairIn) :
  WeldGrooveCharacteristicNominalType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn,
    WeldGrooveCharacteristicNominalTypePairIn)
{
}

WeldVCharacteristicNominalType::WeldVCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * AllAroundIn,
 XmlBoolean * FieldIn,
 XmlToken * SpecificationIn,
 WeldingProcessType * WeldingProcessIn,
 ArrayNonDestructiveTestingType * NonDestructiveTestingIn,
 WeldGrooveCharacteristicNominalTypeChoicePair * WeldGrooveCharacteristicNominalTypePairIn) :
  WeldGrooveCharacteristicNominalType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    AllAroundIn,
    FieldIn,
    SpecificationIn,
    WeldingProcessIn,
    NonDestructiveTestingIn,
    WeldGrooveCharacteristicNominalTypePairIn)
{
}

WeldVCharacteristicNominalType::~WeldVCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void WeldVCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (AllAround)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AllAround");
      AllAround->printSelf(outFile);
      fprintf(outFile, "</AllAround>\n");
    }
  if (Field)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Field");
      Field->printSelf(outFile);
      fprintf(outFile, "</Field>\n");
    }
  if (Specification)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Specification");
      Specification->printSelf(outFile);
      fprintf(outFile, "</Specification>\n");
    }
  if (WeldingProcess)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldingProcess");
      WeldingProcess->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldingProcess>\n");
    }
  if (NonDestructiveTesting)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonDestructiveTesting");
      NonDestructiveTesting->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NonDestructiveTesting>\n");
    }
  if (WeldGrooveCharacteristicNominalTypePair)
    {
      WeldGrooveCharacteristicNominalTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WeldVCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WeldVCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WeldVCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WeldVCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WeldVCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WeldingProcessEnumType

*/

WeldingProcessEnumType::WeldingProcessEnumType() :
  XmlString()
{
}

WeldingProcessEnumType::WeldingProcessEnumType(
 const char * valIn) :
  XmlString(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "ARC_WELDING") &&
           strcmp(val.c_str(), "SHIELDED_METAL_ARC_WELDING") &&
           strcmp(val.c_str(), "FLUX_CORED_ARC_WELDING") &&
           strcmp(val.c_str(), "SUBMERGED_ARC_WELDING") &&
           strcmp(val.c_str(), "GAS_METAL_ARC_WELDING") &&
           strcmp(val.c_str(), "GAS_TUNGSTEN_ARC_WELDING") &&
           strcmp(val.c_str(), "PLASMA_ARC_WELDING") &&
           strcmp(val.c_str(), "RESISTANCE_WELDING") &&
           strcmp(val.c_str(), "RESISTANCE_SPOT_WELDING") &&
           strcmp(val.c_str(), "RESISTANCE_SEAM_WELDING") &&
           strcmp(val.c_str(), "PROJECTION_WELD") &&
           strcmp(val.c_str(), "FLASH_WELDING") &&
           strcmp(val.c_str(), "OXYFUEL_GAS_WELDING") &&
           strcmp(val.c_str(), "OXYACETYLENE_WELDING") &&
           strcmp(val.c_str(), "FRICTION_WELDING") &&
           strcmp(val.c_str(), "FORGE_WELDING") &&
           strcmp(val.c_str(), "THERMIT_WELDING") &&
           strcmp(val.c_str(), "ELECTROSLAG_WELDING") &&
           strcmp(val.c_str(), "STUD_ARC_WELDING") &&
           strcmp(val.c_str(), "BRAZING") &&
           strcmp(val.c_str(), "SOLDERING"));
}

WeldingProcessEnumType::~WeldingProcessEnumType() {}

bool WeldingProcessEnumType::WeldingProcessEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "ARC_WELDING") &&
          strcmp(val.c_str(), "SHIELDED_METAL_ARC_WELDING") &&
          strcmp(val.c_str(), "FLUX_CORED_ARC_WELDING") &&
          strcmp(val.c_str(), "SUBMERGED_ARC_WELDING") &&
          strcmp(val.c_str(), "GAS_METAL_ARC_WELDING") &&
          strcmp(val.c_str(), "GAS_TUNGSTEN_ARC_WELDING") &&
          strcmp(val.c_str(), "PLASMA_ARC_WELDING") &&
          strcmp(val.c_str(), "RESISTANCE_WELDING") &&
          strcmp(val.c_str(), "RESISTANCE_SPOT_WELDING") &&
          strcmp(val.c_str(), "RESISTANCE_SEAM_WELDING") &&
          strcmp(val.c_str(), "PROJECTION_WELD") &&
          strcmp(val.c_str(), "FLASH_WELDING") &&
          strcmp(val.c_str(), "OXYFUEL_GAS_WELDING") &&
          strcmp(val.c_str(), "OXYACETYLENE_WELDING") &&
          strcmp(val.c_str(), "FRICTION_WELDING") &&
          strcmp(val.c_str(), "FORGE_WELDING") &&
          strcmp(val.c_str(), "THERMIT_WELDING") &&
          strcmp(val.c_str(), "ELECTROSLAG_WELDING") &&
          strcmp(val.c_str(), "STUD_ARC_WELDING") &&
          strcmp(val.c_str(), "BRAZING") &&
          strcmp(val.c_str(), "SOLDERING"));
}

void WeldingProcessEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "WeldingProcessEnumType");
}

void WeldingProcessEnumType::printSelf(FILE * outFile)
{
  if (WeldingProcessEnumTypeIsBad())
    {
      fprintf(stderr, "bad WeldingProcessEnumType value, ");
      XmlString::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlString::printSelf(outFile);
}

void WeldingProcessEnumType::oPrintSelf(FILE * outFile)
{
  if (WeldingProcessEnumTypeIsBad())
    {
      fprintf(stderr, "bad WeldingProcessEnumType value, ");
      XmlString::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlString::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class WeldingProcessSuffixEnumType

*/

WeldingProcessSuffixEnumType::WeldingProcessSuffixEnumType() :
  XmlString()
{
}

WeldingProcessSuffixEnumType::WeldingProcessSuffixEnumType(
 const char * valIn) :
  XmlString(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "MANUAL") &&
           strcmp(val.c_str(), "SEMI_AUTOMATIC") &&
           strcmp(val.c_str(), "ROBOTIC") &&
           strcmp(val.c_str(), "MACHINE"));
}

WeldingProcessSuffixEnumType::~WeldingProcessSuffixEnumType() {}

bool WeldingProcessSuffixEnumType::WeldingProcessSuffixEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "MANUAL") &&
          strcmp(val.c_str(), "SEMI_AUTOMATIC") &&
          strcmp(val.c_str(), "ROBOTIC") &&
          strcmp(val.c_str(), "MACHINE"));
}

void WeldingProcessSuffixEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "WeldingProcessSuffixEnumType");
}

void WeldingProcessSuffixEnumType::printSelf(FILE * outFile)
{
  if (WeldingProcessSuffixEnumTypeIsBad())
    {
      fprintf(stderr, "bad WeldingProcessSuffixEnumType value, ");
      XmlString::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlString::printSelf(outFile);
}

void WeldingProcessSuffixEnumType::oPrintSelf(FILE * outFile)
{
  if (WeldingProcessSuffixEnumTypeIsBad())
    {
      fprintf(stderr, "bad WeldingProcessSuffixEnumType value, ");
      XmlString::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlString::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class WeldingProcessType

*/

WeldingProcessType::WeldingProcessType()
{
  Process = 0;
  Suffix = 0;
}

WeldingProcessType::WeldingProcessType(
 WeldingProcessEnumType * ProcessIn,
 WeldingProcessSuffixEnumType * SuffixIn)
{
  Process = ProcessIn;
  Suffix = SuffixIn;
}

WeldingProcessType::~WeldingProcessType()
{
  #ifndef NODESTRUCT
  delete Process;
  delete Suffix;
  #endif
}

void WeldingProcessType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Process");
  Process->printSelf(outFile);
  fprintf(outFile, "</Process>\n");
  if (Suffix)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Suffix");
      Suffix->printSelf(outFile);
      fprintf(outFile, "</Suffix>\n");
    }
  doSpaces(-INDENT, outFile);
}

WeldingProcessEnumType * WeldingProcessType::getProcess()
{return Process;}

void WeldingProcessType::setProcess(WeldingProcessEnumType * ProcessIn)
{Process = ProcessIn;}

WeldingProcessSuffixEnumType * WeldingProcessType::getSuffix()
{return Suffix;}

void WeldingProcessType::setSuffix(WeldingProcessSuffixEnumType * SuffixIn)
{Suffix = SuffixIn;}

/* ***************************************************************** */

/* class WidthCharacteristicDefinitionType

*/

WidthCharacteristicDefinitionType::WidthCharacteristicDefinitionType() :
  LinearCharacteristicDefinitionBaseType()
{
}

WidthCharacteristicDefinitionType::WidthCharacteristicDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseTypePairIn) :
  LinearCharacteristicDefinitionBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    LinearCharacteristicDefinitionBaseTypePairIn)
{
}

WidthCharacteristicDefinitionType::WidthCharacteristicDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 XmlBoolean * FreeStateIn,
 XmlBoolean * StatisticalCharacteristicIn,
 XmlBoolean * CommonZoneIn,
 XmlBoolean * CommonToleranceIn,
 XmlBoolean * MedianFeatureIn,
 XmlBoolean * EnvelopeRequirementIn,
 XmlBoolean * IndependencyIn,
 XmlBoolean * UnitedOrContinuousFeatureIn,
 XmlBoolean * SeparateZoneIn,
 DimensionModifierEnumType * DimensionTypeIn,
 DimensionModifiersType * DimensionModifiersIn,
 LinearCharacteristicDefinitionBaseTypeChoicePair * LinearCharacteristicDefinitionBaseTypePairIn) :
  LinearCharacteristicDefinitionBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FreeStateIn,
    StatisticalCharacteristicIn,
    CommonZoneIn,
    CommonToleranceIn,
    MedianFeatureIn,
    EnvelopeRequirementIn,
    IndependencyIn,
    UnitedOrContinuousFeatureIn,
    SeparateZoneIn,
    DimensionTypeIn,
    DimensionModifiersIn,
    LinearCharacteristicDefinitionBaseTypePairIn)
{
}

WidthCharacteristicDefinitionType::~WidthCharacteristicDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void WidthCharacteristicDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FreeState)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FreeState");
      FreeState->printSelf(outFile);
      fprintf(outFile, "</FreeState>\n");
    }
  if (StatisticalCharacteristic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatisticalCharacteristic");
      StatisticalCharacteristic->printSelf(outFile);
      fprintf(outFile, "</StatisticalCharacteristic>\n");
    }
  if (CommonZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonZone");
      CommonZone->printSelf(outFile);
      fprintf(outFile, "</CommonZone>\n");
    }
  if (CommonTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CommonTolerance");
      CommonTolerance->printSelf(outFile);
      fprintf(outFile, "</CommonTolerance>\n");
    }
  if (MedianFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MedianFeature");
      MedianFeature->printSelf(outFile);
      fprintf(outFile, "</MedianFeature>\n");
    }
  if (EnvelopeRequirement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvelopeRequirement");
      EnvelopeRequirement->printSelf(outFile);
      fprintf(outFile, "</EnvelopeRequirement>\n");
    }
  if (Independency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Independency");
      Independency->printSelf(outFile);
      fprintf(outFile, "</Independency>\n");
    }
  if (UnitedOrContinuousFeature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnitedOrContinuousFeature");
      UnitedOrContinuousFeature->printSelf(outFile);
      fprintf(outFile, "</UnitedOrContinuousFeature>\n");
    }
  if (SeparateZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SeparateZone");
      SeparateZone->printSelf(outFile);
      fprintf(outFile, "</SeparateZone>\n");
    }
  if (DimensionType)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionType");
      DimensionType->printSelf(outFile);
      fprintf(outFile, "</DimensionType>\n");
    }
  if (DimensionModifiers)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DimensionModifiers");
      DimensionModifiers->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DimensionModifiers>\n");
    }
  LinearCharacteristicDefinitionBaseTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

bool WidthCharacteristicDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WidthCharacteristicDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WidthCharacteristicDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WidthCharacteristicDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WidthCharacteristicDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WidthCharacteristicItemType

*/

WidthCharacteristicItemType::WidthCharacteristicItemType() :
  LinearCharacteristicItemBaseType()
{
}

WidthCharacteristicItemType::WidthCharacteristicItemType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LinearCharacteristicItemBaseType(
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WidthCharacteristicItemType::WidthCharacteristicItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 ArrayReferenceType * FeatureItemIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceType * NotableEventIdsIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceFullType * CharacteristicNominalIdIn,
 LocationOnDrawingType * LocationOnDrawingIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  LinearCharacteristicItemBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    NameIn,
    CharacteristicDesignatorIn,
    FeatureItemIdsIn,
    SubstituteFeatureAlgorithmIn,
    NotableEventIdsIn,
    MeasurementDeviceIdsIn,
    CharacteristicNominalIdIn,
    LocationOnDrawingIn,
    VirtualMeasurementIn)
{
}

WidthCharacteristicItemType::~WidthCharacteristicItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void WidthCharacteristicItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (FeatureItemIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemIds");
      FeatureItemIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItemIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicNominalId");
  CharacteristicNominalId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicNominalId>\n");
  if (LocationOnDrawing)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationOnDrawing");
      LocationOnDrawing->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LocationOnDrawing>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool WidthCharacteristicItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WidthCharacteristicItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WidthCharacteristicItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WidthCharacteristicItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WidthCharacteristicItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WidthCharacteristicMeasurementType

*/

WidthCharacteristicMeasurementType::WidthCharacteristicMeasurementType() :
  LinearCharacteristicMeasurementBaseType()
{
}

WidthCharacteristicMeasurementType::WidthCharacteristicMeasurementType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  LinearCharacteristicMeasurementBaseType(
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

WidthCharacteristicMeasurementType::WidthCharacteristicMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 CharacteristicStatusType * StatusIn,
 QIFReferenceType * CharacteristicItemIdIn,
 XmlDateTime * TimeStampIn,
 ArrayReferenceType * FeatureMeasurementIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ActualComponentIdIn,
 ArrayReferenceType * MeasurementDeviceIdsIn,
 QIFReferenceType * ManufacturingProcessIdIn,
 ArrayReferenceType * NotedEventIdsIn,
 XmlToken * NonConformanceDesignatorIn,
 MeasuredLinearValueType * ValueIn,
 MeasuredLinearValueType * MaxValueIn,
 MeasuredLinearValueType * MinValueIn) :
  LinearCharacteristicMeasurementBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    StatusIn,
    CharacteristicItemIdIn,
    TimeStampIn,
    FeatureMeasurementIdsIn,
    SubstituteFeatureAlgorithmIn,
    ActualComponentIdIn,
    MeasurementDeviceIdsIn,
    ManufacturingProcessIdIn,
    NotedEventIdsIn,
    NonConformanceDesignatorIn,
    ValueIn,
    MaxValueIn,
    MinValueIn)
{
}

WidthCharacteristicMeasurementType::~WidthCharacteristicMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void WidthCharacteristicMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicItemId");
  CharacteristicItemId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicItemId>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (FeatureMeasurementIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureMeasurementIds");
      FeatureMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureMeasurementIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (NonConformanceDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NonConformanceDesignator");
      NonConformanceDesignator->printSelf(outFile);
      fprintf(outFile, "</NonConformanceDesignator>\n");
    }
  if (Value)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Value");
      Value->printSelf(outFile);
      fprintf(outFile, "</Value>\n");
    }
  if (MaxValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValue");
      MaxValue->printSelf(outFile);
      fprintf(outFile, "</MaxValue>\n");
    }
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool WidthCharacteristicMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WidthCharacteristicMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WidthCharacteristicMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WidthCharacteristicMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WidthCharacteristicMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class WidthCharacteristicNominalType

*/

WidthCharacteristicNominalType::WidthCharacteristicNominalType() :
  LinearCharacteristicNominalBaseType()
{
}

WidthCharacteristicNominalType::WidthCharacteristicNominalType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn) :
  LinearCharacteristicNominalBaseType(
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn,
    TargetDualValueIn)
{
}

WidthCharacteristicNominalType::WidthCharacteristicNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn,
 QIFReferenceType * CharacteristicDefinitionIdIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureZoneIdsIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 XmlToken * NameIn,
 CharacteristicDesignatorType * CharacteristicDesignatorIn,
 LinearValueType * TargetValueIn,
 LinearDualValueType * TargetDualValueIn) :
  LinearCharacteristicNominalBaseType(
    idIn,
    AttributesIn,
    DescriptionIn,
    CharacteristicDefinitionIdIn,
    FeatureNominalIdsIn,
    SubstituteFeatureAlgorithmIn,
    FeatureZoneIdsIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    NameIn,
    CharacteristicDesignatorIn,
    TargetValueIn,
    TargetDualValueIn)
{
}

WidthCharacteristicNominalType::~WidthCharacteristicNominalType()
{
  #ifndef NODESTRUCT
  #endif
}

void WidthCharacteristicNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CharacteristicDefinitionId");
  CharacteristicDefinitionId->printSelf(outFile);
  fprintf(outFile, "</CharacteristicDefinitionId>\n");
  if (FeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominalIds");
      FeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominalIds>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (FeatureZoneIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureZoneIds");
      FeatureZoneIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureZoneIds>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (CharacteristicDesignator)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicDesignator");
      CharacteristicDesignator->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicDesignator>\n");
    }
  if (TargetValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetValue");
      TargetValue->printSelf(outFile);
      fprintf(outFile, "</TargetValue>\n");
    }
  if (TargetDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetDualValue");
      TargetDualValue->printSelf(outFile);
      fprintf(outFile, "</TargetDualValue>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool WidthCharacteristicNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in WidthCharacteristicNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in WidthCharacteristicNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in WidthCharacteristicNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in WidthCharacteristicNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class CircularityChar_1041_Type

*/

CircularityChar_1041_Type::CircularityChar_1041_Type()
{
  ToleranceValue = 0;
  ToleranceDualValue = 0;
  CircularityChar_1064 = 0;
}

CircularityChar_1041_Type::CircularityChar_1041_Type(
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 CircularityChar_1064_Type * CircularityChar_1064In)
{
  ToleranceValue = ToleranceValueIn;
  ToleranceDualValue = ToleranceDualValueIn;
  CircularityChar_1064 = CircularityChar_1064In;
}

CircularityChar_1041_Type::~CircularityChar_1041_Type()
{
  #ifndef NODESTRUCT
  delete ToleranceValue;
  delete ToleranceDualValue;
  delete CircularityChar_1064;
  #endif
}

void CircularityChar_1041_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<ToleranceValue");
  ToleranceValue->printSelf(outFile);
  fprintf(outFile, "</ToleranceValue>\n");
  if (ToleranceDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceDualValue");
      ToleranceDualValue->printSelf(outFile);
      fprintf(outFile, "</ToleranceDualValue>\n");
    }
  if (CircularityChar_1064)
    {
  CircularityChar_1064->printSelf(outFile);
    }
}

LinearValueType * CircularityChar_1041_Type::getToleranceValue()
{return ToleranceValue;}

void CircularityChar_1041_Type::setToleranceValue(LinearValueType * ToleranceValueIn)
{ToleranceValue = ToleranceValueIn;}

LinearDualValueType * CircularityChar_1041_Type::getToleranceDualValue()
{return ToleranceDualValue;}

void CircularityChar_1041_Type::setToleranceDualValue(LinearDualValueType * ToleranceDualValueIn)
{ToleranceDualValue = ToleranceDualValueIn;}

CircularityChar_1064_Type * CircularityChar_1041_Type::getCircularityChar_1064()
{return CircularityChar_1064;}

void CircularityChar_1041_Type::setCircularityChar_1064(CircularityChar_1064_Type * CircularityChar_1064In)
{CircularityChar_1064 = CircularityChar_1064In;}

/* ***************************************************************** */

/* class CircularityChar_1042_Type

*/

CircularityChar_1042_Type::CircularityChar_1042_Type()
{
  CircularityChar_1042_TypePair = 0;
}

CircularityChar_1042_Type::CircularityChar_1042_Type(
 CircularityChar_1042_TypeChoicePair * CircularityChar_1042_TypePairIn)
{
  CircularityChar_1042_TypePair = CircularityChar_1042_TypePairIn;
}

CircularityChar_1042_Type::~CircularityChar_1042_Type()
{
  #ifndef NODESTRUCT
  delete CircularityChar_1042_TypePair;
  #endif
}

void CircularityChar_1042_Type::printSelf(FILE * outFile)
{
  CircularityChar_1042_TypePair->printSelf(outFile);
}

CircularityChar_1042_TypeChoicePair * CircularityChar_1042_Type::getCircularityChar_1042_TypePair()
{return CircularityChar_1042_TypePair;}

void CircularityChar_1042_Type::setCircularityChar_1042_TypePair(CircularityChar_1042_TypeChoicePair * CircularityChar_1042_TypePairIn)
{CircularityChar_1042_TypePair = CircularityChar_1042_TypePairIn;}
CircularityChar_1042_TypeChoicePair::CircularityChar_1042_TypeChoicePair() {}

CircularityChar_1042_TypeChoicePair::CircularityChar_1042_TypeChoicePair(
 whichOne CircularityChar_1042_TypeTypeIn,
 CircularityChar_1042_TypeVal CircularityChar_1042_TypeValueIn)
{
  CircularityChar_1042_TypeType = CircularityChar_1042_TypeTypeIn;
  CircularityChar_1042_TypeValue = CircularityChar_1042_TypeValueIn;
}

CircularityChar_1042_TypeChoicePair::~CircularityChar_1042_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (CircularityChar_1042_TypeType == ToleranceZonePerUnitAngleE)
    delete CircularityChar_1042_TypeValue.ToleranceZonePerUnitAngle;
  else if (CircularityChar_1042_TypeType == ToleranceZonePerUnitArcLengthE)
    delete CircularityChar_1042_TypeValue.ToleranceZonePerUnitArcLength;
  #endif
}

void CircularityChar_1042_TypeChoicePair::printSelf(FILE * outFile)
{
  if (CircularityChar_1042_TypeType == ToleranceZonePerUnitAngleE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceZonePerUnitAngle");
      CircularityChar_1042_TypeValue.ToleranceZonePerUnitAngle->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ToleranceZonePerUnitAngle>\n");
    }
  else if (CircularityChar_1042_TypeType == ToleranceZonePerUnitArcLengthE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceZonePerUnitArcLength");
      CircularityChar_1042_TypeValue.ToleranceZonePerUnitArcLength->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ToleranceZonePerUnitArcLength>\n");
    }
}

/* ***************************************************************** */

/* class CircularityChar_1043_Type

*/

CircularityChar_1043_Type::CircularityChar_1043_Type()
{
  ZoneRadii = 0;
  ZonePlane = 0;
}

CircularityChar_1043_Type::CircularityChar_1043_Type(
 MeasuredZoneRadiiType * ZoneRadiiIn,
 MeasuredPlaneType * ZonePlaneIn)
{
  ZoneRadii = ZoneRadiiIn;
  ZonePlane = ZonePlaneIn;
}

CircularityChar_1043_Type::~CircularityChar_1043_Type()
{
  #ifndef NODESTRUCT
  delete ZoneRadii;
  delete ZonePlane;
  #endif
}

void CircularityChar_1043_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<ZoneRadii");
  ZoneRadii->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ZoneRadii>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<ZonePlane");
  ZonePlane->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ZonePlane>\n");
}

MeasuredZoneRadiiType * CircularityChar_1043_Type::getZoneRadii()
{return ZoneRadii;}

void CircularityChar_1043_Type::setZoneRadii(MeasuredZoneRadiiType * ZoneRadiiIn)
{ZoneRadii = ZoneRadiiIn;}

MeasuredPlaneType * CircularityChar_1043_Type::getZonePlane()
{return ZonePlane;}

void CircularityChar_1043_Type::setZonePlane(MeasuredPlaneType * ZonePlaneIn)
{ZonePlane = ZonePlaneIn;}

/* ***************************************************************** */

/* class CriticalityType_1044_Type

*/

CriticalityType_1044_Type::CriticalityType_1044_Type()
{
  CriticalityType_1044_TypePair = 0;
}

CriticalityType_1044_Type::CriticalityType_1044_Type(
 CriticalityType_1044_TypeChoicePair * CriticalityType_1044_TypePairIn)
{
  CriticalityType_1044_TypePair = CriticalityType_1044_TypePairIn;
}

CriticalityType_1044_Type::~CriticalityType_1044_Type()
{
  #ifndef NODESTRUCT
  delete CriticalityType_1044_TypePair;
  #endif
}

void CriticalityType_1044_Type::printSelf(FILE * outFile)
{
  CriticalityType_1044_TypePair->printSelf(outFile);
}

CriticalityType_1044_TypeChoicePair * CriticalityType_1044_Type::getCriticalityType_1044_TypePair()
{return CriticalityType_1044_TypePair;}

void CriticalityType_1044_Type::setCriticalityType_1044_TypePair(CriticalityType_1044_TypeChoicePair * CriticalityType_1044_TypePairIn)
{CriticalityType_1044_TypePair = CriticalityType_1044_TypePairIn;}
CriticalityType_1044_TypeChoicePair::CriticalityType_1044_TypeChoicePair() {}

CriticalityType_1044_TypeChoicePair::CriticalityType_1044_TypeChoicePair(
 whichOne CriticalityType_1044_TypeTypeIn,
 CriticalityType_1044_TypeVal CriticalityType_1044_TypeValueIn)
{
  CriticalityType_1044_TypeType = CriticalityType_1044_TypeTypeIn;
  CriticalityType_1044_TypeValue = CriticalityType_1044_TypeValueIn;
}

CriticalityType_1044_TypeChoicePair::~CriticalityType_1044_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (CriticalityType_1044_TypeType == LevelEnumE)
    delete CriticalityType_1044_TypeValue.LevelEnum;
  else if (CriticalityType_1044_TypeType == OtherLevelE)
    delete CriticalityType_1044_TypeValue.OtherLevel;
  #endif
}

void CriticalityType_1044_TypeChoicePair::printSelf(FILE * outFile)
{
  if (CriticalityType_1044_TypeType == LevelEnumE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LevelEnum");
      CriticalityType_1044_TypeValue.LevelEnum->printSelf(outFile);
      fprintf(outFile, "</LevelEnum>\n");
    }
  else if (CriticalityType_1044_TypeType == OtherLevelE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OtherLevel");
      CriticalityType_1044_TypeValue.OtherLevel->printSelf(outFile);
      fprintf(outFile, "</OtherLevel>\n");
    }
}

/* ***************************************************************** */

/* class CriticalityType_1045_Type

*/

CriticalityType_1045_Type::CriticalityType_1045_Type()
{
  CriticalityType_1045_TypePair = 0;
}

CriticalityType_1045_Type::CriticalityType_1045_Type(
 CriticalityType_1045_TypeChoicePair * CriticalityType_1045_TypePairIn)
{
  CriticalityType_1045_TypePair = CriticalityType_1045_TypePairIn;
}

CriticalityType_1045_Type::~CriticalityType_1045_Type()
{
  #ifndef NODESTRUCT
  delete CriticalityType_1045_TypePair;
  #endif
}

void CriticalityType_1045_Type::printSelf(FILE * outFile)
{
  if (CriticalityType_1045_TypePair)
    {
      CriticalityType_1045_TypePair->printSelf(outFile);
    }
}

CriticalityType_1045_TypeChoicePair * CriticalityType_1045_Type::getCriticalityType_1045_TypePair()
{return CriticalityType_1045_TypePair;}

void CriticalityType_1045_Type::setCriticalityType_1045_TypePair(CriticalityType_1045_TypeChoicePair * CriticalityType_1045_TypePairIn)
{CriticalityType_1045_TypePair = CriticalityType_1045_TypePairIn;}
CriticalityType_1045_TypeChoicePair::CriticalityType_1045_TypeChoicePair() {}

CriticalityType_1045_TypeChoicePair::CriticalityType_1045_TypeChoicePair(
 whichOne CriticalityType_1045_TypeTypeIn,
 CriticalityType_1045_TypeVal CriticalityType_1045_TypeValueIn)
{
  CriticalityType_1045_TypeType = CriticalityType_1045_TypeTypeIn;
  CriticalityType_1045_TypeValue = CriticalityType_1045_TypeValueIn;
}

CriticalityType_1045_TypeChoicePair::~CriticalityType_1045_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (CriticalityType_1045_TypeType == AreaEnumE)
    delete CriticalityType_1045_TypeValue.AreaEnum;
  else if (CriticalityType_1045_TypeType == OtherAreaE)
    delete CriticalityType_1045_TypeValue.OtherArea;
  #endif
}

void CriticalityType_1045_TypeChoicePair::printSelf(FILE * outFile)
{
  if (CriticalityType_1045_TypeType == AreaEnumE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AreaEnum");
      CriticalityType_1045_TypeValue.AreaEnum->printSelf(outFile);
      fprintf(outFile, "</AreaEnum>\n");
    }
  else if (CriticalityType_1045_TypeType == OtherAreaE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OtherArea");
      CriticalityType_1045_TypeValue.OtherArea->printSelf(outFile);
      fprintf(outFile, "</OtherArea>\n");
    }
}

/* ***************************************************************** */

/* class CylindricityCha_1046_Type

*/

CylindricityCha_1046_Type::CylindricityCha_1046_Type()
{
  ToleranceValue = 0;
  ToleranceDualValue = 0;
  CylindricityCha_1065 = 0;
}

CylindricityCha_1046_Type::CylindricityCha_1046_Type(
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 CylindricityCha_1065_Type * CylindricityCha_1065In)
{
  ToleranceValue = ToleranceValueIn;
  ToleranceDualValue = ToleranceDualValueIn;
  CylindricityCha_1065 = CylindricityCha_1065In;
}

CylindricityCha_1046_Type::~CylindricityCha_1046_Type()
{
  #ifndef NODESTRUCT
  delete ToleranceValue;
  delete ToleranceDualValue;
  delete CylindricityCha_1065;
  #endif
}

void CylindricityCha_1046_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<ToleranceValue");
  ToleranceValue->printSelf(outFile);
  fprintf(outFile, "</ToleranceValue>\n");
  if (ToleranceDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceDualValue");
      ToleranceDualValue->printSelf(outFile);
      fprintf(outFile, "</ToleranceDualValue>\n");
    }
  if (CylindricityCha_1065)
    {
  CylindricityCha_1065->printSelf(outFile);
    }
}

LinearValueType * CylindricityCha_1046_Type::getToleranceValue()
{return ToleranceValue;}

void CylindricityCha_1046_Type::setToleranceValue(LinearValueType * ToleranceValueIn)
{ToleranceValue = ToleranceValueIn;}

LinearDualValueType * CylindricityCha_1046_Type::getToleranceDualValue()
{return ToleranceDualValue;}

void CylindricityCha_1046_Type::setToleranceDualValue(LinearDualValueType * ToleranceDualValueIn)
{ToleranceDualValue = ToleranceDualValueIn;}

CylindricityCha_1065_Type * CylindricityCha_1046_Type::getCylindricityCha_1065()
{return CylindricityCha_1065;}

void CylindricityCha_1046_Type::setCylindricityCha_1065(CylindricityCha_1065_Type * CylindricityCha_1065In)
{CylindricityCha_1065 = CylindricityCha_1065In;}

/* ***************************************************************** */

/* class CylindricityCha_1047_Type

*/

CylindricityCha_1047_Type::CylindricityCha_1047_Type()
{
  CylindricityCha_1047_TypePair = 0;
}

CylindricityCha_1047_Type::CylindricityCha_1047_Type(
 CylindricityCha_1047_TypeChoicePair * CylindricityCha_1047_TypePairIn)
{
  CylindricityCha_1047_TypePair = CylindricityCha_1047_TypePairIn;
}

CylindricityCha_1047_Type::~CylindricityCha_1047_Type()
{
  #ifndef NODESTRUCT
  delete CylindricityCha_1047_TypePair;
  #endif
}

void CylindricityCha_1047_Type::printSelf(FILE * outFile)
{
  CylindricityCha_1047_TypePair->printSelf(outFile);
}

CylindricityCha_1047_TypeChoicePair * CylindricityCha_1047_Type::getCylindricityCha_1047_TypePair()
{return CylindricityCha_1047_TypePair;}

void CylindricityCha_1047_Type::setCylindricityCha_1047_TypePair(CylindricityCha_1047_TypeChoicePair * CylindricityCha_1047_TypePairIn)
{CylindricityCha_1047_TypePair = CylindricityCha_1047_TypePairIn;}
CylindricityCha_1047_TypeChoicePair::CylindricityCha_1047_TypeChoicePair() {}

CylindricityCha_1047_TypeChoicePair::CylindricityCha_1047_TypeChoicePair(
 whichOne CylindricityCha_1047_TypeTypeIn,
 CylindricityCha_1047_TypeVal CylindricityCha_1047_TypeValueIn)
{
  CylindricityCha_1047_TypeType = CylindricityCha_1047_TypeTypeIn;
  CylindricityCha_1047_TypeValue = CylindricityCha_1047_TypeValueIn;
}

CylindricityCha_1047_TypeChoicePair::~CylindricityCha_1047_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (CylindricityCha_1047_TypeType == ToleranceZonePerUnitAngleE)
    delete CylindricityCha_1047_TypeValue.ToleranceZonePerUnitAngle;
  else if (CylindricityCha_1047_TypeType == ToleranceZonePerUnitArcLengthE)
    delete CylindricityCha_1047_TypeValue.ToleranceZonePerUnitArcLength;
  else if (CylindricityCha_1047_TypeType == ToleranceZonePerUnitPolarAreaE)
    delete CylindricityCha_1047_TypeValue.ToleranceZonePerUnitPolarArea;
  else if (CylindricityCha_1047_TypeType == ToleranceZonePerUnitAreaE)
    delete CylindricityCha_1047_TypeValue.ToleranceZonePerUnitArea;
  else if (CylindricityCha_1047_TypeType == ToleranceZonePerUnitLengthE)
    delete CylindricityCha_1047_TypeValue.ToleranceZonePerUnitLength;
  #endif
}

void CylindricityCha_1047_TypeChoicePair::printSelf(FILE * outFile)
{
  if (CylindricityCha_1047_TypeType == ToleranceZonePerUnitAngleE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceZonePerUnitAngle");
      CylindricityCha_1047_TypeValue.ToleranceZonePerUnitAngle->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ToleranceZonePerUnitAngle>\n");
    }
  else if (CylindricityCha_1047_TypeType == ToleranceZonePerUnitArcLengthE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceZonePerUnitArcLength");
      CylindricityCha_1047_TypeValue.ToleranceZonePerUnitArcLength->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ToleranceZonePerUnitArcLength>\n");
    }
  else if (CylindricityCha_1047_TypeType == ToleranceZonePerUnitPolarAreaE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceZonePerUnitPolarArea");
      CylindricityCha_1047_TypeValue.ToleranceZonePerUnitPolarArea->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ToleranceZonePerUnitPolarArea>\n");
    }
  else if (CylindricityCha_1047_TypeType == ToleranceZonePerUnitAreaE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceZonePerUnitArea");
      CylindricityCha_1047_TypeValue.ToleranceZonePerUnitArea->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ToleranceZonePerUnitArea>\n");
    }
  else if (CylindricityCha_1047_TypeType == ToleranceZonePerUnitLengthE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceZonePerUnitLength");
      CylindricityCha_1047_TypeValue.ToleranceZonePerUnitLength->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ToleranceZonePerUnitLength>\n");
    }
}

/* ***************************************************************** */

/* class CylindricityCha_1048_Type

*/

CylindricityCha_1048_Type::CylindricityCha_1048_Type()
{
  ZoneRadii = 0;
  ZoneAxis = 0;
}

CylindricityCha_1048_Type::CylindricityCha_1048_Type(
 MeasuredZoneRadiiType * ZoneRadiiIn,
 MeasuredZoneAxisType * ZoneAxisIn)
{
  ZoneRadii = ZoneRadiiIn;
  ZoneAxis = ZoneAxisIn;
}

CylindricityCha_1048_Type::~CylindricityCha_1048_Type()
{
  #ifndef NODESTRUCT
  delete ZoneRadii;
  delete ZoneAxis;
  #endif
}

void CylindricityCha_1048_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<ZoneRadii");
  ZoneRadii->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ZoneRadii>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<ZoneAxis");
  ZoneAxis->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ZoneAxis>\n");
}

MeasuredZoneRadiiType * CylindricityCha_1048_Type::getZoneRadii()
{return ZoneRadii;}

void CylindricityCha_1048_Type::setZoneRadii(MeasuredZoneRadiiType * ZoneRadiiIn)
{ZoneRadii = ZoneRadiiIn;}

MeasuredZoneAxisType * CylindricityCha_1048_Type::getZoneAxis()
{return ZoneAxis;}

void CylindricityCha_1048_Type::setZoneAxis(MeasuredZoneAxisType * ZoneAxisIn)
{ZoneAxis = ZoneAxisIn;}

/* ***************************************************************** */

/* class FlatnessCharact_1049_Type

*/

FlatnessCharact_1049_Type::FlatnessCharact_1049_Type()
{
  FlatnessCharact_1049_TypePair = 0;
}

FlatnessCharact_1049_Type::FlatnessCharact_1049_Type(
 FlatnessCharact_1049_TypeChoicePair * FlatnessCharact_1049_TypePairIn)
{
  FlatnessCharact_1049_TypePair = FlatnessCharact_1049_TypePairIn;
}

FlatnessCharact_1049_Type::~FlatnessCharact_1049_Type()
{
  #ifndef NODESTRUCT
  delete FlatnessCharact_1049_TypePair;
  #endif
}

void FlatnessCharact_1049_Type::printSelf(FILE * outFile)
{
  FlatnessCharact_1049_TypePair->printSelf(outFile);
}

FlatnessCharact_1049_TypeChoicePair * FlatnessCharact_1049_Type::getFlatnessCharact_1049_TypePair()
{return FlatnessCharact_1049_TypePair;}

void FlatnessCharact_1049_Type::setFlatnessCharact_1049_TypePair(FlatnessCharact_1049_TypeChoicePair * FlatnessCharact_1049_TypePairIn)
{FlatnessCharact_1049_TypePair = FlatnessCharact_1049_TypePairIn;}
FlatnessCharact_1049_TypeChoicePair::FlatnessCharact_1049_TypeChoicePair() {}

FlatnessCharact_1049_TypeChoicePair::FlatnessCharact_1049_TypeChoicePair(
 whichOne FlatnessCharact_1049_TypeTypeIn,
 FlatnessCharact_1049_TypeVal FlatnessCharact_1049_TypeValueIn)
{
  FlatnessCharact_1049_TypeType = FlatnessCharact_1049_TypeTypeIn;
  FlatnessCharact_1049_TypeValue = FlatnessCharact_1049_TypeValueIn;
}

FlatnessCharact_1049_TypeChoicePair::~FlatnessCharact_1049_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (FlatnessCharact_1049_TypeType == FlatnessCharact_1066E)
    delete FlatnessCharact_1049_TypeValue.FlatnessCharact_1066;
  else if (FlatnessCharact_1049_TypeType == FlatnessCharact_1067E)
    delete FlatnessCharact_1049_TypeValue.FlatnessCharact_1067;
  #endif
}

void FlatnessCharact_1049_TypeChoicePair::printSelf(FILE * outFile)
{
  if (FlatnessCharact_1049_TypeType == FlatnessCharact_1066E)
    {
      FlatnessCharact_1049_TypeValue.FlatnessCharact_1066->printSelf(outFile);
    }
  else if (FlatnessCharact_1049_TypeType == FlatnessCharact_1067E)
    {
      FlatnessCharact_1049_TypeValue.FlatnessCharact_1067->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class GeometricCharac_1050_Type

*/

GeometricCharac_1050_Type::GeometricCharac_1050_Type()
{
  GeometricCharac_1050_TypePair = 0;
}

GeometricCharac_1050_Type::GeometricCharac_1050_Type(
 GeometricCharac_1050_TypeChoicePair * GeometricCharac_1050_TypePairIn)
{
  GeometricCharac_1050_TypePair = GeometricCharac_1050_TypePairIn;
}

GeometricCharac_1050_Type::~GeometricCharac_1050_Type()
{
  #ifndef NODESTRUCT
  delete GeometricCharac_1050_TypePair;
  #endif
}

void GeometricCharac_1050_Type::printSelf(FILE * outFile)
{
  if (GeometricCharac_1050_TypePair)
    {
      GeometricCharac_1050_TypePair->printSelf(outFile);
    }
}

GeometricCharac_1050_TypeChoicePair * GeometricCharac_1050_Type::getGeometricCharac_1050_TypePair()
{return GeometricCharac_1050_TypePair;}

void GeometricCharac_1050_Type::setGeometricCharac_1050_TypePair(GeometricCharac_1050_TypeChoicePair * GeometricCharac_1050_TypePairIn)
{GeometricCharac_1050_TypePair = GeometricCharac_1050_TypePairIn;}
GeometricCharac_1050_TypeChoicePair::GeometricCharac_1050_TypeChoicePair() {}

GeometricCharac_1050_TypeChoicePair::GeometricCharac_1050_TypeChoicePair(
 whichOne GeometricCharac_1050_TypeTypeIn,
 GeometricCharac_1050_TypeVal GeometricCharac_1050_TypeValueIn)
{
  GeometricCharac_1050_TypeType = GeometricCharac_1050_TypeTypeIn;
  GeometricCharac_1050_TypeValue = GeometricCharac_1050_TypeValueIn;
}

GeometricCharac_1050_TypeChoicePair::~GeometricCharac_1050_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (GeometricCharac_1050_TypeType == AssociatedTolerancedFeatureSpecificationElementE)
    delete GeometricCharac_1050_TypeValue.AssociatedTolerancedFeatureSpecificationElement;
  else if (GeometricCharac_1050_TypeType == ReferenceFeatureAssociationSpecificationElementE)
    delete GeometricCharac_1050_TypeValue.ReferenceFeatureAssociationSpecificationElement;
  #endif
}

void GeometricCharac_1050_TypeChoicePair::printSelf(FILE * outFile)
{
  if (GeometricCharac_1050_TypeType == AssociatedTolerancedFeatureSpecificationElementE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AssociatedTolerancedFeatureSpecificationElement");
      GeometricCharac_1050_TypeValue.AssociatedTolerancedFeatureSpecificationElement->printSelf(outFile);
      fprintf(outFile, "</AssociatedTolerancedFeatureSpecificationElement>\n");
    }
  else if (GeometricCharac_1050_TypeType == ReferenceFeatureAssociationSpecificationElementE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ReferenceFeatureAssociationSpecificationElement");
      GeometricCharac_1050_TypeValue.ReferenceFeatureAssociationSpecificationElement->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ReferenceFeatureAssociationSpecificationElement>\n");
    }
}

/* ***************************************************************** */

/* class LocationOnDrawi_1051_Type

*/

LocationOnDrawi_1051_Type::LocationOnDrawi_1051_Type()
{
  DrawingId = 0;
  SheetNumber = 0;
  DrawingZone = 0;
}

LocationOnDrawi_1051_Type::LocationOnDrawi_1051_Type(
 QIFReferenceFullType * DrawingIdIn,
 XmlString * SheetNumberIn,
 XmlString * DrawingZoneIn)
{
  DrawingId = DrawingIdIn;
  SheetNumber = SheetNumberIn;
  DrawingZone = DrawingZoneIn;
}

LocationOnDrawi_1051_Type::~LocationOnDrawi_1051_Type()
{
  #ifndef NODESTRUCT
  delete DrawingId;
  delete SheetNumber;
  delete DrawingZone;
  #endif
}

void LocationOnDrawi_1051_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<DrawingId");
  DrawingId->printSelf(outFile);
  fprintf(outFile, "</DrawingId>\n");
  if (SheetNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SheetNumber");
      SheetNumber->printSelf(outFile);
      fprintf(outFile, "</SheetNumber>\n");
    }
  if (DrawingZone)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DrawingZone");
      DrawingZone->printSelf(outFile);
      fprintf(outFile, "</DrawingZone>\n");
    }
}

QIFReferenceFullType * LocationOnDrawi_1051_Type::getDrawingId()
{return DrawingId;}

void LocationOnDrawi_1051_Type::setDrawingId(QIFReferenceFullType * DrawingIdIn)
{DrawingId = DrawingIdIn;}

XmlString * LocationOnDrawi_1051_Type::getSheetNumber()
{return SheetNumber;}

void LocationOnDrawi_1051_Type::setSheetNumber(XmlString * SheetNumberIn)
{SheetNumber = SheetNumberIn;}

XmlString * LocationOnDrawi_1051_Type::getDrawingZone()
{return DrawingZone;}

void LocationOnDrawi_1051_Type::setDrawingZone(XmlString * DrawingZoneIn)
{DrawingZone = DrawingZoneIn;}

/* ***************************************************************** */

/* class LocationOnDrawi_1052_Type

*/

LocationOnDrawi_1052_Type::LocationOnDrawi_1052_Type()
{
  ModelId = 0;
  View = 0;
}

LocationOnDrawi_1052_Type::LocationOnDrawi_1052_Type(
 QIFReferenceFullType * ModelIdIn,
 XmlString * ViewIn)
{
  ModelId = ModelIdIn;
  View = ViewIn;
}

LocationOnDrawi_1052_Type::~LocationOnDrawi_1052_Type()
{
  #ifndef NODESTRUCT
  delete ModelId;
  delete View;
  #endif
}

void LocationOnDrawi_1052_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<ModelId");
  ModelId->printSelf(outFile);
  fprintf(outFile, "</ModelId>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<View");
  View->printSelf(outFile);
  fprintf(outFile, "</View>\n");
}

QIFReferenceFullType * LocationOnDrawi_1052_Type::getModelId()
{return ModelId;}

void LocationOnDrawi_1052_Type::setModelId(QIFReferenceFullType * ModelIdIn)
{ModelId = ModelIdIn;}

XmlString * LocationOnDrawi_1052_Type::getView()
{return View;}

void LocationOnDrawi_1052_Type::setView(XmlString * ViewIn)
{View = ViewIn;}

/* ***************************************************************** */

/* class LocationOnDrawi_1053_Type

*/

LocationOnDrawi_1053_Type::LocationOnDrawi_1053_Type()
{
  ViewId = 0;
}

LocationOnDrawi_1053_Type::LocationOnDrawi_1053_Type(
 QIFReferenceFullType * ViewIdIn)
{
  ViewId = ViewIdIn;
}

LocationOnDrawi_1053_Type::~LocationOnDrawi_1053_Type()
{
  #ifndef NODESTRUCT
  delete ViewId;
  #endif
}

void LocationOnDrawi_1053_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<ViewId");
  ViewId->printSelf(outFile);
  fprintf(outFile, "</ViewId>\n");
}

QIFReferenceFullType * LocationOnDrawi_1053_Type::getViewId()
{return ViewId;}

void LocationOnDrawi_1053_Type::setViewId(QIFReferenceFullType * ViewIdIn)
{ViewId = ViewIdIn;}

/* ***************************************************************** */

/* class OrientationChar_1054_Type

*/

OrientationChar_1054_Type::OrientationChar_1054_Type()
{
  OrientationChar_1054_TypePair = 0;
}

OrientationChar_1054_Type::OrientationChar_1054_Type(
 OrientationChar_1054_TypeChoicePair * OrientationChar_1054_TypePairIn)
{
  OrientationChar_1054_TypePair = OrientationChar_1054_TypePairIn;
}

OrientationChar_1054_Type::~OrientationChar_1054_Type()
{
  #ifndef NODESTRUCT
  delete OrientationChar_1054_TypePair;
  #endif
}

void OrientationChar_1054_Type::printSelf(FILE * outFile)
{
  if (OrientationChar_1054_TypePair)
    {
      OrientationChar_1054_TypePair->printSelf(outFile);
    }
}

OrientationChar_1054_TypeChoicePair * OrientationChar_1054_Type::getOrientationChar_1054_TypePair()
{return OrientationChar_1054_TypePair;}

void OrientationChar_1054_Type::setOrientationChar_1054_TypePair(OrientationChar_1054_TypeChoicePair * OrientationChar_1054_TypePairIn)
{OrientationChar_1054_TypePair = OrientationChar_1054_TypePairIn;}
OrientationChar_1054_TypeChoicePair::OrientationChar_1054_TypeChoicePair() {}

OrientationChar_1054_TypeChoicePair::OrientationChar_1054_TypeChoicePair(
 whichOne OrientationChar_1054_TypeTypeIn,
 OrientationChar_1054_TypeVal OrientationChar_1054_TypeValueIn)
{
  OrientationChar_1054_TypeType = OrientationChar_1054_TypeTypeIn;
  OrientationChar_1054_TypeValue = OrientationChar_1054_TypeValueIn;
}

OrientationChar_1054_TypeChoicePair::~OrientationChar_1054_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (OrientationChar_1054_TypeType == EachRadialElementE)
    delete OrientationChar_1054_TypeValue.EachRadialElement;
  else if (OrientationChar_1054_TypeType == EachElementE)
    delete OrientationChar_1054_TypeValue.EachElement;
  #endif
}

void OrientationChar_1054_TypeChoicePair::printSelf(FILE * outFile)
{
  if (OrientationChar_1054_TypeType == EachRadialElementE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EachRadialElement");
      OrientationChar_1054_TypeValue.EachRadialElement->printSelf(outFile);
      fprintf(outFile, "</EachRadialElement>\n");
    }
  else if (OrientationChar_1054_TypeType == EachElementE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EachElement");
      OrientationChar_1054_TypeValue.EachElement->printSelf(outFile);
      fprintf(outFile, "</EachElement>\n");
    }
}

/* ***************************************************************** */

/* class OriginReference_1055_Type

*/

OriginReference_1055_Type::OriginReference_1055_Type()
{
  FeatureNominalId = 0;
  ReferencedComponent = 0;
}

OriginReference_1055_Type::OriginReference_1055_Type(
 QIFReferenceFullType * FeatureNominalIdIn,
 ReferencedComponentEnumType * ReferencedComponentIn)
{
  FeatureNominalId = FeatureNominalIdIn;
  ReferencedComponent = ReferencedComponentIn;
}

OriginReference_1055_Type::~OriginReference_1055_Type()
{
  #ifndef NODESTRUCT
  delete FeatureNominalId;
  delete ReferencedComponent;
  #endif
}

void OriginReference_1055_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<ReferencedComponent");
  ReferencedComponent->printSelf(outFile);
  fprintf(outFile, "</ReferencedComponent>\n");
}

QIFReferenceFullType * OriginReference_1055_Type::getFeatureNominalId()
{return FeatureNominalId;}

void OriginReference_1055_Type::setFeatureNominalId(QIFReferenceFullType * FeatureNominalIdIn)
{FeatureNominalId = FeatureNominalIdIn;}

ReferencedComponentEnumType * OriginReference_1055_Type::getReferencedComponent()
{return ReferencedComponent;}

void OriginReference_1055_Type::setReferencedComponent(ReferencedComponentEnumType * ReferencedComponentIn)
{ReferencedComponent = ReferencedComponentIn;}

/* ***************************************************************** */

/* class ProfileCharacte_1056_Type

*/

ProfileCharacte_1056_Type::ProfileCharacte_1056_Type()
{
  ProfileCharacte_1056_TypePair = 0;
}

ProfileCharacte_1056_Type::ProfileCharacte_1056_Type(
 ProfileCharacte_1056_TypeChoicePair * ProfileCharacte_1056_TypePairIn)
{
  ProfileCharacte_1056_TypePair = ProfileCharacte_1056_TypePairIn;
}

ProfileCharacte_1056_Type::~ProfileCharacte_1056_Type()
{
  #ifndef NODESTRUCT
  delete ProfileCharacte_1056_TypePair;
  #endif
}

void ProfileCharacte_1056_Type::printSelf(FILE * outFile)
{
  if (ProfileCharacte_1056_TypePair)
    {
      ProfileCharacte_1056_TypePair->printSelf(outFile);
    }
}

ProfileCharacte_1056_TypeChoicePair * ProfileCharacte_1056_Type::getProfileCharacte_1056_TypePair()
{return ProfileCharacte_1056_TypePair;}

void ProfileCharacte_1056_Type::setProfileCharacte_1056_TypePair(ProfileCharacte_1056_TypeChoicePair * ProfileCharacte_1056_TypePairIn)
{ProfileCharacte_1056_TypePair = ProfileCharacte_1056_TypePairIn;}
ProfileCharacte_1056_TypeChoicePair::ProfileCharacte_1056_TypeChoicePair() {}

ProfileCharacte_1056_TypeChoicePair::ProfileCharacte_1056_TypeChoicePair(
 whichOne ProfileCharacte_1056_TypeTypeIn,
 ProfileCharacte_1056_TypeVal ProfileCharacte_1056_TypeValueIn)
{
  ProfileCharacte_1056_TypeType = ProfileCharacte_1056_TypeTypeIn;
  ProfileCharacte_1056_TypeValue = ProfileCharacte_1056_TypeValueIn;
}

ProfileCharacte_1056_TypeChoicePair::~ProfileCharacte_1056_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (ProfileCharacte_1056_TypeType == OuterDispositionE)
    delete ProfileCharacte_1056_TypeValue.OuterDisposition;
  else if (ProfileCharacte_1056_TypeType == UnequallyDisposedZoneE)
    delete ProfileCharacte_1056_TypeValue.UnequallyDisposedZone;
  #endif
}

void ProfileCharacte_1056_TypeChoicePair::printSelf(FILE * outFile)
{
  if (ProfileCharacte_1056_TypeType == OuterDispositionE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OuterDisposition");
      ProfileCharacte_1056_TypeValue.OuterDisposition->printSelf(outFile);
      fprintf(outFile, "</OuterDisposition>\n");
    }
  else if (ProfileCharacte_1056_TypeType == UnequallyDisposedZoneE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UnequallyDisposedZone");
      ProfileCharacte_1056_TypeValue.UnequallyDisposedZone->printSelf(outFile);
      fprintf(outFile, "</UnequallyDisposedZone>\n");
    }
}

/* ***************************************************************** */

/* class SphericityChara_1057_Type

*/

SphericityChara_1057_Type::SphericityChara_1057_Type()
{
  ZoneRadii = 0;
  ZonePoint = 0;
}

SphericityChara_1057_Type::SphericityChara_1057_Type(
 MeasuredZoneRadiiType * ZoneRadiiIn,
 MeasuredPointType * ZonePointIn)
{
  ZoneRadii = ZoneRadiiIn;
  ZonePoint = ZonePointIn;
}

SphericityChara_1057_Type::~SphericityChara_1057_Type()
{
  #ifndef NODESTRUCT
  delete ZoneRadii;
  delete ZonePoint;
  #endif
}

void SphericityChara_1057_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<ZoneRadii");
  ZoneRadii->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ZoneRadii>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<ZonePoint");
  ZonePoint->printSelf(outFile);
  fprintf(outFile, "</ZonePoint>\n");
}

MeasuredZoneRadiiType * SphericityChara_1057_Type::getZoneRadii()
{return ZoneRadii;}

void SphericityChara_1057_Type::setZoneRadii(MeasuredZoneRadiiType * ZoneRadiiIn)
{ZoneRadii = ZoneRadiiIn;}

MeasuredPointType * SphericityChara_1057_Type::getZonePoint()
{return ZonePoint;}

void SphericityChara_1057_Type::setZonePoint(MeasuredPointType * ZonePointIn)
{ZonePoint = ZonePointIn;}

/* ***************************************************************** */

/* class StraightnessCha_1058_Type

*/

StraightnessCha_1058_Type::StraightnessCha_1058_Type()
{
  StraightnessCha_1058_TypePair = 0;
}

StraightnessCha_1058_Type::StraightnessCha_1058_Type(
 StraightnessCha_1058_TypeChoicePair * StraightnessCha_1058_TypePairIn)
{
  StraightnessCha_1058_TypePair = StraightnessCha_1058_TypePairIn;
}

StraightnessCha_1058_Type::~StraightnessCha_1058_Type()
{
  #ifndef NODESTRUCT
  delete StraightnessCha_1058_TypePair;
  #endif
}

void StraightnessCha_1058_Type::printSelf(FILE * outFile)
{
  StraightnessCha_1058_TypePair->printSelf(outFile);
}

StraightnessCha_1058_TypeChoicePair * StraightnessCha_1058_Type::getStraightnessCha_1058_TypePair()
{return StraightnessCha_1058_TypePair;}

void StraightnessCha_1058_Type::setStraightnessCha_1058_TypePair(StraightnessCha_1058_TypeChoicePair * StraightnessCha_1058_TypePairIn)
{StraightnessCha_1058_TypePair = StraightnessCha_1058_TypePairIn;}
StraightnessCha_1058_TypeChoicePair::StraightnessCha_1058_TypeChoicePair() {}

StraightnessCha_1058_TypeChoicePair::StraightnessCha_1058_TypeChoicePair(
 whichOne StraightnessCha_1058_TypeTypeIn,
 StraightnessCha_1058_TypeVal StraightnessCha_1058_TypeValueIn)
{
  StraightnessCha_1058_TypeType = StraightnessCha_1058_TypeTypeIn;
  StraightnessCha_1058_TypeValue = StraightnessCha_1058_TypeValueIn;
}

StraightnessCha_1058_TypeChoicePair::~StraightnessCha_1058_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (StraightnessCha_1058_TypeType == StraightnessCha_1068E)
    delete StraightnessCha_1058_TypeValue.StraightnessCha_1068;
  else if (StraightnessCha_1058_TypeType == StraightnessCha_1069E)
    delete StraightnessCha_1058_TypeValue.StraightnessCha_1069;
  #endif
}

void StraightnessCha_1058_TypeChoicePair::printSelf(FILE * outFile)
{
  if (StraightnessCha_1058_TypeType == StraightnessCha_1068E)
    {
      StraightnessCha_1058_TypeValue.StraightnessCha_1068->printSelf(outFile);
    }
  else if (StraightnessCha_1058_TypeType == StraightnessCha_1069E)
    {
      StraightnessCha_1058_TypeValue.StraightnessCha_1069->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class SurfaceProfileN_1059_Type

*/

SurfaceProfileN_1059_Type::SurfaceProfileN_1059_Type()
{
  SurfaceProfileN_1059_TypePair = 0;
}

SurfaceProfileN_1059_Type::SurfaceProfileN_1059_Type(
 SurfaceProfileN_1059_TypeChoicePair * SurfaceProfileN_1059_TypePairIn)
{
  SurfaceProfileN_1059_TypePair = SurfaceProfileN_1059_TypePairIn;
}

SurfaceProfileN_1059_Type::~SurfaceProfileN_1059_Type()
{
  #ifndef NODESTRUCT
  delete SurfaceProfileN_1059_TypePair;
  #endif
}

void SurfaceProfileN_1059_Type::printSelf(FILE * outFile)
{
  if (SurfaceProfileN_1059_TypePair)
    {
      SurfaceProfileN_1059_TypePair->printSelf(outFile);
    }
}

SurfaceProfileN_1059_TypeChoicePair * SurfaceProfileN_1059_Type::getSurfaceProfileN_1059_TypePair()
{return SurfaceProfileN_1059_TypePair;}

void SurfaceProfileN_1059_Type::setSurfaceProfileN_1059_TypePair(SurfaceProfileN_1059_TypeChoicePair * SurfaceProfileN_1059_TypePairIn)
{SurfaceProfileN_1059_TypePair = SurfaceProfileN_1059_TypePairIn;}
SurfaceProfileN_1059_TypeChoicePair::SurfaceProfileN_1059_TypeChoicePair() {}

SurfaceProfileN_1059_TypeChoicePair::SurfaceProfileN_1059_TypeChoicePair(
 whichOne SurfaceProfileN_1059_TypeTypeIn,
 SurfaceProfileN_1059_TypeVal SurfaceProfileN_1059_TypeValueIn)
{
  SurfaceProfileN_1059_TypeType = SurfaceProfileN_1059_TypeTypeIn;
  SurfaceProfileN_1059_TypeValue = SurfaceProfileN_1059_TypeValueIn;
}

SurfaceProfileN_1059_TypeChoicePair::~SurfaceProfileN_1059_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (SurfaceProfileN_1059_TypeType == ToPointOuterDispositionE)
    delete SurfaceProfileN_1059_TypeValue.ToPointOuterDisposition;
  else if (SurfaceProfileN_1059_TypeType == ToPointUnequallyDisposedZoneE)
    delete SurfaceProfileN_1059_TypeValue.ToPointUnequallyDisposedZone;
  #endif
}

void SurfaceProfileN_1059_TypeChoicePair::printSelf(FILE * outFile)
{
  if (SurfaceProfileN_1059_TypeType == ToPointOuterDispositionE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToPointOuterDisposition");
      SurfaceProfileN_1059_TypeValue.ToPointOuterDisposition->printSelf(outFile);
      fprintf(outFile, "</ToPointOuterDisposition>\n");
    }
  else if (SurfaceProfileN_1059_TypeType == ToPointUnequallyDisposedZoneE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToPointUnequallyDisposedZone");
      SurfaceProfileN_1059_TypeValue.ToPointUnequallyDisposedZone->printSelf(outFile);
      fprintf(outFile, "</ToPointUnequallyDisposedZone>\n");
    }
}

/* ***************************************************************** */

/* class UserDefinedUnit_1060_Type

*/

UserDefinedUnit_1060_Type::UserDefinedUnit_1060_Type()
{
  UserDefinedUnit_1060_TypePair = 0;
}

UserDefinedUnit_1060_Type::UserDefinedUnit_1060_Type(
 UserDefinedUnit_1060_TypeChoicePair * UserDefinedUnit_1060_TypePairIn)
{
  UserDefinedUnit_1060_TypePair = UserDefinedUnit_1060_TypePairIn;
}

UserDefinedUnit_1060_Type::~UserDefinedUnit_1060_Type()
{
  #ifndef NODESTRUCT
  delete UserDefinedUnit_1060_TypePair;
  #endif
}

void UserDefinedUnit_1060_Type::printSelf(FILE * outFile)
{
  UserDefinedUnit_1060_TypePair->printSelf(outFile);
}

UserDefinedUnit_1060_TypeChoicePair * UserDefinedUnit_1060_Type::getUserDefinedUnit_1060_TypePair()
{return UserDefinedUnit_1060_TypePair;}

void UserDefinedUnit_1060_Type::setUserDefinedUnit_1060_TypePair(UserDefinedUnit_1060_TypeChoicePair * UserDefinedUnit_1060_TypePairIn)
{UserDefinedUnit_1060_TypePair = UserDefinedUnit_1060_TypePairIn;}
UserDefinedUnit_1060_TypeChoicePair::UserDefinedUnit_1060_TypeChoicePair() {}

UserDefinedUnit_1060_TypeChoicePair::UserDefinedUnit_1060_TypeChoicePair(
 whichOne UserDefinedUnit_1060_TypeTypeIn,
 UserDefinedUnit_1060_TypeVal UserDefinedUnit_1060_TypeValueIn)
{
  UserDefinedUnit_1060_TypeType = UserDefinedUnit_1060_TypeTypeIn;
  UserDefinedUnit_1060_TypeValue = UserDefinedUnit_1060_TypeValueIn;
}

UserDefinedUnit_1060_TypeChoicePair::~UserDefinedUnit_1060_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (UserDefinedUnit_1060_TypeType == UserDefinedUnit_1070E)
    delete UserDefinedUnit_1060_TypeValue.UserDefinedUnit_1070;
  else if (UserDefinedUnit_1060_TypeType == MinValueE)
    delete UserDefinedUnit_1060_TypeValue.MinValue;
  #endif
}

void UserDefinedUnit_1060_TypeChoicePair::printSelf(FILE * outFile)
{
  if (UserDefinedUnit_1060_TypeType == UserDefinedUnit_1070E)
    {
      UserDefinedUnit_1060_TypeValue.UserDefinedUnit_1070->printSelf(outFile);
    }
  else if (UserDefinedUnit_1060_TypeType == MinValueE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      UserDefinedUnit_1060_TypeValue.MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
}

/* ***************************************************************** */

/* class WeldFilletChara_1061_Type

*/

WeldFilletChara_1061_Type::WeldFilletChara_1061_Type()
{
  WeldFilletChara_1061_TypePair = 0;
}

WeldFilletChara_1061_Type::WeldFilletChara_1061_Type(
 WeldFilletChara_1061_TypeChoicePair * WeldFilletChara_1061_TypePairIn)
{
  WeldFilletChara_1061_TypePair = WeldFilletChara_1061_TypePairIn;
}

WeldFilletChara_1061_Type::~WeldFilletChara_1061_Type()
{
  #ifndef NODESTRUCT
  delete WeldFilletChara_1061_TypePair;
  #endif
}

void WeldFilletChara_1061_Type::printSelf(FILE * outFile)
{
  if (WeldFilletChara_1061_TypePair)
    {
      WeldFilletChara_1061_TypePair->printSelf(outFile);
    }
}

WeldFilletChara_1061_TypeChoicePair * WeldFilletChara_1061_Type::getWeldFilletChara_1061_TypePair()
{return WeldFilletChara_1061_TypePair;}

void WeldFilletChara_1061_Type::setWeldFilletChara_1061_TypePair(WeldFilletChara_1061_TypeChoicePair * WeldFilletChara_1061_TypePairIn)
{WeldFilletChara_1061_TypePair = WeldFilletChara_1061_TypePairIn;}
WeldFilletChara_1061_TypeChoicePair::WeldFilletChara_1061_TypeChoicePair() {}

WeldFilletChara_1061_TypeChoicePair::WeldFilletChara_1061_TypeChoicePair(
 whichOne WeldFilletChara_1061_TypeTypeIn,
 WeldFilletChara_1061_TypeVal WeldFilletChara_1061_TypeValueIn)
{
  WeldFilletChara_1061_TypeType = WeldFilletChara_1061_TypeTypeIn;
  WeldFilletChara_1061_TypeValue = WeldFilletChara_1061_TypeValueIn;
}

WeldFilletChara_1061_TypeChoicePair::~WeldFilletChara_1061_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (WeldFilletChara_1061_TypeType == BothSidesE)
    delete WeldFilletChara_1061_TypeValue.BothSides;
  else if (WeldFilletChara_1061_TypeType == OneSideE)
    delete WeldFilletChara_1061_TypeValue.OneSide;
  #endif
}

void WeldFilletChara_1061_TypeChoicePair::printSelf(FILE * outFile)
{
  if (WeldFilletChara_1061_TypeType == BothSidesE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BothSides");
      WeldFilletChara_1061_TypeValue.BothSides->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BothSides>\n");
    }
  else if (WeldFilletChara_1061_TypeType == OneSideE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OneSide");
      WeldFilletChara_1061_TypeValue.OneSide->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OneSide>\n");
    }
}

/* ***************************************************************** */

/* class WeldFilletChara_1062_Type

*/

WeldFilletChara_1062_Type::WeldFilletChara_1062_Type()
{
  WeldFilletChara_1062_TypePair = 0;
}

WeldFilletChara_1062_Type::WeldFilletChara_1062_Type(
 WeldFilletChara_1062_TypeChoicePair * WeldFilletChara_1062_TypePairIn)
{
  WeldFilletChara_1062_TypePair = WeldFilletChara_1062_TypePairIn;
}

WeldFilletChara_1062_Type::~WeldFilletChara_1062_Type()
{
  #ifndef NODESTRUCT
  delete WeldFilletChara_1062_TypePair;
  #endif
}

void WeldFilletChara_1062_Type::printSelf(FILE * outFile)
{
  if (WeldFilletChara_1062_TypePair)
    {
      WeldFilletChara_1062_TypePair->printSelf(outFile);
    }
}

WeldFilletChara_1062_TypeChoicePair * WeldFilletChara_1062_Type::getWeldFilletChara_1062_TypePair()
{return WeldFilletChara_1062_TypePair;}

void WeldFilletChara_1062_Type::setWeldFilletChara_1062_TypePair(WeldFilletChara_1062_TypeChoicePair * WeldFilletChara_1062_TypePairIn)
{WeldFilletChara_1062_TypePair = WeldFilletChara_1062_TypePairIn;}
WeldFilletChara_1062_TypeChoicePair::WeldFilletChara_1062_TypeChoicePair() {}

WeldFilletChara_1062_TypeChoicePair::WeldFilletChara_1062_TypeChoicePair(
 whichOne WeldFilletChara_1062_TypeTypeIn,
 WeldFilletChara_1062_TypeVal WeldFilletChara_1062_TypeValueIn)
{
  WeldFilletChara_1062_TypeType = WeldFilletChara_1062_TypeTypeIn;
  WeldFilletChara_1062_TypeValue = WeldFilletChara_1062_TypeValueIn;
}

WeldFilletChara_1062_TypeChoicePair::~WeldFilletChara_1062_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (WeldFilletChara_1062_TypeType == BothSidesE)
    delete WeldFilletChara_1062_TypeValue.BothSides;
  else if (WeldFilletChara_1062_TypeType == OneSideE)
    delete WeldFilletChara_1062_TypeValue.OneSide;
  #endif
}

void WeldFilletChara_1062_TypeChoicePair::printSelf(FILE * outFile)
{
  if (WeldFilletChara_1062_TypeType == BothSidesE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BothSides");
      WeldFilletChara_1062_TypeValue.BothSides->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BothSides>\n");
    }
  else if (WeldFilletChara_1062_TypeType == OneSideE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OneSide");
      WeldFilletChara_1062_TypeValue.OneSide->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</OneSide>\n");
    }
}

/* ***************************************************************** */

/* class WeldGrooveOneSi_1063_Type

*/

WeldGrooveOneSi_1063_Type::WeldGrooveOneSi_1063_Type()
{
  SideParameters = 0;
  SupplementarySymbol = 0;
}

WeldGrooveOneSi_1063_Type::WeldGrooveOneSi_1063_Type(
 WeldGrooveOneSideParametersType * SideParametersIn,
 WeldSupplementarySymbolEnumType * SupplementarySymbolIn)
{
  SideParameters = SideParametersIn;
  SupplementarySymbol = SupplementarySymbolIn;
}

WeldGrooveOneSi_1063_Type::~WeldGrooveOneSi_1063_Type()
{
  #ifndef NODESTRUCT
  delete SideParameters;
  delete SupplementarySymbol;
  #endif
}

void WeldGrooveOneSi_1063_Type::printSelf(FILE * outFile)
{
  if (SideParameters)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SideParameters");
      SideParameters->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SideParameters>\n");
    }
  if (SupplementarySymbol)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SupplementarySymbol");
      SupplementarySymbol->printSelf(outFile);
      fprintf(outFile, "</SupplementarySymbol>\n");
    }
}

WeldGrooveOneSideParametersType * WeldGrooveOneSi_1063_Type::getSideParameters()
{return SideParameters;}

void WeldGrooveOneSi_1063_Type::setSideParameters(WeldGrooveOneSideParametersType * SideParametersIn)
{SideParameters = SideParametersIn;}

WeldSupplementarySymbolEnumType * WeldGrooveOneSi_1063_Type::getSupplementarySymbol()
{return SupplementarySymbol;}

void WeldGrooveOneSi_1063_Type::setSupplementarySymbol(WeldSupplementarySymbolEnumType * SupplementarySymbolIn)
{SupplementarySymbol = SupplementarySymbolIn;}

/* ***************************************************************** */

/* class CircularityChar_1064_Type

*/

CircularityChar_1064_Type::CircularityChar_1064_Type()
{
  CircularityChar_1064_TypePair = 0;
}

CircularityChar_1064_Type::CircularityChar_1064_Type(
 CircularityChar_1064_TypeChoicePair * CircularityChar_1064_TypePairIn)
{
  CircularityChar_1064_TypePair = CircularityChar_1064_TypePairIn;
}

CircularityChar_1064_Type::~CircularityChar_1064_Type()
{
  #ifndef NODESTRUCT
  delete CircularityChar_1064_TypePair;
  #endif
}

void CircularityChar_1064_Type::printSelf(FILE * outFile)
{
  if (CircularityChar_1064_TypePair)
    {
      CircularityChar_1064_TypePair->printSelf(outFile);
    }
}

CircularityChar_1064_TypeChoicePair * CircularityChar_1064_Type::getCircularityChar_1064_TypePair()
{return CircularityChar_1064_TypePair;}

void CircularityChar_1064_Type::setCircularityChar_1064_TypePair(CircularityChar_1064_TypeChoicePair * CircularityChar_1064_TypePairIn)
{CircularityChar_1064_TypePair = CircularityChar_1064_TypePairIn;}
CircularityChar_1064_TypeChoicePair::CircularityChar_1064_TypeChoicePair() {}

CircularityChar_1064_TypeChoicePair::CircularityChar_1064_TypeChoicePair(
 whichOne CircularityChar_1064_TypeTypeIn,
 CircularityChar_1064_TypeVal CircularityChar_1064_TypeValueIn)
{
  CircularityChar_1064_TypeType = CircularityChar_1064_TypeTypeIn;
  CircularityChar_1064_TypeValue = CircularityChar_1064_TypeValueIn;
}

CircularityChar_1064_TypeChoicePair::~CircularityChar_1064_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (CircularityChar_1064_TypeType == ToleranceZonePerUnitAngleE)
    delete CircularityChar_1064_TypeValue.ToleranceZonePerUnitAngle;
  else if (CircularityChar_1064_TypeType == ToleranceZonePerUnitArcLengthE)
    delete CircularityChar_1064_TypeValue.ToleranceZonePerUnitArcLength;
  #endif
}

void CircularityChar_1064_TypeChoicePair::printSelf(FILE * outFile)
{
  if (CircularityChar_1064_TypeType == ToleranceZonePerUnitAngleE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceZonePerUnitAngle");
      CircularityChar_1064_TypeValue.ToleranceZonePerUnitAngle->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ToleranceZonePerUnitAngle>\n");
    }
  else if (CircularityChar_1064_TypeType == ToleranceZonePerUnitArcLengthE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceZonePerUnitArcLength");
      CircularityChar_1064_TypeValue.ToleranceZonePerUnitArcLength->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ToleranceZonePerUnitArcLength>\n");
    }
}

/* ***************************************************************** */

/* class CylindricityCha_1065_Type

*/

CylindricityCha_1065_Type::CylindricityCha_1065_Type()
{
  CylindricityCha_1065_TypePair = 0;
}

CylindricityCha_1065_Type::CylindricityCha_1065_Type(
 CylindricityCha_1065_TypeChoicePair * CylindricityCha_1065_TypePairIn)
{
  CylindricityCha_1065_TypePair = CylindricityCha_1065_TypePairIn;
}

CylindricityCha_1065_Type::~CylindricityCha_1065_Type()
{
  #ifndef NODESTRUCT
  delete CylindricityCha_1065_TypePair;
  #endif
}

void CylindricityCha_1065_Type::printSelf(FILE * outFile)
{
  if (CylindricityCha_1065_TypePair)
    {
      CylindricityCha_1065_TypePair->printSelf(outFile);
    }
}

CylindricityCha_1065_TypeChoicePair * CylindricityCha_1065_Type::getCylindricityCha_1065_TypePair()
{return CylindricityCha_1065_TypePair;}

void CylindricityCha_1065_Type::setCylindricityCha_1065_TypePair(CylindricityCha_1065_TypeChoicePair * CylindricityCha_1065_TypePairIn)
{CylindricityCha_1065_TypePair = CylindricityCha_1065_TypePairIn;}
CylindricityCha_1065_TypeChoicePair::CylindricityCha_1065_TypeChoicePair() {}

CylindricityCha_1065_TypeChoicePair::CylindricityCha_1065_TypeChoicePair(
 whichOne CylindricityCha_1065_TypeTypeIn,
 CylindricityCha_1065_TypeVal CylindricityCha_1065_TypeValueIn)
{
  CylindricityCha_1065_TypeType = CylindricityCha_1065_TypeTypeIn;
  CylindricityCha_1065_TypeValue = CylindricityCha_1065_TypeValueIn;
}

CylindricityCha_1065_TypeChoicePair::~CylindricityCha_1065_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (CylindricityCha_1065_TypeType == ToleranceZonePerUnitAngleE)
    delete CylindricityCha_1065_TypeValue.ToleranceZonePerUnitAngle;
  else if (CylindricityCha_1065_TypeType == ToleranceZonePerUnitArcLengthE)
    delete CylindricityCha_1065_TypeValue.ToleranceZonePerUnitArcLength;
  else if (CylindricityCha_1065_TypeType == ToleranceZonePerUnitPolarAreaE)
    delete CylindricityCha_1065_TypeValue.ToleranceZonePerUnitPolarArea;
  else if (CylindricityCha_1065_TypeType == ToleranceZonePerUnitAreaE)
    delete CylindricityCha_1065_TypeValue.ToleranceZonePerUnitArea;
  else if (CylindricityCha_1065_TypeType == ToleranceZonePerUnitLengthE)
    delete CylindricityCha_1065_TypeValue.ToleranceZonePerUnitLength;
  #endif
}

void CylindricityCha_1065_TypeChoicePair::printSelf(FILE * outFile)
{
  if (CylindricityCha_1065_TypeType == ToleranceZonePerUnitAngleE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceZonePerUnitAngle");
      CylindricityCha_1065_TypeValue.ToleranceZonePerUnitAngle->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ToleranceZonePerUnitAngle>\n");
    }
  else if (CylindricityCha_1065_TypeType == ToleranceZonePerUnitArcLengthE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceZonePerUnitArcLength");
      CylindricityCha_1065_TypeValue.ToleranceZonePerUnitArcLength->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ToleranceZonePerUnitArcLength>\n");
    }
  else if (CylindricityCha_1065_TypeType == ToleranceZonePerUnitPolarAreaE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceZonePerUnitPolarArea");
      CylindricityCha_1065_TypeValue.ToleranceZonePerUnitPolarArea->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ToleranceZonePerUnitPolarArea>\n");
    }
  else if (CylindricityCha_1065_TypeType == ToleranceZonePerUnitAreaE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceZonePerUnitArea");
      CylindricityCha_1065_TypeValue.ToleranceZonePerUnitArea->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ToleranceZonePerUnitArea>\n");
    }
  else if (CylindricityCha_1065_TypeType == ToleranceZonePerUnitLengthE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceZonePerUnitLength");
      CylindricityCha_1065_TypeValue.ToleranceZonePerUnitLength->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ToleranceZonePerUnitLength>\n");
    }
}

/* ***************************************************************** */

/* class FlatnessCharact_1066_Type

*/

FlatnessCharact_1066_Type::FlatnessCharact_1066_Type()
{
  ToleranceValue = 0;
  ToleranceDualValue = 0;
  ToleranceZonePerUnitArea = 0;
}

FlatnessCharact_1066_Type::FlatnessCharact_1066_Type(
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 ToleranceZonePerUnitAreaType * ToleranceZonePerUnitAreaIn)
{
  ToleranceValue = ToleranceValueIn;
  ToleranceDualValue = ToleranceDualValueIn;
  ToleranceZonePerUnitArea = ToleranceZonePerUnitAreaIn;
}

FlatnessCharact_1066_Type::~FlatnessCharact_1066_Type()
{
  #ifndef NODESTRUCT
  delete ToleranceValue;
  delete ToleranceDualValue;
  delete ToleranceZonePerUnitArea;
  #endif
}

void FlatnessCharact_1066_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<ToleranceValue");
  ToleranceValue->printSelf(outFile);
  fprintf(outFile, "</ToleranceValue>\n");
  if (ToleranceDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceDualValue");
      ToleranceDualValue->printSelf(outFile);
      fprintf(outFile, "</ToleranceDualValue>\n");
    }
  if (ToleranceZonePerUnitArea)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceZonePerUnitArea");
      ToleranceZonePerUnitArea->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ToleranceZonePerUnitArea>\n");
    }
}

LinearValueType * FlatnessCharact_1066_Type::getToleranceValue()
{return ToleranceValue;}

void FlatnessCharact_1066_Type::setToleranceValue(LinearValueType * ToleranceValueIn)
{ToleranceValue = ToleranceValueIn;}

LinearDualValueType * FlatnessCharact_1066_Type::getToleranceDualValue()
{return ToleranceDualValue;}

void FlatnessCharact_1066_Type::setToleranceDualValue(LinearDualValueType * ToleranceDualValueIn)
{ToleranceDualValue = ToleranceDualValueIn;}

ToleranceZonePerUnitAreaType * FlatnessCharact_1066_Type::getToleranceZonePerUnitArea()
{return ToleranceZonePerUnitArea;}

void FlatnessCharact_1066_Type::setToleranceZonePerUnitArea(ToleranceZonePerUnitAreaType * ToleranceZonePerUnitAreaIn)
{ToleranceZonePerUnitArea = ToleranceZonePerUnitAreaIn;}

/* ***************************************************************** */

/* class FlatnessCharact_1067_Type

*/

FlatnessCharact_1067_Type::FlatnessCharact_1067_Type()
{
  ToleranceZonePerUnitArea = 0;
}

FlatnessCharact_1067_Type::FlatnessCharact_1067_Type(
 ToleranceZonePerUnitAreaType * ToleranceZonePerUnitAreaIn)
{
  ToleranceZonePerUnitArea = ToleranceZonePerUnitAreaIn;
}

FlatnessCharact_1067_Type::~FlatnessCharact_1067_Type()
{
  #ifndef NODESTRUCT
  delete ToleranceZonePerUnitArea;
  #endif
}

void FlatnessCharact_1067_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<ToleranceZonePerUnitArea");
  ToleranceZonePerUnitArea->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ToleranceZonePerUnitArea>\n");
}

ToleranceZonePerUnitAreaType * FlatnessCharact_1067_Type::getToleranceZonePerUnitArea()
{return ToleranceZonePerUnitArea;}

void FlatnessCharact_1067_Type::setToleranceZonePerUnitArea(ToleranceZonePerUnitAreaType * ToleranceZonePerUnitAreaIn)
{ToleranceZonePerUnitArea = ToleranceZonePerUnitAreaIn;}

/* ***************************************************************** */

/* class StraightnessCha_1068_Type

*/

StraightnessCha_1068_Type::StraightnessCha_1068_Type()
{
  ToleranceValue = 0;
  ToleranceDualValue = 0;
  ToleranceZonePerUnitLength = 0;
}

StraightnessCha_1068_Type::StraightnessCha_1068_Type(
 LinearValueType * ToleranceValueIn,
 LinearDualValueType * ToleranceDualValueIn,
 ToleranceZonePerUnitLengthType * ToleranceZonePerUnitLengthIn)
{
  ToleranceValue = ToleranceValueIn;
  ToleranceDualValue = ToleranceDualValueIn;
  ToleranceZonePerUnitLength = ToleranceZonePerUnitLengthIn;
}

StraightnessCha_1068_Type::~StraightnessCha_1068_Type()
{
  #ifndef NODESTRUCT
  delete ToleranceValue;
  delete ToleranceDualValue;
  delete ToleranceZonePerUnitLength;
  #endif
}

void StraightnessCha_1068_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<ToleranceValue");
  ToleranceValue->printSelf(outFile);
  fprintf(outFile, "</ToleranceValue>\n");
  if (ToleranceDualValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceDualValue");
      ToleranceDualValue->printSelf(outFile);
      fprintf(outFile, "</ToleranceDualValue>\n");
    }
  if (ToleranceZonePerUnitLength)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToleranceZonePerUnitLength");
      ToleranceZonePerUnitLength->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ToleranceZonePerUnitLength>\n");
    }
}

LinearValueType * StraightnessCha_1068_Type::getToleranceValue()
{return ToleranceValue;}

void StraightnessCha_1068_Type::setToleranceValue(LinearValueType * ToleranceValueIn)
{ToleranceValue = ToleranceValueIn;}

LinearDualValueType * StraightnessCha_1068_Type::getToleranceDualValue()
{return ToleranceDualValue;}

void StraightnessCha_1068_Type::setToleranceDualValue(LinearDualValueType * ToleranceDualValueIn)
{ToleranceDualValue = ToleranceDualValueIn;}

ToleranceZonePerUnitLengthType * StraightnessCha_1068_Type::getToleranceZonePerUnitLength()
{return ToleranceZonePerUnitLength;}

void StraightnessCha_1068_Type::setToleranceZonePerUnitLength(ToleranceZonePerUnitLengthType * ToleranceZonePerUnitLengthIn)
{ToleranceZonePerUnitLength = ToleranceZonePerUnitLengthIn;}

/* ***************************************************************** */

/* class StraightnessCha_1069_Type

*/

StraightnessCha_1069_Type::StraightnessCha_1069_Type()
{
  ToleranceZonePerUnitLength = 0;
}

StraightnessCha_1069_Type::StraightnessCha_1069_Type(
 ToleranceZonePerUnitLengthType * ToleranceZonePerUnitLengthIn)
{
  ToleranceZonePerUnitLength = ToleranceZonePerUnitLengthIn;
}

StraightnessCha_1069_Type::~StraightnessCha_1069_Type()
{
  #ifndef NODESTRUCT
  delete ToleranceZonePerUnitLength;
  #endif
}

void StraightnessCha_1069_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<ToleranceZonePerUnitLength");
  ToleranceZonePerUnitLength->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ToleranceZonePerUnitLength>\n");
}

ToleranceZonePerUnitLengthType * StraightnessCha_1069_Type::getToleranceZonePerUnitLength()
{return ToleranceZonePerUnitLength;}

void StraightnessCha_1069_Type::setToleranceZonePerUnitLength(ToleranceZonePerUnitLengthType * ToleranceZonePerUnitLengthIn)
{ToleranceZonePerUnitLength = ToleranceZonePerUnitLengthIn;}

/* ***************************************************************** */

/* class UserDefinedUnit_1070_Type

*/

UserDefinedUnit_1070_Type::UserDefinedUnit_1070_Type()
{
  MaxValue = 0;
  MinValue = 0;
}

UserDefinedUnit_1070_Type::UserDefinedUnit_1070_Type(
 UserDefinedUnitValueType * MaxValueIn,
 UserDefinedUnitValueType * MinValueIn)
{
  MaxValue = MaxValueIn;
  MinValue = MinValueIn;
}

UserDefinedUnit_1070_Type::~UserDefinedUnit_1070_Type()
{
  #ifndef NODESTRUCT
  delete MaxValue;
  delete MinValue;
  #endif
}

void UserDefinedUnit_1070_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxValue");
  MaxValue->printSelf(outFile);
  fprintf(outFile, "</MaxValue>\n");
  if (MinValue)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValue");
      MinValue->printSelf(outFile);
      fprintf(outFile, "</MinValue>\n");
    }
}

UserDefinedUnitValueType * UserDefinedUnit_1070_Type::getMaxValue()
{return MaxValue;}

void UserDefinedUnit_1070_Type::setMaxValue(UserDefinedUnitValueType * MaxValueIn)
{MaxValue = MaxValueIn;}

UserDefinedUnitValueType * UserDefinedUnit_1070_Type::getMinValue()
{return MinValue;}

void UserDefinedUnit_1070_Type::setMinValue(UserDefinedUnitValueType * MinValueIn)
{MinValue = MinValueIn;}

/* ***************************************************************** */

