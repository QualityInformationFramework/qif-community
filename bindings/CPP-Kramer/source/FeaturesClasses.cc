/* ***************************************************************** */

#include <stdio.h>             // for printf, etc.
#include <string.h>            // for strdup
#include <stdlib.h>            // for exit
#include <list>
#include  <map>
#include <xmlSchemaInstance.hh>
#include "FeaturesClasses.hh"

#define INDENT 2
extern std::map<unsigned int, XmlSchemaInstanceBase *> idMap;

/* ***************************************************************** */
/* ***************************************************************** */

/* class BaseFeaturePointListType

*/

BaseFeaturePointListType::BaseFeaturePointListType()
{
  n = 0;
  BaseFeaturePointSet = 0;
}

BaseFeaturePointListType::BaseFeaturePointListType(
 BaseFeaturePointSetTypeLisd * BaseFeaturePointSetIn)
{
  n = 0;
  BaseFeaturePointSet = BaseFeaturePointSetIn;
}

BaseFeaturePointListType::BaseFeaturePointListType(
 NaturalType * nIn,
 BaseFeaturePointSetTypeLisd * BaseFeaturePointSetIn)
{
  n = nIn;
  BaseFeaturePointSet = BaseFeaturePointSetIn;
}

BaseFeaturePointListType::~BaseFeaturePointListType()
{
  #ifndef NODESTRUCT
  delete n;
  delete BaseFeaturePointSet;
  #endif
}

void BaseFeaturePointListType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!BaseFeaturePointSet)
      {
        fprintf(stderr, "BaseFeaturePointSet list is missing\n");
        exit(1);
      }
    if (BaseFeaturePointSet->size() == 0)
      {
        fprintf(stderr, "BaseFeaturePointSet list is empty\n");
        exit(1);
      }
    if (BaseFeaturePointSet->size() < 1)
      {
        fprintf(stderr,
                "size of BaseFeaturePointSet list (%d) less than minimum required (1)\n",
                (int)BaseFeaturePointSet->size());
        exit(1);
      }
    std::list<BaseFeaturePointSetType *>::iterator iter;
    for (iter = BaseFeaturePointSet->begin();
         iter != BaseFeaturePointSet->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<BaseFeaturePointSet");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</BaseFeaturePointSet>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool BaseFeaturePointListType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in BaseFeaturePointListType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in BaseFeaturePointListType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in BaseFeaturePointListType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in BaseFeaturePointListType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * BaseFeaturePointListType::getn()
{return n;}

void BaseFeaturePointListType::setn(NaturalType * nIn)
{n = nIn;}

BaseFeaturePointSetTypeLisd * BaseFeaturePointListType::getBaseFeaturePointSet()
{return BaseFeaturePointSet;}

void BaseFeaturePointListType::setBaseFeaturePointSet(BaseFeaturePointSetTypeLisd * BaseFeaturePointSetIn)
{BaseFeaturePointSet = BaseFeaturePointSetIn;}

/* ***************************************************************** */

/* class BaseFeaturePointSetType

*/

BaseFeaturePointSetType::BaseFeaturePointSetType()
{
  FeatureId = 0;
  PointIndex = 0;
  ReferencedComponent = 0;
  SequenceNumber = 0;
}

BaseFeaturePointSetType::BaseFeaturePointSetType(
 QIFReferenceType * FeatureIdIn,
 PointIndexType * PointIndexIn,
 ReferencedComponentEnumType * ReferencedComponentIn,
 NaturalType * SequenceNumberIn)
{
  FeatureId = FeatureIdIn;
  PointIndex = PointIndexIn;
  ReferencedComponent = ReferencedComponentIn;
  SequenceNumber = SequenceNumberIn;
}

BaseFeaturePointSetType::~BaseFeaturePointSetType()
{
  #ifndef NODESTRUCT
  delete FeatureId;
  delete PointIndex;
  delete ReferencedComponent;
  delete SequenceNumber;
  #endif
}

void BaseFeaturePointSetType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureId");
  FeatureId->printSelf(outFile);
  fprintf(outFile, "</FeatureId>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<PointIndex");
  PointIndex->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</PointIndex>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<ReferencedComponent");
  ReferencedComponent->printSelf(outFile);
  fprintf(outFile, "</ReferencedComponent>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<SequenceNumber");
  SequenceNumber->printSelf(outFile);
  fprintf(outFile, "</SequenceNumber>\n");
  doSpaces(-INDENT, outFile);
}

QIFReferenceType * BaseFeaturePointSetType::getFeatureId()
{return FeatureId;}

void BaseFeaturePointSetType::setFeatureId(QIFReferenceType * FeatureIdIn)
{FeatureId = FeatureIdIn;}

PointIndexType * BaseFeaturePointSetType::getPointIndex()
{return PointIndex;}

void BaseFeaturePointSetType::setPointIndex(PointIndexType * PointIndexIn)
{PointIndex = PointIndexIn;}

ReferencedComponentEnumType * BaseFeaturePointSetType::getReferencedComponent()
{return ReferencedComponent;}

void BaseFeaturePointSetType::setReferencedComponent(ReferencedComponentEnumType * ReferencedComponentIn)
{ReferencedComponent = ReferencedComponentIn;}

NaturalType * BaseFeaturePointSetType::getSequenceNumber()
{return SequenceNumber;}

void BaseFeaturePointSetType::setSequenceNumber(NaturalType * SequenceNumberIn)
{SequenceNumber = SequenceNumberIn;}

/* ***************************************************************** */

/* class BaseFeaturePointSetTypeLisd

*/

BaseFeaturePointSetTypeLisd::BaseFeaturePointSetTypeLisd() {}

BaseFeaturePointSetTypeLisd::BaseFeaturePointSetTypeLisd(BaseFeaturePointSetType * aBaseFeaturePointSetType)
{
  push_back(aBaseFeaturePointSetType);
}

BaseFeaturePointSetTypeLisd::~BaseFeaturePointSetTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<BaseFeaturePointSetType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void BaseFeaturePointSetTypeLisd::printSelf(FILE * outFile)
{
  std::list<BaseFeaturePointSetType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class CircleBestFitType

*/

CircleBestFitType::CircleBestFitType() :
  ConstructionMethodBaseType()
{
  n = 0;
  BaseFeature = 0;
}

CircleBestFitType::CircleBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = 0;
  BaseFeature = BaseFeatureIn;
}

CircleBestFitType::CircleBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 NaturalType * nIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = nIn;
  BaseFeature = BaseFeatureIn;
}

CircleBestFitType::~CircleBestFitType()
{
  #ifndef NODESTRUCT
  delete n;
  delete BaseFeature;
  #endif
}

void CircleBestFitType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  {
    if (!BaseFeature)
      {
        fprintf(stderr, "BaseFeature list is missing\n");
        exit(1);
      }
    if (BaseFeature->size() == 0)
      {
        fprintf(stderr, "BaseFeature list is empty\n");
        exit(1);
      }
    if (BaseFeature->size() < 3)
      {
        fprintf(stderr,
                "size of BaseFeature list (%d) less than minimum required (3)\n",
                (int)BaseFeature->size());
        exit(1);
      }
    std::list<SequencedBaseFeatureType *>::iterator iter;
    for (iter = BaseFeature->begin();
         iter != BaseFeature->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<BaseFeature");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</BaseFeature>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool CircleBestFitType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in CircleBestFitType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in CircleBestFitType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CircleBestFitType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in CircleBestFitType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * CircleBestFitType::getn()
{return n;}

void CircleBestFitType::setn(NaturalType * nIn)
{n = nIn;}

SequencedBaseFeatureTypeLisd * CircleBestFitType::getBaseFeature()
{return BaseFeature;}

void CircleBestFitType::setBaseFeature(SequencedBaseFeatureTypeLisd * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class CircleCastType

*/

CircleCastType::CircleCastType() :
  ConstructionMethodBaseType()
{
  BaseFeature = 0;
}

CircleCastType::CircleCastType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeature = BaseFeatureIn;
}

CircleCastType::~CircleCastType()
{
  #ifndef NODESTRUCT
  delete BaseFeature;
  #endif
}

void CircleCastType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeature");
  BaseFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * CircleCastType::getBaseFeature()
{return BaseFeature;}

void CircleCastType::setBaseFeature(BaseFeatureType * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class CircleCheckedFeatureType

*/

CircleCheckedFeatureType::CircleCheckedFeatureType()
{
  CheckDetails = 0;
}

CircleCheckedFeatureType::CircleCheckedFeatureType(
 CircleCheckedType * CheckDetailsIn)
{
  CheckDetails = CheckDetailsIn;
}

CircleCheckedFeatureType::~CircleCheckedFeatureType()
{
  #ifndef NODESTRUCT
  delete CheckDetails;
  #endif
}

void CircleCheckedFeatureType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (CheckDetails)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CheckDetails");
      CheckDetails->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CheckDetails>\n");
    }
  doSpaces(-INDENT, outFile);
}

CircleCheckedType * CircleCheckedFeatureType::getCheckDetails()
{return CheckDetails;}

void CircleCheckedFeatureType::setCheckDetails(CircleCheckedType * CheckDetailsIn)
{CheckDetails = CheckDetailsIn;}

/* ***************************************************************** */

/* class CircleCheckedType

*/

CircleCheckedType::CircleCheckedType()
{
  CircleCheckedTypePair = 0;
}

CircleCheckedType::CircleCheckedType(
 CircleCheckedTypeChoicePair * CircleCheckedTypePairIn)
{
  CircleCheckedTypePair = CircleCheckedTypePairIn;
}

CircleCheckedType::~CircleCheckedType()
{
  #ifndef NODESTRUCT
  delete CircleCheckedTypePair;
  #endif
}

void CircleCheckedType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  CircleCheckedTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

CircleCheckedTypeChoicePair * CircleCheckedType::getCircleCheckedTypePair()
{return CircleCheckedTypePair;}

void CircleCheckedType::setCircleCheckedTypePair(CircleCheckedTypeChoicePair * CircleCheckedTypePairIn)
{CircleCheckedTypePair = CircleCheckedTypePairIn;}
CircleCheckedTypeChoicePair::CircleCheckedTypeChoicePair() {}

CircleCheckedTypeChoicePair::CircleCheckedTypeChoicePair(
 whichOne CircleCheckedTypeTypeIn,
 CircleCheckedTypeVal * CircleCheckedTypeValueIn)
{
  CircleCheckedTypeType = CircleCheckedTypeTypeIn;
  CircleCheckedTypeValue = CircleCheckedTypeValueIn;
}

CircleCheckedTypeChoicePair::~CircleCheckedTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (CircleCheckedTypeType == MeasuredE)
    delete CircleCheckedTypeValue->Measured;
  else if (CircleCheckedTypeType == ConstructedE)
    delete CircleCheckedTypeValue->Constructed;
  delete CircleCheckedTypeValue;
  #endif
}

void CircleCheckedTypeChoicePair::printSelf(FILE * outFile)
{
  if (CircleCheckedTypeType == MeasuredE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Measured");
      CircleCheckedTypeValue->Measured->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Measured>\n");
    }
  else if (CircleCheckedTypeType == ConstructedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      CircleCheckedTypeValue->Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
}

/* ***************************************************************** */

/* class CircleConstructionMethodType

*/

CircleConstructionMethodType::CircleConstructionMethodType()
{
  CircleConstructionMethodTypePair = 0;
}

CircleConstructionMethodType::CircleConstructionMethodType(
 CircleConstructionMethodTypeChoicePair * CircleConstructionMethodTypePairIn)
{
  CircleConstructionMethodTypePair = CircleConstructionMethodTypePairIn;
}

CircleConstructionMethodType::~CircleConstructionMethodType()
{
  #ifndef NODESTRUCT
  delete CircleConstructionMethodTypePair;
  #endif
}

void CircleConstructionMethodType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (CircleConstructionMethodTypePair)
    {
      CircleConstructionMethodTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

CircleConstructionMethodTypeChoicePair * CircleConstructionMethodType::getCircleConstructionMethodTypePair()
{return CircleConstructionMethodTypePair;}

void CircleConstructionMethodType::setCircleConstructionMethodTypePair(CircleConstructionMethodTypeChoicePair * CircleConstructionMethodTypePairIn)
{CircleConstructionMethodTypePair = CircleConstructionMethodTypePairIn;}
CircleConstructionMethodTypeChoicePair::CircleConstructionMethodTypeChoicePair() {}

CircleConstructionMethodTypeChoicePair::CircleConstructionMethodTypeChoicePair(
 whichOne CircleConstructionMethodTypeTypeIn,
 CircleConstructionMethodTypeVal * CircleConstructionMethodTypeValueIn)
{
  CircleConstructionMethodTypeType = CircleConstructionMethodTypeTypeIn;
  CircleConstructionMethodTypeValue = CircleConstructionMethodTypeValueIn;
}

CircleConstructionMethodTypeChoicePair::~CircleConstructionMethodTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (CircleConstructionMethodTypeType == BestFitE)
    delete CircleConstructionMethodTypeValue->BestFit;
  else if (CircleConstructionMethodTypeType == RecompensatedE)
    delete CircleConstructionMethodTypeValue->Recompensated;
  else if (CircleConstructionMethodTypeType == IntersectionE)
    delete CircleConstructionMethodTypeValue->Intersection;
  else if (CircleConstructionMethodTypeType == ProjectionE)
    delete CircleConstructionMethodTypeValue->Projection;
  else if (CircleConstructionMethodTypeType == CopyE)
    delete CircleConstructionMethodTypeValue->Copy;
  else if (CircleConstructionMethodTypeType == CastE)
    delete CircleConstructionMethodTypeValue->Cast;
  else if (CircleConstructionMethodTypeType == TangentE)
    delete CircleConstructionMethodTypeValue->Tangent;
  else if (CircleConstructionMethodTypeType == TangentThroughE)
    delete CircleConstructionMethodTypeValue->TangentThrough;
  else if (CircleConstructionMethodTypeType == TransformE)
    delete CircleConstructionMethodTypeValue->Transform;
  else if (CircleConstructionMethodTypeType == FromConeE)
    delete CircleConstructionMethodTypeValue->FromCone;
  else if (CircleConstructionMethodTypeType == FromScanE)
    delete CircleConstructionMethodTypeValue->FromScan;
  delete CircleConstructionMethodTypeValue;
  #endif
}

void CircleConstructionMethodTypeChoicePair::printSelf(FILE * outFile)
{
  if (CircleConstructionMethodTypeType == BestFitE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BestFit");
      CircleConstructionMethodTypeValue->BestFit->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BestFit>\n");
    }
  else if (CircleConstructionMethodTypeType == RecompensatedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Recompensated");
      CircleConstructionMethodTypeValue->Recompensated->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Recompensated>\n");
    }
  else if (CircleConstructionMethodTypeType == IntersectionE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Intersection");
      CircleConstructionMethodTypeValue->Intersection->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Intersection>\n");
    }
  else if (CircleConstructionMethodTypeType == ProjectionE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Projection");
      CircleConstructionMethodTypeValue->Projection->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Projection>\n");
    }
  else if (CircleConstructionMethodTypeType == CopyE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Copy");
      CircleConstructionMethodTypeValue->Copy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Copy>\n");
    }
  else if (CircleConstructionMethodTypeType == CastE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Cast");
      CircleConstructionMethodTypeValue->Cast->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Cast>\n");
    }
  else if (CircleConstructionMethodTypeType == TangentE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Tangent");
      CircleConstructionMethodTypeValue->Tangent->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Tangent>\n");
    }
  else if (CircleConstructionMethodTypeType == TangentThroughE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TangentThrough");
      CircleConstructionMethodTypeValue->TangentThrough->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</TangentThrough>\n");
    }
  else if (CircleConstructionMethodTypeType == TransformE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Transform");
      CircleConstructionMethodTypeValue->Transform->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Transform>\n");
    }
  else if (CircleConstructionMethodTypeType == FromConeE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FromCone");
      CircleConstructionMethodTypeValue->FromCone->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FromCone>\n");
    }
  else if (CircleConstructionMethodTypeType == FromScanE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FromScan");
      CircleConstructionMethodTypeValue->FromScan->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FromScan>\n");
    }
}

/* ***************************************************************** */

/* class CircleCopyType

*/

CircleCopyType::CircleCopyType() :
  ConstructionMethodBaseType()
{
  BaseCircle = 0;
}

CircleCopyType::CircleCopyType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseCircleIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseCircle = BaseCircleIn;
}

CircleCopyType::~CircleCopyType()
{
  #ifndef NODESTRUCT
  delete BaseCircle;
  #endif
}

void CircleCopyType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseCircle");
  BaseCircle->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseCircle>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * CircleCopyType::getBaseCircle()
{return BaseCircle;}

void CircleCopyType::setBaseCircle(BaseFeatureType * BaseCircleIn)
{BaseCircle = BaseCircleIn;}

/* ***************************************************************** */

/* class CircleFeatureDefinitionType

*/

CircleFeatureDefinitionType::CircleFeatureDefinitionType() :
  CurveFeatureDefinitionBaseType()
{
  InternalExternal = 0;
  Diameter = 0;
}

CircleFeatureDefinitionType::CircleFeatureDefinitionType(
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * DiameterIn) :
  CurveFeatureDefinitionBaseType(
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  Diameter = DiameterIn;
}

CircleFeatureDefinitionType::CircleFeatureDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * DiameterIn) :
  CurveFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  Diameter = DiameterIn;
}

CircleFeatureDefinitionType::~CircleFeatureDefinitionType()
{
  #ifndef NODESTRUCT
  delete InternalExternal;
  delete Diameter;
  #endif
}

void CircleFeatureDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<InternalExternal");
  InternalExternal->printSelf(outFile);
  fprintf(outFile, "</InternalExternal>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Diameter");
  Diameter->printSelf(outFile);
  fprintf(outFile, "</Diameter>\n");
  doSpaces(-INDENT, outFile);
}

bool CircleFeatureDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CircleFeatureDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CircleFeatureDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CircleFeatureDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CircleFeatureDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

InternalExternalEnumType * CircleFeatureDefinitionType::getInternalExternal()
{return InternalExternal;}

void CircleFeatureDefinitionType::setInternalExternal(InternalExternalEnumType * InternalExternalIn)
{InternalExternal = InternalExternalIn;}

LinearValueType * CircleFeatureDefinitionType::getDiameter()
{return Diameter;}

void CircleFeatureDefinitionType::setDiameter(LinearValueType * DiameterIn)
{Diameter = DiameterIn;}

/* ***************************************************************** */

/* class CircleFeatureItemType

*/

CircleFeatureItemType::CircleFeatureItemType() :
  CurveFeatureItemBaseType()
{
  DeterminationMode = 0;
}

CircleFeatureItemType::CircleFeatureItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 CircleMeasurementDeterminationType * DeterminationModeIn) :
  CurveFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

CircleFeatureItemType::CircleFeatureItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 CircleMeasurementDeterminationType * DeterminationModeIn) :
  CurveFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

CircleFeatureItemType::~CircleFeatureItemType()
{
  #ifndef NODESTRUCT
  delete DeterminationMode;
  #endif
}

void CircleFeatureItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<DeterminationMode");
  DeterminationMode->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeterminationMode>\n");
  doSpaces(-INDENT, outFile);
}

bool CircleFeatureItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CircleFeatureItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CircleFeatureItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CircleFeatureItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CircleFeatureItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

CircleMeasurementDeterminationType * CircleFeatureItemType::getDeterminationMode()
{return DeterminationMode;}

void CircleFeatureItemType::setDeterminationMode(CircleMeasurementDeterminationType * DeterminationModeIn)
{DeterminationMode = DeterminationModeIn;}

/* ***************************************************************** */

/* class CircleFeatureMeasurementType

*/

CircleFeatureMeasurementType::CircleFeatureMeasurementType() :
  CurveFeatureMeasurementBaseType()
{
  Location = 0;
  Normal = 0;
  Diameter = 0;
  DiameterMin = 0;
  DiameterMax = 0;
  Form = 0;
  SweepMeasurementRange = 0;
  SweepFull = 0;
}

CircleFeatureMeasurementType::CircleFeatureMeasurementType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredPointType * LocationIn,
 MeasuredUnitVectorType * NormalIn,
 MeasuredLinearValueType * DiameterIn,
 MeasuredLinearValueType * DiameterMinIn,
 MeasuredLinearValueType * DiameterMaxIn,
 MeasuredLinearValueType * FormIn,
 SweepType * SweepMeasurementRangeIn,
 SweepType * SweepFullIn) :
  CurveFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Location = LocationIn;
  Normal = NormalIn;
  Diameter = DiameterIn;
  DiameterMin = DiameterMinIn;
  DiameterMax = DiameterMaxIn;
  Form = FormIn;
  SweepMeasurementRange = SweepMeasurementRangeIn;
  SweepFull = SweepFullIn;
}

CircleFeatureMeasurementType::CircleFeatureMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredPointType * LocationIn,
 MeasuredUnitVectorType * NormalIn,
 MeasuredLinearValueType * DiameterIn,
 MeasuredLinearValueType * DiameterMinIn,
 MeasuredLinearValueType * DiameterMaxIn,
 MeasuredLinearValueType * FormIn,
 SweepType * SweepMeasurementRangeIn,
 SweepType * SweepFullIn) :
  CurveFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Location = LocationIn;
  Normal = NormalIn;
  Diameter = DiameterIn;
  DiameterMin = DiameterMinIn;
  DiameterMax = DiameterMaxIn;
  Form = FormIn;
  SweepMeasurementRange = SweepMeasurementRangeIn;
  SweepFull = SweepFullIn;
}

CircleFeatureMeasurementType::~CircleFeatureMeasurementType()
{
  #ifndef NODESTRUCT
  delete Location;
  delete Normal;
  delete Diameter;
  delete DiameterMin;
  delete DiameterMax;
  delete Form;
  delete SweepMeasurementRange;
  delete SweepFull;
  #endif
}

void CircleFeatureMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  if (Location)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Location");
      Location->printSelf(outFile);
      fprintf(outFile, "</Location>\n");
    }
  if (Normal)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Normal");
      Normal->printSelf(outFile);
      fprintf(outFile, "</Normal>\n");
    }
  if (Diameter)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Diameter");
      Diameter->printSelf(outFile);
      fprintf(outFile, "</Diameter>\n");
    }
  if (DiameterMin)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DiameterMin");
      DiameterMin->printSelf(outFile);
      fprintf(outFile, "</DiameterMin>\n");
    }
  if (DiameterMax)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DiameterMax");
      DiameterMax->printSelf(outFile);
      fprintf(outFile, "</DiameterMax>\n");
    }
  if (Form)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Form");
      Form->printSelf(outFile);
      fprintf(outFile, "</Form>\n");
    }
  if (SweepMeasurementRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SweepMeasurementRange");
      SweepMeasurementRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SweepMeasurementRange>\n");
    }
  if (SweepFull)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SweepFull");
      SweepFull->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SweepFull>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CircleFeatureMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CircleFeatureMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CircleFeatureMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CircleFeatureMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CircleFeatureMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredPointType * CircleFeatureMeasurementType::getLocation()
{return Location;}

void CircleFeatureMeasurementType::setLocation(MeasuredPointType * LocationIn)
{Location = LocationIn;}

MeasuredUnitVectorType * CircleFeatureMeasurementType::getNormal()
{return Normal;}

void CircleFeatureMeasurementType::setNormal(MeasuredUnitVectorType * NormalIn)
{Normal = NormalIn;}

MeasuredLinearValueType * CircleFeatureMeasurementType::getDiameter()
{return Diameter;}

void CircleFeatureMeasurementType::setDiameter(MeasuredLinearValueType * DiameterIn)
{Diameter = DiameterIn;}

MeasuredLinearValueType * CircleFeatureMeasurementType::getDiameterMin()
{return DiameterMin;}

void CircleFeatureMeasurementType::setDiameterMin(MeasuredLinearValueType * DiameterMinIn)
{DiameterMin = DiameterMinIn;}

MeasuredLinearValueType * CircleFeatureMeasurementType::getDiameterMax()
{return DiameterMax;}

void CircleFeatureMeasurementType::setDiameterMax(MeasuredLinearValueType * DiameterMaxIn)
{DiameterMax = DiameterMaxIn;}

MeasuredLinearValueType * CircleFeatureMeasurementType::getForm()
{return Form;}

void CircleFeatureMeasurementType::setForm(MeasuredLinearValueType * FormIn)
{Form = FormIn;}

SweepType * CircleFeatureMeasurementType::getSweepMeasurementRange()
{return SweepMeasurementRange;}

void CircleFeatureMeasurementType::setSweepMeasurementRange(SweepType * SweepMeasurementRangeIn)
{SweepMeasurementRange = SweepMeasurementRangeIn;}

SweepType * CircleFeatureMeasurementType::getSweepFull()
{return SweepFull;}

void CircleFeatureMeasurementType::setSweepFull(SweepType * SweepFullIn)
{SweepFull = SweepFullIn;}

/* ***************************************************************** */

/* class CircleFeatureNominalType

*/

CircleFeatureNominalType::CircleFeatureNominalType() :
  CurveFeatureNominalBaseType()
{
  Location = 0;
  Normal = 0;
  Sweep = 0;
  Constructed = 0;
}

CircleFeatureNominalType::CircleFeatureNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 PointType * LocationIn,
 UnitVectorType * NormalIn,
 SweepType * SweepIn,
 CircleConstructionMethodType * ConstructedIn) :
  CurveFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    SurfaceFeatureNominalIdIn)
{
  Location = LocationIn;
  Normal = NormalIn;
  Sweep = SweepIn;
  Constructed = ConstructedIn;
}

CircleFeatureNominalType::CircleFeatureNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 PointType * LocationIn,
 UnitVectorType * NormalIn,
 SweepType * SweepIn,
 CircleConstructionMethodType * ConstructedIn) :
  CurveFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    SurfaceFeatureNominalIdIn)
{
  Location = LocationIn;
  Normal = NormalIn;
  Sweep = SweepIn;
  Constructed = ConstructedIn;
}

CircleFeatureNominalType::~CircleFeatureNominalType()
{
  #ifndef NODESTRUCT
  delete Location;
  delete Normal;
  delete Sweep;
  delete Constructed;
  #endif
}

void CircleFeatureNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (SurfaceFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SurfaceFeatureNominalId");
      SurfaceFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</SurfaceFeatureNominalId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Location");
  Location->printSelf(outFile);
  fprintf(outFile, "</Location>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Normal");
  Normal->printSelf(outFile);
  fprintf(outFile, "</Normal>\n");
  if (Sweep)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Sweep");
      Sweep->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Sweep>\n");
    }
  if (Constructed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CircleFeatureNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CircleFeatureNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CircleFeatureNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CircleFeatureNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CircleFeatureNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

PointType * CircleFeatureNominalType::getLocation()
{return Location;}

void CircleFeatureNominalType::setLocation(PointType * LocationIn)
{Location = LocationIn;}

UnitVectorType * CircleFeatureNominalType::getNormal()
{return Normal;}

void CircleFeatureNominalType::setNormal(UnitVectorType * NormalIn)
{Normal = NormalIn;}

SweepType * CircleFeatureNominalType::getSweep()
{return Sweep;}

void CircleFeatureNominalType::setSweep(SweepType * SweepIn)
{Sweep = SweepIn;}

CircleConstructionMethodType * CircleFeatureNominalType::getConstructed()
{return Constructed;}

void CircleFeatureNominalType::setConstructed(CircleConstructionMethodType * ConstructedIn)
{Constructed = ConstructedIn;}

/* ***************************************************************** */

/* class CircleFromConeType

*/

CircleFromConeType::CircleFromConeType() :
  ConstructionMethodBaseType()
{
  CircleFromConeTypePair = 0;
}

CircleFromConeType::CircleFromConeType(
 XmlBoolean * NominalsCalculatedIn,
 CircleFromConeTypeChoicePair * CircleFromConeTypePairIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  CircleFromConeTypePair = CircleFromConeTypePairIn;
}

CircleFromConeType::~CircleFromConeType()
{
  #ifndef NODESTRUCT
  delete CircleFromConeTypePair;
  #endif
}

void CircleFromConeType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  CircleFromConeTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}
CircleFromConeTypeChoicePair * CircleFromConeType::getCircleFromConeTypeChoicePair()
{return CircleFromConeTypePair;}

void CircleFromConeType::setCircleFromConeTypeChoicePair(CircleFromConeTypeChoicePair * CircleFromConeTypePairIn)
{CircleFromConeTypePair = CircleFromConeTypePairIn;}

/* ***************************************************************** */

CircleFromConeTypeChoicePair::CircleFromConeTypeChoicePair() {}

CircleFromConeTypeChoicePair::CircleFromConeTypeChoicePair(
 whichOne CircleFromConeTypeTypeIn,
 CircleFromConeTypeVal * CircleFromConeTypeValueIn)
{
  CircleFromConeTypeType = CircleFromConeTypeTypeIn;
  CircleFromConeTypeValue = CircleFromConeTypeValueIn;
}

CircleFromConeTypeChoicePair::~CircleFromConeTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (CircleFromConeTypeType == DiameterE)
    delete CircleFromConeTypeValue->Diameter;
  else if (CircleFromConeTypeType == DistanceE)
    delete CircleFromConeTypeValue->Distance;
  delete CircleFromConeTypeValue;
  #endif
}

void CircleFromConeTypeChoicePair::printSelf(FILE * outFile)
{
  if (CircleFromConeTypeType == DiameterE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Diameter");
      CircleFromConeTypeValue->Diameter->printSelf(outFile);
      fprintf(outFile, "</Diameter>\n");
    }
  else if (CircleFromConeTypeType == DistanceE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Distance");
      CircleFromConeTypeValue->Distance->printSelf(outFile);
      fprintf(outFile, "</Distance>\n");
    }
}

/* ***************************************************************** */

/* class CircleFromScanType

*/

CircleFromScanType::CircleFromScanType() :
  ConstructionMethodBaseType()
{
  SurfaceFeature = 0;
  SearchRadius = 0;
  Depth = 0;
}

CircleFromScanType::CircleFromScanType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * SurfaceFeatureIn,
 LinearValueType * SearchRadiusIn,
 LinearValueType * DepthIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  SurfaceFeature = SurfaceFeatureIn;
  SearchRadius = SearchRadiusIn;
  Depth = DepthIn;
}

CircleFromScanType::~CircleFromScanType()
{
  #ifndef NODESTRUCT
  delete SurfaceFeature;
  delete SearchRadius;
  delete Depth;
  #endif
}

void CircleFromScanType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<SurfaceFeature");
  SurfaceFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</SurfaceFeature>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<SearchRadius");
  SearchRadius->printSelf(outFile);
  fprintf(outFile, "</SearchRadius>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Depth");
  Depth->printSelf(outFile);
  fprintf(outFile, "</Depth>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * CircleFromScanType::getSurfaceFeature()
{return SurfaceFeature;}

void CircleFromScanType::setSurfaceFeature(BaseFeatureType * SurfaceFeatureIn)
{SurfaceFeature = SurfaceFeatureIn;}

LinearValueType * CircleFromScanType::getSearchRadius()
{return SearchRadius;}

void CircleFromScanType::setSearchRadius(LinearValueType * SearchRadiusIn)
{SearchRadius = SearchRadiusIn;}

LinearValueType * CircleFromScanType::getDepth()
{return Depth;}

void CircleFromScanType::setDepth(LinearValueType * DepthIn)
{Depth = DepthIn;}

/* ***************************************************************** */

/* class CircleIntersectionType

*/

CircleIntersectionType::CircleIntersectionType() :
  ConstructionMethodBaseType()
{
  IntersectionFeature = 0;
}

CircleIntersectionType::CircleIntersectionType(
 XmlBoolean * NominalsCalculatedIn,
 SequencedBaseFeatureTypeLisd * IntersectionFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  IntersectionFeature = IntersectionFeatureIn;
}

CircleIntersectionType::~CircleIntersectionType()
{
  #ifndef NODESTRUCT
  delete IntersectionFeature;
  #endif
}

void CircleIntersectionType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  {
    if (!IntersectionFeature)
      {
        fprintf(stderr, "IntersectionFeature list is missing\n");
        exit(1);
      }
    if (IntersectionFeature->size() == 0)
      {
        fprintf(stderr, "IntersectionFeature list is empty\n");
        exit(1);
      }
    if (IntersectionFeature->size() > 2)
      {
        fprintf(stderr,
                "size of IntersectionFeature list (%d) greater than maximum allowed (2)\n",
                (int)IntersectionFeature->size());
        exit(1);
      }
    if (IntersectionFeature->size() < 2)
      {
        fprintf(stderr,
                "size of IntersectionFeature list (%d) less than minimum required (2)\n",
                (int)IntersectionFeature->size());
        exit(1);
      }
    std::list<SequencedBaseFeatureType *>::iterator iter;
    for (iter = IntersectionFeature->begin();
         iter != IntersectionFeature->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<IntersectionFeature");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</IntersectionFeature>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

SequencedBaseFeatureTypeLisd * CircleIntersectionType::getIntersectionFeature()
{return IntersectionFeature;}

void CircleIntersectionType::setIntersectionFeature(SequencedBaseFeatureTypeLisd * IntersectionFeatureIn)
{IntersectionFeature = IntersectionFeatureIn;}

/* ***************************************************************** */

/* class CircleMeasurementDeterminationType

*/

CircleMeasurementDeterminationType::CircleMeasurementDeterminationType()
{
  CircleMeasurementDeterminationTypePair = 0;
}

CircleMeasurementDeterminationType::CircleMeasurementDeterminationType(
 CircleMeasurementDeterminationTypeChoicePair * CircleMeasurementDeterminationTypePairIn)
{
  CircleMeasurementDeterminationTypePair = CircleMeasurementDeterminationTypePairIn;
}

CircleMeasurementDeterminationType::~CircleMeasurementDeterminationType()
{
  #ifndef NODESTRUCT
  delete CircleMeasurementDeterminationTypePair;
  #endif
}

void CircleMeasurementDeterminationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  CircleMeasurementDeterminationTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

CircleMeasurementDeterminationTypeChoicePair * CircleMeasurementDeterminationType::getCircleMeasurementDeterminationTypePair()
{return CircleMeasurementDeterminationTypePair;}

void CircleMeasurementDeterminationType::setCircleMeasurementDeterminationTypePair(CircleMeasurementDeterminationTypeChoicePair * CircleMeasurementDeterminationTypePairIn)
{CircleMeasurementDeterminationTypePair = CircleMeasurementDeterminationTypePairIn;}
CircleMeasurementDeterminationTypeChoicePair::CircleMeasurementDeterminationTypeChoicePair() {}

CircleMeasurementDeterminationTypeChoicePair::CircleMeasurementDeterminationTypeChoicePair(
 whichOne CircleMeasurementDeterminationTypeTypeIn,
 CircleMeasurementDeterminationTypeVal * CircleMeasurementDeterminationTypeValueIn)
{
  CircleMeasurementDeterminationTypeType = CircleMeasurementDeterminationTypeTypeIn;
  CircleMeasurementDeterminationTypeValue = CircleMeasurementDeterminationTypeValueIn;
}

CircleMeasurementDeterminationTypeChoicePair::~CircleMeasurementDeterminationTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (CircleMeasurementDeterminationTypeType == CheckedE)
    delete CircleMeasurementDeterminationTypeValue->Checked;
  else if (CircleMeasurementDeterminationTypeType == SetE)
    delete CircleMeasurementDeterminationTypeValue->Set;
  delete CircleMeasurementDeterminationTypeValue;
  #endif
}

void CircleMeasurementDeterminationTypeChoicePair::printSelf(FILE * outFile)
{
  if (CircleMeasurementDeterminationTypeType == CheckedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Checked");
      CircleMeasurementDeterminationTypeValue->Checked->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Checked>\n");
    }
  else if (CircleMeasurementDeterminationTypeType == SetE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Set");
      CircleMeasurementDeterminationTypeValue->Set->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class CircleProjectionType

*/

CircleProjectionType::CircleProjectionType() :
  ConstructionMethodBaseType()
{
  ProjectionCircle = 0;
  ProjectionPlane = 0;
}

CircleProjectionType::CircleProjectionType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * ProjectionCircleIn,
 BaseFeatureType * ProjectionPlaneIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  ProjectionCircle = ProjectionCircleIn;
  ProjectionPlane = ProjectionPlaneIn;
}

CircleProjectionType::~CircleProjectionType()
{
  #ifndef NODESTRUCT
  delete ProjectionCircle;
  delete ProjectionPlane;
  #endif
}

void CircleProjectionType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ProjectionCircle");
  ProjectionCircle->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ProjectionCircle>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<ProjectionPlane");
  ProjectionPlane->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ProjectionPlane>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * CircleProjectionType::getProjectionCircle()
{return ProjectionCircle;}

void CircleProjectionType::setProjectionCircle(BaseFeatureType * ProjectionCircleIn)
{ProjectionCircle = ProjectionCircleIn;}

BaseFeatureType * CircleProjectionType::getProjectionPlane()
{return ProjectionPlane;}

void CircleProjectionType::setProjectionPlane(BaseFeatureType * ProjectionPlaneIn)
{ProjectionPlane = ProjectionPlaneIn;}

/* ***************************************************************** */

/* class CircleRecompType

*/

CircleRecompType::CircleRecompType() :
  ConstructionMethodBaseType()
{
  BaseFeaturePointList = 0;
}

CircleRecompType::CircleRecompType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeaturePointListType * BaseFeaturePointListIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeaturePointList = BaseFeaturePointListIn;
}

CircleRecompType::~CircleRecompType()
{
  #ifndef NODESTRUCT
  delete BaseFeaturePointList;
  #endif
}

void CircleRecompType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeaturePointList");
  BaseFeaturePointList->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeaturePointList>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeaturePointListType * CircleRecompType::getBaseFeaturePointList()
{return BaseFeaturePointList;}

void CircleRecompType::setBaseFeaturePointList(BaseFeaturePointListType * BaseFeaturePointListIn)
{BaseFeaturePointList = BaseFeaturePointListIn;}

/* ***************************************************************** */

/* class CircleTangentThroughType

*/

CircleTangentThroughType::CircleTangentThroughType() :
  ConstructionMethodBaseType()
{
  TangentFeature = 0;
  PointFeature = 0;
}

CircleTangentThroughType::CircleTangentThroughType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * TangentFeatureIn,
 BaseFeatureType * PointFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  TangentFeature = TangentFeatureIn;
  PointFeature = PointFeatureIn;
}

CircleTangentThroughType::~CircleTangentThroughType()
{
  #ifndef NODESTRUCT
  delete TangentFeature;
  delete PointFeature;
  #endif
}

void CircleTangentThroughType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<TangentFeature");
  TangentFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</TangentFeature>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<PointFeature");
  PointFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</PointFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * CircleTangentThroughType::getTangentFeature()
{return TangentFeature;}

void CircleTangentThroughType::setTangentFeature(BaseFeatureType * TangentFeatureIn)
{TangentFeature = TangentFeatureIn;}

BaseFeatureType * CircleTangentThroughType::getPointFeature()
{return PointFeature;}

void CircleTangentThroughType::setPointFeature(BaseFeatureType * PointFeatureIn)
{PointFeature = PointFeatureIn;}

/* ***************************************************************** */

/* class CircleTangentType

*/

CircleTangentType::CircleTangentType() :
  ConstructionMethodBaseType()
{
  TangentFeature = 0;
}

CircleTangentType::CircleTangentType(
 XmlBoolean * NominalsCalculatedIn,
 SequencedBaseFeatureTypeLisd * TangentFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  TangentFeature = TangentFeatureIn;
}

CircleTangentType::~CircleTangentType()
{
  #ifndef NODESTRUCT
  delete TangentFeature;
  #endif
}

void CircleTangentType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  {
    if (!TangentFeature)
      {
        fprintf(stderr, "TangentFeature list is missing\n");
        exit(1);
      }
    if (TangentFeature->size() == 0)
      {
        fprintf(stderr, "TangentFeature list is empty\n");
        exit(1);
      }
    if (TangentFeature->size() > 2)
      {
        fprintf(stderr,
                "size of TangentFeature list (%d) greater than maximum allowed (2)\n",
                (int)TangentFeature->size());
        exit(1);
      }
    if (TangentFeature->size() < 2)
      {
        fprintf(stderr,
                "size of TangentFeature list (%d) less than minimum required (2)\n",
                (int)TangentFeature->size());
        exit(1);
      }
    std::list<SequencedBaseFeatureType *>::iterator iter;
    for (iter = TangentFeature->begin();
         iter != TangentFeature->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<TangentFeature");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</TangentFeature>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

SequencedBaseFeatureTypeLisd * CircleTangentType::getTangentFeature()
{return TangentFeature;}

void CircleTangentType::setTangentFeature(SequencedBaseFeatureTypeLisd * TangentFeatureIn)
{TangentFeature = TangentFeatureIn;}

/* ***************************************************************** */

/* class CircleTransformType

*/

CircleTransformType::CircleTransformType() :
  ConstructionMethodBaseType()
{
  BaseCircle = 0;
  Transformation = 0;
}

CircleTransformType::CircleTransformType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseCircleIn,
 TransformationReferenceType * TransformationIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseCircle = BaseCircleIn;
  Transformation = TransformationIn;
}

CircleTransformType::~CircleTransformType()
{
  #ifndef NODESTRUCT
  delete BaseCircle;
  delete Transformation;
  #endif
}

void CircleTransformType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseCircle");
  BaseCircle->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseCircle>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Transformation");
  Transformation->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Transformation>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * CircleTransformType::getBaseCircle()
{return BaseCircle;}

void CircleTransformType::setBaseCircle(BaseFeatureType * BaseCircleIn)
{BaseCircle = BaseCircleIn;}

TransformationReferenceType * CircleTransformType::getTransformation()
{return Transformation;}

void CircleTransformType::setTransformation(TransformationReferenceType * TransformationIn)
{Transformation = TransformationIn;}

/* ***************************************************************** */

/* class CircularArcBestFitType

*/

CircularArcBestFitType::CircularArcBestFitType() :
  ConstructionMethodBaseType()
{
  n = 0;
  BaseFeature = 0;
}

CircularArcBestFitType::CircularArcBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = 0;
  BaseFeature = BaseFeatureIn;
}

CircularArcBestFitType::CircularArcBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 NaturalType * nIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = nIn;
  BaseFeature = BaseFeatureIn;
}

CircularArcBestFitType::~CircularArcBestFitType()
{
  #ifndef NODESTRUCT
  delete n;
  delete BaseFeature;
  #endif
}

void CircularArcBestFitType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  {
    if (!BaseFeature)
      {
        fprintf(stderr, "BaseFeature list is missing\n");
        exit(1);
      }
    if (BaseFeature->size() == 0)
      {
        fprintf(stderr, "BaseFeature list is empty\n");
        exit(1);
      }
    if (BaseFeature->size() < 3)
      {
        fprintf(stderr,
                "size of BaseFeature list (%d) less than minimum required (3)\n",
                (int)BaseFeature->size());
        exit(1);
      }
    std::list<SequencedBaseFeatureType *>::iterator iter;
    for (iter = BaseFeature->begin();
         iter != BaseFeature->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<BaseFeature");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</BaseFeature>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool CircularArcBestFitType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in CircularArcBestFitType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in CircularArcBestFitType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CircularArcBestFitType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in CircularArcBestFitType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * CircularArcBestFitType::getn()
{return n;}

void CircularArcBestFitType::setn(NaturalType * nIn)
{n = nIn;}

SequencedBaseFeatureTypeLisd * CircularArcBestFitType::getBaseFeature()
{return BaseFeature;}

void CircularArcBestFitType::setBaseFeature(SequencedBaseFeatureTypeLisd * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class CircularArcCastType

*/

CircularArcCastType::CircularArcCastType() :
  ConstructionMethodBaseType()
{
  BaseFeature = 0;
}

CircularArcCastType::CircularArcCastType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeature = BaseFeatureIn;
}

CircularArcCastType::~CircularArcCastType()
{
  #ifndef NODESTRUCT
  delete BaseFeature;
  #endif
}

void CircularArcCastType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeature");
  BaseFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * CircularArcCastType::getBaseFeature()
{return BaseFeature;}

void CircularArcCastType::setBaseFeature(BaseFeatureType * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class CircularArcCheckedFeatureType

*/

CircularArcCheckedFeatureType::CircularArcCheckedFeatureType()
{
  CheckDetails = 0;
}

CircularArcCheckedFeatureType::CircularArcCheckedFeatureType(
 CircularArcCheckedType * CheckDetailsIn)
{
  CheckDetails = CheckDetailsIn;
}

CircularArcCheckedFeatureType::~CircularArcCheckedFeatureType()
{
  #ifndef NODESTRUCT
  delete CheckDetails;
  #endif
}

void CircularArcCheckedFeatureType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (CheckDetails)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CheckDetails");
      CheckDetails->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CheckDetails>\n");
    }
  doSpaces(-INDENT, outFile);
}

CircularArcCheckedType * CircularArcCheckedFeatureType::getCheckDetails()
{return CheckDetails;}

void CircularArcCheckedFeatureType::setCheckDetails(CircularArcCheckedType * CheckDetailsIn)
{CheckDetails = CheckDetailsIn;}

/* ***************************************************************** */

/* class CircularArcCheckedType

*/

CircularArcCheckedType::CircularArcCheckedType()
{
  CircularArcCheckedTypePair = 0;
}

CircularArcCheckedType::CircularArcCheckedType(
 CircularArcCheckedTypeChoicePair * CircularArcCheckedTypePairIn)
{
  CircularArcCheckedTypePair = CircularArcCheckedTypePairIn;
}

CircularArcCheckedType::~CircularArcCheckedType()
{
  #ifndef NODESTRUCT
  delete CircularArcCheckedTypePair;
  #endif
}

void CircularArcCheckedType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  CircularArcCheckedTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

CircularArcCheckedTypeChoicePair * CircularArcCheckedType::getCircularArcCheckedTypePair()
{return CircularArcCheckedTypePair;}

void CircularArcCheckedType::setCircularArcCheckedTypePair(CircularArcCheckedTypeChoicePair * CircularArcCheckedTypePairIn)
{CircularArcCheckedTypePair = CircularArcCheckedTypePairIn;}
CircularArcCheckedTypeChoicePair::CircularArcCheckedTypeChoicePair() {}

CircularArcCheckedTypeChoicePair::CircularArcCheckedTypeChoicePair(
 whichOne CircularArcCheckedTypeTypeIn,
 CircularArcCheckedTypeVal * CircularArcCheckedTypeValueIn)
{
  CircularArcCheckedTypeType = CircularArcCheckedTypeTypeIn;
  CircularArcCheckedTypeValue = CircularArcCheckedTypeValueIn;
}

CircularArcCheckedTypeChoicePair::~CircularArcCheckedTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (CircularArcCheckedTypeType == MeasuredE)
    delete CircularArcCheckedTypeValue->Measured;
  else if (CircularArcCheckedTypeType == ConstructedE)
    delete CircularArcCheckedTypeValue->Constructed;
  delete CircularArcCheckedTypeValue;
  #endif
}

void CircularArcCheckedTypeChoicePair::printSelf(FILE * outFile)
{
  if (CircularArcCheckedTypeType == MeasuredE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Measured");
      CircularArcCheckedTypeValue->Measured->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Measured>\n");
    }
  else if (CircularArcCheckedTypeType == ConstructedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      CircularArcCheckedTypeValue->Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
}

/* ***************************************************************** */

/* class CircularArcConstructionMethodType

*/

CircularArcConstructionMethodType::CircularArcConstructionMethodType()
{
  CircularArcConstructionMethodTypePair = 0;
}

CircularArcConstructionMethodType::CircularArcConstructionMethodType(
 CircularArcConstructionMethodTypeChoicePair * CircularArcConstructionMethodTypePairIn)
{
  CircularArcConstructionMethodTypePair = CircularArcConstructionMethodTypePairIn;
}

CircularArcConstructionMethodType::~CircularArcConstructionMethodType()
{
  #ifndef NODESTRUCT
  delete CircularArcConstructionMethodTypePair;
  #endif
}

void CircularArcConstructionMethodType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (CircularArcConstructionMethodTypePair)
    {
      CircularArcConstructionMethodTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

CircularArcConstructionMethodTypeChoicePair * CircularArcConstructionMethodType::getCircularArcConstructionMethodTypePair()
{return CircularArcConstructionMethodTypePair;}

void CircularArcConstructionMethodType::setCircularArcConstructionMethodTypePair(CircularArcConstructionMethodTypeChoicePair * CircularArcConstructionMethodTypePairIn)
{CircularArcConstructionMethodTypePair = CircularArcConstructionMethodTypePairIn;}
CircularArcConstructionMethodTypeChoicePair::CircularArcConstructionMethodTypeChoicePair() {}

CircularArcConstructionMethodTypeChoicePair::CircularArcConstructionMethodTypeChoicePair(
 whichOne CircularArcConstructionMethodTypeTypeIn,
 CircularArcConstructionMethodTypeVal * CircularArcConstructionMethodTypeValueIn)
{
  CircularArcConstructionMethodTypeType = CircularArcConstructionMethodTypeTypeIn;
  CircularArcConstructionMethodTypeValue = CircularArcConstructionMethodTypeValueIn;
}

CircularArcConstructionMethodTypeChoicePair::~CircularArcConstructionMethodTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (CircularArcConstructionMethodTypeType == BestFitE)
    delete CircularArcConstructionMethodTypeValue->BestFit;
  else if (CircularArcConstructionMethodTypeType == IntersectionE)
    delete CircularArcConstructionMethodTypeValue->Intersection;
  else if (CircularArcConstructionMethodTypeType == RecompensatedE)
    delete CircularArcConstructionMethodTypeValue->Recompensated;
  else if (CircularArcConstructionMethodTypeType == ProjectionE)
    delete CircularArcConstructionMethodTypeValue->Projection;
  else if (CircularArcConstructionMethodTypeType == CopyE)
    delete CircularArcConstructionMethodTypeValue->Copy;
  else if (CircularArcConstructionMethodTypeType == CastE)
    delete CircularArcConstructionMethodTypeValue->Cast;
  else if (CircularArcConstructionMethodTypeType == TransformE)
    delete CircularArcConstructionMethodTypeValue->Transform;
  else if (CircularArcConstructionMethodTypeType == FromScanE)
    delete CircularArcConstructionMethodTypeValue->FromScan;
  else if (CircularArcConstructionMethodTypeType == ExtractE)
    delete CircularArcConstructionMethodTypeValue->Extract;
  delete CircularArcConstructionMethodTypeValue;
  #endif
}

void CircularArcConstructionMethodTypeChoicePair::printSelf(FILE * outFile)
{
  if (CircularArcConstructionMethodTypeType == BestFitE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BestFit");
      CircularArcConstructionMethodTypeValue->BestFit->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BestFit>\n");
    }
  else if (CircularArcConstructionMethodTypeType == IntersectionE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Intersection");
      CircularArcConstructionMethodTypeValue->Intersection->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Intersection>\n");
    }
  else if (CircularArcConstructionMethodTypeType == RecompensatedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Recompensated");
      CircularArcConstructionMethodTypeValue->Recompensated->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Recompensated>\n");
    }
  else if (CircularArcConstructionMethodTypeType == ProjectionE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Projection");
      CircularArcConstructionMethodTypeValue->Projection->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Projection>\n");
    }
  else if (CircularArcConstructionMethodTypeType == CopyE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Copy");
      CircularArcConstructionMethodTypeValue->Copy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Copy>\n");
    }
  else if (CircularArcConstructionMethodTypeType == CastE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Cast");
      CircularArcConstructionMethodTypeValue->Cast->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Cast>\n");
    }
  else if (CircularArcConstructionMethodTypeType == TransformE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Transform");
      CircularArcConstructionMethodTypeValue->Transform->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Transform>\n");
    }
  else if (CircularArcConstructionMethodTypeType == FromScanE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FromScan");
      CircularArcConstructionMethodTypeValue->FromScan->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FromScan>\n");
    }
  else if (CircularArcConstructionMethodTypeType == ExtractE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Extract");
      CircularArcConstructionMethodTypeValue->Extract->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Extract>\n");
    }
}

/* ***************************************************************** */

/* class CircularArcCopyType

*/

CircularArcCopyType::CircularArcCopyType() :
  ConstructionMethodBaseType()
{
  BaseArc = 0;
}

CircularArcCopyType::CircularArcCopyType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseArcIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseArc = BaseArcIn;
}

CircularArcCopyType::~CircularArcCopyType()
{
  #ifndef NODESTRUCT
  delete BaseArc;
  #endif
}

void CircularArcCopyType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseArc");
  BaseArc->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseArc>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * CircularArcCopyType::getBaseArc()
{return BaseArc;}

void CircularArcCopyType::setBaseArc(BaseFeatureType * BaseArcIn)
{BaseArc = BaseArcIn;}

/* ***************************************************************** */

/* class CircularArcExtractType

*/

CircularArcExtractType::CircularArcExtractType() :
  ConstructionMethodBaseType()
{
  CurveFeature = 0;
}

CircularArcExtractType::CircularArcExtractType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * CurveFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  CurveFeature = CurveFeatureIn;
}

CircularArcExtractType::~CircularArcExtractType()
{
  #ifndef NODESTRUCT
  delete CurveFeature;
  #endif
}

void CircularArcExtractType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CurveFeature");
  CurveFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</CurveFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * CircularArcExtractType::getCurveFeature()
{return CurveFeature;}

void CircularArcExtractType::setCurveFeature(BaseFeatureType * CurveFeatureIn)
{CurveFeature = CurveFeatureIn;}

/* ***************************************************************** */

/* class CircularArcFeatureDefinitionType

*/

CircularArcFeatureDefinitionType::CircularArcFeatureDefinitionType() :
  CurveFeatureDefinitionBaseType()
{
  InternalExternal = 0;
  Radius = 0;
}

CircularArcFeatureDefinitionType::CircularArcFeatureDefinitionType(
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * RadiusIn) :
  CurveFeatureDefinitionBaseType(
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  Radius = RadiusIn;
}

CircularArcFeatureDefinitionType::CircularArcFeatureDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * RadiusIn) :
  CurveFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  Radius = RadiusIn;
}

CircularArcFeatureDefinitionType::~CircularArcFeatureDefinitionType()
{
  #ifndef NODESTRUCT
  delete InternalExternal;
  delete Radius;
  #endif
}

void CircularArcFeatureDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<InternalExternal");
  InternalExternal->printSelf(outFile);
  fprintf(outFile, "</InternalExternal>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Radius");
  Radius->printSelf(outFile);
  fprintf(outFile, "</Radius>\n");
  doSpaces(-INDENT, outFile);
}

bool CircularArcFeatureDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CircularArcFeatureDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CircularArcFeatureDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CircularArcFeatureDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CircularArcFeatureDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

InternalExternalEnumType * CircularArcFeatureDefinitionType::getInternalExternal()
{return InternalExternal;}

void CircularArcFeatureDefinitionType::setInternalExternal(InternalExternalEnumType * InternalExternalIn)
{InternalExternal = InternalExternalIn;}

LinearValueType * CircularArcFeatureDefinitionType::getRadius()
{return Radius;}

void CircularArcFeatureDefinitionType::setRadius(LinearValueType * RadiusIn)
{Radius = RadiusIn;}

/* ***************************************************************** */

/* class CircularArcFeatureItemType

*/

CircularArcFeatureItemType::CircularArcFeatureItemType() :
  CurveFeatureItemBaseType()
{
  DeterminationMode = 0;
}

CircularArcFeatureItemType::CircularArcFeatureItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 CircularArcMeasurementDeterminationType * DeterminationModeIn) :
  CurveFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

CircularArcFeatureItemType::CircularArcFeatureItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 CircularArcMeasurementDeterminationType * DeterminationModeIn) :
  CurveFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

CircularArcFeatureItemType::~CircularArcFeatureItemType()
{
  #ifndef NODESTRUCT
  delete DeterminationMode;
  #endif
}

void CircularArcFeatureItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<DeterminationMode");
  DeterminationMode->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeterminationMode>\n");
  doSpaces(-INDENT, outFile);
}

bool CircularArcFeatureItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CircularArcFeatureItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CircularArcFeatureItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CircularArcFeatureItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CircularArcFeatureItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

CircularArcMeasurementDeterminationType * CircularArcFeatureItemType::getDeterminationMode()
{return DeterminationMode;}

void CircularArcFeatureItemType::setDeterminationMode(CircularArcMeasurementDeterminationType * DeterminationModeIn)
{DeterminationMode = DeterminationModeIn;}

/* ***************************************************************** */

/* class CircularArcFeatureMeasurementType

*/

CircularArcFeatureMeasurementType::CircularArcFeatureMeasurementType() :
  CurveFeatureMeasurementBaseType()
{
  Location = 0;
  Normal = 0;
  Radius = 0;
  RadiusMin = 0;
  RadiusMax = 0;
  SweepMeasurementRange = 0;
  SweepFull = 0;
  Form = 0;
}

CircularArcFeatureMeasurementType::CircularArcFeatureMeasurementType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredPointType * LocationIn,
 MeasuredUnitVectorType * NormalIn,
 MeasuredLinearValueType * RadiusIn,
 MeasuredLinearValueType * RadiusMinIn,
 MeasuredLinearValueType * RadiusMaxIn,
 SweepType * SweepMeasurementRangeIn,
 SweepType * SweepFullIn,
 MeasuredLinearValueType * FormIn) :
  CurveFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Location = LocationIn;
  Normal = NormalIn;
  Radius = RadiusIn;
  RadiusMin = RadiusMinIn;
  RadiusMax = RadiusMaxIn;
  SweepMeasurementRange = SweepMeasurementRangeIn;
  SweepFull = SweepFullIn;
  Form = FormIn;
}

CircularArcFeatureMeasurementType::CircularArcFeatureMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredPointType * LocationIn,
 MeasuredUnitVectorType * NormalIn,
 MeasuredLinearValueType * RadiusIn,
 MeasuredLinearValueType * RadiusMinIn,
 MeasuredLinearValueType * RadiusMaxIn,
 SweepType * SweepMeasurementRangeIn,
 SweepType * SweepFullIn,
 MeasuredLinearValueType * FormIn) :
  CurveFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Location = LocationIn;
  Normal = NormalIn;
  Radius = RadiusIn;
  RadiusMin = RadiusMinIn;
  RadiusMax = RadiusMaxIn;
  SweepMeasurementRange = SweepMeasurementRangeIn;
  SweepFull = SweepFullIn;
  Form = FormIn;
}

CircularArcFeatureMeasurementType::~CircularArcFeatureMeasurementType()
{
  #ifndef NODESTRUCT
  delete Location;
  delete Normal;
  delete Radius;
  delete RadiusMin;
  delete RadiusMax;
  delete SweepMeasurementRange;
  delete SweepFull;
  delete Form;
  #endif
}

void CircularArcFeatureMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  if (Location)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Location");
      Location->printSelf(outFile);
      fprintf(outFile, "</Location>\n");
    }
  if (Normal)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Normal");
      Normal->printSelf(outFile);
      fprintf(outFile, "</Normal>\n");
    }
  if (Radius)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Radius");
      Radius->printSelf(outFile);
      fprintf(outFile, "</Radius>\n");
    }
  if (RadiusMin)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<RadiusMin");
      RadiusMin->printSelf(outFile);
      fprintf(outFile, "</RadiusMin>\n");
    }
  if (RadiusMax)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<RadiusMax");
      RadiusMax->printSelf(outFile);
      fprintf(outFile, "</RadiusMax>\n");
    }
  if (SweepMeasurementRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SweepMeasurementRange");
      SweepMeasurementRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SweepMeasurementRange>\n");
    }
  if (SweepFull)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SweepFull");
      SweepFull->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SweepFull>\n");
    }
  if (Form)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Form");
      Form->printSelf(outFile);
      fprintf(outFile, "</Form>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CircularArcFeatureMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CircularArcFeatureMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CircularArcFeatureMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CircularArcFeatureMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CircularArcFeatureMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredPointType * CircularArcFeatureMeasurementType::getLocation()
{return Location;}

void CircularArcFeatureMeasurementType::setLocation(MeasuredPointType * LocationIn)
{Location = LocationIn;}

MeasuredUnitVectorType * CircularArcFeatureMeasurementType::getNormal()
{return Normal;}

void CircularArcFeatureMeasurementType::setNormal(MeasuredUnitVectorType * NormalIn)
{Normal = NormalIn;}

MeasuredLinearValueType * CircularArcFeatureMeasurementType::getRadius()
{return Radius;}

void CircularArcFeatureMeasurementType::setRadius(MeasuredLinearValueType * RadiusIn)
{Radius = RadiusIn;}

MeasuredLinearValueType * CircularArcFeatureMeasurementType::getRadiusMin()
{return RadiusMin;}

void CircularArcFeatureMeasurementType::setRadiusMin(MeasuredLinearValueType * RadiusMinIn)
{RadiusMin = RadiusMinIn;}

MeasuredLinearValueType * CircularArcFeatureMeasurementType::getRadiusMax()
{return RadiusMax;}

void CircularArcFeatureMeasurementType::setRadiusMax(MeasuredLinearValueType * RadiusMaxIn)
{RadiusMax = RadiusMaxIn;}

SweepType * CircularArcFeatureMeasurementType::getSweepMeasurementRange()
{return SweepMeasurementRange;}

void CircularArcFeatureMeasurementType::setSweepMeasurementRange(SweepType * SweepMeasurementRangeIn)
{SweepMeasurementRange = SweepMeasurementRangeIn;}

SweepType * CircularArcFeatureMeasurementType::getSweepFull()
{return SweepFull;}

void CircularArcFeatureMeasurementType::setSweepFull(SweepType * SweepFullIn)
{SweepFull = SweepFullIn;}

MeasuredLinearValueType * CircularArcFeatureMeasurementType::getForm()
{return Form;}

void CircularArcFeatureMeasurementType::setForm(MeasuredLinearValueType * FormIn)
{Form = FormIn;}

/* ***************************************************************** */

/* class CircularArcFeatureNominalType

*/

CircularArcFeatureNominalType::CircularArcFeatureNominalType() :
  CurveFeatureNominalBaseType()
{
  Location = 0;
  Sweep = 0;
  Normal = 0;
  Constructed = 0;
}

CircularArcFeatureNominalType::CircularArcFeatureNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 PointType * LocationIn,
 SweepType * SweepIn,
 UnitVectorType * NormalIn,
 CircularArcConstructionMethodType * ConstructedIn) :
  CurveFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    SurfaceFeatureNominalIdIn)
{
  Location = LocationIn;
  Sweep = SweepIn;
  Normal = NormalIn;
  Constructed = ConstructedIn;
}

CircularArcFeatureNominalType::CircularArcFeatureNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 PointType * LocationIn,
 SweepType * SweepIn,
 UnitVectorType * NormalIn,
 CircularArcConstructionMethodType * ConstructedIn) :
  CurveFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    SurfaceFeatureNominalIdIn)
{
  Location = LocationIn;
  Sweep = SweepIn;
  Normal = NormalIn;
  Constructed = ConstructedIn;
}

CircularArcFeatureNominalType::~CircularArcFeatureNominalType()
{
  #ifndef NODESTRUCT
  delete Location;
  delete Sweep;
  delete Normal;
  delete Constructed;
  #endif
}

void CircularArcFeatureNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (SurfaceFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SurfaceFeatureNominalId");
      SurfaceFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</SurfaceFeatureNominalId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Location");
  Location->printSelf(outFile);
  fprintf(outFile, "</Location>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Sweep");
  Sweep->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Sweep>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Normal");
  Normal->printSelf(outFile);
  fprintf(outFile, "</Normal>\n");
  if (Constructed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CircularArcFeatureNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CircularArcFeatureNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CircularArcFeatureNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CircularArcFeatureNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CircularArcFeatureNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

PointType * CircularArcFeatureNominalType::getLocation()
{return Location;}

void CircularArcFeatureNominalType::setLocation(PointType * LocationIn)
{Location = LocationIn;}

SweepType * CircularArcFeatureNominalType::getSweep()
{return Sweep;}

void CircularArcFeatureNominalType::setSweep(SweepType * SweepIn)
{Sweep = SweepIn;}

UnitVectorType * CircularArcFeatureNominalType::getNormal()
{return Normal;}

void CircularArcFeatureNominalType::setNormal(UnitVectorType * NormalIn)
{Normal = NormalIn;}

CircularArcConstructionMethodType * CircularArcFeatureNominalType::getConstructed()
{return Constructed;}

void CircularArcFeatureNominalType::setConstructed(CircularArcConstructionMethodType * ConstructedIn)
{Constructed = ConstructedIn;}

/* ***************************************************************** */

/* class CircularArcFromScanType

*/

CircularArcFromScanType::CircularArcFromScanType() :
  ConstructionMethodBaseType()
{
  SurfaceFeature = 0;
  SearchRadius = 0;
  Depth = 0;
}

CircularArcFromScanType::CircularArcFromScanType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * SurfaceFeatureIn,
 LinearValueType * SearchRadiusIn,
 LinearValueType * DepthIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  SurfaceFeature = SurfaceFeatureIn;
  SearchRadius = SearchRadiusIn;
  Depth = DepthIn;
}

CircularArcFromScanType::~CircularArcFromScanType()
{
  #ifndef NODESTRUCT
  delete SurfaceFeature;
  delete SearchRadius;
  delete Depth;
  #endif
}

void CircularArcFromScanType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<SurfaceFeature");
  SurfaceFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</SurfaceFeature>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<SearchRadius");
  SearchRadius->printSelf(outFile);
  fprintf(outFile, "</SearchRadius>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Depth");
  Depth->printSelf(outFile);
  fprintf(outFile, "</Depth>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * CircularArcFromScanType::getSurfaceFeature()
{return SurfaceFeature;}

void CircularArcFromScanType::setSurfaceFeature(BaseFeatureType * SurfaceFeatureIn)
{SurfaceFeature = SurfaceFeatureIn;}

LinearValueType * CircularArcFromScanType::getSearchRadius()
{return SearchRadius;}

void CircularArcFromScanType::setSearchRadius(LinearValueType * SearchRadiusIn)
{SearchRadius = SearchRadiusIn;}

LinearValueType * CircularArcFromScanType::getDepth()
{return Depth;}

void CircularArcFromScanType::setDepth(LinearValueType * DepthIn)
{Depth = DepthIn;}

/* ***************************************************************** */

/* class CircularArcIntersectionType

*/

CircularArcIntersectionType::CircularArcIntersectionType() :
  ConstructionMethodBaseType()
{
  IntersectionFeature = 0;
}

CircularArcIntersectionType::CircularArcIntersectionType(
 XmlBoolean * NominalsCalculatedIn,
 SequencedBaseFeatureTypeLisd * IntersectionFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  IntersectionFeature = IntersectionFeatureIn;
}

CircularArcIntersectionType::~CircularArcIntersectionType()
{
  #ifndef NODESTRUCT
  delete IntersectionFeature;
  #endif
}

void CircularArcIntersectionType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  {
    if (!IntersectionFeature)
      {
        fprintf(stderr, "IntersectionFeature list is missing\n");
        exit(1);
      }
    if (IntersectionFeature->size() == 0)
      {
        fprintf(stderr, "IntersectionFeature list is empty\n");
        exit(1);
      }
    if (IntersectionFeature->size() > 2)
      {
        fprintf(stderr,
                "size of IntersectionFeature list (%d) greater than maximum allowed (2)\n",
                (int)IntersectionFeature->size());
        exit(1);
      }
    if (IntersectionFeature->size() < 2)
      {
        fprintf(stderr,
                "size of IntersectionFeature list (%d) less than minimum required (2)\n",
                (int)IntersectionFeature->size());
        exit(1);
      }
    std::list<SequencedBaseFeatureType *>::iterator iter;
    for (iter = IntersectionFeature->begin();
         iter != IntersectionFeature->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<IntersectionFeature");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</IntersectionFeature>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

SequencedBaseFeatureTypeLisd * CircularArcIntersectionType::getIntersectionFeature()
{return IntersectionFeature;}

void CircularArcIntersectionType::setIntersectionFeature(SequencedBaseFeatureTypeLisd * IntersectionFeatureIn)
{IntersectionFeature = IntersectionFeatureIn;}

/* ***************************************************************** */

/* class CircularArcMeasurementDeterminationType

*/

CircularArcMeasurementDeterminationType::CircularArcMeasurementDeterminationType()
{
  CircularArcMeasurementDeterminationTypePair = 0;
}

CircularArcMeasurementDeterminationType::CircularArcMeasurementDeterminationType(
 CircularArcMeasurementDeterminationTypeChoicePair * CircularArcMeasurementDeterminationTypePairIn)
{
  CircularArcMeasurementDeterminationTypePair = CircularArcMeasurementDeterminationTypePairIn;
}

CircularArcMeasurementDeterminationType::~CircularArcMeasurementDeterminationType()
{
  #ifndef NODESTRUCT
  delete CircularArcMeasurementDeterminationTypePair;
  #endif
}

void CircularArcMeasurementDeterminationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  CircularArcMeasurementDeterminationTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

CircularArcMeasurementDeterminationTypeChoicePair * CircularArcMeasurementDeterminationType::getCircularArcMeasurementDeterminationTypePair()
{return CircularArcMeasurementDeterminationTypePair;}

void CircularArcMeasurementDeterminationType::setCircularArcMeasurementDeterminationTypePair(CircularArcMeasurementDeterminationTypeChoicePair * CircularArcMeasurementDeterminationTypePairIn)
{CircularArcMeasurementDeterminationTypePair = CircularArcMeasurementDeterminationTypePairIn;}
CircularArcMeasurementDeterminationTypeChoicePair::CircularArcMeasurementDeterminationTypeChoicePair() {}

CircularArcMeasurementDeterminationTypeChoicePair::CircularArcMeasurementDeterminationTypeChoicePair(
 whichOne CircularArcMeasurementDeterminationTypeTypeIn,
 CircularArcMeasurementDeterminationTypeVal * CircularArcMeasurementDeterminationTypeValueIn)
{
  CircularArcMeasurementDeterminationTypeType = CircularArcMeasurementDeterminationTypeTypeIn;
  CircularArcMeasurementDeterminationTypeValue = CircularArcMeasurementDeterminationTypeValueIn;
}

CircularArcMeasurementDeterminationTypeChoicePair::~CircularArcMeasurementDeterminationTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (CircularArcMeasurementDeterminationTypeType == CheckedE)
    delete CircularArcMeasurementDeterminationTypeValue->Checked;
  else if (CircularArcMeasurementDeterminationTypeType == SetE)
    delete CircularArcMeasurementDeterminationTypeValue->Set;
  delete CircularArcMeasurementDeterminationTypeValue;
  #endif
}

void CircularArcMeasurementDeterminationTypeChoicePair::printSelf(FILE * outFile)
{
  if (CircularArcMeasurementDeterminationTypeType == CheckedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Checked");
      CircularArcMeasurementDeterminationTypeValue->Checked->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Checked>\n");
    }
  else if (CircularArcMeasurementDeterminationTypeType == SetE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Set");
      CircularArcMeasurementDeterminationTypeValue->Set->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class CircularArcProjectionType

*/

CircularArcProjectionType::CircularArcProjectionType() :
  ConstructionMethodBaseType()
{
  ProjectionArc = 0;
  ProjectionPlane = 0;
}

CircularArcProjectionType::CircularArcProjectionType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * ProjectionArcIn,
 BaseFeatureType * ProjectionPlaneIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  ProjectionArc = ProjectionArcIn;
  ProjectionPlane = ProjectionPlaneIn;
}

CircularArcProjectionType::~CircularArcProjectionType()
{
  #ifndef NODESTRUCT
  delete ProjectionArc;
  delete ProjectionPlane;
  #endif
}

void CircularArcProjectionType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ProjectionArc");
  ProjectionArc->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ProjectionArc>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<ProjectionPlane");
  ProjectionPlane->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ProjectionPlane>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * CircularArcProjectionType::getProjectionArc()
{return ProjectionArc;}

void CircularArcProjectionType::setProjectionArc(BaseFeatureType * ProjectionArcIn)
{ProjectionArc = ProjectionArcIn;}

BaseFeatureType * CircularArcProjectionType::getProjectionPlane()
{return ProjectionPlane;}

void CircularArcProjectionType::setProjectionPlane(BaseFeatureType * ProjectionPlaneIn)
{ProjectionPlane = ProjectionPlaneIn;}

/* ***************************************************************** */

/* class CircularArcRecompType

*/

CircularArcRecompType::CircularArcRecompType() :
  ConstructionMethodBaseType()
{
  BaseFeaturePointList = 0;
}

CircularArcRecompType::CircularArcRecompType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeaturePointListType * BaseFeaturePointListIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeaturePointList = BaseFeaturePointListIn;
}

CircularArcRecompType::~CircularArcRecompType()
{
  #ifndef NODESTRUCT
  delete BaseFeaturePointList;
  #endif
}

void CircularArcRecompType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeaturePointList");
  BaseFeaturePointList->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeaturePointList>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeaturePointListType * CircularArcRecompType::getBaseFeaturePointList()
{return BaseFeaturePointList;}

void CircularArcRecompType::setBaseFeaturePointList(BaseFeaturePointListType * BaseFeaturePointListIn)
{BaseFeaturePointList = BaseFeaturePointListIn;}

/* ***************************************************************** */

/* class CircularArcTransformType

*/

CircularArcTransformType::CircularArcTransformType() :
  ConstructionMethodBaseType()
{
  BaseArc = 0;
  Transformation = 0;
}

CircularArcTransformType::CircularArcTransformType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseArcIn,
 TransformationReferenceType * TransformationIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseArc = BaseArcIn;
  Transformation = TransformationIn;
}

CircularArcTransformType::~CircularArcTransformType()
{
  #ifndef NODESTRUCT
  delete BaseArc;
  delete Transformation;
  #endif
}

void CircularArcTransformType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseArc");
  BaseArc->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseArc>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Transformation");
  Transformation->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Transformation>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * CircularArcTransformType::getBaseArc()
{return BaseArc;}

void CircularArcTransformType::setBaseArc(BaseFeatureType * BaseArcIn)
{BaseArc = BaseArcIn;}

TransformationReferenceType * CircularArcTransformType::getTransformation()
{return Transformation;}

void CircularArcTransformType::setTransformation(TransformationReferenceType * TransformationIn)
{Transformation = TransformationIn;}

/* ***************************************************************** */

/* class ConeBestFitType

*/

ConeBestFitType::ConeBestFitType() :
  ConstructionMethodBaseType()
{
  n = 0;
  BaseFeature = 0;
}

ConeBestFitType::ConeBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = 0;
  BaseFeature = BaseFeatureIn;
}

ConeBestFitType::ConeBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 NaturalType * nIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = nIn;
  BaseFeature = BaseFeatureIn;
}

ConeBestFitType::~ConeBestFitType()
{
  #ifndef NODESTRUCT
  delete n;
  delete BaseFeature;
  #endif
}

void ConeBestFitType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  {
    if (!BaseFeature)
      {
        fprintf(stderr, "BaseFeature list is missing\n");
        exit(1);
      }
    if (BaseFeature->size() == 0)
      {
        fprintf(stderr, "BaseFeature list is empty\n");
        exit(1);
      }
    if (BaseFeature->size() < 6)
      {
        fprintf(stderr,
                "size of BaseFeature list (%d) less than minimum required (6)\n",
                (int)BaseFeature->size());
        exit(1);
      }
    std::list<SequencedBaseFeatureType *>::iterator iter;
    for (iter = BaseFeature->begin();
         iter != BaseFeature->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<BaseFeature");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</BaseFeature>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool ConeBestFitType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in ConeBestFitType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in ConeBestFitType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ConeBestFitType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in ConeBestFitType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * ConeBestFitType::getn()
{return n;}

void ConeBestFitType::setn(NaturalType * nIn)
{n = nIn;}

SequencedBaseFeatureTypeLisd * ConeBestFitType::getBaseFeature()
{return BaseFeature;}

void ConeBestFitType::setBaseFeature(SequencedBaseFeatureTypeLisd * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class ConeCastType

*/

ConeCastType::ConeCastType() :
  ConstructionMethodBaseType()
{
  BaseFeature = 0;
}

ConeCastType::ConeCastType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeature = BaseFeatureIn;
}

ConeCastType::~ConeCastType()
{
  #ifndef NODESTRUCT
  delete BaseFeature;
  #endif
}

void ConeCastType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeature");
  BaseFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * ConeCastType::getBaseFeature()
{return BaseFeature;}

void ConeCastType::setBaseFeature(BaseFeatureType * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class ConeCheckedFeatureType

*/

ConeCheckedFeatureType::ConeCheckedFeatureType()
{
  CheckDetails = 0;
}

ConeCheckedFeatureType::ConeCheckedFeatureType(
 ConeCheckedType * CheckDetailsIn)
{
  CheckDetails = CheckDetailsIn;
}

ConeCheckedFeatureType::~ConeCheckedFeatureType()
{
  #ifndef NODESTRUCT
  delete CheckDetails;
  #endif
}

void ConeCheckedFeatureType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (CheckDetails)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CheckDetails");
      CheckDetails->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CheckDetails>\n");
    }
  doSpaces(-INDENT, outFile);
}

ConeCheckedType * ConeCheckedFeatureType::getCheckDetails()
{return CheckDetails;}

void ConeCheckedFeatureType::setCheckDetails(ConeCheckedType * CheckDetailsIn)
{CheckDetails = CheckDetailsIn;}

/* ***************************************************************** */

/* class ConeCheckedType

*/

ConeCheckedType::ConeCheckedType()
{
  ConeCheckedTypePair = 0;
}

ConeCheckedType::ConeCheckedType(
 ConeCheckedTypeChoicePair * ConeCheckedTypePairIn)
{
  ConeCheckedTypePair = ConeCheckedTypePairIn;
}

ConeCheckedType::~ConeCheckedType()
{
  #ifndef NODESTRUCT
  delete ConeCheckedTypePair;
  #endif
}

void ConeCheckedType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  ConeCheckedTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

ConeCheckedTypeChoicePair * ConeCheckedType::getConeCheckedTypePair()
{return ConeCheckedTypePair;}

void ConeCheckedType::setConeCheckedTypePair(ConeCheckedTypeChoicePair * ConeCheckedTypePairIn)
{ConeCheckedTypePair = ConeCheckedTypePairIn;}
ConeCheckedTypeChoicePair::ConeCheckedTypeChoicePair() {}

ConeCheckedTypeChoicePair::ConeCheckedTypeChoicePair(
 whichOne ConeCheckedTypeTypeIn,
 ConeCheckedTypeVal * ConeCheckedTypeValueIn)
{
  ConeCheckedTypeType = ConeCheckedTypeTypeIn;
  ConeCheckedTypeValue = ConeCheckedTypeValueIn;
}

ConeCheckedTypeChoicePair::~ConeCheckedTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (ConeCheckedTypeType == MeasuredE)
    delete ConeCheckedTypeValue->Measured;
  else if (ConeCheckedTypeType == ConstructedE)
    delete ConeCheckedTypeValue->Constructed;
  delete ConeCheckedTypeValue;
  #endif
}

void ConeCheckedTypeChoicePair::printSelf(FILE * outFile)
{
  if (ConeCheckedTypeType == MeasuredE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Measured");
      ConeCheckedTypeValue->Measured->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Measured>\n");
    }
  else if (ConeCheckedTypeType == ConstructedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      ConeCheckedTypeValue->Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
}

/* ***************************************************************** */

/* class ConeConstructionMethodType

*/

ConeConstructionMethodType::ConeConstructionMethodType()
{
  ConeConstructionMethodTypePair = 0;
}

ConeConstructionMethodType::ConeConstructionMethodType(
 ConeConstructionMethodTypeChoicePair * ConeConstructionMethodTypePairIn)
{
  ConeConstructionMethodTypePair = ConeConstructionMethodTypePairIn;
}

ConeConstructionMethodType::~ConeConstructionMethodType()
{
  #ifndef NODESTRUCT
  delete ConeConstructionMethodTypePair;
  #endif
}

void ConeConstructionMethodType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (ConeConstructionMethodTypePair)
    {
      ConeConstructionMethodTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

ConeConstructionMethodTypeChoicePair * ConeConstructionMethodType::getConeConstructionMethodTypePair()
{return ConeConstructionMethodTypePair;}

void ConeConstructionMethodType::setConeConstructionMethodTypePair(ConeConstructionMethodTypeChoicePair * ConeConstructionMethodTypePairIn)
{ConeConstructionMethodTypePair = ConeConstructionMethodTypePairIn;}
ConeConstructionMethodTypeChoicePair::ConeConstructionMethodTypeChoicePair() {}

ConeConstructionMethodTypeChoicePair::ConeConstructionMethodTypeChoicePair(
 whichOne ConeConstructionMethodTypeTypeIn,
 ConeConstructionMethodTypeVal * ConeConstructionMethodTypeValueIn)
{
  ConeConstructionMethodTypeType = ConeConstructionMethodTypeTypeIn;
  ConeConstructionMethodTypeValue = ConeConstructionMethodTypeValueIn;
}

ConeConstructionMethodTypeChoicePair::~ConeConstructionMethodTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (ConeConstructionMethodTypeType == BestFitE)
    delete ConeConstructionMethodTypeValue->BestFit;
  else if (ConeConstructionMethodTypeType == RecompensatedE)
    delete ConeConstructionMethodTypeValue->Recompensated;
  else if (ConeConstructionMethodTypeType == CopyE)
    delete ConeConstructionMethodTypeValue->Copy;
  else if (ConeConstructionMethodTypeType == CastE)
    delete ConeConstructionMethodTypeValue->Cast;
  else if (ConeConstructionMethodTypeType == TransformE)
    delete ConeConstructionMethodTypeValue->Transform;
  else if (ConeConstructionMethodTypeType == FromScanE)
    delete ConeConstructionMethodTypeValue->FromScan;
  delete ConeConstructionMethodTypeValue;
  #endif
}

void ConeConstructionMethodTypeChoicePair::printSelf(FILE * outFile)
{
  if (ConeConstructionMethodTypeType == BestFitE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BestFit");
      ConeConstructionMethodTypeValue->BestFit->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BestFit>\n");
    }
  else if (ConeConstructionMethodTypeType == RecompensatedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Recompensated");
      ConeConstructionMethodTypeValue->Recompensated->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Recompensated>\n");
    }
  else if (ConeConstructionMethodTypeType == CopyE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Copy");
      ConeConstructionMethodTypeValue->Copy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Copy>\n");
    }
  else if (ConeConstructionMethodTypeType == CastE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Cast");
      ConeConstructionMethodTypeValue->Cast->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Cast>\n");
    }
  else if (ConeConstructionMethodTypeType == TransformE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Transform");
      ConeConstructionMethodTypeValue->Transform->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Transform>\n");
    }
  else if (ConeConstructionMethodTypeType == FromScanE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FromScan");
      ConeConstructionMethodTypeValue->FromScan->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FromScan>\n");
    }
}

/* ***************************************************************** */

/* class ConeCopyType

*/

ConeCopyType::ConeCopyType() :
  ConstructionMethodBaseType()
{
  BaseCone = 0;
}

ConeCopyType::ConeCopyType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseConeIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseCone = BaseConeIn;
}

ConeCopyType::~ConeCopyType()
{
  #ifndef NODESTRUCT
  delete BaseCone;
  #endif
}

void ConeCopyType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseCone");
  BaseCone->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseCone>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * ConeCopyType::getBaseCone()
{return BaseCone;}

void ConeCopyType::setBaseCone(BaseFeatureType * BaseConeIn)
{BaseCone = BaseConeIn;}

/* ***************************************************************** */

/* class ConeFeatureDefinitionType

*/

ConeFeatureDefinitionType::ConeFeatureDefinitionType() :
  SurfaceFeatureDefinitionBaseType()
{
  InternalExternal = 0;
  Diameter = 0;
  ConeFeatureDefi_1071 = 0;
  ConeFeatureDefi_1072 = 0;
}

ConeFeatureDefinitionType::ConeFeatureDefinitionType(
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * DiameterIn,
 ConeFeatureDefi_1071_Type * ConeFeatureDefi_1071In,
 ConeFeatureDefi_1072_Type * ConeFeatureDefi_1072In) :
  SurfaceFeatureDefinitionBaseType(
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  Diameter = DiameterIn;
  ConeFeatureDefi_1071 = ConeFeatureDefi_1071In;
  ConeFeatureDefi_1072 = ConeFeatureDefi_1072In;
}

ConeFeatureDefinitionType::ConeFeatureDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * DiameterIn,
 ConeFeatureDefi_1071_Type * ConeFeatureDefi_1071In,
 ConeFeatureDefi_1072_Type * ConeFeatureDefi_1072In) :
  SurfaceFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  Diameter = DiameterIn;
  ConeFeatureDefi_1071 = ConeFeatureDefi_1071In;
  ConeFeatureDefi_1072 = ConeFeatureDefi_1072In;
}

ConeFeatureDefinitionType::~ConeFeatureDefinitionType()
{
  #ifndef NODESTRUCT
  delete InternalExternal;
  delete Diameter;
  delete ConeFeatureDefi_1071;
  delete ConeFeatureDefi_1072;
  #endif
}

void ConeFeatureDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<InternalExternal");
  InternalExternal->printSelf(outFile);
  fprintf(outFile, "</InternalExternal>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Diameter");
  Diameter->printSelf(outFile);
  fprintf(outFile, "</Diameter>\n");
  ConeFeatureDefi_1071->printSelf(outFile);
  if (ConeFeatureDefi_1072)
    {
      ConeFeatureDefi_1072->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool ConeFeatureDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ConeFeatureDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ConeFeatureDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ConeFeatureDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ConeFeatureDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

InternalExternalEnumType * ConeFeatureDefinitionType::getInternalExternal()
{return InternalExternal;}

void ConeFeatureDefinitionType::setInternalExternal(InternalExternalEnumType * InternalExternalIn)
{InternalExternal = InternalExternalIn;}

LinearValueType * ConeFeatureDefinitionType::getDiameter()
{return Diameter;}

void ConeFeatureDefinitionType::setDiameter(LinearValueType * DiameterIn)
{Diameter = DiameterIn;}

ConeFeatureDefi_1071_Type * ConeFeatureDefinitionType::getConeFeatureDefi_1071()
{return ConeFeatureDefi_1071;}

void ConeFeatureDefinitionType::setConeFeatureDefi_1071(ConeFeatureDefi_1071_Type * ConeFeatureDefi_1071In)
{ConeFeatureDefi_1071 = ConeFeatureDefi_1071In;}

ConeFeatureDefi_1072_Type * ConeFeatureDefinitionType::getConeFeatureDefi_1072()
{return ConeFeatureDefi_1072;}

void ConeFeatureDefinitionType::setConeFeatureDefi_1072(ConeFeatureDefi_1072_Type * ConeFeatureDefi_1072In)
{ConeFeatureDefi_1072 = ConeFeatureDefi_1072In;}

/* ***************************************************************** */

/* class ConeFeatureItemType

*/

ConeFeatureItemType::ConeFeatureItemType() :
  SurfaceFeatureItemBaseType()
{
  DeterminationMode = 0;
}

ConeFeatureItemType::ConeFeatureItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 ConeMeasurementDeterminationType * DeterminationModeIn) :
  SurfaceFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

ConeFeatureItemType::ConeFeatureItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 ConeMeasurementDeterminationType * DeterminationModeIn) :
  SurfaceFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

ConeFeatureItemType::~ConeFeatureItemType()
{
  #ifndef NODESTRUCT
  delete DeterminationMode;
  #endif
}

void ConeFeatureItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<DeterminationMode");
  DeterminationMode->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeterminationMode>\n");
  doSpaces(-INDENT, outFile);
}

bool ConeFeatureItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ConeFeatureItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ConeFeatureItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ConeFeatureItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ConeFeatureItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

ConeMeasurementDeterminationType * ConeFeatureItemType::getDeterminationMode()
{return DeterminationMode;}

void ConeFeatureItemType::setDeterminationMode(ConeMeasurementDeterminationType * DeterminationModeIn)
{DeterminationMode = DeterminationModeIn;}

/* ***************************************************************** */

/* class ConeFeatureMeasurementType

*/

ConeFeatureMeasurementType::ConeFeatureMeasurementType() :
  SurfaceFeatureMeasurementBaseType()
{
  Axis = 0;
  Diameter = 0;
  DiameterMin = 0;
  DiameterMax = 0;
  ConeFeatureMeas_1073 = 0;
  SmallEndDistance = 0;
  LargeEndDistance = 0;
  SweepMeasurementRange = 0;
  SweepFull = 0;
  Form = 0;
}

ConeFeatureMeasurementType::ConeFeatureMeasurementType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredAxisType * AxisIn,
 MeasuredLinearValueType * DiameterIn,
 MeasuredLinearValueType * DiameterMinIn,
 MeasuredLinearValueType * DiameterMaxIn,
 ConeFeatureMeas_1073_Type * ConeFeatureMeas_1073In,
 MeasuredLinearValueType * SmallEndDistanceIn,
 MeasuredLinearValueType * LargeEndDistanceIn,
 SweepType * SweepMeasurementRangeIn,
 SweepType * SweepFullIn,
 MeasuredLinearValueType * FormIn) :
  SurfaceFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Axis = AxisIn;
  Diameter = DiameterIn;
  DiameterMin = DiameterMinIn;
  DiameterMax = DiameterMaxIn;
  ConeFeatureMeas_1073 = ConeFeatureMeas_1073In;
  SmallEndDistance = SmallEndDistanceIn;
  LargeEndDistance = LargeEndDistanceIn;
  SweepMeasurementRange = SweepMeasurementRangeIn;
  SweepFull = SweepFullIn;
  Form = FormIn;
}

ConeFeatureMeasurementType::ConeFeatureMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredAxisType * AxisIn,
 MeasuredLinearValueType * DiameterIn,
 MeasuredLinearValueType * DiameterMinIn,
 MeasuredLinearValueType * DiameterMaxIn,
 ConeFeatureMeas_1073_Type * ConeFeatureMeas_1073In,
 MeasuredLinearValueType * SmallEndDistanceIn,
 MeasuredLinearValueType * LargeEndDistanceIn,
 SweepType * SweepMeasurementRangeIn,
 SweepType * SweepFullIn,
 MeasuredLinearValueType * FormIn) :
  SurfaceFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Axis = AxisIn;
  Diameter = DiameterIn;
  DiameterMin = DiameterMinIn;
  DiameterMax = DiameterMaxIn;
  ConeFeatureMeas_1073 = ConeFeatureMeas_1073In;
  SmallEndDistance = SmallEndDistanceIn;
  LargeEndDistance = LargeEndDistanceIn;
  SweepMeasurementRange = SweepMeasurementRangeIn;
  SweepFull = SweepFullIn;
  Form = FormIn;
}

ConeFeatureMeasurementType::~ConeFeatureMeasurementType()
{
  #ifndef NODESTRUCT
  delete Axis;
  delete Diameter;
  delete DiameterMin;
  delete DiameterMax;
  delete ConeFeatureMeas_1073;
  delete SmallEndDistance;
  delete LargeEndDistance;
  delete SweepMeasurementRange;
  delete SweepFull;
  delete Form;
  #endif
}

void ConeFeatureMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  if (Axis)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Axis");
      Axis->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Axis>\n");
    }
  if (Diameter)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Diameter");
      Diameter->printSelf(outFile);
      fprintf(outFile, "</Diameter>\n");
    }
  if (DiameterMin)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DiameterMin");
      DiameterMin->printSelf(outFile);
      fprintf(outFile, "</DiameterMin>\n");
    }
  if (DiameterMax)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DiameterMax");
      DiameterMax->printSelf(outFile);
      fprintf(outFile, "</DiameterMax>\n");
    }
  if (ConeFeatureMeas_1073)
    {
  ConeFeatureMeas_1073->printSelf(outFile);
    }
  if (SmallEndDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SmallEndDistance");
      SmallEndDistance->printSelf(outFile);
      fprintf(outFile, "</SmallEndDistance>\n");
    }
  if (LargeEndDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LargeEndDistance");
      LargeEndDistance->printSelf(outFile);
      fprintf(outFile, "</LargeEndDistance>\n");
    }
  if (SweepMeasurementRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SweepMeasurementRange");
      SweepMeasurementRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SweepMeasurementRange>\n");
    }
  if (SweepFull)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SweepFull");
      SweepFull->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SweepFull>\n");
    }
  if (Form)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Form");
      Form->printSelf(outFile);
      fprintf(outFile, "</Form>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ConeFeatureMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ConeFeatureMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ConeFeatureMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ConeFeatureMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ConeFeatureMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredAxisType * ConeFeatureMeasurementType::getAxis()
{return Axis;}

void ConeFeatureMeasurementType::setAxis(MeasuredAxisType * AxisIn)
{Axis = AxisIn;}

MeasuredLinearValueType * ConeFeatureMeasurementType::getDiameter()
{return Diameter;}

void ConeFeatureMeasurementType::setDiameter(MeasuredLinearValueType * DiameterIn)
{Diameter = DiameterIn;}

MeasuredLinearValueType * ConeFeatureMeasurementType::getDiameterMin()
{return DiameterMin;}

void ConeFeatureMeasurementType::setDiameterMin(MeasuredLinearValueType * DiameterMinIn)
{DiameterMin = DiameterMinIn;}

MeasuredLinearValueType * ConeFeatureMeasurementType::getDiameterMax()
{return DiameterMax;}

void ConeFeatureMeasurementType::setDiameterMax(MeasuredLinearValueType * DiameterMaxIn)
{DiameterMax = DiameterMaxIn;}

ConeFeatureMeas_1073_Type * ConeFeatureMeasurementType::getConeFeatureMeas_1073()
{return ConeFeatureMeas_1073;}

void ConeFeatureMeasurementType::setConeFeatureMeas_1073(ConeFeatureMeas_1073_Type * ConeFeatureMeas_1073In)
{ConeFeatureMeas_1073 = ConeFeatureMeas_1073In;}

MeasuredLinearValueType * ConeFeatureMeasurementType::getSmallEndDistance()
{return SmallEndDistance;}

void ConeFeatureMeasurementType::setSmallEndDistance(MeasuredLinearValueType * SmallEndDistanceIn)
{SmallEndDistance = SmallEndDistanceIn;}

MeasuredLinearValueType * ConeFeatureMeasurementType::getLargeEndDistance()
{return LargeEndDistance;}

void ConeFeatureMeasurementType::setLargeEndDistance(MeasuredLinearValueType * LargeEndDistanceIn)
{LargeEndDistance = LargeEndDistanceIn;}

SweepType * ConeFeatureMeasurementType::getSweepMeasurementRange()
{return SweepMeasurementRange;}

void ConeFeatureMeasurementType::setSweepMeasurementRange(SweepType * SweepMeasurementRangeIn)
{SweepMeasurementRange = SweepMeasurementRangeIn;}

SweepType * ConeFeatureMeasurementType::getSweepFull()
{return SweepFull;}

void ConeFeatureMeasurementType::setSweepFull(SweepType * SweepFullIn)
{SweepFull = SweepFullIn;}

MeasuredLinearValueType * ConeFeatureMeasurementType::getForm()
{return Form;}

void ConeFeatureMeasurementType::setForm(MeasuredLinearValueType * FormIn)
{Form = FormIn;}

/* ***************************************************************** */

/* class ConeFeatureNominalType

*/

ConeFeatureNominalType::ConeFeatureNominalType() :
  SurfaceFeatureNominalBaseType()
{
  Axis = 0;
  Sweep = 0;
  Constructed = 0;
}

ConeFeatureNominalType::ConeFeatureNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 AxisType * AxisIn,
 SweepType * SweepIn,
 ConeConstructionMethodType * ConstructedIn) :
  SurfaceFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  Axis = AxisIn;
  Sweep = SweepIn;
  Constructed = ConstructedIn;
}

ConeFeatureNominalType::ConeFeatureNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 AxisType * AxisIn,
 SweepType * SweepIn,
 ConeConstructionMethodType * ConstructedIn) :
  SurfaceFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  Axis = AxisIn;
  Sweep = SweepIn;
  Constructed = ConstructedIn;
}

ConeFeatureNominalType::~ConeFeatureNominalType()
{
  #ifndef NODESTRUCT
  delete Axis;
  delete Sweep;
  delete Constructed;
  #endif
}

void ConeFeatureNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Axis");
  Axis->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Axis>\n");
  if (Sweep)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Sweep");
      Sweep->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Sweep>\n");
    }
  if (Constructed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ConeFeatureNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ConeFeatureNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ConeFeatureNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ConeFeatureNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ConeFeatureNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

AxisType * ConeFeatureNominalType::getAxis()
{return Axis;}

void ConeFeatureNominalType::setAxis(AxisType * AxisIn)
{Axis = AxisIn;}

SweepType * ConeFeatureNominalType::getSweep()
{return Sweep;}

void ConeFeatureNominalType::setSweep(SweepType * SweepIn)
{Sweep = SweepIn;}

ConeConstructionMethodType * ConeFeatureNominalType::getConstructed()
{return Constructed;}

void ConeFeatureNominalType::setConstructed(ConeConstructionMethodType * ConstructedIn)
{Constructed = ConstructedIn;}

/* ***************************************************************** */

/* class ConeFromScanType

*/

ConeFromScanType::ConeFromScanType() :
  ConstructionMethodBaseType()
{
  SurfaceFeature = 0;
  SearchRadius = 0;
}

ConeFromScanType::ConeFromScanType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * SurfaceFeatureIn,
 LinearValueType * SearchRadiusIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  SurfaceFeature = SurfaceFeatureIn;
  SearchRadius = SearchRadiusIn;
}

ConeFromScanType::~ConeFromScanType()
{
  #ifndef NODESTRUCT
  delete SurfaceFeature;
  delete SearchRadius;
  #endif
}

void ConeFromScanType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<SurfaceFeature");
  SurfaceFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</SurfaceFeature>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<SearchRadius");
  SearchRadius->printSelf(outFile);
  fprintf(outFile, "</SearchRadius>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * ConeFromScanType::getSurfaceFeature()
{return SurfaceFeature;}

void ConeFromScanType::setSurfaceFeature(BaseFeatureType * SurfaceFeatureIn)
{SurfaceFeature = SurfaceFeatureIn;}

LinearValueType * ConeFromScanType::getSearchRadius()
{return SearchRadius;}

void ConeFromScanType::setSearchRadius(LinearValueType * SearchRadiusIn)
{SearchRadius = SearchRadiusIn;}

/* ***************************************************************** */

/* class ConeMeasurementDeterminationType

*/

ConeMeasurementDeterminationType::ConeMeasurementDeterminationType()
{
  ConeMeasurementDeterminationTypePair = 0;
}

ConeMeasurementDeterminationType::ConeMeasurementDeterminationType(
 ConeMeasurementDeterminationTypeChoicePair * ConeMeasurementDeterminationTypePairIn)
{
  ConeMeasurementDeterminationTypePair = ConeMeasurementDeterminationTypePairIn;
}

ConeMeasurementDeterminationType::~ConeMeasurementDeterminationType()
{
  #ifndef NODESTRUCT
  delete ConeMeasurementDeterminationTypePair;
  #endif
}

void ConeMeasurementDeterminationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  ConeMeasurementDeterminationTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

ConeMeasurementDeterminationTypeChoicePair * ConeMeasurementDeterminationType::getConeMeasurementDeterminationTypePair()
{return ConeMeasurementDeterminationTypePair;}

void ConeMeasurementDeterminationType::setConeMeasurementDeterminationTypePair(ConeMeasurementDeterminationTypeChoicePair * ConeMeasurementDeterminationTypePairIn)
{ConeMeasurementDeterminationTypePair = ConeMeasurementDeterminationTypePairIn;}
ConeMeasurementDeterminationTypeChoicePair::ConeMeasurementDeterminationTypeChoicePair() {}

ConeMeasurementDeterminationTypeChoicePair::ConeMeasurementDeterminationTypeChoicePair(
 whichOne ConeMeasurementDeterminationTypeTypeIn,
 ConeMeasurementDeterminationTypeVal * ConeMeasurementDeterminationTypeValueIn)
{
  ConeMeasurementDeterminationTypeType = ConeMeasurementDeterminationTypeTypeIn;
  ConeMeasurementDeterminationTypeValue = ConeMeasurementDeterminationTypeValueIn;
}

ConeMeasurementDeterminationTypeChoicePair::~ConeMeasurementDeterminationTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (ConeMeasurementDeterminationTypeType == CheckedE)
    delete ConeMeasurementDeterminationTypeValue->Checked;
  else if (ConeMeasurementDeterminationTypeType == SetE)
    delete ConeMeasurementDeterminationTypeValue->Set;
  delete ConeMeasurementDeterminationTypeValue;
  #endif
}

void ConeMeasurementDeterminationTypeChoicePair::printSelf(FILE * outFile)
{
  if (ConeMeasurementDeterminationTypeType == CheckedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Checked");
      ConeMeasurementDeterminationTypeValue->Checked->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Checked>\n");
    }
  else if (ConeMeasurementDeterminationTypeType == SetE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Set");
      ConeMeasurementDeterminationTypeValue->Set->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class ConeRecompType

*/

ConeRecompType::ConeRecompType() :
  ConstructionMethodBaseType()
{
  BaseFeaturePointList = 0;
}

ConeRecompType::ConeRecompType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeaturePointListType * BaseFeaturePointListIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeaturePointList = BaseFeaturePointListIn;
}

ConeRecompType::~ConeRecompType()
{
  #ifndef NODESTRUCT
  delete BaseFeaturePointList;
  #endif
}

void ConeRecompType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeaturePointList");
  BaseFeaturePointList->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeaturePointList>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeaturePointListType * ConeRecompType::getBaseFeaturePointList()
{return BaseFeaturePointList;}

void ConeRecompType::setBaseFeaturePointList(BaseFeaturePointListType * BaseFeaturePointListIn)
{BaseFeaturePointList = BaseFeaturePointListIn;}

/* ***************************************************************** */

/* class ConeTransformType

*/

ConeTransformType::ConeTransformType() :
  ConstructionMethodBaseType()
{
  BaseCone = 0;
  Transformation = 0;
}

ConeTransformType::ConeTransformType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseConeIn,
 TransformationReferenceType * TransformationIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseCone = BaseConeIn;
  Transformation = TransformationIn;
}

ConeTransformType::~ConeTransformType()
{
  #ifndef NODESTRUCT
  delete BaseCone;
  delete Transformation;
  #endif
}

void ConeTransformType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseCone");
  BaseCone->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseCone>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Transformation");
  Transformation->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Transformation>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * ConeTransformType::getBaseCone()
{return BaseCone;}

void ConeTransformType::setBaseCone(BaseFeatureType * BaseConeIn)
{BaseCone = BaseConeIn;}

TransformationReferenceType * ConeTransformType::getTransformation()
{return Transformation;}

void ConeTransformType::setTransformation(TransformationReferenceType * TransformationIn)
{Transformation = TransformationIn;}

/* ***************************************************************** */

/* class ConicalSegmentBestFitType

*/

ConicalSegmentBestFitType::ConicalSegmentBestFitType() :
  ConstructionMethodBaseType()
{
  n = 0;
  BaseFeature = 0;
}

ConicalSegmentBestFitType::ConicalSegmentBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = 0;
  BaseFeature = BaseFeatureIn;
}

ConicalSegmentBestFitType::ConicalSegmentBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 NaturalType * nIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = nIn;
  BaseFeature = BaseFeatureIn;
}

ConicalSegmentBestFitType::~ConicalSegmentBestFitType()
{
  #ifndef NODESTRUCT
  delete n;
  delete BaseFeature;
  #endif
}

void ConicalSegmentBestFitType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  {
    if (!BaseFeature)
      {
        fprintf(stderr, "BaseFeature list is missing\n");
        exit(1);
      }
    if (BaseFeature->size() == 0)
      {
        fprintf(stderr, "BaseFeature list is empty\n");
        exit(1);
      }
    if (BaseFeature->size() < 6)
      {
        fprintf(stderr,
                "size of BaseFeature list (%d) less than minimum required (6)\n",
                (int)BaseFeature->size());
        exit(1);
      }
    std::list<SequencedBaseFeatureType *>::iterator iter;
    for (iter = BaseFeature->begin();
         iter != BaseFeature->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<BaseFeature");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</BaseFeature>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool ConicalSegmentBestFitType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in ConicalSegmentBestFitType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in ConicalSegmentBestFitType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ConicalSegmentBestFitType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in ConicalSegmentBestFitType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * ConicalSegmentBestFitType::getn()
{return n;}

void ConicalSegmentBestFitType::setn(NaturalType * nIn)
{n = nIn;}

SequencedBaseFeatureTypeLisd * ConicalSegmentBestFitType::getBaseFeature()
{return BaseFeature;}

void ConicalSegmentBestFitType::setBaseFeature(SequencedBaseFeatureTypeLisd * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class ConicalSegmentCastType

*/

ConicalSegmentCastType::ConicalSegmentCastType() :
  ConstructionMethodBaseType()
{
  BaseFeature = 0;
}

ConicalSegmentCastType::ConicalSegmentCastType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeature = BaseFeatureIn;
}

ConicalSegmentCastType::~ConicalSegmentCastType()
{
  #ifndef NODESTRUCT
  delete BaseFeature;
  #endif
}

void ConicalSegmentCastType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeature");
  BaseFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * ConicalSegmentCastType::getBaseFeature()
{return BaseFeature;}

void ConicalSegmentCastType::setBaseFeature(BaseFeatureType * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class ConicalSegmentCheckedFeatureType

*/

ConicalSegmentCheckedFeatureType::ConicalSegmentCheckedFeatureType()
{
  CheckDetails = 0;
}

ConicalSegmentCheckedFeatureType::ConicalSegmentCheckedFeatureType(
 ConicalSegmentCheckedType * CheckDetailsIn)
{
  CheckDetails = CheckDetailsIn;
}

ConicalSegmentCheckedFeatureType::~ConicalSegmentCheckedFeatureType()
{
  #ifndef NODESTRUCT
  delete CheckDetails;
  #endif
}

void ConicalSegmentCheckedFeatureType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (CheckDetails)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CheckDetails");
      CheckDetails->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CheckDetails>\n");
    }
  doSpaces(-INDENT, outFile);
}

ConicalSegmentCheckedType * ConicalSegmentCheckedFeatureType::getCheckDetails()
{return CheckDetails;}

void ConicalSegmentCheckedFeatureType::setCheckDetails(ConicalSegmentCheckedType * CheckDetailsIn)
{CheckDetails = CheckDetailsIn;}

/* ***************************************************************** */

/* class ConicalSegmentCheckedType

*/

ConicalSegmentCheckedType::ConicalSegmentCheckedType()
{
  ConicalSegmentCheckedTypePair = 0;
}

ConicalSegmentCheckedType::ConicalSegmentCheckedType(
 ConicalSegmentCheckedTypeChoicePair * ConicalSegmentCheckedTypePairIn)
{
  ConicalSegmentCheckedTypePair = ConicalSegmentCheckedTypePairIn;
}

ConicalSegmentCheckedType::~ConicalSegmentCheckedType()
{
  #ifndef NODESTRUCT
  delete ConicalSegmentCheckedTypePair;
  #endif
}

void ConicalSegmentCheckedType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  ConicalSegmentCheckedTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

ConicalSegmentCheckedTypeChoicePair * ConicalSegmentCheckedType::getConicalSegmentCheckedTypePair()
{return ConicalSegmentCheckedTypePair;}

void ConicalSegmentCheckedType::setConicalSegmentCheckedTypePair(ConicalSegmentCheckedTypeChoicePair * ConicalSegmentCheckedTypePairIn)
{ConicalSegmentCheckedTypePair = ConicalSegmentCheckedTypePairIn;}
ConicalSegmentCheckedTypeChoicePair::ConicalSegmentCheckedTypeChoicePair() {}

ConicalSegmentCheckedTypeChoicePair::ConicalSegmentCheckedTypeChoicePair(
 whichOne ConicalSegmentCheckedTypeTypeIn,
 ConicalSegmentCheckedTypeVal * ConicalSegmentCheckedTypeValueIn)
{
  ConicalSegmentCheckedTypeType = ConicalSegmentCheckedTypeTypeIn;
  ConicalSegmentCheckedTypeValue = ConicalSegmentCheckedTypeValueIn;
}

ConicalSegmentCheckedTypeChoicePair::~ConicalSegmentCheckedTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (ConicalSegmentCheckedTypeType == MeasuredE)
    delete ConicalSegmentCheckedTypeValue->Measured;
  else if (ConicalSegmentCheckedTypeType == ConstructedE)
    delete ConicalSegmentCheckedTypeValue->Constructed;
  delete ConicalSegmentCheckedTypeValue;
  #endif
}

void ConicalSegmentCheckedTypeChoicePair::printSelf(FILE * outFile)
{
  if (ConicalSegmentCheckedTypeType == MeasuredE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Measured");
      ConicalSegmentCheckedTypeValue->Measured->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Measured>\n");
    }
  else if (ConicalSegmentCheckedTypeType == ConstructedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      ConicalSegmentCheckedTypeValue->Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
}

/* ***************************************************************** */

/* class ConicalSegmentConstructionMethodType

*/

ConicalSegmentConstructionMethodType::ConicalSegmentConstructionMethodType()
{
  ConicalSegmentConstructionMethodTypePair = 0;
}

ConicalSegmentConstructionMethodType::ConicalSegmentConstructionMethodType(
 ConicalSegmentConstructionMethodTypeChoicePair * ConicalSegmentConstructionMethodTypePairIn)
{
  ConicalSegmentConstructionMethodTypePair = ConicalSegmentConstructionMethodTypePairIn;
}

ConicalSegmentConstructionMethodType::~ConicalSegmentConstructionMethodType()
{
  #ifndef NODESTRUCT
  delete ConicalSegmentConstructionMethodTypePair;
  #endif
}

void ConicalSegmentConstructionMethodType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (ConicalSegmentConstructionMethodTypePair)
    {
      ConicalSegmentConstructionMethodTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

ConicalSegmentConstructionMethodTypeChoicePair * ConicalSegmentConstructionMethodType::getConicalSegmentConstructionMethodTypePair()
{return ConicalSegmentConstructionMethodTypePair;}

void ConicalSegmentConstructionMethodType::setConicalSegmentConstructionMethodTypePair(ConicalSegmentConstructionMethodTypeChoicePair * ConicalSegmentConstructionMethodTypePairIn)
{ConicalSegmentConstructionMethodTypePair = ConicalSegmentConstructionMethodTypePairIn;}
ConicalSegmentConstructionMethodTypeChoicePair::ConicalSegmentConstructionMethodTypeChoicePair() {}

ConicalSegmentConstructionMethodTypeChoicePair::ConicalSegmentConstructionMethodTypeChoicePair(
 whichOne ConicalSegmentConstructionMethodTypeTypeIn,
 ConicalSegmentConstructionMethodTypeVal * ConicalSegmentConstructionMethodTypeValueIn)
{
  ConicalSegmentConstructionMethodTypeType = ConicalSegmentConstructionMethodTypeTypeIn;
  ConicalSegmentConstructionMethodTypeValue = ConicalSegmentConstructionMethodTypeValueIn;
}

ConicalSegmentConstructionMethodTypeChoicePair::~ConicalSegmentConstructionMethodTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (ConicalSegmentConstructionMethodTypeType == BestFitE)
    delete ConicalSegmentConstructionMethodTypeValue->BestFit;
  else if (ConicalSegmentConstructionMethodTypeType == RecompensatedE)
    delete ConicalSegmentConstructionMethodTypeValue->Recompensated;
  else if (ConicalSegmentConstructionMethodTypeType == CopyE)
    delete ConicalSegmentConstructionMethodTypeValue->Copy;
  else if (ConicalSegmentConstructionMethodTypeType == CastE)
    delete ConicalSegmentConstructionMethodTypeValue->Cast;
  else if (ConicalSegmentConstructionMethodTypeType == TransformE)
    delete ConicalSegmentConstructionMethodTypeValue->Transform;
  delete ConicalSegmentConstructionMethodTypeValue;
  #endif
}

void ConicalSegmentConstructionMethodTypeChoicePair::printSelf(FILE * outFile)
{
  if (ConicalSegmentConstructionMethodTypeType == BestFitE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BestFit");
      ConicalSegmentConstructionMethodTypeValue->BestFit->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BestFit>\n");
    }
  else if (ConicalSegmentConstructionMethodTypeType == RecompensatedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Recompensated");
      ConicalSegmentConstructionMethodTypeValue->Recompensated->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Recompensated>\n");
    }
  else if (ConicalSegmentConstructionMethodTypeType == CopyE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Copy");
      ConicalSegmentConstructionMethodTypeValue->Copy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Copy>\n");
    }
  else if (ConicalSegmentConstructionMethodTypeType == CastE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Cast");
      ConicalSegmentConstructionMethodTypeValue->Cast->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Cast>\n");
    }
  else if (ConicalSegmentConstructionMethodTypeType == TransformE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Transform");
      ConicalSegmentConstructionMethodTypeValue->Transform->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Transform>\n");
    }
}

/* ***************************************************************** */

/* class ConicalSegmentCopyType

*/

ConicalSegmentCopyType::ConicalSegmentCopyType() :
  ConstructionMethodBaseType()
{
  BaseConicalSegment = 0;
}

ConicalSegmentCopyType::ConicalSegmentCopyType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseConicalSegmentIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseConicalSegment = BaseConicalSegmentIn;
}

ConicalSegmentCopyType::~ConicalSegmentCopyType()
{
  #ifndef NODESTRUCT
  delete BaseConicalSegment;
  #endif
}

void ConicalSegmentCopyType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseConicalSegment");
  BaseConicalSegment->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseConicalSegment>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * ConicalSegmentCopyType::getBaseConicalSegment()
{return BaseConicalSegment;}

void ConicalSegmentCopyType::setBaseConicalSegment(BaseFeatureType * BaseConicalSegmentIn)
{BaseConicalSegment = BaseConicalSegmentIn;}

/* ***************************************************************** */

/* class ConicalSegmentFeatureDefinitionType

*/

ConicalSegmentFeatureDefinitionType::ConicalSegmentFeatureDefinitionType() :
  SurfaceFeatureDefinitionBaseType()
{
  InternalExternal = 0;
  Diameter = 0;
  ConicalSegmentF_1074 = 0;
  ConicalSegmentF_1075 = 0;
}

ConicalSegmentFeatureDefinitionType::ConicalSegmentFeatureDefinitionType(
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * DiameterIn,
 ConicalSegmentF_1074_Type * ConicalSegmentF_1074In,
 ConicalSegmentF_1075_Type * ConicalSegmentF_1075In) :
  SurfaceFeatureDefinitionBaseType(
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  Diameter = DiameterIn;
  ConicalSegmentF_1074 = ConicalSegmentF_1074In;
  ConicalSegmentF_1075 = ConicalSegmentF_1075In;
}

ConicalSegmentFeatureDefinitionType::ConicalSegmentFeatureDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * DiameterIn,
 ConicalSegmentF_1074_Type * ConicalSegmentF_1074In,
 ConicalSegmentF_1075_Type * ConicalSegmentF_1075In) :
  SurfaceFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  Diameter = DiameterIn;
  ConicalSegmentF_1074 = ConicalSegmentF_1074In;
  ConicalSegmentF_1075 = ConicalSegmentF_1075In;
}

ConicalSegmentFeatureDefinitionType::~ConicalSegmentFeatureDefinitionType()
{
  #ifndef NODESTRUCT
  delete InternalExternal;
  delete Diameter;
  delete ConicalSegmentF_1074;
  delete ConicalSegmentF_1075;
  #endif
}

void ConicalSegmentFeatureDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<InternalExternal");
  InternalExternal->printSelf(outFile);
  fprintf(outFile, "</InternalExternal>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Diameter");
  Diameter->printSelf(outFile);
  fprintf(outFile, "</Diameter>\n");
  ConicalSegmentF_1074->printSelf(outFile);
  if (ConicalSegmentF_1075)
    {
      ConicalSegmentF_1075->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool ConicalSegmentFeatureDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ConicalSegmentFeatureDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ConicalSegmentFeatureDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ConicalSegmentFeatureDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ConicalSegmentFeatureDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

InternalExternalEnumType * ConicalSegmentFeatureDefinitionType::getInternalExternal()
{return InternalExternal;}

void ConicalSegmentFeatureDefinitionType::setInternalExternal(InternalExternalEnumType * InternalExternalIn)
{InternalExternal = InternalExternalIn;}

LinearValueType * ConicalSegmentFeatureDefinitionType::getDiameter()
{return Diameter;}

void ConicalSegmentFeatureDefinitionType::setDiameter(LinearValueType * DiameterIn)
{Diameter = DiameterIn;}

ConicalSegmentF_1074_Type * ConicalSegmentFeatureDefinitionType::getConicalSegmentF_1074()
{return ConicalSegmentF_1074;}

void ConicalSegmentFeatureDefinitionType::setConicalSegmentF_1074(ConicalSegmentF_1074_Type * ConicalSegmentF_1074In)
{ConicalSegmentF_1074 = ConicalSegmentF_1074In;}

ConicalSegmentF_1075_Type * ConicalSegmentFeatureDefinitionType::getConicalSegmentF_1075()
{return ConicalSegmentF_1075;}

void ConicalSegmentFeatureDefinitionType::setConicalSegmentF_1075(ConicalSegmentF_1075_Type * ConicalSegmentF_1075In)
{ConicalSegmentF_1075 = ConicalSegmentF_1075In;}

/* ***************************************************************** */

/* class ConicalSegmentFeatureItemType

*/

ConicalSegmentFeatureItemType::ConicalSegmentFeatureItemType() :
  SurfaceFeatureItemBaseType()
{
  DeterminationMode = 0;
}

ConicalSegmentFeatureItemType::ConicalSegmentFeatureItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 ConicalSegmentMeasurementDeterminationType * DeterminationModeIn) :
  SurfaceFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

ConicalSegmentFeatureItemType::ConicalSegmentFeatureItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 ConicalSegmentMeasurementDeterminationType * DeterminationModeIn) :
  SurfaceFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

ConicalSegmentFeatureItemType::~ConicalSegmentFeatureItemType()
{
  #ifndef NODESTRUCT
  delete DeterminationMode;
  #endif
}

void ConicalSegmentFeatureItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<DeterminationMode");
  DeterminationMode->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeterminationMode>\n");
  doSpaces(-INDENT, outFile);
}

bool ConicalSegmentFeatureItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ConicalSegmentFeatureItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ConicalSegmentFeatureItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ConicalSegmentFeatureItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ConicalSegmentFeatureItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

ConicalSegmentMeasurementDeterminationType * ConicalSegmentFeatureItemType::getDeterminationMode()
{return DeterminationMode;}

void ConicalSegmentFeatureItemType::setDeterminationMode(ConicalSegmentMeasurementDeterminationType * DeterminationModeIn)
{DeterminationMode = DeterminationModeIn;}

/* ***************************************************************** */

/* class ConicalSegmentFeatureMeasurementType

*/

ConicalSegmentFeatureMeasurementType::ConicalSegmentFeatureMeasurementType() :
  SurfaceFeatureMeasurementBaseType()
{
  Axis = 0;
  Diameter = 0;
  DiameterMin = 0;
  DiameterMax = 0;
  ConicalSegmentF_1076 = 0;
  SmallEndDistance = 0;
  LargeEndDistance = 0;
  SweepMeasurementRange = 0;
  SweepFull = 0;
  Form = 0;
}

ConicalSegmentFeatureMeasurementType::ConicalSegmentFeatureMeasurementType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredAxisType * AxisIn,
 MeasuredLinearValueType * DiameterIn,
 MeasuredLinearValueType * DiameterMinIn,
 MeasuredLinearValueType * DiameterMaxIn,
 ConicalSegmentF_1076_Type * ConicalSegmentF_1076In,
 MeasuredLinearValueType * SmallEndDistanceIn,
 MeasuredLinearValueType * LargeEndDistanceIn,
 SweepType * SweepMeasurementRangeIn,
 SweepType * SweepFullIn,
 MeasuredLinearValueType * FormIn) :
  SurfaceFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Axis = AxisIn;
  Diameter = DiameterIn;
  DiameterMin = DiameterMinIn;
  DiameterMax = DiameterMaxIn;
  ConicalSegmentF_1076 = ConicalSegmentF_1076In;
  SmallEndDistance = SmallEndDistanceIn;
  LargeEndDistance = LargeEndDistanceIn;
  SweepMeasurementRange = SweepMeasurementRangeIn;
  SweepFull = SweepFullIn;
  Form = FormIn;
}

ConicalSegmentFeatureMeasurementType::ConicalSegmentFeatureMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredAxisType * AxisIn,
 MeasuredLinearValueType * DiameterIn,
 MeasuredLinearValueType * DiameterMinIn,
 MeasuredLinearValueType * DiameterMaxIn,
 ConicalSegmentF_1076_Type * ConicalSegmentF_1076In,
 MeasuredLinearValueType * SmallEndDistanceIn,
 MeasuredLinearValueType * LargeEndDistanceIn,
 SweepType * SweepMeasurementRangeIn,
 SweepType * SweepFullIn,
 MeasuredLinearValueType * FormIn) :
  SurfaceFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Axis = AxisIn;
  Diameter = DiameterIn;
  DiameterMin = DiameterMinIn;
  DiameterMax = DiameterMaxIn;
  ConicalSegmentF_1076 = ConicalSegmentF_1076In;
  SmallEndDistance = SmallEndDistanceIn;
  LargeEndDistance = LargeEndDistanceIn;
  SweepMeasurementRange = SweepMeasurementRangeIn;
  SweepFull = SweepFullIn;
  Form = FormIn;
}

ConicalSegmentFeatureMeasurementType::~ConicalSegmentFeatureMeasurementType()
{
  #ifndef NODESTRUCT
  delete Axis;
  delete Diameter;
  delete DiameterMin;
  delete DiameterMax;
  delete ConicalSegmentF_1076;
  delete SmallEndDistance;
  delete LargeEndDistance;
  delete SweepMeasurementRange;
  delete SweepFull;
  delete Form;
  #endif
}

void ConicalSegmentFeatureMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  if (Axis)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Axis");
      Axis->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Axis>\n");
    }
  if (Diameter)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Diameter");
      Diameter->printSelf(outFile);
      fprintf(outFile, "</Diameter>\n");
    }
  if (DiameterMin)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DiameterMin");
      DiameterMin->printSelf(outFile);
      fprintf(outFile, "</DiameterMin>\n");
    }
  if (DiameterMax)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DiameterMax");
      DiameterMax->printSelf(outFile);
      fprintf(outFile, "</DiameterMax>\n");
    }
  if (ConicalSegmentF_1076)
    {
  ConicalSegmentF_1076->printSelf(outFile);
    }
  if (SmallEndDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SmallEndDistance");
      SmallEndDistance->printSelf(outFile);
      fprintf(outFile, "</SmallEndDistance>\n");
    }
  if (LargeEndDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LargeEndDistance");
      LargeEndDistance->printSelf(outFile);
      fprintf(outFile, "</LargeEndDistance>\n");
    }
  if (SweepMeasurementRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SweepMeasurementRange");
      SweepMeasurementRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SweepMeasurementRange>\n");
    }
  if (SweepFull)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SweepFull");
      SweepFull->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SweepFull>\n");
    }
  if (Form)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Form");
      Form->printSelf(outFile);
      fprintf(outFile, "</Form>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ConicalSegmentFeatureMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ConicalSegmentFeatureMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ConicalSegmentFeatureMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ConicalSegmentFeatureMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ConicalSegmentFeatureMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredAxisType * ConicalSegmentFeatureMeasurementType::getAxis()
{return Axis;}

void ConicalSegmentFeatureMeasurementType::setAxis(MeasuredAxisType * AxisIn)
{Axis = AxisIn;}

MeasuredLinearValueType * ConicalSegmentFeatureMeasurementType::getDiameter()
{return Diameter;}

void ConicalSegmentFeatureMeasurementType::setDiameter(MeasuredLinearValueType * DiameterIn)
{Diameter = DiameterIn;}

MeasuredLinearValueType * ConicalSegmentFeatureMeasurementType::getDiameterMin()
{return DiameterMin;}

void ConicalSegmentFeatureMeasurementType::setDiameterMin(MeasuredLinearValueType * DiameterMinIn)
{DiameterMin = DiameterMinIn;}

MeasuredLinearValueType * ConicalSegmentFeatureMeasurementType::getDiameterMax()
{return DiameterMax;}

void ConicalSegmentFeatureMeasurementType::setDiameterMax(MeasuredLinearValueType * DiameterMaxIn)
{DiameterMax = DiameterMaxIn;}

ConicalSegmentF_1076_Type * ConicalSegmentFeatureMeasurementType::getConicalSegmentF_1076()
{return ConicalSegmentF_1076;}

void ConicalSegmentFeatureMeasurementType::setConicalSegmentF_1076(ConicalSegmentF_1076_Type * ConicalSegmentF_1076In)
{ConicalSegmentF_1076 = ConicalSegmentF_1076In;}

MeasuredLinearValueType * ConicalSegmentFeatureMeasurementType::getSmallEndDistance()
{return SmallEndDistance;}

void ConicalSegmentFeatureMeasurementType::setSmallEndDistance(MeasuredLinearValueType * SmallEndDistanceIn)
{SmallEndDistance = SmallEndDistanceIn;}

MeasuredLinearValueType * ConicalSegmentFeatureMeasurementType::getLargeEndDistance()
{return LargeEndDistance;}

void ConicalSegmentFeatureMeasurementType::setLargeEndDistance(MeasuredLinearValueType * LargeEndDistanceIn)
{LargeEndDistance = LargeEndDistanceIn;}

SweepType * ConicalSegmentFeatureMeasurementType::getSweepMeasurementRange()
{return SweepMeasurementRange;}

void ConicalSegmentFeatureMeasurementType::setSweepMeasurementRange(SweepType * SweepMeasurementRangeIn)
{SweepMeasurementRange = SweepMeasurementRangeIn;}

SweepType * ConicalSegmentFeatureMeasurementType::getSweepFull()
{return SweepFull;}

void ConicalSegmentFeatureMeasurementType::setSweepFull(SweepType * SweepFullIn)
{SweepFull = SweepFullIn;}

MeasuredLinearValueType * ConicalSegmentFeatureMeasurementType::getForm()
{return Form;}

void ConicalSegmentFeatureMeasurementType::setForm(MeasuredLinearValueType * FormIn)
{Form = FormIn;}

/* ***************************************************************** */

/* class ConicalSegmentFeatureNominalType

*/

ConicalSegmentFeatureNominalType::ConicalSegmentFeatureNominalType() :
  SurfaceFeatureNominalBaseType()
{
  Axis = 0;
  Sweep = 0;
  Constructed = 0;
}

ConicalSegmentFeatureNominalType::ConicalSegmentFeatureNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 AxisType * AxisIn,
 SweepType * SweepIn,
 ConicalSegmentConstructionMethodType * ConstructedIn) :
  SurfaceFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  Axis = AxisIn;
  Sweep = SweepIn;
  Constructed = ConstructedIn;
}

ConicalSegmentFeatureNominalType::ConicalSegmentFeatureNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 AxisType * AxisIn,
 SweepType * SweepIn,
 ConicalSegmentConstructionMethodType * ConstructedIn) :
  SurfaceFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  Axis = AxisIn;
  Sweep = SweepIn;
  Constructed = ConstructedIn;
}

ConicalSegmentFeatureNominalType::~ConicalSegmentFeatureNominalType()
{
  #ifndef NODESTRUCT
  delete Axis;
  delete Sweep;
  delete Constructed;
  #endif
}

void ConicalSegmentFeatureNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Axis");
  Axis->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Axis>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Sweep");
  Sweep->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Sweep>\n");
  if (Constructed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ConicalSegmentFeatureNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ConicalSegmentFeatureNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ConicalSegmentFeatureNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ConicalSegmentFeatureNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ConicalSegmentFeatureNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

AxisType * ConicalSegmentFeatureNominalType::getAxis()
{return Axis;}

void ConicalSegmentFeatureNominalType::setAxis(AxisType * AxisIn)
{Axis = AxisIn;}

SweepType * ConicalSegmentFeatureNominalType::getSweep()
{return Sweep;}

void ConicalSegmentFeatureNominalType::setSweep(SweepType * SweepIn)
{Sweep = SweepIn;}

ConicalSegmentConstructionMethodType * ConicalSegmentFeatureNominalType::getConstructed()
{return Constructed;}

void ConicalSegmentFeatureNominalType::setConstructed(ConicalSegmentConstructionMethodType * ConstructedIn)
{Constructed = ConstructedIn;}

/* ***************************************************************** */

/* class ConicalSegmentMeasurementDeterminationType

*/

ConicalSegmentMeasurementDeterminationType::ConicalSegmentMeasurementDeterminationType()
{
  ConicalSegmentMeasurementDeterminationTypePair = 0;
}

ConicalSegmentMeasurementDeterminationType::ConicalSegmentMeasurementDeterminationType(
 ConicalSegmentMeasurementDeterminationTypeChoicePair * ConicalSegmentMeasurementDeterminationTypePairIn)
{
  ConicalSegmentMeasurementDeterminationTypePair = ConicalSegmentMeasurementDeterminationTypePairIn;
}

ConicalSegmentMeasurementDeterminationType::~ConicalSegmentMeasurementDeterminationType()
{
  #ifndef NODESTRUCT
  delete ConicalSegmentMeasurementDeterminationTypePair;
  #endif
}

void ConicalSegmentMeasurementDeterminationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  ConicalSegmentMeasurementDeterminationTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

ConicalSegmentMeasurementDeterminationTypeChoicePair * ConicalSegmentMeasurementDeterminationType::getConicalSegmentMeasurementDeterminationTypePair()
{return ConicalSegmentMeasurementDeterminationTypePair;}

void ConicalSegmentMeasurementDeterminationType::setConicalSegmentMeasurementDeterminationTypePair(ConicalSegmentMeasurementDeterminationTypeChoicePair * ConicalSegmentMeasurementDeterminationTypePairIn)
{ConicalSegmentMeasurementDeterminationTypePair = ConicalSegmentMeasurementDeterminationTypePairIn;}
ConicalSegmentMeasurementDeterminationTypeChoicePair::ConicalSegmentMeasurementDeterminationTypeChoicePair() {}

ConicalSegmentMeasurementDeterminationTypeChoicePair::ConicalSegmentMeasurementDeterminationTypeChoicePair(
 whichOne ConicalSegmentMeasurementDeterminationTypeTypeIn,
 ConicalSegmentMeasurementDeterminationTypeVal * ConicalSegmentMeasurementDeterminationTypeValueIn)
{
  ConicalSegmentMeasurementDeterminationTypeType = ConicalSegmentMeasurementDeterminationTypeTypeIn;
  ConicalSegmentMeasurementDeterminationTypeValue = ConicalSegmentMeasurementDeterminationTypeValueIn;
}

ConicalSegmentMeasurementDeterminationTypeChoicePair::~ConicalSegmentMeasurementDeterminationTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (ConicalSegmentMeasurementDeterminationTypeType == CheckedE)
    delete ConicalSegmentMeasurementDeterminationTypeValue->Checked;
  else if (ConicalSegmentMeasurementDeterminationTypeType == SetE)
    delete ConicalSegmentMeasurementDeterminationTypeValue->Set;
  delete ConicalSegmentMeasurementDeterminationTypeValue;
  #endif
}

void ConicalSegmentMeasurementDeterminationTypeChoicePair::printSelf(FILE * outFile)
{
  if (ConicalSegmentMeasurementDeterminationTypeType == CheckedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Checked");
      ConicalSegmentMeasurementDeterminationTypeValue->Checked->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Checked>\n");
    }
  else if (ConicalSegmentMeasurementDeterminationTypeType == SetE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Set");
      ConicalSegmentMeasurementDeterminationTypeValue->Set->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class ConicalSegmentRecompType

*/

ConicalSegmentRecompType::ConicalSegmentRecompType() :
  ConstructionMethodBaseType()
{
  BaseFeaturePointList = 0;
}

ConicalSegmentRecompType::ConicalSegmentRecompType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeaturePointListType * BaseFeaturePointListIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeaturePointList = BaseFeaturePointListIn;
}

ConicalSegmentRecompType::~ConicalSegmentRecompType()
{
  #ifndef NODESTRUCT
  delete BaseFeaturePointList;
  #endif
}

void ConicalSegmentRecompType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeaturePointList");
  BaseFeaturePointList->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeaturePointList>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeaturePointListType * ConicalSegmentRecompType::getBaseFeaturePointList()
{return BaseFeaturePointList;}

void ConicalSegmentRecompType::setBaseFeaturePointList(BaseFeaturePointListType * BaseFeaturePointListIn)
{BaseFeaturePointList = BaseFeaturePointListIn;}

/* ***************************************************************** */

/* class ConicalSegmentTransformType

*/

ConicalSegmentTransformType::ConicalSegmentTransformType() :
  ConstructionMethodBaseType()
{
  BaseConicalSegment = 0;
  Transformation = 0;
}

ConicalSegmentTransformType::ConicalSegmentTransformType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseConicalSegmentIn,
 TransformationReferenceType * TransformationIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseConicalSegment = BaseConicalSegmentIn;
  Transformation = TransformationIn;
}

ConicalSegmentTransformType::~ConicalSegmentTransformType()
{
  #ifndef NODESTRUCT
  delete BaseConicalSegment;
  delete Transformation;
  #endif
}

void ConicalSegmentTransformType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseConicalSegment");
  BaseConicalSegment->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseConicalSegment>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Transformation");
  Transformation->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Transformation>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * ConicalSegmentTransformType::getBaseConicalSegment()
{return BaseConicalSegment;}

void ConicalSegmentTransformType::setBaseConicalSegment(BaseFeatureType * BaseConicalSegmentIn)
{BaseConicalSegment = BaseConicalSegmentIn;}

TransformationReferenceType * ConicalSegmentTransformType::getTransformation()
{return Transformation;}

void ConicalSegmentTransformType::setTransformation(TransformationReferenceType * TransformationIn)
{Transformation = TransformationIn;}

/* ***************************************************************** */

/* class ConstructionMethodBaseType

*/

ConstructionMethodBaseType::ConstructionMethodBaseType()
{
  NominalsCalculated = 0;
}

ConstructionMethodBaseType::ConstructionMethodBaseType(
 XmlBoolean * NominalsCalculatedIn)
{
  NominalsCalculated = NominalsCalculatedIn;
}

ConstructionMethodBaseType::~ConstructionMethodBaseType()
{
  #ifndef NODESTRUCT
  delete NominalsCalculated;
  #endif
}

void ConstructionMethodBaseType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(-INDENT, outFile);
}

XmlBoolean * ConstructionMethodBaseType::getNominalsCalculated()
{return NominalsCalculated;}

void ConstructionMethodBaseType::setNominalsCalculated(XmlBoolean * NominalsCalculatedIn)
{NominalsCalculated = NominalsCalculatedIn;}

/* ***************************************************************** */

/* class CurveFeatureDefinitionBaseType

*/

CurveFeatureDefinitionBaseType::CurveFeatureDefinitionBaseType() :
  ShapeFeatureDefinitionBaseType()
{
}

CurveFeatureDefinitionBaseType::CurveFeatureDefinitionBaseType(
 AttributesType * AttributesIn) :
  ShapeFeatureDefinitionBaseType(
    AttributesIn)
{
}

CurveFeatureDefinitionBaseType::CurveFeatureDefinitionBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn) :
  ShapeFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
}

CurveFeatureDefinitionBaseType::~CurveFeatureDefinitionBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void CurveFeatureDefinitionBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CurveFeatureDefinitionBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CurveFeatureDefinitionBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CurveFeatureDefinitionBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CurveFeatureDefinitionBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CurveFeatureDefinitionBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class CurveFeatureItemBaseType

*/

CurveFeatureItemBaseType::CurveFeatureItemBaseType() :
  ShapeFeatureItemBaseType()
{
}

CurveFeatureItemBaseType::CurveFeatureItemBaseType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  ShapeFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
}

CurveFeatureItemBaseType::CurveFeatureItemBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  ShapeFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
}

CurveFeatureItemBaseType::~CurveFeatureItemBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void CurveFeatureItemBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool CurveFeatureItemBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CurveFeatureItemBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CurveFeatureItemBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CurveFeatureItemBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CurveFeatureItemBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class CurveFeatureMeasurementBaseType

*/

CurveFeatureMeasurementBaseType::CurveFeatureMeasurementBaseType() :
  ShapeFeatureMeasurementBaseType()
{
}

CurveFeatureMeasurementBaseType::CurveFeatureMeasurementBaseType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn) :
  ShapeFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
}

CurveFeatureMeasurementBaseType::CurveFeatureMeasurementBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn) :
  ShapeFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
}

CurveFeatureMeasurementBaseType::~CurveFeatureMeasurementBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void CurveFeatureMeasurementBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CurveFeatureMeasurementBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CurveFeatureMeasurementBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CurveFeatureMeasurementBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CurveFeatureMeasurementBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CurveFeatureMeasurementBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class CurveFeatureNominalBaseType

*/

CurveFeatureNominalBaseType::CurveFeatureNominalBaseType() :
  ShapeFeatureNominalBaseType()
{
  SurfaceFeatureNominalId = 0;
}

CurveFeatureNominalBaseType::CurveFeatureNominalBaseType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn) :
  ShapeFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  SurfaceFeatureNominalId = SurfaceFeatureNominalIdIn;
}

CurveFeatureNominalBaseType::CurveFeatureNominalBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn) :
  ShapeFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  SurfaceFeatureNominalId = SurfaceFeatureNominalIdIn;
}

CurveFeatureNominalBaseType::~CurveFeatureNominalBaseType()
{
  #ifndef NODESTRUCT
  delete SurfaceFeatureNominalId;
  #endif
}

void CurveFeatureNominalBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (SurfaceFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SurfaceFeatureNominalId");
      SurfaceFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</SurfaceFeatureNominalId>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CurveFeatureNominalBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CurveFeatureNominalBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CurveFeatureNominalBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CurveFeatureNominalBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CurveFeatureNominalBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

QIFReferenceFullType * CurveFeatureNominalBaseType::getSurfaceFeatureNominalId()
{return SurfaceFeatureNominalId;}

void CurveFeatureNominalBaseType::setSurfaceFeatureNominalId(QIFReferenceFullType * SurfaceFeatureNominalIdIn)
{SurfaceFeatureNominalId = SurfaceFeatureNominalIdIn;}

/* ***************************************************************** */

/* class CylinderBestFitType

*/

CylinderBestFitType::CylinderBestFitType() :
  ConstructionMethodBaseType()
{
  n = 0;
  BaseFeature = 0;
}

CylinderBestFitType::CylinderBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = 0;
  BaseFeature = BaseFeatureIn;
}

CylinderBestFitType::CylinderBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 NaturalType * nIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = nIn;
  BaseFeature = BaseFeatureIn;
}

CylinderBestFitType::~CylinderBestFitType()
{
  #ifndef NODESTRUCT
  delete n;
  delete BaseFeature;
  #endif
}

void CylinderBestFitType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  {
    if (!BaseFeature)
      {
        fprintf(stderr, "BaseFeature list is missing\n");
        exit(1);
      }
    if (BaseFeature->size() == 0)
      {
        fprintf(stderr, "BaseFeature list is empty\n");
        exit(1);
      }
    if (BaseFeature->size() < 6)
      {
        fprintf(stderr,
                "size of BaseFeature list (%d) less than minimum required (6)\n",
                (int)BaseFeature->size());
        exit(1);
      }
    std::list<SequencedBaseFeatureType *>::iterator iter;
    for (iter = BaseFeature->begin();
         iter != BaseFeature->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<BaseFeature");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</BaseFeature>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool CylinderBestFitType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in CylinderBestFitType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in CylinderBestFitType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CylinderBestFitType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in CylinderBestFitType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * CylinderBestFitType::getn()
{return n;}

void CylinderBestFitType::setn(NaturalType * nIn)
{n = nIn;}

SequencedBaseFeatureTypeLisd * CylinderBestFitType::getBaseFeature()
{return BaseFeature;}

void CylinderBestFitType::setBaseFeature(SequencedBaseFeatureTypeLisd * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class CylinderCastType

*/

CylinderCastType::CylinderCastType() :
  ConstructionMethodBaseType()
{
  BaseFeature = 0;
}

CylinderCastType::CylinderCastType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeature = BaseFeatureIn;
}

CylinderCastType::~CylinderCastType()
{
  #ifndef NODESTRUCT
  delete BaseFeature;
  #endif
}

void CylinderCastType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeature");
  BaseFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * CylinderCastType::getBaseFeature()
{return BaseFeature;}

void CylinderCastType::setBaseFeature(BaseFeatureType * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class CylinderCheckedFeatureType

*/

CylinderCheckedFeatureType::CylinderCheckedFeatureType()
{
  CheckDetails = 0;
}

CylinderCheckedFeatureType::CylinderCheckedFeatureType(
 CylinderCheckedType * CheckDetailsIn)
{
  CheckDetails = CheckDetailsIn;
}

CylinderCheckedFeatureType::~CylinderCheckedFeatureType()
{
  #ifndef NODESTRUCT
  delete CheckDetails;
  #endif
}

void CylinderCheckedFeatureType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (CheckDetails)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CheckDetails");
      CheckDetails->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CheckDetails>\n");
    }
  doSpaces(-INDENT, outFile);
}

CylinderCheckedType * CylinderCheckedFeatureType::getCheckDetails()
{return CheckDetails;}

void CylinderCheckedFeatureType::setCheckDetails(CylinderCheckedType * CheckDetailsIn)
{CheckDetails = CheckDetailsIn;}

/* ***************************************************************** */

/* class CylinderCheckedType

*/

CylinderCheckedType::CylinderCheckedType()
{
  CylinderCheckedTypePair = 0;
}

CylinderCheckedType::CylinderCheckedType(
 CylinderCheckedTypeChoicePair * CylinderCheckedTypePairIn)
{
  CylinderCheckedTypePair = CylinderCheckedTypePairIn;
}

CylinderCheckedType::~CylinderCheckedType()
{
  #ifndef NODESTRUCT
  delete CylinderCheckedTypePair;
  #endif
}

void CylinderCheckedType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  CylinderCheckedTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

CylinderCheckedTypeChoicePair * CylinderCheckedType::getCylinderCheckedTypePair()
{return CylinderCheckedTypePair;}

void CylinderCheckedType::setCylinderCheckedTypePair(CylinderCheckedTypeChoicePair * CylinderCheckedTypePairIn)
{CylinderCheckedTypePair = CylinderCheckedTypePairIn;}
CylinderCheckedTypeChoicePair::CylinderCheckedTypeChoicePair() {}

CylinderCheckedTypeChoicePair::CylinderCheckedTypeChoicePair(
 whichOne CylinderCheckedTypeTypeIn,
 CylinderCheckedTypeVal * CylinderCheckedTypeValueIn)
{
  CylinderCheckedTypeType = CylinderCheckedTypeTypeIn;
  CylinderCheckedTypeValue = CylinderCheckedTypeValueIn;
}

CylinderCheckedTypeChoicePair::~CylinderCheckedTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (CylinderCheckedTypeType == MeasuredE)
    delete CylinderCheckedTypeValue->Measured;
  else if (CylinderCheckedTypeType == ConstructedE)
    delete CylinderCheckedTypeValue->Constructed;
  delete CylinderCheckedTypeValue;
  #endif
}

void CylinderCheckedTypeChoicePair::printSelf(FILE * outFile)
{
  if (CylinderCheckedTypeType == MeasuredE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Measured");
      CylinderCheckedTypeValue->Measured->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Measured>\n");
    }
  else if (CylinderCheckedTypeType == ConstructedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      CylinderCheckedTypeValue->Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
}

/* ***************************************************************** */

/* class CylinderConstructionMethodType

*/

CylinderConstructionMethodType::CylinderConstructionMethodType()
{
  CylinderConstructionMethodTypePair = 0;
}

CylinderConstructionMethodType::CylinderConstructionMethodType(
 CylinderConstructionMethodTypeChoicePair * CylinderConstructionMethodTypePairIn)
{
  CylinderConstructionMethodTypePair = CylinderConstructionMethodTypePairIn;
}

CylinderConstructionMethodType::~CylinderConstructionMethodType()
{
  #ifndef NODESTRUCT
  delete CylinderConstructionMethodTypePair;
  #endif
}

void CylinderConstructionMethodType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (CylinderConstructionMethodTypePair)
    {
      CylinderConstructionMethodTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

CylinderConstructionMethodTypeChoicePair * CylinderConstructionMethodType::getCylinderConstructionMethodTypePair()
{return CylinderConstructionMethodTypePair;}

void CylinderConstructionMethodType::setCylinderConstructionMethodTypePair(CylinderConstructionMethodTypeChoicePair * CylinderConstructionMethodTypePairIn)
{CylinderConstructionMethodTypePair = CylinderConstructionMethodTypePairIn;}
CylinderConstructionMethodTypeChoicePair::CylinderConstructionMethodTypeChoicePair() {}

CylinderConstructionMethodTypeChoicePair::CylinderConstructionMethodTypeChoicePair(
 whichOne CylinderConstructionMethodTypeTypeIn,
 CylinderConstructionMethodTypeVal * CylinderConstructionMethodTypeValueIn)
{
  CylinderConstructionMethodTypeType = CylinderConstructionMethodTypeTypeIn;
  CylinderConstructionMethodTypeValue = CylinderConstructionMethodTypeValueIn;
}

CylinderConstructionMethodTypeChoicePair::~CylinderConstructionMethodTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (CylinderConstructionMethodTypeType == BestFitE)
    delete CylinderConstructionMethodTypeValue->BestFit;
  else if (CylinderConstructionMethodTypeType == RecompensatedE)
    delete CylinderConstructionMethodTypeValue->Recompensated;
  else if (CylinderConstructionMethodTypeType == CopyE)
    delete CylinderConstructionMethodTypeValue->Copy;
  else if (CylinderConstructionMethodTypeType == CastE)
    delete CylinderConstructionMethodTypeValue->Cast;
  else if (CylinderConstructionMethodTypeType == TransformE)
    delete CylinderConstructionMethodTypeValue->Transform;
  else if (CylinderConstructionMethodTypeType == FromScanE)
    delete CylinderConstructionMethodTypeValue->FromScan;
  delete CylinderConstructionMethodTypeValue;
  #endif
}

void CylinderConstructionMethodTypeChoicePair::printSelf(FILE * outFile)
{
  if (CylinderConstructionMethodTypeType == BestFitE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BestFit");
      CylinderConstructionMethodTypeValue->BestFit->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BestFit>\n");
    }
  else if (CylinderConstructionMethodTypeType == RecompensatedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Recompensated");
      CylinderConstructionMethodTypeValue->Recompensated->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Recompensated>\n");
    }
  else if (CylinderConstructionMethodTypeType == CopyE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Copy");
      CylinderConstructionMethodTypeValue->Copy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Copy>\n");
    }
  else if (CylinderConstructionMethodTypeType == CastE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Cast");
      CylinderConstructionMethodTypeValue->Cast->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Cast>\n");
    }
  else if (CylinderConstructionMethodTypeType == TransformE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Transform");
      CylinderConstructionMethodTypeValue->Transform->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Transform>\n");
    }
  else if (CylinderConstructionMethodTypeType == FromScanE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FromScan");
      CylinderConstructionMethodTypeValue->FromScan->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FromScan>\n");
    }
}

/* ***************************************************************** */

/* class CylinderCopyType

*/

CylinderCopyType::CylinderCopyType() :
  ConstructionMethodBaseType()
{
  BaseCylinder = 0;
}

CylinderCopyType::CylinderCopyType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseCylinderIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseCylinder = BaseCylinderIn;
}

CylinderCopyType::~CylinderCopyType()
{
  #ifndef NODESTRUCT
  delete BaseCylinder;
  #endif
}

void CylinderCopyType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseCylinder");
  BaseCylinder->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseCylinder>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * CylinderCopyType::getBaseCylinder()
{return BaseCylinder;}

void CylinderCopyType::setBaseCylinder(BaseFeatureType * BaseCylinderIn)
{BaseCylinder = BaseCylinderIn;}

/* ***************************************************************** */

/* class CylinderFeatureDefinitionType

*/

CylinderFeatureDefinitionType::CylinderFeatureDefinitionType() :
  SurfaceFeatureDefinitionBaseType()
{
  InternalExternal = 0;
  Diameter = 0;
  Length = 0;
  Bottom = 0;
}

CylinderFeatureDefinitionType::CylinderFeatureDefinitionType(
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * DiameterIn,
 LinearValueType * LengthIn,
 BottomType * BottomIn) :
  SurfaceFeatureDefinitionBaseType(
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  Diameter = DiameterIn;
  Length = LengthIn;
  Bottom = BottomIn;
}

CylinderFeatureDefinitionType::CylinderFeatureDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * DiameterIn,
 LinearValueType * LengthIn,
 BottomType * BottomIn) :
  SurfaceFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  Diameter = DiameterIn;
  Length = LengthIn;
  Bottom = BottomIn;
}

CylinderFeatureDefinitionType::~CylinderFeatureDefinitionType()
{
  #ifndef NODESTRUCT
  delete InternalExternal;
  delete Diameter;
  delete Length;
  delete Bottom;
  #endif
}

void CylinderFeatureDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<InternalExternal");
  InternalExternal->printSelf(outFile);
  fprintf(outFile, "</InternalExternal>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Diameter");
  Diameter->printSelf(outFile);
  fprintf(outFile, "</Diameter>\n");
  if (Length)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Length");
      Length->printSelf(outFile);
      fprintf(outFile, "</Length>\n");
    }
  if (Bottom)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Bottom");
      Bottom->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Bottom>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CylinderFeatureDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CylinderFeatureDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CylinderFeatureDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CylinderFeatureDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CylinderFeatureDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

InternalExternalEnumType * CylinderFeatureDefinitionType::getInternalExternal()
{return InternalExternal;}

void CylinderFeatureDefinitionType::setInternalExternal(InternalExternalEnumType * InternalExternalIn)
{InternalExternal = InternalExternalIn;}

LinearValueType * CylinderFeatureDefinitionType::getDiameter()
{return Diameter;}

void CylinderFeatureDefinitionType::setDiameter(LinearValueType * DiameterIn)
{Diameter = DiameterIn;}

LinearValueType * CylinderFeatureDefinitionType::getLength()
{return Length;}

void CylinderFeatureDefinitionType::setLength(LinearValueType * LengthIn)
{Length = LengthIn;}

BottomType * CylinderFeatureDefinitionType::getBottom()
{return Bottom;}

void CylinderFeatureDefinitionType::setBottom(BottomType * BottomIn)
{Bottom = BottomIn;}

/* ***************************************************************** */

/* class CylinderFeatureItemType

*/

CylinderFeatureItemType::CylinderFeatureItemType() :
  SurfaceFeatureItemBaseType()
{
  DeterminationMode = 0;
}

CylinderFeatureItemType::CylinderFeatureItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 CylinderMeasurementDeterminationType * DeterminationModeIn) :
  SurfaceFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

CylinderFeatureItemType::CylinderFeatureItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 CylinderMeasurementDeterminationType * DeterminationModeIn) :
  SurfaceFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

CylinderFeatureItemType::~CylinderFeatureItemType()
{
  #ifndef NODESTRUCT
  delete DeterminationMode;
  #endif
}

void CylinderFeatureItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<DeterminationMode");
  DeterminationMode->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeterminationMode>\n");
  doSpaces(-INDENT, outFile);
}

bool CylinderFeatureItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CylinderFeatureItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CylinderFeatureItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CylinderFeatureItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CylinderFeatureItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

CylinderMeasurementDeterminationType * CylinderFeatureItemType::getDeterminationMode()
{return DeterminationMode;}

void CylinderFeatureItemType::setDeterminationMode(CylinderMeasurementDeterminationType * DeterminationModeIn)
{DeterminationMode = DeterminationModeIn;}

/* ***************************************************************** */

/* class CylinderFeatureMeasurementType

*/

CylinderFeatureMeasurementType::CylinderFeatureMeasurementType() :
  SurfaceFeatureMeasurementBaseType()
{
  Axis = 0;
  Diameter = 0;
  Length = 0;
  DiameterMin = 0;
  DiameterMax = 0;
  SweepMeasurementRange = 0;
  SweepFull = 0;
  Form = 0;
}

CylinderFeatureMeasurementType::CylinderFeatureMeasurementType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredAxisType * AxisIn,
 MeasuredLinearValueType * DiameterIn,
 MeasuredLinearValueType * LengthIn,
 MeasuredLinearValueType * DiameterMinIn,
 MeasuredLinearValueType * DiameterMaxIn,
 SweepType * SweepMeasurementRangeIn,
 SweepType * SweepFullIn,
 MeasuredLinearValueType * FormIn) :
  SurfaceFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Axis = AxisIn;
  Diameter = DiameterIn;
  Length = LengthIn;
  DiameterMin = DiameterMinIn;
  DiameterMax = DiameterMaxIn;
  SweepMeasurementRange = SweepMeasurementRangeIn;
  SweepFull = SweepFullIn;
  Form = FormIn;
}

CylinderFeatureMeasurementType::CylinderFeatureMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredAxisType * AxisIn,
 MeasuredLinearValueType * DiameterIn,
 MeasuredLinearValueType * LengthIn,
 MeasuredLinearValueType * DiameterMinIn,
 MeasuredLinearValueType * DiameterMaxIn,
 SweepType * SweepMeasurementRangeIn,
 SweepType * SweepFullIn,
 MeasuredLinearValueType * FormIn) :
  SurfaceFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Axis = AxisIn;
  Diameter = DiameterIn;
  Length = LengthIn;
  DiameterMin = DiameterMinIn;
  DiameterMax = DiameterMaxIn;
  SweepMeasurementRange = SweepMeasurementRangeIn;
  SweepFull = SweepFullIn;
  Form = FormIn;
}

CylinderFeatureMeasurementType::~CylinderFeatureMeasurementType()
{
  #ifndef NODESTRUCT
  delete Axis;
  delete Diameter;
  delete Length;
  delete DiameterMin;
  delete DiameterMax;
  delete SweepMeasurementRange;
  delete SweepFull;
  delete Form;
  #endif
}

void CylinderFeatureMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  if (Axis)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Axis");
      Axis->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Axis>\n");
    }
  if (Diameter)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Diameter");
      Diameter->printSelf(outFile);
      fprintf(outFile, "</Diameter>\n");
    }
  if (Length)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Length");
      Length->printSelf(outFile);
      fprintf(outFile, "</Length>\n");
    }
  if (DiameterMin)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DiameterMin");
      DiameterMin->printSelf(outFile);
      fprintf(outFile, "</DiameterMin>\n");
    }
  if (DiameterMax)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DiameterMax");
      DiameterMax->printSelf(outFile);
      fprintf(outFile, "</DiameterMax>\n");
    }
  if (SweepMeasurementRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SweepMeasurementRange");
      SweepMeasurementRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SweepMeasurementRange>\n");
    }
  if (SweepFull)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SweepFull");
      SweepFull->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SweepFull>\n");
    }
  if (Form)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Form");
      Form->printSelf(outFile);
      fprintf(outFile, "</Form>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CylinderFeatureMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CylinderFeatureMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CylinderFeatureMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CylinderFeatureMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CylinderFeatureMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredAxisType * CylinderFeatureMeasurementType::getAxis()
{return Axis;}

void CylinderFeatureMeasurementType::setAxis(MeasuredAxisType * AxisIn)
{Axis = AxisIn;}

MeasuredLinearValueType * CylinderFeatureMeasurementType::getDiameter()
{return Diameter;}

void CylinderFeatureMeasurementType::setDiameter(MeasuredLinearValueType * DiameterIn)
{Diameter = DiameterIn;}

MeasuredLinearValueType * CylinderFeatureMeasurementType::getLength()
{return Length;}

void CylinderFeatureMeasurementType::setLength(MeasuredLinearValueType * LengthIn)
{Length = LengthIn;}

MeasuredLinearValueType * CylinderFeatureMeasurementType::getDiameterMin()
{return DiameterMin;}

void CylinderFeatureMeasurementType::setDiameterMin(MeasuredLinearValueType * DiameterMinIn)
{DiameterMin = DiameterMinIn;}

MeasuredLinearValueType * CylinderFeatureMeasurementType::getDiameterMax()
{return DiameterMax;}

void CylinderFeatureMeasurementType::setDiameterMax(MeasuredLinearValueType * DiameterMaxIn)
{DiameterMax = DiameterMaxIn;}

SweepType * CylinderFeatureMeasurementType::getSweepMeasurementRange()
{return SweepMeasurementRange;}

void CylinderFeatureMeasurementType::setSweepMeasurementRange(SweepType * SweepMeasurementRangeIn)
{SweepMeasurementRange = SweepMeasurementRangeIn;}

SweepType * CylinderFeatureMeasurementType::getSweepFull()
{return SweepFull;}

void CylinderFeatureMeasurementType::setSweepFull(SweepType * SweepFullIn)
{SweepFull = SweepFullIn;}

MeasuredLinearValueType * CylinderFeatureMeasurementType::getForm()
{return Form;}

void CylinderFeatureMeasurementType::setForm(MeasuredLinearValueType * FormIn)
{Form = FormIn;}

/* ***************************************************************** */

/* class CylinderFeatureNominalType

*/

CylinderFeatureNominalType::CylinderFeatureNominalType() :
  SurfaceFeatureNominalBaseType()
{
  Axis = 0;
  Sweep = 0;
  Constructed = 0;
}

CylinderFeatureNominalType::CylinderFeatureNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 AxisType * AxisIn,
 SweepType * SweepIn,
 CylinderConstructionMethodType * ConstructedIn) :
  SurfaceFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  Axis = AxisIn;
  Sweep = SweepIn;
  Constructed = ConstructedIn;
}

CylinderFeatureNominalType::CylinderFeatureNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 AxisType * AxisIn,
 SweepType * SweepIn,
 CylinderConstructionMethodType * ConstructedIn) :
  SurfaceFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  Axis = AxisIn;
  Sweep = SweepIn;
  Constructed = ConstructedIn;
}

CylinderFeatureNominalType::~CylinderFeatureNominalType()
{
  #ifndef NODESTRUCT
  delete Axis;
  delete Sweep;
  delete Constructed;
  #endif
}

void CylinderFeatureNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Axis");
  Axis->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Axis>\n");
  if (Sweep)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Sweep");
      Sweep->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Sweep>\n");
    }
  if (Constructed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CylinderFeatureNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CylinderFeatureNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CylinderFeatureNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CylinderFeatureNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CylinderFeatureNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

AxisType * CylinderFeatureNominalType::getAxis()
{return Axis;}

void CylinderFeatureNominalType::setAxis(AxisType * AxisIn)
{Axis = AxisIn;}

SweepType * CylinderFeatureNominalType::getSweep()
{return Sweep;}

void CylinderFeatureNominalType::setSweep(SweepType * SweepIn)
{Sweep = SweepIn;}

CylinderConstructionMethodType * CylinderFeatureNominalType::getConstructed()
{return Constructed;}

void CylinderFeatureNominalType::setConstructed(CylinderConstructionMethodType * ConstructedIn)
{Constructed = ConstructedIn;}

/* ***************************************************************** */

/* class CylinderFromScanType

*/

CylinderFromScanType::CylinderFromScanType() :
  ConstructionMethodBaseType()
{
  SurfaceFeature = 0;
  SearchRadius = 0;
}

CylinderFromScanType::CylinderFromScanType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * SurfaceFeatureIn,
 LinearValueType * SearchRadiusIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  SurfaceFeature = SurfaceFeatureIn;
  SearchRadius = SearchRadiusIn;
}

CylinderFromScanType::~CylinderFromScanType()
{
  #ifndef NODESTRUCT
  delete SurfaceFeature;
  delete SearchRadius;
  #endif
}

void CylinderFromScanType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<SurfaceFeature");
  SurfaceFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</SurfaceFeature>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<SearchRadius");
  SearchRadius->printSelf(outFile);
  fprintf(outFile, "</SearchRadius>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * CylinderFromScanType::getSurfaceFeature()
{return SurfaceFeature;}

void CylinderFromScanType::setSurfaceFeature(BaseFeatureType * SurfaceFeatureIn)
{SurfaceFeature = SurfaceFeatureIn;}

LinearValueType * CylinderFromScanType::getSearchRadius()
{return SearchRadius;}

void CylinderFromScanType::setSearchRadius(LinearValueType * SearchRadiusIn)
{SearchRadius = SearchRadiusIn;}

/* ***************************************************************** */

/* class CylinderMeasurementDeterminationType

*/

CylinderMeasurementDeterminationType::CylinderMeasurementDeterminationType()
{
  CylinderMeasurementDeterminationTypePair = 0;
}

CylinderMeasurementDeterminationType::CylinderMeasurementDeterminationType(
 CylinderMeasurementDeterminationTypeChoicePair * CylinderMeasurementDeterminationTypePairIn)
{
  CylinderMeasurementDeterminationTypePair = CylinderMeasurementDeterminationTypePairIn;
}

CylinderMeasurementDeterminationType::~CylinderMeasurementDeterminationType()
{
  #ifndef NODESTRUCT
  delete CylinderMeasurementDeterminationTypePair;
  #endif
}

void CylinderMeasurementDeterminationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  CylinderMeasurementDeterminationTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

CylinderMeasurementDeterminationTypeChoicePair * CylinderMeasurementDeterminationType::getCylinderMeasurementDeterminationTypePair()
{return CylinderMeasurementDeterminationTypePair;}

void CylinderMeasurementDeterminationType::setCylinderMeasurementDeterminationTypePair(CylinderMeasurementDeterminationTypeChoicePair * CylinderMeasurementDeterminationTypePairIn)
{CylinderMeasurementDeterminationTypePair = CylinderMeasurementDeterminationTypePairIn;}
CylinderMeasurementDeterminationTypeChoicePair::CylinderMeasurementDeterminationTypeChoicePair() {}

CylinderMeasurementDeterminationTypeChoicePair::CylinderMeasurementDeterminationTypeChoicePair(
 whichOne CylinderMeasurementDeterminationTypeTypeIn,
 CylinderMeasurementDeterminationTypeVal * CylinderMeasurementDeterminationTypeValueIn)
{
  CylinderMeasurementDeterminationTypeType = CylinderMeasurementDeterminationTypeTypeIn;
  CylinderMeasurementDeterminationTypeValue = CylinderMeasurementDeterminationTypeValueIn;
}

CylinderMeasurementDeterminationTypeChoicePair::~CylinderMeasurementDeterminationTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (CylinderMeasurementDeterminationTypeType == CheckedE)
    delete CylinderMeasurementDeterminationTypeValue->Checked;
  else if (CylinderMeasurementDeterminationTypeType == SetE)
    delete CylinderMeasurementDeterminationTypeValue->Set;
  delete CylinderMeasurementDeterminationTypeValue;
  #endif
}

void CylinderMeasurementDeterminationTypeChoicePair::printSelf(FILE * outFile)
{
  if (CylinderMeasurementDeterminationTypeType == CheckedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Checked");
      CylinderMeasurementDeterminationTypeValue->Checked->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Checked>\n");
    }
  else if (CylinderMeasurementDeterminationTypeType == SetE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Set");
      CylinderMeasurementDeterminationTypeValue->Set->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class CylinderRecompType

*/

CylinderRecompType::CylinderRecompType() :
  ConstructionMethodBaseType()
{
  BaseFeaturePointList = 0;
}

CylinderRecompType::CylinderRecompType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeaturePointListType * BaseFeaturePointListIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeaturePointList = BaseFeaturePointListIn;
}

CylinderRecompType::~CylinderRecompType()
{
  #ifndef NODESTRUCT
  delete BaseFeaturePointList;
  #endif
}

void CylinderRecompType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeaturePointList");
  BaseFeaturePointList->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeaturePointList>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeaturePointListType * CylinderRecompType::getBaseFeaturePointList()
{return BaseFeaturePointList;}

void CylinderRecompType::setBaseFeaturePointList(BaseFeaturePointListType * BaseFeaturePointListIn)
{BaseFeaturePointList = BaseFeaturePointListIn;}

/* ***************************************************************** */

/* class CylinderTransformType

*/

CylinderTransformType::CylinderTransformType() :
  ConstructionMethodBaseType()
{
  BaseCylinder = 0;
  Transformation = 0;
}

CylinderTransformType::CylinderTransformType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseCylinderIn,
 TransformationReferenceType * TransformationIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseCylinder = BaseCylinderIn;
  Transformation = TransformationIn;
}

CylinderTransformType::~CylinderTransformType()
{
  #ifndef NODESTRUCT
  delete BaseCylinder;
  delete Transformation;
  #endif
}

void CylinderTransformType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseCylinder");
  BaseCylinder->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseCylinder>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Transformation");
  Transformation->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Transformation>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * CylinderTransformType::getBaseCylinder()
{return BaseCylinder;}

void CylinderTransformType::setBaseCylinder(BaseFeatureType * BaseCylinderIn)
{BaseCylinder = BaseCylinderIn;}

TransformationReferenceType * CylinderTransformType::getTransformation()
{return Transformation;}

void CylinderTransformType::setTransformation(TransformationReferenceType * TransformationIn)
{Transformation = TransformationIn;}

/* ***************************************************************** */

/* class CylindricalSegmentBestFitType

*/

CylindricalSegmentBestFitType::CylindricalSegmentBestFitType() :
  ConstructionMethodBaseType()
{
  n = 0;
  BaseFeature = 0;
}

CylindricalSegmentBestFitType::CylindricalSegmentBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = 0;
  BaseFeature = BaseFeatureIn;
}

CylindricalSegmentBestFitType::CylindricalSegmentBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 NaturalType * nIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = nIn;
  BaseFeature = BaseFeatureIn;
}

CylindricalSegmentBestFitType::~CylindricalSegmentBestFitType()
{
  #ifndef NODESTRUCT
  delete n;
  delete BaseFeature;
  #endif
}

void CylindricalSegmentBestFitType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  {
    if (!BaseFeature)
      {
        fprintf(stderr, "BaseFeature list is missing\n");
        exit(1);
      }
    if (BaseFeature->size() == 0)
      {
        fprintf(stderr, "BaseFeature list is empty\n");
        exit(1);
      }
    if (BaseFeature->size() < 6)
      {
        fprintf(stderr,
                "size of BaseFeature list (%d) less than minimum required (6)\n",
                (int)BaseFeature->size());
        exit(1);
      }
    std::list<SequencedBaseFeatureType *>::iterator iter;
    for (iter = BaseFeature->begin();
         iter != BaseFeature->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<BaseFeature");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</BaseFeature>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool CylindricalSegmentBestFitType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in CylindricalSegmentBestFitType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in CylindricalSegmentBestFitType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CylindricalSegmentBestFitType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in CylindricalSegmentBestFitType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * CylindricalSegmentBestFitType::getn()
{return n;}

void CylindricalSegmentBestFitType::setn(NaturalType * nIn)
{n = nIn;}

SequencedBaseFeatureTypeLisd * CylindricalSegmentBestFitType::getBaseFeature()
{return BaseFeature;}

void CylindricalSegmentBestFitType::setBaseFeature(SequencedBaseFeatureTypeLisd * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class CylindricalSegmentCastType

*/

CylindricalSegmentCastType::CylindricalSegmentCastType() :
  ConstructionMethodBaseType()
{
  BaseFeature = 0;
}

CylindricalSegmentCastType::CylindricalSegmentCastType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeature = BaseFeatureIn;
}

CylindricalSegmentCastType::~CylindricalSegmentCastType()
{
  #ifndef NODESTRUCT
  delete BaseFeature;
  #endif
}

void CylindricalSegmentCastType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeature");
  BaseFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * CylindricalSegmentCastType::getBaseFeature()
{return BaseFeature;}

void CylindricalSegmentCastType::setBaseFeature(BaseFeatureType * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class CylindricalSegmentCheckedFeatureType

*/

CylindricalSegmentCheckedFeatureType::CylindricalSegmentCheckedFeatureType()
{
  CheckDetails = 0;
}

CylindricalSegmentCheckedFeatureType::CylindricalSegmentCheckedFeatureType(
 CylindricalSegmentCheckedType * CheckDetailsIn)
{
  CheckDetails = CheckDetailsIn;
}

CylindricalSegmentCheckedFeatureType::~CylindricalSegmentCheckedFeatureType()
{
  #ifndef NODESTRUCT
  delete CheckDetails;
  #endif
}

void CylindricalSegmentCheckedFeatureType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (CheckDetails)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CheckDetails");
      CheckDetails->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CheckDetails>\n");
    }
  doSpaces(-INDENT, outFile);
}

CylindricalSegmentCheckedType * CylindricalSegmentCheckedFeatureType::getCheckDetails()
{return CheckDetails;}

void CylindricalSegmentCheckedFeatureType::setCheckDetails(CylindricalSegmentCheckedType * CheckDetailsIn)
{CheckDetails = CheckDetailsIn;}

/* ***************************************************************** */

/* class CylindricalSegmentCheckedType

*/

CylindricalSegmentCheckedType::CylindricalSegmentCheckedType()
{
  CylindricalSegmentCheckedTypePair = 0;
}

CylindricalSegmentCheckedType::CylindricalSegmentCheckedType(
 CylindricalSegmentCheckedTypeChoicePair * CylindricalSegmentCheckedTypePairIn)
{
  CylindricalSegmentCheckedTypePair = CylindricalSegmentCheckedTypePairIn;
}

CylindricalSegmentCheckedType::~CylindricalSegmentCheckedType()
{
  #ifndef NODESTRUCT
  delete CylindricalSegmentCheckedTypePair;
  #endif
}

void CylindricalSegmentCheckedType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  CylindricalSegmentCheckedTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

CylindricalSegmentCheckedTypeChoicePair * CylindricalSegmentCheckedType::getCylindricalSegmentCheckedTypePair()
{return CylindricalSegmentCheckedTypePair;}

void CylindricalSegmentCheckedType::setCylindricalSegmentCheckedTypePair(CylindricalSegmentCheckedTypeChoicePair * CylindricalSegmentCheckedTypePairIn)
{CylindricalSegmentCheckedTypePair = CylindricalSegmentCheckedTypePairIn;}
CylindricalSegmentCheckedTypeChoicePair::CylindricalSegmentCheckedTypeChoicePair() {}

CylindricalSegmentCheckedTypeChoicePair::CylindricalSegmentCheckedTypeChoicePair(
 whichOne CylindricalSegmentCheckedTypeTypeIn,
 CylindricalSegmentCheckedTypeVal * CylindricalSegmentCheckedTypeValueIn)
{
  CylindricalSegmentCheckedTypeType = CylindricalSegmentCheckedTypeTypeIn;
  CylindricalSegmentCheckedTypeValue = CylindricalSegmentCheckedTypeValueIn;
}

CylindricalSegmentCheckedTypeChoicePair::~CylindricalSegmentCheckedTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (CylindricalSegmentCheckedTypeType == MeasuredE)
    delete CylindricalSegmentCheckedTypeValue->Measured;
  else if (CylindricalSegmentCheckedTypeType == ConstructedE)
    delete CylindricalSegmentCheckedTypeValue->Constructed;
  delete CylindricalSegmentCheckedTypeValue;
  #endif
}

void CylindricalSegmentCheckedTypeChoicePair::printSelf(FILE * outFile)
{
  if (CylindricalSegmentCheckedTypeType == MeasuredE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Measured");
      CylindricalSegmentCheckedTypeValue->Measured->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Measured>\n");
    }
  else if (CylindricalSegmentCheckedTypeType == ConstructedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      CylindricalSegmentCheckedTypeValue->Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
}

/* ***************************************************************** */

/* class CylindricalSegmentConstructionMethodType

*/

CylindricalSegmentConstructionMethodType::CylindricalSegmentConstructionMethodType()
{
  CylindricalSegmentConstructionMethodTypePair = 0;
}

CylindricalSegmentConstructionMethodType::CylindricalSegmentConstructionMethodType(
 CylindricalSegmentConstructionMethodTypeChoicePair * CylindricalSegmentConstructionMethodTypePairIn)
{
  CylindricalSegmentConstructionMethodTypePair = CylindricalSegmentConstructionMethodTypePairIn;
}

CylindricalSegmentConstructionMethodType::~CylindricalSegmentConstructionMethodType()
{
  #ifndef NODESTRUCT
  delete CylindricalSegmentConstructionMethodTypePair;
  #endif
}

void CylindricalSegmentConstructionMethodType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (CylindricalSegmentConstructionMethodTypePair)
    {
      CylindricalSegmentConstructionMethodTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

CylindricalSegmentConstructionMethodTypeChoicePair * CylindricalSegmentConstructionMethodType::getCylindricalSegmentConstructionMethodTypePair()
{return CylindricalSegmentConstructionMethodTypePair;}

void CylindricalSegmentConstructionMethodType::setCylindricalSegmentConstructionMethodTypePair(CylindricalSegmentConstructionMethodTypeChoicePair * CylindricalSegmentConstructionMethodTypePairIn)
{CylindricalSegmentConstructionMethodTypePair = CylindricalSegmentConstructionMethodTypePairIn;}
CylindricalSegmentConstructionMethodTypeChoicePair::CylindricalSegmentConstructionMethodTypeChoicePair() {}

CylindricalSegmentConstructionMethodTypeChoicePair::CylindricalSegmentConstructionMethodTypeChoicePair(
 whichOne CylindricalSegmentConstructionMethodTypeTypeIn,
 CylindricalSegmentConstructionMethodTypeVal * CylindricalSegmentConstructionMethodTypeValueIn)
{
  CylindricalSegmentConstructionMethodTypeType = CylindricalSegmentConstructionMethodTypeTypeIn;
  CylindricalSegmentConstructionMethodTypeValue = CylindricalSegmentConstructionMethodTypeValueIn;
}

CylindricalSegmentConstructionMethodTypeChoicePair::~CylindricalSegmentConstructionMethodTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (CylindricalSegmentConstructionMethodTypeType == BestFitE)
    delete CylindricalSegmentConstructionMethodTypeValue->BestFit;
  else if (CylindricalSegmentConstructionMethodTypeType == RecompensatedE)
    delete CylindricalSegmentConstructionMethodTypeValue->Recompensated;
  else if (CylindricalSegmentConstructionMethodTypeType == CopyE)
    delete CylindricalSegmentConstructionMethodTypeValue->Copy;
  else if (CylindricalSegmentConstructionMethodTypeType == CastE)
    delete CylindricalSegmentConstructionMethodTypeValue->Cast;
  else if (CylindricalSegmentConstructionMethodTypeType == TransformE)
    delete CylindricalSegmentConstructionMethodTypeValue->Transform;
  delete CylindricalSegmentConstructionMethodTypeValue;
  #endif
}

void CylindricalSegmentConstructionMethodTypeChoicePair::printSelf(FILE * outFile)
{
  if (CylindricalSegmentConstructionMethodTypeType == BestFitE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BestFit");
      CylindricalSegmentConstructionMethodTypeValue->BestFit->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BestFit>\n");
    }
  else if (CylindricalSegmentConstructionMethodTypeType == RecompensatedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Recompensated");
      CylindricalSegmentConstructionMethodTypeValue->Recompensated->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Recompensated>\n");
    }
  else if (CylindricalSegmentConstructionMethodTypeType == CopyE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Copy");
      CylindricalSegmentConstructionMethodTypeValue->Copy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Copy>\n");
    }
  else if (CylindricalSegmentConstructionMethodTypeType == CastE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Cast");
      CylindricalSegmentConstructionMethodTypeValue->Cast->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Cast>\n");
    }
  else if (CylindricalSegmentConstructionMethodTypeType == TransformE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Transform");
      CylindricalSegmentConstructionMethodTypeValue->Transform->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Transform>\n");
    }
}

/* ***************************************************************** */

/* class CylindricalSegmentCopyType

*/

CylindricalSegmentCopyType::CylindricalSegmentCopyType() :
  ConstructionMethodBaseType()
{
  BaseCylindricalSegment = 0;
}

CylindricalSegmentCopyType::CylindricalSegmentCopyType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseCylindricalSegmentIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseCylindricalSegment = BaseCylindricalSegmentIn;
}

CylindricalSegmentCopyType::~CylindricalSegmentCopyType()
{
  #ifndef NODESTRUCT
  delete BaseCylindricalSegment;
  #endif
}

void CylindricalSegmentCopyType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseCylindricalSegment");
  BaseCylindricalSegment->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseCylindricalSegment>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * CylindricalSegmentCopyType::getBaseCylindricalSegment()
{return BaseCylindricalSegment;}

void CylindricalSegmentCopyType::setBaseCylindricalSegment(BaseFeatureType * BaseCylindricalSegmentIn)
{BaseCylindricalSegment = BaseCylindricalSegmentIn;}

/* ***************************************************************** */

/* class CylindricalSegmentFeatureDefinitionType

*/

CylindricalSegmentFeatureDefinitionType::CylindricalSegmentFeatureDefinitionType() :
  SurfaceFeatureDefinitionBaseType()
{
  InternalExternal = 0;
  Diameter = 0;
  Length = 0;
  Bottom = 0;
}

CylindricalSegmentFeatureDefinitionType::CylindricalSegmentFeatureDefinitionType(
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * DiameterIn,
 LinearValueType * LengthIn,
 BottomType * BottomIn) :
  SurfaceFeatureDefinitionBaseType(
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  Diameter = DiameterIn;
  Length = LengthIn;
  Bottom = BottomIn;
}

CylindricalSegmentFeatureDefinitionType::CylindricalSegmentFeatureDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * DiameterIn,
 LinearValueType * LengthIn,
 BottomType * BottomIn) :
  SurfaceFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  Diameter = DiameterIn;
  Length = LengthIn;
  Bottom = BottomIn;
}

CylindricalSegmentFeatureDefinitionType::~CylindricalSegmentFeatureDefinitionType()
{
  #ifndef NODESTRUCT
  delete InternalExternal;
  delete Diameter;
  delete Length;
  delete Bottom;
  #endif
}

void CylindricalSegmentFeatureDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<InternalExternal");
  InternalExternal->printSelf(outFile);
  fprintf(outFile, "</InternalExternal>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Diameter");
  Diameter->printSelf(outFile);
  fprintf(outFile, "</Diameter>\n");
  if (Length)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Length");
      Length->printSelf(outFile);
      fprintf(outFile, "</Length>\n");
    }
  if (Bottom)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Bottom");
      Bottom->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Bottom>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CylindricalSegmentFeatureDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CylindricalSegmentFeatureDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CylindricalSegmentFeatureDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CylindricalSegmentFeatureDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CylindricalSegmentFeatureDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

InternalExternalEnumType * CylindricalSegmentFeatureDefinitionType::getInternalExternal()
{return InternalExternal;}

void CylindricalSegmentFeatureDefinitionType::setInternalExternal(InternalExternalEnumType * InternalExternalIn)
{InternalExternal = InternalExternalIn;}

LinearValueType * CylindricalSegmentFeatureDefinitionType::getDiameter()
{return Diameter;}

void CylindricalSegmentFeatureDefinitionType::setDiameter(LinearValueType * DiameterIn)
{Diameter = DiameterIn;}

LinearValueType * CylindricalSegmentFeatureDefinitionType::getLength()
{return Length;}

void CylindricalSegmentFeatureDefinitionType::setLength(LinearValueType * LengthIn)
{Length = LengthIn;}

BottomType * CylindricalSegmentFeatureDefinitionType::getBottom()
{return Bottom;}

void CylindricalSegmentFeatureDefinitionType::setBottom(BottomType * BottomIn)
{Bottom = BottomIn;}

/* ***************************************************************** */

/* class CylindricalSegmentFeatureItemType

*/

CylindricalSegmentFeatureItemType::CylindricalSegmentFeatureItemType() :
  SurfaceFeatureItemBaseType()
{
  DeterminationMode = 0;
}

CylindricalSegmentFeatureItemType::CylindricalSegmentFeatureItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 CylindricalSegmentMeasurementDeterminationType * DeterminationModeIn) :
  SurfaceFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

CylindricalSegmentFeatureItemType::CylindricalSegmentFeatureItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 CylindricalSegmentMeasurementDeterminationType * DeterminationModeIn) :
  SurfaceFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

CylindricalSegmentFeatureItemType::~CylindricalSegmentFeatureItemType()
{
  #ifndef NODESTRUCT
  delete DeterminationMode;
  #endif
}

void CylindricalSegmentFeatureItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<DeterminationMode");
  DeterminationMode->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeterminationMode>\n");
  doSpaces(-INDENT, outFile);
}

bool CylindricalSegmentFeatureItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CylindricalSegmentFeatureItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CylindricalSegmentFeatureItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CylindricalSegmentFeatureItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CylindricalSegmentFeatureItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

CylindricalSegmentMeasurementDeterminationType * CylindricalSegmentFeatureItemType::getDeterminationMode()
{return DeterminationMode;}

void CylindricalSegmentFeatureItemType::setDeterminationMode(CylindricalSegmentMeasurementDeterminationType * DeterminationModeIn)
{DeterminationMode = DeterminationModeIn;}

/* ***************************************************************** */

/* class CylindricalSegmentFeatureMeasurementType

*/

CylindricalSegmentFeatureMeasurementType::CylindricalSegmentFeatureMeasurementType() :
  SurfaceFeatureMeasurementBaseType()
{
  Axis = 0;
  Diameter = 0;
  Length = 0;
  DiameterMin = 0;
  DiameterMax = 0;
  SweepMeasurementRange = 0;
  SweepFull = 0;
  Form = 0;
}

CylindricalSegmentFeatureMeasurementType::CylindricalSegmentFeatureMeasurementType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredAxisType * AxisIn,
 MeasuredLinearValueType * DiameterIn,
 MeasuredLinearValueType * LengthIn,
 MeasuredLinearValueType * DiameterMinIn,
 MeasuredLinearValueType * DiameterMaxIn,
 SweepType * SweepMeasurementRangeIn,
 SweepType * SweepFullIn,
 MeasuredLinearValueType * FormIn) :
  SurfaceFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Axis = AxisIn;
  Diameter = DiameterIn;
  Length = LengthIn;
  DiameterMin = DiameterMinIn;
  DiameterMax = DiameterMaxIn;
  SweepMeasurementRange = SweepMeasurementRangeIn;
  SweepFull = SweepFullIn;
  Form = FormIn;
}

CylindricalSegmentFeatureMeasurementType::CylindricalSegmentFeatureMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredAxisType * AxisIn,
 MeasuredLinearValueType * DiameterIn,
 MeasuredLinearValueType * LengthIn,
 MeasuredLinearValueType * DiameterMinIn,
 MeasuredLinearValueType * DiameterMaxIn,
 SweepType * SweepMeasurementRangeIn,
 SweepType * SweepFullIn,
 MeasuredLinearValueType * FormIn) :
  SurfaceFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Axis = AxisIn;
  Diameter = DiameterIn;
  Length = LengthIn;
  DiameterMin = DiameterMinIn;
  DiameterMax = DiameterMaxIn;
  SweepMeasurementRange = SweepMeasurementRangeIn;
  SweepFull = SweepFullIn;
  Form = FormIn;
}

CylindricalSegmentFeatureMeasurementType::~CylindricalSegmentFeatureMeasurementType()
{
  #ifndef NODESTRUCT
  delete Axis;
  delete Diameter;
  delete Length;
  delete DiameterMin;
  delete DiameterMax;
  delete SweepMeasurementRange;
  delete SweepFull;
  delete Form;
  #endif
}

void CylindricalSegmentFeatureMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  if (Axis)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Axis");
      Axis->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Axis>\n");
    }
  if (Diameter)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Diameter");
      Diameter->printSelf(outFile);
      fprintf(outFile, "</Diameter>\n");
    }
  if (Length)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Length");
      Length->printSelf(outFile);
      fprintf(outFile, "</Length>\n");
    }
  if (DiameterMin)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DiameterMin");
      DiameterMin->printSelf(outFile);
      fprintf(outFile, "</DiameterMin>\n");
    }
  if (DiameterMax)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DiameterMax");
      DiameterMax->printSelf(outFile);
      fprintf(outFile, "</DiameterMax>\n");
    }
  if (SweepMeasurementRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SweepMeasurementRange");
      SweepMeasurementRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SweepMeasurementRange>\n");
    }
  if (SweepFull)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SweepFull");
      SweepFull->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SweepFull>\n");
    }
  if (Form)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Form");
      Form->printSelf(outFile);
      fprintf(outFile, "</Form>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CylindricalSegmentFeatureMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CylindricalSegmentFeatureMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CylindricalSegmentFeatureMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CylindricalSegmentFeatureMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CylindricalSegmentFeatureMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredAxisType * CylindricalSegmentFeatureMeasurementType::getAxis()
{return Axis;}

void CylindricalSegmentFeatureMeasurementType::setAxis(MeasuredAxisType * AxisIn)
{Axis = AxisIn;}

MeasuredLinearValueType * CylindricalSegmentFeatureMeasurementType::getDiameter()
{return Diameter;}

void CylindricalSegmentFeatureMeasurementType::setDiameter(MeasuredLinearValueType * DiameterIn)
{Diameter = DiameterIn;}

MeasuredLinearValueType * CylindricalSegmentFeatureMeasurementType::getLength()
{return Length;}

void CylindricalSegmentFeatureMeasurementType::setLength(MeasuredLinearValueType * LengthIn)
{Length = LengthIn;}

MeasuredLinearValueType * CylindricalSegmentFeatureMeasurementType::getDiameterMin()
{return DiameterMin;}

void CylindricalSegmentFeatureMeasurementType::setDiameterMin(MeasuredLinearValueType * DiameterMinIn)
{DiameterMin = DiameterMinIn;}

MeasuredLinearValueType * CylindricalSegmentFeatureMeasurementType::getDiameterMax()
{return DiameterMax;}

void CylindricalSegmentFeatureMeasurementType::setDiameterMax(MeasuredLinearValueType * DiameterMaxIn)
{DiameterMax = DiameterMaxIn;}

SweepType * CylindricalSegmentFeatureMeasurementType::getSweepMeasurementRange()
{return SweepMeasurementRange;}

void CylindricalSegmentFeatureMeasurementType::setSweepMeasurementRange(SweepType * SweepMeasurementRangeIn)
{SweepMeasurementRange = SweepMeasurementRangeIn;}

SweepType * CylindricalSegmentFeatureMeasurementType::getSweepFull()
{return SweepFull;}

void CylindricalSegmentFeatureMeasurementType::setSweepFull(SweepType * SweepFullIn)
{SweepFull = SweepFullIn;}

MeasuredLinearValueType * CylindricalSegmentFeatureMeasurementType::getForm()
{return Form;}

void CylindricalSegmentFeatureMeasurementType::setForm(MeasuredLinearValueType * FormIn)
{Form = FormIn;}

/* ***************************************************************** */

/* class CylindricalSegmentFeatureNominalType

*/

CylindricalSegmentFeatureNominalType::CylindricalSegmentFeatureNominalType() :
  SurfaceFeatureNominalBaseType()
{
  Axis = 0;
  Sweep = 0;
  Constructed = 0;
}

CylindricalSegmentFeatureNominalType::CylindricalSegmentFeatureNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 AxisType * AxisIn,
 SweepType * SweepIn,
 CylindricalSegmentConstructionMethodType * ConstructedIn) :
  SurfaceFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  Axis = AxisIn;
  Sweep = SweepIn;
  Constructed = ConstructedIn;
}

CylindricalSegmentFeatureNominalType::CylindricalSegmentFeatureNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 AxisType * AxisIn,
 SweepType * SweepIn,
 CylindricalSegmentConstructionMethodType * ConstructedIn) :
  SurfaceFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  Axis = AxisIn;
  Sweep = SweepIn;
  Constructed = ConstructedIn;
}

CylindricalSegmentFeatureNominalType::~CylindricalSegmentFeatureNominalType()
{
  #ifndef NODESTRUCT
  delete Axis;
  delete Sweep;
  delete Constructed;
  #endif
}

void CylindricalSegmentFeatureNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Axis");
  Axis->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Axis>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Sweep");
  Sweep->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Sweep>\n");
  if (Constructed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CylindricalSegmentFeatureNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CylindricalSegmentFeatureNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CylindricalSegmentFeatureNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CylindricalSegmentFeatureNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CylindricalSegmentFeatureNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

AxisType * CylindricalSegmentFeatureNominalType::getAxis()
{return Axis;}

void CylindricalSegmentFeatureNominalType::setAxis(AxisType * AxisIn)
{Axis = AxisIn;}

SweepType * CylindricalSegmentFeatureNominalType::getSweep()
{return Sweep;}

void CylindricalSegmentFeatureNominalType::setSweep(SweepType * SweepIn)
{Sweep = SweepIn;}

CylindricalSegmentConstructionMethodType * CylindricalSegmentFeatureNominalType::getConstructed()
{return Constructed;}

void CylindricalSegmentFeatureNominalType::setConstructed(CylindricalSegmentConstructionMethodType * ConstructedIn)
{Constructed = ConstructedIn;}

/* ***************************************************************** */

/* class CylindricalSegmentMeasurementDeterminationType

*/

CylindricalSegmentMeasurementDeterminationType::CylindricalSegmentMeasurementDeterminationType()
{
  CylindricalSegmentMeasurementDeterminationTypePair = 0;
}

CylindricalSegmentMeasurementDeterminationType::CylindricalSegmentMeasurementDeterminationType(
 CylindricalSegmentMeasurementDeterminationTypeChoicePair * CylindricalSegmentMeasurementDeterminationTypePairIn)
{
  CylindricalSegmentMeasurementDeterminationTypePair = CylindricalSegmentMeasurementDeterminationTypePairIn;
}

CylindricalSegmentMeasurementDeterminationType::~CylindricalSegmentMeasurementDeterminationType()
{
  #ifndef NODESTRUCT
  delete CylindricalSegmentMeasurementDeterminationTypePair;
  #endif
}

void CylindricalSegmentMeasurementDeterminationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  CylindricalSegmentMeasurementDeterminationTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

CylindricalSegmentMeasurementDeterminationTypeChoicePair * CylindricalSegmentMeasurementDeterminationType::getCylindricalSegmentMeasurementDeterminationTypePair()
{return CylindricalSegmentMeasurementDeterminationTypePair;}

void CylindricalSegmentMeasurementDeterminationType::setCylindricalSegmentMeasurementDeterminationTypePair(CylindricalSegmentMeasurementDeterminationTypeChoicePair * CylindricalSegmentMeasurementDeterminationTypePairIn)
{CylindricalSegmentMeasurementDeterminationTypePair = CylindricalSegmentMeasurementDeterminationTypePairIn;}
CylindricalSegmentMeasurementDeterminationTypeChoicePair::CylindricalSegmentMeasurementDeterminationTypeChoicePair() {}

CylindricalSegmentMeasurementDeterminationTypeChoicePair::CylindricalSegmentMeasurementDeterminationTypeChoicePair(
 whichOne CylindricalSegmentMeasurementDeterminationTypeTypeIn,
 CylindricalSegmentMeasurementDeterminationTypeVal * CylindricalSegmentMeasurementDeterminationTypeValueIn)
{
  CylindricalSegmentMeasurementDeterminationTypeType = CylindricalSegmentMeasurementDeterminationTypeTypeIn;
  CylindricalSegmentMeasurementDeterminationTypeValue = CylindricalSegmentMeasurementDeterminationTypeValueIn;
}

CylindricalSegmentMeasurementDeterminationTypeChoicePair::~CylindricalSegmentMeasurementDeterminationTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (CylindricalSegmentMeasurementDeterminationTypeType == CheckedE)
    delete CylindricalSegmentMeasurementDeterminationTypeValue->Checked;
  else if (CylindricalSegmentMeasurementDeterminationTypeType == SetE)
    delete CylindricalSegmentMeasurementDeterminationTypeValue->Set;
  delete CylindricalSegmentMeasurementDeterminationTypeValue;
  #endif
}

void CylindricalSegmentMeasurementDeterminationTypeChoicePair::printSelf(FILE * outFile)
{
  if (CylindricalSegmentMeasurementDeterminationTypeType == CheckedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Checked");
      CylindricalSegmentMeasurementDeterminationTypeValue->Checked->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Checked>\n");
    }
  else if (CylindricalSegmentMeasurementDeterminationTypeType == SetE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Set");
      CylindricalSegmentMeasurementDeterminationTypeValue->Set->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class CylindricalSegmentRecompType

*/

CylindricalSegmentRecompType::CylindricalSegmentRecompType() :
  ConstructionMethodBaseType()
{
  BaseFeaturePointList = 0;
}

CylindricalSegmentRecompType::CylindricalSegmentRecompType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeaturePointListType * BaseFeaturePointListIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeaturePointList = BaseFeaturePointListIn;
}

CylindricalSegmentRecompType::~CylindricalSegmentRecompType()
{
  #ifndef NODESTRUCT
  delete BaseFeaturePointList;
  #endif
}

void CylindricalSegmentRecompType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeaturePointList");
  BaseFeaturePointList->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeaturePointList>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeaturePointListType * CylindricalSegmentRecompType::getBaseFeaturePointList()
{return BaseFeaturePointList;}

void CylindricalSegmentRecompType::setBaseFeaturePointList(BaseFeaturePointListType * BaseFeaturePointListIn)
{BaseFeaturePointList = BaseFeaturePointListIn;}

/* ***************************************************************** */

/* class CylindricalSegmentTransformType

*/

CylindricalSegmentTransformType::CylindricalSegmentTransformType() :
  ConstructionMethodBaseType()
{
  BaseCylindricalSegment = 0;
  Transformation = 0;
}

CylindricalSegmentTransformType::CylindricalSegmentTransformType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseCylindricalSegmentIn,
 TransformationReferenceType * TransformationIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseCylindricalSegment = BaseCylindricalSegmentIn;
  Transformation = TransformationIn;
}

CylindricalSegmentTransformType::~CylindricalSegmentTransformType()
{
  #ifndef NODESTRUCT
  delete BaseCylindricalSegment;
  delete Transformation;
  #endif
}

void CylindricalSegmentTransformType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseCylindricalSegment");
  BaseCylindricalSegment->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseCylindricalSegment>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Transformation");
  Transformation->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Transformation>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * CylindricalSegmentTransformType::getBaseCylindricalSegment()
{return BaseCylindricalSegment;}

void CylindricalSegmentTransformType::setBaseCylindricalSegment(BaseFeatureType * BaseCylindricalSegmentIn)
{BaseCylindricalSegment = BaseCylindricalSegmentIn;}

TransformationReferenceType * CylindricalSegmentTransformType::getTransformation()
{return Transformation;}

void CylindricalSegmentTransformType::setTransformation(TransformationReferenceType * TransformationIn)
{Transformation = TransformationIn;}

/* ***************************************************************** */

/* class DefiningPointsMeasurementType

*/

DefiningPointsMeasurementType::DefiningPointsMeasurementType()
{
  combinedUncertainty = 0;
  decimalPlaces = 0;
  linearUnit = 0;
  meanError = 0;
  n = 0;
  significantFigures = 0;
  validity = 0;
  xCombinedUncertainty = 0;
  xDecimalPlaces = 0;
  xMeanError = 0;
  xSignificantFigures = 0;
  xValidity = 0;
  yCombinedUncertainty = 0;
  yDecimalPlaces = 0;
  yMeanError = 0;
  ySignificantFigures = 0;
  yValidity = 0;
  zCombinedUncertainty = 0;
  zDecimalPlaces = 0;
  zMeanError = 0;
  zSignificantFigures = 0;
  zValidity = 0;
  DefiningPoint = 0;
}

DefiningPointsMeasurementType::DefiningPointsMeasurementType(
 DefiningPointMeasurementTypeLisd * DefiningPointIn)
{
  combinedUncertainty = 0;
  decimalPlaces = 0;
  linearUnit = 0;
  meanError = 0;
  n = 0;
  significantFigures = 0;
  validity = 0;
  xCombinedUncertainty = 0;
  xDecimalPlaces = 0;
  xMeanError = 0;
  xSignificantFigures = 0;
  xValidity = 0;
  yCombinedUncertainty = 0;
  yDecimalPlaces = 0;
  yMeanError = 0;
  ySignificantFigures = 0;
  yValidity = 0;
  zCombinedUncertainty = 0;
  zDecimalPlaces = 0;
  zMeanError = 0;
  zSignificantFigures = 0;
  zValidity = 0;
  DefiningPoint = DefiningPointIn;
}

DefiningPointsMeasurementType::DefiningPointsMeasurementType(
 XmlDecimal * combinedUncertaintyIn,
 XmlNonNegativeInteger * decimalPlacesIn,
 XmlToken * linearUnitIn,
 XmlDecimal * meanErrorIn,
 NaturalType * nIn,
 XmlNonNegativeInteger * significantFiguresIn,
 ValidityEnumType * validityIn,
 XmlDecimal * xCombinedUncertaintyIn,
 XmlNonNegativeInteger * xDecimalPlacesIn,
 XmlDecimal * xMeanErrorIn,
 XmlNonNegativeInteger * xSignificantFiguresIn,
 ValidityEnumType * xValidityIn,
 XmlDecimal * yCombinedUncertaintyIn,
 XmlNonNegativeInteger * yDecimalPlacesIn,
 XmlDecimal * yMeanErrorIn,
 XmlNonNegativeInteger * ySignificantFiguresIn,
 ValidityEnumType * yValidityIn,
 XmlDecimal * zCombinedUncertaintyIn,
 XmlNonNegativeInteger * zDecimalPlacesIn,
 XmlDecimal * zMeanErrorIn,
 XmlNonNegativeInteger * zSignificantFiguresIn,
 ValidityEnumType * zValidityIn,
 DefiningPointMeasurementTypeLisd * DefiningPointIn)
{
  combinedUncertainty = combinedUncertaintyIn;
  decimalPlaces = decimalPlacesIn;
  linearUnit = linearUnitIn;
  meanError = meanErrorIn;
  n = nIn;
  significantFigures = significantFiguresIn;
  validity = validityIn;
  xCombinedUncertainty = xCombinedUncertaintyIn;
  xDecimalPlaces = xDecimalPlacesIn;
  xMeanError = xMeanErrorIn;
  xSignificantFigures = xSignificantFiguresIn;
  xValidity = xValidityIn;
  yCombinedUncertainty = yCombinedUncertaintyIn;
  yDecimalPlaces = yDecimalPlacesIn;
  yMeanError = yMeanErrorIn;
  ySignificantFigures = ySignificantFiguresIn;
  yValidity = yValidityIn;
  zCombinedUncertainty = zCombinedUncertaintyIn;
  zDecimalPlaces = zDecimalPlacesIn;
  zMeanError = zMeanErrorIn;
  zSignificantFigures = zSignificantFiguresIn;
  zValidity = zValidityIn;
  DefiningPoint = DefiningPointIn;
}

DefiningPointsMeasurementType::~DefiningPointsMeasurementType()
{
  #ifndef NODESTRUCT
  delete combinedUncertainty;
  delete decimalPlaces;
  delete linearUnit;
  delete meanError;
  delete n;
  delete significantFigures;
  delete validity;
  delete xCombinedUncertainty;
  delete xDecimalPlaces;
  delete xMeanError;
  delete xSignificantFigures;
  delete xValidity;
  delete yCombinedUncertainty;
  delete yDecimalPlaces;
  delete yMeanError;
  delete ySignificantFigures;
  delete yValidity;
  delete zCombinedUncertainty;
  delete zDecimalPlaces;
  delete zMeanError;
  delete zSignificantFigures;
  delete zValidity;
  delete DefiningPoint;
  #endif
}

void DefiningPointsMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (combinedUncertainty)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "combinedUncertainty=\"");
      combinedUncertainty->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (decimalPlaces)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "decimalPlaces=\"");
      decimalPlaces->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (linearUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "linearUnit=\"");
      linearUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (meanError)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "meanError=\"");
      meanError->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  if (significantFigures)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "significantFigures=\"");
      significantFigures->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (validity)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "validity=\"");
      validity->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (xCombinedUncertainty)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "xCombinedUncertainty=\"");
      xCombinedUncertainty->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (xDecimalPlaces)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "xDecimalPlaces=\"");
      xDecimalPlaces->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (xMeanError)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "xMeanError=\"");
      xMeanError->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (xSignificantFigures)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "xSignificantFigures=\"");
      xSignificantFigures->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (xValidity)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "xValidity=\"");
      xValidity->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (yCombinedUncertainty)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "yCombinedUncertainty=\"");
      yCombinedUncertainty->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (yDecimalPlaces)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "yDecimalPlaces=\"");
      yDecimalPlaces->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (yMeanError)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "yMeanError=\"");
      yMeanError->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (ySignificantFigures)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "ySignificantFigures=\"");
      ySignificantFigures->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (yValidity)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "yValidity=\"");
      yValidity->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (zCombinedUncertainty)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "zCombinedUncertainty=\"");
      zCombinedUncertainty->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (zDecimalPlaces)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "zDecimalPlaces=\"");
      zDecimalPlaces->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (zMeanError)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "zMeanError=\"");
      zMeanError->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (zSignificantFigures)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "zSignificantFigures=\"");
      zSignificantFigures->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (zValidity)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "zValidity=\"");
      zValidity->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!DefiningPoint)
      {
        fprintf(stderr, "DefiningPoint list is missing\n");
        exit(1);
      }
    if (DefiningPoint->size() == 0)
      {
        fprintf(stderr, "DefiningPoint list is empty\n");
        exit(1);
      }
    if (DefiningPoint->size() < 1)
      {
        fprintf(stderr,
                "size of DefiningPoint list (%d) less than minimum required (1)\n",
                (int)DefiningPoint->size());
        exit(1);
      }
    std::list<DefiningPointMeasurementType *>::iterator iter;
    for (iter = DefiningPoint->begin();
         iter != DefiningPoint->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<DefiningPoint");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</DefiningPoint>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool DefiningPointsMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "combinedUncertainty")
        {
          XmlDecimal * combinedUncertaintyVal;
          if (this->combinedUncertainty)
            {
              fprintf(stderr, "two values for combinedUncertainty in DefiningPointsMeasurementType\n");
              returnValue = true;
              break;
            }
          combinedUncertaintyVal = new XmlDecimal(decl->getval().c_str());
          if (combinedUncertaintyVal->getbad())
            {
              delete combinedUncertaintyVal;
              fprintf(stderr, "bad value %s for combinedUncertainty in DefiningPointsMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->combinedUncertainty = combinedUncertaintyVal;
        }
      else if (decl->getname() == "decimalPlaces")
        {
          XmlNonNegativeInteger * decimalPlacesVal;
          if (this->decimalPlaces)
            {
              fprintf(stderr, "two values for decimalPlaces in DefiningPointsMeasurementType\n");
              returnValue = true;
              break;
            }
          decimalPlacesVal = new XmlNonNegativeInteger(decl->getval().c_str());
          if (decimalPlacesVal->getbad())
            {
              delete decimalPlacesVal;
              fprintf(stderr, "bad value %s for decimalPlaces in DefiningPointsMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->decimalPlaces = decimalPlacesVal;
        }
      else if (decl->getname() == "linearUnit")
        {
          XmlToken * linearUnitVal;
          if (this->linearUnit)
            {
              fprintf(stderr, "two values for linearUnit in DefiningPointsMeasurementType\n");
              returnValue = true;
              break;
            }
          linearUnitVal = new XmlToken(decl->getval().c_str());
          if (linearUnitVal->getbad())
            {
              delete linearUnitVal;
              fprintf(stderr, "bad value %s for linearUnit in DefiningPointsMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->linearUnit = linearUnitVal;
        }
      else if (decl->getname() == "meanError")
        {
          XmlDecimal * meanErrorVal;
          if (this->meanError)
            {
              fprintf(stderr, "two values for meanError in DefiningPointsMeasurementType\n");
              returnValue = true;
              break;
            }
          meanErrorVal = new XmlDecimal(decl->getval().c_str());
          if (meanErrorVal->getbad())
            {
              delete meanErrorVal;
              fprintf(stderr, "bad value %s for meanError in DefiningPointsMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->meanError = meanErrorVal;
        }
      else if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in DefiningPointsMeasurementType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in DefiningPointsMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else if (decl->getname() == "significantFigures")
        {
          XmlNonNegativeInteger * significantFiguresVal;
          if (this->significantFigures)
            {
              fprintf(stderr, "two values for significantFigures in DefiningPointsMeasurementType\n");
              returnValue = true;
              break;
            }
          significantFiguresVal = new XmlNonNegativeInteger(decl->getval().c_str());
          if (significantFiguresVal->getbad())
            {
              delete significantFiguresVal;
              fprintf(stderr, "bad value %s for significantFigures in DefiningPointsMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->significantFigures = significantFiguresVal;
        }
      else if (decl->getname() == "validity")
        {
          ValidityEnumType * validityVal;
          if (this->validity)
            {
              fprintf(stderr, "two values for validity in DefiningPointsMeasurementType\n");
              returnValue = true;
              break;
            }
          validityVal = new ValidityEnumType(decl->getval().c_str());
          if (validityVal->getbad())
            {
              delete validityVal;
              fprintf(stderr, "bad value %s for validity in DefiningPointsMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->validity = validityVal;
        }
      else if (decl->getname() == "xCombinedUncertainty")
        {
          XmlDecimal * xCombinedUncertaintyVal;
          if (this->xCombinedUncertainty)
            {
              fprintf(stderr, "two values for xCombinedUncertainty in DefiningPointsMeasurementType\n");
              returnValue = true;
              break;
            }
          xCombinedUncertaintyVal = new XmlDecimal(decl->getval().c_str());
          if (xCombinedUncertaintyVal->getbad())
            {
              delete xCombinedUncertaintyVal;
              fprintf(stderr, "bad value %s for xCombinedUncertainty in DefiningPointsMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->xCombinedUncertainty = xCombinedUncertaintyVal;
        }
      else if (decl->getname() == "xDecimalPlaces")
        {
          XmlNonNegativeInteger * xDecimalPlacesVal;
          if (this->xDecimalPlaces)
            {
              fprintf(stderr, "two values for xDecimalPlaces in DefiningPointsMeasurementType\n");
              returnValue = true;
              break;
            }
          xDecimalPlacesVal = new XmlNonNegativeInteger(decl->getval().c_str());
          if (xDecimalPlacesVal->getbad())
            {
              delete xDecimalPlacesVal;
              fprintf(stderr, "bad value %s for xDecimalPlaces in DefiningPointsMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->xDecimalPlaces = xDecimalPlacesVal;
        }
      else if (decl->getname() == "xMeanError")
        {
          XmlDecimal * xMeanErrorVal;
          if (this->xMeanError)
            {
              fprintf(stderr, "two values for xMeanError in DefiningPointsMeasurementType\n");
              returnValue = true;
              break;
            }
          xMeanErrorVal = new XmlDecimal(decl->getval().c_str());
          if (xMeanErrorVal->getbad())
            {
              delete xMeanErrorVal;
              fprintf(stderr, "bad value %s for xMeanError in DefiningPointsMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->xMeanError = xMeanErrorVal;
        }
      else if (decl->getname() == "xSignificantFigures")
        {
          XmlNonNegativeInteger * xSignificantFiguresVal;
          if (this->xSignificantFigures)
            {
              fprintf(stderr, "two values for xSignificantFigures in DefiningPointsMeasurementType\n");
              returnValue = true;
              break;
            }
          xSignificantFiguresVal = new XmlNonNegativeInteger(decl->getval().c_str());
          if (xSignificantFiguresVal->getbad())
            {
              delete xSignificantFiguresVal;
              fprintf(stderr, "bad value %s for xSignificantFigures in DefiningPointsMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->xSignificantFigures = xSignificantFiguresVal;
        }
      else if (decl->getname() == "xValidity")
        {
          ValidityEnumType * xValidityVal;
          if (this->xValidity)
            {
              fprintf(stderr, "two values for xValidity in DefiningPointsMeasurementType\n");
              returnValue = true;
              break;
            }
          xValidityVal = new ValidityEnumType(decl->getval().c_str());
          if (xValidityVal->getbad())
            {
              delete xValidityVal;
              fprintf(stderr, "bad value %s for xValidity in DefiningPointsMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->xValidity = xValidityVal;
        }
      else if (decl->getname() == "yCombinedUncertainty")
        {
          XmlDecimal * yCombinedUncertaintyVal;
          if (this->yCombinedUncertainty)
            {
              fprintf(stderr, "two values for yCombinedUncertainty in DefiningPointsMeasurementType\n");
              returnValue = true;
              break;
            }
          yCombinedUncertaintyVal = new XmlDecimal(decl->getval().c_str());
          if (yCombinedUncertaintyVal->getbad())
            {
              delete yCombinedUncertaintyVal;
              fprintf(stderr, "bad value %s for yCombinedUncertainty in DefiningPointsMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->yCombinedUncertainty = yCombinedUncertaintyVal;
        }
      else if (decl->getname() == "yDecimalPlaces")
        {
          XmlNonNegativeInteger * yDecimalPlacesVal;
          if (this->yDecimalPlaces)
            {
              fprintf(stderr, "two values for yDecimalPlaces in DefiningPointsMeasurementType\n");
              returnValue = true;
              break;
            }
          yDecimalPlacesVal = new XmlNonNegativeInteger(decl->getval().c_str());
          if (yDecimalPlacesVal->getbad())
            {
              delete yDecimalPlacesVal;
              fprintf(stderr, "bad value %s for yDecimalPlaces in DefiningPointsMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->yDecimalPlaces = yDecimalPlacesVal;
        }
      else if (decl->getname() == "yMeanError")
        {
          XmlDecimal * yMeanErrorVal;
          if (this->yMeanError)
            {
              fprintf(stderr, "two values for yMeanError in DefiningPointsMeasurementType\n");
              returnValue = true;
              break;
            }
          yMeanErrorVal = new XmlDecimal(decl->getval().c_str());
          if (yMeanErrorVal->getbad())
            {
              delete yMeanErrorVal;
              fprintf(stderr, "bad value %s for yMeanError in DefiningPointsMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->yMeanError = yMeanErrorVal;
        }
      else if (decl->getname() == "ySignificantFigures")
        {
          XmlNonNegativeInteger * ySignificantFiguresVal;
          if (this->ySignificantFigures)
            {
              fprintf(stderr, "two values for ySignificantFigures in DefiningPointsMeasurementType\n");
              returnValue = true;
              break;
            }
          ySignificantFiguresVal = new XmlNonNegativeInteger(decl->getval().c_str());
          if (ySignificantFiguresVal->getbad())
            {
              delete ySignificantFiguresVal;
              fprintf(stderr, "bad value %s for ySignificantFigures in DefiningPointsMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->ySignificantFigures = ySignificantFiguresVal;
        }
      else if (decl->getname() == "yValidity")
        {
          ValidityEnumType * yValidityVal;
          if (this->yValidity)
            {
              fprintf(stderr, "two values for yValidity in DefiningPointsMeasurementType\n");
              returnValue = true;
              break;
            }
          yValidityVal = new ValidityEnumType(decl->getval().c_str());
          if (yValidityVal->getbad())
            {
              delete yValidityVal;
              fprintf(stderr, "bad value %s for yValidity in DefiningPointsMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->yValidity = yValidityVal;
        }
      else if (decl->getname() == "zCombinedUncertainty")
        {
          XmlDecimal * zCombinedUncertaintyVal;
          if (this->zCombinedUncertainty)
            {
              fprintf(stderr, "two values for zCombinedUncertainty in DefiningPointsMeasurementType\n");
              returnValue = true;
              break;
            }
          zCombinedUncertaintyVal = new XmlDecimal(decl->getval().c_str());
          if (zCombinedUncertaintyVal->getbad())
            {
              delete zCombinedUncertaintyVal;
              fprintf(stderr, "bad value %s for zCombinedUncertainty in DefiningPointsMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->zCombinedUncertainty = zCombinedUncertaintyVal;
        }
      else if (decl->getname() == "zDecimalPlaces")
        {
          XmlNonNegativeInteger * zDecimalPlacesVal;
          if (this->zDecimalPlaces)
            {
              fprintf(stderr, "two values for zDecimalPlaces in DefiningPointsMeasurementType\n");
              returnValue = true;
              break;
            }
          zDecimalPlacesVal = new XmlNonNegativeInteger(decl->getval().c_str());
          if (zDecimalPlacesVal->getbad())
            {
              delete zDecimalPlacesVal;
              fprintf(stderr, "bad value %s for zDecimalPlaces in DefiningPointsMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->zDecimalPlaces = zDecimalPlacesVal;
        }
      else if (decl->getname() == "zMeanError")
        {
          XmlDecimal * zMeanErrorVal;
          if (this->zMeanError)
            {
              fprintf(stderr, "two values for zMeanError in DefiningPointsMeasurementType\n");
              returnValue = true;
              break;
            }
          zMeanErrorVal = new XmlDecimal(decl->getval().c_str());
          if (zMeanErrorVal->getbad())
            {
              delete zMeanErrorVal;
              fprintf(stderr, "bad value %s for zMeanError in DefiningPointsMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->zMeanError = zMeanErrorVal;
        }
      else if (decl->getname() == "zSignificantFigures")
        {
          XmlNonNegativeInteger * zSignificantFiguresVal;
          if (this->zSignificantFigures)
            {
              fprintf(stderr, "two values for zSignificantFigures in DefiningPointsMeasurementType\n");
              returnValue = true;
              break;
            }
          zSignificantFiguresVal = new XmlNonNegativeInteger(decl->getval().c_str());
          if (zSignificantFiguresVal->getbad())
            {
              delete zSignificantFiguresVal;
              fprintf(stderr, "bad value %s for zSignificantFigures in DefiningPointsMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->zSignificantFigures = zSignificantFiguresVal;
        }
      else if (decl->getname() == "zValidity")
        {
          ValidityEnumType * zValidityVal;
          if (this->zValidity)
            {
              fprintf(stderr, "two values for zValidity in DefiningPointsMeasurementType\n");
              returnValue = true;
              break;
            }
          zValidityVal = new ValidityEnumType(decl->getval().c_str());
          if (zValidityVal->getbad())
            {
              delete zValidityVal;
              fprintf(stderr, "bad value %s for zValidity in DefiningPointsMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->zValidity = zValidityVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in DefiningPointsMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in DefiningPointsMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->combinedUncertainty;
      this->combinedUncertainty = 0;
      delete this->decimalPlaces;
      this->decimalPlaces = 0;
      delete this->linearUnit;
      this->linearUnit = 0;
      delete this->meanError;
      this->meanError = 0;
      delete this->n;
      this->n = 0;
      delete this->significantFigures;
      this->significantFigures = 0;
      delete this->validity;
      this->validity = 0;
      delete this->xCombinedUncertainty;
      this->xCombinedUncertainty = 0;
      delete this->xDecimalPlaces;
      this->xDecimalPlaces = 0;
      delete this->xMeanError;
      this->xMeanError = 0;
      delete this->xSignificantFigures;
      this->xSignificantFigures = 0;
      delete this->xValidity;
      this->xValidity = 0;
      delete this->yCombinedUncertainty;
      this->yCombinedUncertainty = 0;
      delete this->yDecimalPlaces;
      this->yDecimalPlaces = 0;
      delete this->yMeanError;
      this->yMeanError = 0;
      delete this->ySignificantFigures;
      this->ySignificantFigures = 0;
      delete this->yValidity;
      this->yValidity = 0;
      delete this->zCombinedUncertainty;
      this->zCombinedUncertainty = 0;
      delete this->zDecimalPlaces;
      this->zDecimalPlaces = 0;
      delete this->zMeanError;
      this->zMeanError = 0;
      delete this->zSignificantFigures;
      this->zSignificantFigures = 0;
      delete this->zValidity;
      this->zValidity = 0;
    }
  return returnValue;
}

XmlDecimal * DefiningPointsMeasurementType::getcombinedUncertainty()
{return combinedUncertainty;}

void DefiningPointsMeasurementType::setcombinedUncertainty(XmlDecimal * combinedUncertaintyIn)
{combinedUncertainty = combinedUncertaintyIn;}

XmlNonNegativeInteger * DefiningPointsMeasurementType::getdecimalPlaces()
{return decimalPlaces;}

void DefiningPointsMeasurementType::setdecimalPlaces(XmlNonNegativeInteger * decimalPlacesIn)
{decimalPlaces = decimalPlacesIn;}

XmlToken * DefiningPointsMeasurementType::getlinearUnit()
{return linearUnit;}

void DefiningPointsMeasurementType::setlinearUnit(XmlToken * linearUnitIn)
{linearUnit = linearUnitIn;}

XmlDecimal * DefiningPointsMeasurementType::getmeanError()
{return meanError;}

void DefiningPointsMeasurementType::setmeanError(XmlDecimal * meanErrorIn)
{meanError = meanErrorIn;}

NaturalType * DefiningPointsMeasurementType::getn()
{return n;}

void DefiningPointsMeasurementType::setn(NaturalType * nIn)
{n = nIn;}

XmlNonNegativeInteger * DefiningPointsMeasurementType::getsignificantFigures()
{return significantFigures;}

void DefiningPointsMeasurementType::setsignificantFigures(XmlNonNegativeInteger * significantFiguresIn)
{significantFigures = significantFiguresIn;}

ValidityEnumType * DefiningPointsMeasurementType::getvalidity()
{return validity;}

void DefiningPointsMeasurementType::setvalidity(ValidityEnumType * validityIn)
{validity = validityIn;}

XmlDecimal * DefiningPointsMeasurementType::getxCombinedUncertainty()
{return xCombinedUncertainty;}

void DefiningPointsMeasurementType::setxCombinedUncertainty(XmlDecimal * xCombinedUncertaintyIn)
{xCombinedUncertainty = xCombinedUncertaintyIn;}

XmlNonNegativeInteger * DefiningPointsMeasurementType::getxDecimalPlaces()
{return xDecimalPlaces;}

void DefiningPointsMeasurementType::setxDecimalPlaces(XmlNonNegativeInteger * xDecimalPlacesIn)
{xDecimalPlaces = xDecimalPlacesIn;}

XmlDecimal * DefiningPointsMeasurementType::getxMeanError()
{return xMeanError;}

void DefiningPointsMeasurementType::setxMeanError(XmlDecimal * xMeanErrorIn)
{xMeanError = xMeanErrorIn;}

XmlNonNegativeInteger * DefiningPointsMeasurementType::getxSignificantFigures()
{return xSignificantFigures;}

void DefiningPointsMeasurementType::setxSignificantFigures(XmlNonNegativeInteger * xSignificantFiguresIn)
{xSignificantFigures = xSignificantFiguresIn;}

ValidityEnumType * DefiningPointsMeasurementType::getxValidity()
{return xValidity;}

void DefiningPointsMeasurementType::setxValidity(ValidityEnumType * xValidityIn)
{xValidity = xValidityIn;}

XmlDecimal * DefiningPointsMeasurementType::getyCombinedUncertainty()
{return yCombinedUncertainty;}

void DefiningPointsMeasurementType::setyCombinedUncertainty(XmlDecimal * yCombinedUncertaintyIn)
{yCombinedUncertainty = yCombinedUncertaintyIn;}

XmlNonNegativeInteger * DefiningPointsMeasurementType::getyDecimalPlaces()
{return yDecimalPlaces;}

void DefiningPointsMeasurementType::setyDecimalPlaces(XmlNonNegativeInteger * yDecimalPlacesIn)
{yDecimalPlaces = yDecimalPlacesIn;}

XmlDecimal * DefiningPointsMeasurementType::getyMeanError()
{return yMeanError;}

void DefiningPointsMeasurementType::setyMeanError(XmlDecimal * yMeanErrorIn)
{yMeanError = yMeanErrorIn;}

XmlNonNegativeInteger * DefiningPointsMeasurementType::getySignificantFigures()
{return ySignificantFigures;}

void DefiningPointsMeasurementType::setySignificantFigures(XmlNonNegativeInteger * ySignificantFiguresIn)
{ySignificantFigures = ySignificantFiguresIn;}

ValidityEnumType * DefiningPointsMeasurementType::getyValidity()
{return yValidity;}

void DefiningPointsMeasurementType::setyValidity(ValidityEnumType * yValidityIn)
{yValidity = yValidityIn;}

XmlDecimal * DefiningPointsMeasurementType::getzCombinedUncertainty()
{return zCombinedUncertainty;}

void DefiningPointsMeasurementType::setzCombinedUncertainty(XmlDecimal * zCombinedUncertaintyIn)
{zCombinedUncertainty = zCombinedUncertaintyIn;}

XmlNonNegativeInteger * DefiningPointsMeasurementType::getzDecimalPlaces()
{return zDecimalPlaces;}

void DefiningPointsMeasurementType::setzDecimalPlaces(XmlNonNegativeInteger * zDecimalPlacesIn)
{zDecimalPlaces = zDecimalPlacesIn;}

XmlDecimal * DefiningPointsMeasurementType::getzMeanError()
{return zMeanError;}

void DefiningPointsMeasurementType::setzMeanError(XmlDecimal * zMeanErrorIn)
{zMeanError = zMeanErrorIn;}

XmlNonNegativeInteger * DefiningPointsMeasurementType::getzSignificantFigures()
{return zSignificantFigures;}

void DefiningPointsMeasurementType::setzSignificantFigures(XmlNonNegativeInteger * zSignificantFiguresIn)
{zSignificantFigures = zSignificantFiguresIn;}

ValidityEnumType * DefiningPointsMeasurementType::getzValidity()
{return zValidity;}

void DefiningPointsMeasurementType::setzValidity(ValidityEnumType * zValidityIn)
{zValidity = zValidityIn;}

DefiningPointMeasurementTypeLisd * DefiningPointsMeasurementType::getDefiningPoint()
{return DefiningPoint;}

void DefiningPointsMeasurementType::setDefiningPoint(DefiningPointMeasurementTypeLisd * DefiningPointIn)
{DefiningPoint = DefiningPointIn;}

/* ***************************************************************** */

/* class DefiningPointsNominalType

*/

DefiningPointsNominalType::DefiningPointsNominalType()
{
  decimalPlaces = 0;
  linearUnit = 0;
  n = 0;
  significantFigures = 0;
  validity = 0;
  xDecimalPlaces = 0;
  xSignificantFigures = 0;
  xValidity = 0;
  yDecimalPlaces = 0;
  ySignificantFigures = 0;
  yValidity = 0;
  zDecimalPlaces = 0;
  zSignificantFigures = 0;
  zValidity = 0;
  DefiningPoint = 0;
}

DefiningPointsNominalType::DefiningPointsNominalType(
 DefiningPointNominalTypeLisd * DefiningPointIn)
{
  decimalPlaces = 0;
  linearUnit = 0;
  n = 0;
  significantFigures = 0;
  validity = 0;
  xDecimalPlaces = 0;
  xSignificantFigures = 0;
  xValidity = 0;
  yDecimalPlaces = 0;
  ySignificantFigures = 0;
  yValidity = 0;
  zDecimalPlaces = 0;
  zSignificantFigures = 0;
  zValidity = 0;
  DefiningPoint = DefiningPointIn;
}

DefiningPointsNominalType::DefiningPointsNominalType(
 XmlNonNegativeInteger * decimalPlacesIn,
 XmlToken * linearUnitIn,
 NaturalType * nIn,
 XmlNonNegativeInteger * significantFiguresIn,
 ValidityEnumType * validityIn,
 XmlNonNegativeInteger * xDecimalPlacesIn,
 XmlNonNegativeInteger * xSignificantFiguresIn,
 ValidityEnumType * xValidityIn,
 XmlNonNegativeInteger * yDecimalPlacesIn,
 XmlNonNegativeInteger * ySignificantFiguresIn,
 ValidityEnumType * yValidityIn,
 XmlNonNegativeInteger * zDecimalPlacesIn,
 XmlNonNegativeInteger * zSignificantFiguresIn,
 ValidityEnumType * zValidityIn,
 DefiningPointNominalTypeLisd * DefiningPointIn)
{
  decimalPlaces = decimalPlacesIn;
  linearUnit = linearUnitIn;
  n = nIn;
  significantFigures = significantFiguresIn;
  validity = validityIn;
  xDecimalPlaces = xDecimalPlacesIn;
  xSignificantFigures = xSignificantFiguresIn;
  xValidity = xValidityIn;
  yDecimalPlaces = yDecimalPlacesIn;
  ySignificantFigures = ySignificantFiguresIn;
  yValidity = yValidityIn;
  zDecimalPlaces = zDecimalPlacesIn;
  zSignificantFigures = zSignificantFiguresIn;
  zValidity = zValidityIn;
  DefiningPoint = DefiningPointIn;
}

DefiningPointsNominalType::~DefiningPointsNominalType()
{
  #ifndef NODESTRUCT
  delete decimalPlaces;
  delete linearUnit;
  delete n;
  delete significantFigures;
  delete validity;
  delete xDecimalPlaces;
  delete xSignificantFigures;
  delete xValidity;
  delete yDecimalPlaces;
  delete ySignificantFigures;
  delete yValidity;
  delete zDecimalPlaces;
  delete zSignificantFigures;
  delete zValidity;
  delete DefiningPoint;
  #endif
}

void DefiningPointsNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (decimalPlaces)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "decimalPlaces=\"");
      decimalPlaces->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (linearUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "linearUnit=\"");
      linearUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  if (significantFigures)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "significantFigures=\"");
      significantFigures->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (validity)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "validity=\"");
      validity->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (xDecimalPlaces)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "xDecimalPlaces=\"");
      xDecimalPlaces->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (xSignificantFigures)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "xSignificantFigures=\"");
      xSignificantFigures->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (xValidity)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "xValidity=\"");
      xValidity->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (yDecimalPlaces)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "yDecimalPlaces=\"");
      yDecimalPlaces->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (ySignificantFigures)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "ySignificantFigures=\"");
      ySignificantFigures->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (yValidity)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "yValidity=\"");
      yValidity->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (zDecimalPlaces)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "zDecimalPlaces=\"");
      zDecimalPlaces->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (zSignificantFigures)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "zSignificantFigures=\"");
      zSignificantFigures->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (zValidity)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "zValidity=\"");
      zValidity->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!DefiningPoint)
      {
        fprintf(stderr, "DefiningPoint list is missing\n");
        exit(1);
      }
    if (DefiningPoint->size() == 0)
      {
        fprintf(stderr, "DefiningPoint list is empty\n");
        exit(1);
      }
    if (DefiningPoint->size() < 1)
      {
        fprintf(stderr,
                "size of DefiningPoint list (%d) less than minimum required (1)\n",
                (int)DefiningPoint->size());
        exit(1);
      }
    std::list<DefiningPointNominalType *>::iterator iter;
    for (iter = DefiningPoint->begin();
         iter != DefiningPoint->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<DefiningPoint");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</DefiningPoint>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool DefiningPointsNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "decimalPlaces")
        {
          XmlNonNegativeInteger * decimalPlacesVal;
          if (this->decimalPlaces)
            {
              fprintf(stderr, "two values for decimalPlaces in DefiningPointsNominalType\n");
              returnValue = true;
              break;
            }
          decimalPlacesVal = new XmlNonNegativeInteger(decl->getval().c_str());
          if (decimalPlacesVal->getbad())
            {
              delete decimalPlacesVal;
              fprintf(stderr, "bad value %s for decimalPlaces in DefiningPointsNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->decimalPlaces = decimalPlacesVal;
        }
      else if (decl->getname() == "linearUnit")
        {
          XmlToken * linearUnitVal;
          if (this->linearUnit)
            {
              fprintf(stderr, "two values for linearUnit in DefiningPointsNominalType\n");
              returnValue = true;
              break;
            }
          linearUnitVal = new XmlToken(decl->getval().c_str());
          if (linearUnitVal->getbad())
            {
              delete linearUnitVal;
              fprintf(stderr, "bad value %s for linearUnit in DefiningPointsNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->linearUnit = linearUnitVal;
        }
      else if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in DefiningPointsNominalType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in DefiningPointsNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else if (decl->getname() == "significantFigures")
        {
          XmlNonNegativeInteger * significantFiguresVal;
          if (this->significantFigures)
            {
              fprintf(stderr, "two values for significantFigures in DefiningPointsNominalType\n");
              returnValue = true;
              break;
            }
          significantFiguresVal = new XmlNonNegativeInteger(decl->getval().c_str());
          if (significantFiguresVal->getbad())
            {
              delete significantFiguresVal;
              fprintf(stderr, "bad value %s for significantFigures in DefiningPointsNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->significantFigures = significantFiguresVal;
        }
      else if (decl->getname() == "validity")
        {
          ValidityEnumType * validityVal;
          if (this->validity)
            {
              fprintf(stderr, "two values for validity in DefiningPointsNominalType\n");
              returnValue = true;
              break;
            }
          validityVal = new ValidityEnumType(decl->getval().c_str());
          if (validityVal->getbad())
            {
              delete validityVal;
              fprintf(stderr, "bad value %s for validity in DefiningPointsNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->validity = validityVal;
        }
      else if (decl->getname() == "xDecimalPlaces")
        {
          XmlNonNegativeInteger * xDecimalPlacesVal;
          if (this->xDecimalPlaces)
            {
              fprintf(stderr, "two values for xDecimalPlaces in DefiningPointsNominalType\n");
              returnValue = true;
              break;
            }
          xDecimalPlacesVal = new XmlNonNegativeInteger(decl->getval().c_str());
          if (xDecimalPlacesVal->getbad())
            {
              delete xDecimalPlacesVal;
              fprintf(stderr, "bad value %s for xDecimalPlaces in DefiningPointsNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->xDecimalPlaces = xDecimalPlacesVal;
        }
      else if (decl->getname() == "xSignificantFigures")
        {
          XmlNonNegativeInteger * xSignificantFiguresVal;
          if (this->xSignificantFigures)
            {
              fprintf(stderr, "two values for xSignificantFigures in DefiningPointsNominalType\n");
              returnValue = true;
              break;
            }
          xSignificantFiguresVal = new XmlNonNegativeInteger(decl->getval().c_str());
          if (xSignificantFiguresVal->getbad())
            {
              delete xSignificantFiguresVal;
              fprintf(stderr, "bad value %s for xSignificantFigures in DefiningPointsNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->xSignificantFigures = xSignificantFiguresVal;
        }
      else if (decl->getname() == "xValidity")
        {
          ValidityEnumType * xValidityVal;
          if (this->xValidity)
            {
              fprintf(stderr, "two values for xValidity in DefiningPointsNominalType\n");
              returnValue = true;
              break;
            }
          xValidityVal = new ValidityEnumType(decl->getval().c_str());
          if (xValidityVal->getbad())
            {
              delete xValidityVal;
              fprintf(stderr, "bad value %s for xValidity in DefiningPointsNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->xValidity = xValidityVal;
        }
      else if (decl->getname() == "yDecimalPlaces")
        {
          XmlNonNegativeInteger * yDecimalPlacesVal;
          if (this->yDecimalPlaces)
            {
              fprintf(stderr, "two values for yDecimalPlaces in DefiningPointsNominalType\n");
              returnValue = true;
              break;
            }
          yDecimalPlacesVal = new XmlNonNegativeInteger(decl->getval().c_str());
          if (yDecimalPlacesVal->getbad())
            {
              delete yDecimalPlacesVal;
              fprintf(stderr, "bad value %s for yDecimalPlaces in DefiningPointsNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->yDecimalPlaces = yDecimalPlacesVal;
        }
      else if (decl->getname() == "ySignificantFigures")
        {
          XmlNonNegativeInteger * ySignificantFiguresVal;
          if (this->ySignificantFigures)
            {
              fprintf(stderr, "two values for ySignificantFigures in DefiningPointsNominalType\n");
              returnValue = true;
              break;
            }
          ySignificantFiguresVal = new XmlNonNegativeInteger(decl->getval().c_str());
          if (ySignificantFiguresVal->getbad())
            {
              delete ySignificantFiguresVal;
              fprintf(stderr, "bad value %s for ySignificantFigures in DefiningPointsNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->ySignificantFigures = ySignificantFiguresVal;
        }
      else if (decl->getname() == "yValidity")
        {
          ValidityEnumType * yValidityVal;
          if (this->yValidity)
            {
              fprintf(stderr, "two values for yValidity in DefiningPointsNominalType\n");
              returnValue = true;
              break;
            }
          yValidityVal = new ValidityEnumType(decl->getval().c_str());
          if (yValidityVal->getbad())
            {
              delete yValidityVal;
              fprintf(stderr, "bad value %s for yValidity in DefiningPointsNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->yValidity = yValidityVal;
        }
      else if (decl->getname() == "zDecimalPlaces")
        {
          XmlNonNegativeInteger * zDecimalPlacesVal;
          if (this->zDecimalPlaces)
            {
              fprintf(stderr, "two values for zDecimalPlaces in DefiningPointsNominalType\n");
              returnValue = true;
              break;
            }
          zDecimalPlacesVal = new XmlNonNegativeInteger(decl->getval().c_str());
          if (zDecimalPlacesVal->getbad())
            {
              delete zDecimalPlacesVal;
              fprintf(stderr, "bad value %s for zDecimalPlaces in DefiningPointsNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->zDecimalPlaces = zDecimalPlacesVal;
        }
      else if (decl->getname() == "zSignificantFigures")
        {
          XmlNonNegativeInteger * zSignificantFiguresVal;
          if (this->zSignificantFigures)
            {
              fprintf(stderr, "two values for zSignificantFigures in DefiningPointsNominalType\n");
              returnValue = true;
              break;
            }
          zSignificantFiguresVal = new XmlNonNegativeInteger(decl->getval().c_str());
          if (zSignificantFiguresVal->getbad())
            {
              delete zSignificantFiguresVal;
              fprintf(stderr, "bad value %s for zSignificantFigures in DefiningPointsNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->zSignificantFigures = zSignificantFiguresVal;
        }
      else if (decl->getname() == "zValidity")
        {
          ValidityEnumType * zValidityVal;
          if (this->zValidity)
            {
              fprintf(stderr, "two values for zValidity in DefiningPointsNominalType\n");
              returnValue = true;
              break;
            }
          zValidityVal = new ValidityEnumType(decl->getval().c_str());
          if (zValidityVal->getbad())
            {
              delete zValidityVal;
              fprintf(stderr, "bad value %s for zValidity in DefiningPointsNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->zValidity = zValidityVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in DefiningPointsNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in DefiningPointsNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->decimalPlaces;
      this->decimalPlaces = 0;
      delete this->linearUnit;
      this->linearUnit = 0;
      delete this->n;
      this->n = 0;
      delete this->significantFigures;
      this->significantFigures = 0;
      delete this->validity;
      this->validity = 0;
      delete this->xDecimalPlaces;
      this->xDecimalPlaces = 0;
      delete this->xSignificantFigures;
      this->xSignificantFigures = 0;
      delete this->xValidity;
      this->xValidity = 0;
      delete this->yDecimalPlaces;
      this->yDecimalPlaces = 0;
      delete this->ySignificantFigures;
      this->ySignificantFigures = 0;
      delete this->yValidity;
      this->yValidity = 0;
      delete this->zDecimalPlaces;
      this->zDecimalPlaces = 0;
      delete this->zSignificantFigures;
      this->zSignificantFigures = 0;
      delete this->zValidity;
      this->zValidity = 0;
    }
  return returnValue;
}

XmlNonNegativeInteger * DefiningPointsNominalType::getdecimalPlaces()
{return decimalPlaces;}

void DefiningPointsNominalType::setdecimalPlaces(XmlNonNegativeInteger * decimalPlacesIn)
{decimalPlaces = decimalPlacesIn;}

XmlToken * DefiningPointsNominalType::getlinearUnit()
{return linearUnit;}

void DefiningPointsNominalType::setlinearUnit(XmlToken * linearUnitIn)
{linearUnit = linearUnitIn;}

NaturalType * DefiningPointsNominalType::getn()
{return n;}

void DefiningPointsNominalType::setn(NaturalType * nIn)
{n = nIn;}

XmlNonNegativeInteger * DefiningPointsNominalType::getsignificantFigures()
{return significantFigures;}

void DefiningPointsNominalType::setsignificantFigures(XmlNonNegativeInteger * significantFiguresIn)
{significantFigures = significantFiguresIn;}

ValidityEnumType * DefiningPointsNominalType::getvalidity()
{return validity;}

void DefiningPointsNominalType::setvalidity(ValidityEnumType * validityIn)
{validity = validityIn;}

XmlNonNegativeInteger * DefiningPointsNominalType::getxDecimalPlaces()
{return xDecimalPlaces;}

void DefiningPointsNominalType::setxDecimalPlaces(XmlNonNegativeInteger * xDecimalPlacesIn)
{xDecimalPlaces = xDecimalPlacesIn;}

XmlNonNegativeInteger * DefiningPointsNominalType::getxSignificantFigures()
{return xSignificantFigures;}

void DefiningPointsNominalType::setxSignificantFigures(XmlNonNegativeInteger * xSignificantFiguresIn)
{xSignificantFigures = xSignificantFiguresIn;}

ValidityEnumType * DefiningPointsNominalType::getxValidity()
{return xValidity;}

void DefiningPointsNominalType::setxValidity(ValidityEnumType * xValidityIn)
{xValidity = xValidityIn;}

XmlNonNegativeInteger * DefiningPointsNominalType::getyDecimalPlaces()
{return yDecimalPlaces;}

void DefiningPointsNominalType::setyDecimalPlaces(XmlNonNegativeInteger * yDecimalPlacesIn)
{yDecimalPlaces = yDecimalPlacesIn;}

XmlNonNegativeInteger * DefiningPointsNominalType::getySignificantFigures()
{return ySignificantFigures;}

void DefiningPointsNominalType::setySignificantFigures(XmlNonNegativeInteger * ySignificantFiguresIn)
{ySignificantFigures = ySignificantFiguresIn;}

ValidityEnumType * DefiningPointsNominalType::getyValidity()
{return yValidity;}

void DefiningPointsNominalType::setyValidity(ValidityEnumType * yValidityIn)
{yValidity = yValidityIn;}

XmlNonNegativeInteger * DefiningPointsNominalType::getzDecimalPlaces()
{return zDecimalPlaces;}

void DefiningPointsNominalType::setzDecimalPlaces(XmlNonNegativeInteger * zDecimalPlacesIn)
{zDecimalPlaces = zDecimalPlacesIn;}

XmlNonNegativeInteger * DefiningPointsNominalType::getzSignificantFigures()
{return zSignificantFigures;}

void DefiningPointsNominalType::setzSignificantFigures(XmlNonNegativeInteger * zSignificantFiguresIn)
{zSignificantFigures = zSignificantFiguresIn;}

ValidityEnumType * DefiningPointsNominalType::getzValidity()
{return zValidity;}

void DefiningPointsNominalType::setzValidity(ValidityEnumType * zValidityIn)
{zValidity = zValidityIn;}

DefiningPointNominalTypeLisd * DefiningPointsNominalType::getDefiningPoint()
{return DefiningPoint;}

void DefiningPointsNominalType::setDefiningPoint(DefiningPointNominalTypeLisd * DefiningPointIn)
{DefiningPoint = DefiningPointIn;}

/* ***************************************************************** */

/* class EdgePointCastType

*/

EdgePointCastType::EdgePointCastType() :
  ConstructionMethodBaseType()
{
  BaseFeature = 0;
}

EdgePointCastType::EdgePointCastType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeature = BaseFeatureIn;
}

EdgePointCastType::~EdgePointCastType()
{
  #ifndef NODESTRUCT
  delete BaseFeature;
  #endif
}

void EdgePointCastType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeature");
  BaseFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * EdgePointCastType::getBaseFeature()
{return BaseFeature;}

void EdgePointCastType::setBaseFeature(BaseFeatureType * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class EdgePointCheckedFeatureType

*/

EdgePointCheckedFeatureType::EdgePointCheckedFeatureType()
{
  CheckDetails = 0;
}

EdgePointCheckedFeatureType::EdgePointCheckedFeatureType(
 EdgePointCheckedType * CheckDetailsIn)
{
  CheckDetails = CheckDetailsIn;
}

EdgePointCheckedFeatureType::~EdgePointCheckedFeatureType()
{
  #ifndef NODESTRUCT
  delete CheckDetails;
  #endif
}

void EdgePointCheckedFeatureType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (CheckDetails)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CheckDetails");
      CheckDetails->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CheckDetails>\n");
    }
  doSpaces(-INDENT, outFile);
}

EdgePointCheckedType * EdgePointCheckedFeatureType::getCheckDetails()
{return CheckDetails;}

void EdgePointCheckedFeatureType::setCheckDetails(EdgePointCheckedType * CheckDetailsIn)
{CheckDetails = CheckDetailsIn;}

/* ***************************************************************** */

/* class EdgePointCheckedType

*/

EdgePointCheckedType::EdgePointCheckedType()
{
  EdgePointCheckedTypePair = 0;
}

EdgePointCheckedType::EdgePointCheckedType(
 EdgePointCheckedTypeChoicePair * EdgePointCheckedTypePairIn)
{
  EdgePointCheckedTypePair = EdgePointCheckedTypePairIn;
}

EdgePointCheckedType::~EdgePointCheckedType()
{
  #ifndef NODESTRUCT
  delete EdgePointCheckedTypePair;
  #endif
}

void EdgePointCheckedType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  EdgePointCheckedTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

EdgePointCheckedTypeChoicePair * EdgePointCheckedType::getEdgePointCheckedTypePair()
{return EdgePointCheckedTypePair;}

void EdgePointCheckedType::setEdgePointCheckedTypePair(EdgePointCheckedTypeChoicePair * EdgePointCheckedTypePairIn)
{EdgePointCheckedTypePair = EdgePointCheckedTypePairIn;}
EdgePointCheckedTypeChoicePair::EdgePointCheckedTypeChoicePair() {}

EdgePointCheckedTypeChoicePair::EdgePointCheckedTypeChoicePair(
 whichOne EdgePointCheckedTypeTypeIn,
 EdgePointCheckedTypeVal * EdgePointCheckedTypeValueIn)
{
  EdgePointCheckedTypeType = EdgePointCheckedTypeTypeIn;
  EdgePointCheckedTypeValue = EdgePointCheckedTypeValueIn;
}

EdgePointCheckedTypeChoicePair::~EdgePointCheckedTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (EdgePointCheckedTypeType == MeasuredE)
    delete EdgePointCheckedTypeValue->Measured;
  else if (EdgePointCheckedTypeType == ConstructedE)
    delete EdgePointCheckedTypeValue->Constructed;
  delete EdgePointCheckedTypeValue;
  #endif
}

void EdgePointCheckedTypeChoicePair::printSelf(FILE * outFile)
{
  if (EdgePointCheckedTypeType == MeasuredE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Measured");
      EdgePointCheckedTypeValue->Measured->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Measured>\n");
    }
  else if (EdgePointCheckedTypeType == ConstructedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      EdgePointCheckedTypeValue->Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
}

/* ***************************************************************** */

/* class EdgePointConstructionMethodType

*/

EdgePointConstructionMethodType::EdgePointConstructionMethodType()
{
  EdgePointConstructionMethodTypePair = 0;
}

EdgePointConstructionMethodType::EdgePointConstructionMethodType(
 EdgePointConstructionMethodTypeChoicePair * EdgePointConstructionMethodTypePairIn)
{
  EdgePointConstructionMethodTypePair = EdgePointConstructionMethodTypePairIn;
}

EdgePointConstructionMethodType::~EdgePointConstructionMethodType()
{
  #ifndef NODESTRUCT
  delete EdgePointConstructionMethodTypePair;
  #endif
}

void EdgePointConstructionMethodType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (EdgePointConstructionMethodTypePair)
    {
      EdgePointConstructionMethodTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

EdgePointConstructionMethodTypeChoicePair * EdgePointConstructionMethodType::getEdgePointConstructionMethodTypePair()
{return EdgePointConstructionMethodTypePair;}

void EdgePointConstructionMethodType::setEdgePointConstructionMethodTypePair(EdgePointConstructionMethodTypeChoicePair * EdgePointConstructionMethodTypePairIn)
{EdgePointConstructionMethodTypePair = EdgePointConstructionMethodTypePairIn;}
EdgePointConstructionMethodTypeChoicePair::EdgePointConstructionMethodTypeChoicePair() {}

EdgePointConstructionMethodTypeChoicePair::EdgePointConstructionMethodTypeChoicePair(
 whichOne EdgePointConstructionMethodTypeTypeIn,
 EdgePointConstructionMethodTypeVal * EdgePointConstructionMethodTypeValueIn)
{
  EdgePointConstructionMethodTypeType = EdgePointConstructionMethodTypeTypeIn;
  EdgePointConstructionMethodTypeValue = EdgePointConstructionMethodTypeValueIn;
}

EdgePointConstructionMethodTypeChoicePair::~EdgePointConstructionMethodTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (EdgePointConstructionMethodTypeType == CopyE)
    delete EdgePointConstructionMethodTypeValue->Copy;
  else if (EdgePointConstructionMethodTypeType == CastE)
    delete EdgePointConstructionMethodTypeValue->Cast;
  else if (EdgePointConstructionMethodTypeType == TransformE)
    delete EdgePointConstructionMethodTypeValue->Transform;
  else if (EdgePointConstructionMethodTypeType == FromScanE)
    delete EdgePointConstructionMethodTypeValue->FromScan;
  delete EdgePointConstructionMethodTypeValue;
  #endif
}

void EdgePointConstructionMethodTypeChoicePair::printSelf(FILE * outFile)
{
  if (EdgePointConstructionMethodTypeType == CopyE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Copy");
      EdgePointConstructionMethodTypeValue->Copy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Copy>\n");
    }
  else if (EdgePointConstructionMethodTypeType == CastE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Cast");
      EdgePointConstructionMethodTypeValue->Cast->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Cast>\n");
    }
  else if (EdgePointConstructionMethodTypeType == TransformE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Transform");
      EdgePointConstructionMethodTypeValue->Transform->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Transform>\n");
    }
  else if (EdgePointConstructionMethodTypeType == FromScanE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FromScan");
      EdgePointConstructionMethodTypeValue->FromScan->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FromScan>\n");
    }
}

/* ***************************************************************** */

/* class EdgePointCopyType

*/

EdgePointCopyType::EdgePointCopyType() :
  ConstructionMethodBaseType()
{
  BaseEdgePoint = 0;
}

EdgePointCopyType::EdgePointCopyType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseEdgePointIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseEdgePoint = BaseEdgePointIn;
}

EdgePointCopyType::~EdgePointCopyType()
{
  #ifndef NODESTRUCT
  delete BaseEdgePoint;
  #endif
}

void EdgePointCopyType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseEdgePoint");
  BaseEdgePoint->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseEdgePoint>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * EdgePointCopyType::getBaseEdgePoint()
{return BaseEdgePoint;}

void EdgePointCopyType::setBaseEdgePoint(BaseFeatureType * BaseEdgePointIn)
{BaseEdgePoint = BaseEdgePointIn;}

/* ***************************************************************** */

/* class EdgePointFeatureDefinitionType

*/

EdgePointFeatureDefinitionType::EdgePointFeatureDefinitionType() :
  PointFeatureDefinitionBaseType()
{
  InternalExternal = 0;
}

EdgePointFeatureDefinitionType::EdgePointFeatureDefinitionType(
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn) :
  PointFeatureDefinitionBaseType(
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
}

EdgePointFeatureDefinitionType::EdgePointFeatureDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn) :
  PointFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
}

EdgePointFeatureDefinitionType::~EdgePointFeatureDefinitionType()
{
  #ifndef NODESTRUCT
  delete InternalExternal;
  #endif
}

void EdgePointFeatureDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<InternalExternal");
  InternalExternal->printSelf(outFile);
  fprintf(outFile, "</InternalExternal>\n");
  doSpaces(-INDENT, outFile);
}

bool EdgePointFeatureDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in EdgePointFeatureDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in EdgePointFeatureDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in EdgePointFeatureDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in EdgePointFeatureDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

InternalExternalEnumType * EdgePointFeatureDefinitionType::getInternalExternal()
{return InternalExternal;}

void EdgePointFeatureDefinitionType::setInternalExternal(InternalExternalEnumType * InternalExternalIn)
{InternalExternal = InternalExternalIn;}

/* ***************************************************************** */

/* class EdgePointFeatureItemType

*/

EdgePointFeatureItemType::EdgePointFeatureItemType() :
  PointFeatureItemBaseType()
{
  DeterminationMode = 0;
}

EdgePointFeatureItemType::EdgePointFeatureItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 EdgePointMeasurementDeterminationType * DeterminationModeIn) :
  PointFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

EdgePointFeatureItemType::EdgePointFeatureItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 EdgePointMeasurementDeterminationType * DeterminationModeIn) :
  PointFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

EdgePointFeatureItemType::~EdgePointFeatureItemType()
{
  #ifndef NODESTRUCT
  delete DeterminationMode;
  #endif
}

void EdgePointFeatureItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<DeterminationMode");
  DeterminationMode->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeterminationMode>\n");
  doSpaces(-INDENT, outFile);
}

bool EdgePointFeatureItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in EdgePointFeatureItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in EdgePointFeatureItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in EdgePointFeatureItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in EdgePointFeatureItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

EdgePointMeasurementDeterminationType * EdgePointFeatureItemType::getDeterminationMode()
{return DeterminationMode;}

void EdgePointFeatureItemType::setDeterminationMode(EdgePointMeasurementDeterminationType * DeterminationModeIn)
{DeterminationMode = DeterminationModeIn;}

/* ***************************************************************** */

/* class EdgePointFeatureMeasurementType

*/

EdgePointFeatureMeasurementType::EdgePointFeatureMeasurementType() :
  PointFeatureMeasurementBaseType()
{
  Location = 0;
  Normal = 0;
  AdjacentNormal = 0;
}

EdgePointFeatureMeasurementType::EdgePointFeatureMeasurementType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredPointType * LocationIn,
 MeasuredUnitVectorType * NormalIn,
 MeasuredUnitVectorType * AdjacentNormalIn) :
  PointFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Location = LocationIn;
  Normal = NormalIn;
  AdjacentNormal = AdjacentNormalIn;
}

EdgePointFeatureMeasurementType::EdgePointFeatureMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredPointType * LocationIn,
 MeasuredUnitVectorType * NormalIn,
 MeasuredUnitVectorType * AdjacentNormalIn) :
  PointFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Location = LocationIn;
  Normal = NormalIn;
  AdjacentNormal = AdjacentNormalIn;
}

EdgePointFeatureMeasurementType::~EdgePointFeatureMeasurementType()
{
  #ifndef NODESTRUCT
  delete Location;
  delete Normal;
  delete AdjacentNormal;
  #endif
}

void EdgePointFeatureMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  if (Location)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Location");
      Location->printSelf(outFile);
      fprintf(outFile, "</Location>\n");
    }
  if (Normal)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Normal");
      Normal->printSelf(outFile);
      fprintf(outFile, "</Normal>\n");
    }
  if (AdjacentNormal)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AdjacentNormal");
      AdjacentNormal->printSelf(outFile);
      fprintf(outFile, "</AdjacentNormal>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool EdgePointFeatureMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in EdgePointFeatureMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in EdgePointFeatureMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in EdgePointFeatureMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in EdgePointFeatureMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredPointType * EdgePointFeatureMeasurementType::getLocation()
{return Location;}

void EdgePointFeatureMeasurementType::setLocation(MeasuredPointType * LocationIn)
{Location = LocationIn;}

MeasuredUnitVectorType * EdgePointFeatureMeasurementType::getNormal()
{return Normal;}

void EdgePointFeatureMeasurementType::setNormal(MeasuredUnitVectorType * NormalIn)
{Normal = NormalIn;}

MeasuredUnitVectorType * EdgePointFeatureMeasurementType::getAdjacentNormal()
{return AdjacentNormal;}

void EdgePointFeatureMeasurementType::setAdjacentNormal(MeasuredUnitVectorType * AdjacentNormalIn)
{AdjacentNormal = AdjacentNormalIn;}

/* ***************************************************************** */

/* class EdgePointFeatureNominalType

*/

EdgePointFeatureNominalType::EdgePointFeatureNominalType() :
  PointFeatureNominalBaseType()
{
  Location = 0;
  Normal = 0;
  AdjacentNormal = 0;
  Constructed = 0;
}

EdgePointFeatureNominalType::EdgePointFeatureNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 PointFeatureNominalBaseTypeChoicePair * PointFeatureNominalBaseTypePairIn,
 PointType * LocationIn,
 UnitVectorType * NormalIn,
 UnitVectorType * AdjacentNormalIn,
 EdgePointConstructionMethodType * ConstructedIn) :
  PointFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    PointFeatureNominalBaseTypePairIn)
{
  Location = LocationIn;
  Normal = NormalIn;
  AdjacentNormal = AdjacentNormalIn;
  Constructed = ConstructedIn;
}

EdgePointFeatureNominalType::EdgePointFeatureNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 PointFeatureNominalBaseTypeChoicePair * PointFeatureNominalBaseTypePairIn,
 PointType * LocationIn,
 UnitVectorType * NormalIn,
 UnitVectorType * AdjacentNormalIn,
 EdgePointConstructionMethodType * ConstructedIn) :
  PointFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    PointFeatureNominalBaseTypePairIn)
{
  Location = LocationIn;
  Normal = NormalIn;
  AdjacentNormal = AdjacentNormalIn;
  Constructed = ConstructedIn;
}

EdgePointFeatureNominalType::~EdgePointFeatureNominalType()
{
  #ifndef NODESTRUCT
  delete Location;
  delete Normal;
  delete AdjacentNormal;
  delete Constructed;
  #endif
}

void EdgePointFeatureNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (PointFeatureNominalBaseTypePair)
    {
      PointFeatureNominalBaseTypePair->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Location");
  Location->printSelf(outFile);
  fprintf(outFile, "</Location>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Normal");
  Normal->printSelf(outFile);
  fprintf(outFile, "</Normal>\n");
  if (AdjacentNormal)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AdjacentNormal");
      AdjacentNormal->printSelf(outFile);
      fprintf(outFile, "</AdjacentNormal>\n");
    }
  if (Constructed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool EdgePointFeatureNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in EdgePointFeatureNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in EdgePointFeatureNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in EdgePointFeatureNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in EdgePointFeatureNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

PointType * EdgePointFeatureNominalType::getLocation()
{return Location;}

void EdgePointFeatureNominalType::setLocation(PointType * LocationIn)
{Location = LocationIn;}

UnitVectorType * EdgePointFeatureNominalType::getNormal()
{return Normal;}

void EdgePointFeatureNominalType::setNormal(UnitVectorType * NormalIn)
{Normal = NormalIn;}

UnitVectorType * EdgePointFeatureNominalType::getAdjacentNormal()
{return AdjacentNormal;}

void EdgePointFeatureNominalType::setAdjacentNormal(UnitVectorType * AdjacentNormalIn)
{AdjacentNormal = AdjacentNormalIn;}

EdgePointConstructionMethodType * EdgePointFeatureNominalType::getConstructed()
{return Constructed;}

void EdgePointFeatureNominalType::setConstructed(EdgePointConstructionMethodType * ConstructedIn)
{Constructed = ConstructedIn;}

/* ***************************************************************** */

/* class EdgePointFromScanType

*/

EdgePointFromScanType::EdgePointFromScanType() :
  ConstructionMethodBaseType()
{
  SurfaceFeature = 0;
  SearchRadius = 0;
  PatchRadius = 0;
  Distance = 0;
  Depth = 0;
  RetrievalMethod = 0;
}

EdgePointFromScanType::EdgePointFromScanType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * SurfaceFeatureIn,
 LinearValueType * SearchRadiusIn,
 LinearValueType * PatchRadiusIn,
 LinearValueType * DistanceIn,
 LinearValueType * DepthIn,
 RetrievalMethodEnumType * RetrievalMethodIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  SurfaceFeature = SurfaceFeatureIn;
  SearchRadius = SearchRadiusIn;
  PatchRadius = PatchRadiusIn;
  Distance = DistanceIn;
  Depth = DepthIn;
  RetrievalMethod = RetrievalMethodIn;
}

EdgePointFromScanType::~EdgePointFromScanType()
{
  #ifndef NODESTRUCT
  delete SurfaceFeature;
  delete SearchRadius;
  delete PatchRadius;
  delete Distance;
  delete Depth;
  delete RetrievalMethod;
  #endif
}

void EdgePointFromScanType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<SurfaceFeature");
  SurfaceFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</SurfaceFeature>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<SearchRadius");
  SearchRadius->printSelf(outFile);
  fprintf(outFile, "</SearchRadius>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<PatchRadius");
  PatchRadius->printSelf(outFile);
  fprintf(outFile, "</PatchRadius>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Distance");
  Distance->printSelf(outFile);
  fprintf(outFile, "</Distance>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Depth");
  Depth->printSelf(outFile);
  fprintf(outFile, "</Depth>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<RetrievalMethod");
  RetrievalMethod->printSelf(outFile);
  fprintf(outFile, "</RetrievalMethod>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * EdgePointFromScanType::getSurfaceFeature()
{return SurfaceFeature;}

void EdgePointFromScanType::setSurfaceFeature(BaseFeatureType * SurfaceFeatureIn)
{SurfaceFeature = SurfaceFeatureIn;}

LinearValueType * EdgePointFromScanType::getSearchRadius()
{return SearchRadius;}

void EdgePointFromScanType::setSearchRadius(LinearValueType * SearchRadiusIn)
{SearchRadius = SearchRadiusIn;}

LinearValueType * EdgePointFromScanType::getPatchRadius()
{return PatchRadius;}

void EdgePointFromScanType::setPatchRadius(LinearValueType * PatchRadiusIn)
{PatchRadius = PatchRadiusIn;}

LinearValueType * EdgePointFromScanType::getDistance()
{return Distance;}

void EdgePointFromScanType::setDistance(LinearValueType * DistanceIn)
{Distance = DistanceIn;}

LinearValueType * EdgePointFromScanType::getDepth()
{return Depth;}

void EdgePointFromScanType::setDepth(LinearValueType * DepthIn)
{Depth = DepthIn;}

RetrievalMethodEnumType * EdgePointFromScanType::getRetrievalMethod()
{return RetrievalMethod;}

void EdgePointFromScanType::setRetrievalMethod(RetrievalMethodEnumType * RetrievalMethodIn)
{RetrievalMethod = RetrievalMethodIn;}

/* ***************************************************************** */

/* class EdgePointMeasurementDeterminationType

*/

EdgePointMeasurementDeterminationType::EdgePointMeasurementDeterminationType()
{
  EdgePointMeasurementDeterminationTypePair = 0;
}

EdgePointMeasurementDeterminationType::EdgePointMeasurementDeterminationType(
 EdgePointMeasurementDeterminationTypeChoicePair * EdgePointMeasurementDeterminationTypePairIn)
{
  EdgePointMeasurementDeterminationTypePair = EdgePointMeasurementDeterminationTypePairIn;
}

EdgePointMeasurementDeterminationType::~EdgePointMeasurementDeterminationType()
{
  #ifndef NODESTRUCT
  delete EdgePointMeasurementDeterminationTypePair;
  #endif
}

void EdgePointMeasurementDeterminationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  EdgePointMeasurementDeterminationTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

EdgePointMeasurementDeterminationTypeChoicePair * EdgePointMeasurementDeterminationType::getEdgePointMeasurementDeterminationTypePair()
{return EdgePointMeasurementDeterminationTypePair;}

void EdgePointMeasurementDeterminationType::setEdgePointMeasurementDeterminationTypePair(EdgePointMeasurementDeterminationTypeChoicePair * EdgePointMeasurementDeterminationTypePairIn)
{EdgePointMeasurementDeterminationTypePair = EdgePointMeasurementDeterminationTypePairIn;}
EdgePointMeasurementDeterminationTypeChoicePair::EdgePointMeasurementDeterminationTypeChoicePair() {}

EdgePointMeasurementDeterminationTypeChoicePair::EdgePointMeasurementDeterminationTypeChoicePair(
 whichOne EdgePointMeasurementDeterminationTypeTypeIn,
 EdgePointMeasurementDeterminationTypeVal * EdgePointMeasurementDeterminationTypeValueIn)
{
  EdgePointMeasurementDeterminationTypeType = EdgePointMeasurementDeterminationTypeTypeIn;
  EdgePointMeasurementDeterminationTypeValue = EdgePointMeasurementDeterminationTypeValueIn;
}

EdgePointMeasurementDeterminationTypeChoicePair::~EdgePointMeasurementDeterminationTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (EdgePointMeasurementDeterminationTypeType == CheckedE)
    delete EdgePointMeasurementDeterminationTypeValue->Checked;
  else if (EdgePointMeasurementDeterminationTypeType == SetE)
    delete EdgePointMeasurementDeterminationTypeValue->Set;
  delete EdgePointMeasurementDeterminationTypeValue;
  #endif
}

void EdgePointMeasurementDeterminationTypeChoicePair::printSelf(FILE * outFile)
{
  if (EdgePointMeasurementDeterminationTypeType == CheckedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Checked");
      EdgePointMeasurementDeterminationTypeValue->Checked->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Checked>\n");
    }
  else if (EdgePointMeasurementDeterminationTypeType == SetE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Set");
      EdgePointMeasurementDeterminationTypeValue->Set->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class EdgePointTransformType

*/

EdgePointTransformType::EdgePointTransformType() :
  ConstructionMethodBaseType()
{
  BaseEdgePoint = 0;
  Transformation = 0;
}

EdgePointTransformType::EdgePointTransformType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseEdgePointIn,
 TransformationReferenceType * TransformationIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseEdgePoint = BaseEdgePointIn;
  Transformation = TransformationIn;
}

EdgePointTransformType::~EdgePointTransformType()
{
  #ifndef NODESTRUCT
  delete BaseEdgePoint;
  delete Transformation;
  #endif
}

void EdgePointTransformType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseEdgePoint");
  BaseEdgePoint->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseEdgePoint>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Transformation");
  Transformation->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Transformation>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * EdgePointTransformType::getBaseEdgePoint()
{return BaseEdgePoint;}

void EdgePointTransformType::setBaseEdgePoint(BaseFeatureType * BaseEdgePointIn)
{BaseEdgePoint = BaseEdgePointIn;}

TransformationReferenceType * EdgePointTransformType::getTransformation()
{return Transformation;}

void EdgePointTransformType::setTransformation(TransformationReferenceType * TransformationIn)
{Transformation = TransformationIn;}

/* ***************************************************************** */

/* class EllipseBestFitType

*/

EllipseBestFitType::EllipseBestFitType() :
  ConstructionMethodBaseType()
{
  n = 0;
  BaseFeature = 0;
}

EllipseBestFitType::EllipseBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = 0;
  BaseFeature = BaseFeatureIn;
}

EllipseBestFitType::EllipseBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 NaturalType * nIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = nIn;
  BaseFeature = BaseFeatureIn;
}

EllipseBestFitType::~EllipseBestFitType()
{
  #ifndef NODESTRUCT
  delete n;
  delete BaseFeature;
  #endif
}

void EllipseBestFitType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  {
    if (!BaseFeature)
      {
        fprintf(stderr, "BaseFeature list is missing\n");
        exit(1);
      }
    if (BaseFeature->size() == 0)
      {
        fprintf(stderr, "BaseFeature list is empty\n");
        exit(1);
      }
    if (BaseFeature->size() < 5)
      {
        fprintf(stderr,
                "size of BaseFeature list (%d) less than minimum required (5)\n",
                (int)BaseFeature->size());
        exit(1);
      }
    std::list<SequencedBaseFeatureType *>::iterator iter;
    for (iter = BaseFeature->begin();
         iter != BaseFeature->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<BaseFeature");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</BaseFeature>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool EllipseBestFitType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in EllipseBestFitType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in EllipseBestFitType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in EllipseBestFitType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in EllipseBestFitType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * EllipseBestFitType::getn()
{return n;}

void EllipseBestFitType::setn(NaturalType * nIn)
{n = nIn;}

SequencedBaseFeatureTypeLisd * EllipseBestFitType::getBaseFeature()
{return BaseFeature;}

void EllipseBestFitType::setBaseFeature(SequencedBaseFeatureTypeLisd * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class EllipseCastType

*/

EllipseCastType::EllipseCastType() :
  ConstructionMethodBaseType()
{
  BaseFeature = 0;
}

EllipseCastType::EllipseCastType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeature = BaseFeatureIn;
}

EllipseCastType::~EllipseCastType()
{
  #ifndef NODESTRUCT
  delete BaseFeature;
  #endif
}

void EllipseCastType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeature");
  BaseFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * EllipseCastType::getBaseFeature()
{return BaseFeature;}

void EllipseCastType::setBaseFeature(BaseFeatureType * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class EllipseCheckedFeatureType

*/

EllipseCheckedFeatureType::EllipseCheckedFeatureType()
{
  CheckDetails = 0;
}

EllipseCheckedFeatureType::EllipseCheckedFeatureType(
 EllipseCheckedType * CheckDetailsIn)
{
  CheckDetails = CheckDetailsIn;
}

EllipseCheckedFeatureType::~EllipseCheckedFeatureType()
{
  #ifndef NODESTRUCT
  delete CheckDetails;
  #endif
}

void EllipseCheckedFeatureType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (CheckDetails)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CheckDetails");
      CheckDetails->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CheckDetails>\n");
    }
  doSpaces(-INDENT, outFile);
}

EllipseCheckedType * EllipseCheckedFeatureType::getCheckDetails()
{return CheckDetails;}

void EllipseCheckedFeatureType::setCheckDetails(EllipseCheckedType * CheckDetailsIn)
{CheckDetails = CheckDetailsIn;}

/* ***************************************************************** */

/* class EllipseCheckedType

*/

EllipseCheckedType::EllipseCheckedType()
{
  EllipseCheckedTypePair = 0;
}

EllipseCheckedType::EllipseCheckedType(
 EllipseCheckedTypeChoicePair * EllipseCheckedTypePairIn)
{
  EllipseCheckedTypePair = EllipseCheckedTypePairIn;
}

EllipseCheckedType::~EllipseCheckedType()
{
  #ifndef NODESTRUCT
  delete EllipseCheckedTypePair;
  #endif
}

void EllipseCheckedType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  EllipseCheckedTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

EllipseCheckedTypeChoicePair * EllipseCheckedType::getEllipseCheckedTypePair()
{return EllipseCheckedTypePair;}

void EllipseCheckedType::setEllipseCheckedTypePair(EllipseCheckedTypeChoicePair * EllipseCheckedTypePairIn)
{EllipseCheckedTypePair = EllipseCheckedTypePairIn;}
EllipseCheckedTypeChoicePair::EllipseCheckedTypeChoicePair() {}

EllipseCheckedTypeChoicePair::EllipseCheckedTypeChoicePair(
 whichOne EllipseCheckedTypeTypeIn,
 EllipseCheckedTypeVal * EllipseCheckedTypeValueIn)
{
  EllipseCheckedTypeType = EllipseCheckedTypeTypeIn;
  EllipseCheckedTypeValue = EllipseCheckedTypeValueIn;
}

EllipseCheckedTypeChoicePair::~EllipseCheckedTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (EllipseCheckedTypeType == MeasuredE)
    delete EllipseCheckedTypeValue->Measured;
  else if (EllipseCheckedTypeType == ConstructedE)
    delete EllipseCheckedTypeValue->Constructed;
  delete EllipseCheckedTypeValue;
  #endif
}

void EllipseCheckedTypeChoicePair::printSelf(FILE * outFile)
{
  if (EllipseCheckedTypeType == MeasuredE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Measured");
      EllipseCheckedTypeValue->Measured->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Measured>\n");
    }
  else if (EllipseCheckedTypeType == ConstructedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      EllipseCheckedTypeValue->Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
}

/* ***************************************************************** */

/* class EllipseConstructionMethodType

*/

EllipseConstructionMethodType::EllipseConstructionMethodType()
{
  EllipseConstructionMethodTypePair = 0;
}

EllipseConstructionMethodType::EllipseConstructionMethodType(
 EllipseConstructionMethodTypeChoicePair * EllipseConstructionMethodTypePairIn)
{
  EllipseConstructionMethodTypePair = EllipseConstructionMethodTypePairIn;
}

EllipseConstructionMethodType::~EllipseConstructionMethodType()
{
  #ifndef NODESTRUCT
  delete EllipseConstructionMethodTypePair;
  #endif
}

void EllipseConstructionMethodType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (EllipseConstructionMethodTypePair)
    {
      EllipseConstructionMethodTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

EllipseConstructionMethodTypeChoicePair * EllipseConstructionMethodType::getEllipseConstructionMethodTypePair()
{return EllipseConstructionMethodTypePair;}

void EllipseConstructionMethodType::setEllipseConstructionMethodTypePair(EllipseConstructionMethodTypeChoicePair * EllipseConstructionMethodTypePairIn)
{EllipseConstructionMethodTypePair = EllipseConstructionMethodTypePairIn;}
EllipseConstructionMethodTypeChoicePair::EllipseConstructionMethodTypeChoicePair() {}

EllipseConstructionMethodTypeChoicePair::EllipseConstructionMethodTypeChoicePair(
 whichOne EllipseConstructionMethodTypeTypeIn,
 EllipseConstructionMethodTypeVal * EllipseConstructionMethodTypeValueIn)
{
  EllipseConstructionMethodTypeType = EllipseConstructionMethodTypeTypeIn;
  EllipseConstructionMethodTypeValue = EllipseConstructionMethodTypeValueIn;
}

EllipseConstructionMethodTypeChoicePair::~EllipseConstructionMethodTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (EllipseConstructionMethodTypeType == BestFitE)
    delete EllipseConstructionMethodTypeValue->BestFit;
  else if (EllipseConstructionMethodTypeType == RecompensatedE)
    delete EllipseConstructionMethodTypeValue->Recompensated;
  else if (EllipseConstructionMethodTypeType == IntersectionE)
    delete EllipseConstructionMethodTypeValue->Intersection;
  else if (EllipseConstructionMethodTypeType == ProjectionE)
    delete EllipseConstructionMethodTypeValue->Projection;
  else if (EllipseConstructionMethodTypeType == CopyE)
    delete EllipseConstructionMethodTypeValue->Copy;
  else if (EllipseConstructionMethodTypeType == CastE)
    delete EllipseConstructionMethodTypeValue->Cast;
  else if (EllipseConstructionMethodTypeType == TransformE)
    delete EllipseConstructionMethodTypeValue->Transform;
  else if (EllipseConstructionMethodTypeType == FromScanE)
    delete EllipseConstructionMethodTypeValue->FromScan;
  delete EllipseConstructionMethodTypeValue;
  #endif
}

void EllipseConstructionMethodTypeChoicePair::printSelf(FILE * outFile)
{
  if (EllipseConstructionMethodTypeType == BestFitE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BestFit");
      EllipseConstructionMethodTypeValue->BestFit->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BestFit>\n");
    }
  else if (EllipseConstructionMethodTypeType == RecompensatedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Recompensated");
      EllipseConstructionMethodTypeValue->Recompensated->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Recompensated>\n");
    }
  else if (EllipseConstructionMethodTypeType == IntersectionE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Intersection");
      EllipseConstructionMethodTypeValue->Intersection->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Intersection>\n");
    }
  else if (EllipseConstructionMethodTypeType == ProjectionE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Projection");
      EllipseConstructionMethodTypeValue->Projection->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Projection>\n");
    }
  else if (EllipseConstructionMethodTypeType == CopyE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Copy");
      EllipseConstructionMethodTypeValue->Copy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Copy>\n");
    }
  else if (EllipseConstructionMethodTypeType == CastE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Cast");
      EllipseConstructionMethodTypeValue->Cast->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Cast>\n");
    }
  else if (EllipseConstructionMethodTypeType == TransformE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Transform");
      EllipseConstructionMethodTypeValue->Transform->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Transform>\n");
    }
  else if (EllipseConstructionMethodTypeType == FromScanE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FromScan");
      EllipseConstructionMethodTypeValue->FromScan->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FromScan>\n");
    }
}

/* ***************************************************************** */

/* class EllipseCopyType

*/

EllipseCopyType::EllipseCopyType() :
  ConstructionMethodBaseType()
{
  BaseEllipse = 0;
}

EllipseCopyType::EllipseCopyType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseEllipseIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseEllipse = BaseEllipseIn;
}

EllipseCopyType::~EllipseCopyType()
{
  #ifndef NODESTRUCT
  delete BaseEllipse;
  #endif
}

void EllipseCopyType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseEllipse");
  BaseEllipse->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseEllipse>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * EllipseCopyType::getBaseEllipse()
{return BaseEllipse;}

void EllipseCopyType::setBaseEllipse(BaseFeatureType * BaseEllipseIn)
{BaseEllipse = BaseEllipseIn;}

/* ***************************************************************** */

/* class EllipseFeatureDefinitionType

*/

EllipseFeatureDefinitionType::EllipseFeatureDefinitionType() :
  CurveFeatureDefinitionBaseType()
{
  InternalExternal = 0;
  MajorDiameter = 0;
  MinorDiameter = 0;
}

EllipseFeatureDefinitionType::EllipseFeatureDefinitionType(
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * MajorDiameterIn,
 LinearValueType * MinorDiameterIn) :
  CurveFeatureDefinitionBaseType(
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  MajorDiameter = MajorDiameterIn;
  MinorDiameter = MinorDiameterIn;
}

EllipseFeatureDefinitionType::EllipseFeatureDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * MajorDiameterIn,
 LinearValueType * MinorDiameterIn) :
  CurveFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  MajorDiameter = MajorDiameterIn;
  MinorDiameter = MinorDiameterIn;
}

EllipseFeatureDefinitionType::~EllipseFeatureDefinitionType()
{
  #ifndef NODESTRUCT
  delete InternalExternal;
  delete MajorDiameter;
  delete MinorDiameter;
  #endif
}

void EllipseFeatureDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<InternalExternal");
  InternalExternal->printSelf(outFile);
  fprintf(outFile, "</InternalExternal>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MajorDiameter");
  MajorDiameter->printSelf(outFile);
  fprintf(outFile, "</MajorDiameter>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MinorDiameter");
  MinorDiameter->printSelf(outFile);
  fprintf(outFile, "</MinorDiameter>\n");
  doSpaces(-INDENT, outFile);
}

bool EllipseFeatureDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in EllipseFeatureDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in EllipseFeatureDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in EllipseFeatureDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in EllipseFeatureDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

InternalExternalEnumType * EllipseFeatureDefinitionType::getInternalExternal()
{return InternalExternal;}

void EllipseFeatureDefinitionType::setInternalExternal(InternalExternalEnumType * InternalExternalIn)
{InternalExternal = InternalExternalIn;}

LinearValueType * EllipseFeatureDefinitionType::getMajorDiameter()
{return MajorDiameter;}

void EllipseFeatureDefinitionType::setMajorDiameter(LinearValueType * MajorDiameterIn)
{MajorDiameter = MajorDiameterIn;}

LinearValueType * EllipseFeatureDefinitionType::getMinorDiameter()
{return MinorDiameter;}

void EllipseFeatureDefinitionType::setMinorDiameter(LinearValueType * MinorDiameterIn)
{MinorDiameter = MinorDiameterIn;}

/* ***************************************************************** */

/* class EllipseFeatureItemType

*/

EllipseFeatureItemType::EllipseFeatureItemType() :
  CurveFeatureItemBaseType()
{
  DeterminationMode = 0;
}

EllipseFeatureItemType::EllipseFeatureItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 EllipseMeasurementDeterminationType * DeterminationModeIn) :
  CurveFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

EllipseFeatureItemType::EllipseFeatureItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 EllipseMeasurementDeterminationType * DeterminationModeIn) :
  CurveFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

EllipseFeatureItemType::~EllipseFeatureItemType()
{
  #ifndef NODESTRUCT
  delete DeterminationMode;
  #endif
}

void EllipseFeatureItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<DeterminationMode");
  DeterminationMode->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeterminationMode>\n");
  doSpaces(-INDENT, outFile);
}

bool EllipseFeatureItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in EllipseFeatureItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in EllipseFeatureItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in EllipseFeatureItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in EllipseFeatureItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

EllipseMeasurementDeterminationType * EllipseFeatureItemType::getDeterminationMode()
{return DeterminationMode;}

void EllipseFeatureItemType::setDeterminationMode(EllipseMeasurementDeterminationType * DeterminationModeIn)
{DeterminationMode = DeterminationModeIn;}

/* ***************************************************************** */

/* class EllipseFeatureMeasurementType

*/

EllipseFeatureMeasurementType::EllipseFeatureMeasurementType() :
  CurveFeatureMeasurementBaseType()
{
  Axis = 0;
  Normal = 0;
  SweepMeasurementRange = 0;
  SweepFull = 0;
  MajorDiameter = 0;
  MinorDiameter = 0;
  Form = 0;
}

EllipseFeatureMeasurementType::EllipseFeatureMeasurementType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredAxisType * AxisIn,
 MeasuredUnitVectorType * NormalIn,
 SweepType * SweepMeasurementRangeIn,
 SweepType * SweepFullIn,
 MeasuredLinearValueType * MajorDiameterIn,
 MeasuredLinearValueType * MinorDiameterIn,
 MeasuredLinearValueType * FormIn) :
  CurveFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Axis = AxisIn;
  Normal = NormalIn;
  SweepMeasurementRange = SweepMeasurementRangeIn;
  SweepFull = SweepFullIn;
  MajorDiameter = MajorDiameterIn;
  MinorDiameter = MinorDiameterIn;
  Form = FormIn;
}

EllipseFeatureMeasurementType::EllipseFeatureMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredAxisType * AxisIn,
 MeasuredUnitVectorType * NormalIn,
 SweepType * SweepMeasurementRangeIn,
 SweepType * SweepFullIn,
 MeasuredLinearValueType * MajorDiameterIn,
 MeasuredLinearValueType * MinorDiameterIn,
 MeasuredLinearValueType * FormIn) :
  CurveFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Axis = AxisIn;
  Normal = NormalIn;
  SweepMeasurementRange = SweepMeasurementRangeIn;
  SweepFull = SweepFullIn;
  MajorDiameter = MajorDiameterIn;
  MinorDiameter = MinorDiameterIn;
  Form = FormIn;
}

EllipseFeatureMeasurementType::~EllipseFeatureMeasurementType()
{
  #ifndef NODESTRUCT
  delete Axis;
  delete Normal;
  delete SweepMeasurementRange;
  delete SweepFull;
  delete MajorDiameter;
  delete MinorDiameter;
  delete Form;
  #endif
}

void EllipseFeatureMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  if (Axis)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Axis");
      Axis->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Axis>\n");
    }
  if (Normal)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Normal");
      Normal->printSelf(outFile);
      fprintf(outFile, "</Normal>\n");
    }
  if (SweepMeasurementRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SweepMeasurementRange");
      SweepMeasurementRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SweepMeasurementRange>\n");
    }
  if (SweepFull)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SweepFull");
      SweepFull->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SweepFull>\n");
    }
  if (MajorDiameter)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MajorDiameter");
      MajorDiameter->printSelf(outFile);
      fprintf(outFile, "</MajorDiameter>\n");
    }
  if (MinorDiameter)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinorDiameter");
      MinorDiameter->printSelf(outFile);
      fprintf(outFile, "</MinorDiameter>\n");
    }
  if (Form)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Form");
      Form->printSelf(outFile);
      fprintf(outFile, "</Form>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool EllipseFeatureMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in EllipseFeatureMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in EllipseFeatureMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in EllipseFeatureMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in EllipseFeatureMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredAxisType * EllipseFeatureMeasurementType::getAxis()
{return Axis;}

void EllipseFeatureMeasurementType::setAxis(MeasuredAxisType * AxisIn)
{Axis = AxisIn;}

MeasuredUnitVectorType * EllipseFeatureMeasurementType::getNormal()
{return Normal;}

void EllipseFeatureMeasurementType::setNormal(MeasuredUnitVectorType * NormalIn)
{Normal = NormalIn;}

SweepType * EllipseFeatureMeasurementType::getSweepMeasurementRange()
{return SweepMeasurementRange;}

void EllipseFeatureMeasurementType::setSweepMeasurementRange(SweepType * SweepMeasurementRangeIn)
{SweepMeasurementRange = SweepMeasurementRangeIn;}

SweepType * EllipseFeatureMeasurementType::getSweepFull()
{return SweepFull;}

void EllipseFeatureMeasurementType::setSweepFull(SweepType * SweepFullIn)
{SweepFull = SweepFullIn;}

MeasuredLinearValueType * EllipseFeatureMeasurementType::getMajorDiameter()
{return MajorDiameter;}

void EllipseFeatureMeasurementType::setMajorDiameter(MeasuredLinearValueType * MajorDiameterIn)
{MajorDiameter = MajorDiameterIn;}

MeasuredLinearValueType * EllipseFeatureMeasurementType::getMinorDiameter()
{return MinorDiameter;}

void EllipseFeatureMeasurementType::setMinorDiameter(MeasuredLinearValueType * MinorDiameterIn)
{MinorDiameter = MinorDiameterIn;}

MeasuredLinearValueType * EllipseFeatureMeasurementType::getForm()
{return Form;}

void EllipseFeatureMeasurementType::setForm(MeasuredLinearValueType * FormIn)
{Form = FormIn;}

/* ***************************************************************** */

/* class EllipseFeatureNominalType

*/

EllipseFeatureNominalType::EllipseFeatureNominalType() :
  CurveFeatureNominalBaseType()
{
  Axis = 0;
  Normal = 0;
  Sweep = 0;
  Constructed = 0;
}

EllipseFeatureNominalType::EllipseFeatureNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 AxisType * AxisIn,
 UnitVectorType * NormalIn,
 SweepType * SweepIn,
 EllipseConstructionMethodType * ConstructedIn) :
  CurveFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    SurfaceFeatureNominalIdIn)
{
  Axis = AxisIn;
  Normal = NormalIn;
  Sweep = SweepIn;
  Constructed = ConstructedIn;
}

EllipseFeatureNominalType::EllipseFeatureNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 AxisType * AxisIn,
 UnitVectorType * NormalIn,
 SweepType * SweepIn,
 EllipseConstructionMethodType * ConstructedIn) :
  CurveFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    SurfaceFeatureNominalIdIn)
{
  Axis = AxisIn;
  Normal = NormalIn;
  Sweep = SweepIn;
  Constructed = ConstructedIn;
}

EllipseFeatureNominalType::~EllipseFeatureNominalType()
{
  #ifndef NODESTRUCT
  delete Axis;
  delete Normal;
  delete Sweep;
  delete Constructed;
  #endif
}

void EllipseFeatureNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (SurfaceFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SurfaceFeatureNominalId");
      SurfaceFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</SurfaceFeatureNominalId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Axis");
  Axis->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Axis>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Normal");
  Normal->printSelf(outFile);
  fprintf(outFile, "</Normal>\n");
  if (Sweep)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Sweep");
      Sweep->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Sweep>\n");
    }
  if (Constructed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool EllipseFeatureNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in EllipseFeatureNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in EllipseFeatureNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in EllipseFeatureNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in EllipseFeatureNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

AxisType * EllipseFeatureNominalType::getAxis()
{return Axis;}

void EllipseFeatureNominalType::setAxis(AxisType * AxisIn)
{Axis = AxisIn;}

UnitVectorType * EllipseFeatureNominalType::getNormal()
{return Normal;}

void EllipseFeatureNominalType::setNormal(UnitVectorType * NormalIn)
{Normal = NormalIn;}

SweepType * EllipseFeatureNominalType::getSweep()
{return Sweep;}

void EllipseFeatureNominalType::setSweep(SweepType * SweepIn)
{Sweep = SweepIn;}

EllipseConstructionMethodType * EllipseFeatureNominalType::getConstructed()
{return Constructed;}

void EllipseFeatureNominalType::setConstructed(EllipseConstructionMethodType * ConstructedIn)
{Constructed = ConstructedIn;}

/* ***************************************************************** */

/* class EllipseFromScanType

*/

EllipseFromScanType::EllipseFromScanType() :
  ConstructionMethodBaseType()
{
  SurfaceFeature = 0;
  SearchRadius = 0;
  Depth = 0;
}

EllipseFromScanType::EllipseFromScanType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * SurfaceFeatureIn,
 LinearValueType * SearchRadiusIn,
 LinearValueType * DepthIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  SurfaceFeature = SurfaceFeatureIn;
  SearchRadius = SearchRadiusIn;
  Depth = DepthIn;
}

EllipseFromScanType::~EllipseFromScanType()
{
  #ifndef NODESTRUCT
  delete SurfaceFeature;
  delete SearchRadius;
  delete Depth;
  #endif
}

void EllipseFromScanType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<SurfaceFeature");
  SurfaceFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</SurfaceFeature>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<SearchRadius");
  SearchRadius->printSelf(outFile);
  fprintf(outFile, "</SearchRadius>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Depth");
  Depth->printSelf(outFile);
  fprintf(outFile, "</Depth>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * EllipseFromScanType::getSurfaceFeature()
{return SurfaceFeature;}

void EllipseFromScanType::setSurfaceFeature(BaseFeatureType * SurfaceFeatureIn)
{SurfaceFeature = SurfaceFeatureIn;}

LinearValueType * EllipseFromScanType::getSearchRadius()
{return SearchRadius;}

void EllipseFromScanType::setSearchRadius(LinearValueType * SearchRadiusIn)
{SearchRadius = SearchRadiusIn;}

LinearValueType * EllipseFromScanType::getDepth()
{return Depth;}

void EllipseFromScanType::setDepth(LinearValueType * DepthIn)
{Depth = DepthIn;}

/* ***************************************************************** */

/* class EllipseIntersectionType

*/

EllipseIntersectionType::EllipseIntersectionType() :
  ConstructionMethodBaseType()
{
  IntersectionPlane = 0;
  IntersectionFeature = 0;
}

EllipseIntersectionType::EllipseIntersectionType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * IntersectionPlaneIn,
 BaseFeatureType * IntersectionFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  IntersectionPlane = IntersectionPlaneIn;
  IntersectionFeature = IntersectionFeatureIn;
}

EllipseIntersectionType::~EllipseIntersectionType()
{
  #ifndef NODESTRUCT
  delete IntersectionPlane;
  delete IntersectionFeature;
  #endif
}

void EllipseIntersectionType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<IntersectionPlane");
  IntersectionPlane->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</IntersectionPlane>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<IntersectionFeature");
  IntersectionFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</IntersectionFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * EllipseIntersectionType::getIntersectionPlane()
{return IntersectionPlane;}

void EllipseIntersectionType::setIntersectionPlane(BaseFeatureType * IntersectionPlaneIn)
{IntersectionPlane = IntersectionPlaneIn;}

BaseFeatureType * EllipseIntersectionType::getIntersectionFeature()
{return IntersectionFeature;}

void EllipseIntersectionType::setIntersectionFeature(BaseFeatureType * IntersectionFeatureIn)
{IntersectionFeature = IntersectionFeatureIn;}

/* ***************************************************************** */

/* class EllipseMeasurementDeterminationType

*/

EllipseMeasurementDeterminationType::EllipseMeasurementDeterminationType()
{
  EllipseMeasurementDeterminationTypePair = 0;
}

EllipseMeasurementDeterminationType::EllipseMeasurementDeterminationType(
 EllipseMeasurementDeterminationTypeChoicePair * EllipseMeasurementDeterminationTypePairIn)
{
  EllipseMeasurementDeterminationTypePair = EllipseMeasurementDeterminationTypePairIn;
}

EllipseMeasurementDeterminationType::~EllipseMeasurementDeterminationType()
{
  #ifndef NODESTRUCT
  delete EllipseMeasurementDeterminationTypePair;
  #endif
}

void EllipseMeasurementDeterminationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  EllipseMeasurementDeterminationTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

EllipseMeasurementDeterminationTypeChoicePair * EllipseMeasurementDeterminationType::getEllipseMeasurementDeterminationTypePair()
{return EllipseMeasurementDeterminationTypePair;}

void EllipseMeasurementDeterminationType::setEllipseMeasurementDeterminationTypePair(EllipseMeasurementDeterminationTypeChoicePair * EllipseMeasurementDeterminationTypePairIn)
{EllipseMeasurementDeterminationTypePair = EllipseMeasurementDeterminationTypePairIn;}
EllipseMeasurementDeterminationTypeChoicePair::EllipseMeasurementDeterminationTypeChoicePair() {}

EllipseMeasurementDeterminationTypeChoicePair::EllipseMeasurementDeterminationTypeChoicePair(
 whichOne EllipseMeasurementDeterminationTypeTypeIn,
 EllipseMeasurementDeterminationTypeVal * EllipseMeasurementDeterminationTypeValueIn)
{
  EllipseMeasurementDeterminationTypeType = EllipseMeasurementDeterminationTypeTypeIn;
  EllipseMeasurementDeterminationTypeValue = EllipseMeasurementDeterminationTypeValueIn;
}

EllipseMeasurementDeterminationTypeChoicePair::~EllipseMeasurementDeterminationTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (EllipseMeasurementDeterminationTypeType == CheckedE)
    delete EllipseMeasurementDeterminationTypeValue->Checked;
  else if (EllipseMeasurementDeterminationTypeType == SetE)
    delete EllipseMeasurementDeterminationTypeValue->Set;
  delete EllipseMeasurementDeterminationTypeValue;
  #endif
}

void EllipseMeasurementDeterminationTypeChoicePair::printSelf(FILE * outFile)
{
  if (EllipseMeasurementDeterminationTypeType == CheckedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Checked");
      EllipseMeasurementDeterminationTypeValue->Checked->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Checked>\n");
    }
  else if (EllipseMeasurementDeterminationTypeType == SetE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Set");
      EllipseMeasurementDeterminationTypeValue->Set->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class EllipseProjectionType

*/

EllipseProjectionType::EllipseProjectionType() :
  ConstructionMethodBaseType()
{
  ProjectionFeature = 0;
  ProjectionPlane = 0;
}

EllipseProjectionType::EllipseProjectionType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * ProjectionFeatureIn,
 BaseFeatureType * ProjectionPlaneIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  ProjectionFeature = ProjectionFeatureIn;
  ProjectionPlane = ProjectionPlaneIn;
}

EllipseProjectionType::~EllipseProjectionType()
{
  #ifndef NODESTRUCT
  delete ProjectionFeature;
  delete ProjectionPlane;
  #endif
}

void EllipseProjectionType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ProjectionFeature");
  ProjectionFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ProjectionFeature>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<ProjectionPlane");
  ProjectionPlane->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ProjectionPlane>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * EllipseProjectionType::getProjectionFeature()
{return ProjectionFeature;}

void EllipseProjectionType::setProjectionFeature(BaseFeatureType * ProjectionFeatureIn)
{ProjectionFeature = ProjectionFeatureIn;}

BaseFeatureType * EllipseProjectionType::getProjectionPlane()
{return ProjectionPlane;}

void EllipseProjectionType::setProjectionPlane(BaseFeatureType * ProjectionPlaneIn)
{ProjectionPlane = ProjectionPlaneIn;}

/* ***************************************************************** */

/* class EllipseRecompType

*/

EllipseRecompType::EllipseRecompType() :
  ConstructionMethodBaseType()
{
  BaseFeaturePointList = 0;
}

EllipseRecompType::EllipseRecompType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeaturePointListType * BaseFeaturePointListIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeaturePointList = BaseFeaturePointListIn;
}

EllipseRecompType::~EllipseRecompType()
{
  #ifndef NODESTRUCT
  delete BaseFeaturePointList;
  #endif
}

void EllipseRecompType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeaturePointList");
  BaseFeaturePointList->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeaturePointList>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeaturePointListType * EllipseRecompType::getBaseFeaturePointList()
{return BaseFeaturePointList;}

void EllipseRecompType::setBaseFeaturePointList(BaseFeaturePointListType * BaseFeaturePointListIn)
{BaseFeaturePointList = BaseFeaturePointListIn;}

/* ***************************************************************** */

/* class EllipseTransformType

*/

EllipseTransformType::EllipseTransformType() :
  ConstructionMethodBaseType()
{
  BaseEllipse = 0;
  Transformation = 0;
}

EllipseTransformType::EllipseTransformType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseEllipseIn,
 TransformationReferenceType * TransformationIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseEllipse = BaseEllipseIn;
  Transformation = TransformationIn;
}

EllipseTransformType::~EllipseTransformType()
{
  #ifndef NODESTRUCT
  delete BaseEllipse;
  delete Transformation;
  #endif
}

void EllipseTransformType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseEllipse");
  BaseEllipse->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseEllipse>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Transformation");
  Transformation->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Transformation>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * EllipseTransformType::getBaseEllipse()
{return BaseEllipse;}

void EllipseTransformType::setBaseEllipse(BaseFeatureType * BaseEllipseIn)
{BaseEllipse = BaseEllipseIn;}

TransformationReferenceType * EllipseTransformType::getTransformation()
{return Transformation;}

void EllipseTransformType::setTransformation(TransformationReferenceType * TransformationIn)
{Transformation = TransformationIn;}

/* ***************************************************************** */

/* class EllipticalArcBestFitType

*/

EllipticalArcBestFitType::EllipticalArcBestFitType() :
  ConstructionMethodBaseType()
{
  n = 0;
  BaseFeature = 0;
}

EllipticalArcBestFitType::EllipticalArcBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = 0;
  BaseFeature = BaseFeatureIn;
}

EllipticalArcBestFitType::EllipticalArcBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 NaturalType * nIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = nIn;
  BaseFeature = BaseFeatureIn;
}

EllipticalArcBestFitType::~EllipticalArcBestFitType()
{
  #ifndef NODESTRUCT
  delete n;
  delete BaseFeature;
  #endif
}

void EllipticalArcBestFitType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  {
    if (!BaseFeature)
      {
        fprintf(stderr, "BaseFeature list is missing\n");
        exit(1);
      }
    if (BaseFeature->size() == 0)
      {
        fprintf(stderr, "BaseFeature list is empty\n");
        exit(1);
      }
    if (BaseFeature->size() < 5)
      {
        fprintf(stderr,
                "size of BaseFeature list (%d) less than minimum required (5)\n",
                (int)BaseFeature->size());
        exit(1);
      }
    std::list<SequencedBaseFeatureType *>::iterator iter;
    for (iter = BaseFeature->begin();
         iter != BaseFeature->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<BaseFeature");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</BaseFeature>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool EllipticalArcBestFitType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in EllipticalArcBestFitType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in EllipticalArcBestFitType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in EllipticalArcBestFitType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in EllipticalArcBestFitType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * EllipticalArcBestFitType::getn()
{return n;}

void EllipticalArcBestFitType::setn(NaturalType * nIn)
{n = nIn;}

SequencedBaseFeatureTypeLisd * EllipticalArcBestFitType::getBaseFeature()
{return BaseFeature;}

void EllipticalArcBestFitType::setBaseFeature(SequencedBaseFeatureTypeLisd * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class EllipticalArcCastType

*/

EllipticalArcCastType::EllipticalArcCastType() :
  ConstructionMethodBaseType()
{
  BaseFeature = 0;
}

EllipticalArcCastType::EllipticalArcCastType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeature = BaseFeatureIn;
}

EllipticalArcCastType::~EllipticalArcCastType()
{
  #ifndef NODESTRUCT
  delete BaseFeature;
  #endif
}

void EllipticalArcCastType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeature");
  BaseFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * EllipticalArcCastType::getBaseFeature()
{return BaseFeature;}

void EllipticalArcCastType::setBaseFeature(BaseFeatureType * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class EllipticalArcCheckedFeatureType

*/

EllipticalArcCheckedFeatureType::EllipticalArcCheckedFeatureType()
{
  CheckDetails = 0;
}

EllipticalArcCheckedFeatureType::EllipticalArcCheckedFeatureType(
 EllipticalArcCheckedType * CheckDetailsIn)
{
  CheckDetails = CheckDetailsIn;
}

EllipticalArcCheckedFeatureType::~EllipticalArcCheckedFeatureType()
{
  #ifndef NODESTRUCT
  delete CheckDetails;
  #endif
}

void EllipticalArcCheckedFeatureType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (CheckDetails)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CheckDetails");
      CheckDetails->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CheckDetails>\n");
    }
  doSpaces(-INDENT, outFile);
}

EllipticalArcCheckedType * EllipticalArcCheckedFeatureType::getCheckDetails()
{return CheckDetails;}

void EllipticalArcCheckedFeatureType::setCheckDetails(EllipticalArcCheckedType * CheckDetailsIn)
{CheckDetails = CheckDetailsIn;}

/* ***************************************************************** */

/* class EllipticalArcCheckedType

*/

EllipticalArcCheckedType::EllipticalArcCheckedType()
{
  EllipticalArcCheckedTypePair = 0;
}

EllipticalArcCheckedType::EllipticalArcCheckedType(
 EllipticalArcCheckedTypeChoicePair * EllipticalArcCheckedTypePairIn)
{
  EllipticalArcCheckedTypePair = EllipticalArcCheckedTypePairIn;
}

EllipticalArcCheckedType::~EllipticalArcCheckedType()
{
  #ifndef NODESTRUCT
  delete EllipticalArcCheckedTypePair;
  #endif
}

void EllipticalArcCheckedType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  EllipticalArcCheckedTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

EllipticalArcCheckedTypeChoicePair * EllipticalArcCheckedType::getEllipticalArcCheckedTypePair()
{return EllipticalArcCheckedTypePair;}

void EllipticalArcCheckedType::setEllipticalArcCheckedTypePair(EllipticalArcCheckedTypeChoicePair * EllipticalArcCheckedTypePairIn)
{EllipticalArcCheckedTypePair = EllipticalArcCheckedTypePairIn;}
EllipticalArcCheckedTypeChoicePair::EllipticalArcCheckedTypeChoicePair() {}

EllipticalArcCheckedTypeChoicePair::EllipticalArcCheckedTypeChoicePair(
 whichOne EllipticalArcCheckedTypeTypeIn,
 EllipticalArcCheckedTypeVal * EllipticalArcCheckedTypeValueIn)
{
  EllipticalArcCheckedTypeType = EllipticalArcCheckedTypeTypeIn;
  EllipticalArcCheckedTypeValue = EllipticalArcCheckedTypeValueIn;
}

EllipticalArcCheckedTypeChoicePair::~EllipticalArcCheckedTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (EllipticalArcCheckedTypeType == MeasuredE)
    delete EllipticalArcCheckedTypeValue->Measured;
  else if (EllipticalArcCheckedTypeType == ConstructedE)
    delete EllipticalArcCheckedTypeValue->Constructed;
  delete EllipticalArcCheckedTypeValue;
  #endif
}

void EllipticalArcCheckedTypeChoicePair::printSelf(FILE * outFile)
{
  if (EllipticalArcCheckedTypeType == MeasuredE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Measured");
      EllipticalArcCheckedTypeValue->Measured->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Measured>\n");
    }
  else if (EllipticalArcCheckedTypeType == ConstructedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      EllipticalArcCheckedTypeValue->Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
}

/* ***************************************************************** */

/* class EllipticalArcConstructionMethodType

*/

EllipticalArcConstructionMethodType::EllipticalArcConstructionMethodType()
{
  EllipticalArcConstructionMethodTypePair = 0;
}

EllipticalArcConstructionMethodType::EllipticalArcConstructionMethodType(
 EllipticalArcConstructionMethodTypeChoicePair * EllipticalArcConstructionMethodTypePairIn)
{
  EllipticalArcConstructionMethodTypePair = EllipticalArcConstructionMethodTypePairIn;
}

EllipticalArcConstructionMethodType::~EllipticalArcConstructionMethodType()
{
  #ifndef NODESTRUCT
  delete EllipticalArcConstructionMethodTypePair;
  #endif
}

void EllipticalArcConstructionMethodType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (EllipticalArcConstructionMethodTypePair)
    {
      EllipticalArcConstructionMethodTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

EllipticalArcConstructionMethodTypeChoicePair * EllipticalArcConstructionMethodType::getEllipticalArcConstructionMethodTypePair()
{return EllipticalArcConstructionMethodTypePair;}

void EllipticalArcConstructionMethodType::setEllipticalArcConstructionMethodTypePair(EllipticalArcConstructionMethodTypeChoicePair * EllipticalArcConstructionMethodTypePairIn)
{EllipticalArcConstructionMethodTypePair = EllipticalArcConstructionMethodTypePairIn;}
EllipticalArcConstructionMethodTypeChoicePair::EllipticalArcConstructionMethodTypeChoicePair() {}

EllipticalArcConstructionMethodTypeChoicePair::EllipticalArcConstructionMethodTypeChoicePair(
 whichOne EllipticalArcConstructionMethodTypeTypeIn,
 EllipticalArcConstructionMethodTypeVal * EllipticalArcConstructionMethodTypeValueIn)
{
  EllipticalArcConstructionMethodTypeType = EllipticalArcConstructionMethodTypeTypeIn;
  EllipticalArcConstructionMethodTypeValue = EllipticalArcConstructionMethodTypeValueIn;
}

EllipticalArcConstructionMethodTypeChoicePair::~EllipticalArcConstructionMethodTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (EllipticalArcConstructionMethodTypeType == BestFitE)
    delete EllipticalArcConstructionMethodTypeValue->BestFit;
  else if (EllipticalArcConstructionMethodTypeType == RecompensatedE)
    delete EllipticalArcConstructionMethodTypeValue->Recompensated;
  else if (EllipticalArcConstructionMethodTypeType == IntersectionE)
    delete EllipticalArcConstructionMethodTypeValue->Intersection;
  else if (EllipticalArcConstructionMethodTypeType == ProjectionE)
    delete EllipticalArcConstructionMethodTypeValue->Projection;
  else if (EllipticalArcConstructionMethodTypeType == CopyE)
    delete EllipticalArcConstructionMethodTypeValue->Copy;
  else if (EllipticalArcConstructionMethodTypeType == CastE)
    delete EllipticalArcConstructionMethodTypeValue->Cast;
  else if (EllipticalArcConstructionMethodTypeType == TransformE)
    delete EllipticalArcConstructionMethodTypeValue->Transform;
  else if (EllipticalArcConstructionMethodTypeType == FromScanE)
    delete EllipticalArcConstructionMethodTypeValue->FromScan;
  delete EllipticalArcConstructionMethodTypeValue;
  #endif
}

void EllipticalArcConstructionMethodTypeChoicePair::printSelf(FILE * outFile)
{
  if (EllipticalArcConstructionMethodTypeType == BestFitE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BestFit");
      EllipticalArcConstructionMethodTypeValue->BestFit->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BestFit>\n");
    }
  else if (EllipticalArcConstructionMethodTypeType == RecompensatedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Recompensated");
      EllipticalArcConstructionMethodTypeValue->Recompensated->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Recompensated>\n");
    }
  else if (EllipticalArcConstructionMethodTypeType == IntersectionE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Intersection");
      EllipticalArcConstructionMethodTypeValue->Intersection->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Intersection>\n");
    }
  else if (EllipticalArcConstructionMethodTypeType == ProjectionE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Projection");
      EllipticalArcConstructionMethodTypeValue->Projection->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Projection>\n");
    }
  else if (EllipticalArcConstructionMethodTypeType == CopyE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Copy");
      EllipticalArcConstructionMethodTypeValue->Copy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Copy>\n");
    }
  else if (EllipticalArcConstructionMethodTypeType == CastE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Cast");
      EllipticalArcConstructionMethodTypeValue->Cast->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Cast>\n");
    }
  else if (EllipticalArcConstructionMethodTypeType == TransformE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Transform");
      EllipticalArcConstructionMethodTypeValue->Transform->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Transform>\n");
    }
  else if (EllipticalArcConstructionMethodTypeType == FromScanE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FromScan");
      EllipticalArcConstructionMethodTypeValue->FromScan->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FromScan>\n");
    }
}

/* ***************************************************************** */

/* class EllipticalArcCopyType

*/

EllipticalArcCopyType::EllipticalArcCopyType() :
  ConstructionMethodBaseType()
{
  BaseEllipticalArc = 0;
}

EllipticalArcCopyType::EllipticalArcCopyType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseEllipticalArcIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseEllipticalArc = BaseEllipticalArcIn;
}

EllipticalArcCopyType::~EllipticalArcCopyType()
{
  #ifndef NODESTRUCT
  delete BaseEllipticalArc;
  #endif
}

void EllipticalArcCopyType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseEllipticalArc");
  BaseEllipticalArc->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseEllipticalArc>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * EllipticalArcCopyType::getBaseEllipticalArc()
{return BaseEllipticalArc;}

void EllipticalArcCopyType::setBaseEllipticalArc(BaseFeatureType * BaseEllipticalArcIn)
{BaseEllipticalArc = BaseEllipticalArcIn;}

/* ***************************************************************** */

/* class EllipticalArcFeatureDefinitionType

*/

EllipticalArcFeatureDefinitionType::EllipticalArcFeatureDefinitionType() :
  CurveFeatureDefinitionBaseType()
{
  InternalExternal = 0;
  MajorDiameter = 0;
  MinorDiameter = 0;
}

EllipticalArcFeatureDefinitionType::EllipticalArcFeatureDefinitionType(
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * MajorDiameterIn,
 LinearValueType * MinorDiameterIn) :
  CurveFeatureDefinitionBaseType(
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  MajorDiameter = MajorDiameterIn;
  MinorDiameter = MinorDiameterIn;
}

EllipticalArcFeatureDefinitionType::EllipticalArcFeatureDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * MajorDiameterIn,
 LinearValueType * MinorDiameterIn) :
  CurveFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  MajorDiameter = MajorDiameterIn;
  MinorDiameter = MinorDiameterIn;
}

EllipticalArcFeatureDefinitionType::~EllipticalArcFeatureDefinitionType()
{
  #ifndef NODESTRUCT
  delete InternalExternal;
  delete MajorDiameter;
  delete MinorDiameter;
  #endif
}

void EllipticalArcFeatureDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<InternalExternal");
  InternalExternal->printSelf(outFile);
  fprintf(outFile, "</InternalExternal>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MajorDiameter");
  MajorDiameter->printSelf(outFile);
  fprintf(outFile, "</MajorDiameter>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MinorDiameter");
  MinorDiameter->printSelf(outFile);
  fprintf(outFile, "</MinorDiameter>\n");
  doSpaces(-INDENT, outFile);
}

bool EllipticalArcFeatureDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in EllipticalArcFeatureDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in EllipticalArcFeatureDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in EllipticalArcFeatureDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in EllipticalArcFeatureDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

InternalExternalEnumType * EllipticalArcFeatureDefinitionType::getInternalExternal()
{return InternalExternal;}

void EllipticalArcFeatureDefinitionType::setInternalExternal(InternalExternalEnumType * InternalExternalIn)
{InternalExternal = InternalExternalIn;}

LinearValueType * EllipticalArcFeatureDefinitionType::getMajorDiameter()
{return MajorDiameter;}

void EllipticalArcFeatureDefinitionType::setMajorDiameter(LinearValueType * MajorDiameterIn)
{MajorDiameter = MajorDiameterIn;}

LinearValueType * EllipticalArcFeatureDefinitionType::getMinorDiameter()
{return MinorDiameter;}

void EllipticalArcFeatureDefinitionType::setMinorDiameter(LinearValueType * MinorDiameterIn)
{MinorDiameter = MinorDiameterIn;}

/* ***************************************************************** */

/* class EllipticalArcFeatureItemType

*/

EllipticalArcFeatureItemType::EllipticalArcFeatureItemType() :
  CurveFeatureItemBaseType()
{
  DeterminationMode = 0;
}

EllipticalArcFeatureItemType::EllipticalArcFeatureItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 EllipticalArcMeasurementDeterminationType * DeterminationModeIn) :
  CurveFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

EllipticalArcFeatureItemType::EllipticalArcFeatureItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 EllipticalArcMeasurementDeterminationType * DeterminationModeIn) :
  CurveFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

EllipticalArcFeatureItemType::~EllipticalArcFeatureItemType()
{
  #ifndef NODESTRUCT
  delete DeterminationMode;
  #endif
}

void EllipticalArcFeatureItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<DeterminationMode");
  DeterminationMode->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeterminationMode>\n");
  doSpaces(-INDENT, outFile);
}

bool EllipticalArcFeatureItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in EllipticalArcFeatureItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in EllipticalArcFeatureItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in EllipticalArcFeatureItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in EllipticalArcFeatureItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

EllipticalArcMeasurementDeterminationType * EllipticalArcFeatureItemType::getDeterminationMode()
{return DeterminationMode;}

void EllipticalArcFeatureItemType::setDeterminationMode(EllipticalArcMeasurementDeterminationType * DeterminationModeIn)
{DeterminationMode = DeterminationModeIn;}

/* ***************************************************************** */

/* class EllipticalArcFeatureMeasurementType

*/

EllipticalArcFeatureMeasurementType::EllipticalArcFeatureMeasurementType() :
  CurveFeatureMeasurementBaseType()
{
  Axis = 0;
  Normal = 0;
  SweepMeasurementRange = 0;
  SweepFull = 0;
  MajorDiameter = 0;
  MinorDiameter = 0;
  Form = 0;
}

EllipticalArcFeatureMeasurementType::EllipticalArcFeatureMeasurementType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredAxisType * AxisIn,
 MeasuredUnitVectorType * NormalIn,
 SweepType * SweepMeasurementRangeIn,
 SweepType * SweepFullIn,
 MeasuredLinearValueType * MajorDiameterIn,
 MeasuredLinearValueType * MinorDiameterIn,
 MeasuredLinearValueType * FormIn) :
  CurveFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Axis = AxisIn;
  Normal = NormalIn;
  SweepMeasurementRange = SweepMeasurementRangeIn;
  SweepFull = SweepFullIn;
  MajorDiameter = MajorDiameterIn;
  MinorDiameter = MinorDiameterIn;
  Form = FormIn;
}

EllipticalArcFeatureMeasurementType::EllipticalArcFeatureMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredAxisType * AxisIn,
 MeasuredUnitVectorType * NormalIn,
 SweepType * SweepMeasurementRangeIn,
 SweepType * SweepFullIn,
 MeasuredLinearValueType * MajorDiameterIn,
 MeasuredLinearValueType * MinorDiameterIn,
 MeasuredLinearValueType * FormIn) :
  CurveFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Axis = AxisIn;
  Normal = NormalIn;
  SweepMeasurementRange = SweepMeasurementRangeIn;
  SweepFull = SweepFullIn;
  MajorDiameter = MajorDiameterIn;
  MinorDiameter = MinorDiameterIn;
  Form = FormIn;
}

EllipticalArcFeatureMeasurementType::~EllipticalArcFeatureMeasurementType()
{
  #ifndef NODESTRUCT
  delete Axis;
  delete Normal;
  delete SweepMeasurementRange;
  delete SweepFull;
  delete MajorDiameter;
  delete MinorDiameter;
  delete Form;
  #endif
}

void EllipticalArcFeatureMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  if (Axis)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Axis");
      Axis->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Axis>\n");
    }
  if (Normal)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Normal");
      Normal->printSelf(outFile);
      fprintf(outFile, "</Normal>\n");
    }
  if (SweepMeasurementRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SweepMeasurementRange");
      SweepMeasurementRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SweepMeasurementRange>\n");
    }
  if (SweepFull)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SweepFull");
      SweepFull->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SweepFull>\n");
    }
  if (MajorDiameter)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MajorDiameter");
      MajorDiameter->printSelf(outFile);
      fprintf(outFile, "</MajorDiameter>\n");
    }
  if (MinorDiameter)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinorDiameter");
      MinorDiameter->printSelf(outFile);
      fprintf(outFile, "</MinorDiameter>\n");
    }
  if (Form)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Form");
      Form->printSelf(outFile);
      fprintf(outFile, "</Form>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool EllipticalArcFeatureMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in EllipticalArcFeatureMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in EllipticalArcFeatureMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in EllipticalArcFeatureMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in EllipticalArcFeatureMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredAxisType * EllipticalArcFeatureMeasurementType::getAxis()
{return Axis;}

void EllipticalArcFeatureMeasurementType::setAxis(MeasuredAxisType * AxisIn)
{Axis = AxisIn;}

MeasuredUnitVectorType * EllipticalArcFeatureMeasurementType::getNormal()
{return Normal;}

void EllipticalArcFeatureMeasurementType::setNormal(MeasuredUnitVectorType * NormalIn)
{Normal = NormalIn;}

SweepType * EllipticalArcFeatureMeasurementType::getSweepMeasurementRange()
{return SweepMeasurementRange;}

void EllipticalArcFeatureMeasurementType::setSweepMeasurementRange(SweepType * SweepMeasurementRangeIn)
{SweepMeasurementRange = SweepMeasurementRangeIn;}

SweepType * EllipticalArcFeatureMeasurementType::getSweepFull()
{return SweepFull;}

void EllipticalArcFeatureMeasurementType::setSweepFull(SweepType * SweepFullIn)
{SweepFull = SweepFullIn;}

MeasuredLinearValueType * EllipticalArcFeatureMeasurementType::getMajorDiameter()
{return MajorDiameter;}

void EllipticalArcFeatureMeasurementType::setMajorDiameter(MeasuredLinearValueType * MajorDiameterIn)
{MajorDiameter = MajorDiameterIn;}

MeasuredLinearValueType * EllipticalArcFeatureMeasurementType::getMinorDiameter()
{return MinorDiameter;}

void EllipticalArcFeatureMeasurementType::setMinorDiameter(MeasuredLinearValueType * MinorDiameterIn)
{MinorDiameter = MinorDiameterIn;}

MeasuredLinearValueType * EllipticalArcFeatureMeasurementType::getForm()
{return Form;}

void EllipticalArcFeatureMeasurementType::setForm(MeasuredLinearValueType * FormIn)
{Form = FormIn;}

/* ***************************************************************** */

/* class EllipticalArcFeatureNominalType

*/

EllipticalArcFeatureNominalType::EllipticalArcFeatureNominalType() :
  CurveFeatureNominalBaseType()
{
  Axis = 0;
  Normal = 0;
  Sweep = 0;
  Constructed = 0;
}

EllipticalArcFeatureNominalType::EllipticalArcFeatureNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 AxisType * AxisIn,
 UnitVectorType * NormalIn,
 SweepType * SweepIn,
 EllipticalArcConstructionMethodType * ConstructedIn) :
  CurveFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    SurfaceFeatureNominalIdIn)
{
  Axis = AxisIn;
  Normal = NormalIn;
  Sweep = SweepIn;
  Constructed = ConstructedIn;
}

EllipticalArcFeatureNominalType::EllipticalArcFeatureNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 AxisType * AxisIn,
 UnitVectorType * NormalIn,
 SweepType * SweepIn,
 EllipticalArcConstructionMethodType * ConstructedIn) :
  CurveFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    SurfaceFeatureNominalIdIn)
{
  Axis = AxisIn;
  Normal = NormalIn;
  Sweep = SweepIn;
  Constructed = ConstructedIn;
}

EllipticalArcFeatureNominalType::~EllipticalArcFeatureNominalType()
{
  #ifndef NODESTRUCT
  delete Axis;
  delete Normal;
  delete Sweep;
  delete Constructed;
  #endif
}

void EllipticalArcFeatureNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (SurfaceFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SurfaceFeatureNominalId");
      SurfaceFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</SurfaceFeatureNominalId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Axis");
  Axis->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Axis>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Normal");
  Normal->printSelf(outFile);
  fprintf(outFile, "</Normal>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Sweep");
  Sweep->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Sweep>\n");
  if (Constructed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool EllipticalArcFeatureNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in EllipticalArcFeatureNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in EllipticalArcFeatureNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in EllipticalArcFeatureNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in EllipticalArcFeatureNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

AxisType * EllipticalArcFeatureNominalType::getAxis()
{return Axis;}

void EllipticalArcFeatureNominalType::setAxis(AxisType * AxisIn)
{Axis = AxisIn;}

UnitVectorType * EllipticalArcFeatureNominalType::getNormal()
{return Normal;}

void EllipticalArcFeatureNominalType::setNormal(UnitVectorType * NormalIn)
{Normal = NormalIn;}

SweepType * EllipticalArcFeatureNominalType::getSweep()
{return Sweep;}

void EllipticalArcFeatureNominalType::setSweep(SweepType * SweepIn)
{Sweep = SweepIn;}

EllipticalArcConstructionMethodType * EllipticalArcFeatureNominalType::getConstructed()
{return Constructed;}

void EllipticalArcFeatureNominalType::setConstructed(EllipticalArcConstructionMethodType * ConstructedIn)
{Constructed = ConstructedIn;}

/* ***************************************************************** */

/* class EllipticalArcFromScanType

*/

EllipticalArcFromScanType::EllipticalArcFromScanType() :
  ConstructionMethodBaseType()
{
  SurfaceFeature = 0;
  SearchRadius = 0;
  Depth = 0;
}

EllipticalArcFromScanType::EllipticalArcFromScanType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * SurfaceFeatureIn,
 LinearValueType * SearchRadiusIn,
 LinearValueType * DepthIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  SurfaceFeature = SurfaceFeatureIn;
  SearchRadius = SearchRadiusIn;
  Depth = DepthIn;
}

EllipticalArcFromScanType::~EllipticalArcFromScanType()
{
  #ifndef NODESTRUCT
  delete SurfaceFeature;
  delete SearchRadius;
  delete Depth;
  #endif
}

void EllipticalArcFromScanType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<SurfaceFeature");
  SurfaceFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</SurfaceFeature>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<SearchRadius");
  SearchRadius->printSelf(outFile);
  fprintf(outFile, "</SearchRadius>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Depth");
  Depth->printSelf(outFile);
  fprintf(outFile, "</Depth>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * EllipticalArcFromScanType::getSurfaceFeature()
{return SurfaceFeature;}

void EllipticalArcFromScanType::setSurfaceFeature(BaseFeatureType * SurfaceFeatureIn)
{SurfaceFeature = SurfaceFeatureIn;}

LinearValueType * EllipticalArcFromScanType::getSearchRadius()
{return SearchRadius;}

void EllipticalArcFromScanType::setSearchRadius(LinearValueType * SearchRadiusIn)
{SearchRadius = SearchRadiusIn;}

LinearValueType * EllipticalArcFromScanType::getDepth()
{return Depth;}

void EllipticalArcFromScanType::setDepth(LinearValueType * DepthIn)
{Depth = DepthIn;}

/* ***************************************************************** */

/* class EllipticalArcIntersectionType

*/

EllipticalArcIntersectionType::EllipticalArcIntersectionType() :
  ConstructionMethodBaseType()
{
  IntersectionPlane = 0;
  IntersectionFeature = 0;
}

EllipticalArcIntersectionType::EllipticalArcIntersectionType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * IntersectionPlaneIn,
 BaseFeatureType * IntersectionFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  IntersectionPlane = IntersectionPlaneIn;
  IntersectionFeature = IntersectionFeatureIn;
}

EllipticalArcIntersectionType::~EllipticalArcIntersectionType()
{
  #ifndef NODESTRUCT
  delete IntersectionPlane;
  delete IntersectionFeature;
  #endif
}

void EllipticalArcIntersectionType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<IntersectionPlane");
  IntersectionPlane->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</IntersectionPlane>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<IntersectionFeature");
  IntersectionFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</IntersectionFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * EllipticalArcIntersectionType::getIntersectionPlane()
{return IntersectionPlane;}

void EllipticalArcIntersectionType::setIntersectionPlane(BaseFeatureType * IntersectionPlaneIn)
{IntersectionPlane = IntersectionPlaneIn;}

BaseFeatureType * EllipticalArcIntersectionType::getIntersectionFeature()
{return IntersectionFeature;}

void EllipticalArcIntersectionType::setIntersectionFeature(BaseFeatureType * IntersectionFeatureIn)
{IntersectionFeature = IntersectionFeatureIn;}

/* ***************************************************************** */

/* class EllipticalArcMeasurementDeterminationType

*/

EllipticalArcMeasurementDeterminationType::EllipticalArcMeasurementDeterminationType()
{
  EllipticalArcMeasurementDeterminationTypePair = 0;
}

EllipticalArcMeasurementDeterminationType::EllipticalArcMeasurementDeterminationType(
 EllipticalArcMeasurementDeterminationTypeChoicePair * EllipticalArcMeasurementDeterminationTypePairIn)
{
  EllipticalArcMeasurementDeterminationTypePair = EllipticalArcMeasurementDeterminationTypePairIn;
}

EllipticalArcMeasurementDeterminationType::~EllipticalArcMeasurementDeterminationType()
{
  #ifndef NODESTRUCT
  delete EllipticalArcMeasurementDeterminationTypePair;
  #endif
}

void EllipticalArcMeasurementDeterminationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  EllipticalArcMeasurementDeterminationTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

EllipticalArcMeasurementDeterminationTypeChoicePair * EllipticalArcMeasurementDeterminationType::getEllipticalArcMeasurementDeterminationTypePair()
{return EllipticalArcMeasurementDeterminationTypePair;}

void EllipticalArcMeasurementDeterminationType::setEllipticalArcMeasurementDeterminationTypePair(EllipticalArcMeasurementDeterminationTypeChoicePair * EllipticalArcMeasurementDeterminationTypePairIn)
{EllipticalArcMeasurementDeterminationTypePair = EllipticalArcMeasurementDeterminationTypePairIn;}
EllipticalArcMeasurementDeterminationTypeChoicePair::EllipticalArcMeasurementDeterminationTypeChoicePair() {}

EllipticalArcMeasurementDeterminationTypeChoicePair::EllipticalArcMeasurementDeterminationTypeChoicePair(
 whichOne EllipticalArcMeasurementDeterminationTypeTypeIn,
 EllipticalArcMeasurementDeterminationTypeVal * EllipticalArcMeasurementDeterminationTypeValueIn)
{
  EllipticalArcMeasurementDeterminationTypeType = EllipticalArcMeasurementDeterminationTypeTypeIn;
  EllipticalArcMeasurementDeterminationTypeValue = EllipticalArcMeasurementDeterminationTypeValueIn;
}

EllipticalArcMeasurementDeterminationTypeChoicePair::~EllipticalArcMeasurementDeterminationTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (EllipticalArcMeasurementDeterminationTypeType == CheckedE)
    delete EllipticalArcMeasurementDeterminationTypeValue->Checked;
  else if (EllipticalArcMeasurementDeterminationTypeType == SetE)
    delete EllipticalArcMeasurementDeterminationTypeValue->Set;
  delete EllipticalArcMeasurementDeterminationTypeValue;
  #endif
}

void EllipticalArcMeasurementDeterminationTypeChoicePair::printSelf(FILE * outFile)
{
  if (EllipticalArcMeasurementDeterminationTypeType == CheckedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Checked");
      EllipticalArcMeasurementDeterminationTypeValue->Checked->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Checked>\n");
    }
  else if (EllipticalArcMeasurementDeterminationTypeType == SetE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Set");
      EllipticalArcMeasurementDeterminationTypeValue->Set->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class EllipticalArcProjectionType

*/

EllipticalArcProjectionType::EllipticalArcProjectionType() :
  ConstructionMethodBaseType()
{
  ProjectionFeature = 0;
  ProjectionPlane = 0;
}

EllipticalArcProjectionType::EllipticalArcProjectionType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * ProjectionFeatureIn,
 BaseFeatureType * ProjectionPlaneIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  ProjectionFeature = ProjectionFeatureIn;
  ProjectionPlane = ProjectionPlaneIn;
}

EllipticalArcProjectionType::~EllipticalArcProjectionType()
{
  #ifndef NODESTRUCT
  delete ProjectionFeature;
  delete ProjectionPlane;
  #endif
}

void EllipticalArcProjectionType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ProjectionFeature");
  ProjectionFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ProjectionFeature>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<ProjectionPlane");
  ProjectionPlane->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ProjectionPlane>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * EllipticalArcProjectionType::getProjectionFeature()
{return ProjectionFeature;}

void EllipticalArcProjectionType::setProjectionFeature(BaseFeatureType * ProjectionFeatureIn)
{ProjectionFeature = ProjectionFeatureIn;}

BaseFeatureType * EllipticalArcProjectionType::getProjectionPlane()
{return ProjectionPlane;}

void EllipticalArcProjectionType::setProjectionPlane(BaseFeatureType * ProjectionPlaneIn)
{ProjectionPlane = ProjectionPlaneIn;}

/* ***************************************************************** */

/* class EllipticalArcRecompType

*/

EllipticalArcRecompType::EllipticalArcRecompType() :
  ConstructionMethodBaseType()
{
  BaseFeaturePointList = 0;
}

EllipticalArcRecompType::EllipticalArcRecompType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeaturePointListType * BaseFeaturePointListIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeaturePointList = BaseFeaturePointListIn;
}

EllipticalArcRecompType::~EllipticalArcRecompType()
{
  #ifndef NODESTRUCT
  delete BaseFeaturePointList;
  #endif
}

void EllipticalArcRecompType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeaturePointList");
  BaseFeaturePointList->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeaturePointList>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeaturePointListType * EllipticalArcRecompType::getBaseFeaturePointList()
{return BaseFeaturePointList;}

void EllipticalArcRecompType::setBaseFeaturePointList(BaseFeaturePointListType * BaseFeaturePointListIn)
{BaseFeaturePointList = BaseFeaturePointListIn;}

/* ***************************************************************** */

/* class EllipticalArcTransformType

*/

EllipticalArcTransformType::EllipticalArcTransformType() :
  ConstructionMethodBaseType()
{
  BaseEllipticalArc = 0;
  Transformation = 0;
}

EllipticalArcTransformType::EllipticalArcTransformType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseEllipticalArcIn,
 TransformationReferenceType * TransformationIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseEllipticalArc = BaseEllipticalArcIn;
  Transformation = TransformationIn;
}

EllipticalArcTransformType::~EllipticalArcTransformType()
{
  #ifndef NODESTRUCT
  delete BaseEllipticalArc;
  delete Transformation;
  #endif
}

void EllipticalArcTransformType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseEllipticalArc");
  BaseEllipticalArc->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseEllipticalArc>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Transformation");
  Transformation->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Transformation>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * EllipticalArcTransformType::getBaseEllipticalArc()
{return BaseEllipticalArc;}

void EllipticalArcTransformType::setBaseEllipticalArc(BaseFeatureType * BaseEllipticalArcIn)
{BaseEllipticalArc = BaseEllipticalArcIn;}

TransformationReferenceType * EllipticalArcTransformType::getTransformation()
{return Transformation;}

void EllipticalArcTransformType::setTransformation(TransformationReferenceType * TransformationIn)
{Transformation = TransformationIn;}

/* ***************************************************************** */

/* class ElongatedCircleBestFitType

*/

ElongatedCircleBestFitType::ElongatedCircleBestFitType() :
  ConstructionMethodBaseType()
{
  n = 0;
  BaseFeature = 0;
}

ElongatedCircleBestFitType::ElongatedCircleBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = 0;
  BaseFeature = BaseFeatureIn;
}

ElongatedCircleBestFitType::ElongatedCircleBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 NaturalType * nIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = nIn;
  BaseFeature = BaseFeatureIn;
}

ElongatedCircleBestFitType::~ElongatedCircleBestFitType()
{
  #ifndef NODESTRUCT
  delete n;
  delete BaseFeature;
  #endif
}

void ElongatedCircleBestFitType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  {
    if (!BaseFeature)
      {
        fprintf(stderr, "BaseFeature list is missing\n");
        exit(1);
      }
    if (BaseFeature->size() == 0)
      {
        fprintf(stderr, "BaseFeature list is empty\n");
        exit(1);
      }
    if (BaseFeature->size() < 6)
      {
        fprintf(stderr,
                "size of BaseFeature list (%d) less than minimum required (6)\n",
                (int)BaseFeature->size());
        exit(1);
      }
    std::list<SequencedBaseFeatureType *>::iterator iter;
    for (iter = BaseFeature->begin();
         iter != BaseFeature->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<BaseFeature");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</BaseFeature>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool ElongatedCircleBestFitType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in ElongatedCircleBestFitType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in ElongatedCircleBestFitType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ElongatedCircleBestFitType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in ElongatedCircleBestFitType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * ElongatedCircleBestFitType::getn()
{return n;}

void ElongatedCircleBestFitType::setn(NaturalType * nIn)
{n = nIn;}

SequencedBaseFeatureTypeLisd * ElongatedCircleBestFitType::getBaseFeature()
{return BaseFeature;}

void ElongatedCircleBestFitType::setBaseFeature(SequencedBaseFeatureTypeLisd * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class ElongatedCircleCastType

*/

ElongatedCircleCastType::ElongatedCircleCastType() :
  ConstructionMethodBaseType()
{
  BaseFeature = 0;
}

ElongatedCircleCastType::ElongatedCircleCastType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeature = BaseFeatureIn;
}

ElongatedCircleCastType::~ElongatedCircleCastType()
{
  #ifndef NODESTRUCT
  delete BaseFeature;
  #endif
}

void ElongatedCircleCastType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeature");
  BaseFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * ElongatedCircleCastType::getBaseFeature()
{return BaseFeature;}

void ElongatedCircleCastType::setBaseFeature(BaseFeatureType * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class ElongatedCircleCheckedFeatureType

*/

ElongatedCircleCheckedFeatureType::ElongatedCircleCheckedFeatureType()
{
  CheckDetails = 0;
}

ElongatedCircleCheckedFeatureType::ElongatedCircleCheckedFeatureType(
 ElongatedCircleCheckedType * CheckDetailsIn)
{
  CheckDetails = CheckDetailsIn;
}

ElongatedCircleCheckedFeatureType::~ElongatedCircleCheckedFeatureType()
{
  #ifndef NODESTRUCT
  delete CheckDetails;
  #endif
}

void ElongatedCircleCheckedFeatureType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (CheckDetails)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CheckDetails");
      CheckDetails->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CheckDetails>\n");
    }
  doSpaces(-INDENT, outFile);
}

ElongatedCircleCheckedType * ElongatedCircleCheckedFeatureType::getCheckDetails()
{return CheckDetails;}

void ElongatedCircleCheckedFeatureType::setCheckDetails(ElongatedCircleCheckedType * CheckDetailsIn)
{CheckDetails = CheckDetailsIn;}

/* ***************************************************************** */

/* class ElongatedCircleCheckedType

*/

ElongatedCircleCheckedType::ElongatedCircleCheckedType()
{
  ElongatedCircleCheckedTypePair = 0;
}

ElongatedCircleCheckedType::ElongatedCircleCheckedType(
 ElongatedCircleCheckedTypeChoicePair * ElongatedCircleCheckedTypePairIn)
{
  ElongatedCircleCheckedTypePair = ElongatedCircleCheckedTypePairIn;
}

ElongatedCircleCheckedType::~ElongatedCircleCheckedType()
{
  #ifndef NODESTRUCT
  delete ElongatedCircleCheckedTypePair;
  #endif
}

void ElongatedCircleCheckedType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  ElongatedCircleCheckedTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

ElongatedCircleCheckedTypeChoicePair * ElongatedCircleCheckedType::getElongatedCircleCheckedTypePair()
{return ElongatedCircleCheckedTypePair;}

void ElongatedCircleCheckedType::setElongatedCircleCheckedTypePair(ElongatedCircleCheckedTypeChoicePair * ElongatedCircleCheckedTypePairIn)
{ElongatedCircleCheckedTypePair = ElongatedCircleCheckedTypePairIn;}
ElongatedCircleCheckedTypeChoicePair::ElongatedCircleCheckedTypeChoicePair() {}

ElongatedCircleCheckedTypeChoicePair::ElongatedCircleCheckedTypeChoicePair(
 whichOne ElongatedCircleCheckedTypeTypeIn,
 ElongatedCircleCheckedTypeVal * ElongatedCircleCheckedTypeValueIn)
{
  ElongatedCircleCheckedTypeType = ElongatedCircleCheckedTypeTypeIn;
  ElongatedCircleCheckedTypeValue = ElongatedCircleCheckedTypeValueIn;
}

ElongatedCircleCheckedTypeChoicePair::~ElongatedCircleCheckedTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (ElongatedCircleCheckedTypeType == MeasuredE)
    delete ElongatedCircleCheckedTypeValue->Measured;
  else if (ElongatedCircleCheckedTypeType == ConstructedE)
    delete ElongatedCircleCheckedTypeValue->Constructed;
  delete ElongatedCircleCheckedTypeValue;
  #endif
}

void ElongatedCircleCheckedTypeChoicePair::printSelf(FILE * outFile)
{
  if (ElongatedCircleCheckedTypeType == MeasuredE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Measured");
      ElongatedCircleCheckedTypeValue->Measured->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Measured>\n");
    }
  else if (ElongatedCircleCheckedTypeType == ConstructedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      ElongatedCircleCheckedTypeValue->Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
}

/* ***************************************************************** */

/* class ElongatedCircleConstructionMethodType

*/

ElongatedCircleConstructionMethodType::ElongatedCircleConstructionMethodType()
{
  ElongatedCircleConstructionMethodTypePair = 0;
}

ElongatedCircleConstructionMethodType::ElongatedCircleConstructionMethodType(
 ElongatedCircleConstructionMethodTypeChoicePair * ElongatedCircleConstructionMethodTypePairIn)
{
  ElongatedCircleConstructionMethodTypePair = ElongatedCircleConstructionMethodTypePairIn;
}

ElongatedCircleConstructionMethodType::~ElongatedCircleConstructionMethodType()
{
  #ifndef NODESTRUCT
  delete ElongatedCircleConstructionMethodTypePair;
  #endif
}

void ElongatedCircleConstructionMethodType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (ElongatedCircleConstructionMethodTypePair)
    {
      ElongatedCircleConstructionMethodTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

ElongatedCircleConstructionMethodTypeChoicePair * ElongatedCircleConstructionMethodType::getElongatedCircleConstructionMethodTypePair()
{return ElongatedCircleConstructionMethodTypePair;}

void ElongatedCircleConstructionMethodType::setElongatedCircleConstructionMethodTypePair(ElongatedCircleConstructionMethodTypeChoicePair * ElongatedCircleConstructionMethodTypePairIn)
{ElongatedCircleConstructionMethodTypePair = ElongatedCircleConstructionMethodTypePairIn;}
ElongatedCircleConstructionMethodTypeChoicePair::ElongatedCircleConstructionMethodTypeChoicePair() {}

ElongatedCircleConstructionMethodTypeChoicePair::ElongatedCircleConstructionMethodTypeChoicePair(
 whichOne ElongatedCircleConstructionMethodTypeTypeIn,
 ElongatedCircleConstructionMethodTypeVal * ElongatedCircleConstructionMethodTypeValueIn)
{
  ElongatedCircleConstructionMethodTypeType = ElongatedCircleConstructionMethodTypeTypeIn;
  ElongatedCircleConstructionMethodTypeValue = ElongatedCircleConstructionMethodTypeValueIn;
}

ElongatedCircleConstructionMethodTypeChoicePair::~ElongatedCircleConstructionMethodTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (ElongatedCircleConstructionMethodTypeType == BestFitE)
    delete ElongatedCircleConstructionMethodTypeValue->BestFit;
  else if (ElongatedCircleConstructionMethodTypeType == RecompensatedE)
    delete ElongatedCircleConstructionMethodTypeValue->Recompensated;
  else if (ElongatedCircleConstructionMethodTypeType == CopyE)
    delete ElongatedCircleConstructionMethodTypeValue->Copy;
  else if (ElongatedCircleConstructionMethodTypeType == CastE)
    delete ElongatedCircleConstructionMethodTypeValue->Cast;
  else if (ElongatedCircleConstructionMethodTypeType == TransformE)
    delete ElongatedCircleConstructionMethodTypeValue->Transform;
  delete ElongatedCircleConstructionMethodTypeValue;
  #endif
}

void ElongatedCircleConstructionMethodTypeChoicePair::printSelf(FILE * outFile)
{
  if (ElongatedCircleConstructionMethodTypeType == BestFitE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BestFit");
      ElongatedCircleConstructionMethodTypeValue->BestFit->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BestFit>\n");
    }
  else if (ElongatedCircleConstructionMethodTypeType == RecompensatedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Recompensated");
      ElongatedCircleConstructionMethodTypeValue->Recompensated->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Recompensated>\n");
    }
  else if (ElongatedCircleConstructionMethodTypeType == CopyE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Copy");
      ElongatedCircleConstructionMethodTypeValue->Copy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Copy>\n");
    }
  else if (ElongatedCircleConstructionMethodTypeType == CastE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Cast");
      ElongatedCircleConstructionMethodTypeValue->Cast->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Cast>\n");
    }
  else if (ElongatedCircleConstructionMethodTypeType == TransformE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Transform");
      ElongatedCircleConstructionMethodTypeValue->Transform->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Transform>\n");
    }
}

/* ***************************************************************** */

/* class ElongatedCircleCopyType

*/

ElongatedCircleCopyType::ElongatedCircleCopyType() :
  ConstructionMethodBaseType()
{
  BaseElongatedCircle = 0;
}

ElongatedCircleCopyType::ElongatedCircleCopyType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseElongatedCircleIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseElongatedCircle = BaseElongatedCircleIn;
}

ElongatedCircleCopyType::~ElongatedCircleCopyType()
{
  #ifndef NODESTRUCT
  delete BaseElongatedCircle;
  #endif
}

void ElongatedCircleCopyType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseElongatedCircle");
  BaseElongatedCircle->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseElongatedCircle>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * ElongatedCircleCopyType::getBaseElongatedCircle()
{return BaseElongatedCircle;}

void ElongatedCircleCopyType::setBaseElongatedCircle(BaseFeatureType * BaseElongatedCircleIn)
{BaseElongatedCircle = BaseElongatedCircleIn;}

/* ***************************************************************** */

/* class ElongatedCircleFeatureDefinitionType

*/

ElongatedCircleFeatureDefinitionType::ElongatedCircleFeatureDefinitionType() :
  CurveFeatureDefinitionBaseType()
{
  InternalExternal = 0;
  Diameter = 0;
  Length = 0;
}

ElongatedCircleFeatureDefinitionType::ElongatedCircleFeatureDefinitionType(
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * DiameterIn,
 LinearValueType * LengthIn) :
  CurveFeatureDefinitionBaseType(
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  Diameter = DiameterIn;
  Length = LengthIn;
}

ElongatedCircleFeatureDefinitionType::ElongatedCircleFeatureDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * DiameterIn,
 LinearValueType * LengthIn) :
  CurveFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  Diameter = DiameterIn;
  Length = LengthIn;
}

ElongatedCircleFeatureDefinitionType::~ElongatedCircleFeatureDefinitionType()
{
  #ifndef NODESTRUCT
  delete InternalExternal;
  delete Diameter;
  delete Length;
  #endif
}

void ElongatedCircleFeatureDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<InternalExternal");
  InternalExternal->printSelf(outFile);
  fprintf(outFile, "</InternalExternal>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Diameter");
  Diameter->printSelf(outFile);
  fprintf(outFile, "</Diameter>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Length");
  Length->printSelf(outFile);
  fprintf(outFile, "</Length>\n");
  doSpaces(-INDENT, outFile);
}

bool ElongatedCircleFeatureDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ElongatedCircleFeatureDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ElongatedCircleFeatureDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ElongatedCircleFeatureDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ElongatedCircleFeatureDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

InternalExternalEnumType * ElongatedCircleFeatureDefinitionType::getInternalExternal()
{return InternalExternal;}

void ElongatedCircleFeatureDefinitionType::setInternalExternal(InternalExternalEnumType * InternalExternalIn)
{InternalExternal = InternalExternalIn;}

LinearValueType * ElongatedCircleFeatureDefinitionType::getDiameter()
{return Diameter;}

void ElongatedCircleFeatureDefinitionType::setDiameter(LinearValueType * DiameterIn)
{Diameter = DiameterIn;}

LinearValueType * ElongatedCircleFeatureDefinitionType::getLength()
{return Length;}

void ElongatedCircleFeatureDefinitionType::setLength(LinearValueType * LengthIn)
{Length = LengthIn;}

/* ***************************************************************** */

/* class ElongatedCircleFeatureItemType

*/

ElongatedCircleFeatureItemType::ElongatedCircleFeatureItemType() :
  CurveFeatureItemBaseType()
{
  DeterminationMode = 0;
}

ElongatedCircleFeatureItemType::ElongatedCircleFeatureItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 ElongatedCircleMeasurementDeterminationType * DeterminationModeIn) :
  CurveFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

ElongatedCircleFeatureItemType::ElongatedCircleFeatureItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 ElongatedCircleMeasurementDeterminationType * DeterminationModeIn) :
  CurveFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

ElongatedCircleFeatureItemType::~ElongatedCircleFeatureItemType()
{
  #ifndef NODESTRUCT
  delete DeterminationMode;
  #endif
}

void ElongatedCircleFeatureItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<DeterminationMode");
  DeterminationMode->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeterminationMode>\n");
  doSpaces(-INDENT, outFile);
}

bool ElongatedCircleFeatureItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ElongatedCircleFeatureItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ElongatedCircleFeatureItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ElongatedCircleFeatureItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ElongatedCircleFeatureItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

ElongatedCircleMeasurementDeterminationType * ElongatedCircleFeatureItemType::getDeterminationMode()
{return DeterminationMode;}

void ElongatedCircleFeatureItemType::setDeterminationMode(ElongatedCircleMeasurementDeterminationType * DeterminationModeIn)
{DeterminationMode = DeterminationModeIn;}

/* ***************************************************************** */

/* class ElongatedCircleFeatureMeasurementType

*/

ElongatedCircleFeatureMeasurementType::ElongatedCircleFeatureMeasurementType() :
  CurveFeatureMeasurementBaseType()
{
  Diameter = 0;
  DiameterMin = 0;
  DiameterMax = 0;
  CenterLine = 0;
  Normal = 0;
  Length = 0;
  LengthMax = 0;
  LengthMin = 0;
  Form = 0;
}

ElongatedCircleFeatureMeasurementType::ElongatedCircleFeatureMeasurementType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredLinearValueType * DiameterIn,
 MeasuredLinearValueType * DiameterMinIn,
 MeasuredLinearValueType * DiameterMaxIn,
 MeasuredPointAndVectorType * CenterLineIn,
 MeasuredUnitVectorType * NormalIn,
 MeasuredLinearValueType * LengthIn,
 MeasuredLinearValueType * LengthMaxIn,
 MeasuredLinearValueType * LengthMinIn,
 MeasuredLinearValueType * FormIn) :
  CurveFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Diameter = DiameterIn;
  DiameterMin = DiameterMinIn;
  DiameterMax = DiameterMaxIn;
  CenterLine = CenterLineIn;
  Normal = NormalIn;
  Length = LengthIn;
  LengthMax = LengthMaxIn;
  LengthMin = LengthMinIn;
  Form = FormIn;
}

ElongatedCircleFeatureMeasurementType::ElongatedCircleFeatureMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredLinearValueType * DiameterIn,
 MeasuredLinearValueType * DiameterMinIn,
 MeasuredLinearValueType * DiameterMaxIn,
 MeasuredPointAndVectorType * CenterLineIn,
 MeasuredUnitVectorType * NormalIn,
 MeasuredLinearValueType * LengthIn,
 MeasuredLinearValueType * LengthMaxIn,
 MeasuredLinearValueType * LengthMinIn,
 MeasuredLinearValueType * FormIn) :
  CurveFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Diameter = DiameterIn;
  DiameterMin = DiameterMinIn;
  DiameterMax = DiameterMaxIn;
  CenterLine = CenterLineIn;
  Normal = NormalIn;
  Length = LengthIn;
  LengthMax = LengthMaxIn;
  LengthMin = LengthMinIn;
  Form = FormIn;
}

ElongatedCircleFeatureMeasurementType::~ElongatedCircleFeatureMeasurementType()
{
  #ifndef NODESTRUCT
  delete Diameter;
  delete DiameterMin;
  delete DiameterMax;
  delete CenterLine;
  delete Normal;
  delete Length;
  delete LengthMax;
  delete LengthMin;
  delete Form;
  #endif
}

void ElongatedCircleFeatureMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  if (Diameter)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Diameter");
      Diameter->printSelf(outFile);
      fprintf(outFile, "</Diameter>\n");
    }
  if (DiameterMin)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DiameterMin");
      DiameterMin->printSelf(outFile);
      fprintf(outFile, "</DiameterMin>\n");
    }
  if (DiameterMax)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DiameterMax");
      DiameterMax->printSelf(outFile);
      fprintf(outFile, "</DiameterMax>\n");
    }
  if (CenterLine)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CenterLine");
      CenterLine->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CenterLine>\n");
    }
  if (Normal)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Normal");
      Normal->printSelf(outFile);
      fprintf(outFile, "</Normal>\n");
    }
  if (Length)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Length");
      Length->printSelf(outFile);
      fprintf(outFile, "</Length>\n");
    }
  if (LengthMax)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LengthMax");
      LengthMax->printSelf(outFile);
      fprintf(outFile, "</LengthMax>\n");
    }
  if (LengthMin)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LengthMin");
      LengthMin->printSelf(outFile);
      fprintf(outFile, "</LengthMin>\n");
    }
  if (Form)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Form");
      Form->printSelf(outFile);
      fprintf(outFile, "</Form>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ElongatedCircleFeatureMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ElongatedCircleFeatureMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ElongatedCircleFeatureMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ElongatedCircleFeatureMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ElongatedCircleFeatureMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredLinearValueType * ElongatedCircleFeatureMeasurementType::getDiameter()
{return Diameter;}

void ElongatedCircleFeatureMeasurementType::setDiameter(MeasuredLinearValueType * DiameterIn)
{Diameter = DiameterIn;}

MeasuredLinearValueType * ElongatedCircleFeatureMeasurementType::getDiameterMin()
{return DiameterMin;}

void ElongatedCircleFeatureMeasurementType::setDiameterMin(MeasuredLinearValueType * DiameterMinIn)
{DiameterMin = DiameterMinIn;}

MeasuredLinearValueType * ElongatedCircleFeatureMeasurementType::getDiameterMax()
{return DiameterMax;}

void ElongatedCircleFeatureMeasurementType::setDiameterMax(MeasuredLinearValueType * DiameterMaxIn)
{DiameterMax = DiameterMaxIn;}

MeasuredPointAndVectorType * ElongatedCircleFeatureMeasurementType::getCenterLine()
{return CenterLine;}

void ElongatedCircleFeatureMeasurementType::setCenterLine(MeasuredPointAndVectorType * CenterLineIn)
{CenterLine = CenterLineIn;}

MeasuredUnitVectorType * ElongatedCircleFeatureMeasurementType::getNormal()
{return Normal;}

void ElongatedCircleFeatureMeasurementType::setNormal(MeasuredUnitVectorType * NormalIn)
{Normal = NormalIn;}

MeasuredLinearValueType * ElongatedCircleFeatureMeasurementType::getLength()
{return Length;}

void ElongatedCircleFeatureMeasurementType::setLength(MeasuredLinearValueType * LengthIn)
{Length = LengthIn;}

MeasuredLinearValueType * ElongatedCircleFeatureMeasurementType::getLengthMax()
{return LengthMax;}

void ElongatedCircleFeatureMeasurementType::setLengthMax(MeasuredLinearValueType * LengthMaxIn)
{LengthMax = LengthMaxIn;}

MeasuredLinearValueType * ElongatedCircleFeatureMeasurementType::getLengthMin()
{return LengthMin;}

void ElongatedCircleFeatureMeasurementType::setLengthMin(MeasuredLinearValueType * LengthMinIn)
{LengthMin = LengthMinIn;}

MeasuredLinearValueType * ElongatedCircleFeatureMeasurementType::getForm()
{return Form;}

void ElongatedCircleFeatureMeasurementType::setForm(MeasuredLinearValueType * FormIn)
{Form = FormIn;}

/* ***************************************************************** */

/* class ElongatedCircleFeatureNominalType

*/

ElongatedCircleFeatureNominalType::ElongatedCircleFeatureNominalType() :
  CurveFeatureNominalBaseType()
{
  CenterLine = 0;
  Normal = 0;
  Constructed = 0;
}

ElongatedCircleFeatureNominalType::ElongatedCircleFeatureNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 PointAndVectorType * CenterLineIn,
 UnitVectorType * NormalIn,
 ElongatedCircleConstructionMethodType * ConstructedIn) :
  CurveFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    SurfaceFeatureNominalIdIn)
{
  CenterLine = CenterLineIn;
  Normal = NormalIn;
  Constructed = ConstructedIn;
}

ElongatedCircleFeatureNominalType::ElongatedCircleFeatureNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 PointAndVectorType * CenterLineIn,
 UnitVectorType * NormalIn,
 ElongatedCircleConstructionMethodType * ConstructedIn) :
  CurveFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    SurfaceFeatureNominalIdIn)
{
  CenterLine = CenterLineIn;
  Normal = NormalIn;
  Constructed = ConstructedIn;
}

ElongatedCircleFeatureNominalType::~ElongatedCircleFeatureNominalType()
{
  #ifndef NODESTRUCT
  delete CenterLine;
  delete Normal;
  delete Constructed;
  #endif
}

void ElongatedCircleFeatureNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (SurfaceFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SurfaceFeatureNominalId");
      SurfaceFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</SurfaceFeatureNominalId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CenterLine");
  CenterLine->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</CenterLine>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Normal");
  Normal->printSelf(outFile);
  fprintf(outFile, "</Normal>\n");
  if (Constructed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ElongatedCircleFeatureNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ElongatedCircleFeatureNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ElongatedCircleFeatureNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ElongatedCircleFeatureNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ElongatedCircleFeatureNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

PointAndVectorType * ElongatedCircleFeatureNominalType::getCenterLine()
{return CenterLine;}

void ElongatedCircleFeatureNominalType::setCenterLine(PointAndVectorType * CenterLineIn)
{CenterLine = CenterLineIn;}

UnitVectorType * ElongatedCircleFeatureNominalType::getNormal()
{return Normal;}

void ElongatedCircleFeatureNominalType::setNormal(UnitVectorType * NormalIn)
{Normal = NormalIn;}

ElongatedCircleConstructionMethodType * ElongatedCircleFeatureNominalType::getConstructed()
{return Constructed;}

void ElongatedCircleFeatureNominalType::setConstructed(ElongatedCircleConstructionMethodType * ConstructedIn)
{Constructed = ConstructedIn;}

/* ***************************************************************** */

/* class ElongatedCircleMeasurementDeterminationType

*/

ElongatedCircleMeasurementDeterminationType::ElongatedCircleMeasurementDeterminationType()
{
  ElongatedCircleMeasurementDeterminationTypePair = 0;
}

ElongatedCircleMeasurementDeterminationType::ElongatedCircleMeasurementDeterminationType(
 ElongatedCircleMeasurementDeterminationTypeChoicePair * ElongatedCircleMeasurementDeterminationTypePairIn)
{
  ElongatedCircleMeasurementDeterminationTypePair = ElongatedCircleMeasurementDeterminationTypePairIn;
}

ElongatedCircleMeasurementDeterminationType::~ElongatedCircleMeasurementDeterminationType()
{
  #ifndef NODESTRUCT
  delete ElongatedCircleMeasurementDeterminationTypePair;
  #endif
}

void ElongatedCircleMeasurementDeterminationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  ElongatedCircleMeasurementDeterminationTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

ElongatedCircleMeasurementDeterminationTypeChoicePair * ElongatedCircleMeasurementDeterminationType::getElongatedCircleMeasurementDeterminationTypePair()
{return ElongatedCircleMeasurementDeterminationTypePair;}

void ElongatedCircleMeasurementDeterminationType::setElongatedCircleMeasurementDeterminationTypePair(ElongatedCircleMeasurementDeterminationTypeChoicePair * ElongatedCircleMeasurementDeterminationTypePairIn)
{ElongatedCircleMeasurementDeterminationTypePair = ElongatedCircleMeasurementDeterminationTypePairIn;}
ElongatedCircleMeasurementDeterminationTypeChoicePair::ElongatedCircleMeasurementDeterminationTypeChoicePair() {}

ElongatedCircleMeasurementDeterminationTypeChoicePair::ElongatedCircleMeasurementDeterminationTypeChoicePair(
 whichOne ElongatedCircleMeasurementDeterminationTypeTypeIn,
 ElongatedCircleMeasurementDeterminationTypeVal * ElongatedCircleMeasurementDeterminationTypeValueIn)
{
  ElongatedCircleMeasurementDeterminationTypeType = ElongatedCircleMeasurementDeterminationTypeTypeIn;
  ElongatedCircleMeasurementDeterminationTypeValue = ElongatedCircleMeasurementDeterminationTypeValueIn;
}

ElongatedCircleMeasurementDeterminationTypeChoicePair::~ElongatedCircleMeasurementDeterminationTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (ElongatedCircleMeasurementDeterminationTypeType == CheckedE)
    delete ElongatedCircleMeasurementDeterminationTypeValue->Checked;
  else if (ElongatedCircleMeasurementDeterminationTypeType == SetE)
    delete ElongatedCircleMeasurementDeterminationTypeValue->Set;
  delete ElongatedCircleMeasurementDeterminationTypeValue;
  #endif
}

void ElongatedCircleMeasurementDeterminationTypeChoicePair::printSelf(FILE * outFile)
{
  if (ElongatedCircleMeasurementDeterminationTypeType == CheckedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Checked");
      ElongatedCircleMeasurementDeterminationTypeValue->Checked->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Checked>\n");
    }
  else if (ElongatedCircleMeasurementDeterminationTypeType == SetE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Set");
      ElongatedCircleMeasurementDeterminationTypeValue->Set->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class ElongatedCircleRecompType

*/

ElongatedCircleRecompType::ElongatedCircleRecompType() :
  ConstructionMethodBaseType()
{
  BaseFeaturePointList = 0;
}

ElongatedCircleRecompType::ElongatedCircleRecompType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeaturePointListType * BaseFeaturePointListIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeaturePointList = BaseFeaturePointListIn;
}

ElongatedCircleRecompType::~ElongatedCircleRecompType()
{
  #ifndef NODESTRUCT
  delete BaseFeaturePointList;
  #endif
}

void ElongatedCircleRecompType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeaturePointList");
  BaseFeaturePointList->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeaturePointList>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeaturePointListType * ElongatedCircleRecompType::getBaseFeaturePointList()
{return BaseFeaturePointList;}

void ElongatedCircleRecompType::setBaseFeaturePointList(BaseFeaturePointListType * BaseFeaturePointListIn)
{BaseFeaturePointList = BaseFeaturePointListIn;}

/* ***************************************************************** */

/* class ElongatedCircleTransformType

*/

ElongatedCircleTransformType::ElongatedCircleTransformType() :
  ConstructionMethodBaseType()
{
  BaseElongatedCircle = 0;
  Transformation = 0;
}

ElongatedCircleTransformType::ElongatedCircleTransformType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseElongatedCircleIn,
 TransformationReferenceType * TransformationIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseElongatedCircle = BaseElongatedCircleIn;
  Transformation = TransformationIn;
}

ElongatedCircleTransformType::~ElongatedCircleTransformType()
{
  #ifndef NODESTRUCT
  delete BaseElongatedCircle;
  delete Transformation;
  #endif
}

void ElongatedCircleTransformType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseElongatedCircle");
  BaseElongatedCircle->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseElongatedCircle>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Transformation");
  Transformation->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Transformation>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * ElongatedCircleTransformType::getBaseElongatedCircle()
{return BaseElongatedCircle;}

void ElongatedCircleTransformType::setBaseElongatedCircle(BaseFeatureType * BaseElongatedCircleIn)
{BaseElongatedCircle = BaseElongatedCircleIn;}

TransformationReferenceType * ElongatedCircleTransformType::getTransformation()
{return Transformation;}

void ElongatedCircleTransformType::setTransformation(TransformationReferenceType * TransformationIn)
{Transformation = TransformationIn;}

/* ***************************************************************** */

/* class ElongatedCylinderBestFitType

*/

ElongatedCylinderBestFitType::ElongatedCylinderBestFitType() :
  ConstructionMethodBaseType()
{
  n = 0;
  BaseFeature = 0;
}

ElongatedCylinderBestFitType::ElongatedCylinderBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = 0;
  BaseFeature = BaseFeatureIn;
}

ElongatedCylinderBestFitType::ElongatedCylinderBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 NaturalType * nIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = nIn;
  BaseFeature = BaseFeatureIn;
}

ElongatedCylinderBestFitType::~ElongatedCylinderBestFitType()
{
  #ifndef NODESTRUCT
  delete n;
  delete BaseFeature;
  #endif
}

void ElongatedCylinderBestFitType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  {
    if (!BaseFeature)
      {
        fprintf(stderr, "BaseFeature list is missing\n");
        exit(1);
      }
    if (BaseFeature->size() == 0)
      {
        fprintf(stderr, "BaseFeature list is empty\n");
        exit(1);
      }
    if (BaseFeature->size() < 9)
      {
        fprintf(stderr,
                "size of BaseFeature list (%d) less than minimum required (9)\n",
                (int)BaseFeature->size());
        exit(1);
      }
    std::list<SequencedBaseFeatureType *>::iterator iter;
    for (iter = BaseFeature->begin();
         iter != BaseFeature->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<BaseFeature");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</BaseFeature>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool ElongatedCylinderBestFitType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in ElongatedCylinderBestFitType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in ElongatedCylinderBestFitType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ElongatedCylinderBestFitType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in ElongatedCylinderBestFitType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * ElongatedCylinderBestFitType::getn()
{return n;}

void ElongatedCylinderBestFitType::setn(NaturalType * nIn)
{n = nIn;}

SequencedBaseFeatureTypeLisd * ElongatedCylinderBestFitType::getBaseFeature()
{return BaseFeature;}

void ElongatedCylinderBestFitType::setBaseFeature(SequencedBaseFeatureTypeLisd * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class ElongatedCylinderCastType

*/

ElongatedCylinderCastType::ElongatedCylinderCastType() :
  ConstructionMethodBaseType()
{
  BaseFeature = 0;
}

ElongatedCylinderCastType::ElongatedCylinderCastType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeature = BaseFeatureIn;
}

ElongatedCylinderCastType::~ElongatedCylinderCastType()
{
  #ifndef NODESTRUCT
  delete BaseFeature;
  #endif
}

void ElongatedCylinderCastType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeature");
  BaseFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * ElongatedCylinderCastType::getBaseFeature()
{return BaseFeature;}

void ElongatedCylinderCastType::setBaseFeature(BaseFeatureType * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class ElongatedCylinderCheckedFeatureType

*/

ElongatedCylinderCheckedFeatureType::ElongatedCylinderCheckedFeatureType()
{
  CheckDetails = 0;
}

ElongatedCylinderCheckedFeatureType::ElongatedCylinderCheckedFeatureType(
 ElongatedCylinderCheckedType * CheckDetailsIn)
{
  CheckDetails = CheckDetailsIn;
}

ElongatedCylinderCheckedFeatureType::~ElongatedCylinderCheckedFeatureType()
{
  #ifndef NODESTRUCT
  delete CheckDetails;
  #endif
}

void ElongatedCylinderCheckedFeatureType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (CheckDetails)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CheckDetails");
      CheckDetails->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CheckDetails>\n");
    }
  doSpaces(-INDENT, outFile);
}

ElongatedCylinderCheckedType * ElongatedCylinderCheckedFeatureType::getCheckDetails()
{return CheckDetails;}

void ElongatedCylinderCheckedFeatureType::setCheckDetails(ElongatedCylinderCheckedType * CheckDetailsIn)
{CheckDetails = CheckDetailsIn;}

/* ***************************************************************** */

/* class ElongatedCylinderCheckedType

*/

ElongatedCylinderCheckedType::ElongatedCylinderCheckedType()
{
  ElongatedCylinderCheckedTypePair = 0;
}

ElongatedCylinderCheckedType::ElongatedCylinderCheckedType(
 ElongatedCylinderCheckedTypeChoicePair * ElongatedCylinderCheckedTypePairIn)
{
  ElongatedCylinderCheckedTypePair = ElongatedCylinderCheckedTypePairIn;
}

ElongatedCylinderCheckedType::~ElongatedCylinderCheckedType()
{
  #ifndef NODESTRUCT
  delete ElongatedCylinderCheckedTypePair;
  #endif
}

void ElongatedCylinderCheckedType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  ElongatedCylinderCheckedTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

ElongatedCylinderCheckedTypeChoicePair * ElongatedCylinderCheckedType::getElongatedCylinderCheckedTypePair()
{return ElongatedCylinderCheckedTypePair;}

void ElongatedCylinderCheckedType::setElongatedCylinderCheckedTypePair(ElongatedCylinderCheckedTypeChoicePair * ElongatedCylinderCheckedTypePairIn)
{ElongatedCylinderCheckedTypePair = ElongatedCylinderCheckedTypePairIn;}
ElongatedCylinderCheckedTypeChoicePair::ElongatedCylinderCheckedTypeChoicePair() {}

ElongatedCylinderCheckedTypeChoicePair::ElongatedCylinderCheckedTypeChoicePair(
 whichOne ElongatedCylinderCheckedTypeTypeIn,
 ElongatedCylinderCheckedTypeVal * ElongatedCylinderCheckedTypeValueIn)
{
  ElongatedCylinderCheckedTypeType = ElongatedCylinderCheckedTypeTypeIn;
  ElongatedCylinderCheckedTypeValue = ElongatedCylinderCheckedTypeValueIn;
}

ElongatedCylinderCheckedTypeChoicePair::~ElongatedCylinderCheckedTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (ElongatedCylinderCheckedTypeType == MeasuredE)
    delete ElongatedCylinderCheckedTypeValue->Measured;
  else if (ElongatedCylinderCheckedTypeType == ConstructedE)
    delete ElongatedCylinderCheckedTypeValue->Constructed;
  delete ElongatedCylinderCheckedTypeValue;
  #endif
}

void ElongatedCylinderCheckedTypeChoicePair::printSelf(FILE * outFile)
{
  if (ElongatedCylinderCheckedTypeType == MeasuredE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Measured");
      ElongatedCylinderCheckedTypeValue->Measured->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Measured>\n");
    }
  else if (ElongatedCylinderCheckedTypeType == ConstructedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      ElongatedCylinderCheckedTypeValue->Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
}

/* ***************************************************************** */

/* class ElongatedCylinderConstructionMethodType

*/

ElongatedCylinderConstructionMethodType::ElongatedCylinderConstructionMethodType()
{
  ElongatedCylinderConstructionMethodTypePair = 0;
}

ElongatedCylinderConstructionMethodType::ElongatedCylinderConstructionMethodType(
 ElongatedCylinderConstructionMethodTypeChoicePair * ElongatedCylinderConstructionMethodTypePairIn)
{
  ElongatedCylinderConstructionMethodTypePair = ElongatedCylinderConstructionMethodTypePairIn;
}

ElongatedCylinderConstructionMethodType::~ElongatedCylinderConstructionMethodType()
{
  #ifndef NODESTRUCT
  delete ElongatedCylinderConstructionMethodTypePair;
  #endif
}

void ElongatedCylinderConstructionMethodType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (ElongatedCylinderConstructionMethodTypePair)
    {
      ElongatedCylinderConstructionMethodTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

ElongatedCylinderConstructionMethodTypeChoicePair * ElongatedCylinderConstructionMethodType::getElongatedCylinderConstructionMethodTypePair()
{return ElongatedCylinderConstructionMethodTypePair;}

void ElongatedCylinderConstructionMethodType::setElongatedCylinderConstructionMethodTypePair(ElongatedCylinderConstructionMethodTypeChoicePair * ElongatedCylinderConstructionMethodTypePairIn)
{ElongatedCylinderConstructionMethodTypePair = ElongatedCylinderConstructionMethodTypePairIn;}
ElongatedCylinderConstructionMethodTypeChoicePair::ElongatedCylinderConstructionMethodTypeChoicePair() {}

ElongatedCylinderConstructionMethodTypeChoicePair::ElongatedCylinderConstructionMethodTypeChoicePair(
 whichOne ElongatedCylinderConstructionMethodTypeTypeIn,
 ElongatedCylinderConstructionMethodTypeVal * ElongatedCylinderConstructionMethodTypeValueIn)
{
  ElongatedCylinderConstructionMethodTypeType = ElongatedCylinderConstructionMethodTypeTypeIn;
  ElongatedCylinderConstructionMethodTypeValue = ElongatedCylinderConstructionMethodTypeValueIn;
}

ElongatedCylinderConstructionMethodTypeChoicePair::~ElongatedCylinderConstructionMethodTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (ElongatedCylinderConstructionMethodTypeType == BestFitE)
    delete ElongatedCylinderConstructionMethodTypeValue->BestFit;
  else if (ElongatedCylinderConstructionMethodTypeType == RecompensatedE)
    delete ElongatedCylinderConstructionMethodTypeValue->Recompensated;
  else if (ElongatedCylinderConstructionMethodTypeType == CopyE)
    delete ElongatedCylinderConstructionMethodTypeValue->Copy;
  else if (ElongatedCylinderConstructionMethodTypeType == CastE)
    delete ElongatedCylinderConstructionMethodTypeValue->Cast;
  else if (ElongatedCylinderConstructionMethodTypeType == TransformE)
    delete ElongatedCylinderConstructionMethodTypeValue->Transform;
  delete ElongatedCylinderConstructionMethodTypeValue;
  #endif
}

void ElongatedCylinderConstructionMethodTypeChoicePair::printSelf(FILE * outFile)
{
  if (ElongatedCylinderConstructionMethodTypeType == BestFitE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BestFit");
      ElongatedCylinderConstructionMethodTypeValue->BestFit->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BestFit>\n");
    }
  else if (ElongatedCylinderConstructionMethodTypeType == RecompensatedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Recompensated");
      ElongatedCylinderConstructionMethodTypeValue->Recompensated->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Recompensated>\n");
    }
  else if (ElongatedCylinderConstructionMethodTypeType == CopyE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Copy");
      ElongatedCylinderConstructionMethodTypeValue->Copy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Copy>\n");
    }
  else if (ElongatedCylinderConstructionMethodTypeType == CastE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Cast");
      ElongatedCylinderConstructionMethodTypeValue->Cast->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Cast>\n");
    }
  else if (ElongatedCylinderConstructionMethodTypeType == TransformE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Transform");
      ElongatedCylinderConstructionMethodTypeValue->Transform->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Transform>\n");
    }
}

/* ***************************************************************** */

/* class ElongatedCylinderCopyType

*/

ElongatedCylinderCopyType::ElongatedCylinderCopyType() :
  ConstructionMethodBaseType()
{
  BaseElongatedCylinder = 0;
}

ElongatedCylinderCopyType::ElongatedCylinderCopyType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseElongatedCylinderIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseElongatedCylinder = BaseElongatedCylinderIn;
}

ElongatedCylinderCopyType::~ElongatedCylinderCopyType()
{
  #ifndef NODESTRUCT
  delete BaseElongatedCylinder;
  #endif
}

void ElongatedCylinderCopyType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseElongatedCylinder");
  BaseElongatedCylinder->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseElongatedCylinder>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * ElongatedCylinderCopyType::getBaseElongatedCylinder()
{return BaseElongatedCylinder;}

void ElongatedCylinderCopyType::setBaseElongatedCylinder(BaseFeatureType * BaseElongatedCylinderIn)
{BaseElongatedCylinder = BaseElongatedCylinderIn;}

/* ***************************************************************** */

/* class ElongatedCylinderFeatureDefinitionType

*/

ElongatedCylinderFeatureDefinitionType::ElongatedCylinderFeatureDefinitionType() :
  SurfaceFeatureDefinitionBaseType()
{
  InternalExternal = 0;
  Diameter = 0;
  Length = 0;
  Depth = 0;
}

ElongatedCylinderFeatureDefinitionType::ElongatedCylinderFeatureDefinitionType(
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * DiameterIn,
 LinearValueType * LengthIn,
 LinearValueType * DepthIn) :
  SurfaceFeatureDefinitionBaseType(
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  Diameter = DiameterIn;
  Length = LengthIn;
  Depth = DepthIn;
}

ElongatedCylinderFeatureDefinitionType::ElongatedCylinderFeatureDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * DiameterIn,
 LinearValueType * LengthIn,
 LinearValueType * DepthIn) :
  SurfaceFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  Diameter = DiameterIn;
  Length = LengthIn;
  Depth = DepthIn;
}

ElongatedCylinderFeatureDefinitionType::~ElongatedCylinderFeatureDefinitionType()
{
  #ifndef NODESTRUCT
  delete InternalExternal;
  delete Diameter;
  delete Length;
  delete Depth;
  #endif
}

void ElongatedCylinderFeatureDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<InternalExternal");
  InternalExternal->printSelf(outFile);
  fprintf(outFile, "</InternalExternal>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Diameter");
  Diameter->printSelf(outFile);
  fprintf(outFile, "</Diameter>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Length");
  Length->printSelf(outFile);
  fprintf(outFile, "</Length>\n");
  if (Depth)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Depth");
      Depth->printSelf(outFile);
      fprintf(outFile, "</Depth>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ElongatedCylinderFeatureDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ElongatedCylinderFeatureDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ElongatedCylinderFeatureDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ElongatedCylinderFeatureDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ElongatedCylinderFeatureDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

InternalExternalEnumType * ElongatedCylinderFeatureDefinitionType::getInternalExternal()
{return InternalExternal;}

void ElongatedCylinderFeatureDefinitionType::setInternalExternal(InternalExternalEnumType * InternalExternalIn)
{InternalExternal = InternalExternalIn;}

LinearValueType * ElongatedCylinderFeatureDefinitionType::getDiameter()
{return Diameter;}

void ElongatedCylinderFeatureDefinitionType::setDiameter(LinearValueType * DiameterIn)
{Diameter = DiameterIn;}

LinearValueType * ElongatedCylinderFeatureDefinitionType::getLength()
{return Length;}

void ElongatedCylinderFeatureDefinitionType::setLength(LinearValueType * LengthIn)
{Length = LengthIn;}

LinearValueType * ElongatedCylinderFeatureDefinitionType::getDepth()
{return Depth;}

void ElongatedCylinderFeatureDefinitionType::setDepth(LinearValueType * DepthIn)
{Depth = DepthIn;}

/* ***************************************************************** */

/* class ElongatedCylinderFeatureItemType

*/

ElongatedCylinderFeatureItemType::ElongatedCylinderFeatureItemType() :
  SurfaceFeatureItemBaseType()
{
  DeterminationMode = 0;
}

ElongatedCylinderFeatureItemType::ElongatedCylinderFeatureItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 ElongatedCylinderMeasurementDeterminationType * DeterminationModeIn) :
  SurfaceFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

ElongatedCylinderFeatureItemType::ElongatedCylinderFeatureItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 ElongatedCylinderMeasurementDeterminationType * DeterminationModeIn) :
  SurfaceFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

ElongatedCylinderFeatureItemType::~ElongatedCylinderFeatureItemType()
{
  #ifndef NODESTRUCT
  delete DeterminationMode;
  #endif
}

void ElongatedCylinderFeatureItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<DeterminationMode");
  DeterminationMode->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeterminationMode>\n");
  doSpaces(-INDENT, outFile);
}

bool ElongatedCylinderFeatureItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ElongatedCylinderFeatureItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ElongatedCylinderFeatureItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ElongatedCylinderFeatureItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ElongatedCylinderFeatureItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

ElongatedCylinderMeasurementDeterminationType * ElongatedCylinderFeatureItemType::getDeterminationMode()
{return DeterminationMode;}

void ElongatedCylinderFeatureItemType::setDeterminationMode(ElongatedCylinderMeasurementDeterminationType * DeterminationModeIn)
{DeterminationMode = DeterminationModeIn;}

/* ***************************************************************** */

/* class ElongatedCylinderFeatureMeasurementType

*/

ElongatedCylinderFeatureMeasurementType::ElongatedCylinderFeatureMeasurementType() :
  SurfaceFeatureMeasurementBaseType()
{
  Diameter = 0;
  DiameterMin = 0;
  DiameterMax = 0;
  CenterPlane = 0;
  Length = 0;
  LengthMax = 0;
  LengthMin = 0;
  Depth = 0;
  DepthMax = 0;
  DepthMin = 0;
  DepthVector = 0;
  Form = 0;
}

ElongatedCylinderFeatureMeasurementType::ElongatedCylinderFeatureMeasurementType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredLinearValueType * DiameterIn,
 MeasuredLinearValueType * DiameterMinIn,
 MeasuredLinearValueType * DiameterMaxIn,
 MeasuredPlaneType * CenterPlaneIn,
 MeasuredLinearValueType * LengthIn,
 MeasuredLinearValueType * LengthMaxIn,
 MeasuredLinearValueType * LengthMinIn,
 MeasuredLinearValueType * DepthIn,
 MeasuredLinearValueType * DepthMaxIn,
 MeasuredLinearValueType * DepthMinIn,
 MeasuredUnitVectorType * DepthVectorIn,
 MeasuredLinearValueType * FormIn) :
  SurfaceFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Diameter = DiameterIn;
  DiameterMin = DiameterMinIn;
  DiameterMax = DiameterMaxIn;
  CenterPlane = CenterPlaneIn;
  Length = LengthIn;
  LengthMax = LengthMaxIn;
  LengthMin = LengthMinIn;
  Depth = DepthIn;
  DepthMax = DepthMaxIn;
  DepthMin = DepthMinIn;
  DepthVector = DepthVectorIn;
  Form = FormIn;
}

ElongatedCylinderFeatureMeasurementType::ElongatedCylinderFeatureMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredLinearValueType * DiameterIn,
 MeasuredLinearValueType * DiameterMinIn,
 MeasuredLinearValueType * DiameterMaxIn,
 MeasuredPlaneType * CenterPlaneIn,
 MeasuredLinearValueType * LengthIn,
 MeasuredLinearValueType * LengthMaxIn,
 MeasuredLinearValueType * LengthMinIn,
 MeasuredLinearValueType * DepthIn,
 MeasuredLinearValueType * DepthMaxIn,
 MeasuredLinearValueType * DepthMinIn,
 MeasuredUnitVectorType * DepthVectorIn,
 MeasuredLinearValueType * FormIn) :
  SurfaceFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Diameter = DiameterIn;
  DiameterMin = DiameterMinIn;
  DiameterMax = DiameterMaxIn;
  CenterPlane = CenterPlaneIn;
  Length = LengthIn;
  LengthMax = LengthMaxIn;
  LengthMin = LengthMinIn;
  Depth = DepthIn;
  DepthMax = DepthMaxIn;
  DepthMin = DepthMinIn;
  DepthVector = DepthVectorIn;
  Form = FormIn;
}

ElongatedCylinderFeatureMeasurementType::~ElongatedCylinderFeatureMeasurementType()
{
  #ifndef NODESTRUCT
  delete Diameter;
  delete DiameterMin;
  delete DiameterMax;
  delete CenterPlane;
  delete Length;
  delete LengthMax;
  delete LengthMin;
  delete Depth;
  delete DepthMax;
  delete DepthMin;
  delete DepthVector;
  delete Form;
  #endif
}

void ElongatedCylinderFeatureMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  if (Diameter)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Diameter");
      Diameter->printSelf(outFile);
      fprintf(outFile, "</Diameter>\n");
    }
  if (DiameterMin)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DiameterMin");
      DiameterMin->printSelf(outFile);
      fprintf(outFile, "</DiameterMin>\n");
    }
  if (DiameterMax)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DiameterMax");
      DiameterMax->printSelf(outFile);
      fprintf(outFile, "</DiameterMax>\n");
    }
  if (CenterPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CenterPlane");
      CenterPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CenterPlane>\n");
    }
  if (Length)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Length");
      Length->printSelf(outFile);
      fprintf(outFile, "</Length>\n");
    }
  if (LengthMax)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LengthMax");
      LengthMax->printSelf(outFile);
      fprintf(outFile, "</LengthMax>\n");
    }
  if (LengthMin)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LengthMin");
      LengthMin->printSelf(outFile);
      fprintf(outFile, "</LengthMin>\n");
    }
  if (Depth)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Depth");
      Depth->printSelf(outFile);
      fprintf(outFile, "</Depth>\n");
    }
  if (DepthMax)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DepthMax");
      DepthMax->printSelf(outFile);
      fprintf(outFile, "</DepthMax>\n");
    }
  if (DepthMin)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DepthMin");
      DepthMin->printSelf(outFile);
      fprintf(outFile, "</DepthMin>\n");
    }
  if (DepthVector)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DepthVector");
      DepthVector->printSelf(outFile);
      fprintf(outFile, "</DepthVector>\n");
    }
  if (Form)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Form");
      Form->printSelf(outFile);
      fprintf(outFile, "</Form>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ElongatedCylinderFeatureMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ElongatedCylinderFeatureMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ElongatedCylinderFeatureMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ElongatedCylinderFeatureMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ElongatedCylinderFeatureMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredLinearValueType * ElongatedCylinderFeatureMeasurementType::getDiameter()
{return Diameter;}

void ElongatedCylinderFeatureMeasurementType::setDiameter(MeasuredLinearValueType * DiameterIn)
{Diameter = DiameterIn;}

MeasuredLinearValueType * ElongatedCylinderFeatureMeasurementType::getDiameterMin()
{return DiameterMin;}

void ElongatedCylinderFeatureMeasurementType::setDiameterMin(MeasuredLinearValueType * DiameterMinIn)
{DiameterMin = DiameterMinIn;}

MeasuredLinearValueType * ElongatedCylinderFeatureMeasurementType::getDiameterMax()
{return DiameterMax;}

void ElongatedCylinderFeatureMeasurementType::setDiameterMax(MeasuredLinearValueType * DiameterMaxIn)
{DiameterMax = DiameterMaxIn;}

MeasuredPlaneType * ElongatedCylinderFeatureMeasurementType::getCenterPlane()
{return CenterPlane;}

void ElongatedCylinderFeatureMeasurementType::setCenterPlane(MeasuredPlaneType * CenterPlaneIn)
{CenterPlane = CenterPlaneIn;}

MeasuredLinearValueType * ElongatedCylinderFeatureMeasurementType::getLength()
{return Length;}

void ElongatedCylinderFeatureMeasurementType::setLength(MeasuredLinearValueType * LengthIn)
{Length = LengthIn;}

MeasuredLinearValueType * ElongatedCylinderFeatureMeasurementType::getLengthMax()
{return LengthMax;}

void ElongatedCylinderFeatureMeasurementType::setLengthMax(MeasuredLinearValueType * LengthMaxIn)
{LengthMax = LengthMaxIn;}

MeasuredLinearValueType * ElongatedCylinderFeatureMeasurementType::getLengthMin()
{return LengthMin;}

void ElongatedCylinderFeatureMeasurementType::setLengthMin(MeasuredLinearValueType * LengthMinIn)
{LengthMin = LengthMinIn;}

MeasuredLinearValueType * ElongatedCylinderFeatureMeasurementType::getDepth()
{return Depth;}

void ElongatedCylinderFeatureMeasurementType::setDepth(MeasuredLinearValueType * DepthIn)
{Depth = DepthIn;}

MeasuredLinearValueType * ElongatedCylinderFeatureMeasurementType::getDepthMax()
{return DepthMax;}

void ElongatedCylinderFeatureMeasurementType::setDepthMax(MeasuredLinearValueType * DepthMaxIn)
{DepthMax = DepthMaxIn;}

MeasuredLinearValueType * ElongatedCylinderFeatureMeasurementType::getDepthMin()
{return DepthMin;}

void ElongatedCylinderFeatureMeasurementType::setDepthMin(MeasuredLinearValueType * DepthMinIn)
{DepthMin = DepthMinIn;}

MeasuredUnitVectorType * ElongatedCylinderFeatureMeasurementType::getDepthVector()
{return DepthVector;}

void ElongatedCylinderFeatureMeasurementType::setDepthVector(MeasuredUnitVectorType * DepthVectorIn)
{DepthVector = DepthVectorIn;}

MeasuredLinearValueType * ElongatedCylinderFeatureMeasurementType::getForm()
{return Form;}

void ElongatedCylinderFeatureMeasurementType::setForm(MeasuredLinearValueType * FormIn)
{Form = FormIn;}

/* ***************************************************************** */

/* class ElongatedCylinderFeatureNominalType

*/

ElongatedCylinderFeatureNominalType::ElongatedCylinderFeatureNominalType() :
  SurfaceFeatureNominalBaseType()
{
  CenterPlane = 0;
  DepthVector = 0;
  Constructed = 0;
}

ElongatedCylinderFeatureNominalType::ElongatedCylinderFeatureNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 PlaneType * CenterPlaneIn,
 UnitVectorType * DepthVectorIn,
 ElongatedCylinderConstructionMethodType * ConstructedIn) :
  SurfaceFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  CenterPlane = CenterPlaneIn;
  DepthVector = DepthVectorIn;
  Constructed = ConstructedIn;
}

ElongatedCylinderFeatureNominalType::ElongatedCylinderFeatureNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 PlaneType * CenterPlaneIn,
 UnitVectorType * DepthVectorIn,
 ElongatedCylinderConstructionMethodType * ConstructedIn) :
  SurfaceFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  CenterPlane = CenterPlaneIn;
  DepthVector = DepthVectorIn;
  Constructed = ConstructedIn;
}

ElongatedCylinderFeatureNominalType::~ElongatedCylinderFeatureNominalType()
{
  #ifndef NODESTRUCT
  delete CenterPlane;
  delete DepthVector;
  delete Constructed;
  #endif
}

void ElongatedCylinderFeatureNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CenterPlane");
  CenterPlane->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</CenterPlane>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<DepthVector");
  DepthVector->printSelf(outFile);
  fprintf(outFile, "</DepthVector>\n");
  if (Constructed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ElongatedCylinderFeatureNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ElongatedCylinderFeatureNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ElongatedCylinderFeatureNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ElongatedCylinderFeatureNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ElongatedCylinderFeatureNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

PlaneType * ElongatedCylinderFeatureNominalType::getCenterPlane()
{return CenterPlane;}

void ElongatedCylinderFeatureNominalType::setCenterPlane(PlaneType * CenterPlaneIn)
{CenterPlane = CenterPlaneIn;}

UnitVectorType * ElongatedCylinderFeatureNominalType::getDepthVector()
{return DepthVector;}

void ElongatedCylinderFeatureNominalType::setDepthVector(UnitVectorType * DepthVectorIn)
{DepthVector = DepthVectorIn;}

ElongatedCylinderConstructionMethodType * ElongatedCylinderFeatureNominalType::getConstructed()
{return Constructed;}

void ElongatedCylinderFeatureNominalType::setConstructed(ElongatedCylinderConstructionMethodType * ConstructedIn)
{Constructed = ConstructedIn;}

/* ***************************************************************** */

/* class ElongatedCylinderMeasurementDeterminationType

*/

ElongatedCylinderMeasurementDeterminationType::ElongatedCylinderMeasurementDeterminationType()
{
  ElongatedCylinderMeasurementDeterminationTypePair = 0;
}

ElongatedCylinderMeasurementDeterminationType::ElongatedCylinderMeasurementDeterminationType(
 ElongatedCylinderMeasurementDeterminationTypeChoicePair * ElongatedCylinderMeasurementDeterminationTypePairIn)
{
  ElongatedCylinderMeasurementDeterminationTypePair = ElongatedCylinderMeasurementDeterminationTypePairIn;
}

ElongatedCylinderMeasurementDeterminationType::~ElongatedCylinderMeasurementDeterminationType()
{
  #ifndef NODESTRUCT
  delete ElongatedCylinderMeasurementDeterminationTypePair;
  #endif
}

void ElongatedCylinderMeasurementDeterminationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  ElongatedCylinderMeasurementDeterminationTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

ElongatedCylinderMeasurementDeterminationTypeChoicePair * ElongatedCylinderMeasurementDeterminationType::getElongatedCylinderMeasurementDeterminationTypePair()
{return ElongatedCylinderMeasurementDeterminationTypePair;}

void ElongatedCylinderMeasurementDeterminationType::setElongatedCylinderMeasurementDeterminationTypePair(ElongatedCylinderMeasurementDeterminationTypeChoicePair * ElongatedCylinderMeasurementDeterminationTypePairIn)
{ElongatedCylinderMeasurementDeterminationTypePair = ElongatedCylinderMeasurementDeterminationTypePairIn;}
ElongatedCylinderMeasurementDeterminationTypeChoicePair::ElongatedCylinderMeasurementDeterminationTypeChoicePair() {}

ElongatedCylinderMeasurementDeterminationTypeChoicePair::ElongatedCylinderMeasurementDeterminationTypeChoicePair(
 whichOne ElongatedCylinderMeasurementDeterminationTypeTypeIn,
 ElongatedCylinderMeasurementDeterminationTypeVal * ElongatedCylinderMeasurementDeterminationTypeValueIn)
{
  ElongatedCylinderMeasurementDeterminationTypeType = ElongatedCylinderMeasurementDeterminationTypeTypeIn;
  ElongatedCylinderMeasurementDeterminationTypeValue = ElongatedCylinderMeasurementDeterminationTypeValueIn;
}

ElongatedCylinderMeasurementDeterminationTypeChoicePair::~ElongatedCylinderMeasurementDeterminationTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (ElongatedCylinderMeasurementDeterminationTypeType == CheckedE)
    delete ElongatedCylinderMeasurementDeterminationTypeValue->Checked;
  else if (ElongatedCylinderMeasurementDeterminationTypeType == SetE)
    delete ElongatedCylinderMeasurementDeterminationTypeValue->Set;
  delete ElongatedCylinderMeasurementDeterminationTypeValue;
  #endif
}

void ElongatedCylinderMeasurementDeterminationTypeChoicePair::printSelf(FILE * outFile)
{
  if (ElongatedCylinderMeasurementDeterminationTypeType == CheckedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Checked");
      ElongatedCylinderMeasurementDeterminationTypeValue->Checked->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Checked>\n");
    }
  else if (ElongatedCylinderMeasurementDeterminationTypeType == SetE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Set");
      ElongatedCylinderMeasurementDeterminationTypeValue->Set->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class ElongatedCylinderRecompType

*/

ElongatedCylinderRecompType::ElongatedCylinderRecompType() :
  ConstructionMethodBaseType()
{
  BaseFeaturePointList = 0;
}

ElongatedCylinderRecompType::ElongatedCylinderRecompType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeaturePointListType * BaseFeaturePointListIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeaturePointList = BaseFeaturePointListIn;
}

ElongatedCylinderRecompType::~ElongatedCylinderRecompType()
{
  #ifndef NODESTRUCT
  delete BaseFeaturePointList;
  #endif
}

void ElongatedCylinderRecompType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeaturePointList");
  BaseFeaturePointList->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeaturePointList>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeaturePointListType * ElongatedCylinderRecompType::getBaseFeaturePointList()
{return BaseFeaturePointList;}

void ElongatedCylinderRecompType::setBaseFeaturePointList(BaseFeaturePointListType * BaseFeaturePointListIn)
{BaseFeaturePointList = BaseFeaturePointListIn;}

/* ***************************************************************** */

/* class ElongatedCylinderTransformType

*/

ElongatedCylinderTransformType::ElongatedCylinderTransformType() :
  ConstructionMethodBaseType()
{
  BaseElongatedCylinder = 0;
  Transformation = 0;
}

ElongatedCylinderTransformType::ElongatedCylinderTransformType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseElongatedCylinderIn,
 TransformationReferenceType * TransformationIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseElongatedCylinder = BaseElongatedCylinderIn;
  Transformation = TransformationIn;
}

ElongatedCylinderTransformType::~ElongatedCylinderTransformType()
{
  #ifndef NODESTRUCT
  delete BaseElongatedCylinder;
  delete Transformation;
  #endif
}

void ElongatedCylinderTransformType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseElongatedCylinder");
  BaseElongatedCylinder->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseElongatedCylinder>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Transformation");
  Transformation->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Transformation>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * ElongatedCylinderTransformType::getBaseElongatedCylinder()
{return BaseElongatedCylinder;}

void ElongatedCylinderTransformType::setBaseElongatedCylinder(BaseFeatureType * BaseElongatedCylinderIn)
{BaseElongatedCylinder = BaseElongatedCylinderIn;}

TransformationReferenceType * ElongatedCylinderTransformType::getTransformation()
{return Transformation;}

void ElongatedCylinderTransformType::setTransformation(TransformationReferenceType * TransformationIn)
{Transformation = TransformationIn;}

/* ***************************************************************** */

/* class ExtrudedCrossSectionBestFitType

*/

ExtrudedCrossSectionBestFitType::ExtrudedCrossSectionBestFitType() :
  ConstructionMethodBaseType()
{
  n = 0;
  BaseFeature = 0;
}

ExtrudedCrossSectionBestFitType::ExtrudedCrossSectionBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = 0;
  BaseFeature = BaseFeatureIn;
}

ExtrudedCrossSectionBestFitType::ExtrudedCrossSectionBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 NaturalType * nIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = nIn;
  BaseFeature = BaseFeatureIn;
}

ExtrudedCrossSectionBestFitType::~ExtrudedCrossSectionBestFitType()
{
  #ifndef NODESTRUCT
  delete n;
  delete BaseFeature;
  #endif
}

void ExtrudedCrossSectionBestFitType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  {
    if (!BaseFeature)
      {
        fprintf(stderr, "BaseFeature list is missing\n");
        exit(1);
      }
    if (BaseFeature->size() == 0)
      {
        fprintf(stderr, "BaseFeature list is empty\n");
        exit(1);
      }
    if (BaseFeature->size() < 6)
      {
        fprintf(stderr,
                "size of BaseFeature list (%d) less than minimum required (6)\n",
                (int)BaseFeature->size());
        exit(1);
      }
    std::list<SequencedBaseFeatureType *>::iterator iter;
    for (iter = BaseFeature->begin();
         iter != BaseFeature->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<BaseFeature");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</BaseFeature>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool ExtrudedCrossSectionBestFitType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in ExtrudedCrossSectionBestFitType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in ExtrudedCrossSectionBestFitType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ExtrudedCrossSectionBestFitType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in ExtrudedCrossSectionBestFitType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * ExtrudedCrossSectionBestFitType::getn()
{return n;}

void ExtrudedCrossSectionBestFitType::setn(NaturalType * nIn)
{n = nIn;}

SequencedBaseFeatureTypeLisd * ExtrudedCrossSectionBestFitType::getBaseFeature()
{return BaseFeature;}

void ExtrudedCrossSectionBestFitType::setBaseFeature(SequencedBaseFeatureTypeLisd * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class ExtrudedCrossSectionCastType

*/

ExtrudedCrossSectionCastType::ExtrudedCrossSectionCastType() :
  ConstructionMethodBaseType()
{
  BaseFeature = 0;
}

ExtrudedCrossSectionCastType::ExtrudedCrossSectionCastType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeature = BaseFeatureIn;
}

ExtrudedCrossSectionCastType::~ExtrudedCrossSectionCastType()
{
  #ifndef NODESTRUCT
  delete BaseFeature;
  #endif
}

void ExtrudedCrossSectionCastType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeature");
  BaseFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * ExtrudedCrossSectionCastType::getBaseFeature()
{return BaseFeature;}

void ExtrudedCrossSectionCastType::setBaseFeature(BaseFeatureType * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class ExtrudedCrossSectionCheckedFeatureType

*/

ExtrudedCrossSectionCheckedFeatureType::ExtrudedCrossSectionCheckedFeatureType()
{
  CheckDetails = 0;
}

ExtrudedCrossSectionCheckedFeatureType::ExtrudedCrossSectionCheckedFeatureType(
 ExtrudedCrossSectionCheckedType * CheckDetailsIn)
{
  CheckDetails = CheckDetailsIn;
}

ExtrudedCrossSectionCheckedFeatureType::~ExtrudedCrossSectionCheckedFeatureType()
{
  #ifndef NODESTRUCT
  delete CheckDetails;
  #endif
}

void ExtrudedCrossSectionCheckedFeatureType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (CheckDetails)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CheckDetails");
      CheckDetails->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CheckDetails>\n");
    }
  doSpaces(-INDENT, outFile);
}

ExtrudedCrossSectionCheckedType * ExtrudedCrossSectionCheckedFeatureType::getCheckDetails()
{return CheckDetails;}

void ExtrudedCrossSectionCheckedFeatureType::setCheckDetails(ExtrudedCrossSectionCheckedType * CheckDetailsIn)
{CheckDetails = CheckDetailsIn;}

/* ***************************************************************** */

/* class ExtrudedCrossSectionCheckedType

*/

ExtrudedCrossSectionCheckedType::ExtrudedCrossSectionCheckedType()
{
  ExtrudedCrossSectionCheckedTypePair = 0;
}

ExtrudedCrossSectionCheckedType::ExtrudedCrossSectionCheckedType(
 ExtrudedCrossSectionCheckedTypeChoicePair * ExtrudedCrossSectionCheckedTypePairIn)
{
  ExtrudedCrossSectionCheckedTypePair = ExtrudedCrossSectionCheckedTypePairIn;
}

ExtrudedCrossSectionCheckedType::~ExtrudedCrossSectionCheckedType()
{
  #ifndef NODESTRUCT
  delete ExtrudedCrossSectionCheckedTypePair;
  #endif
}

void ExtrudedCrossSectionCheckedType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  ExtrudedCrossSectionCheckedTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

ExtrudedCrossSectionCheckedTypeChoicePair * ExtrudedCrossSectionCheckedType::getExtrudedCrossSectionCheckedTypePair()
{return ExtrudedCrossSectionCheckedTypePair;}

void ExtrudedCrossSectionCheckedType::setExtrudedCrossSectionCheckedTypePair(ExtrudedCrossSectionCheckedTypeChoicePair * ExtrudedCrossSectionCheckedTypePairIn)
{ExtrudedCrossSectionCheckedTypePair = ExtrudedCrossSectionCheckedTypePairIn;}
ExtrudedCrossSectionCheckedTypeChoicePair::ExtrudedCrossSectionCheckedTypeChoicePair() {}

ExtrudedCrossSectionCheckedTypeChoicePair::ExtrudedCrossSectionCheckedTypeChoicePair(
 whichOne ExtrudedCrossSectionCheckedTypeTypeIn,
 ExtrudedCrossSectionCheckedTypeVal * ExtrudedCrossSectionCheckedTypeValueIn)
{
  ExtrudedCrossSectionCheckedTypeType = ExtrudedCrossSectionCheckedTypeTypeIn;
  ExtrudedCrossSectionCheckedTypeValue = ExtrudedCrossSectionCheckedTypeValueIn;
}

ExtrudedCrossSectionCheckedTypeChoicePair::~ExtrudedCrossSectionCheckedTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (ExtrudedCrossSectionCheckedTypeType == MeasuredE)
    delete ExtrudedCrossSectionCheckedTypeValue->Measured;
  else if (ExtrudedCrossSectionCheckedTypeType == ConstructedE)
    delete ExtrudedCrossSectionCheckedTypeValue->Constructed;
  delete ExtrudedCrossSectionCheckedTypeValue;
  #endif
}

void ExtrudedCrossSectionCheckedTypeChoicePair::printSelf(FILE * outFile)
{
  if (ExtrudedCrossSectionCheckedTypeType == MeasuredE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Measured");
      ExtrudedCrossSectionCheckedTypeValue->Measured->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Measured>\n");
    }
  else if (ExtrudedCrossSectionCheckedTypeType == ConstructedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      ExtrudedCrossSectionCheckedTypeValue->Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
}

/* ***************************************************************** */

/* class ExtrudedCrossSectionConstructionMethodType

*/

ExtrudedCrossSectionConstructionMethodType::ExtrudedCrossSectionConstructionMethodType()
{
  ExtrudedCrossSectionConstructionMethodTypePair = 0;
}

ExtrudedCrossSectionConstructionMethodType::ExtrudedCrossSectionConstructionMethodType(
 ExtrudedCrossSectionConstructionMethodTypeChoicePair * ExtrudedCrossSectionConstructionMethodTypePairIn)
{
  ExtrudedCrossSectionConstructionMethodTypePair = ExtrudedCrossSectionConstructionMethodTypePairIn;
}

ExtrudedCrossSectionConstructionMethodType::~ExtrudedCrossSectionConstructionMethodType()
{
  #ifndef NODESTRUCT
  delete ExtrudedCrossSectionConstructionMethodTypePair;
  #endif
}

void ExtrudedCrossSectionConstructionMethodType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (ExtrudedCrossSectionConstructionMethodTypePair)
    {
      ExtrudedCrossSectionConstructionMethodTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

ExtrudedCrossSectionConstructionMethodTypeChoicePair * ExtrudedCrossSectionConstructionMethodType::getExtrudedCrossSectionConstructionMethodTypePair()
{return ExtrudedCrossSectionConstructionMethodTypePair;}

void ExtrudedCrossSectionConstructionMethodType::setExtrudedCrossSectionConstructionMethodTypePair(ExtrudedCrossSectionConstructionMethodTypeChoicePair * ExtrudedCrossSectionConstructionMethodTypePairIn)
{ExtrudedCrossSectionConstructionMethodTypePair = ExtrudedCrossSectionConstructionMethodTypePairIn;}
ExtrudedCrossSectionConstructionMethodTypeChoicePair::ExtrudedCrossSectionConstructionMethodTypeChoicePair() {}

ExtrudedCrossSectionConstructionMethodTypeChoicePair::ExtrudedCrossSectionConstructionMethodTypeChoicePair(
 whichOne ExtrudedCrossSectionConstructionMethodTypeTypeIn,
 ExtrudedCrossSectionConstructionMethodTypeVal * ExtrudedCrossSectionConstructionMethodTypeValueIn)
{
  ExtrudedCrossSectionConstructionMethodTypeType = ExtrudedCrossSectionConstructionMethodTypeTypeIn;
  ExtrudedCrossSectionConstructionMethodTypeValue = ExtrudedCrossSectionConstructionMethodTypeValueIn;
}

ExtrudedCrossSectionConstructionMethodTypeChoicePair::~ExtrudedCrossSectionConstructionMethodTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (ExtrudedCrossSectionConstructionMethodTypeType == BestFitE)
    delete ExtrudedCrossSectionConstructionMethodTypeValue->BestFit;
  else if (ExtrudedCrossSectionConstructionMethodTypeType == RecompensatedE)
    delete ExtrudedCrossSectionConstructionMethodTypeValue->Recompensated;
  else if (ExtrudedCrossSectionConstructionMethodTypeType == CopyE)
    delete ExtrudedCrossSectionConstructionMethodTypeValue->Copy;
  else if (ExtrudedCrossSectionConstructionMethodTypeType == CastE)
    delete ExtrudedCrossSectionConstructionMethodTypeValue->Cast;
  else if (ExtrudedCrossSectionConstructionMethodTypeType == TransformE)
    delete ExtrudedCrossSectionConstructionMethodTypeValue->Transform;
  delete ExtrudedCrossSectionConstructionMethodTypeValue;
  #endif
}

void ExtrudedCrossSectionConstructionMethodTypeChoicePair::printSelf(FILE * outFile)
{
  if (ExtrudedCrossSectionConstructionMethodTypeType == BestFitE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BestFit");
      ExtrudedCrossSectionConstructionMethodTypeValue->BestFit->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BestFit>\n");
    }
  else if (ExtrudedCrossSectionConstructionMethodTypeType == RecompensatedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Recompensated");
      ExtrudedCrossSectionConstructionMethodTypeValue->Recompensated->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Recompensated>\n");
    }
  else if (ExtrudedCrossSectionConstructionMethodTypeType == CopyE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Copy");
      ExtrudedCrossSectionConstructionMethodTypeValue->Copy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Copy>\n");
    }
  else if (ExtrudedCrossSectionConstructionMethodTypeType == CastE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Cast");
      ExtrudedCrossSectionConstructionMethodTypeValue->Cast->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Cast>\n");
    }
  else if (ExtrudedCrossSectionConstructionMethodTypeType == TransformE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Transform");
      ExtrudedCrossSectionConstructionMethodTypeValue->Transform->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Transform>\n");
    }
}

/* ***************************************************************** */

/* class ExtrudedCrossSectionCopyType

*/

ExtrudedCrossSectionCopyType::ExtrudedCrossSectionCopyType() :
  ConstructionMethodBaseType()
{
  BaseExtrudedCrossSection = 0;
}

ExtrudedCrossSectionCopyType::ExtrudedCrossSectionCopyType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseExtrudedCrossSectionIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseExtrudedCrossSection = BaseExtrudedCrossSectionIn;
}

ExtrudedCrossSectionCopyType::~ExtrudedCrossSectionCopyType()
{
  #ifndef NODESTRUCT
  delete BaseExtrudedCrossSection;
  #endif
}

void ExtrudedCrossSectionCopyType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseExtrudedCrossSection");
  BaseExtrudedCrossSection->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseExtrudedCrossSection>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * ExtrudedCrossSectionCopyType::getBaseExtrudedCrossSection()
{return BaseExtrudedCrossSection;}

void ExtrudedCrossSectionCopyType::setBaseExtrudedCrossSection(BaseFeatureType * BaseExtrudedCrossSectionIn)
{BaseExtrudedCrossSection = BaseExtrudedCrossSectionIn;}

/* ***************************************************************** */

/* class ExtrudedCrossSectionFeatureDefinitionType

*/

ExtrudedCrossSectionFeatureDefinitionType::ExtrudedCrossSectionFeatureDefinitionType() :
  SurfaceFeatureDefinitionBaseType()
{
  InternalExternal = 0;
  Length = 0;
}

ExtrudedCrossSectionFeatureDefinitionType::ExtrudedCrossSectionFeatureDefinitionType(
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * LengthIn) :
  SurfaceFeatureDefinitionBaseType(
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  Length = LengthIn;
}

ExtrudedCrossSectionFeatureDefinitionType::ExtrudedCrossSectionFeatureDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * LengthIn) :
  SurfaceFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  Length = LengthIn;
}

ExtrudedCrossSectionFeatureDefinitionType::~ExtrudedCrossSectionFeatureDefinitionType()
{
  #ifndef NODESTRUCT
  delete InternalExternal;
  delete Length;
  #endif
}

void ExtrudedCrossSectionFeatureDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<InternalExternal");
  InternalExternal->printSelf(outFile);
  fprintf(outFile, "</InternalExternal>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Length");
  Length->printSelf(outFile);
  fprintf(outFile, "</Length>\n");
  doSpaces(-INDENT, outFile);
}

bool ExtrudedCrossSectionFeatureDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ExtrudedCrossSectionFeatureDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ExtrudedCrossSectionFeatureDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ExtrudedCrossSectionFeatureDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ExtrudedCrossSectionFeatureDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

InternalExternalEnumType * ExtrudedCrossSectionFeatureDefinitionType::getInternalExternal()
{return InternalExternal;}

void ExtrudedCrossSectionFeatureDefinitionType::setInternalExternal(InternalExternalEnumType * InternalExternalIn)
{InternalExternal = InternalExternalIn;}

LinearValueType * ExtrudedCrossSectionFeatureDefinitionType::getLength()
{return Length;}

void ExtrudedCrossSectionFeatureDefinitionType::setLength(LinearValueType * LengthIn)
{Length = LengthIn;}

/* ***************************************************************** */

/* class ExtrudedCrossSectionFeatureItemType

*/

ExtrudedCrossSectionFeatureItemType::ExtrudedCrossSectionFeatureItemType() :
  SurfaceFeatureItemBaseType()
{
  DeterminationMode = 0;
}

ExtrudedCrossSectionFeatureItemType::ExtrudedCrossSectionFeatureItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 ExtrudedCrossSectionMeasurementDeterminationType * DeterminationModeIn) :
  SurfaceFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

ExtrudedCrossSectionFeatureItemType::ExtrudedCrossSectionFeatureItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 ExtrudedCrossSectionMeasurementDeterminationType * DeterminationModeIn) :
  SurfaceFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

ExtrudedCrossSectionFeatureItemType::~ExtrudedCrossSectionFeatureItemType()
{
  #ifndef NODESTRUCT
  delete DeterminationMode;
  #endif
}

void ExtrudedCrossSectionFeatureItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<DeterminationMode");
  DeterminationMode->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeterminationMode>\n");
  doSpaces(-INDENT, outFile);
}

bool ExtrudedCrossSectionFeatureItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ExtrudedCrossSectionFeatureItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ExtrudedCrossSectionFeatureItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ExtrudedCrossSectionFeatureItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ExtrudedCrossSectionFeatureItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

ExtrudedCrossSectionMeasurementDeterminationType * ExtrudedCrossSectionFeatureItemType::getDeterminationMode()
{return DeterminationMode;}

void ExtrudedCrossSectionFeatureItemType::setDeterminationMode(ExtrudedCrossSectionMeasurementDeterminationType * DeterminationModeIn)
{DeterminationMode = DeterminationModeIn;}

/* ***************************************************************** */

/* class ExtrudedCrossSectionFeatureMeasurementType

*/

ExtrudedCrossSectionFeatureMeasurementType::ExtrudedCrossSectionFeatureMeasurementType() :
  SurfaceFeatureMeasurementBaseType()
{
  Direction = 0;
  Length = 0;
  Form = 0;
}

ExtrudedCrossSectionFeatureMeasurementType::ExtrudedCrossSectionFeatureMeasurementType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredUnitVectorType * DirectionIn,
 MeasuredLinearValueType * LengthIn,
 MeasuredLinearValueType * FormIn) :
  SurfaceFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Direction = DirectionIn;
  Length = LengthIn;
  Form = FormIn;
}

ExtrudedCrossSectionFeatureMeasurementType::ExtrudedCrossSectionFeatureMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredUnitVectorType * DirectionIn,
 MeasuredLinearValueType * LengthIn,
 MeasuredLinearValueType * FormIn) :
  SurfaceFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Direction = DirectionIn;
  Length = LengthIn;
  Form = FormIn;
}

ExtrudedCrossSectionFeatureMeasurementType::~ExtrudedCrossSectionFeatureMeasurementType()
{
  #ifndef NODESTRUCT
  delete Direction;
  delete Length;
  delete Form;
  #endif
}

void ExtrudedCrossSectionFeatureMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  if (Direction)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Direction");
      Direction->printSelf(outFile);
      fprintf(outFile, "</Direction>\n");
    }
  if (Length)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Length");
      Length->printSelf(outFile);
      fprintf(outFile, "</Length>\n");
    }
  if (Form)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Form");
      Form->printSelf(outFile);
      fprintf(outFile, "</Form>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ExtrudedCrossSectionFeatureMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ExtrudedCrossSectionFeatureMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ExtrudedCrossSectionFeatureMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ExtrudedCrossSectionFeatureMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ExtrudedCrossSectionFeatureMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredUnitVectorType * ExtrudedCrossSectionFeatureMeasurementType::getDirection()
{return Direction;}

void ExtrudedCrossSectionFeatureMeasurementType::setDirection(MeasuredUnitVectorType * DirectionIn)
{Direction = DirectionIn;}

MeasuredLinearValueType * ExtrudedCrossSectionFeatureMeasurementType::getLength()
{return Length;}

void ExtrudedCrossSectionFeatureMeasurementType::setLength(MeasuredLinearValueType * LengthIn)
{Length = LengthIn;}

MeasuredLinearValueType * ExtrudedCrossSectionFeatureMeasurementType::getForm()
{return Form;}

void ExtrudedCrossSectionFeatureMeasurementType::setForm(MeasuredLinearValueType * FormIn)
{Form = FormIn;}

/* ***************************************************************** */

/* class ExtrudedCrossSectionFeatureNominalType

*/

ExtrudedCrossSectionFeatureNominalType::ExtrudedCrossSectionFeatureNominalType() :
  SurfaceFeatureNominalBaseType()
{
  Direction = 0;
  CrossSectionReferenceFeatureId = 0;
  Constructed = 0;
}

ExtrudedCrossSectionFeatureNominalType::ExtrudedCrossSectionFeatureNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 UnitVectorType * DirectionIn,
 ArrayReferenceFullType * CrossSectionReferenceFeatureIdIn,
 ExtrudedCrossSectionConstructionMethodType * ConstructedIn) :
  SurfaceFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  Direction = DirectionIn;
  CrossSectionReferenceFeatureId = CrossSectionReferenceFeatureIdIn;
  Constructed = ConstructedIn;
}

ExtrudedCrossSectionFeatureNominalType::ExtrudedCrossSectionFeatureNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 UnitVectorType * DirectionIn,
 ArrayReferenceFullType * CrossSectionReferenceFeatureIdIn,
 ExtrudedCrossSectionConstructionMethodType * ConstructedIn) :
  SurfaceFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  Direction = DirectionIn;
  CrossSectionReferenceFeatureId = CrossSectionReferenceFeatureIdIn;
  Constructed = ConstructedIn;
}

ExtrudedCrossSectionFeatureNominalType::~ExtrudedCrossSectionFeatureNominalType()
{
  #ifndef NODESTRUCT
  delete Direction;
  delete CrossSectionReferenceFeatureId;
  delete Constructed;
  #endif
}

void ExtrudedCrossSectionFeatureNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Direction");
  Direction->printSelf(outFile);
  fprintf(outFile, "</Direction>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CrossSectionReferenceFeatureId");
  CrossSectionReferenceFeatureId->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</CrossSectionReferenceFeatureId>\n");
  if (Constructed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ExtrudedCrossSectionFeatureNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ExtrudedCrossSectionFeatureNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ExtrudedCrossSectionFeatureNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ExtrudedCrossSectionFeatureNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ExtrudedCrossSectionFeatureNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

UnitVectorType * ExtrudedCrossSectionFeatureNominalType::getDirection()
{return Direction;}

void ExtrudedCrossSectionFeatureNominalType::setDirection(UnitVectorType * DirectionIn)
{Direction = DirectionIn;}

ArrayReferenceFullType * ExtrudedCrossSectionFeatureNominalType::getCrossSectionReferenceFeatureId()
{return CrossSectionReferenceFeatureId;}

void ExtrudedCrossSectionFeatureNominalType::setCrossSectionReferenceFeatureId(ArrayReferenceFullType * CrossSectionReferenceFeatureIdIn)
{CrossSectionReferenceFeatureId = CrossSectionReferenceFeatureIdIn;}

ExtrudedCrossSectionConstructionMethodType * ExtrudedCrossSectionFeatureNominalType::getConstructed()
{return Constructed;}

void ExtrudedCrossSectionFeatureNominalType::setConstructed(ExtrudedCrossSectionConstructionMethodType * ConstructedIn)
{Constructed = ConstructedIn;}

/* ***************************************************************** */

/* class ExtrudedCrossSectionMeasurementDeterminationType

*/

ExtrudedCrossSectionMeasurementDeterminationType::ExtrudedCrossSectionMeasurementDeterminationType()
{
  ExtrudedCrossSectionMeasurementDeterminationTypePair = 0;
}

ExtrudedCrossSectionMeasurementDeterminationType::ExtrudedCrossSectionMeasurementDeterminationType(
 ExtrudedCrossSectionMeasurementDeterminationTypeChoicePair * ExtrudedCrossSectionMeasurementDeterminationTypePairIn)
{
  ExtrudedCrossSectionMeasurementDeterminationTypePair = ExtrudedCrossSectionMeasurementDeterminationTypePairIn;
}

ExtrudedCrossSectionMeasurementDeterminationType::~ExtrudedCrossSectionMeasurementDeterminationType()
{
  #ifndef NODESTRUCT
  delete ExtrudedCrossSectionMeasurementDeterminationTypePair;
  #endif
}

void ExtrudedCrossSectionMeasurementDeterminationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  ExtrudedCrossSectionMeasurementDeterminationTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

ExtrudedCrossSectionMeasurementDeterminationTypeChoicePair * ExtrudedCrossSectionMeasurementDeterminationType::getExtrudedCrossSectionMeasurementDeterminationTypePair()
{return ExtrudedCrossSectionMeasurementDeterminationTypePair;}

void ExtrudedCrossSectionMeasurementDeterminationType::setExtrudedCrossSectionMeasurementDeterminationTypePair(ExtrudedCrossSectionMeasurementDeterminationTypeChoicePair * ExtrudedCrossSectionMeasurementDeterminationTypePairIn)
{ExtrudedCrossSectionMeasurementDeterminationTypePair = ExtrudedCrossSectionMeasurementDeterminationTypePairIn;}
ExtrudedCrossSectionMeasurementDeterminationTypeChoicePair::ExtrudedCrossSectionMeasurementDeterminationTypeChoicePair() {}

ExtrudedCrossSectionMeasurementDeterminationTypeChoicePair::ExtrudedCrossSectionMeasurementDeterminationTypeChoicePair(
 whichOne ExtrudedCrossSectionMeasurementDeterminationTypeTypeIn,
 ExtrudedCrossSectionMeasurementDeterminationTypeVal * ExtrudedCrossSectionMeasurementDeterminationTypeValueIn)
{
  ExtrudedCrossSectionMeasurementDeterminationTypeType = ExtrudedCrossSectionMeasurementDeterminationTypeTypeIn;
  ExtrudedCrossSectionMeasurementDeterminationTypeValue = ExtrudedCrossSectionMeasurementDeterminationTypeValueIn;
}

ExtrudedCrossSectionMeasurementDeterminationTypeChoicePair::~ExtrudedCrossSectionMeasurementDeterminationTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (ExtrudedCrossSectionMeasurementDeterminationTypeType == CheckedE)
    delete ExtrudedCrossSectionMeasurementDeterminationTypeValue->Checked;
  else if (ExtrudedCrossSectionMeasurementDeterminationTypeType == SetE)
    delete ExtrudedCrossSectionMeasurementDeterminationTypeValue->Set;
  delete ExtrudedCrossSectionMeasurementDeterminationTypeValue;
  #endif
}

void ExtrudedCrossSectionMeasurementDeterminationTypeChoicePair::printSelf(FILE * outFile)
{
  if (ExtrudedCrossSectionMeasurementDeterminationTypeType == CheckedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Checked");
      ExtrudedCrossSectionMeasurementDeterminationTypeValue->Checked->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Checked>\n");
    }
  else if (ExtrudedCrossSectionMeasurementDeterminationTypeType == SetE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Set");
      ExtrudedCrossSectionMeasurementDeterminationTypeValue->Set->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class ExtrudedCrossSectionRecompType

*/

ExtrudedCrossSectionRecompType::ExtrudedCrossSectionRecompType() :
  ConstructionMethodBaseType()
{
  BaseFeaturePointList = 0;
}

ExtrudedCrossSectionRecompType::ExtrudedCrossSectionRecompType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeaturePointListType * BaseFeaturePointListIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeaturePointList = BaseFeaturePointListIn;
}

ExtrudedCrossSectionRecompType::~ExtrudedCrossSectionRecompType()
{
  #ifndef NODESTRUCT
  delete BaseFeaturePointList;
  #endif
}

void ExtrudedCrossSectionRecompType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeaturePointList");
  BaseFeaturePointList->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeaturePointList>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeaturePointListType * ExtrudedCrossSectionRecompType::getBaseFeaturePointList()
{return BaseFeaturePointList;}

void ExtrudedCrossSectionRecompType::setBaseFeaturePointList(BaseFeaturePointListType * BaseFeaturePointListIn)
{BaseFeaturePointList = BaseFeaturePointListIn;}

/* ***************************************************************** */

/* class ExtrudedCrossSectionTransformType

*/

ExtrudedCrossSectionTransformType::ExtrudedCrossSectionTransformType() :
  ConstructionMethodBaseType()
{
  BaseExtrudedCrossSection = 0;
  Transformation = 0;
}

ExtrudedCrossSectionTransformType::ExtrudedCrossSectionTransformType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseExtrudedCrossSectionIn,
 TransformationReferenceType * TransformationIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseExtrudedCrossSection = BaseExtrudedCrossSectionIn;
  Transformation = TransformationIn;
}

ExtrudedCrossSectionTransformType::~ExtrudedCrossSectionTransformType()
{
  #ifndef NODESTRUCT
  delete BaseExtrudedCrossSection;
  delete Transformation;
  #endif
}

void ExtrudedCrossSectionTransformType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseExtrudedCrossSection");
  BaseExtrudedCrossSection->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseExtrudedCrossSection>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Transformation");
  Transformation->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Transformation>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * ExtrudedCrossSectionTransformType::getBaseExtrudedCrossSection()
{return BaseExtrudedCrossSection;}

void ExtrudedCrossSectionTransformType::setBaseExtrudedCrossSection(BaseFeatureType * BaseExtrudedCrossSectionIn)
{BaseExtrudedCrossSection = BaseExtrudedCrossSectionIn;}

TransformationReferenceType * ExtrudedCrossSectionTransformType::getTransformation()
{return Transformation;}

void ExtrudedCrossSectionTransformType::setTransformation(TransformationReferenceType * TransformationIn)
{Transformation = TransformationIn;}

/* ***************************************************************** */

/* class FeatureAspectsListsType

*/

FeatureAspectsListsType::FeatureAspectsListsType()
{
  FeatureDefinitions = 0;
  FeatureNominals = 0;
  FeatureItems = 0;
  NominalPointSets = 0;
}

FeatureAspectsListsType::FeatureAspectsListsType(
 FeatureDefinitionsType * FeatureDefinitionsIn,
 FeatureNominalsType * FeatureNominalsIn,
 FeatureItemsType * FeatureItemsIn,
 NominalPointSetListType * NominalPointSetsIn)
{
  FeatureDefinitions = FeatureDefinitionsIn;
  FeatureNominals = FeatureNominalsIn;
  FeatureItems = FeatureItemsIn;
  NominalPointSets = NominalPointSetsIn;
}

FeatureAspectsListsType::~FeatureAspectsListsType()
{
  #ifndef NODESTRUCT
  delete FeatureDefinitions;
  delete FeatureNominals;
  delete FeatureItems;
  delete NominalPointSets;
  #endif
}

void FeatureAspectsListsType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (FeatureDefinitions)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureDefinitions");
      FeatureDefinitions->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureDefinitions>\n");
    }
  if (FeatureNominals)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureNominals");
      FeatureNominals->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureNominals>\n");
    }
  if (FeatureItems)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItems");
      FeatureItems->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FeatureItems>\n");
    }
  if (NominalPointSets)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalPointSets");
      NominalPointSets->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NominalPointSets>\n");
    }
  doSpaces(-INDENT, outFile);
}

FeatureDefinitionsType * FeatureAspectsListsType::getFeatureDefinitions()
{return FeatureDefinitions;}

void FeatureAspectsListsType::setFeatureDefinitions(FeatureDefinitionsType * FeatureDefinitionsIn)
{FeatureDefinitions = FeatureDefinitionsIn;}

FeatureNominalsType * FeatureAspectsListsType::getFeatureNominals()
{return FeatureNominals;}

void FeatureAspectsListsType::setFeatureNominals(FeatureNominalsType * FeatureNominalsIn)
{FeatureNominals = FeatureNominalsIn;}

FeatureItemsType * FeatureAspectsListsType::getFeatureItems()
{return FeatureItems;}

void FeatureAspectsListsType::setFeatureItems(FeatureItemsType * FeatureItemsIn)
{FeatureItems = FeatureItemsIn;}

NominalPointSetListType * FeatureAspectsListsType::getNominalPointSets()
{return NominalPointSets;}

void FeatureAspectsListsType::setNominalPointSets(NominalPointSetListType * NominalPointSetsIn)
{NominalPointSets = NominalPointSetsIn;}

/* ***************************************************************** */

/* class FeatureBaseType

*/

FeatureBaseType::FeatureBaseType()
{
  id = 0;
  Attributes = 0;
}

FeatureBaseType::FeatureBaseType(
 AttributesType * AttributesIn)
{
  id = 0;
  Attributes = AttributesIn;
}

FeatureBaseType::FeatureBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn)
{
  id = idIn;
  Attributes = AttributesIn;
}

FeatureBaseType::~FeatureBaseType()
{
  #ifndef NODESTRUCT
  delete id;
  delete Attributes;
  #endif
}

void FeatureBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool FeatureBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in FeatureBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in FeatureBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FeatureBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in FeatureBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

QIFIdType * FeatureBaseType::getid()
{return id;}

void FeatureBaseType::setid(QIFIdType * idIn)
{id = idIn;}

AttributesType * FeatureBaseType::getAttributes()
{return Attributes;}

void FeatureBaseType::setAttributes(AttributesType * AttributesIn)
{Attributes = AttributesIn;}

/* ***************************************************************** */

/* class FeatureDefinitionBaseType

*/

FeatureDefinitionBaseType::FeatureDefinitionBaseType() :
  FeatureBaseType()
{
}

FeatureDefinitionBaseType::FeatureDefinitionBaseType(
 AttributesType * AttributesIn) :
  FeatureBaseType(
    AttributesIn)
{
}

FeatureDefinitionBaseType::FeatureDefinitionBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn) :
  FeatureBaseType(
    idIn,
    AttributesIn)
{
}

FeatureDefinitionBaseType::~FeatureDefinitionBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void FeatureDefinitionBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool FeatureDefinitionBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in FeatureDefinitionBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in FeatureDefinitionBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FeatureDefinitionBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in FeatureDefinitionBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class FeatureDefinitionBaseTypeLisd

*/

FeatureDefinitionBaseTypeLisd::FeatureDefinitionBaseTypeLisd() {}

FeatureDefinitionBaseTypeLisd::FeatureDefinitionBaseTypeLisd(FeatureDefinitionBaseType * aFeatureDefinitionBaseType)
{
  push_back(aFeatureDefinitionBaseType);
}

FeatureDefinitionBaseTypeLisd::~FeatureDefinitionBaseTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<FeatureDefinitionBaseType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void FeatureDefinitionBaseTypeLisd::printSelf(FILE * outFile)
{
  std::list<FeatureDefinitionBaseType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class FeatureDefinitionsType

*/

FeatureDefinitionsType::FeatureDefinitionsType()
{
  n = 0;
  FeatureDefinition = 0;
}

FeatureDefinitionsType::FeatureDefinitionsType(
 FeatureDefinitionBaseTypeLisd * FeatureDefinitionIn)
{
  n = 0;
  FeatureDefinition = FeatureDefinitionIn;
}

FeatureDefinitionsType::FeatureDefinitionsType(
 NaturalType * nIn,
 FeatureDefinitionBaseTypeLisd * FeatureDefinitionIn)
{
  n = nIn;
  FeatureDefinition = FeatureDefinitionIn;
}

FeatureDefinitionsType::~FeatureDefinitionsType()
{
  #ifndef NODESTRUCT
  delete n;
  delete FeatureDefinition;
  #endif
}

void FeatureDefinitionsType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!FeatureDefinition)
      {
        fprintf(stderr, "FeatureDefinition list is missing\n");
        exit(1);
      }
    if (FeatureDefinition->size() == 0)
      {
        fprintf(stderr, "FeatureDefinition list is empty\n");
        exit(1);
      }
    if (FeatureDefinition->size() < 1)
      {
        fprintf(stderr,
                "size of FeatureDefinition list (%d) less than minimum required (1)\n",
                (int)FeatureDefinition->size());
        exit(1);
      }
    std::list<FeatureDefinitionBaseType *>::iterator iter;
    for (iter = FeatureDefinition->begin();
         iter != FeatureDefinition->end(); iter++)
      {
        FeatureDefinitionBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->getprintElement(), "CircleFeatureDefinition") == 0)
          {
            CircleFeatureDefinitionType * typ;
            if ((typ = dynamic_cast<CircleFeatureDefinitionType *>(basie)))
              {
                fprintf(outFile, "<CircleFeatureDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CircleFeatureDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad CircleFeatureDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CircularArcFeatureDefinition") == 0)
          {
            CircularArcFeatureDefinitionType * typ;
            if ((typ = dynamic_cast<CircularArcFeatureDefinitionType *>(basie)))
              {
                fprintf(outFile, "<CircularArcFeatureDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CircularArcFeatureDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad CircularArcFeatureDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ConeFeatureDefinition") == 0)
          {
            ConeFeatureDefinitionType * typ;
            if ((typ = dynamic_cast<ConeFeatureDefinitionType *>(basie)))
              {
                fprintf(outFile, "<ConeFeatureDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ConeFeatureDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad ConeFeatureDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ConicalSegmentFeatureDefinition") == 0)
          {
            ConicalSegmentFeatureDefinitionType * typ;
            if ((typ = dynamic_cast<ConicalSegmentFeatureDefinitionType *>(basie)))
              {
                fprintf(outFile, "<ConicalSegmentFeatureDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ConicalSegmentFeatureDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad ConicalSegmentFeatureDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CylinderFeatureDefinition") == 0)
          {
            CylinderFeatureDefinitionType * typ;
            if ((typ = dynamic_cast<CylinderFeatureDefinitionType *>(basie)))
              {
                fprintf(outFile, "<CylinderFeatureDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CylinderFeatureDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad CylinderFeatureDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CylindricalSegmentFeatureDefinition") == 0)
          {
            CylindricalSegmentFeatureDefinitionType * typ;
            if ((typ = dynamic_cast<CylindricalSegmentFeatureDefinitionType *>(basie)))
              {
                fprintf(outFile, "<CylindricalSegmentFeatureDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CylindricalSegmentFeatureDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad CylindricalSegmentFeatureDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "EdgePointFeatureDefinition") == 0)
          {
            EdgePointFeatureDefinitionType * typ;
            if ((typ = dynamic_cast<EdgePointFeatureDefinitionType *>(basie)))
              {
                fprintf(outFile, "<EdgePointFeatureDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EdgePointFeatureDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad EdgePointFeatureDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "EllipseFeatureDefinition") == 0)
          {
            EllipseFeatureDefinitionType * typ;
            if ((typ = dynamic_cast<EllipseFeatureDefinitionType *>(basie)))
              {
                fprintf(outFile, "<EllipseFeatureDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EllipseFeatureDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad EllipseFeatureDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "EllipticalArcFeatureDefinition") == 0)
          {
            EllipticalArcFeatureDefinitionType * typ;
            if ((typ = dynamic_cast<EllipticalArcFeatureDefinitionType *>(basie)))
              {
                fprintf(outFile, "<EllipticalArcFeatureDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EllipticalArcFeatureDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad EllipticalArcFeatureDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ElongatedCircleFeatureDefinition") == 0)
          {
            ElongatedCircleFeatureDefinitionType * typ;
            if ((typ = dynamic_cast<ElongatedCircleFeatureDefinitionType *>(basie)))
              {
                fprintf(outFile, "<ElongatedCircleFeatureDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ElongatedCircleFeatureDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad ElongatedCircleFeatureDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ElongatedCylinderFeatureDefinition") == 0)
          {
            ElongatedCylinderFeatureDefinitionType * typ;
            if ((typ = dynamic_cast<ElongatedCylinderFeatureDefinitionType *>(basie)))
              {
                fprintf(outFile, "<ElongatedCylinderFeatureDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ElongatedCylinderFeatureDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad ElongatedCylinderFeatureDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ExtrudedCrossSectionFeatureDefinition") == 0)
          {
            ExtrudedCrossSectionFeatureDefinitionType * typ;
            if ((typ = dynamic_cast<ExtrudedCrossSectionFeatureDefinitionType *>(basie)))
              {
                fprintf(outFile, "<ExtrudedCrossSectionFeatureDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ExtrudedCrossSectionFeatureDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad ExtrudedCrossSectionFeatureDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "GroupFeatureDefinition") == 0)
          {
            GroupFeatureDefinitionType * typ;
            if ((typ = dynamic_cast<GroupFeatureDefinitionType *>(basie)))
              {
                fprintf(outFile, "<GroupFeatureDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GroupFeatureDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad GroupFeatureDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "LineFeatureDefinition") == 0)
          {
            LineFeatureDefinitionType * typ;
            if ((typ = dynamic_cast<LineFeatureDefinitionType *>(basie)))
              {
                fprintf(outFile, "<LineFeatureDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LineFeatureDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad LineFeatureDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "MarkingFeatureDefinition") == 0)
          {
            MarkingFeatureDefinitionType * typ;
            if ((typ = dynamic_cast<MarkingFeatureDefinitionType *>(basie)))
              {
                fprintf(outFile, "<MarkingFeatureDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</MarkingFeatureDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad MarkingFeatureDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OppositeAngledLinesFeatureDefinition") == 0)
          {
            OppositeAngledLinesFeatureDefinitionType * typ;
            if ((typ = dynamic_cast<OppositeAngledLinesFeatureDefinitionType *>(basie)))
              {
                fprintf(outFile, "<OppositeAngledLinesFeatureDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OppositeAngledLinesFeatureDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad OppositeAngledLinesFeatureDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OppositeAngledPlanesFeatureDefinition") == 0)
          {
            OppositeAngledPlanesFeatureDefinitionType * typ;
            if ((typ = dynamic_cast<OppositeAngledPlanesFeatureDefinitionType *>(basie)))
              {
                fprintf(outFile, "<OppositeAngledPlanesFeatureDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OppositeAngledPlanesFeatureDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad OppositeAngledPlanesFeatureDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OppositeParallelLinesFeatureDefinition") == 0)
          {
            OppositeParallelLinesFeatureDefinitionType * typ;
            if ((typ = dynamic_cast<OppositeParallelLinesFeatureDefinitionType *>(basie)))
              {
                fprintf(outFile, "<OppositeParallelLinesFeatureDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OppositeParallelLinesFeatureDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad OppositeParallelLinesFeatureDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OppositeParallelPlanesFeatureDefinition") == 0)
          {
            OppositeParallelPlanesFeatureDefinitionType * typ;
            if ((typ = dynamic_cast<OppositeParallelPlanesFeatureDefinitionType *>(basie)))
              {
                fprintf(outFile, "<OppositeParallelPlanesFeatureDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OppositeParallelPlanesFeatureDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad OppositeParallelPlanesFeatureDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OtherCurveFeatureDefinition") == 0)
          {
            OtherCurveFeatureDefinitionType * typ;
            if ((typ = dynamic_cast<OtherCurveFeatureDefinitionType *>(basie)))
              {
                fprintf(outFile, "<OtherCurveFeatureDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OtherCurveFeatureDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad OtherCurveFeatureDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OtherNonShapeFeatureDefinition") == 0)
          {
            OtherNonShapeFeatureDefinitionType * typ;
            if ((typ = dynamic_cast<OtherNonShapeFeatureDefinitionType *>(basie)))
              {
                fprintf(outFile, "<OtherNonShapeFeatureDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OtherNonShapeFeatureDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad OtherNonShapeFeatureDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OtherShapeFeatureDefinition") == 0)
          {
            OtherShapeFeatureDefinitionType * typ;
            if ((typ = dynamic_cast<OtherShapeFeatureDefinitionType *>(basie)))
              {
                fprintf(outFile, "<OtherShapeFeatureDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OtherShapeFeatureDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad OtherShapeFeatureDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OtherSurfaceFeatureDefinition") == 0)
          {
            OtherSurfaceFeatureDefinitionType * typ;
            if ((typ = dynamic_cast<OtherSurfaceFeatureDefinitionType *>(basie)))
              {
                fprintf(outFile, "<OtherSurfaceFeatureDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OtherSurfaceFeatureDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad OtherSurfaceFeatureDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PatternFeatureCircleDefinition") == 0)
          {
            PatternFeatureCircleDefinitionType * typ;
            if ((typ = dynamic_cast<PatternFeatureCircleDefinitionType *>(basie)))
              {
                fprintf(outFile, "<PatternFeatureCircleDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PatternFeatureCircleDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad PatternFeatureCircleDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PatternFeatureCircularArcDefinition") == 0)
          {
            PatternFeatureCircularArcDefinitionType * typ;
            if ((typ = dynamic_cast<PatternFeatureCircularArcDefinitionType *>(basie)))
              {
                fprintf(outFile, "<PatternFeatureCircularArcDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PatternFeatureCircularArcDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad PatternFeatureCircularArcDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PatternFeatureLinearDefinition") == 0)
          {
            PatternFeatureLinearDefinitionType * typ;
            if ((typ = dynamic_cast<PatternFeatureLinearDefinitionType *>(basie)))
              {
                fprintf(outFile, "<PatternFeatureLinearDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PatternFeatureLinearDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad PatternFeatureLinearDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PatternFeatureParallelogramDefinition") == 0)
          {
            PatternFeatureParallelogramDefinitionType * typ;
            if ((typ = dynamic_cast<PatternFeatureParallelogramDefinitionType *>(basie)))
              {
                fprintf(outFile, "<PatternFeatureParallelogramDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PatternFeatureParallelogramDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad PatternFeatureParallelogramDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PlaneFeatureDefinition") == 0)
          {
            PlaneFeatureDefinitionType * typ;
            if ((typ = dynamic_cast<PlaneFeatureDefinitionType *>(basie)))
              {
                fprintf(outFile, "<PlaneFeatureDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PlaneFeatureDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad PlaneFeatureDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PointDefinedCurveFeatureDefinition") == 0)
          {
            PointDefinedCurveFeatureDefinitionType * typ;
            if ((typ = dynamic_cast<PointDefinedCurveFeatureDefinitionType *>(basie)))
              {
                fprintf(outFile, "<PointDefinedCurveFeatureDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PointDefinedCurveFeatureDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad PointDefinedCurveFeatureDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PointDefinedSurfaceFeatureDefinition") == 0)
          {
            PointDefinedSurfaceFeatureDefinitionType * typ;
            if ((typ = dynamic_cast<PointDefinedSurfaceFeatureDefinitionType *>(basie)))
              {
                fprintf(outFile, "<PointDefinedSurfaceFeatureDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PointDefinedSurfaceFeatureDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad PointDefinedSurfaceFeatureDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PointFeatureDefinition") == 0)
          {
            PointFeatureDefinitionType * typ;
            if ((typ = dynamic_cast<PointFeatureDefinitionType *>(basie)))
              {
                fprintf(outFile, "<PointFeatureDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PointFeatureDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad PointFeatureDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SphereFeatureDefinition") == 0)
          {
            SphereFeatureDefinitionType * typ;
            if ((typ = dynamic_cast<SphereFeatureDefinitionType *>(basie)))
              {
                fprintf(outFile, "<SphereFeatureDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphereFeatureDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad SphereFeatureDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SphericalSegmentFeatureDefinition") == 0)
          {
            SphericalSegmentFeatureDefinitionType * typ;
            if ((typ = dynamic_cast<SphericalSegmentFeatureDefinitionType *>(basie)))
              {
                fprintf(outFile, "<SphericalSegmentFeatureDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalSegmentFeatureDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalSegmentFeatureDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SurfaceOfRevolutionFeatureDefinition") == 0)
          {
            SurfaceOfRevolutionFeatureDefinitionType * typ;
            if ((typ = dynamic_cast<SurfaceOfRevolutionFeatureDefinitionType *>(basie)))
              {
                fprintf(outFile, "<SurfaceOfRevolutionFeatureDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SurfaceOfRevolutionFeatureDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad SurfaceOfRevolutionFeatureDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ThreadedFeatureDefinition") == 0)
          {
            ThreadedFeatureDefinitionType * typ;
            if ((typ = dynamic_cast<ThreadedFeatureDefinitionType *>(basie)))
              {
                fprintf(outFile, "<ThreadedFeatureDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ThreadedFeatureDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad ThreadedFeatureDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ToroidalSegmentFeatureDefinition") == 0)
          {
            ToroidalSegmentFeatureDefinitionType * typ;
            if ((typ = dynamic_cast<ToroidalSegmentFeatureDefinitionType *>(basie)))
              {
                fprintf(outFile, "<ToroidalSegmentFeatureDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ToroidalSegmentFeatureDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad ToroidalSegmentFeatureDefinition element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "TorusFeatureDefinition") == 0)
          {
            TorusFeatureDefinitionType * typ;
            if ((typ = dynamic_cast<TorusFeatureDefinitionType *>(basie)))
              {
                fprintf(outFile, "<TorusFeatureDefinition");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TorusFeatureDefinition>\n");
              }
            else
              {
                fprintf(stderr, "bad TorusFeatureDefinition element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad FeatureDefinition type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool FeatureDefinitionsType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in FeatureDefinitionsType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in FeatureDefinitionsType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FeatureDefinitionsType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in FeatureDefinitionsType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * FeatureDefinitionsType::getn()
{return n;}

void FeatureDefinitionsType::setn(NaturalType * nIn)
{n = nIn;}

FeatureDefinitionBaseTypeLisd * FeatureDefinitionsType::getFeatureDefinition()
{return FeatureDefinition;}

void FeatureDefinitionsType::setFeatureDefinition(FeatureDefinitionBaseTypeLisd * FeatureDefinitionIn)
{FeatureDefinition = FeatureDefinitionIn;}

/* ***************************************************************** */

/* class FeatureItemBaseType

*/

FeatureItemBaseType::FeatureItemBaseType() :
  FeatureBaseType()
{
  FeatureNominalId = 0;
  ParentFeatureItemId = 0;
  FeatureName = 0;
  UUID = 0;
  NotableEventIds = 0;
  CoordinateSystemId = 0;
}

FeatureItemBaseType::FeatureItemBaseType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn) :
  FeatureBaseType(
    AttributesIn)
{
  FeatureNominalId = FeatureNominalIdIn;
  ParentFeatureItemId = ParentFeatureItemIdIn;
  FeatureName = FeatureNameIn;
  UUID = UUIDIn;
  NotableEventIds = NotableEventIdsIn;
  CoordinateSystemId = CoordinateSystemIdIn;
}

FeatureItemBaseType::FeatureItemBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn) :
  FeatureBaseType(
    idIn,
    AttributesIn)
{
  FeatureNominalId = FeatureNominalIdIn;
  ParentFeatureItemId = ParentFeatureItemIdIn;
  FeatureName = FeatureNameIn;
  UUID = UUIDIn;
  NotableEventIds = NotableEventIdsIn;
  CoordinateSystemId = CoordinateSystemIdIn;
}

FeatureItemBaseType::~FeatureItemBaseType()
{
  #ifndef NODESTRUCT
  delete FeatureNominalId;
  delete ParentFeatureItemId;
  delete FeatureName;
  delete UUID;
  delete NotableEventIds;
  delete CoordinateSystemId;
  #endif
}

void FeatureItemBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool FeatureItemBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in FeatureItemBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in FeatureItemBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FeatureItemBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in FeatureItemBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

QIFReferenceFullType * FeatureItemBaseType::getFeatureNominalId()
{return FeatureNominalId;}

void FeatureItemBaseType::setFeatureNominalId(QIFReferenceFullType * FeatureNominalIdIn)
{FeatureNominalId = FeatureNominalIdIn;}

QIFReferenceType * FeatureItemBaseType::getParentFeatureItemId()
{return ParentFeatureItemId;}

void FeatureItemBaseType::setParentFeatureItemId(QIFReferenceType * ParentFeatureItemIdIn)
{ParentFeatureItemId = ParentFeatureItemIdIn;}

XmlToken * FeatureItemBaseType::getFeatureName()
{return FeatureName;}

void FeatureItemBaseType::setFeatureName(XmlToken * FeatureNameIn)
{FeatureName = FeatureNameIn;}

QPIdType * FeatureItemBaseType::getUUID()
{return UUID;}

void FeatureItemBaseType::setUUID(QPIdType * UUIDIn)
{UUID = UUIDIn;}

ArrayReferenceType * FeatureItemBaseType::getNotableEventIds()
{return NotableEventIds;}

void FeatureItemBaseType::setNotableEventIds(ArrayReferenceType * NotableEventIdsIn)
{NotableEventIds = NotableEventIdsIn;}

QIFReferenceFullType * FeatureItemBaseType::getCoordinateSystemId()
{return CoordinateSystemId;}

void FeatureItemBaseType::setCoordinateSystemId(QIFReferenceFullType * CoordinateSystemIdIn)
{CoordinateSystemId = CoordinateSystemIdIn;}

/* ***************************************************************** */

/* class FeatureItemBaseTypeLisd

*/

FeatureItemBaseTypeLisd::FeatureItemBaseTypeLisd() {}

FeatureItemBaseTypeLisd::FeatureItemBaseTypeLisd(FeatureItemBaseType * aFeatureItemBaseType)
{
  push_back(aFeatureItemBaseType);
}

FeatureItemBaseTypeLisd::~FeatureItemBaseTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<FeatureItemBaseType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void FeatureItemBaseTypeLisd::printSelf(FILE * outFile)
{
  std::list<FeatureItemBaseType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class FeatureItemsType

*/

FeatureItemsType::FeatureItemsType()
{
  n = 0;
  FeatureItem = 0;
}

FeatureItemsType::FeatureItemsType(
 FeatureItemBaseTypeLisd * FeatureItemIn)
{
  n = 0;
  FeatureItem = FeatureItemIn;
}

FeatureItemsType::FeatureItemsType(
 NaturalType * nIn,
 FeatureItemBaseTypeLisd * FeatureItemIn)
{
  n = nIn;
  FeatureItem = FeatureItemIn;
}

FeatureItemsType::~FeatureItemsType()
{
  #ifndef NODESTRUCT
  delete n;
  delete FeatureItem;
  #endif
}

void FeatureItemsType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!FeatureItem)
      {
        fprintf(stderr, "FeatureItem list is missing\n");
        exit(1);
      }
    if (FeatureItem->size() == 0)
      {
        fprintf(stderr, "FeatureItem list is empty\n");
        exit(1);
      }
    if (FeatureItem->size() < 1)
      {
        fprintf(stderr,
                "size of FeatureItem list (%d) less than minimum required (1)\n",
                (int)FeatureItem->size());
        exit(1);
      }
    std::list<FeatureItemBaseType *>::iterator iter;
    for (iter = FeatureItem->begin();
         iter != FeatureItem->end(); iter++)
      {
        FeatureItemBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->getprintElement(), "CircleFeatureItem") == 0)
          {
            CircleFeatureItemType * typ;
            if ((typ = dynamic_cast<CircleFeatureItemType *>(basie)))
              {
                fprintf(outFile, "<CircleFeatureItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CircleFeatureItem>\n");
              }
            else
              {
                fprintf(stderr, "bad CircleFeatureItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CircularArcFeatureItem") == 0)
          {
            CircularArcFeatureItemType * typ;
            if ((typ = dynamic_cast<CircularArcFeatureItemType *>(basie)))
              {
                fprintf(outFile, "<CircularArcFeatureItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CircularArcFeatureItem>\n");
              }
            else
              {
                fprintf(stderr, "bad CircularArcFeatureItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ConeFeatureItem") == 0)
          {
            ConeFeatureItemType * typ;
            if ((typ = dynamic_cast<ConeFeatureItemType *>(basie)))
              {
                fprintf(outFile, "<ConeFeatureItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ConeFeatureItem>\n");
              }
            else
              {
                fprintf(stderr, "bad ConeFeatureItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ConicalSegmentFeatureItem") == 0)
          {
            ConicalSegmentFeatureItemType * typ;
            if ((typ = dynamic_cast<ConicalSegmentFeatureItemType *>(basie)))
              {
                fprintf(outFile, "<ConicalSegmentFeatureItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ConicalSegmentFeatureItem>\n");
              }
            else
              {
                fprintf(stderr, "bad ConicalSegmentFeatureItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CylinderFeatureItem") == 0)
          {
            CylinderFeatureItemType * typ;
            if ((typ = dynamic_cast<CylinderFeatureItemType *>(basie)))
              {
                fprintf(outFile, "<CylinderFeatureItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CylinderFeatureItem>\n");
              }
            else
              {
                fprintf(stderr, "bad CylinderFeatureItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CylindricalSegmentFeatureItem") == 0)
          {
            CylindricalSegmentFeatureItemType * typ;
            if ((typ = dynamic_cast<CylindricalSegmentFeatureItemType *>(basie)))
              {
                fprintf(outFile, "<CylindricalSegmentFeatureItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CylindricalSegmentFeatureItem>\n");
              }
            else
              {
                fprintf(stderr, "bad CylindricalSegmentFeatureItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "EdgePointFeatureItem") == 0)
          {
            EdgePointFeatureItemType * typ;
            if ((typ = dynamic_cast<EdgePointFeatureItemType *>(basie)))
              {
                fprintf(outFile, "<EdgePointFeatureItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EdgePointFeatureItem>\n");
              }
            else
              {
                fprintf(stderr, "bad EdgePointFeatureItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "EllipseFeatureItem") == 0)
          {
            EllipseFeatureItemType * typ;
            if ((typ = dynamic_cast<EllipseFeatureItemType *>(basie)))
              {
                fprintf(outFile, "<EllipseFeatureItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EllipseFeatureItem>\n");
              }
            else
              {
                fprintf(stderr, "bad EllipseFeatureItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "EllipticalArcFeatureItem") == 0)
          {
            EllipticalArcFeatureItemType * typ;
            if ((typ = dynamic_cast<EllipticalArcFeatureItemType *>(basie)))
              {
                fprintf(outFile, "<EllipticalArcFeatureItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EllipticalArcFeatureItem>\n");
              }
            else
              {
                fprintf(stderr, "bad EllipticalArcFeatureItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ElongatedCircleFeatureItem") == 0)
          {
            ElongatedCircleFeatureItemType * typ;
            if ((typ = dynamic_cast<ElongatedCircleFeatureItemType *>(basie)))
              {
                fprintf(outFile, "<ElongatedCircleFeatureItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ElongatedCircleFeatureItem>\n");
              }
            else
              {
                fprintf(stderr, "bad ElongatedCircleFeatureItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ElongatedCylinderFeatureItem") == 0)
          {
            ElongatedCylinderFeatureItemType * typ;
            if ((typ = dynamic_cast<ElongatedCylinderFeatureItemType *>(basie)))
              {
                fprintf(outFile, "<ElongatedCylinderFeatureItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ElongatedCylinderFeatureItem>\n");
              }
            else
              {
                fprintf(stderr, "bad ElongatedCylinderFeatureItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ExtrudedCrossSectionFeatureItem") == 0)
          {
            ExtrudedCrossSectionFeatureItemType * typ;
            if ((typ = dynamic_cast<ExtrudedCrossSectionFeatureItemType *>(basie)))
              {
                fprintf(outFile, "<ExtrudedCrossSectionFeatureItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ExtrudedCrossSectionFeatureItem>\n");
              }
            else
              {
                fprintf(stderr, "bad ExtrudedCrossSectionFeatureItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "GroupFeatureItem") == 0)
          {
            GroupFeatureItemType * typ;
            if ((typ = dynamic_cast<GroupFeatureItemType *>(basie)))
              {
                fprintf(outFile, "<GroupFeatureItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GroupFeatureItem>\n");
              }
            else
              {
                fprintf(stderr, "bad GroupFeatureItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "LineFeatureItem") == 0)
          {
            LineFeatureItemType * typ;
            if ((typ = dynamic_cast<LineFeatureItemType *>(basie)))
              {
                fprintf(outFile, "<LineFeatureItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LineFeatureItem>\n");
              }
            else
              {
                fprintf(stderr, "bad LineFeatureItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "MarkingFeatureItem") == 0)
          {
            MarkingFeatureItemType * typ;
            if ((typ = dynamic_cast<MarkingFeatureItemType *>(basie)))
              {
                fprintf(outFile, "<MarkingFeatureItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</MarkingFeatureItem>\n");
              }
            else
              {
                fprintf(stderr, "bad MarkingFeatureItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OppositeAngledLinesFeatureItem") == 0)
          {
            OppositeAngledLinesFeatureItemType * typ;
            if ((typ = dynamic_cast<OppositeAngledLinesFeatureItemType *>(basie)))
              {
                fprintf(outFile, "<OppositeAngledLinesFeatureItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OppositeAngledLinesFeatureItem>\n");
              }
            else
              {
                fprintf(stderr, "bad OppositeAngledLinesFeatureItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OppositeAngledPlanesFeatureItem") == 0)
          {
            OppositeAngledPlanesFeatureItemType * typ;
            if ((typ = dynamic_cast<OppositeAngledPlanesFeatureItemType *>(basie)))
              {
                fprintf(outFile, "<OppositeAngledPlanesFeatureItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OppositeAngledPlanesFeatureItem>\n");
              }
            else
              {
                fprintf(stderr, "bad OppositeAngledPlanesFeatureItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OppositeParallelLinesFeatureItem") == 0)
          {
            OppositeParallelLinesFeatureItemType * typ;
            if ((typ = dynamic_cast<OppositeParallelLinesFeatureItemType *>(basie)))
              {
                fprintf(outFile, "<OppositeParallelLinesFeatureItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OppositeParallelLinesFeatureItem>\n");
              }
            else
              {
                fprintf(stderr, "bad OppositeParallelLinesFeatureItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OppositeParallelPlanesFeatureItem") == 0)
          {
            OppositeParallelPlanesFeatureItemType * typ;
            if ((typ = dynamic_cast<OppositeParallelPlanesFeatureItemType *>(basie)))
              {
                fprintf(outFile, "<OppositeParallelPlanesFeatureItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OppositeParallelPlanesFeatureItem>\n");
              }
            else
              {
                fprintf(stderr, "bad OppositeParallelPlanesFeatureItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OtherCurveFeatureItem") == 0)
          {
            OtherCurveFeatureItemType * typ;
            if ((typ = dynamic_cast<OtherCurveFeatureItemType *>(basie)))
              {
                fprintf(outFile, "<OtherCurveFeatureItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OtherCurveFeatureItem>\n");
              }
            else
              {
                fprintf(stderr, "bad OtherCurveFeatureItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OtherNonShapeFeatureItem") == 0)
          {
            OtherNonShapeFeatureItemType * typ;
            if ((typ = dynamic_cast<OtherNonShapeFeatureItemType *>(basie)))
              {
                fprintf(outFile, "<OtherNonShapeFeatureItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OtherNonShapeFeatureItem>\n");
              }
            else
              {
                fprintf(stderr, "bad OtherNonShapeFeatureItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OtherShapeFeatureItem") == 0)
          {
            OtherShapeFeatureItemType * typ;
            if ((typ = dynamic_cast<OtherShapeFeatureItemType *>(basie)))
              {
                fprintf(outFile, "<OtherShapeFeatureItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OtherShapeFeatureItem>\n");
              }
            else
              {
                fprintf(stderr, "bad OtherShapeFeatureItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OtherSurfaceFeatureItem") == 0)
          {
            OtherSurfaceFeatureItemType * typ;
            if ((typ = dynamic_cast<OtherSurfaceFeatureItemType *>(basie)))
              {
                fprintf(outFile, "<OtherSurfaceFeatureItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OtherSurfaceFeatureItem>\n");
              }
            else
              {
                fprintf(stderr, "bad OtherSurfaceFeatureItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PatternFeatureCircleItem") == 0)
          {
            PatternFeatureCircleItemType * typ;
            if ((typ = dynamic_cast<PatternFeatureCircleItemType *>(basie)))
              {
                fprintf(outFile, "<PatternFeatureCircleItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PatternFeatureCircleItem>\n");
              }
            else
              {
                fprintf(stderr, "bad PatternFeatureCircleItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PatternFeatureCircularArcItem") == 0)
          {
            PatternFeatureCircularArcItemType * typ;
            if ((typ = dynamic_cast<PatternFeatureCircularArcItemType *>(basie)))
              {
                fprintf(outFile, "<PatternFeatureCircularArcItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PatternFeatureCircularArcItem>\n");
              }
            else
              {
                fprintf(stderr, "bad PatternFeatureCircularArcItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PatternFeatureLinearItem") == 0)
          {
            PatternFeatureLinearItemType * typ;
            if ((typ = dynamic_cast<PatternFeatureLinearItemType *>(basie)))
              {
                fprintf(outFile, "<PatternFeatureLinearItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PatternFeatureLinearItem>\n");
              }
            else
              {
                fprintf(stderr, "bad PatternFeatureLinearItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PatternFeatureParallelogramItem") == 0)
          {
            PatternFeatureParallelogramItemType * typ;
            if ((typ = dynamic_cast<PatternFeatureParallelogramItemType *>(basie)))
              {
                fprintf(outFile, "<PatternFeatureParallelogramItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PatternFeatureParallelogramItem>\n");
              }
            else
              {
                fprintf(stderr, "bad PatternFeatureParallelogramItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PlaneFeatureItem") == 0)
          {
            PlaneFeatureItemType * typ;
            if ((typ = dynamic_cast<PlaneFeatureItemType *>(basie)))
              {
                fprintf(outFile, "<PlaneFeatureItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PlaneFeatureItem>\n");
              }
            else
              {
                fprintf(stderr, "bad PlaneFeatureItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PointDefinedCurveFeatureItem") == 0)
          {
            PointDefinedCurveFeatureItemType * typ;
            if ((typ = dynamic_cast<PointDefinedCurveFeatureItemType *>(basie)))
              {
                fprintf(outFile, "<PointDefinedCurveFeatureItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PointDefinedCurveFeatureItem>\n");
              }
            else
              {
                fprintf(stderr, "bad PointDefinedCurveFeatureItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PointDefinedSurfaceFeatureItem") == 0)
          {
            PointDefinedSurfaceFeatureItemType * typ;
            if ((typ = dynamic_cast<PointDefinedSurfaceFeatureItemType *>(basie)))
              {
                fprintf(outFile, "<PointDefinedSurfaceFeatureItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PointDefinedSurfaceFeatureItem>\n");
              }
            else
              {
                fprintf(stderr, "bad PointDefinedSurfaceFeatureItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PointFeatureItem") == 0)
          {
            PointFeatureItemType * typ;
            if ((typ = dynamic_cast<PointFeatureItemType *>(basie)))
              {
                fprintf(outFile, "<PointFeatureItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PointFeatureItem>\n");
              }
            else
              {
                fprintf(stderr, "bad PointFeatureItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SphereFeatureItem") == 0)
          {
            SphereFeatureItemType * typ;
            if ((typ = dynamic_cast<SphereFeatureItemType *>(basie)))
              {
                fprintf(outFile, "<SphereFeatureItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphereFeatureItem>\n");
              }
            else
              {
                fprintf(stderr, "bad SphereFeatureItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SphericalSegmentFeatureItem") == 0)
          {
            SphericalSegmentFeatureItemType * typ;
            if ((typ = dynamic_cast<SphericalSegmentFeatureItemType *>(basie)))
              {
                fprintf(outFile, "<SphericalSegmentFeatureItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalSegmentFeatureItem>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalSegmentFeatureItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SurfaceOfRevolutionFeatureItem") == 0)
          {
            SurfaceOfRevolutionFeatureItemType * typ;
            if ((typ = dynamic_cast<SurfaceOfRevolutionFeatureItemType *>(basie)))
              {
                fprintf(outFile, "<SurfaceOfRevolutionFeatureItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SurfaceOfRevolutionFeatureItem>\n");
              }
            else
              {
                fprintf(stderr, "bad SurfaceOfRevolutionFeatureItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ThreadedFeatureItem") == 0)
          {
            ThreadedFeatureItemType * typ;
            if ((typ = dynamic_cast<ThreadedFeatureItemType *>(basie)))
              {
                fprintf(outFile, "<ThreadedFeatureItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ThreadedFeatureItem>\n");
              }
            else
              {
                fprintf(stderr, "bad ThreadedFeatureItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ToroidalSegmentFeatureItem") == 0)
          {
            ToroidalSegmentFeatureItemType * typ;
            if ((typ = dynamic_cast<ToroidalSegmentFeatureItemType *>(basie)))
              {
                fprintf(outFile, "<ToroidalSegmentFeatureItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ToroidalSegmentFeatureItem>\n");
              }
            else
              {
                fprintf(stderr, "bad ToroidalSegmentFeatureItem element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "TorusFeatureItem") == 0)
          {
            TorusFeatureItemType * typ;
            if ((typ = dynamic_cast<TorusFeatureItemType *>(basie)))
              {
                fprintf(outFile, "<TorusFeatureItem");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TorusFeatureItem>\n");
              }
            else
              {
                fprintf(stderr, "bad TorusFeatureItem element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad FeatureItem type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool FeatureItemsType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in FeatureItemsType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in FeatureItemsType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FeatureItemsType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in FeatureItemsType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * FeatureItemsType::getn()
{return n;}

void FeatureItemsType::setn(NaturalType * nIn)
{n = nIn;}

FeatureItemBaseTypeLisd * FeatureItemsType::getFeatureItem()
{return FeatureItem;}

void FeatureItemsType::setFeatureItem(FeatureItemBaseTypeLisd * FeatureItemIn)
{FeatureItem = FeatureItemIn;}

/* ***************************************************************** */

/* class FeatureMeasurementBaseType

*/

FeatureMeasurementBaseType::FeatureMeasurementBaseType() :
  FeatureBaseType()
{
  FeatureItemId = 0;
  FeatureName = 0;
  TimeStamp = 0;
  ActualComponentId = 0;
  ManufacturingProcessId = 0;
  MeasurementDeviceIds = 0;
  ActualTransformId = 0;
  NotedEventIds = 0;
}

FeatureMeasurementBaseType::FeatureMeasurementBaseType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn) :
  FeatureBaseType(
    AttributesIn)
{
  FeatureItemId = FeatureItemIdIn;
  FeatureName = FeatureNameIn;
  TimeStamp = TimeStampIn;
  ActualComponentId = ActualComponentIdIn;
  ManufacturingProcessId = ManufacturingProcessIdIn;
  MeasurementDeviceIds = MeasurementDeviceIdsIn;
  ActualTransformId = ActualTransformIdIn;
  NotedEventIds = NotedEventIdsIn;
}

FeatureMeasurementBaseType::FeatureMeasurementBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn) :
  FeatureBaseType(
    idIn,
    AttributesIn)
{
  FeatureItemId = FeatureItemIdIn;
  FeatureName = FeatureNameIn;
  TimeStamp = TimeStampIn;
  ActualComponentId = ActualComponentIdIn;
  ManufacturingProcessId = ManufacturingProcessIdIn;
  MeasurementDeviceIds = MeasurementDeviceIdsIn;
  ActualTransformId = ActualTransformIdIn;
  NotedEventIds = NotedEventIdsIn;
}

FeatureMeasurementBaseType::~FeatureMeasurementBaseType()
{
  #ifndef NODESTRUCT
  delete FeatureItemId;
  delete FeatureName;
  delete TimeStamp;
  delete ActualComponentId;
  delete ManufacturingProcessId;
  delete MeasurementDeviceIds;
  delete ActualTransformId;
  delete NotedEventIds;
  #endif
}

void FeatureMeasurementBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool FeatureMeasurementBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in FeatureMeasurementBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in FeatureMeasurementBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FeatureMeasurementBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in FeatureMeasurementBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

QIFReferenceType * FeatureMeasurementBaseType::getFeatureItemId()
{return FeatureItemId;}

void FeatureMeasurementBaseType::setFeatureItemId(QIFReferenceType * FeatureItemIdIn)
{FeatureItemId = FeatureItemIdIn;}

XmlToken * FeatureMeasurementBaseType::getFeatureName()
{return FeatureName;}

void FeatureMeasurementBaseType::setFeatureName(XmlToken * FeatureNameIn)
{FeatureName = FeatureNameIn;}

XmlDateTime * FeatureMeasurementBaseType::getTimeStamp()
{return TimeStamp;}

void FeatureMeasurementBaseType::setTimeStamp(XmlDateTime * TimeStampIn)
{TimeStamp = TimeStampIn;}

QIFReferenceFullType * FeatureMeasurementBaseType::getActualComponentId()
{return ActualComponentId;}

void FeatureMeasurementBaseType::setActualComponentId(QIFReferenceFullType * ActualComponentIdIn)
{ActualComponentId = ActualComponentIdIn;}

QIFReferenceFullType * FeatureMeasurementBaseType::getManufacturingProcessId()
{return ManufacturingProcessId;}

void FeatureMeasurementBaseType::setManufacturingProcessId(QIFReferenceFullType * ManufacturingProcessIdIn)
{ManufacturingProcessId = ManufacturingProcessIdIn;}

ArrayReferenceFullType * FeatureMeasurementBaseType::getMeasurementDeviceIds()
{return MeasurementDeviceIds;}

void FeatureMeasurementBaseType::setMeasurementDeviceIds(ArrayReferenceFullType * MeasurementDeviceIdsIn)
{MeasurementDeviceIds = MeasurementDeviceIdsIn;}

QIFReferenceType * FeatureMeasurementBaseType::getActualTransformId()
{return ActualTransformId;}

void FeatureMeasurementBaseType::setActualTransformId(QIFReferenceType * ActualTransformIdIn)
{ActualTransformId = ActualTransformIdIn;}

ArrayReferenceFullType * FeatureMeasurementBaseType::getNotedEventIds()
{return NotedEventIds;}

void FeatureMeasurementBaseType::setNotedEventIds(ArrayReferenceFullType * NotedEventIdsIn)
{NotedEventIds = NotedEventIdsIn;}

/* ***************************************************************** */

/* class FeatureMeasurementBaseTypeLisd

*/

FeatureMeasurementBaseTypeLisd::FeatureMeasurementBaseTypeLisd() {}

FeatureMeasurementBaseTypeLisd::FeatureMeasurementBaseTypeLisd(FeatureMeasurementBaseType * aFeatureMeasurementBaseType)
{
  push_back(aFeatureMeasurementBaseType);
}

FeatureMeasurementBaseTypeLisd::~FeatureMeasurementBaseTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<FeatureMeasurementBaseType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void FeatureMeasurementBaseTypeLisd::printSelf(FILE * outFile)
{
  std::list<FeatureMeasurementBaseType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class FeatureMeasurementsType

*/

FeatureMeasurementsType::FeatureMeasurementsType()
{
  n = 0;
  FeatureMeasurement = 0;
}

FeatureMeasurementsType::FeatureMeasurementsType(
 FeatureMeasurementBaseTypeLisd * FeatureMeasurementIn)
{
  n = 0;
  FeatureMeasurement = FeatureMeasurementIn;
}

FeatureMeasurementsType::FeatureMeasurementsType(
 NaturalType * nIn,
 FeatureMeasurementBaseTypeLisd * FeatureMeasurementIn)
{
  n = nIn;
  FeatureMeasurement = FeatureMeasurementIn;
}

FeatureMeasurementsType::~FeatureMeasurementsType()
{
  #ifndef NODESTRUCT
  delete n;
  delete FeatureMeasurement;
  #endif
}

void FeatureMeasurementsType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!FeatureMeasurement)
      {
        fprintf(stderr, "FeatureMeasurement list is missing\n");
        exit(1);
      }
    if (FeatureMeasurement->size() == 0)
      {
        fprintf(stderr, "FeatureMeasurement list is empty\n");
        exit(1);
      }
    if (FeatureMeasurement->size() < 1)
      {
        fprintf(stderr,
                "size of FeatureMeasurement list (%d) less than minimum required (1)\n",
                (int)FeatureMeasurement->size());
        exit(1);
      }
    std::list<FeatureMeasurementBaseType *>::iterator iter;
    for (iter = FeatureMeasurement->begin();
         iter != FeatureMeasurement->end(); iter++)
      {
        FeatureMeasurementBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->getprintElement(), "CircleFeatureMeasurement") == 0)
          {
            CircleFeatureMeasurementType * typ;
            if ((typ = dynamic_cast<CircleFeatureMeasurementType *>(basie)))
              {
                fprintf(outFile, "<CircleFeatureMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CircleFeatureMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad CircleFeatureMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CircularArcFeatureMeasurement") == 0)
          {
            CircularArcFeatureMeasurementType * typ;
            if ((typ = dynamic_cast<CircularArcFeatureMeasurementType *>(basie)))
              {
                fprintf(outFile, "<CircularArcFeatureMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CircularArcFeatureMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad CircularArcFeatureMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ConeFeatureMeasurement") == 0)
          {
            ConeFeatureMeasurementType * typ;
            if ((typ = dynamic_cast<ConeFeatureMeasurementType *>(basie)))
              {
                fprintf(outFile, "<ConeFeatureMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ConeFeatureMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad ConeFeatureMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ConicalSegmentFeatureMeasurement") == 0)
          {
            ConicalSegmentFeatureMeasurementType * typ;
            if ((typ = dynamic_cast<ConicalSegmentFeatureMeasurementType *>(basie)))
              {
                fprintf(outFile, "<ConicalSegmentFeatureMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ConicalSegmentFeatureMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad ConicalSegmentFeatureMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CylinderFeatureMeasurement") == 0)
          {
            CylinderFeatureMeasurementType * typ;
            if ((typ = dynamic_cast<CylinderFeatureMeasurementType *>(basie)))
              {
                fprintf(outFile, "<CylinderFeatureMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CylinderFeatureMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad CylinderFeatureMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CylindricalSegmentFeatureMeasurement") == 0)
          {
            CylindricalSegmentFeatureMeasurementType * typ;
            if ((typ = dynamic_cast<CylindricalSegmentFeatureMeasurementType *>(basie)))
              {
                fprintf(outFile, "<CylindricalSegmentFeatureMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CylindricalSegmentFeatureMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad CylindricalSegmentFeatureMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "EdgePointFeatureMeasurement") == 0)
          {
            EdgePointFeatureMeasurementType * typ;
            if ((typ = dynamic_cast<EdgePointFeatureMeasurementType *>(basie)))
              {
                fprintf(outFile, "<EdgePointFeatureMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EdgePointFeatureMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad EdgePointFeatureMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "EllipseFeatureMeasurement") == 0)
          {
            EllipseFeatureMeasurementType * typ;
            if ((typ = dynamic_cast<EllipseFeatureMeasurementType *>(basie)))
              {
                fprintf(outFile, "<EllipseFeatureMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EllipseFeatureMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad EllipseFeatureMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "EllipticalArcFeatureMeasurement") == 0)
          {
            EllipticalArcFeatureMeasurementType * typ;
            if ((typ = dynamic_cast<EllipticalArcFeatureMeasurementType *>(basie)))
              {
                fprintf(outFile, "<EllipticalArcFeatureMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EllipticalArcFeatureMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad EllipticalArcFeatureMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ElongatedCircleFeatureMeasurement") == 0)
          {
            ElongatedCircleFeatureMeasurementType * typ;
            if ((typ = dynamic_cast<ElongatedCircleFeatureMeasurementType *>(basie)))
              {
                fprintf(outFile, "<ElongatedCircleFeatureMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ElongatedCircleFeatureMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad ElongatedCircleFeatureMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ElongatedCylinderFeatureMeasurement") == 0)
          {
            ElongatedCylinderFeatureMeasurementType * typ;
            if ((typ = dynamic_cast<ElongatedCylinderFeatureMeasurementType *>(basie)))
              {
                fprintf(outFile, "<ElongatedCylinderFeatureMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ElongatedCylinderFeatureMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad ElongatedCylinderFeatureMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ExtrudedCrossSectionFeatureMeasurement") == 0)
          {
            ExtrudedCrossSectionFeatureMeasurementType * typ;
            if ((typ = dynamic_cast<ExtrudedCrossSectionFeatureMeasurementType *>(basie)))
              {
                fprintf(outFile, "<ExtrudedCrossSectionFeatureMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ExtrudedCrossSectionFeatureMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad ExtrudedCrossSectionFeatureMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "GroupFeatureMeasurement") == 0)
          {
            GroupFeatureMeasurementType * typ;
            if ((typ = dynamic_cast<GroupFeatureMeasurementType *>(basie)))
              {
                fprintf(outFile, "<GroupFeatureMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GroupFeatureMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad GroupFeatureMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "LineFeatureMeasurement") == 0)
          {
            LineFeatureMeasurementType * typ;
            if ((typ = dynamic_cast<LineFeatureMeasurementType *>(basie)))
              {
                fprintf(outFile, "<LineFeatureMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LineFeatureMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad LineFeatureMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "MarkingFeatureMeasurement") == 0)
          {
            MarkingFeatureMeasurementType * typ;
            if ((typ = dynamic_cast<MarkingFeatureMeasurementType *>(basie)))
              {
                fprintf(outFile, "<MarkingFeatureMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</MarkingFeatureMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad MarkingFeatureMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OppositeAngledLinesFeatureMeasurement") == 0)
          {
            OppositeAngledLinesFeatureMeasurementType * typ;
            if ((typ = dynamic_cast<OppositeAngledLinesFeatureMeasurementType *>(basie)))
              {
                fprintf(outFile, "<OppositeAngledLinesFeatureMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OppositeAngledLinesFeatureMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad OppositeAngledLinesFeatureMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OppositeAngledPlanesFeatureMeasurement") == 0)
          {
            OppositeAngledPlanesFeatureMeasurementType * typ;
            if ((typ = dynamic_cast<OppositeAngledPlanesFeatureMeasurementType *>(basie)))
              {
                fprintf(outFile, "<OppositeAngledPlanesFeatureMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OppositeAngledPlanesFeatureMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad OppositeAngledPlanesFeatureMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OppositeParallelLinesFeatureMeasurement") == 0)
          {
            OppositeParallelLinesFeatureMeasurementType * typ;
            if ((typ = dynamic_cast<OppositeParallelLinesFeatureMeasurementType *>(basie)))
              {
                fprintf(outFile, "<OppositeParallelLinesFeatureMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OppositeParallelLinesFeatureMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad OppositeParallelLinesFeatureMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OppositeParallelPlanesFeatureMeasurement") == 0)
          {
            OppositeParallelPlanesFeatureMeasurementType * typ;
            if ((typ = dynamic_cast<OppositeParallelPlanesFeatureMeasurementType *>(basie)))
              {
                fprintf(outFile, "<OppositeParallelPlanesFeatureMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OppositeParallelPlanesFeatureMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad OppositeParallelPlanesFeatureMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OtherCurveFeatureMeasurement") == 0)
          {
            OtherCurveFeatureMeasurementType * typ;
            if ((typ = dynamic_cast<OtherCurveFeatureMeasurementType *>(basie)))
              {
                fprintf(outFile, "<OtherCurveFeatureMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OtherCurveFeatureMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad OtherCurveFeatureMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OtherNonShapeFeatureMeasurement") == 0)
          {
            OtherNonShapeFeatureMeasurementType * typ;
            if ((typ = dynamic_cast<OtherNonShapeFeatureMeasurementType *>(basie)))
              {
                fprintf(outFile, "<OtherNonShapeFeatureMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OtherNonShapeFeatureMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad OtherNonShapeFeatureMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OtherShapeFeatureMeasurement") == 0)
          {
            OtherShapeFeatureMeasurementType * typ;
            if ((typ = dynamic_cast<OtherShapeFeatureMeasurementType *>(basie)))
              {
                fprintf(outFile, "<OtherShapeFeatureMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OtherShapeFeatureMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad OtherShapeFeatureMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OtherSurfaceFeatureMeasurement") == 0)
          {
            OtherSurfaceFeatureMeasurementType * typ;
            if ((typ = dynamic_cast<OtherSurfaceFeatureMeasurementType *>(basie)))
              {
                fprintf(outFile, "<OtherSurfaceFeatureMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OtherSurfaceFeatureMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad OtherSurfaceFeatureMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PlaneFeatureMeasurement") == 0)
          {
            PlaneFeatureMeasurementType * typ;
            if ((typ = dynamic_cast<PlaneFeatureMeasurementType *>(basie)))
              {
                fprintf(outFile, "<PlaneFeatureMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PlaneFeatureMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad PlaneFeatureMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PointDefinedCurveFeatureMeasurement") == 0)
          {
            PointDefinedCurveFeatureMeasurementType * typ;
            if ((typ = dynamic_cast<PointDefinedCurveFeatureMeasurementType *>(basie)))
              {
                fprintf(outFile, "<PointDefinedCurveFeatureMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PointDefinedCurveFeatureMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad PointDefinedCurveFeatureMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PointDefinedSurfaceFeatureMeasurement") == 0)
          {
            PointDefinedSurfaceFeatureMeasurementType * typ;
            if ((typ = dynamic_cast<PointDefinedSurfaceFeatureMeasurementType *>(basie)))
              {
                fprintf(outFile, "<PointDefinedSurfaceFeatureMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PointDefinedSurfaceFeatureMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad PointDefinedSurfaceFeatureMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PointFeatureMeasurement") == 0)
          {
            PointFeatureMeasurementType * typ;
            if ((typ = dynamic_cast<PointFeatureMeasurementType *>(basie)))
              {
                fprintf(outFile, "<PointFeatureMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PointFeatureMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad PointFeatureMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SphereFeatureMeasurement") == 0)
          {
            SphereFeatureMeasurementType * typ;
            if ((typ = dynamic_cast<SphereFeatureMeasurementType *>(basie)))
              {
                fprintf(outFile, "<SphereFeatureMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphereFeatureMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad SphereFeatureMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SphericalSegmentFeatureMeasurement") == 0)
          {
            SphericalSegmentFeatureMeasurementType * typ;
            if ((typ = dynamic_cast<SphericalSegmentFeatureMeasurementType *>(basie)))
              {
                fprintf(outFile, "<SphericalSegmentFeatureMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalSegmentFeatureMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalSegmentFeatureMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SurfaceOfRevolutionFeatureMeasurement") == 0)
          {
            SurfaceOfRevolutionFeatureMeasurementType * typ;
            if ((typ = dynamic_cast<SurfaceOfRevolutionFeatureMeasurementType *>(basie)))
              {
                fprintf(outFile, "<SurfaceOfRevolutionFeatureMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SurfaceOfRevolutionFeatureMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad SurfaceOfRevolutionFeatureMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ThreadedFeatureMeasurement") == 0)
          {
            ThreadedFeatureMeasurementType * typ;
            if ((typ = dynamic_cast<ThreadedFeatureMeasurementType *>(basie)))
              {
                fprintf(outFile, "<ThreadedFeatureMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ThreadedFeatureMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad ThreadedFeatureMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ToroidalSegmentFeatureMeasurement") == 0)
          {
            ToroidalSegmentFeatureMeasurementType * typ;
            if ((typ = dynamic_cast<ToroidalSegmentFeatureMeasurementType *>(basie)))
              {
                fprintf(outFile, "<ToroidalSegmentFeatureMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ToroidalSegmentFeatureMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad ToroidalSegmentFeatureMeasurement element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "TorusFeatureMeasurement") == 0)
          {
            TorusFeatureMeasurementType * typ;
            if ((typ = dynamic_cast<TorusFeatureMeasurementType *>(basie)))
              {
                fprintf(outFile, "<TorusFeatureMeasurement");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TorusFeatureMeasurement>\n");
              }
            else
              {
                fprintf(stderr, "bad TorusFeatureMeasurement element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad FeatureMeasurement type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool FeatureMeasurementsType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in FeatureMeasurementsType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in FeatureMeasurementsType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FeatureMeasurementsType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in FeatureMeasurementsType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * FeatureMeasurementsType::getn()
{return n;}

void FeatureMeasurementsType::setn(NaturalType * nIn)
{n = nIn;}

FeatureMeasurementBaseTypeLisd * FeatureMeasurementsType::getFeatureMeasurement()
{return FeatureMeasurement;}

void FeatureMeasurementsType::setFeatureMeasurement(FeatureMeasurementBaseTypeLisd * FeatureMeasurementIn)
{FeatureMeasurement = FeatureMeasurementIn;}

/* ***************************************************************** */

/* class FeatureNominalBaseType

*/

FeatureNominalBaseType::FeatureNominalBaseType() :
  FeatureBaseType()
{
  Name = 0;
  UUID = 0;
  FeatureDefinitionId = 0;
  ParentFeatureNominalId = 0;
  EntityInternalIds = 0;
  EntityExternalIds = 0;
}

FeatureNominalBaseType::FeatureNominalBaseType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn) :
  FeatureBaseType(
    AttributesIn)
{
  Name = NameIn;
  UUID = UUIDIn;
  FeatureDefinitionId = FeatureDefinitionIdIn;
  ParentFeatureNominalId = ParentFeatureNominalIdIn;
  EntityInternalIds = EntityInternalIdsIn;
  EntityExternalIds = EntityExternalIdsIn;
}

FeatureNominalBaseType::FeatureNominalBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn) :
  FeatureBaseType(
    idIn,
    AttributesIn)
{
  Name = NameIn;
  UUID = UUIDIn;
  FeatureDefinitionId = FeatureDefinitionIdIn;
  ParentFeatureNominalId = ParentFeatureNominalIdIn;
  EntityInternalIds = EntityInternalIdsIn;
  EntityExternalIds = EntityExternalIdsIn;
}

FeatureNominalBaseType::~FeatureNominalBaseType()
{
  #ifndef NODESTRUCT
  delete Name;
  delete UUID;
  delete FeatureDefinitionId;
  delete ParentFeatureNominalId;
  delete EntityInternalIds;
  delete EntityExternalIds;
  #endif
}

void FeatureNominalBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool FeatureNominalBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in FeatureNominalBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in FeatureNominalBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FeatureNominalBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in FeatureNominalBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

XmlToken * FeatureNominalBaseType::getName()
{return Name;}

void FeatureNominalBaseType::setName(XmlToken * NameIn)
{Name = NameIn;}

QPIdType * FeatureNominalBaseType::getUUID()
{return UUID;}

void FeatureNominalBaseType::setUUID(QPIdType * UUIDIn)
{UUID = UUIDIn;}

QIFReferenceType * FeatureNominalBaseType::getFeatureDefinitionId()
{return FeatureDefinitionId;}

void FeatureNominalBaseType::setFeatureDefinitionId(QIFReferenceType * FeatureDefinitionIdIn)
{FeatureDefinitionId = FeatureDefinitionIdIn;}

QIFReferenceType * FeatureNominalBaseType::getParentFeatureNominalId()
{return ParentFeatureNominalId;}

void FeatureNominalBaseType::setParentFeatureNominalId(QIFReferenceType * ParentFeatureNominalIdIn)
{ParentFeatureNominalId = ParentFeatureNominalIdIn;}

ArrayReferenceFullType * FeatureNominalBaseType::getEntityInternalIds()
{return EntityInternalIds;}

void FeatureNominalBaseType::setEntityInternalIds(ArrayReferenceFullType * EntityInternalIdsIn)
{EntityInternalIds = EntityInternalIdsIn;}

ArrayReferenceFullType * FeatureNominalBaseType::getEntityExternalIds()
{return EntityExternalIds;}

void FeatureNominalBaseType::setEntityExternalIds(ArrayReferenceFullType * EntityExternalIdsIn)
{EntityExternalIds = EntityExternalIdsIn;}

/* ***************************************************************** */

/* class FeatureNominalBaseTypeLisd

*/

FeatureNominalBaseTypeLisd::FeatureNominalBaseTypeLisd() {}

FeatureNominalBaseTypeLisd::FeatureNominalBaseTypeLisd(FeatureNominalBaseType * aFeatureNominalBaseType)
{
  push_back(aFeatureNominalBaseType);
}

FeatureNominalBaseTypeLisd::~FeatureNominalBaseTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<FeatureNominalBaseType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void FeatureNominalBaseTypeLisd::printSelf(FILE * outFile)
{
  std::list<FeatureNominalBaseType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class FeatureNominalsType

*/

FeatureNominalsType::FeatureNominalsType()
{
  n = 0;
  FeatureNominal = 0;
}

FeatureNominalsType::FeatureNominalsType(
 FeatureNominalBaseTypeLisd * FeatureNominalIn)
{
  n = 0;
  FeatureNominal = FeatureNominalIn;
}

FeatureNominalsType::FeatureNominalsType(
 NaturalType * nIn,
 FeatureNominalBaseTypeLisd * FeatureNominalIn)
{
  n = nIn;
  FeatureNominal = FeatureNominalIn;
}

FeatureNominalsType::~FeatureNominalsType()
{
  #ifndef NODESTRUCT
  delete n;
  delete FeatureNominal;
  #endif
}

void FeatureNominalsType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!FeatureNominal)
      {
        fprintf(stderr, "FeatureNominal list is missing\n");
        exit(1);
      }
    if (FeatureNominal->size() == 0)
      {
        fprintf(stderr, "FeatureNominal list is empty\n");
        exit(1);
      }
    if (FeatureNominal->size() < 1)
      {
        fprintf(stderr,
                "size of FeatureNominal list (%d) less than minimum required (1)\n",
                (int)FeatureNominal->size());
        exit(1);
      }
    std::list<FeatureNominalBaseType *>::iterator iter;
    for (iter = FeatureNominal->begin();
         iter != FeatureNominal->end(); iter++)
      {
        FeatureNominalBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->getprintElement(), "CircleFeatureNominal") == 0)
          {
            CircleFeatureNominalType * typ;
            if ((typ = dynamic_cast<CircleFeatureNominalType *>(basie)))
              {
                fprintf(outFile, "<CircleFeatureNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CircleFeatureNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad CircleFeatureNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CircularArcFeatureNominal") == 0)
          {
            CircularArcFeatureNominalType * typ;
            if ((typ = dynamic_cast<CircularArcFeatureNominalType *>(basie)))
              {
                fprintf(outFile, "<CircularArcFeatureNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CircularArcFeatureNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad CircularArcFeatureNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ConeFeatureNominal") == 0)
          {
            ConeFeatureNominalType * typ;
            if ((typ = dynamic_cast<ConeFeatureNominalType *>(basie)))
              {
                fprintf(outFile, "<ConeFeatureNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ConeFeatureNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad ConeFeatureNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ConicalSegmentFeatureNominal") == 0)
          {
            ConicalSegmentFeatureNominalType * typ;
            if ((typ = dynamic_cast<ConicalSegmentFeatureNominalType *>(basie)))
              {
                fprintf(outFile, "<ConicalSegmentFeatureNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ConicalSegmentFeatureNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad ConicalSegmentFeatureNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CylinderFeatureNominal") == 0)
          {
            CylinderFeatureNominalType * typ;
            if ((typ = dynamic_cast<CylinderFeatureNominalType *>(basie)))
              {
                fprintf(outFile, "<CylinderFeatureNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CylinderFeatureNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad CylinderFeatureNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CylindricalSegmentFeatureNominal") == 0)
          {
            CylindricalSegmentFeatureNominalType * typ;
            if ((typ = dynamic_cast<CylindricalSegmentFeatureNominalType *>(basie)))
              {
                fprintf(outFile, "<CylindricalSegmentFeatureNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CylindricalSegmentFeatureNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad CylindricalSegmentFeatureNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "EdgePointFeatureNominal") == 0)
          {
            EdgePointFeatureNominalType * typ;
            if ((typ = dynamic_cast<EdgePointFeatureNominalType *>(basie)))
              {
                fprintf(outFile, "<EdgePointFeatureNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EdgePointFeatureNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad EdgePointFeatureNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "EllipseFeatureNominal") == 0)
          {
            EllipseFeatureNominalType * typ;
            if ((typ = dynamic_cast<EllipseFeatureNominalType *>(basie)))
              {
                fprintf(outFile, "<EllipseFeatureNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EllipseFeatureNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad EllipseFeatureNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "EllipticalArcFeatureNominal") == 0)
          {
            EllipticalArcFeatureNominalType * typ;
            if ((typ = dynamic_cast<EllipticalArcFeatureNominalType *>(basie)))
              {
                fprintf(outFile, "<EllipticalArcFeatureNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EllipticalArcFeatureNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad EllipticalArcFeatureNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ElongatedCircleFeatureNominal") == 0)
          {
            ElongatedCircleFeatureNominalType * typ;
            if ((typ = dynamic_cast<ElongatedCircleFeatureNominalType *>(basie)))
              {
                fprintf(outFile, "<ElongatedCircleFeatureNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ElongatedCircleFeatureNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad ElongatedCircleFeatureNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ElongatedCylinderFeatureNominal") == 0)
          {
            ElongatedCylinderFeatureNominalType * typ;
            if ((typ = dynamic_cast<ElongatedCylinderFeatureNominalType *>(basie)))
              {
                fprintf(outFile, "<ElongatedCylinderFeatureNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ElongatedCylinderFeatureNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad ElongatedCylinderFeatureNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ExtrudedCrossSectionFeatureNominal") == 0)
          {
            ExtrudedCrossSectionFeatureNominalType * typ;
            if ((typ = dynamic_cast<ExtrudedCrossSectionFeatureNominalType *>(basie)))
              {
                fprintf(outFile, "<ExtrudedCrossSectionFeatureNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ExtrudedCrossSectionFeatureNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad ExtrudedCrossSectionFeatureNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "GroupFeatureNominal") == 0)
          {
            GroupFeatureNominalType * typ;
            if ((typ = dynamic_cast<GroupFeatureNominalType *>(basie)))
              {
                fprintf(outFile, "<GroupFeatureNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GroupFeatureNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad GroupFeatureNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "LineFeatureNominal") == 0)
          {
            LineFeatureNominalType * typ;
            if ((typ = dynamic_cast<LineFeatureNominalType *>(basie)))
              {
                fprintf(outFile, "<LineFeatureNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LineFeatureNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad LineFeatureNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "MarkingFeatureNominal") == 0)
          {
            MarkingFeatureNominalType * typ;
            if ((typ = dynamic_cast<MarkingFeatureNominalType *>(basie)))
              {
                fprintf(outFile, "<MarkingFeatureNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</MarkingFeatureNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad MarkingFeatureNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OppositeAngledLinesFeatureNominal") == 0)
          {
            OppositeAngledLinesFeatureNominalType * typ;
            if ((typ = dynamic_cast<OppositeAngledLinesFeatureNominalType *>(basie)))
              {
                fprintf(outFile, "<OppositeAngledLinesFeatureNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OppositeAngledLinesFeatureNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad OppositeAngledLinesFeatureNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OppositeAngledPlanesFeatureNominal") == 0)
          {
            OppositeAngledPlanesFeatureNominalType * typ;
            if ((typ = dynamic_cast<OppositeAngledPlanesFeatureNominalType *>(basie)))
              {
                fprintf(outFile, "<OppositeAngledPlanesFeatureNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OppositeAngledPlanesFeatureNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad OppositeAngledPlanesFeatureNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OppositeParallelLinesFeatureNominal") == 0)
          {
            OppositeParallelLinesFeatureNominalType * typ;
            if ((typ = dynamic_cast<OppositeParallelLinesFeatureNominalType *>(basie)))
              {
                fprintf(outFile, "<OppositeParallelLinesFeatureNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OppositeParallelLinesFeatureNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad OppositeParallelLinesFeatureNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OppositeParallelPlanesFeatureNominal") == 0)
          {
            OppositeParallelPlanesFeatureNominalType * typ;
            if ((typ = dynamic_cast<OppositeParallelPlanesFeatureNominalType *>(basie)))
              {
                fprintf(outFile, "<OppositeParallelPlanesFeatureNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OppositeParallelPlanesFeatureNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad OppositeParallelPlanesFeatureNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OtherCurveFeatureNominal") == 0)
          {
            OtherCurveFeatureNominalType * typ;
            if ((typ = dynamic_cast<OtherCurveFeatureNominalType *>(basie)))
              {
                fprintf(outFile, "<OtherCurveFeatureNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OtherCurveFeatureNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad OtherCurveFeatureNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OtherNonShapeFeatureNominal") == 0)
          {
            OtherNonShapeFeatureNominalType * typ;
            if ((typ = dynamic_cast<OtherNonShapeFeatureNominalType *>(basie)))
              {
                fprintf(outFile, "<OtherNonShapeFeatureNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OtherNonShapeFeatureNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad OtherNonShapeFeatureNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OtherShapeFeatureNominal") == 0)
          {
            OtherShapeFeatureNominalType * typ;
            if ((typ = dynamic_cast<OtherShapeFeatureNominalType *>(basie)))
              {
                fprintf(outFile, "<OtherShapeFeatureNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OtherShapeFeatureNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad OtherShapeFeatureNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OtherSurfaceFeatureNominal") == 0)
          {
            OtherSurfaceFeatureNominalType * typ;
            if ((typ = dynamic_cast<OtherSurfaceFeatureNominalType *>(basie)))
              {
                fprintf(outFile, "<OtherSurfaceFeatureNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OtherSurfaceFeatureNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad OtherSurfaceFeatureNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PatternFeatureCircleNominal") == 0)
          {
            PatternFeatureCircleNominalType * typ;
            if ((typ = dynamic_cast<PatternFeatureCircleNominalType *>(basie)))
              {
                fprintf(outFile, "<PatternFeatureCircleNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PatternFeatureCircleNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad PatternFeatureCircleNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PatternFeatureCircularArcNominal") == 0)
          {
            PatternFeatureCircularArcNominalType * typ;
            if ((typ = dynamic_cast<PatternFeatureCircularArcNominalType *>(basie)))
              {
                fprintf(outFile, "<PatternFeatureCircularArcNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PatternFeatureCircularArcNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad PatternFeatureCircularArcNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PatternFeatureLinearNominal") == 0)
          {
            PatternFeatureLinearNominalType * typ;
            if ((typ = dynamic_cast<PatternFeatureLinearNominalType *>(basie)))
              {
                fprintf(outFile, "<PatternFeatureLinearNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PatternFeatureLinearNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad PatternFeatureLinearNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PatternFeatureParallelogramNominal") == 0)
          {
            PatternFeatureParallelogramNominalType * typ;
            if ((typ = dynamic_cast<PatternFeatureParallelogramNominalType *>(basie)))
              {
                fprintf(outFile, "<PatternFeatureParallelogramNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PatternFeatureParallelogramNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad PatternFeatureParallelogramNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PlaneFeatureNominal") == 0)
          {
            PlaneFeatureNominalType * typ;
            if ((typ = dynamic_cast<PlaneFeatureNominalType *>(basie)))
              {
                fprintf(outFile, "<PlaneFeatureNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PlaneFeatureNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad PlaneFeatureNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PointDefinedCurveFeatureNominal") == 0)
          {
            PointDefinedCurveFeatureNominalType * typ;
            if ((typ = dynamic_cast<PointDefinedCurveFeatureNominalType *>(basie)))
              {
                fprintf(outFile, "<PointDefinedCurveFeatureNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PointDefinedCurveFeatureNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad PointDefinedCurveFeatureNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PointDefinedSurfaceFeatureNominal") == 0)
          {
            PointDefinedSurfaceFeatureNominalType * typ;
            if ((typ = dynamic_cast<PointDefinedSurfaceFeatureNominalType *>(basie)))
              {
                fprintf(outFile, "<PointDefinedSurfaceFeatureNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PointDefinedSurfaceFeatureNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad PointDefinedSurfaceFeatureNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "PointFeatureNominal") == 0)
          {
            PointFeatureNominalType * typ;
            if ((typ = dynamic_cast<PointFeatureNominalType *>(basie)))
              {
                fprintf(outFile, "<PointFeatureNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PointFeatureNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad PointFeatureNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SphereFeatureNominal") == 0)
          {
            SphereFeatureNominalType * typ;
            if ((typ = dynamic_cast<SphereFeatureNominalType *>(basie)))
              {
                fprintf(outFile, "<SphereFeatureNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphereFeatureNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad SphereFeatureNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SphericalSegmentFeatureNominal") == 0)
          {
            SphericalSegmentFeatureNominalType * typ;
            if ((typ = dynamic_cast<SphericalSegmentFeatureNominalType *>(basie)))
              {
                fprintf(outFile, "<SphericalSegmentFeatureNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalSegmentFeatureNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalSegmentFeatureNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SurfaceOfRevolutionFeatureNominal") == 0)
          {
            SurfaceOfRevolutionFeatureNominalType * typ;
            if ((typ = dynamic_cast<SurfaceOfRevolutionFeatureNominalType *>(basie)))
              {
                fprintf(outFile, "<SurfaceOfRevolutionFeatureNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SurfaceOfRevolutionFeatureNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad SurfaceOfRevolutionFeatureNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ThreadedFeatureNominal") == 0)
          {
            ThreadedFeatureNominalType * typ;
            if ((typ = dynamic_cast<ThreadedFeatureNominalType *>(basie)))
              {
                fprintf(outFile, "<ThreadedFeatureNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ThreadedFeatureNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad ThreadedFeatureNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ToroidalSegmentFeatureNominal") == 0)
          {
            ToroidalSegmentFeatureNominalType * typ;
            if ((typ = dynamic_cast<ToroidalSegmentFeatureNominalType *>(basie)))
              {
                fprintf(outFile, "<ToroidalSegmentFeatureNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ToroidalSegmentFeatureNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad ToroidalSegmentFeatureNominal element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "TorusFeatureNominal") == 0)
          {
            TorusFeatureNominalType * typ;
            if ((typ = dynamic_cast<TorusFeatureNominalType *>(basie)))
              {
                fprintf(outFile, "<TorusFeatureNominal");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TorusFeatureNominal>\n");
              }
            else
              {
                fprintf(stderr, "bad TorusFeatureNominal element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad FeatureNominal type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool FeatureNominalsType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in FeatureNominalsType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in FeatureNominalsType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FeatureNominalsType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in FeatureNominalsType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * FeatureNominalsType::getn()
{return n;}

void FeatureNominalsType::setn(NaturalType * nIn)
{n = nIn;}

FeatureNominalBaseTypeLisd * FeatureNominalsType::getFeatureNominal()
{return FeatureNominal;}

void FeatureNominalsType::setFeatureNominal(FeatureNominalBaseTypeLisd * FeatureNominalIn)
{FeatureNominal = FeatureNominalIn;}

/* ***************************************************************** */

/* class FeatureZoneAreaBaseType

*/

FeatureZoneAreaBaseType::FeatureZoneAreaBaseType() :
  FeatureZoneBaseType()
{
  FeatureZoneAreaBaseTypePair = 0;
}

FeatureZoneAreaBaseType::FeatureZoneAreaBaseType(
 AttributesType * AttributesIn,
 XmlToken * LabelIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 FeatureZoneAreaBaseTypeChoicePair * FeatureZoneAreaBaseTypePairIn) :
  FeatureZoneBaseType(
    AttributesIn,
    LabelIn,
    SurfaceFeatureNominalIdIn)
{
  FeatureZoneAreaBaseTypePair = FeatureZoneAreaBaseTypePairIn;
}

FeatureZoneAreaBaseType::FeatureZoneAreaBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * LabelIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 FeatureZoneAreaBaseTypeChoicePair * FeatureZoneAreaBaseTypePairIn) :
  FeatureZoneBaseType(
    idIn,
    AttributesIn,
    LabelIn,
    SurfaceFeatureNominalIdIn)
{
  FeatureZoneAreaBaseTypePair = FeatureZoneAreaBaseTypePairIn;
}

FeatureZoneAreaBaseType::~FeatureZoneAreaBaseType()
{
  #ifndef NODESTRUCT
  delete FeatureZoneAreaBaseTypePair;
  #endif
}

void FeatureZoneAreaBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Label)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Label");
      Label->printSelf(outFile);
      fprintf(outFile, "</Label>\n");
    }
  if (SurfaceFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SurfaceFeatureNominalId");
      SurfaceFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</SurfaceFeatureNominalId>\n");
    }
  if (FeatureZoneAreaBaseTypePair)
    {
      FeatureZoneAreaBaseTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}
FeatureZoneAreaBaseTypeChoicePair * FeatureZoneAreaBaseType::getFeatureZoneAreaBaseTypeChoicePair()
{return FeatureZoneAreaBaseTypePair;}

void FeatureZoneAreaBaseType::setFeatureZoneAreaBaseTypeChoicePair(FeatureZoneAreaBaseTypeChoicePair * FeatureZoneAreaBaseTypePairIn)
{FeatureZoneAreaBaseTypePair = FeatureZoneAreaBaseTypePairIn;}

/* ***************************************************************** */

FeatureZoneAreaBaseTypeChoicePair::FeatureZoneAreaBaseTypeChoicePair() {}

FeatureZoneAreaBaseTypeChoicePair::FeatureZoneAreaBaseTypeChoicePair(
 whichOne FeatureZoneAreaBaseTypeTypeIn,
 FeatureZoneAreaBaseTypeVal * FeatureZoneAreaBaseTypeValueIn)
{
  FeatureZoneAreaBaseTypeType = FeatureZoneAreaBaseTypeTypeIn;
  FeatureZoneAreaBaseTypeValue = FeatureZoneAreaBaseTypeValueIn;
}

FeatureZoneAreaBaseTypeChoicePair::~FeatureZoneAreaBaseTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (FeatureZoneAreaBaseTypeType == FaceIdsE)
    delete FeatureZoneAreaBaseTypeValue->FaceIds;
  else if (FeatureZoneAreaBaseTypeType == EdgeIdsE)
    delete FeatureZoneAreaBaseTypeValue->EdgeIds;
  delete FeatureZoneAreaBaseTypeValue;
  #endif
}

void FeatureZoneAreaBaseTypeChoicePair::printSelf(FILE * outFile)
{
  if (FeatureZoneAreaBaseTypeType == FaceIdsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FaceIds");
      FeatureZoneAreaBaseTypeValue->FaceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FaceIds>\n");
    }
  else if (FeatureZoneAreaBaseTypeType == EdgeIdsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EdgeIds");
      FeatureZoneAreaBaseTypeValue->EdgeIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EdgeIds>\n");
    }
}

bool FeatureZoneAreaBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in FeatureZoneAreaBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in FeatureZoneAreaBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FeatureZoneAreaBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in FeatureZoneAreaBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class FeatureZoneAreaBetweenType

*/

FeatureZoneAreaBetweenType::FeatureZoneAreaBetweenType() :
  FeatureZoneAreaBaseType()
{
  FeatureZoneArea_1077 = 0;
  FeatureZoneArea_1078 = 0;
  StartDirection = 0;
  PlaneNormal = 0;
}

FeatureZoneAreaBetweenType::FeatureZoneAreaBetweenType(
 AttributesType * AttributesIn,
 XmlToken * LabelIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 FeatureZoneAreaBaseTypeChoicePair * FeatureZoneAreaBaseTypePairIn,
 FeatureZoneArea_1077_Type * FeatureZoneArea_1077In,
 FeatureZoneArea_1078_Type * FeatureZoneArea_1078In,
 UnitVectorType * StartDirectionIn,
 UnitVectorType * PlaneNormalIn) :
  FeatureZoneAreaBaseType(
    AttributesIn,
    LabelIn,
    SurfaceFeatureNominalIdIn,
    FeatureZoneAreaBaseTypePairIn)
{
  FeatureZoneArea_1077 = FeatureZoneArea_1077In;
  FeatureZoneArea_1078 = FeatureZoneArea_1078In;
  StartDirection = StartDirectionIn;
  PlaneNormal = PlaneNormalIn;
}

FeatureZoneAreaBetweenType::FeatureZoneAreaBetweenType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * LabelIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 FeatureZoneAreaBaseTypeChoicePair * FeatureZoneAreaBaseTypePairIn,
 FeatureZoneArea_1077_Type * FeatureZoneArea_1077In,
 FeatureZoneArea_1078_Type * FeatureZoneArea_1078In,
 UnitVectorType * StartDirectionIn,
 UnitVectorType * PlaneNormalIn) :
  FeatureZoneAreaBaseType(
    idIn,
    AttributesIn,
    LabelIn,
    SurfaceFeatureNominalIdIn,
    FeatureZoneAreaBaseTypePairIn)
{
  FeatureZoneArea_1077 = FeatureZoneArea_1077In;
  FeatureZoneArea_1078 = FeatureZoneArea_1078In;
  StartDirection = StartDirectionIn;
  PlaneNormal = PlaneNormalIn;
}

FeatureZoneAreaBetweenType::~FeatureZoneAreaBetweenType()
{
  #ifndef NODESTRUCT
  delete FeatureZoneArea_1077;
  delete FeatureZoneArea_1078;
  delete StartDirection;
  delete PlaneNormal;
  #endif
}

void FeatureZoneAreaBetweenType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Label)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Label");
      Label->printSelf(outFile);
      fprintf(outFile, "</Label>\n");
    }
  if (SurfaceFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SurfaceFeatureNominalId");
      SurfaceFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</SurfaceFeatureNominalId>\n");
    }
  if (FeatureZoneAreaBaseTypePair)
    {
      FeatureZoneAreaBaseTypePair->printSelf(outFile);
    }
  FeatureZoneArea_1077->printSelf(outFile);
  FeatureZoneArea_1078->printSelf(outFile);
  if (StartDirection)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StartDirection");
      StartDirection->printSelf(outFile);
      fprintf(outFile, "</StartDirection>\n");
    }
  if (PlaneNormal)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PlaneNormal");
      PlaneNormal->printSelf(outFile);
      fprintf(outFile, "</PlaneNormal>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool FeatureZoneAreaBetweenType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in FeatureZoneAreaBetweenType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in FeatureZoneAreaBetweenType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FeatureZoneAreaBetweenType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in FeatureZoneAreaBetweenType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

FeatureZoneArea_1077_Type * FeatureZoneAreaBetweenType::getFeatureZoneArea_1077()
{return FeatureZoneArea_1077;}

void FeatureZoneAreaBetweenType::setFeatureZoneArea_1077(FeatureZoneArea_1077_Type * FeatureZoneArea_1077In)
{FeatureZoneArea_1077 = FeatureZoneArea_1077In;}

FeatureZoneArea_1078_Type * FeatureZoneAreaBetweenType::getFeatureZoneArea_1078()
{return FeatureZoneArea_1078;}

void FeatureZoneAreaBetweenType::setFeatureZoneArea_1078(FeatureZoneArea_1078_Type * FeatureZoneArea_1078In)
{FeatureZoneArea_1078 = FeatureZoneArea_1078In;}

UnitVectorType * FeatureZoneAreaBetweenType::getStartDirection()
{return StartDirection;}

void FeatureZoneAreaBetweenType::setStartDirection(UnitVectorType * StartDirectionIn)
{StartDirection = StartDirectionIn;}

UnitVectorType * FeatureZoneAreaBetweenType::getPlaneNormal()
{return PlaneNormal;}

void FeatureZoneAreaBetweenType::setPlaneNormal(UnitVectorType * PlaneNormalIn)
{PlaneNormal = PlaneNormalIn;}

/* ***************************************************************** */

/* class FeatureZoneAreaCircularType

*/

FeatureZoneAreaCircularType::FeatureZoneAreaCircularType() :
  FeatureZoneAreaBaseType()
{
  Circle = 0;
}

FeatureZoneAreaCircularType::FeatureZoneAreaCircularType(
 AttributesType * AttributesIn,
 XmlToken * LabelIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 FeatureZoneAreaBaseTypeChoicePair * FeatureZoneAreaBaseTypePairIn,
 CircleType * CircleIn) :
  FeatureZoneAreaBaseType(
    AttributesIn,
    LabelIn,
    SurfaceFeatureNominalIdIn,
    FeatureZoneAreaBaseTypePairIn)
{
  Circle = CircleIn;
}

FeatureZoneAreaCircularType::FeatureZoneAreaCircularType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * LabelIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 FeatureZoneAreaBaseTypeChoicePair * FeatureZoneAreaBaseTypePairIn,
 CircleType * CircleIn) :
  FeatureZoneAreaBaseType(
    idIn,
    AttributesIn,
    LabelIn,
    SurfaceFeatureNominalIdIn,
    FeatureZoneAreaBaseTypePairIn)
{
  Circle = CircleIn;
}

FeatureZoneAreaCircularType::~FeatureZoneAreaCircularType()
{
  #ifndef NODESTRUCT
  delete Circle;
  #endif
}

void FeatureZoneAreaCircularType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Label)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Label");
      Label->printSelf(outFile);
      fprintf(outFile, "</Label>\n");
    }
  if (SurfaceFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SurfaceFeatureNominalId");
      SurfaceFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</SurfaceFeatureNominalId>\n");
    }
  if (FeatureZoneAreaBaseTypePair)
    {
      FeatureZoneAreaBaseTypePair->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Circle");
  Circle->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Circle>\n");
  doSpaces(-INDENT, outFile);
}

bool FeatureZoneAreaCircularType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in FeatureZoneAreaCircularType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in FeatureZoneAreaCircularType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FeatureZoneAreaCircularType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in FeatureZoneAreaCircularType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

CircleType * FeatureZoneAreaCircularType::getCircle()
{return Circle;}

void FeatureZoneAreaCircularType::setCircle(CircleType * CircleIn)
{Circle = CircleIn;}

/* ***************************************************************** */

/* class FeatureZoneAreaCylindricalType

*/

FeatureZoneAreaCylindricalType::FeatureZoneAreaCylindricalType() :
  FeatureZoneAreaBaseType()
{
  Cylinder = 0;
}

FeatureZoneAreaCylindricalType::FeatureZoneAreaCylindricalType(
 AttributesType * AttributesIn,
 XmlToken * LabelIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 FeatureZoneAreaBaseTypeChoicePair * FeatureZoneAreaBaseTypePairIn,
 CylinderType * CylinderIn) :
  FeatureZoneAreaBaseType(
    AttributesIn,
    LabelIn,
    SurfaceFeatureNominalIdIn,
    FeatureZoneAreaBaseTypePairIn)
{
  Cylinder = CylinderIn;
}

FeatureZoneAreaCylindricalType::FeatureZoneAreaCylindricalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * LabelIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 FeatureZoneAreaBaseTypeChoicePair * FeatureZoneAreaBaseTypePairIn,
 CylinderType * CylinderIn) :
  FeatureZoneAreaBaseType(
    idIn,
    AttributesIn,
    LabelIn,
    SurfaceFeatureNominalIdIn,
    FeatureZoneAreaBaseTypePairIn)
{
  Cylinder = CylinderIn;
}

FeatureZoneAreaCylindricalType::~FeatureZoneAreaCylindricalType()
{
  #ifndef NODESTRUCT
  delete Cylinder;
  #endif
}

void FeatureZoneAreaCylindricalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Label)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Label");
      Label->printSelf(outFile);
      fprintf(outFile, "</Label>\n");
    }
  if (SurfaceFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SurfaceFeatureNominalId");
      SurfaceFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</SurfaceFeatureNominalId>\n");
    }
  if (FeatureZoneAreaBaseTypePair)
    {
      FeatureZoneAreaBaseTypePair->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Cylinder");
  Cylinder->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Cylinder>\n");
  doSpaces(-INDENT, outFile);
}

bool FeatureZoneAreaCylindricalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in FeatureZoneAreaCylindricalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in FeatureZoneAreaCylindricalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FeatureZoneAreaCylindricalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in FeatureZoneAreaCylindricalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

CylinderType * FeatureZoneAreaCylindricalType::getCylinder()
{return Cylinder;}

void FeatureZoneAreaCylindricalType::setCylinder(CylinderType * CylinderIn)
{Cylinder = CylinderIn;}

/* ***************************************************************** */

/* class FeatureZoneAreaIrregularType

*/

FeatureZoneAreaIrregularType::FeatureZoneAreaIrregularType() :
  FeatureZoneAreaBaseType()
{
}

FeatureZoneAreaIrregularType::FeatureZoneAreaIrregularType(
 AttributesType * AttributesIn,
 XmlToken * LabelIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 FeatureZoneAreaBaseTypeChoicePair * FeatureZoneAreaBaseTypePairIn) :
  FeatureZoneAreaBaseType(
    AttributesIn,
    LabelIn,
    SurfaceFeatureNominalIdIn,
    FeatureZoneAreaBaseTypePairIn)
{
}

FeatureZoneAreaIrregularType::FeatureZoneAreaIrregularType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * LabelIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 FeatureZoneAreaBaseTypeChoicePair * FeatureZoneAreaBaseTypePairIn) :
  FeatureZoneAreaBaseType(
    idIn,
    AttributesIn,
    LabelIn,
    SurfaceFeatureNominalIdIn,
    FeatureZoneAreaBaseTypePairIn)
{
}

FeatureZoneAreaIrregularType::~FeatureZoneAreaIrregularType()
{
  #ifndef NODESTRUCT
  #endif
}

void FeatureZoneAreaIrregularType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Label)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Label");
      Label->printSelf(outFile);
      fprintf(outFile, "</Label>\n");
    }
  if (SurfaceFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SurfaceFeatureNominalId");
      SurfaceFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</SurfaceFeatureNominalId>\n");
    }
  if (FeatureZoneAreaBaseTypePair)
    {
      FeatureZoneAreaBaseTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool FeatureZoneAreaIrregularType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in FeatureZoneAreaIrregularType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in FeatureZoneAreaIrregularType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FeatureZoneAreaIrregularType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in FeatureZoneAreaIrregularType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class FeatureZoneAreaRectangularType

*/

FeatureZoneAreaRectangularType::FeatureZoneAreaRectangularType() :
  FeatureZoneAreaBaseType()
{
  Rectangle = 0;
}

FeatureZoneAreaRectangularType::FeatureZoneAreaRectangularType(
 AttributesType * AttributesIn,
 XmlToken * LabelIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 FeatureZoneAreaBaseTypeChoicePair * FeatureZoneAreaBaseTypePairIn,
 RectangleType * RectangleIn) :
  FeatureZoneAreaBaseType(
    AttributesIn,
    LabelIn,
    SurfaceFeatureNominalIdIn,
    FeatureZoneAreaBaseTypePairIn)
{
  Rectangle = RectangleIn;
}

FeatureZoneAreaRectangularType::FeatureZoneAreaRectangularType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * LabelIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 FeatureZoneAreaBaseTypeChoicePair * FeatureZoneAreaBaseTypePairIn,
 RectangleType * RectangleIn) :
  FeatureZoneAreaBaseType(
    idIn,
    AttributesIn,
    LabelIn,
    SurfaceFeatureNominalIdIn,
    FeatureZoneAreaBaseTypePairIn)
{
  Rectangle = RectangleIn;
}

FeatureZoneAreaRectangularType::~FeatureZoneAreaRectangularType()
{
  #ifndef NODESTRUCT
  delete Rectangle;
  #endif
}

void FeatureZoneAreaRectangularType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Label)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Label");
      Label->printSelf(outFile);
      fprintf(outFile, "</Label>\n");
    }
  if (SurfaceFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SurfaceFeatureNominalId");
      SurfaceFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</SurfaceFeatureNominalId>\n");
    }
  if (FeatureZoneAreaBaseTypePair)
    {
      FeatureZoneAreaBaseTypePair->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Rectangle");
  Rectangle->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Rectangle>\n");
  doSpaces(-INDENT, outFile);
}

bool FeatureZoneAreaRectangularType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in FeatureZoneAreaRectangularType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in FeatureZoneAreaRectangularType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FeatureZoneAreaRectangularType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in FeatureZoneAreaRectangularType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

RectangleType * FeatureZoneAreaRectangularType::getRectangle()
{return Rectangle;}

void FeatureZoneAreaRectangularType::setRectangle(RectangleType * RectangleIn)
{Rectangle = RectangleIn;}

/* ***************************************************************** */

/* class FeatureZoneAreaSphericalType

*/

FeatureZoneAreaSphericalType::FeatureZoneAreaSphericalType() :
  FeatureZoneAreaBaseType()
{
  Sphere = 0;
}

FeatureZoneAreaSphericalType::FeatureZoneAreaSphericalType(
 AttributesType * AttributesIn,
 XmlToken * LabelIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 FeatureZoneAreaBaseTypeChoicePair * FeatureZoneAreaBaseTypePairIn,
 SphereType * SphereIn) :
  FeatureZoneAreaBaseType(
    AttributesIn,
    LabelIn,
    SurfaceFeatureNominalIdIn,
    FeatureZoneAreaBaseTypePairIn)
{
  Sphere = SphereIn;
}

FeatureZoneAreaSphericalType::FeatureZoneAreaSphericalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * LabelIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 FeatureZoneAreaBaseTypeChoicePair * FeatureZoneAreaBaseTypePairIn,
 SphereType * SphereIn) :
  FeatureZoneAreaBaseType(
    idIn,
    AttributesIn,
    LabelIn,
    SurfaceFeatureNominalIdIn,
    FeatureZoneAreaBaseTypePairIn)
{
  Sphere = SphereIn;
}

FeatureZoneAreaSphericalType::~FeatureZoneAreaSphericalType()
{
  #ifndef NODESTRUCT
  delete Sphere;
  #endif
}

void FeatureZoneAreaSphericalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Label)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Label");
      Label->printSelf(outFile);
      fprintf(outFile, "</Label>\n");
    }
  if (SurfaceFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SurfaceFeatureNominalId");
      SurfaceFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</SurfaceFeatureNominalId>\n");
    }
  if (FeatureZoneAreaBaseTypePair)
    {
      FeatureZoneAreaBaseTypePair->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Sphere");
  Sphere->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Sphere>\n");
  doSpaces(-INDENT, outFile);
}

bool FeatureZoneAreaSphericalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in FeatureZoneAreaSphericalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in FeatureZoneAreaSphericalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FeatureZoneAreaSphericalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in FeatureZoneAreaSphericalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

SphereType * FeatureZoneAreaSphericalType::getSphere()
{return Sphere;}

void FeatureZoneAreaSphericalType::setSphere(SphereType * SphereIn)
{Sphere = SphereIn;}

/* ***************************************************************** */

/* class FeatureZoneBaseType

*/

FeatureZoneBaseType::FeatureZoneBaseType()
{
  id = 0;
  Attributes = 0;
  Label = 0;
  SurfaceFeatureNominalId = 0;
}

FeatureZoneBaseType::FeatureZoneBaseType(
 AttributesType * AttributesIn,
 XmlToken * LabelIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn)
{
  id = 0;
  Attributes = AttributesIn;
  Label = LabelIn;
  SurfaceFeatureNominalId = SurfaceFeatureNominalIdIn;
}

FeatureZoneBaseType::FeatureZoneBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * LabelIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn)
{
  id = idIn;
  Attributes = AttributesIn;
  Label = LabelIn;
  SurfaceFeatureNominalId = SurfaceFeatureNominalIdIn;
}

FeatureZoneBaseType::~FeatureZoneBaseType()
{
  #ifndef NODESTRUCT
  delete id;
  delete Attributes;
  delete Label;
  delete SurfaceFeatureNominalId;
  #endif
}

void FeatureZoneBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Label)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Label");
      Label->printSelf(outFile);
      fprintf(outFile, "</Label>\n");
    }
  if (SurfaceFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SurfaceFeatureNominalId");
      SurfaceFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</SurfaceFeatureNominalId>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool FeatureZoneBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in FeatureZoneBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in FeatureZoneBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FeatureZoneBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in FeatureZoneBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

QIFIdType * FeatureZoneBaseType::getid()
{return id;}

void FeatureZoneBaseType::setid(QIFIdType * idIn)
{id = idIn;}

AttributesType * FeatureZoneBaseType::getAttributes()
{return Attributes;}

void FeatureZoneBaseType::setAttributes(AttributesType * AttributesIn)
{Attributes = AttributesIn;}

XmlToken * FeatureZoneBaseType::getLabel()
{return Label;}

void FeatureZoneBaseType::setLabel(XmlToken * LabelIn)
{Label = LabelIn;}

QIFReferenceFullType * FeatureZoneBaseType::getSurfaceFeatureNominalId()
{return SurfaceFeatureNominalId;}

void FeatureZoneBaseType::setSurfaceFeatureNominalId(QIFReferenceFullType * SurfaceFeatureNominalIdIn)
{SurfaceFeatureNominalId = SurfaceFeatureNominalIdIn;}

/* ***************************************************************** */

/* class FeatureZoneBaseTypeLisd

*/

FeatureZoneBaseTypeLisd::FeatureZoneBaseTypeLisd() {}

FeatureZoneBaseTypeLisd::FeatureZoneBaseTypeLisd(FeatureZoneBaseType * aFeatureZoneBaseType)
{
  push_back(aFeatureZoneBaseType);
}

FeatureZoneBaseTypeLisd::~FeatureZoneBaseTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<FeatureZoneBaseType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void FeatureZoneBaseTypeLisd::printSelf(FILE * outFile)
{
  std::list<FeatureZoneBaseType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class FeatureZoneCurveBaseType

*/

FeatureZoneCurveBaseType::FeatureZoneCurveBaseType() :
  FeatureZoneBaseType()
{
  FeatureZoneCurveBaseTypePair = 0;
}

FeatureZoneCurveBaseType::FeatureZoneCurveBaseType(
 AttributesType * AttributesIn,
 XmlToken * LabelIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 FeatureZoneCurveBaseTypeChoicePair * FeatureZoneCurveBaseTypePairIn) :
  FeatureZoneBaseType(
    AttributesIn,
    LabelIn,
    SurfaceFeatureNominalIdIn)
{
  FeatureZoneCurveBaseTypePair = FeatureZoneCurveBaseTypePairIn;
}

FeatureZoneCurveBaseType::FeatureZoneCurveBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * LabelIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 FeatureZoneCurveBaseTypeChoicePair * FeatureZoneCurveBaseTypePairIn) :
  FeatureZoneBaseType(
    idIn,
    AttributesIn,
    LabelIn,
    SurfaceFeatureNominalIdIn)
{
  FeatureZoneCurveBaseTypePair = FeatureZoneCurveBaseTypePairIn;
}

FeatureZoneCurveBaseType::~FeatureZoneCurveBaseType()
{
  #ifndef NODESTRUCT
  delete FeatureZoneCurveBaseTypePair;
  #endif
}

void FeatureZoneCurveBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Label)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Label");
      Label->printSelf(outFile);
      fprintf(outFile, "</Label>\n");
    }
  if (SurfaceFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SurfaceFeatureNominalId");
      SurfaceFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</SurfaceFeatureNominalId>\n");
    }
  if (FeatureZoneCurveBaseTypePair)
    {
      FeatureZoneCurveBaseTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}
FeatureZoneCurveBaseTypeChoicePair * FeatureZoneCurveBaseType::getFeatureZoneCurveBaseTypeChoicePair()
{return FeatureZoneCurveBaseTypePair;}

void FeatureZoneCurveBaseType::setFeatureZoneCurveBaseTypeChoicePair(FeatureZoneCurveBaseTypeChoicePair * FeatureZoneCurveBaseTypePairIn)
{FeatureZoneCurveBaseTypePair = FeatureZoneCurveBaseTypePairIn;}

/* ***************************************************************** */

FeatureZoneCurveBaseTypeChoicePair::FeatureZoneCurveBaseTypeChoicePair() {}

FeatureZoneCurveBaseTypeChoicePair::FeatureZoneCurveBaseTypeChoicePair(
 whichOne FeatureZoneCurveBaseTypeTypeIn,
 FeatureZoneCurveBaseTypeVal * FeatureZoneCurveBaseTypeValueIn)
{
  FeatureZoneCurveBaseTypeType = FeatureZoneCurveBaseTypeTypeIn;
  FeatureZoneCurveBaseTypeValue = FeatureZoneCurveBaseTypeValueIn;
}

FeatureZoneCurveBaseTypeChoicePair::~FeatureZoneCurveBaseTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (FeatureZoneCurveBaseTypeType == EdgeIdsE)
    delete FeatureZoneCurveBaseTypeValue->EdgeIds;
  else if (FeatureZoneCurveBaseTypeType == CurveIdsE)
    delete FeatureZoneCurveBaseTypeValue->CurveIds;
  delete FeatureZoneCurveBaseTypeValue;
  #endif
}

void FeatureZoneCurveBaseTypeChoicePair::printSelf(FILE * outFile)
{
  if (FeatureZoneCurveBaseTypeType == EdgeIdsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EdgeIds");
      FeatureZoneCurveBaseTypeValue->EdgeIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EdgeIds>\n");
    }
  else if (FeatureZoneCurveBaseTypeType == CurveIdsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CurveIds");
      FeatureZoneCurveBaseTypeValue->CurveIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CurveIds>\n");
    }
}

bool FeatureZoneCurveBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in FeatureZoneCurveBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in FeatureZoneCurveBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FeatureZoneCurveBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in FeatureZoneCurveBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class FeatureZoneCurveCircularType

*/

FeatureZoneCurveCircularType::FeatureZoneCurveCircularType() :
  FeatureZoneCurveBaseType()
{
  Circle = 0;
}

FeatureZoneCurveCircularType::FeatureZoneCurveCircularType(
 AttributesType * AttributesIn,
 XmlToken * LabelIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 FeatureZoneCurveBaseTypeChoicePair * FeatureZoneCurveBaseTypePairIn,
 CircleType * CircleIn) :
  FeatureZoneCurveBaseType(
    AttributesIn,
    LabelIn,
    SurfaceFeatureNominalIdIn,
    FeatureZoneCurveBaseTypePairIn)
{
  Circle = CircleIn;
}

FeatureZoneCurveCircularType::FeatureZoneCurveCircularType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * LabelIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 FeatureZoneCurveBaseTypeChoicePair * FeatureZoneCurveBaseTypePairIn,
 CircleType * CircleIn) :
  FeatureZoneCurveBaseType(
    idIn,
    AttributesIn,
    LabelIn,
    SurfaceFeatureNominalIdIn,
    FeatureZoneCurveBaseTypePairIn)
{
  Circle = CircleIn;
}

FeatureZoneCurveCircularType::~FeatureZoneCurveCircularType()
{
  #ifndef NODESTRUCT
  delete Circle;
  #endif
}

void FeatureZoneCurveCircularType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Label)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Label");
      Label->printSelf(outFile);
      fprintf(outFile, "</Label>\n");
    }
  if (SurfaceFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SurfaceFeatureNominalId");
      SurfaceFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</SurfaceFeatureNominalId>\n");
    }
  if (FeatureZoneCurveBaseTypePair)
    {
      FeatureZoneCurveBaseTypePair->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Circle");
  Circle->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Circle>\n");
  doSpaces(-INDENT, outFile);
}

bool FeatureZoneCurveCircularType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in FeatureZoneCurveCircularType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in FeatureZoneCurveCircularType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FeatureZoneCurveCircularType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in FeatureZoneCurveCircularType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

CircleType * FeatureZoneCurveCircularType::getCircle()
{return Circle;}

void FeatureZoneCurveCircularType::setCircle(CircleType * CircleIn)
{Circle = CircleIn;}

/* ***************************************************************** */

/* class FeatureZoneCurveIrregularType

*/

FeatureZoneCurveIrregularType::FeatureZoneCurveIrregularType() :
  FeatureZoneCurveBaseType()
{
  CurvePoints = 0;
}

FeatureZoneCurveIrregularType::FeatureZoneCurveIrregularType(
 AttributesType * AttributesIn,
 XmlToken * LabelIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 FeatureZoneCurveBaseTypeChoicePair * FeatureZoneCurveBaseTypePairIn,
 PolyLineType * CurvePointsIn) :
  FeatureZoneCurveBaseType(
    AttributesIn,
    LabelIn,
    SurfaceFeatureNominalIdIn,
    FeatureZoneCurveBaseTypePairIn)
{
  CurvePoints = CurvePointsIn;
}

FeatureZoneCurveIrregularType::FeatureZoneCurveIrregularType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * LabelIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 FeatureZoneCurveBaseTypeChoicePair * FeatureZoneCurveBaseTypePairIn,
 PolyLineType * CurvePointsIn) :
  FeatureZoneCurveBaseType(
    idIn,
    AttributesIn,
    LabelIn,
    SurfaceFeatureNominalIdIn,
    FeatureZoneCurveBaseTypePairIn)
{
  CurvePoints = CurvePointsIn;
}

FeatureZoneCurveIrregularType::~FeatureZoneCurveIrregularType()
{
  #ifndef NODESTRUCT
  delete CurvePoints;
  #endif
}

void FeatureZoneCurveIrregularType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Label)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Label");
      Label->printSelf(outFile);
      fprintf(outFile, "</Label>\n");
    }
  if (SurfaceFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SurfaceFeatureNominalId");
      SurfaceFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</SurfaceFeatureNominalId>\n");
    }
  if (FeatureZoneCurveBaseTypePair)
    {
      FeatureZoneCurveBaseTypePair->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CurvePoints");
  CurvePoints->printSelf(outFile);
  fprintf(outFile, "</CurvePoints>\n");
  doSpaces(-INDENT, outFile);
}

bool FeatureZoneCurveIrregularType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in FeatureZoneCurveIrregularType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in FeatureZoneCurveIrregularType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FeatureZoneCurveIrregularType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in FeatureZoneCurveIrregularType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

PolyLineType * FeatureZoneCurveIrregularType::getCurvePoints()
{return CurvePoints;}

void FeatureZoneCurveIrregularType::setCurvePoints(PolyLineType * CurvePointsIn)
{CurvePoints = CurvePointsIn;}

/* ***************************************************************** */

/* class FeatureZoneCurveLineType

*/

FeatureZoneCurveLineType::FeatureZoneCurveLineType() :
  FeatureZoneCurveBaseType()
{
  Line = 0;
}

FeatureZoneCurveLineType::FeatureZoneCurveLineType(
 AttributesType * AttributesIn,
 XmlToken * LabelIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 FeatureZoneCurveBaseTypeChoicePair * FeatureZoneCurveBaseTypePairIn,
 LineSegmentType * LineIn) :
  FeatureZoneCurveBaseType(
    AttributesIn,
    LabelIn,
    SurfaceFeatureNominalIdIn,
    FeatureZoneCurveBaseTypePairIn)
{
  Line = LineIn;
}

FeatureZoneCurveLineType::FeatureZoneCurveLineType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * LabelIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 FeatureZoneCurveBaseTypeChoicePair * FeatureZoneCurveBaseTypePairIn,
 LineSegmentType * LineIn) :
  FeatureZoneCurveBaseType(
    idIn,
    AttributesIn,
    LabelIn,
    SurfaceFeatureNominalIdIn,
    FeatureZoneCurveBaseTypePairIn)
{
  Line = LineIn;
}

FeatureZoneCurveLineType::~FeatureZoneCurveLineType()
{
  #ifndef NODESTRUCT
  delete Line;
  #endif
}

void FeatureZoneCurveLineType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Label)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Label");
      Label->printSelf(outFile);
      fprintf(outFile, "</Label>\n");
    }
  if (SurfaceFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SurfaceFeatureNominalId");
      SurfaceFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</SurfaceFeatureNominalId>\n");
    }
  if (FeatureZoneCurveBaseTypePair)
    {
      FeatureZoneCurveBaseTypePair->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Line");
  Line->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Line>\n");
  doSpaces(-INDENT, outFile);
}

bool FeatureZoneCurveLineType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in FeatureZoneCurveLineType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in FeatureZoneCurveLineType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FeatureZoneCurveLineType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in FeatureZoneCurveLineType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LineSegmentType * FeatureZoneCurveLineType::getLine()
{return Line;}

void FeatureZoneCurveLineType::setLine(LineSegmentType * LineIn)
{Line = LineIn;}

/* ***************************************************************** */

/* class FeatureZoneListType

*/

FeatureZoneListType::FeatureZoneListType()
{
  n = 0;
  FeatureZone = 0;
}

FeatureZoneListType::FeatureZoneListType(
 FeatureZoneBaseTypeLisd * FeatureZoneIn)
{
  n = 0;
  FeatureZone = FeatureZoneIn;
}

FeatureZoneListType::FeatureZoneListType(
 NaturalType * nIn,
 FeatureZoneBaseTypeLisd * FeatureZoneIn)
{
  n = nIn;
  FeatureZone = FeatureZoneIn;
}

FeatureZoneListType::~FeatureZoneListType()
{
  #ifndef NODESTRUCT
  delete n;
  delete FeatureZone;
  #endif
}

void FeatureZoneListType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!FeatureZone)
      {
        fprintf(stderr, "FeatureZone list is missing\n");
        exit(1);
      }
    if (FeatureZone->size() == 0)
      {
        fprintf(stderr, "FeatureZone list is empty\n");
        exit(1);
      }
    if (FeatureZone->size() < 1)
      {
        fprintf(stderr,
                "size of FeatureZone list (%d) less than minimum required (1)\n",
                (int)FeatureZone->size());
        exit(1);
      }
    std::list<FeatureZoneBaseType *>::iterator iter;
    for (iter = FeatureZone->begin();
         iter != FeatureZone->end(); iter++)
      {
        FeatureZoneBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->getprintElement(), "FeatureZonePoint") == 0)
          {
            FeatureZonePointType * typ;
            if ((typ = dynamic_cast<FeatureZonePointType *>(basie)))
              {
                fprintf(outFile, "<FeatureZonePoint");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</FeatureZonePoint>\n");
              }
            else
              {
                fprintf(stderr, "bad FeatureZonePoint element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "FeatureZoneCurveLine") == 0)
          {
            FeatureZoneCurveLineType * typ;
            if ((typ = dynamic_cast<FeatureZoneCurveLineType *>(basie)))
              {
                fprintf(outFile, "<FeatureZoneCurveLine");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</FeatureZoneCurveLine>\n");
              }
            else
              {
                fprintf(stderr, "bad FeatureZoneCurveLine element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "FeatureZoneCurveCircular") == 0)
          {
            FeatureZoneCurveCircularType * typ;
            if ((typ = dynamic_cast<FeatureZoneCurveCircularType *>(basie)))
              {
                fprintf(outFile, "<FeatureZoneCurveCircular");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</FeatureZoneCurveCircular>\n");
              }
            else
              {
                fprintf(stderr, "bad FeatureZoneCurveCircular element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "FeatureZoneCurveIrregular") == 0)
          {
            FeatureZoneCurveIrregularType * typ;
            if ((typ = dynamic_cast<FeatureZoneCurveIrregularType *>(basie)))
              {
                fprintf(outFile, "<FeatureZoneCurveIrregular");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</FeatureZoneCurveIrregular>\n");
              }
            else
              {
                fprintf(stderr, "bad FeatureZoneCurveIrregular element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "FeatureZoneAreaCircular") == 0)
          {
            FeatureZoneAreaCircularType * typ;
            if ((typ = dynamic_cast<FeatureZoneAreaCircularType *>(basie)))
              {
                fprintf(outFile, "<FeatureZoneAreaCircular");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</FeatureZoneAreaCircular>\n");
              }
            else
              {
                fprintf(stderr, "bad FeatureZoneAreaCircular element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "FeatureZoneAreaRectangular") == 0)
          {
            FeatureZoneAreaRectangularType * typ;
            if ((typ = dynamic_cast<FeatureZoneAreaRectangularType *>(basie)))
              {
                fprintf(outFile, "<FeatureZoneAreaRectangular");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</FeatureZoneAreaRectangular>\n");
              }
            else
              {
                fprintf(stderr, "bad FeatureZoneAreaRectangular element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "FeatureZoneAreaIrregular") == 0)
          {
            FeatureZoneAreaIrregularType * typ;
            if ((typ = dynamic_cast<FeatureZoneAreaIrregularType *>(basie)))
              {
                fprintf(outFile, "<FeatureZoneAreaIrregular");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</FeatureZoneAreaIrregular>\n");
              }
            else
              {
                fprintf(stderr, "bad FeatureZoneAreaIrregular element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "FeatureZoneAreaCylindrical") == 0)
          {
            FeatureZoneAreaCylindricalType * typ;
            if ((typ = dynamic_cast<FeatureZoneAreaCylindricalType *>(basie)))
              {
                fprintf(outFile, "<FeatureZoneAreaCylindrical");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</FeatureZoneAreaCylindrical>\n");
              }
            else
              {
                fprintf(stderr, "bad FeatureZoneAreaCylindrical element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "FeatureZoneAreaSpherical") == 0)
          {
            FeatureZoneAreaSphericalType * typ;
            if ((typ = dynamic_cast<FeatureZoneAreaSphericalType *>(basie)))
              {
                fprintf(outFile, "<FeatureZoneAreaSpherical");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</FeatureZoneAreaSpherical>\n");
              }
            else
              {
                fprintf(stderr, "bad FeatureZoneAreaSpherical element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "FeatureZoneAreaBetween") == 0)
          {
            FeatureZoneAreaBetweenType * typ;
            if ((typ = dynamic_cast<FeatureZoneAreaBetweenType *>(basie)))
              {
                fprintf(outFile, "<FeatureZoneAreaBetween");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</FeatureZoneAreaBetween>\n");
              }
            else
              {
                fprintf(stderr, "bad FeatureZoneAreaBetween element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad FeatureZone type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool FeatureZoneListType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in FeatureZoneListType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in FeatureZoneListType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FeatureZoneListType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in FeatureZoneListType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * FeatureZoneListType::getn()
{return n;}

void FeatureZoneListType::setn(NaturalType * nIn)
{n = nIn;}

FeatureZoneBaseTypeLisd * FeatureZoneListType::getFeatureZone()
{return FeatureZone;}

void FeatureZoneListType::setFeatureZone(FeatureZoneBaseTypeLisd * FeatureZoneIn)
{FeatureZone = FeatureZoneIn;}

/* ***************************************************************** */

/* class FeatureZonePointType

*/

FeatureZonePointType::FeatureZonePointType() :
  FeatureZoneBaseType()
{
  FeatureZonePoin_1079 = 0;
  Point = 0;
}

FeatureZonePointType::FeatureZonePointType(
 AttributesType * AttributesIn,
 XmlToken * LabelIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 FeatureZonePoin_1079_Type * FeatureZonePoin_1079In,
 PointType * PointIn) :
  FeatureZoneBaseType(
    AttributesIn,
    LabelIn,
    SurfaceFeatureNominalIdIn)
{
  FeatureZonePoin_1079 = FeatureZonePoin_1079In;
  Point = PointIn;
}

FeatureZonePointType::FeatureZonePointType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * LabelIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 FeatureZonePoin_1079_Type * FeatureZonePoin_1079In,
 PointType * PointIn) :
  FeatureZoneBaseType(
    idIn,
    AttributesIn,
    LabelIn,
    SurfaceFeatureNominalIdIn)
{
  FeatureZonePoin_1079 = FeatureZonePoin_1079In;
  Point = PointIn;
}

FeatureZonePointType::~FeatureZonePointType()
{
  #ifndef NODESTRUCT
  delete FeatureZonePoin_1079;
  delete Point;
  #endif
}

void FeatureZonePointType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Label)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Label");
      Label->printSelf(outFile);
      fprintf(outFile, "</Label>\n");
    }
  if (SurfaceFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SurfaceFeatureNominalId");
      SurfaceFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</SurfaceFeatureNominalId>\n");
    }
  if (FeatureZonePoin_1079)
    {
  FeatureZonePoin_1079->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Point");
  Point->printSelf(outFile);
  fprintf(outFile, "</Point>\n");
  doSpaces(-INDENT, outFile);
}

bool FeatureZonePointType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in FeatureZonePointType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in FeatureZonePointType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FeatureZonePointType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in FeatureZonePointType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

FeatureZonePoin_1079_Type * FeatureZonePointType::getFeatureZonePoin_1079()
{return FeatureZonePoin_1079;}

void FeatureZonePointType::setFeatureZonePoin_1079(FeatureZonePoin_1079_Type * FeatureZonePoin_1079In)
{FeatureZonePoin_1079 = FeatureZonePoin_1079In;}

PointType * FeatureZonePointType::getPoint()
{return Point;}

void FeatureZonePointType::setPoint(PointType * PointIn)
{Point = PointIn;}

/* ***************************************************************** */

/* class GroupFeatureDefinitionType

*/

GroupFeatureDefinitionType::GroupFeatureDefinitionType() :
  ShapeFeatureDefinitionBaseType()
{
  IsProfileGroup = 0;
  IsRunoutGroup = 0;
  GroupFeatureDef_1080 = 0;
}

GroupFeatureDefinitionType::GroupFeatureDefinitionType(
 AttributesType * AttributesIn,
 XmlBoolean * IsProfileGroupIn,
 XmlBoolean * IsRunoutGroupIn,
 GroupFeatureDef_1080_Type * GroupFeatureDef_1080In) :
  ShapeFeatureDefinitionBaseType(
    AttributesIn)
{
  IsProfileGroup = IsProfileGroupIn;
  IsRunoutGroup = IsRunoutGroupIn;
  GroupFeatureDef_1080 = GroupFeatureDef_1080In;
}

GroupFeatureDefinitionType::GroupFeatureDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlBoolean * IsProfileGroupIn,
 XmlBoolean * IsRunoutGroupIn,
 GroupFeatureDef_1080_Type * GroupFeatureDef_1080In) :
  ShapeFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
  IsProfileGroup = IsProfileGroupIn;
  IsRunoutGroup = IsRunoutGroupIn;
  GroupFeatureDef_1080 = GroupFeatureDef_1080In;
}

GroupFeatureDefinitionType::~GroupFeatureDefinitionType()
{
  #ifndef NODESTRUCT
  delete IsProfileGroup;
  delete IsRunoutGroup;
  delete GroupFeatureDef_1080;
  #endif
}

void GroupFeatureDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (IsProfileGroup)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IsProfileGroup");
      IsProfileGroup->printSelf(outFile);
      fprintf(outFile, "</IsProfileGroup>\n");
    }
  if (IsRunoutGroup)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IsRunoutGroup");
      IsRunoutGroup->printSelf(outFile);
      fprintf(outFile, "</IsRunoutGroup>\n");
    }
  if (GroupFeatureDef_1080)
    {
  GroupFeatureDef_1080->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool GroupFeatureDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in GroupFeatureDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in GroupFeatureDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in GroupFeatureDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in GroupFeatureDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

XmlBoolean * GroupFeatureDefinitionType::getIsProfileGroup()
{return IsProfileGroup;}

void GroupFeatureDefinitionType::setIsProfileGroup(XmlBoolean * IsProfileGroupIn)
{IsProfileGroup = IsProfileGroupIn;}

XmlBoolean * GroupFeatureDefinitionType::getIsRunoutGroup()
{return IsRunoutGroup;}

void GroupFeatureDefinitionType::setIsRunoutGroup(XmlBoolean * IsRunoutGroupIn)
{IsRunoutGroup = IsRunoutGroupIn;}

GroupFeatureDef_1080_Type * GroupFeatureDefinitionType::getGroupFeatureDef_1080()
{return GroupFeatureDef_1080;}

void GroupFeatureDefinitionType::setGroupFeatureDef_1080(GroupFeatureDef_1080_Type * GroupFeatureDef_1080In)
{GroupFeatureDef_1080 = GroupFeatureDef_1080In;}

/* ***************************************************************** */

/* class GroupFeatureItemType

*/

GroupFeatureItemType::GroupFeatureItemType() :
  ShapeFeatureItemBaseType()
{
}

GroupFeatureItemType::GroupFeatureItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  ShapeFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
}

GroupFeatureItemType::GroupFeatureItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  ShapeFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
}

GroupFeatureItemType::~GroupFeatureItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void GroupFeatureItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool GroupFeatureItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in GroupFeatureItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in GroupFeatureItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in GroupFeatureItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in GroupFeatureItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class GroupFeatureMeasurementType

*/

GroupFeatureMeasurementType::GroupFeatureMeasurementType() :
  ShapeFeatureMeasurementBaseType()
{
}

GroupFeatureMeasurementType::GroupFeatureMeasurementType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn) :
  ShapeFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
}

GroupFeatureMeasurementType::GroupFeatureMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn) :
  ShapeFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
}

GroupFeatureMeasurementType::~GroupFeatureMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void GroupFeatureMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool GroupFeatureMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in GroupFeatureMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in GroupFeatureMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in GroupFeatureMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in GroupFeatureMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class GroupFeatureNominalType

*/

GroupFeatureNominalType::GroupFeatureNominalType() :
  ShapeFeatureNominalBaseType()
{
  FeatureNominalIds = 0;
}

GroupFeatureNominalType::GroupFeatureNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureNominalIdsIn) :
  ShapeFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  FeatureNominalIds = FeatureNominalIdsIn;
}

GroupFeatureNominalType::GroupFeatureNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureNominalIdsIn) :
  ShapeFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  FeatureNominalIds = FeatureNominalIdsIn;
}

GroupFeatureNominalType::~GroupFeatureNominalType()
{
  #ifndef NODESTRUCT
  delete FeatureNominalIds;
  #endif
}

void GroupFeatureNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalIds");
  FeatureNominalIds->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</FeatureNominalIds>\n");
  doSpaces(-INDENT, outFile);
}

bool GroupFeatureNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in GroupFeatureNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in GroupFeatureNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in GroupFeatureNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in GroupFeatureNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

ArrayReferenceFullType * GroupFeatureNominalType::getFeatureNominalIds()
{return FeatureNominalIds;}

void GroupFeatureNominalType::setFeatureNominalIds(ArrayReferenceFullType * FeatureNominalIdsIn)
{FeatureNominalIds = FeatureNominalIdsIn;}

/* ***************************************************************** */

/* class LineBestFitType

*/

LineBestFitType::LineBestFitType() :
  ConstructionMethodBaseType()
{
  n = 0;
  BaseFeature = 0;
}

LineBestFitType::LineBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = 0;
  BaseFeature = BaseFeatureIn;
}

LineBestFitType::LineBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 NaturalType * nIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = nIn;
  BaseFeature = BaseFeatureIn;
}

LineBestFitType::~LineBestFitType()
{
  #ifndef NODESTRUCT
  delete n;
  delete BaseFeature;
  #endif
}

void LineBestFitType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  {
    if (!BaseFeature)
      {
        fprintf(stderr, "BaseFeature list is missing\n");
        exit(1);
      }
    if (BaseFeature->size() == 0)
      {
        fprintf(stderr, "BaseFeature list is empty\n");
        exit(1);
      }
    if (BaseFeature->size() < 2)
      {
        fprintf(stderr,
                "size of BaseFeature list (%d) less than minimum required (2)\n",
                (int)BaseFeature->size());
        exit(1);
      }
    std::list<SequencedBaseFeatureType *>::iterator iter;
    for (iter = BaseFeature->begin();
         iter != BaseFeature->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<BaseFeature");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</BaseFeature>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool LineBestFitType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in LineBestFitType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in LineBestFitType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in LineBestFitType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in LineBestFitType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * LineBestFitType::getn()
{return n;}

void LineBestFitType::setn(NaturalType * nIn)
{n = nIn;}

SequencedBaseFeatureTypeLisd * LineBestFitType::getBaseFeature()
{return BaseFeature;}

void LineBestFitType::setBaseFeature(SequencedBaseFeatureTypeLisd * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class LineCastType

*/

LineCastType::LineCastType() :
  ConstructionMethodBaseType()
{
  BaseFeature = 0;
}

LineCastType::LineCastType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeature = BaseFeatureIn;
}

LineCastType::~LineCastType()
{
  #ifndef NODESTRUCT
  delete BaseFeature;
  #endif
}

void LineCastType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeature");
  BaseFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * LineCastType::getBaseFeature()
{return BaseFeature;}

void LineCastType::setBaseFeature(BaseFeatureType * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class LineCheckedFeatureType

*/

LineCheckedFeatureType::LineCheckedFeatureType()
{
  CheckDetails = 0;
}

LineCheckedFeatureType::LineCheckedFeatureType(
 LineCheckedType * CheckDetailsIn)
{
  CheckDetails = CheckDetailsIn;
}

LineCheckedFeatureType::~LineCheckedFeatureType()
{
  #ifndef NODESTRUCT
  delete CheckDetails;
  #endif
}

void LineCheckedFeatureType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (CheckDetails)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CheckDetails");
      CheckDetails->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CheckDetails>\n");
    }
  doSpaces(-INDENT, outFile);
}

LineCheckedType * LineCheckedFeatureType::getCheckDetails()
{return CheckDetails;}

void LineCheckedFeatureType::setCheckDetails(LineCheckedType * CheckDetailsIn)
{CheckDetails = CheckDetailsIn;}

/* ***************************************************************** */

/* class LineCheckedType

*/

LineCheckedType::LineCheckedType()
{
  LineCheckedTypePair = 0;
}

LineCheckedType::LineCheckedType(
 LineCheckedTypeChoicePair * LineCheckedTypePairIn)
{
  LineCheckedTypePair = LineCheckedTypePairIn;
}

LineCheckedType::~LineCheckedType()
{
  #ifndef NODESTRUCT
  delete LineCheckedTypePair;
  #endif
}

void LineCheckedType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  LineCheckedTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

LineCheckedTypeChoicePair * LineCheckedType::getLineCheckedTypePair()
{return LineCheckedTypePair;}

void LineCheckedType::setLineCheckedTypePair(LineCheckedTypeChoicePair * LineCheckedTypePairIn)
{LineCheckedTypePair = LineCheckedTypePairIn;}
LineCheckedTypeChoicePair::LineCheckedTypeChoicePair() {}

LineCheckedTypeChoicePair::LineCheckedTypeChoicePair(
 whichOne LineCheckedTypeTypeIn,
 LineCheckedTypeVal * LineCheckedTypeValueIn)
{
  LineCheckedTypeType = LineCheckedTypeTypeIn;
  LineCheckedTypeValue = LineCheckedTypeValueIn;
}

LineCheckedTypeChoicePair::~LineCheckedTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (LineCheckedTypeType == MeasuredE)
    delete LineCheckedTypeValue->Measured;
  else if (LineCheckedTypeType == ConstructedE)
    delete LineCheckedTypeValue->Constructed;
  delete LineCheckedTypeValue;
  #endif
}

void LineCheckedTypeChoicePair::printSelf(FILE * outFile)
{
  if (LineCheckedTypeType == MeasuredE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Measured");
      LineCheckedTypeValue->Measured->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Measured>\n");
    }
  else if (LineCheckedTypeType == ConstructedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      LineCheckedTypeValue->Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
}

/* ***************************************************************** */

/* class LineConstructionMethodType

*/

LineConstructionMethodType::LineConstructionMethodType()
{
  LineConstructionMethodTypePair = 0;
}

LineConstructionMethodType::LineConstructionMethodType(
 LineConstructionMethodTypeChoicePair * LineConstructionMethodTypePairIn)
{
  LineConstructionMethodTypePair = LineConstructionMethodTypePairIn;
}

LineConstructionMethodType::~LineConstructionMethodType()
{
  #ifndef NODESTRUCT
  delete LineConstructionMethodTypePair;
  #endif
}

void LineConstructionMethodType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (LineConstructionMethodTypePair)
    {
      LineConstructionMethodTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

LineConstructionMethodTypeChoicePair * LineConstructionMethodType::getLineConstructionMethodTypePair()
{return LineConstructionMethodTypePair;}

void LineConstructionMethodType::setLineConstructionMethodTypePair(LineConstructionMethodTypeChoicePair * LineConstructionMethodTypePairIn)
{LineConstructionMethodTypePair = LineConstructionMethodTypePairIn;}
LineConstructionMethodTypeChoicePair::LineConstructionMethodTypeChoicePair() {}

LineConstructionMethodTypeChoicePair::LineConstructionMethodTypeChoicePair(
 whichOne LineConstructionMethodTypeTypeIn,
 LineConstructionMethodTypeVal * LineConstructionMethodTypeValueIn)
{
  LineConstructionMethodTypeType = LineConstructionMethodTypeTypeIn;
  LineConstructionMethodTypeValue = LineConstructionMethodTypeValueIn;
}

LineConstructionMethodTypeChoicePair::~LineConstructionMethodTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (LineConstructionMethodTypeType == BestFitE)
    delete LineConstructionMethodTypeValue->BestFit;
  else if (LineConstructionMethodTypeType == RecompensatedE)
    delete LineConstructionMethodTypeValue->Recompensated;
  else if (LineConstructionMethodTypeType == MidlineE)
    delete LineConstructionMethodTypeValue->Midline;
  else if (LineConstructionMethodTypeType == IntersectionE)
    delete LineConstructionMethodTypeValue->Intersection;
  else if (LineConstructionMethodTypeType == ProjectionE)
    delete LineConstructionMethodTypeValue->Projection;
  else if (LineConstructionMethodTypeType == PerpendicularE)
    delete LineConstructionMethodTypeValue->Perpendicular;
  else if (LineConstructionMethodTypeType == ParallelE)
    delete LineConstructionMethodTypeValue->Parallel;
  else if (LineConstructionMethodTypeType == CopyE)
    delete LineConstructionMethodTypeValue->Copy;
  else if (LineConstructionMethodTypeType == CastE)
    delete LineConstructionMethodTypeValue->Cast;
  else if (LineConstructionMethodTypeType == TangentThroughE)
    delete LineConstructionMethodTypeValue->TangentThrough;
  else if (LineConstructionMethodTypeType == TransformE)
    delete LineConstructionMethodTypeValue->Transform;
  else if (LineConstructionMethodTypeType == ExtractE)
    delete LineConstructionMethodTypeValue->Extract;
  else if (LineConstructionMethodTypeType == FromScanE)
    delete LineConstructionMethodTypeValue->FromScan;
  delete LineConstructionMethodTypeValue;
  #endif
}

void LineConstructionMethodTypeChoicePair::printSelf(FILE * outFile)
{
  if (LineConstructionMethodTypeType == BestFitE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BestFit");
      LineConstructionMethodTypeValue->BestFit->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BestFit>\n");
    }
  else if (LineConstructionMethodTypeType == RecompensatedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Recompensated");
      LineConstructionMethodTypeValue->Recompensated->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Recompensated>\n");
    }
  else if (LineConstructionMethodTypeType == MidlineE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Midline");
      LineConstructionMethodTypeValue->Midline->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Midline>\n");
    }
  else if (LineConstructionMethodTypeType == IntersectionE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Intersection");
      LineConstructionMethodTypeValue->Intersection->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Intersection>\n");
    }
  else if (LineConstructionMethodTypeType == ProjectionE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Projection");
      LineConstructionMethodTypeValue->Projection->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Projection>\n");
    }
  else if (LineConstructionMethodTypeType == PerpendicularE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Perpendicular");
      LineConstructionMethodTypeValue->Perpendicular->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Perpendicular>\n");
    }
  else if (LineConstructionMethodTypeType == ParallelE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Parallel");
      LineConstructionMethodTypeValue->Parallel->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Parallel>\n");
    }
  else if (LineConstructionMethodTypeType == CopyE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Copy");
      LineConstructionMethodTypeValue->Copy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Copy>\n");
    }
  else if (LineConstructionMethodTypeType == CastE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Cast");
      LineConstructionMethodTypeValue->Cast->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Cast>\n");
    }
  else if (LineConstructionMethodTypeType == TangentThroughE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TangentThrough");
      LineConstructionMethodTypeValue->TangentThrough->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</TangentThrough>\n");
    }
  else if (LineConstructionMethodTypeType == TransformE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Transform");
      LineConstructionMethodTypeValue->Transform->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Transform>\n");
    }
  else if (LineConstructionMethodTypeType == ExtractE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Extract");
      LineConstructionMethodTypeValue->Extract->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Extract>\n");
    }
  else if (LineConstructionMethodTypeType == FromScanE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FromScan");
      LineConstructionMethodTypeValue->FromScan->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FromScan>\n");
    }
}

/* ***************************************************************** */

/* class LineCopyType

*/

LineCopyType::LineCopyType() :
  ConstructionMethodBaseType()
{
  BaseLine = 0;
}

LineCopyType::LineCopyType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseLineIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseLine = BaseLineIn;
}

LineCopyType::~LineCopyType()
{
  #ifndef NODESTRUCT
  delete BaseLine;
  #endif
}

void LineCopyType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseLine");
  BaseLine->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseLine>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * LineCopyType::getBaseLine()
{return BaseLine;}

void LineCopyType::setBaseLine(BaseFeatureType * BaseLineIn)
{BaseLine = BaseLineIn;}

/* ***************************************************************** */

/* class LineExtractType

*/

LineExtractType::LineExtractType() :
  ConstructionMethodBaseType()
{
  CurveFeature = 0;
}

LineExtractType::LineExtractType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * CurveFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  CurveFeature = CurveFeatureIn;
}

LineExtractType::~LineExtractType()
{
  #ifndef NODESTRUCT
  delete CurveFeature;
  #endif
}

void LineExtractType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CurveFeature");
  CurveFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</CurveFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * LineExtractType::getCurveFeature()
{return CurveFeature;}

void LineExtractType::setCurveFeature(BaseFeatureType * CurveFeatureIn)
{CurveFeature = CurveFeatureIn;}

/* ***************************************************************** */

/* class LineFeatureDefinitionType

*/

LineFeatureDefinitionType::LineFeatureDefinitionType() :
  CurveFeatureDefinitionBaseType()
{
}

LineFeatureDefinitionType::LineFeatureDefinitionType(
 AttributesType * AttributesIn) :
  CurveFeatureDefinitionBaseType(
    AttributesIn)
{
}

LineFeatureDefinitionType::LineFeatureDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn) :
  CurveFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
}

LineFeatureDefinitionType::~LineFeatureDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void LineFeatureDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool LineFeatureDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in LineFeatureDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in LineFeatureDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in LineFeatureDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in LineFeatureDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class LineFeatureItemType

*/

LineFeatureItemType::LineFeatureItemType() :
  CurveFeatureItemBaseType()
{
  DeterminationMode = 0;
}

LineFeatureItemType::LineFeatureItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 LineMeasurementDeterminationType * DeterminationModeIn) :
  CurveFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

LineFeatureItemType::LineFeatureItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 LineMeasurementDeterminationType * DeterminationModeIn) :
  CurveFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

LineFeatureItemType::~LineFeatureItemType()
{
  #ifndef NODESTRUCT
  delete DeterminationMode;
  #endif
}

void LineFeatureItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<DeterminationMode");
  DeterminationMode->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeterminationMode>\n");
  doSpaces(-INDENT, outFile);
}

bool LineFeatureItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in LineFeatureItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in LineFeatureItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in LineFeatureItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in LineFeatureItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LineMeasurementDeterminationType * LineFeatureItemType::getDeterminationMode()
{return DeterminationMode;}

void LineFeatureItemType::setDeterminationMode(LineMeasurementDeterminationType * DeterminationModeIn)
{DeterminationMode = DeterminationModeIn;}

/* ***************************************************************** */

/* class LineFeatureMeasurementType

*/

LineFeatureMeasurementType::LineFeatureMeasurementType() :
  CurveFeatureMeasurementBaseType()
{
  Location = 0;
  Direction = 0;
  Length = 0;
  Normal = 0;
  Form = 0;
}

LineFeatureMeasurementType::LineFeatureMeasurementType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredPointType * LocationIn,
 MeasuredUnitVectorType * DirectionIn,
 MeasuredLinearValueType * LengthIn,
 MeasuredUnitVectorType * NormalIn,
 MeasuredLinearValueType * FormIn) :
  CurveFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Location = LocationIn;
  Direction = DirectionIn;
  Length = LengthIn;
  Normal = NormalIn;
  Form = FormIn;
}

LineFeatureMeasurementType::LineFeatureMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredPointType * LocationIn,
 MeasuredUnitVectorType * DirectionIn,
 MeasuredLinearValueType * LengthIn,
 MeasuredUnitVectorType * NormalIn,
 MeasuredLinearValueType * FormIn) :
  CurveFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Location = LocationIn;
  Direction = DirectionIn;
  Length = LengthIn;
  Normal = NormalIn;
  Form = FormIn;
}

LineFeatureMeasurementType::~LineFeatureMeasurementType()
{
  #ifndef NODESTRUCT
  delete Location;
  delete Direction;
  delete Length;
  delete Normal;
  delete Form;
  #endif
}

void LineFeatureMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  if (Location)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Location");
      Location->printSelf(outFile);
      fprintf(outFile, "</Location>\n");
    }
  if (Direction)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Direction");
      Direction->printSelf(outFile);
      fprintf(outFile, "</Direction>\n");
    }
  if (Length)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Length");
      Length->printSelf(outFile);
      fprintf(outFile, "</Length>\n");
    }
  if (Normal)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Normal");
      Normal->printSelf(outFile);
      fprintf(outFile, "</Normal>\n");
    }
  if (Form)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Form");
      Form->printSelf(outFile);
      fprintf(outFile, "</Form>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool LineFeatureMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in LineFeatureMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in LineFeatureMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in LineFeatureMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in LineFeatureMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredPointType * LineFeatureMeasurementType::getLocation()
{return Location;}

void LineFeatureMeasurementType::setLocation(MeasuredPointType * LocationIn)
{Location = LocationIn;}

MeasuredUnitVectorType * LineFeatureMeasurementType::getDirection()
{return Direction;}

void LineFeatureMeasurementType::setDirection(MeasuredUnitVectorType * DirectionIn)
{Direction = DirectionIn;}

MeasuredLinearValueType * LineFeatureMeasurementType::getLength()
{return Length;}

void LineFeatureMeasurementType::setLength(MeasuredLinearValueType * LengthIn)
{Length = LengthIn;}

MeasuredUnitVectorType * LineFeatureMeasurementType::getNormal()
{return Normal;}

void LineFeatureMeasurementType::setNormal(MeasuredUnitVectorType * NormalIn)
{Normal = NormalIn;}

MeasuredLinearValueType * LineFeatureMeasurementType::getForm()
{return Form;}

void LineFeatureMeasurementType::setForm(MeasuredLinearValueType * FormIn)
{Form = FormIn;}

/* ***************************************************************** */

/* class LineFeatureNominalType

*/

LineFeatureNominalType::LineFeatureNominalType() :
  CurveFeatureNominalBaseType()
{
  Location = 0;
  Direction = 0;
  Length = 0;
  Normal = 0;
  Constructed = 0;
}

LineFeatureNominalType::LineFeatureNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 PointType * LocationIn,
 UnitVectorType * DirectionIn,
 LinearValueType * LengthIn,
 UnitVectorType * NormalIn,
 LineConstructionMethodType * ConstructedIn) :
  CurveFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    SurfaceFeatureNominalIdIn)
{
  Location = LocationIn;
  Direction = DirectionIn;
  Length = LengthIn;
  Normal = NormalIn;
  Constructed = ConstructedIn;
}

LineFeatureNominalType::LineFeatureNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 PointType * LocationIn,
 UnitVectorType * DirectionIn,
 LinearValueType * LengthIn,
 UnitVectorType * NormalIn,
 LineConstructionMethodType * ConstructedIn) :
  CurveFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    SurfaceFeatureNominalIdIn)
{
  Location = LocationIn;
  Direction = DirectionIn;
  Length = LengthIn;
  Normal = NormalIn;
  Constructed = ConstructedIn;
}

LineFeatureNominalType::~LineFeatureNominalType()
{
  #ifndef NODESTRUCT
  delete Location;
  delete Direction;
  delete Length;
  delete Normal;
  delete Constructed;
  #endif
}

void LineFeatureNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (SurfaceFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SurfaceFeatureNominalId");
      SurfaceFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</SurfaceFeatureNominalId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Location");
  Location->printSelf(outFile);
  fprintf(outFile, "</Location>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Direction");
  Direction->printSelf(outFile);
  fprintf(outFile, "</Direction>\n");
  if (Length)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Length");
      Length->printSelf(outFile);
      fprintf(outFile, "</Length>\n");
    }
  if (Normal)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Normal");
      Normal->printSelf(outFile);
      fprintf(outFile, "</Normal>\n");
    }
  if (Constructed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool LineFeatureNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in LineFeatureNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in LineFeatureNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in LineFeatureNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in LineFeatureNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

PointType * LineFeatureNominalType::getLocation()
{return Location;}

void LineFeatureNominalType::setLocation(PointType * LocationIn)
{Location = LocationIn;}

UnitVectorType * LineFeatureNominalType::getDirection()
{return Direction;}

void LineFeatureNominalType::setDirection(UnitVectorType * DirectionIn)
{Direction = DirectionIn;}

LinearValueType * LineFeatureNominalType::getLength()
{return Length;}

void LineFeatureNominalType::setLength(LinearValueType * LengthIn)
{Length = LengthIn;}

UnitVectorType * LineFeatureNominalType::getNormal()
{return Normal;}

void LineFeatureNominalType::setNormal(UnitVectorType * NormalIn)
{Normal = NormalIn;}

LineConstructionMethodType * LineFeatureNominalType::getConstructed()
{return Constructed;}

void LineFeatureNominalType::setConstructed(LineConstructionMethodType * ConstructedIn)
{Constructed = ConstructedIn;}

/* ***************************************************************** */

/* class LineFromScanType

*/

LineFromScanType::LineFromScanType() :
  ConstructionMethodBaseType()
{
  SurfaceFeature = 0;
  SearchRadius = 0;
}

LineFromScanType::LineFromScanType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * SurfaceFeatureIn,
 LinearValueType * SearchRadiusIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  SurfaceFeature = SurfaceFeatureIn;
  SearchRadius = SearchRadiusIn;
}

LineFromScanType::~LineFromScanType()
{
  #ifndef NODESTRUCT
  delete SurfaceFeature;
  delete SearchRadius;
  #endif
}

void LineFromScanType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<SurfaceFeature");
  SurfaceFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</SurfaceFeature>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<SearchRadius");
  SearchRadius->printSelf(outFile);
  fprintf(outFile, "</SearchRadius>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * LineFromScanType::getSurfaceFeature()
{return SurfaceFeature;}

void LineFromScanType::setSurfaceFeature(BaseFeatureType * SurfaceFeatureIn)
{SurfaceFeature = SurfaceFeatureIn;}

LinearValueType * LineFromScanType::getSearchRadius()
{return SearchRadius;}

void LineFromScanType::setSearchRadius(LinearValueType * SearchRadiusIn)
{SearchRadius = SearchRadiusIn;}

/* ***************************************************************** */

/* class LineIntersectionType

*/

LineIntersectionType::LineIntersectionType() :
  ConstructionMethodBaseType()
{
  IntersectionFeature = 0;
}

LineIntersectionType::LineIntersectionType(
 XmlBoolean * NominalsCalculatedIn,
 SequencedBaseFeatureTypeLisd * IntersectionFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  IntersectionFeature = IntersectionFeatureIn;
}

LineIntersectionType::~LineIntersectionType()
{
  #ifndef NODESTRUCT
  delete IntersectionFeature;
  #endif
}

void LineIntersectionType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  {
    if (!IntersectionFeature)
      {
        fprintf(stderr, "IntersectionFeature list is missing\n");
        exit(1);
      }
    if (IntersectionFeature->size() == 0)
      {
        fprintf(stderr, "IntersectionFeature list is empty\n");
        exit(1);
      }
    if (IntersectionFeature->size() > 2)
      {
        fprintf(stderr,
                "size of IntersectionFeature list (%d) greater than maximum allowed (2)\n",
                (int)IntersectionFeature->size());
        exit(1);
      }
    if (IntersectionFeature->size() < 2)
      {
        fprintf(stderr,
                "size of IntersectionFeature list (%d) less than minimum required (2)\n",
                (int)IntersectionFeature->size());
        exit(1);
      }
    std::list<SequencedBaseFeatureType *>::iterator iter;
    for (iter = IntersectionFeature->begin();
         iter != IntersectionFeature->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<IntersectionFeature");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</IntersectionFeature>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

SequencedBaseFeatureTypeLisd * LineIntersectionType::getIntersectionFeature()
{return IntersectionFeature;}

void LineIntersectionType::setIntersectionFeature(SequencedBaseFeatureTypeLisd * IntersectionFeatureIn)
{IntersectionFeature = IntersectionFeatureIn;}

/* ***************************************************************** */

/* class LineMeasurementDeterminationType

*/

LineMeasurementDeterminationType::LineMeasurementDeterminationType()
{
  LineMeasurementDeterminationTypePair = 0;
}

LineMeasurementDeterminationType::LineMeasurementDeterminationType(
 LineMeasurementDeterminationTypeChoicePair * LineMeasurementDeterminationTypePairIn)
{
  LineMeasurementDeterminationTypePair = LineMeasurementDeterminationTypePairIn;
}

LineMeasurementDeterminationType::~LineMeasurementDeterminationType()
{
  #ifndef NODESTRUCT
  delete LineMeasurementDeterminationTypePair;
  #endif
}

void LineMeasurementDeterminationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  LineMeasurementDeterminationTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

LineMeasurementDeterminationTypeChoicePair * LineMeasurementDeterminationType::getLineMeasurementDeterminationTypePair()
{return LineMeasurementDeterminationTypePair;}

void LineMeasurementDeterminationType::setLineMeasurementDeterminationTypePair(LineMeasurementDeterminationTypeChoicePair * LineMeasurementDeterminationTypePairIn)
{LineMeasurementDeterminationTypePair = LineMeasurementDeterminationTypePairIn;}
LineMeasurementDeterminationTypeChoicePair::LineMeasurementDeterminationTypeChoicePair() {}

LineMeasurementDeterminationTypeChoicePair::LineMeasurementDeterminationTypeChoicePair(
 whichOne LineMeasurementDeterminationTypeTypeIn,
 LineMeasurementDeterminationTypeVal * LineMeasurementDeterminationTypeValueIn)
{
  LineMeasurementDeterminationTypeType = LineMeasurementDeterminationTypeTypeIn;
  LineMeasurementDeterminationTypeValue = LineMeasurementDeterminationTypeValueIn;
}

LineMeasurementDeterminationTypeChoicePair::~LineMeasurementDeterminationTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (LineMeasurementDeterminationTypeType == CheckedE)
    delete LineMeasurementDeterminationTypeValue->Checked;
  else if (LineMeasurementDeterminationTypeType == SetE)
    delete LineMeasurementDeterminationTypeValue->Set;
  delete LineMeasurementDeterminationTypeValue;
  #endif
}

void LineMeasurementDeterminationTypeChoicePair::printSelf(FILE * outFile)
{
  if (LineMeasurementDeterminationTypeType == CheckedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Checked");
      LineMeasurementDeterminationTypeValue->Checked->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Checked>\n");
    }
  else if (LineMeasurementDeterminationTypeType == SetE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Set");
      LineMeasurementDeterminationTypeValue->Set->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class LineMidlineType

*/

LineMidlineType::LineMidlineType() :
  ConstructionMethodBaseType()
{
  BaseLine = 0;
}

LineMidlineType::LineMidlineType(
 XmlBoolean * NominalsCalculatedIn,
 SequencedBaseFeatureTypeLisd * BaseLineIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseLine = BaseLineIn;
}

LineMidlineType::~LineMidlineType()
{
  #ifndef NODESTRUCT
  delete BaseLine;
  #endif
}

void LineMidlineType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  {
    if (!BaseLine)
      {
        fprintf(stderr, "BaseLine list is missing\n");
        exit(1);
      }
    if (BaseLine->size() == 0)
      {
        fprintf(stderr, "BaseLine list is empty\n");
        exit(1);
      }
    if (BaseLine->size() > 2)
      {
        fprintf(stderr,
                "size of BaseLine list (%d) greater than maximum allowed (2)\n",
                (int)BaseLine->size());
        exit(1);
      }
    if (BaseLine->size() < 2)
      {
        fprintf(stderr,
                "size of BaseLine list (%d) less than minimum required (2)\n",
                (int)BaseLine->size());
        exit(1);
      }
    std::list<SequencedBaseFeatureType *>::iterator iter;
    for (iter = BaseLine->begin();
         iter != BaseLine->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<BaseLine");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</BaseLine>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

SequencedBaseFeatureTypeLisd * LineMidlineType::getBaseLine()
{return BaseLine;}

void LineMidlineType::setBaseLine(SequencedBaseFeatureTypeLisd * BaseLineIn)
{BaseLine = BaseLineIn;}

/* ***************************************************************** */

/* class LineParallelType

*/

LineParallelType::LineParallelType() :
  ConstructionMethodBaseType()
{
  ParallelFeature = 0;
  PointFeature = 0;
}

LineParallelType::LineParallelType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * ParallelFeatureIn,
 BaseFeatureType * PointFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  ParallelFeature = ParallelFeatureIn;
  PointFeature = PointFeatureIn;
}

LineParallelType::~LineParallelType()
{
  #ifndef NODESTRUCT
  delete ParallelFeature;
  delete PointFeature;
  #endif
}

void LineParallelType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ParallelFeature");
  ParallelFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ParallelFeature>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<PointFeature");
  PointFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</PointFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * LineParallelType::getParallelFeature()
{return ParallelFeature;}

void LineParallelType::setParallelFeature(BaseFeatureType * ParallelFeatureIn)
{ParallelFeature = ParallelFeatureIn;}

BaseFeatureType * LineParallelType::getPointFeature()
{return PointFeature;}

void LineParallelType::setPointFeature(BaseFeatureType * PointFeatureIn)
{PointFeature = PointFeatureIn;}

/* ***************************************************************** */

/* class LinePerpendicularType

*/

LinePerpendicularType::LinePerpendicularType() :
  ConstructionMethodBaseType()
{
  PerpendicularFeature = 0;
  PointFeature = 0;
}

LinePerpendicularType::LinePerpendicularType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * PerpendicularFeatureIn,
 BaseFeatureType * PointFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  PerpendicularFeature = PerpendicularFeatureIn;
  PointFeature = PointFeatureIn;
}

LinePerpendicularType::~LinePerpendicularType()
{
  #ifndef NODESTRUCT
  delete PerpendicularFeature;
  delete PointFeature;
  #endif
}

void LinePerpendicularType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<PerpendicularFeature");
  PerpendicularFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</PerpendicularFeature>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<PointFeature");
  PointFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</PointFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * LinePerpendicularType::getPerpendicularFeature()
{return PerpendicularFeature;}

void LinePerpendicularType::setPerpendicularFeature(BaseFeatureType * PerpendicularFeatureIn)
{PerpendicularFeature = PerpendicularFeatureIn;}

BaseFeatureType * LinePerpendicularType::getPointFeature()
{return PointFeature;}

void LinePerpendicularType::setPointFeature(BaseFeatureType * PointFeatureIn)
{PointFeature = PointFeatureIn;}

/* ***************************************************************** */

/* class LineProjectionType

*/

LineProjectionType::LineProjectionType() :
  ConstructionMethodBaseType()
{
  ProjectionPlane = 0;
  ProjectionLine = 0;
}

LineProjectionType::LineProjectionType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * ProjectionPlaneIn,
 BaseFeatureType * ProjectionLineIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  ProjectionPlane = ProjectionPlaneIn;
  ProjectionLine = ProjectionLineIn;
}

LineProjectionType::~LineProjectionType()
{
  #ifndef NODESTRUCT
  delete ProjectionPlane;
  delete ProjectionLine;
  #endif
}

void LineProjectionType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ProjectionPlane");
  ProjectionPlane->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ProjectionPlane>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<ProjectionLine");
  ProjectionLine->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ProjectionLine>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * LineProjectionType::getProjectionPlane()
{return ProjectionPlane;}

void LineProjectionType::setProjectionPlane(BaseFeatureType * ProjectionPlaneIn)
{ProjectionPlane = ProjectionPlaneIn;}

BaseFeatureType * LineProjectionType::getProjectionLine()
{return ProjectionLine;}

void LineProjectionType::setProjectionLine(BaseFeatureType * ProjectionLineIn)
{ProjectionLine = ProjectionLineIn;}

/* ***************************************************************** */

/* class LineRecompType

*/

LineRecompType::LineRecompType() :
  ConstructionMethodBaseType()
{
  BaseFeaturePointList = 0;
}

LineRecompType::LineRecompType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeaturePointListType * BaseFeaturePointListIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeaturePointList = BaseFeaturePointListIn;
}

LineRecompType::~LineRecompType()
{
  #ifndef NODESTRUCT
  delete BaseFeaturePointList;
  #endif
}

void LineRecompType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeaturePointList");
  BaseFeaturePointList->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeaturePointList>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeaturePointListType * LineRecompType::getBaseFeaturePointList()
{return BaseFeaturePointList;}

void LineRecompType::setBaseFeaturePointList(BaseFeaturePointListType * BaseFeaturePointListIn)
{BaseFeaturePointList = BaseFeaturePointListIn;}

/* ***************************************************************** */

/* class LineTangentThroughType

*/

LineTangentThroughType::LineTangentThroughType() :
  ConstructionMethodBaseType()
{
  TangentFeature = 0;
  PointFeature = 0;
}

LineTangentThroughType::LineTangentThroughType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * TangentFeatureIn,
 BaseFeatureType * PointFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  TangentFeature = TangentFeatureIn;
  PointFeature = PointFeatureIn;
}

LineTangentThroughType::~LineTangentThroughType()
{
  #ifndef NODESTRUCT
  delete TangentFeature;
  delete PointFeature;
  #endif
}

void LineTangentThroughType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<TangentFeature");
  TangentFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</TangentFeature>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<PointFeature");
  PointFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</PointFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * LineTangentThroughType::getTangentFeature()
{return TangentFeature;}

void LineTangentThroughType::setTangentFeature(BaseFeatureType * TangentFeatureIn)
{TangentFeature = TangentFeatureIn;}

BaseFeatureType * LineTangentThroughType::getPointFeature()
{return PointFeature;}

void LineTangentThroughType::setPointFeature(BaseFeatureType * PointFeatureIn)
{PointFeature = PointFeatureIn;}

/* ***************************************************************** */

/* class LineTransformType

*/

LineTransformType::LineTransformType() :
  ConstructionMethodBaseType()
{
  BaseLine = 0;
  Transformation = 0;
}

LineTransformType::LineTransformType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseLineIn,
 TransformationReferenceType * TransformationIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseLine = BaseLineIn;
  Transformation = TransformationIn;
}

LineTransformType::~LineTransformType()
{
  #ifndef NODESTRUCT
  delete BaseLine;
  delete Transformation;
  #endif
}

void LineTransformType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseLine");
  BaseLine->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseLine>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Transformation");
  Transformation->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Transformation>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * LineTransformType::getBaseLine()
{return BaseLine;}

void LineTransformType::setBaseLine(BaseFeatureType * BaseLineIn)
{BaseLine = BaseLineIn;}

TransformationReferenceType * LineTransformType::getTransformation()
{return Transformation;}

void LineTransformType::setTransformation(TransformationReferenceType * TransformationIn)
{Transformation = TransformationIn;}

/* ***************************************************************** */

/* class MarkingFeatureDefinitionType

*/

MarkingFeatureDefinitionType::MarkingFeatureDefinitionType() :
  NonShapeFeatureDefinitionBaseType()
{
  Text = 0;
  MarkingMethod = 0;
}

MarkingFeatureDefinitionType::MarkingFeatureDefinitionType(
 AttributesType * AttributesIn,
 XmlString * TextIn,
 MarkingMethodType * MarkingMethodIn) :
  NonShapeFeatureDefinitionBaseType(
    AttributesIn)
{
  Text = TextIn;
  MarkingMethod = MarkingMethodIn;
}

MarkingFeatureDefinitionType::MarkingFeatureDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * TextIn,
 MarkingMethodType * MarkingMethodIn) :
  NonShapeFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
  Text = TextIn;
  MarkingMethod = MarkingMethodIn;
}

MarkingFeatureDefinitionType::~MarkingFeatureDefinitionType()
{
  #ifndef NODESTRUCT
  delete Text;
  delete MarkingMethod;
  #endif
}

void MarkingFeatureDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Text");
  Text->printSelf(outFile);
  fprintf(outFile, "</Text>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MarkingMethod");
  MarkingMethod->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</MarkingMethod>\n");
  doSpaces(-INDENT, outFile);
}

bool MarkingFeatureDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in MarkingFeatureDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in MarkingFeatureDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in MarkingFeatureDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in MarkingFeatureDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

XmlString * MarkingFeatureDefinitionType::getText()
{return Text;}

void MarkingFeatureDefinitionType::setText(XmlString * TextIn)
{Text = TextIn;}

MarkingMethodType * MarkingFeatureDefinitionType::getMarkingMethod()
{return MarkingMethod;}

void MarkingFeatureDefinitionType::setMarkingMethod(MarkingMethodType * MarkingMethodIn)
{MarkingMethod = MarkingMethodIn;}

/* ***************************************************************** */

/* class MarkingFeatureItemType

*/

MarkingFeatureItemType::MarkingFeatureItemType() :
  NonShapeFeatureItemBaseType()
{
}

MarkingFeatureItemType::MarkingFeatureItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn) :
  NonShapeFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn)
{
}

MarkingFeatureItemType::MarkingFeatureItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn) :
  NonShapeFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn)
{
}

MarkingFeatureItemType::~MarkingFeatureItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void MarkingFeatureItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool MarkingFeatureItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in MarkingFeatureItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in MarkingFeatureItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in MarkingFeatureItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in MarkingFeatureItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class MarkingFeatureMeasurementType

*/

MarkingFeatureMeasurementType::MarkingFeatureMeasurementType() :
  NonShapeFeatureMeasurementBaseType()
{
  Text = 0;
  Location = 0;
}

MarkingFeatureMeasurementType::MarkingFeatureMeasurementType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 XmlString * TextIn,
 RectangleType * LocationIn) :
  NonShapeFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn)
{
  Text = TextIn;
  Location = LocationIn;
}

MarkingFeatureMeasurementType::MarkingFeatureMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 XmlString * TextIn,
 RectangleType * LocationIn) :
  NonShapeFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn)
{
  Text = TextIn;
  Location = LocationIn;
}

MarkingFeatureMeasurementType::~MarkingFeatureMeasurementType()
{
  #ifndef NODESTRUCT
  delete Text;
  delete Location;
  #endif
}

void MarkingFeatureMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Text");
  Text->printSelf(outFile);
  fprintf(outFile, "</Text>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Location");
  Location->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Location>\n");
  doSpaces(-INDENT, outFile);
}

bool MarkingFeatureMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in MarkingFeatureMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in MarkingFeatureMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in MarkingFeatureMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in MarkingFeatureMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

XmlString * MarkingFeatureMeasurementType::getText()
{return Text;}

void MarkingFeatureMeasurementType::setText(XmlString * TextIn)
{Text = TextIn;}

RectangleType * MarkingFeatureMeasurementType::getLocation()
{return Location;}

void MarkingFeatureMeasurementType::setLocation(RectangleType * LocationIn)
{Location = LocationIn;}

/* ***************************************************************** */

/* class MarkingFeatureNominalType

*/

MarkingFeatureNominalType::MarkingFeatureNominalType() :
  NonShapeFeatureNominalBaseType()
{
  Location = 0;
}

MarkingFeatureNominalType::MarkingFeatureNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 RectangleType * LocationIn) :
  NonShapeFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn)
{
  Location = LocationIn;
}

MarkingFeatureNominalType::MarkingFeatureNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 RectangleType * LocationIn) :
  NonShapeFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn)
{
  Location = LocationIn;
}

MarkingFeatureNominalType::~MarkingFeatureNominalType()
{
  #ifndef NODESTRUCT
  delete Location;
  #endif
}

void MarkingFeatureNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Location");
  Location->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Location>\n");
  doSpaces(-INDENT, outFile);
}

bool MarkingFeatureNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in MarkingFeatureNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in MarkingFeatureNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in MarkingFeatureNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in MarkingFeatureNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

RectangleType * MarkingFeatureNominalType::getLocation()
{return Location;}

void MarkingFeatureNominalType::setLocation(RectangleType * LocationIn)
{Location = LocationIn;}

/* ***************************************************************** */

/* class MarkingMethodEnumType

*/

MarkingMethodEnumType::MarkingMethodEnumType() :
  XmlNMTOKEN()
{
}

MarkingMethodEnumType::MarkingMethodEnumType(
 const char * valIn) :
  XmlNMTOKEN(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "PAINT") &&
           strcmp(val.c_str(), "STAIN") &&
           strcmp(val.c_str(), "ENSCRIBE") &&
           strcmp(val.c_str(), "EMBOSS"));
}

MarkingMethodEnumType::~MarkingMethodEnumType() {}

bool MarkingMethodEnumType::MarkingMethodEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "PAINT") &&
          strcmp(val.c_str(), "STAIN") &&
          strcmp(val.c_str(), "ENSCRIBE") &&
          strcmp(val.c_str(), "EMBOSS"));
}

void MarkingMethodEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "MarkingMethodEnumType");
}

void MarkingMethodEnumType::printSelf(FILE * outFile)
{
  if (MarkingMethodEnumTypeIsBad())
    {
      fprintf(stderr, "bad MarkingMethodEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::printSelf(outFile);
}

void MarkingMethodEnumType::oPrintSelf(FILE * outFile)
{
  if (MarkingMethodEnumTypeIsBad())
    {
      fprintf(stderr, "bad MarkingMethodEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class MarkingMethodType

*/

MarkingMethodType::MarkingMethodType()
{
  MarkingMethodTypePair = 0;
}

MarkingMethodType::MarkingMethodType(
 MarkingMethodTypeChoicePair * MarkingMethodTypePairIn)
{
  MarkingMethodTypePair = MarkingMethodTypePairIn;
}

MarkingMethodType::~MarkingMethodType()
{
  #ifndef NODESTRUCT
  delete MarkingMethodTypePair;
  #endif
}

void MarkingMethodType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  MarkingMethodTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

MarkingMethodTypeChoicePair * MarkingMethodType::getMarkingMethodTypePair()
{return MarkingMethodTypePair;}

void MarkingMethodType::setMarkingMethodTypePair(MarkingMethodTypeChoicePair * MarkingMethodTypePairIn)
{MarkingMethodTypePair = MarkingMethodTypePairIn;}
MarkingMethodTypeChoicePair::MarkingMethodTypeChoicePair() {}

MarkingMethodTypeChoicePair::MarkingMethodTypeChoicePair(
 whichOne MarkingMethodTypeTypeIn,
 MarkingMethodTypeVal * MarkingMethodTypeValueIn)
{
  MarkingMethodTypeType = MarkingMethodTypeTypeIn;
  MarkingMethodTypeValue = MarkingMethodTypeValueIn;
}

MarkingMethodTypeChoicePair::~MarkingMethodTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (MarkingMethodTypeType == MarkingMethodEnumE)
    delete MarkingMethodTypeValue->MarkingMethodEnum;
  else if (MarkingMethodTypeType == OtherMarkingMethodE)
    delete MarkingMethodTypeValue->OtherMarkingMethod;
  delete MarkingMethodTypeValue;
  #endif
}

void MarkingMethodTypeChoicePair::printSelf(FILE * outFile)
{
  if (MarkingMethodTypeType == MarkingMethodEnumE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MarkingMethodEnum");
      MarkingMethodTypeValue->MarkingMethodEnum->printSelf(outFile);
      fprintf(outFile, "</MarkingMethodEnum>\n");
    }
  else if (MarkingMethodTypeType == OtherMarkingMethodE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OtherMarkingMethod");
      MarkingMethodTypeValue->OtherMarkingMethod->printSelf(outFile);
      fprintf(outFile, "</OtherMarkingMethod>\n");
    }
}

/* ***************************************************************** */

/* class MeasuredFeatureType

*/

MeasuredFeatureType::MeasuredFeatureType()
{
  PointList = 0;
}

MeasuredFeatureType::MeasuredFeatureType(
 PointListType * PointListIn)
{
  PointList = PointListIn;
}

MeasuredFeatureType::~MeasuredFeatureType()
{
  #ifndef NODESTRUCT
  delete PointList;
  #endif
}

void MeasuredFeatureType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  doSpaces(-INDENT, outFile);
}

PointListType * MeasuredFeatureType::getPointList()
{return PointList;}

void MeasuredFeatureType::setPointList(PointListType * PointListIn)
{PointList = PointListIn;}

/* ***************************************************************** */

/* class MeasuredPointSetType

*/

MeasuredPointSetType::MeasuredPointSetType()
{
  combinedUncertainty = 0;
  count = 0;
  decimalPlaces = 0;
  id = 0;
  linearUnit = 0;
  meanError = 0;
  significantFigures = 0;
  validity = 0;
  xCombinedUncertainty = 0;
  xDecimalPlaces = 0;
  xMeanError = 0;
  xSignificantFigures = 0;
  xValidity = 0;
  yCombinedUncertainty = 0;
  yDecimalPlaces = 0;
  yMeanError = 0;
  ySignificantFigures = 0;
  yValidity = 0;
  zCombinedUncertainty = 0;
  zDecimalPlaces = 0;
  zMeanError = 0;
  zSignificantFigures = 0;
  zValidity = 0;
  Attributes = 0;
  Units = 0;
  MeasuredPointSe_1081 = 0;
  MeasuredPointSe_1082 = 0;
  MeasuredPointSe_1083 = 0;
  MeasuredPointSe_1084 = 0;
  MeasuredPointSe_1085 = 0;
  MeasurementDeviceId = 0;
  MeasuredPointSe_1086 = 0;
  MeasuredPointSe_1087 = 0;
  MeasuredPointSe_1088 = 0;
  MeasuredPointSe_1089 = 0;
  MeasuredPointSe_1090 = 0;
  MeasuredPointSe_1091 = 0;
  MeasuredPointSe_1092 = 0;
  MeasuredPointSe_1093 = 0;
}

MeasuredPointSetType::MeasuredPointSetType(
 AttributesType * AttributesIn,
 OtherUnitsType * UnitsIn,
 MeasuredPointSe_1081_Type * MeasuredPointSe_1081In,
 MeasuredPointSe_1082_Type * MeasuredPointSe_1082In,
 MeasuredPointSe_1083_Type * MeasuredPointSe_1083In,
 MeasuredPointSe_1084_Type * MeasuredPointSe_1084In,
 MeasuredPointSe_1085_Type * MeasuredPointSe_1085In,
 QIFReferenceType * MeasurementDeviceIdIn,
 MeasuredPointSe_1086_Type * MeasuredPointSe_1086In,
 MeasuredPointSe_1087_Type * MeasuredPointSe_1087In,
 MeasuredPointSe_1088_Type * MeasuredPointSe_1088In,
 MeasuredPointSe_1089_Type * MeasuredPointSe_1089In,
 MeasuredPointSe_1090_Type * MeasuredPointSe_1090In,
 MeasuredPointSe_1091_Type * MeasuredPointSe_1091In,
 MeasuredPointSe_1092_Type * MeasuredPointSe_1092In,
 MeasuredPointSe_1093_Type * MeasuredPointSe_1093In)
{
  combinedUncertainty = 0;
  count = 0;
  decimalPlaces = 0;
  id = 0;
  linearUnit = 0;
  meanError = 0;
  significantFigures = 0;
  validity = 0;
  xCombinedUncertainty = 0;
  xDecimalPlaces = 0;
  xMeanError = 0;
  xSignificantFigures = 0;
  xValidity = 0;
  yCombinedUncertainty = 0;
  yDecimalPlaces = 0;
  yMeanError = 0;
  ySignificantFigures = 0;
  yValidity = 0;
  zCombinedUncertainty = 0;
  zDecimalPlaces = 0;
  zMeanError = 0;
  zSignificantFigures = 0;
  zValidity = 0;
  Attributes = AttributesIn;
  Units = UnitsIn;
  MeasuredPointSe_1081 = MeasuredPointSe_1081In;
  MeasuredPointSe_1082 = MeasuredPointSe_1082In;
  MeasuredPointSe_1083 = MeasuredPointSe_1083In;
  MeasuredPointSe_1084 = MeasuredPointSe_1084In;
  MeasuredPointSe_1085 = MeasuredPointSe_1085In;
  MeasurementDeviceId = MeasurementDeviceIdIn;
  MeasuredPointSe_1086 = MeasuredPointSe_1086In;
  MeasuredPointSe_1087 = MeasuredPointSe_1087In;
  MeasuredPointSe_1088 = MeasuredPointSe_1088In;
  MeasuredPointSe_1089 = MeasuredPointSe_1089In;
  MeasuredPointSe_1090 = MeasuredPointSe_1090In;
  MeasuredPointSe_1091 = MeasuredPointSe_1091In;
  MeasuredPointSe_1092 = MeasuredPointSe_1092In;
  MeasuredPointSe_1093 = MeasuredPointSe_1093In;
}

MeasuredPointSetType::MeasuredPointSetType(
 XmlDecimal * combinedUncertaintyIn,
 NaturalType * countIn,
 XmlNonNegativeInteger * decimalPlacesIn,
 QIFIdType * idIn,
 XmlToken * linearUnitIn,
 XmlDecimal * meanErrorIn,
 XmlNonNegativeInteger * significantFiguresIn,
 ValidityEnumType * validityIn,
 XmlDecimal * xCombinedUncertaintyIn,
 XmlNonNegativeInteger * xDecimalPlacesIn,
 XmlDecimal * xMeanErrorIn,
 XmlNonNegativeInteger * xSignificantFiguresIn,
 ValidityEnumType * xValidityIn,
 XmlDecimal * yCombinedUncertaintyIn,
 XmlNonNegativeInteger * yDecimalPlacesIn,
 XmlDecimal * yMeanErrorIn,
 XmlNonNegativeInteger * ySignificantFiguresIn,
 ValidityEnumType * yValidityIn,
 XmlDecimal * zCombinedUncertaintyIn,
 XmlNonNegativeInteger * zDecimalPlacesIn,
 XmlDecimal * zMeanErrorIn,
 XmlNonNegativeInteger * zSignificantFiguresIn,
 ValidityEnumType * zValidityIn,
 AttributesType * AttributesIn,
 OtherUnitsType * UnitsIn,
 MeasuredPointSe_1081_Type * MeasuredPointSe_1081In,
 MeasuredPointSe_1082_Type * MeasuredPointSe_1082In,
 MeasuredPointSe_1083_Type * MeasuredPointSe_1083In,
 MeasuredPointSe_1084_Type * MeasuredPointSe_1084In,
 MeasuredPointSe_1085_Type * MeasuredPointSe_1085In,
 QIFReferenceType * MeasurementDeviceIdIn,
 MeasuredPointSe_1086_Type * MeasuredPointSe_1086In,
 MeasuredPointSe_1087_Type * MeasuredPointSe_1087In,
 MeasuredPointSe_1088_Type * MeasuredPointSe_1088In,
 MeasuredPointSe_1089_Type * MeasuredPointSe_1089In,
 MeasuredPointSe_1090_Type * MeasuredPointSe_1090In,
 MeasuredPointSe_1091_Type * MeasuredPointSe_1091In,
 MeasuredPointSe_1092_Type * MeasuredPointSe_1092In,
 MeasuredPointSe_1093_Type * MeasuredPointSe_1093In)
{
  combinedUncertainty = combinedUncertaintyIn;
  count = countIn;
  decimalPlaces = decimalPlacesIn;
  id = idIn;
  linearUnit = linearUnitIn;
  meanError = meanErrorIn;
  significantFigures = significantFiguresIn;
  validity = validityIn;
  xCombinedUncertainty = xCombinedUncertaintyIn;
  xDecimalPlaces = xDecimalPlacesIn;
  xMeanError = xMeanErrorIn;
  xSignificantFigures = xSignificantFiguresIn;
  xValidity = xValidityIn;
  yCombinedUncertainty = yCombinedUncertaintyIn;
  yDecimalPlaces = yDecimalPlacesIn;
  yMeanError = yMeanErrorIn;
  ySignificantFigures = ySignificantFiguresIn;
  yValidity = yValidityIn;
  zCombinedUncertainty = zCombinedUncertaintyIn;
  zDecimalPlaces = zDecimalPlacesIn;
  zMeanError = zMeanErrorIn;
  zSignificantFigures = zSignificantFiguresIn;
  zValidity = zValidityIn;
  Attributes = AttributesIn;
  Units = UnitsIn;
  MeasuredPointSe_1081 = MeasuredPointSe_1081In;
  MeasuredPointSe_1082 = MeasuredPointSe_1082In;
  MeasuredPointSe_1083 = MeasuredPointSe_1083In;
  MeasuredPointSe_1084 = MeasuredPointSe_1084In;
  MeasuredPointSe_1085 = MeasuredPointSe_1085In;
  MeasurementDeviceId = MeasurementDeviceIdIn;
  MeasuredPointSe_1086 = MeasuredPointSe_1086In;
  MeasuredPointSe_1087 = MeasuredPointSe_1087In;
  MeasuredPointSe_1088 = MeasuredPointSe_1088In;
  MeasuredPointSe_1089 = MeasuredPointSe_1089In;
  MeasuredPointSe_1090 = MeasuredPointSe_1090In;
  MeasuredPointSe_1091 = MeasuredPointSe_1091In;
  MeasuredPointSe_1092 = MeasuredPointSe_1092In;
  MeasuredPointSe_1093 = MeasuredPointSe_1093In;
}

MeasuredPointSetType::~MeasuredPointSetType()
{
  #ifndef NODESTRUCT
  delete combinedUncertainty;
  delete count;
  delete decimalPlaces;
  delete id;
  delete linearUnit;
  delete meanError;
  delete significantFigures;
  delete validity;
  delete xCombinedUncertainty;
  delete xDecimalPlaces;
  delete xMeanError;
  delete xSignificantFigures;
  delete xValidity;
  delete yCombinedUncertainty;
  delete yDecimalPlaces;
  delete yMeanError;
  delete ySignificantFigures;
  delete yValidity;
  delete zCombinedUncertainty;
  delete zDecimalPlaces;
  delete zMeanError;
  delete zSignificantFigures;
  delete zValidity;
  delete Attributes;
  delete Units;
  delete MeasuredPointSe_1081;
  delete MeasuredPointSe_1082;
  delete MeasuredPointSe_1083;
  delete MeasuredPointSe_1084;
  delete MeasuredPointSe_1085;
  delete MeasurementDeviceId;
  delete MeasuredPointSe_1086;
  delete MeasuredPointSe_1087;
  delete MeasuredPointSe_1088;
  delete MeasuredPointSe_1089;
  delete MeasuredPointSe_1090;
  delete MeasuredPointSe_1091;
  delete MeasuredPointSe_1092;
  delete MeasuredPointSe_1093;
  #endif
}

void MeasuredPointSetType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (combinedUncertainty)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "combinedUncertainty=\"");
      combinedUncertainty->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (count)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "count=\"");
      count->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"count\" missing\n");
      exit(1);
    }
  if (decimalPlaces)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "decimalPlaces=\"");
      decimalPlaces->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  if (linearUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "linearUnit=\"");
      linearUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (meanError)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "meanError=\"");
      meanError->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (significantFigures)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "significantFigures=\"");
      significantFigures->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (validity)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "validity=\"");
      validity->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (xCombinedUncertainty)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "xCombinedUncertainty=\"");
      xCombinedUncertainty->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (xDecimalPlaces)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "xDecimalPlaces=\"");
      xDecimalPlaces->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (xMeanError)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "xMeanError=\"");
      xMeanError->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (xSignificantFigures)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "xSignificantFigures=\"");
      xSignificantFigures->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (xValidity)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "xValidity=\"");
      xValidity->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (yCombinedUncertainty)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "yCombinedUncertainty=\"");
      yCombinedUncertainty->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (yDecimalPlaces)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "yDecimalPlaces=\"");
      yDecimalPlaces->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (yMeanError)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "yMeanError=\"");
      yMeanError->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (ySignificantFigures)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "ySignificantFigures=\"");
      ySignificantFigures->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (yValidity)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "yValidity=\"");
      yValidity->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (zCombinedUncertainty)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "zCombinedUncertainty=\"");
      zCombinedUncertainty->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (zDecimalPlaces)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "zDecimalPlaces=\"");
      zDecimalPlaces->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (zMeanError)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "zMeanError=\"");
      zMeanError->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (zSignificantFigures)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "zSignificantFigures=\"");
      zSignificantFigures->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (zValidity)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "zValidity=\"");
      zValidity->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Units)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Units");
      Units->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Units>\n");
    }
  if (MeasuredPointSe_1081)
    {
  MeasuredPointSe_1081->printSelf(outFile);
    }
  MeasuredPointSe_1082->printSelf(outFile);
  if (MeasuredPointSe_1083)
    {
  MeasuredPointSe_1083->printSelf(outFile);
    }
  MeasuredPointSe_1084->printSelf(outFile);
  if (MeasuredPointSe_1085)
    {
  MeasuredPointSe_1085->printSelf(outFile);
    }
  if (MeasurementDeviceId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceId");
      MeasurementDeviceId->printSelf(outFile);
      fprintf(outFile, "</MeasurementDeviceId>\n");
    }
  if (MeasuredPointSe_1086)
    {
  MeasuredPointSe_1086->printSelf(outFile);
    }
  if (MeasuredPointSe_1087)
    {
  MeasuredPointSe_1087->printSelf(outFile);
    }
  if (MeasuredPointSe_1088)
    {
  MeasuredPointSe_1088->printSelf(outFile);
    }
  if (MeasuredPointSe_1089)
    {
  MeasuredPointSe_1089->printSelf(outFile);
    }
  if (MeasuredPointSe_1090)
    {
  MeasuredPointSe_1090->printSelf(outFile);
    }
  if (MeasuredPointSe_1091)
    {
  MeasuredPointSe_1091->printSelf(outFile);
    }
  if (MeasuredPointSe_1092)
    {
  MeasuredPointSe_1092->printSelf(outFile);
    }
  if (MeasuredPointSe_1093)
    {
      MeasuredPointSe_1093->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool MeasuredPointSetType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "combinedUncertainty")
        {
          XmlDecimal * combinedUncertaintyVal;
          if (this->combinedUncertainty)
            {
              fprintf(stderr, "two values for combinedUncertainty in MeasuredPointSetType\n");
              returnValue = true;
              break;
            }
          combinedUncertaintyVal = new XmlDecimal(decl->getval().c_str());
          if (combinedUncertaintyVal->getbad())
            {
              delete combinedUncertaintyVal;
              fprintf(stderr, "bad value %s for combinedUncertainty in MeasuredPointSetType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->combinedUncertainty = combinedUncertaintyVal;
        }
      else if (decl->getname() == "count")
        {
          NaturalType * countVal;
          if (this->count)
            {
              fprintf(stderr, "two values for count in MeasuredPointSetType\n");
              returnValue = true;
              break;
            }
          countVal = new NaturalType(decl->getval().c_str());
          if (countVal->getbad())
            {
              delete countVal;
              fprintf(stderr, "bad value %s for count in MeasuredPointSetType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->count = countVal;
        }
      else if (decl->getname() == "decimalPlaces")
        {
          XmlNonNegativeInteger * decimalPlacesVal;
          if (this->decimalPlaces)
            {
              fprintf(stderr, "two values for decimalPlaces in MeasuredPointSetType\n");
              returnValue = true;
              break;
            }
          decimalPlacesVal = new XmlNonNegativeInteger(decl->getval().c_str());
          if (decimalPlacesVal->getbad())
            {
              delete decimalPlacesVal;
              fprintf(stderr, "bad value %s for decimalPlaces in MeasuredPointSetType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->decimalPlaces = decimalPlacesVal;
        }
      else if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in MeasuredPointSetType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in MeasuredPointSetType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else if (decl->getname() == "linearUnit")
        {
          XmlToken * linearUnitVal;
          if (this->linearUnit)
            {
              fprintf(stderr, "two values for linearUnit in MeasuredPointSetType\n");
              returnValue = true;
              break;
            }
          linearUnitVal = new XmlToken(decl->getval().c_str());
          if (linearUnitVal->getbad())
            {
              delete linearUnitVal;
              fprintf(stderr, "bad value %s for linearUnit in MeasuredPointSetType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->linearUnit = linearUnitVal;
        }
      else if (decl->getname() == "meanError")
        {
          XmlDecimal * meanErrorVal;
          if (this->meanError)
            {
              fprintf(stderr, "two values for meanError in MeasuredPointSetType\n");
              returnValue = true;
              break;
            }
          meanErrorVal = new XmlDecimal(decl->getval().c_str());
          if (meanErrorVal->getbad())
            {
              delete meanErrorVal;
              fprintf(stderr, "bad value %s for meanError in MeasuredPointSetType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->meanError = meanErrorVal;
        }
      else if (decl->getname() == "significantFigures")
        {
          XmlNonNegativeInteger * significantFiguresVal;
          if (this->significantFigures)
            {
              fprintf(stderr, "two values for significantFigures in MeasuredPointSetType\n");
              returnValue = true;
              break;
            }
          significantFiguresVal = new XmlNonNegativeInteger(decl->getval().c_str());
          if (significantFiguresVal->getbad())
            {
              delete significantFiguresVal;
              fprintf(stderr, "bad value %s for significantFigures in MeasuredPointSetType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->significantFigures = significantFiguresVal;
        }
      else if (decl->getname() == "validity")
        {
          ValidityEnumType * validityVal;
          if (this->validity)
            {
              fprintf(stderr, "two values for validity in MeasuredPointSetType\n");
              returnValue = true;
              break;
            }
          validityVal = new ValidityEnumType(decl->getval().c_str());
          if (validityVal->getbad())
            {
              delete validityVal;
              fprintf(stderr, "bad value %s for validity in MeasuredPointSetType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->validity = validityVal;
        }
      else if (decl->getname() == "xCombinedUncertainty")
        {
          XmlDecimal * xCombinedUncertaintyVal;
          if (this->xCombinedUncertainty)
            {
              fprintf(stderr, "two values for xCombinedUncertainty in MeasuredPointSetType\n");
              returnValue = true;
              break;
            }
          xCombinedUncertaintyVal = new XmlDecimal(decl->getval().c_str());
          if (xCombinedUncertaintyVal->getbad())
            {
              delete xCombinedUncertaintyVal;
              fprintf(stderr, "bad value %s for xCombinedUncertainty in MeasuredPointSetType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->xCombinedUncertainty = xCombinedUncertaintyVal;
        }
      else if (decl->getname() == "xDecimalPlaces")
        {
          XmlNonNegativeInteger * xDecimalPlacesVal;
          if (this->xDecimalPlaces)
            {
              fprintf(stderr, "two values for xDecimalPlaces in MeasuredPointSetType\n");
              returnValue = true;
              break;
            }
          xDecimalPlacesVal = new XmlNonNegativeInteger(decl->getval().c_str());
          if (xDecimalPlacesVal->getbad())
            {
              delete xDecimalPlacesVal;
              fprintf(stderr, "bad value %s for xDecimalPlaces in MeasuredPointSetType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->xDecimalPlaces = xDecimalPlacesVal;
        }
      else if (decl->getname() == "xMeanError")
        {
          XmlDecimal * xMeanErrorVal;
          if (this->xMeanError)
            {
              fprintf(stderr, "two values for xMeanError in MeasuredPointSetType\n");
              returnValue = true;
              break;
            }
          xMeanErrorVal = new XmlDecimal(decl->getval().c_str());
          if (xMeanErrorVal->getbad())
            {
              delete xMeanErrorVal;
              fprintf(stderr, "bad value %s for xMeanError in MeasuredPointSetType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->xMeanError = xMeanErrorVal;
        }
      else if (decl->getname() == "xSignificantFigures")
        {
          XmlNonNegativeInteger * xSignificantFiguresVal;
          if (this->xSignificantFigures)
            {
              fprintf(stderr, "two values for xSignificantFigures in MeasuredPointSetType\n");
              returnValue = true;
              break;
            }
          xSignificantFiguresVal = new XmlNonNegativeInteger(decl->getval().c_str());
          if (xSignificantFiguresVal->getbad())
            {
              delete xSignificantFiguresVal;
              fprintf(stderr, "bad value %s for xSignificantFigures in MeasuredPointSetType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->xSignificantFigures = xSignificantFiguresVal;
        }
      else if (decl->getname() == "xValidity")
        {
          ValidityEnumType * xValidityVal;
          if (this->xValidity)
            {
              fprintf(stderr, "two values for xValidity in MeasuredPointSetType\n");
              returnValue = true;
              break;
            }
          xValidityVal = new ValidityEnumType(decl->getval().c_str());
          if (xValidityVal->getbad())
            {
              delete xValidityVal;
              fprintf(stderr, "bad value %s for xValidity in MeasuredPointSetType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->xValidity = xValidityVal;
        }
      else if (decl->getname() == "yCombinedUncertainty")
        {
          XmlDecimal * yCombinedUncertaintyVal;
          if (this->yCombinedUncertainty)
            {
              fprintf(stderr, "two values for yCombinedUncertainty in MeasuredPointSetType\n");
              returnValue = true;
              break;
            }
          yCombinedUncertaintyVal = new XmlDecimal(decl->getval().c_str());
          if (yCombinedUncertaintyVal->getbad())
            {
              delete yCombinedUncertaintyVal;
              fprintf(stderr, "bad value %s for yCombinedUncertainty in MeasuredPointSetType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->yCombinedUncertainty = yCombinedUncertaintyVal;
        }
      else if (decl->getname() == "yDecimalPlaces")
        {
          XmlNonNegativeInteger * yDecimalPlacesVal;
          if (this->yDecimalPlaces)
            {
              fprintf(stderr, "two values for yDecimalPlaces in MeasuredPointSetType\n");
              returnValue = true;
              break;
            }
          yDecimalPlacesVal = new XmlNonNegativeInteger(decl->getval().c_str());
          if (yDecimalPlacesVal->getbad())
            {
              delete yDecimalPlacesVal;
              fprintf(stderr, "bad value %s for yDecimalPlaces in MeasuredPointSetType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->yDecimalPlaces = yDecimalPlacesVal;
        }
      else if (decl->getname() == "yMeanError")
        {
          XmlDecimal * yMeanErrorVal;
          if (this->yMeanError)
            {
              fprintf(stderr, "two values for yMeanError in MeasuredPointSetType\n");
              returnValue = true;
              break;
            }
          yMeanErrorVal = new XmlDecimal(decl->getval().c_str());
          if (yMeanErrorVal->getbad())
            {
              delete yMeanErrorVal;
              fprintf(stderr, "bad value %s for yMeanError in MeasuredPointSetType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->yMeanError = yMeanErrorVal;
        }
      else if (decl->getname() == "ySignificantFigures")
        {
          XmlNonNegativeInteger * ySignificantFiguresVal;
          if (this->ySignificantFigures)
            {
              fprintf(stderr, "two values for ySignificantFigures in MeasuredPointSetType\n");
              returnValue = true;
              break;
            }
          ySignificantFiguresVal = new XmlNonNegativeInteger(decl->getval().c_str());
          if (ySignificantFiguresVal->getbad())
            {
              delete ySignificantFiguresVal;
              fprintf(stderr, "bad value %s for ySignificantFigures in MeasuredPointSetType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->ySignificantFigures = ySignificantFiguresVal;
        }
      else if (decl->getname() == "yValidity")
        {
          ValidityEnumType * yValidityVal;
          if (this->yValidity)
            {
              fprintf(stderr, "two values for yValidity in MeasuredPointSetType\n");
              returnValue = true;
              break;
            }
          yValidityVal = new ValidityEnumType(decl->getval().c_str());
          if (yValidityVal->getbad())
            {
              delete yValidityVal;
              fprintf(stderr, "bad value %s for yValidity in MeasuredPointSetType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->yValidity = yValidityVal;
        }
      else if (decl->getname() == "zCombinedUncertainty")
        {
          XmlDecimal * zCombinedUncertaintyVal;
          if (this->zCombinedUncertainty)
            {
              fprintf(stderr, "two values for zCombinedUncertainty in MeasuredPointSetType\n");
              returnValue = true;
              break;
            }
          zCombinedUncertaintyVal = new XmlDecimal(decl->getval().c_str());
          if (zCombinedUncertaintyVal->getbad())
            {
              delete zCombinedUncertaintyVal;
              fprintf(stderr, "bad value %s for zCombinedUncertainty in MeasuredPointSetType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->zCombinedUncertainty = zCombinedUncertaintyVal;
        }
      else if (decl->getname() == "zDecimalPlaces")
        {
          XmlNonNegativeInteger * zDecimalPlacesVal;
          if (this->zDecimalPlaces)
            {
              fprintf(stderr, "two values for zDecimalPlaces in MeasuredPointSetType\n");
              returnValue = true;
              break;
            }
          zDecimalPlacesVal = new XmlNonNegativeInteger(decl->getval().c_str());
          if (zDecimalPlacesVal->getbad())
            {
              delete zDecimalPlacesVal;
              fprintf(stderr, "bad value %s for zDecimalPlaces in MeasuredPointSetType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->zDecimalPlaces = zDecimalPlacesVal;
        }
      else if (decl->getname() == "zMeanError")
        {
          XmlDecimal * zMeanErrorVal;
          if (this->zMeanError)
            {
              fprintf(stderr, "two values for zMeanError in MeasuredPointSetType\n");
              returnValue = true;
              break;
            }
          zMeanErrorVal = new XmlDecimal(decl->getval().c_str());
          if (zMeanErrorVal->getbad())
            {
              delete zMeanErrorVal;
              fprintf(stderr, "bad value %s for zMeanError in MeasuredPointSetType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->zMeanError = zMeanErrorVal;
        }
      else if (decl->getname() == "zSignificantFigures")
        {
          XmlNonNegativeInteger * zSignificantFiguresVal;
          if (this->zSignificantFigures)
            {
              fprintf(stderr, "two values for zSignificantFigures in MeasuredPointSetType\n");
              returnValue = true;
              break;
            }
          zSignificantFiguresVal = new XmlNonNegativeInteger(decl->getval().c_str());
          if (zSignificantFiguresVal->getbad())
            {
              delete zSignificantFiguresVal;
              fprintf(stderr, "bad value %s for zSignificantFigures in MeasuredPointSetType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->zSignificantFigures = zSignificantFiguresVal;
        }
      else if (decl->getname() == "zValidity")
        {
          ValidityEnumType * zValidityVal;
          if (this->zValidity)
            {
              fprintf(stderr, "two values for zValidity in MeasuredPointSetType\n");
              returnValue = true;
              break;
            }
          zValidityVal = new ValidityEnumType(decl->getval().c_str());
          if (zValidityVal->getbad())
            {
              delete zValidityVal;
              fprintf(stderr, "bad value %s for zValidity in MeasuredPointSetType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->zValidity = zValidityVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in MeasuredPointSetType\n");
          returnValue = true;
          break;
        }
    }
  if (this->count == 0)
    {
      fprintf(stderr, "required attribute \"count\" missing in MeasuredPointSetType\n");
      returnValue = true;
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in MeasuredPointSetType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->combinedUncertainty;
      this->combinedUncertainty = 0;
      delete this->count;
      this->count = 0;
      delete this->decimalPlaces;
      this->decimalPlaces = 0;
      delete this->id;
      this->id = 0;
      delete this->linearUnit;
      this->linearUnit = 0;
      delete this->meanError;
      this->meanError = 0;
      delete this->significantFigures;
      this->significantFigures = 0;
      delete this->validity;
      this->validity = 0;
      delete this->xCombinedUncertainty;
      this->xCombinedUncertainty = 0;
      delete this->xDecimalPlaces;
      this->xDecimalPlaces = 0;
      delete this->xMeanError;
      this->xMeanError = 0;
      delete this->xSignificantFigures;
      this->xSignificantFigures = 0;
      delete this->xValidity;
      this->xValidity = 0;
      delete this->yCombinedUncertainty;
      this->yCombinedUncertainty = 0;
      delete this->yDecimalPlaces;
      this->yDecimalPlaces = 0;
      delete this->yMeanError;
      this->yMeanError = 0;
      delete this->ySignificantFigures;
      this->ySignificantFigures = 0;
      delete this->yValidity;
      this->yValidity = 0;
      delete this->zCombinedUncertainty;
      this->zCombinedUncertainty = 0;
      delete this->zDecimalPlaces;
      this->zDecimalPlaces = 0;
      delete this->zMeanError;
      this->zMeanError = 0;
      delete this->zSignificantFigures;
      this->zSignificantFigures = 0;
      delete this->zValidity;
      this->zValidity = 0;
    }
  return returnValue;
}

XmlDecimal * MeasuredPointSetType::getcombinedUncertainty()
{return combinedUncertainty;}

void MeasuredPointSetType::setcombinedUncertainty(XmlDecimal * combinedUncertaintyIn)
{combinedUncertainty = combinedUncertaintyIn;}

NaturalType * MeasuredPointSetType::getcount()
{return count;}

void MeasuredPointSetType::setcount(NaturalType * countIn)
{count = countIn;}

XmlNonNegativeInteger * MeasuredPointSetType::getdecimalPlaces()
{return decimalPlaces;}

void MeasuredPointSetType::setdecimalPlaces(XmlNonNegativeInteger * decimalPlacesIn)
{decimalPlaces = decimalPlacesIn;}

QIFIdType * MeasuredPointSetType::getid()
{return id;}

void MeasuredPointSetType::setid(QIFIdType * idIn)
{id = idIn;}

XmlToken * MeasuredPointSetType::getlinearUnit()
{return linearUnit;}

void MeasuredPointSetType::setlinearUnit(XmlToken * linearUnitIn)
{linearUnit = linearUnitIn;}

XmlDecimal * MeasuredPointSetType::getmeanError()
{return meanError;}

void MeasuredPointSetType::setmeanError(XmlDecimal * meanErrorIn)
{meanError = meanErrorIn;}

XmlNonNegativeInteger * MeasuredPointSetType::getsignificantFigures()
{return significantFigures;}

void MeasuredPointSetType::setsignificantFigures(XmlNonNegativeInteger * significantFiguresIn)
{significantFigures = significantFiguresIn;}

ValidityEnumType * MeasuredPointSetType::getvalidity()
{return validity;}

void MeasuredPointSetType::setvalidity(ValidityEnumType * validityIn)
{validity = validityIn;}

XmlDecimal * MeasuredPointSetType::getxCombinedUncertainty()
{return xCombinedUncertainty;}

void MeasuredPointSetType::setxCombinedUncertainty(XmlDecimal * xCombinedUncertaintyIn)
{xCombinedUncertainty = xCombinedUncertaintyIn;}

XmlNonNegativeInteger * MeasuredPointSetType::getxDecimalPlaces()
{return xDecimalPlaces;}

void MeasuredPointSetType::setxDecimalPlaces(XmlNonNegativeInteger * xDecimalPlacesIn)
{xDecimalPlaces = xDecimalPlacesIn;}

XmlDecimal * MeasuredPointSetType::getxMeanError()
{return xMeanError;}

void MeasuredPointSetType::setxMeanError(XmlDecimal * xMeanErrorIn)
{xMeanError = xMeanErrorIn;}

XmlNonNegativeInteger * MeasuredPointSetType::getxSignificantFigures()
{return xSignificantFigures;}

void MeasuredPointSetType::setxSignificantFigures(XmlNonNegativeInteger * xSignificantFiguresIn)
{xSignificantFigures = xSignificantFiguresIn;}

ValidityEnumType * MeasuredPointSetType::getxValidity()
{return xValidity;}

void MeasuredPointSetType::setxValidity(ValidityEnumType * xValidityIn)
{xValidity = xValidityIn;}

XmlDecimal * MeasuredPointSetType::getyCombinedUncertainty()
{return yCombinedUncertainty;}

void MeasuredPointSetType::setyCombinedUncertainty(XmlDecimal * yCombinedUncertaintyIn)
{yCombinedUncertainty = yCombinedUncertaintyIn;}

XmlNonNegativeInteger * MeasuredPointSetType::getyDecimalPlaces()
{return yDecimalPlaces;}

void MeasuredPointSetType::setyDecimalPlaces(XmlNonNegativeInteger * yDecimalPlacesIn)
{yDecimalPlaces = yDecimalPlacesIn;}

XmlDecimal * MeasuredPointSetType::getyMeanError()
{return yMeanError;}

void MeasuredPointSetType::setyMeanError(XmlDecimal * yMeanErrorIn)
{yMeanError = yMeanErrorIn;}

XmlNonNegativeInteger * MeasuredPointSetType::getySignificantFigures()
{return ySignificantFigures;}

void MeasuredPointSetType::setySignificantFigures(XmlNonNegativeInteger * ySignificantFiguresIn)
{ySignificantFigures = ySignificantFiguresIn;}

ValidityEnumType * MeasuredPointSetType::getyValidity()
{return yValidity;}

void MeasuredPointSetType::setyValidity(ValidityEnumType * yValidityIn)
{yValidity = yValidityIn;}

XmlDecimal * MeasuredPointSetType::getzCombinedUncertainty()
{return zCombinedUncertainty;}

void MeasuredPointSetType::setzCombinedUncertainty(XmlDecimal * zCombinedUncertaintyIn)
{zCombinedUncertainty = zCombinedUncertaintyIn;}

XmlNonNegativeInteger * MeasuredPointSetType::getzDecimalPlaces()
{return zDecimalPlaces;}

void MeasuredPointSetType::setzDecimalPlaces(XmlNonNegativeInteger * zDecimalPlacesIn)
{zDecimalPlaces = zDecimalPlacesIn;}

XmlDecimal * MeasuredPointSetType::getzMeanError()
{return zMeanError;}

void MeasuredPointSetType::setzMeanError(XmlDecimal * zMeanErrorIn)
{zMeanError = zMeanErrorIn;}

XmlNonNegativeInteger * MeasuredPointSetType::getzSignificantFigures()
{return zSignificantFigures;}

void MeasuredPointSetType::setzSignificantFigures(XmlNonNegativeInteger * zSignificantFiguresIn)
{zSignificantFigures = zSignificantFiguresIn;}

ValidityEnumType * MeasuredPointSetType::getzValidity()
{return zValidity;}

void MeasuredPointSetType::setzValidity(ValidityEnumType * zValidityIn)
{zValidity = zValidityIn;}

AttributesType * MeasuredPointSetType::getAttributes()
{return Attributes;}

void MeasuredPointSetType::setAttributes(AttributesType * AttributesIn)
{Attributes = AttributesIn;}

OtherUnitsType * MeasuredPointSetType::getUnits()
{return Units;}

void MeasuredPointSetType::setUnits(OtherUnitsType * UnitsIn)
{Units = UnitsIn;}

MeasuredPointSe_1081_Type * MeasuredPointSetType::getMeasuredPointSe_1081()
{return MeasuredPointSe_1081;}

void MeasuredPointSetType::setMeasuredPointSe_1081(MeasuredPointSe_1081_Type * MeasuredPointSe_1081In)
{MeasuredPointSe_1081 = MeasuredPointSe_1081In;}

MeasuredPointSe_1082_Type * MeasuredPointSetType::getMeasuredPointSe_1082()
{return MeasuredPointSe_1082;}

void MeasuredPointSetType::setMeasuredPointSe_1082(MeasuredPointSe_1082_Type * MeasuredPointSe_1082In)
{MeasuredPointSe_1082 = MeasuredPointSe_1082In;}

MeasuredPointSe_1083_Type * MeasuredPointSetType::getMeasuredPointSe_1083()
{return MeasuredPointSe_1083;}

void MeasuredPointSetType::setMeasuredPointSe_1083(MeasuredPointSe_1083_Type * MeasuredPointSe_1083In)
{MeasuredPointSe_1083 = MeasuredPointSe_1083In;}

MeasuredPointSe_1084_Type * MeasuredPointSetType::getMeasuredPointSe_1084()
{return MeasuredPointSe_1084;}

void MeasuredPointSetType::setMeasuredPointSe_1084(MeasuredPointSe_1084_Type * MeasuredPointSe_1084In)
{MeasuredPointSe_1084 = MeasuredPointSe_1084In;}

MeasuredPointSe_1085_Type * MeasuredPointSetType::getMeasuredPointSe_1085()
{return MeasuredPointSe_1085;}

void MeasuredPointSetType::setMeasuredPointSe_1085(MeasuredPointSe_1085_Type * MeasuredPointSe_1085In)
{MeasuredPointSe_1085 = MeasuredPointSe_1085In;}

QIFReferenceType * MeasuredPointSetType::getMeasurementDeviceId()
{return MeasurementDeviceId;}

void MeasuredPointSetType::setMeasurementDeviceId(QIFReferenceType * MeasurementDeviceIdIn)
{MeasurementDeviceId = MeasurementDeviceIdIn;}

MeasuredPointSe_1086_Type * MeasuredPointSetType::getMeasuredPointSe_1086()
{return MeasuredPointSe_1086;}

void MeasuredPointSetType::setMeasuredPointSe_1086(MeasuredPointSe_1086_Type * MeasuredPointSe_1086In)
{MeasuredPointSe_1086 = MeasuredPointSe_1086In;}

MeasuredPointSe_1087_Type * MeasuredPointSetType::getMeasuredPointSe_1087()
{return MeasuredPointSe_1087;}

void MeasuredPointSetType::setMeasuredPointSe_1087(MeasuredPointSe_1087_Type * MeasuredPointSe_1087In)
{MeasuredPointSe_1087 = MeasuredPointSe_1087In;}

MeasuredPointSe_1088_Type * MeasuredPointSetType::getMeasuredPointSe_1088()
{return MeasuredPointSe_1088;}

void MeasuredPointSetType::setMeasuredPointSe_1088(MeasuredPointSe_1088_Type * MeasuredPointSe_1088In)
{MeasuredPointSe_1088 = MeasuredPointSe_1088In;}

MeasuredPointSe_1089_Type * MeasuredPointSetType::getMeasuredPointSe_1089()
{return MeasuredPointSe_1089;}

void MeasuredPointSetType::setMeasuredPointSe_1089(MeasuredPointSe_1089_Type * MeasuredPointSe_1089In)
{MeasuredPointSe_1089 = MeasuredPointSe_1089In;}

MeasuredPointSe_1090_Type * MeasuredPointSetType::getMeasuredPointSe_1090()
{return MeasuredPointSe_1090;}

void MeasuredPointSetType::setMeasuredPointSe_1090(MeasuredPointSe_1090_Type * MeasuredPointSe_1090In)
{MeasuredPointSe_1090 = MeasuredPointSe_1090In;}

MeasuredPointSe_1091_Type * MeasuredPointSetType::getMeasuredPointSe_1091()
{return MeasuredPointSe_1091;}

void MeasuredPointSetType::setMeasuredPointSe_1091(MeasuredPointSe_1091_Type * MeasuredPointSe_1091In)
{MeasuredPointSe_1091 = MeasuredPointSe_1091In;}

MeasuredPointSe_1092_Type * MeasuredPointSetType::getMeasuredPointSe_1092()
{return MeasuredPointSe_1092;}

void MeasuredPointSetType::setMeasuredPointSe_1092(MeasuredPointSe_1092_Type * MeasuredPointSe_1092In)
{MeasuredPointSe_1092 = MeasuredPointSe_1092In;}

MeasuredPointSe_1093_Type * MeasuredPointSetType::getMeasuredPointSe_1093()
{return MeasuredPointSe_1093;}

void MeasuredPointSetType::setMeasuredPointSe_1093(MeasuredPointSe_1093_Type * MeasuredPointSe_1093In)
{MeasuredPointSe_1093 = MeasuredPointSe_1093In;}

/* ***************************************************************** */

/* class MeasuredPointSetTypeLisd

*/

MeasuredPointSetTypeLisd::MeasuredPointSetTypeLisd() {}

MeasuredPointSetTypeLisd::MeasuredPointSetTypeLisd(MeasuredPointSetType * aMeasuredPointSetType)
{
  push_back(aMeasuredPointSetType);
}

MeasuredPointSetTypeLisd::~MeasuredPointSetTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<MeasuredPointSetType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void MeasuredPointSetTypeLisd::printSelf(FILE * outFile)
{
  std::list<MeasuredPointSetType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class MeasuredPointSetsType

*/

MeasuredPointSetsType::MeasuredPointSetsType()
{
  n = 0;
  MeasuredPointSet = 0;
}

MeasuredPointSetsType::MeasuredPointSetsType(
 MeasuredPointSetTypeLisd * MeasuredPointSetIn)
{
  n = 0;
  MeasuredPointSet = MeasuredPointSetIn;
}

MeasuredPointSetsType::MeasuredPointSetsType(
 NaturalType * nIn,
 MeasuredPointSetTypeLisd * MeasuredPointSetIn)
{
  n = nIn;
  MeasuredPointSet = MeasuredPointSetIn;
}

MeasuredPointSetsType::~MeasuredPointSetsType()
{
  #ifndef NODESTRUCT
  delete n;
  delete MeasuredPointSet;
  #endif
}

void MeasuredPointSetsType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!MeasuredPointSet)
      {
        fprintf(stderr, "MeasuredPointSet list is missing\n");
        exit(1);
      }
    if (MeasuredPointSet->size() == 0)
      {
        fprintf(stderr, "MeasuredPointSet list is empty\n");
        exit(1);
      }
    if (MeasuredPointSet->size() < 1)
      {
        fprintf(stderr,
                "size of MeasuredPointSet list (%d) less than minimum required (1)\n",
                (int)MeasuredPointSet->size());
        exit(1);
      }
    std::list<MeasuredPointSetType *>::iterator iter;
    for (iter = MeasuredPointSet->begin();
         iter != MeasuredPointSet->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<MeasuredPointSet");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</MeasuredPointSet>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool MeasuredPointSetsType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in MeasuredPointSetsType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in MeasuredPointSetsType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in MeasuredPointSetsType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in MeasuredPointSetsType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * MeasuredPointSetsType::getn()
{return n;}

void MeasuredPointSetsType::setn(NaturalType * nIn)
{n = nIn;}

MeasuredPointSetTypeLisd * MeasuredPointSetsType::getMeasuredPointSet()
{return MeasuredPointSet;}

void MeasuredPointSetsType::setMeasuredPointSet(MeasuredPointSetTypeLisd * MeasuredPointSetIn)
{MeasuredPointSet = MeasuredPointSetIn;}

/* ***************************************************************** */

/* class NominalPointSetListType

*/

NominalPointSetListType::NominalPointSetListType()
{
  n = 0;
  NominalPointSet = 0;
}

NominalPointSetListType::NominalPointSetListType(
 PointSetNominalTypeLisd * NominalPointSetIn)
{
  n = 0;
  NominalPointSet = NominalPointSetIn;
}

NominalPointSetListType::NominalPointSetListType(
 NaturalType * nIn,
 PointSetNominalTypeLisd * NominalPointSetIn)
{
  n = nIn;
  NominalPointSet = NominalPointSetIn;
}

NominalPointSetListType::~NominalPointSetListType()
{
  #ifndef NODESTRUCT
  delete n;
  delete NominalPointSet;
  #endif
}

void NominalPointSetListType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!NominalPointSet)
      {
        fprintf(stderr, "NominalPointSet list is missing\n");
        exit(1);
      }
    if (NominalPointSet->size() == 0)
      {
        fprintf(stderr, "NominalPointSet list is empty\n");
        exit(1);
      }
    if (NominalPointSet->size() < 1)
      {
        fprintf(stderr,
                "size of NominalPointSet list (%d) less than minimum required (1)\n",
                (int)NominalPointSet->size());
        exit(1);
      }
    std::list<PointSetNominalType *>::iterator iter;
    for (iter = NominalPointSet->begin();
         iter != NominalPointSet->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<NominalPointSet");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</NominalPointSet>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool NominalPointSetListType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in NominalPointSetListType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in NominalPointSetListType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in NominalPointSetListType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in NominalPointSetListType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * NominalPointSetListType::getn()
{return n;}

void NominalPointSetListType::setn(NaturalType * nIn)
{n = nIn;}

PointSetNominalTypeLisd * NominalPointSetListType::getNominalPointSet()
{return NominalPointSet;}

void NominalPointSetListType::setNominalPointSet(PointSetNominalTypeLisd * NominalPointSetIn)
{NominalPointSet = NominalPointSetIn;}

/* ***************************************************************** */

/* class NonShapeFeatureDefinitionBaseType

*/

NonShapeFeatureDefinitionBaseType::NonShapeFeatureDefinitionBaseType() :
  FeatureDefinitionBaseType()
{
}

NonShapeFeatureDefinitionBaseType::NonShapeFeatureDefinitionBaseType(
 AttributesType * AttributesIn) :
  FeatureDefinitionBaseType(
    AttributesIn)
{
}

NonShapeFeatureDefinitionBaseType::NonShapeFeatureDefinitionBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn) :
  FeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
}

NonShapeFeatureDefinitionBaseType::~NonShapeFeatureDefinitionBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void NonShapeFeatureDefinitionBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool NonShapeFeatureDefinitionBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in NonShapeFeatureDefinitionBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in NonShapeFeatureDefinitionBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in NonShapeFeatureDefinitionBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in NonShapeFeatureDefinitionBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class NonShapeFeatureItemBaseType

*/

NonShapeFeatureItemBaseType::NonShapeFeatureItemBaseType() :
  FeatureItemBaseType()
{
}

NonShapeFeatureItemBaseType::NonShapeFeatureItemBaseType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn) :
  FeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn)
{
}

NonShapeFeatureItemBaseType::NonShapeFeatureItemBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn) :
  FeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn)
{
}

NonShapeFeatureItemBaseType::~NonShapeFeatureItemBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void NonShapeFeatureItemBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool NonShapeFeatureItemBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in NonShapeFeatureItemBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in NonShapeFeatureItemBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in NonShapeFeatureItemBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in NonShapeFeatureItemBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class NonShapeFeatureMeasurementBaseType

*/

NonShapeFeatureMeasurementBaseType::NonShapeFeatureMeasurementBaseType() :
  FeatureMeasurementBaseType()
{
}

NonShapeFeatureMeasurementBaseType::NonShapeFeatureMeasurementBaseType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn) :
  FeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn)
{
}

NonShapeFeatureMeasurementBaseType::NonShapeFeatureMeasurementBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn) :
  FeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn)
{
}

NonShapeFeatureMeasurementBaseType::~NonShapeFeatureMeasurementBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void NonShapeFeatureMeasurementBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool NonShapeFeatureMeasurementBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in NonShapeFeatureMeasurementBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in NonShapeFeatureMeasurementBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in NonShapeFeatureMeasurementBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in NonShapeFeatureMeasurementBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class NonShapeFeatureNominalBaseType

*/

NonShapeFeatureNominalBaseType::NonShapeFeatureNominalBaseType() :
  FeatureNominalBaseType()
{
}

NonShapeFeatureNominalBaseType::NonShapeFeatureNominalBaseType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn) :
  FeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn)
{
}

NonShapeFeatureNominalBaseType::NonShapeFeatureNominalBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn) :
  FeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn)
{
}

NonShapeFeatureNominalBaseType::~NonShapeFeatureNominalBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void NonShapeFeatureNominalBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool NonShapeFeatureNominalBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in NonShapeFeatureNominalBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in NonShapeFeatureNominalBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in NonShapeFeatureNominalBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in NonShapeFeatureNominalBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class OppositeAngledLinesBestFitType

*/

OppositeAngledLinesBestFitType::OppositeAngledLinesBestFitType() :
  ConstructionMethodBaseType()
{
  n = 0;
  BaseFeature = 0;
}

OppositeAngledLinesBestFitType::OppositeAngledLinesBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = 0;
  BaseFeature = BaseFeatureIn;
}

OppositeAngledLinesBestFitType::OppositeAngledLinesBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 NaturalType * nIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = nIn;
  BaseFeature = BaseFeatureIn;
}

OppositeAngledLinesBestFitType::~OppositeAngledLinesBestFitType()
{
  #ifndef NODESTRUCT
  delete n;
  delete BaseFeature;
  #endif
}

void OppositeAngledLinesBestFitType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  {
    if (!BaseFeature)
      {
        fprintf(stderr, "BaseFeature list is missing\n");
        exit(1);
      }
    if (BaseFeature->size() == 0)
      {
        fprintf(stderr, "BaseFeature list is empty\n");
        exit(1);
      }
    if (BaseFeature->size() < 4)
      {
        fprintf(stderr,
                "size of BaseFeature list (%d) less than minimum required (4)\n",
                (int)BaseFeature->size());
        exit(1);
      }
    std::list<SequencedBaseFeatureType *>::iterator iter;
    for (iter = BaseFeature->begin();
         iter != BaseFeature->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<BaseFeature");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</BaseFeature>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool OppositeAngledLinesBestFitType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in OppositeAngledLinesBestFitType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in OppositeAngledLinesBestFitType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OppositeAngledLinesBestFitType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in OppositeAngledLinesBestFitType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * OppositeAngledLinesBestFitType::getn()
{return n;}

void OppositeAngledLinesBestFitType::setn(NaturalType * nIn)
{n = nIn;}

SequencedBaseFeatureTypeLisd * OppositeAngledLinesBestFitType::getBaseFeature()
{return BaseFeature;}

void OppositeAngledLinesBestFitType::setBaseFeature(SequencedBaseFeatureTypeLisd * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class OppositeAngledLinesCastType

*/

OppositeAngledLinesCastType::OppositeAngledLinesCastType() :
  ConstructionMethodBaseType()
{
  BaseFeature = 0;
}

OppositeAngledLinesCastType::OppositeAngledLinesCastType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeature = BaseFeatureIn;
}

OppositeAngledLinesCastType::~OppositeAngledLinesCastType()
{
  #ifndef NODESTRUCT
  delete BaseFeature;
  #endif
}

void OppositeAngledLinesCastType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeature");
  BaseFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * OppositeAngledLinesCastType::getBaseFeature()
{return BaseFeature;}

void OppositeAngledLinesCastType::setBaseFeature(BaseFeatureType * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class OppositeAngledLinesCheckedFeatureType

*/

OppositeAngledLinesCheckedFeatureType::OppositeAngledLinesCheckedFeatureType()
{
  CheckDetails = 0;
}

OppositeAngledLinesCheckedFeatureType::OppositeAngledLinesCheckedFeatureType(
 OppositeAngledLinesCheckedType * CheckDetailsIn)
{
  CheckDetails = CheckDetailsIn;
}

OppositeAngledLinesCheckedFeatureType::~OppositeAngledLinesCheckedFeatureType()
{
  #ifndef NODESTRUCT
  delete CheckDetails;
  #endif
}

void OppositeAngledLinesCheckedFeatureType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (CheckDetails)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CheckDetails");
      CheckDetails->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CheckDetails>\n");
    }
  doSpaces(-INDENT, outFile);
}

OppositeAngledLinesCheckedType * OppositeAngledLinesCheckedFeatureType::getCheckDetails()
{return CheckDetails;}

void OppositeAngledLinesCheckedFeatureType::setCheckDetails(OppositeAngledLinesCheckedType * CheckDetailsIn)
{CheckDetails = CheckDetailsIn;}

/* ***************************************************************** */

/* class OppositeAngledLinesCheckedType

*/

OppositeAngledLinesCheckedType::OppositeAngledLinesCheckedType()
{
  OppositeAngledLinesCheckedTypePair = 0;
}

OppositeAngledLinesCheckedType::OppositeAngledLinesCheckedType(
 OppositeAngledLinesCheckedTypeChoicePair * OppositeAngledLinesCheckedTypePairIn)
{
  OppositeAngledLinesCheckedTypePair = OppositeAngledLinesCheckedTypePairIn;
}

OppositeAngledLinesCheckedType::~OppositeAngledLinesCheckedType()
{
  #ifndef NODESTRUCT
  delete OppositeAngledLinesCheckedTypePair;
  #endif
}

void OppositeAngledLinesCheckedType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  OppositeAngledLinesCheckedTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

OppositeAngledLinesCheckedTypeChoicePair * OppositeAngledLinesCheckedType::getOppositeAngledLinesCheckedTypePair()
{return OppositeAngledLinesCheckedTypePair;}

void OppositeAngledLinesCheckedType::setOppositeAngledLinesCheckedTypePair(OppositeAngledLinesCheckedTypeChoicePair * OppositeAngledLinesCheckedTypePairIn)
{OppositeAngledLinesCheckedTypePair = OppositeAngledLinesCheckedTypePairIn;}
OppositeAngledLinesCheckedTypeChoicePair::OppositeAngledLinesCheckedTypeChoicePair() {}

OppositeAngledLinesCheckedTypeChoicePair::OppositeAngledLinesCheckedTypeChoicePair(
 whichOne OppositeAngledLinesCheckedTypeTypeIn,
 OppositeAngledLinesCheckedTypeVal * OppositeAngledLinesCheckedTypeValueIn)
{
  OppositeAngledLinesCheckedTypeType = OppositeAngledLinesCheckedTypeTypeIn;
  OppositeAngledLinesCheckedTypeValue = OppositeAngledLinesCheckedTypeValueIn;
}

OppositeAngledLinesCheckedTypeChoicePair::~OppositeAngledLinesCheckedTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (OppositeAngledLinesCheckedTypeType == MeasuredE)
    delete OppositeAngledLinesCheckedTypeValue->Measured;
  else if (OppositeAngledLinesCheckedTypeType == ConstructedE)
    delete OppositeAngledLinesCheckedTypeValue->Constructed;
  delete OppositeAngledLinesCheckedTypeValue;
  #endif
}

void OppositeAngledLinesCheckedTypeChoicePair::printSelf(FILE * outFile)
{
  if (OppositeAngledLinesCheckedTypeType == MeasuredE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Measured");
      OppositeAngledLinesCheckedTypeValue->Measured->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Measured>\n");
    }
  else if (OppositeAngledLinesCheckedTypeType == ConstructedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      OppositeAngledLinesCheckedTypeValue->Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
}

/* ***************************************************************** */

/* class OppositeAngledLinesConstructionMethodType

*/

OppositeAngledLinesConstructionMethodType::OppositeAngledLinesConstructionMethodType()
{
  OppositeAngledLinesConstructionMethodTypePair = 0;
}

OppositeAngledLinesConstructionMethodType::OppositeAngledLinesConstructionMethodType(
 OppositeAngledLinesConstructionMethodTypeChoicePair * OppositeAngledLinesConstructionMethodTypePairIn)
{
  OppositeAngledLinesConstructionMethodTypePair = OppositeAngledLinesConstructionMethodTypePairIn;
}

OppositeAngledLinesConstructionMethodType::~OppositeAngledLinesConstructionMethodType()
{
  #ifndef NODESTRUCT
  delete OppositeAngledLinesConstructionMethodTypePair;
  #endif
}

void OppositeAngledLinesConstructionMethodType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (OppositeAngledLinesConstructionMethodTypePair)
    {
      OppositeAngledLinesConstructionMethodTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

OppositeAngledLinesConstructionMethodTypeChoicePair * OppositeAngledLinesConstructionMethodType::getOppositeAngledLinesConstructionMethodTypePair()
{return OppositeAngledLinesConstructionMethodTypePair;}

void OppositeAngledLinesConstructionMethodType::setOppositeAngledLinesConstructionMethodTypePair(OppositeAngledLinesConstructionMethodTypeChoicePair * OppositeAngledLinesConstructionMethodTypePairIn)
{OppositeAngledLinesConstructionMethodTypePair = OppositeAngledLinesConstructionMethodTypePairIn;}
OppositeAngledLinesConstructionMethodTypeChoicePair::OppositeAngledLinesConstructionMethodTypeChoicePair() {}

OppositeAngledLinesConstructionMethodTypeChoicePair::OppositeAngledLinesConstructionMethodTypeChoicePair(
 whichOne OppositeAngledLinesConstructionMethodTypeTypeIn,
 OppositeAngledLinesConstructionMethodTypeVal * OppositeAngledLinesConstructionMethodTypeValueIn)
{
  OppositeAngledLinesConstructionMethodTypeType = OppositeAngledLinesConstructionMethodTypeTypeIn;
  OppositeAngledLinesConstructionMethodTypeValue = OppositeAngledLinesConstructionMethodTypeValueIn;
}

OppositeAngledLinesConstructionMethodTypeChoicePair::~OppositeAngledLinesConstructionMethodTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (OppositeAngledLinesConstructionMethodTypeType == BestFitE)
    delete OppositeAngledLinesConstructionMethodTypeValue->BestFit;
  else if (OppositeAngledLinesConstructionMethodTypeType == RecompensatedE)
    delete OppositeAngledLinesConstructionMethodTypeValue->Recompensated;
  else if (OppositeAngledLinesConstructionMethodTypeType == IntersectionE)
    delete OppositeAngledLinesConstructionMethodTypeValue->Intersection;
  else if (OppositeAngledLinesConstructionMethodTypeType == ProjectionE)
    delete OppositeAngledLinesConstructionMethodTypeValue->Projection;
  else if (OppositeAngledLinesConstructionMethodTypeType == CopyE)
    delete OppositeAngledLinesConstructionMethodTypeValue->Copy;
  else if (OppositeAngledLinesConstructionMethodTypeType == CastE)
    delete OppositeAngledLinesConstructionMethodTypeValue->Cast;
  else if (OppositeAngledLinesConstructionMethodTypeType == TransformE)
    delete OppositeAngledLinesConstructionMethodTypeValue->Transform;
  else if (OppositeAngledLinesConstructionMethodTypeType == FromScanE)
    delete OppositeAngledLinesConstructionMethodTypeValue->FromScan;
  delete OppositeAngledLinesConstructionMethodTypeValue;
  #endif
}

void OppositeAngledLinesConstructionMethodTypeChoicePair::printSelf(FILE * outFile)
{
  if (OppositeAngledLinesConstructionMethodTypeType == BestFitE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BestFit");
      OppositeAngledLinesConstructionMethodTypeValue->BestFit->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BestFit>\n");
    }
  else if (OppositeAngledLinesConstructionMethodTypeType == RecompensatedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Recompensated");
      OppositeAngledLinesConstructionMethodTypeValue->Recompensated->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Recompensated>\n");
    }
  else if (OppositeAngledLinesConstructionMethodTypeType == IntersectionE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Intersection");
      OppositeAngledLinesConstructionMethodTypeValue->Intersection->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Intersection>\n");
    }
  else if (OppositeAngledLinesConstructionMethodTypeType == ProjectionE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Projection");
      OppositeAngledLinesConstructionMethodTypeValue->Projection->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Projection>\n");
    }
  else if (OppositeAngledLinesConstructionMethodTypeType == CopyE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Copy");
      OppositeAngledLinesConstructionMethodTypeValue->Copy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Copy>\n");
    }
  else if (OppositeAngledLinesConstructionMethodTypeType == CastE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Cast");
      OppositeAngledLinesConstructionMethodTypeValue->Cast->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Cast>\n");
    }
  else if (OppositeAngledLinesConstructionMethodTypeType == TransformE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Transform");
      OppositeAngledLinesConstructionMethodTypeValue->Transform->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Transform>\n");
    }
  else if (OppositeAngledLinesConstructionMethodTypeType == FromScanE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FromScan");
      OppositeAngledLinesConstructionMethodTypeValue->FromScan->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FromScan>\n");
    }
}

/* ***************************************************************** */

/* class OppositeAngledLinesCopyType

*/

OppositeAngledLinesCopyType::OppositeAngledLinesCopyType() :
  ConstructionMethodBaseType()
{
  BaseOppositeAngledLines = 0;
}

OppositeAngledLinesCopyType::OppositeAngledLinesCopyType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseOppositeAngledLinesIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseOppositeAngledLines = BaseOppositeAngledLinesIn;
}

OppositeAngledLinesCopyType::~OppositeAngledLinesCopyType()
{
  #ifndef NODESTRUCT
  delete BaseOppositeAngledLines;
  #endif
}

void OppositeAngledLinesCopyType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseOppositeAngledLines");
  BaseOppositeAngledLines->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseOppositeAngledLines>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * OppositeAngledLinesCopyType::getBaseOppositeAngledLines()
{return BaseOppositeAngledLines;}

void OppositeAngledLinesCopyType::setBaseOppositeAngledLines(BaseFeatureType * BaseOppositeAngledLinesIn)
{BaseOppositeAngledLines = BaseOppositeAngledLinesIn;}

/* ***************************************************************** */

/* class OppositeAngledLinesFeatureDefinitionType

*/

OppositeAngledLinesFeatureDefinitionType::OppositeAngledLinesFeatureDefinitionType() :
  CurveFeatureDefinitionBaseType()
{
  InternalExternal = 0;
  Width = 0;
  Length = 0;
  EndType = 0;
  TaperAngle = 0;
  SingleOpenEnd = 0;
  EndRadius1 = 0;
  EndRadius2 = 0;
}

OppositeAngledLinesFeatureDefinitionType::OppositeAngledLinesFeatureDefinitionType(
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * WidthIn,
 LinearValueType * LengthIn,
 SlotEndType * EndTypeIn,
 AngularValueType * TaperAngleIn,
 XmlBoolean * SingleOpenEndIn,
 EndRadiusType * EndRadius1In,
 EndRadiusType * EndRadius2In) :
  CurveFeatureDefinitionBaseType(
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  Width = WidthIn;
  Length = LengthIn;
  EndType = EndTypeIn;
  TaperAngle = TaperAngleIn;
  SingleOpenEnd = SingleOpenEndIn;
  EndRadius1 = EndRadius1In;
  EndRadius2 = EndRadius2In;
}

OppositeAngledLinesFeatureDefinitionType::OppositeAngledLinesFeatureDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * WidthIn,
 LinearValueType * LengthIn,
 SlotEndType * EndTypeIn,
 AngularValueType * TaperAngleIn,
 XmlBoolean * SingleOpenEndIn,
 EndRadiusType * EndRadius1In,
 EndRadiusType * EndRadius2In) :
  CurveFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  Width = WidthIn;
  Length = LengthIn;
  EndType = EndTypeIn;
  TaperAngle = TaperAngleIn;
  SingleOpenEnd = SingleOpenEndIn;
  EndRadius1 = EndRadius1In;
  EndRadius2 = EndRadius2In;
}

OppositeAngledLinesFeatureDefinitionType::~OppositeAngledLinesFeatureDefinitionType()
{
  #ifndef NODESTRUCT
  delete InternalExternal;
  delete Width;
  delete Length;
  delete EndType;
  delete TaperAngle;
  delete SingleOpenEnd;
  delete EndRadius1;
  delete EndRadius2;
  #endif
}

void OppositeAngledLinesFeatureDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<InternalExternal");
  InternalExternal->printSelf(outFile);
  fprintf(outFile, "</InternalExternal>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Width");
  Width->printSelf(outFile);
  fprintf(outFile, "</Width>\n");
  if (Length)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Length");
      Length->printSelf(outFile);
      fprintf(outFile, "</Length>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<EndType");
  EndType->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</EndType>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<TaperAngle");
  TaperAngle->printSelf(outFile);
  fprintf(outFile, "</TaperAngle>\n");
  if (SingleOpenEnd)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SingleOpenEnd");
      SingleOpenEnd->printSelf(outFile);
      fprintf(outFile, "</SingleOpenEnd>\n");
    }
  if (EndRadius1)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EndRadius1");
      EndRadius1->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EndRadius1>\n");
    }
  if (EndRadius2)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EndRadius2");
      EndRadius2->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EndRadius2>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool OppositeAngledLinesFeatureDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OppositeAngledLinesFeatureDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OppositeAngledLinesFeatureDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OppositeAngledLinesFeatureDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OppositeAngledLinesFeatureDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

InternalExternalEnumType * OppositeAngledLinesFeatureDefinitionType::getInternalExternal()
{return InternalExternal;}

void OppositeAngledLinesFeatureDefinitionType::setInternalExternal(InternalExternalEnumType * InternalExternalIn)
{InternalExternal = InternalExternalIn;}

LinearValueType * OppositeAngledLinesFeatureDefinitionType::getWidth()
{return Width;}

void OppositeAngledLinesFeatureDefinitionType::setWidth(LinearValueType * WidthIn)
{Width = WidthIn;}

LinearValueType * OppositeAngledLinesFeatureDefinitionType::getLength()
{return Length;}

void OppositeAngledLinesFeatureDefinitionType::setLength(LinearValueType * LengthIn)
{Length = LengthIn;}

SlotEndType * OppositeAngledLinesFeatureDefinitionType::getEndType()
{return EndType;}

void OppositeAngledLinesFeatureDefinitionType::setEndType(SlotEndType * EndTypeIn)
{EndType = EndTypeIn;}

AngularValueType * OppositeAngledLinesFeatureDefinitionType::getTaperAngle()
{return TaperAngle;}

void OppositeAngledLinesFeatureDefinitionType::setTaperAngle(AngularValueType * TaperAngleIn)
{TaperAngle = TaperAngleIn;}

XmlBoolean * OppositeAngledLinesFeatureDefinitionType::getSingleOpenEnd()
{return SingleOpenEnd;}

void OppositeAngledLinesFeatureDefinitionType::setSingleOpenEnd(XmlBoolean * SingleOpenEndIn)
{SingleOpenEnd = SingleOpenEndIn;}

EndRadiusType * OppositeAngledLinesFeatureDefinitionType::getEndRadius1()
{return EndRadius1;}

void OppositeAngledLinesFeatureDefinitionType::setEndRadius1(EndRadiusType * EndRadius1In)
{EndRadius1 = EndRadius1In;}

EndRadiusType * OppositeAngledLinesFeatureDefinitionType::getEndRadius2()
{return EndRadius2;}

void OppositeAngledLinesFeatureDefinitionType::setEndRadius2(EndRadiusType * EndRadius2In)
{EndRadius2 = EndRadius2In;}

/* ***************************************************************** */

/* class OppositeAngledLinesFeatureItemType

*/

OppositeAngledLinesFeatureItemType::OppositeAngledLinesFeatureItemType() :
  CurveFeatureItemBaseType()
{
  DeterminationMode = 0;
}

OppositeAngledLinesFeatureItemType::OppositeAngledLinesFeatureItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 OppositeAngledLinesMeasurementDeterminationType * DeterminationModeIn) :
  CurveFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

OppositeAngledLinesFeatureItemType::OppositeAngledLinesFeatureItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 OppositeAngledLinesMeasurementDeterminationType * DeterminationModeIn) :
  CurveFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

OppositeAngledLinesFeatureItemType::~OppositeAngledLinesFeatureItemType()
{
  #ifndef NODESTRUCT
  delete DeterminationMode;
  #endif
}

void OppositeAngledLinesFeatureItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<DeterminationMode");
  DeterminationMode->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeterminationMode>\n");
  doSpaces(-INDENT, outFile);
}

bool OppositeAngledLinesFeatureItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OppositeAngledLinesFeatureItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OppositeAngledLinesFeatureItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OppositeAngledLinesFeatureItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OppositeAngledLinesFeatureItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

OppositeAngledLinesMeasurementDeterminationType * OppositeAngledLinesFeatureItemType::getDeterminationMode()
{return DeterminationMode;}

void OppositeAngledLinesFeatureItemType::setDeterminationMode(OppositeAngledLinesMeasurementDeterminationType * DeterminationModeIn)
{DeterminationMode = DeterminationModeIn;}

/* ***************************************************************** */

/* class OppositeAngledLinesFeatureMeasurementType

*/

OppositeAngledLinesFeatureMeasurementType::OppositeAngledLinesFeatureMeasurementType() :
  CurveFeatureMeasurementBaseType()
{
  CenterLine = 0;
  Normal = 0;
  Width = 0;
  WidthMin = 0;
  WidthMax = 0;
  Length = 0;
  LengthMin = 0;
  LengthMax = 0;
  TaperAngle = 0;
  EndRadius1 = 0;
  EndRadius2 = 0;
  Form = 0;
}

OppositeAngledLinesFeatureMeasurementType::OppositeAngledLinesFeatureMeasurementType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredPointAndVectorType * CenterLineIn,
 MeasuredUnitVectorType * NormalIn,
 MeasuredLinearValueType * WidthIn,
 MeasuredLinearValueType * WidthMinIn,
 MeasuredLinearValueType * WidthMaxIn,
 MeasuredLinearValueType * LengthIn,
 MeasuredLinearValueType * LengthMinIn,
 MeasuredLinearValueType * LengthMaxIn,
 MeasuredAngularValueType * TaperAngleIn,
 MeasuredEndRadiusType * EndRadius1In,
 MeasuredEndRadiusType * EndRadius2In,
 MeasuredLinearValueType * FormIn) :
  CurveFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  CenterLine = CenterLineIn;
  Normal = NormalIn;
  Width = WidthIn;
  WidthMin = WidthMinIn;
  WidthMax = WidthMaxIn;
  Length = LengthIn;
  LengthMin = LengthMinIn;
  LengthMax = LengthMaxIn;
  TaperAngle = TaperAngleIn;
  EndRadius1 = EndRadius1In;
  EndRadius2 = EndRadius2In;
  Form = FormIn;
}

OppositeAngledLinesFeatureMeasurementType::OppositeAngledLinesFeatureMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredPointAndVectorType * CenterLineIn,
 MeasuredUnitVectorType * NormalIn,
 MeasuredLinearValueType * WidthIn,
 MeasuredLinearValueType * WidthMinIn,
 MeasuredLinearValueType * WidthMaxIn,
 MeasuredLinearValueType * LengthIn,
 MeasuredLinearValueType * LengthMinIn,
 MeasuredLinearValueType * LengthMaxIn,
 MeasuredAngularValueType * TaperAngleIn,
 MeasuredEndRadiusType * EndRadius1In,
 MeasuredEndRadiusType * EndRadius2In,
 MeasuredLinearValueType * FormIn) :
  CurveFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  CenterLine = CenterLineIn;
  Normal = NormalIn;
  Width = WidthIn;
  WidthMin = WidthMinIn;
  WidthMax = WidthMaxIn;
  Length = LengthIn;
  LengthMin = LengthMinIn;
  LengthMax = LengthMaxIn;
  TaperAngle = TaperAngleIn;
  EndRadius1 = EndRadius1In;
  EndRadius2 = EndRadius2In;
  Form = FormIn;
}

OppositeAngledLinesFeatureMeasurementType::~OppositeAngledLinesFeatureMeasurementType()
{
  #ifndef NODESTRUCT
  delete CenterLine;
  delete Normal;
  delete Width;
  delete WidthMin;
  delete WidthMax;
  delete Length;
  delete LengthMin;
  delete LengthMax;
  delete TaperAngle;
  delete EndRadius1;
  delete EndRadius2;
  delete Form;
  #endif
}

void OppositeAngledLinesFeatureMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  if (CenterLine)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CenterLine");
      CenterLine->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CenterLine>\n");
    }
  if (Normal)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Normal");
      Normal->printSelf(outFile);
      fprintf(outFile, "</Normal>\n");
    }
  if (Width)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Width");
      Width->printSelf(outFile);
      fprintf(outFile, "</Width>\n");
    }
  if (WidthMin)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WidthMin");
      WidthMin->printSelf(outFile);
      fprintf(outFile, "</WidthMin>\n");
    }
  if (WidthMax)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WidthMax");
      WidthMax->printSelf(outFile);
      fprintf(outFile, "</WidthMax>\n");
    }
  if (Length)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Length");
      Length->printSelf(outFile);
      fprintf(outFile, "</Length>\n");
    }
  if (LengthMin)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LengthMin");
      LengthMin->printSelf(outFile);
      fprintf(outFile, "</LengthMin>\n");
    }
  if (LengthMax)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LengthMax");
      LengthMax->printSelf(outFile);
      fprintf(outFile, "</LengthMax>\n");
    }
  if (TaperAngle)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TaperAngle");
      TaperAngle->printSelf(outFile);
      fprintf(outFile, "</TaperAngle>\n");
    }
  if (EndRadius1)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EndRadius1");
      EndRadius1->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EndRadius1>\n");
    }
  if (EndRadius2)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EndRadius2");
      EndRadius2->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EndRadius2>\n");
    }
  if (Form)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Form");
      Form->printSelf(outFile);
      fprintf(outFile, "</Form>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool OppositeAngledLinesFeatureMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OppositeAngledLinesFeatureMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OppositeAngledLinesFeatureMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OppositeAngledLinesFeatureMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OppositeAngledLinesFeatureMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredPointAndVectorType * OppositeAngledLinesFeatureMeasurementType::getCenterLine()
{return CenterLine;}

void OppositeAngledLinesFeatureMeasurementType::setCenterLine(MeasuredPointAndVectorType * CenterLineIn)
{CenterLine = CenterLineIn;}

MeasuredUnitVectorType * OppositeAngledLinesFeatureMeasurementType::getNormal()
{return Normal;}

void OppositeAngledLinesFeatureMeasurementType::setNormal(MeasuredUnitVectorType * NormalIn)
{Normal = NormalIn;}

MeasuredLinearValueType * OppositeAngledLinesFeatureMeasurementType::getWidth()
{return Width;}

void OppositeAngledLinesFeatureMeasurementType::setWidth(MeasuredLinearValueType * WidthIn)
{Width = WidthIn;}

MeasuredLinearValueType * OppositeAngledLinesFeatureMeasurementType::getWidthMin()
{return WidthMin;}

void OppositeAngledLinesFeatureMeasurementType::setWidthMin(MeasuredLinearValueType * WidthMinIn)
{WidthMin = WidthMinIn;}

MeasuredLinearValueType * OppositeAngledLinesFeatureMeasurementType::getWidthMax()
{return WidthMax;}

void OppositeAngledLinesFeatureMeasurementType::setWidthMax(MeasuredLinearValueType * WidthMaxIn)
{WidthMax = WidthMaxIn;}

MeasuredLinearValueType * OppositeAngledLinesFeatureMeasurementType::getLength()
{return Length;}

void OppositeAngledLinesFeatureMeasurementType::setLength(MeasuredLinearValueType * LengthIn)
{Length = LengthIn;}

MeasuredLinearValueType * OppositeAngledLinesFeatureMeasurementType::getLengthMin()
{return LengthMin;}

void OppositeAngledLinesFeatureMeasurementType::setLengthMin(MeasuredLinearValueType * LengthMinIn)
{LengthMin = LengthMinIn;}

MeasuredLinearValueType * OppositeAngledLinesFeatureMeasurementType::getLengthMax()
{return LengthMax;}

void OppositeAngledLinesFeatureMeasurementType::setLengthMax(MeasuredLinearValueType * LengthMaxIn)
{LengthMax = LengthMaxIn;}

MeasuredAngularValueType * OppositeAngledLinesFeatureMeasurementType::getTaperAngle()
{return TaperAngle;}

void OppositeAngledLinesFeatureMeasurementType::setTaperAngle(MeasuredAngularValueType * TaperAngleIn)
{TaperAngle = TaperAngleIn;}

MeasuredEndRadiusType * OppositeAngledLinesFeatureMeasurementType::getEndRadius1()
{return EndRadius1;}

void OppositeAngledLinesFeatureMeasurementType::setEndRadius1(MeasuredEndRadiusType * EndRadius1In)
{EndRadius1 = EndRadius1In;}

MeasuredEndRadiusType * OppositeAngledLinesFeatureMeasurementType::getEndRadius2()
{return EndRadius2;}

void OppositeAngledLinesFeatureMeasurementType::setEndRadius2(MeasuredEndRadiusType * EndRadius2In)
{EndRadius2 = EndRadius2In;}

MeasuredLinearValueType * OppositeAngledLinesFeatureMeasurementType::getForm()
{return Form;}

void OppositeAngledLinesFeatureMeasurementType::setForm(MeasuredLinearValueType * FormIn)
{Form = FormIn;}

/* ***************************************************************** */

/* class OppositeAngledLinesFeatureNominalType

*/

OppositeAngledLinesFeatureNominalType::OppositeAngledLinesFeatureNominalType() :
  CurveFeatureNominalBaseType()
{
  CenterLine = 0;
  Normal = 0;
  Constructed = 0;
}

OppositeAngledLinesFeatureNominalType::OppositeAngledLinesFeatureNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 PointAndVectorType * CenterLineIn,
 UnitVectorType * NormalIn,
 OppositeAngledLinesConstructionMethodType * ConstructedIn) :
  CurveFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    SurfaceFeatureNominalIdIn)
{
  CenterLine = CenterLineIn;
  Normal = NormalIn;
  Constructed = ConstructedIn;
}

OppositeAngledLinesFeatureNominalType::OppositeAngledLinesFeatureNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 PointAndVectorType * CenterLineIn,
 UnitVectorType * NormalIn,
 OppositeAngledLinesConstructionMethodType * ConstructedIn) :
  CurveFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    SurfaceFeatureNominalIdIn)
{
  CenterLine = CenterLineIn;
  Normal = NormalIn;
  Constructed = ConstructedIn;
}

OppositeAngledLinesFeatureNominalType::~OppositeAngledLinesFeatureNominalType()
{
  #ifndef NODESTRUCT
  delete CenterLine;
  delete Normal;
  delete Constructed;
  #endif
}

void OppositeAngledLinesFeatureNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (SurfaceFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SurfaceFeatureNominalId");
      SurfaceFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</SurfaceFeatureNominalId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CenterLine");
  CenterLine->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</CenterLine>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Normal");
  Normal->printSelf(outFile);
  fprintf(outFile, "</Normal>\n");
  if (Constructed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool OppositeAngledLinesFeatureNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OppositeAngledLinesFeatureNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OppositeAngledLinesFeatureNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OppositeAngledLinesFeatureNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OppositeAngledLinesFeatureNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

PointAndVectorType * OppositeAngledLinesFeatureNominalType::getCenterLine()
{return CenterLine;}

void OppositeAngledLinesFeatureNominalType::setCenterLine(PointAndVectorType * CenterLineIn)
{CenterLine = CenterLineIn;}

UnitVectorType * OppositeAngledLinesFeatureNominalType::getNormal()
{return Normal;}

void OppositeAngledLinesFeatureNominalType::setNormal(UnitVectorType * NormalIn)
{Normal = NormalIn;}

OppositeAngledLinesConstructionMethodType * OppositeAngledLinesFeatureNominalType::getConstructed()
{return Constructed;}

void OppositeAngledLinesFeatureNominalType::setConstructed(OppositeAngledLinesConstructionMethodType * ConstructedIn)
{Constructed = ConstructedIn;}

/* ***************************************************************** */

/* class OppositeAngledLinesFromScanType

*/

OppositeAngledLinesFromScanType::OppositeAngledLinesFromScanType() :
  ConstructionMethodBaseType()
{
  SurfaceFeature = 0;
  SearchRadius = 0;
  Depth = 0;
}

OppositeAngledLinesFromScanType::OppositeAngledLinesFromScanType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * SurfaceFeatureIn,
 LinearValueType * SearchRadiusIn,
 LinearValueType * DepthIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  SurfaceFeature = SurfaceFeatureIn;
  SearchRadius = SearchRadiusIn;
  Depth = DepthIn;
}

OppositeAngledLinesFromScanType::~OppositeAngledLinesFromScanType()
{
  #ifndef NODESTRUCT
  delete SurfaceFeature;
  delete SearchRadius;
  delete Depth;
  #endif
}

void OppositeAngledLinesFromScanType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<SurfaceFeature");
  SurfaceFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</SurfaceFeature>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<SearchRadius");
  SearchRadius->printSelf(outFile);
  fprintf(outFile, "</SearchRadius>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Depth");
  Depth->printSelf(outFile);
  fprintf(outFile, "</Depth>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * OppositeAngledLinesFromScanType::getSurfaceFeature()
{return SurfaceFeature;}

void OppositeAngledLinesFromScanType::setSurfaceFeature(BaseFeatureType * SurfaceFeatureIn)
{SurfaceFeature = SurfaceFeatureIn;}

LinearValueType * OppositeAngledLinesFromScanType::getSearchRadius()
{return SearchRadius;}

void OppositeAngledLinesFromScanType::setSearchRadius(LinearValueType * SearchRadiusIn)
{SearchRadius = SearchRadiusIn;}

LinearValueType * OppositeAngledLinesFromScanType::getDepth()
{return Depth;}

void OppositeAngledLinesFromScanType::setDepth(LinearValueType * DepthIn)
{Depth = DepthIn;}

/* ***************************************************************** */

/* class OppositeAngledLinesIntersectionType

*/

OppositeAngledLinesIntersectionType::OppositeAngledLinesIntersectionType() :
  ConstructionMethodBaseType()
{
  IntersectionPlane = 0;
  IntersectionFeature = 0;
}

OppositeAngledLinesIntersectionType::OppositeAngledLinesIntersectionType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * IntersectionPlaneIn,
 BaseFeatureType * IntersectionFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  IntersectionPlane = IntersectionPlaneIn;
  IntersectionFeature = IntersectionFeatureIn;
}

OppositeAngledLinesIntersectionType::~OppositeAngledLinesIntersectionType()
{
  #ifndef NODESTRUCT
  delete IntersectionPlane;
  delete IntersectionFeature;
  #endif
}

void OppositeAngledLinesIntersectionType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<IntersectionPlane");
  IntersectionPlane->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</IntersectionPlane>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<IntersectionFeature");
  IntersectionFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</IntersectionFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * OppositeAngledLinesIntersectionType::getIntersectionPlane()
{return IntersectionPlane;}

void OppositeAngledLinesIntersectionType::setIntersectionPlane(BaseFeatureType * IntersectionPlaneIn)
{IntersectionPlane = IntersectionPlaneIn;}

BaseFeatureType * OppositeAngledLinesIntersectionType::getIntersectionFeature()
{return IntersectionFeature;}

void OppositeAngledLinesIntersectionType::setIntersectionFeature(BaseFeatureType * IntersectionFeatureIn)
{IntersectionFeature = IntersectionFeatureIn;}

/* ***************************************************************** */

/* class OppositeAngledLinesMeasurementDeterminationType

*/

OppositeAngledLinesMeasurementDeterminationType::OppositeAngledLinesMeasurementDeterminationType()
{
  OppositeAngledLinesMeasurementDeterminationTypePair = 0;
}

OppositeAngledLinesMeasurementDeterminationType::OppositeAngledLinesMeasurementDeterminationType(
 OppositeAngledLinesMeasurementDeterminationTypeChoicePair * OppositeAngledLinesMeasurementDeterminationTypePairIn)
{
  OppositeAngledLinesMeasurementDeterminationTypePair = OppositeAngledLinesMeasurementDeterminationTypePairIn;
}

OppositeAngledLinesMeasurementDeterminationType::~OppositeAngledLinesMeasurementDeterminationType()
{
  #ifndef NODESTRUCT
  delete OppositeAngledLinesMeasurementDeterminationTypePair;
  #endif
}

void OppositeAngledLinesMeasurementDeterminationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  OppositeAngledLinesMeasurementDeterminationTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

OppositeAngledLinesMeasurementDeterminationTypeChoicePair * OppositeAngledLinesMeasurementDeterminationType::getOppositeAngledLinesMeasurementDeterminationTypePair()
{return OppositeAngledLinesMeasurementDeterminationTypePair;}

void OppositeAngledLinesMeasurementDeterminationType::setOppositeAngledLinesMeasurementDeterminationTypePair(OppositeAngledLinesMeasurementDeterminationTypeChoicePair * OppositeAngledLinesMeasurementDeterminationTypePairIn)
{OppositeAngledLinesMeasurementDeterminationTypePair = OppositeAngledLinesMeasurementDeterminationTypePairIn;}
OppositeAngledLinesMeasurementDeterminationTypeChoicePair::OppositeAngledLinesMeasurementDeterminationTypeChoicePair() {}

OppositeAngledLinesMeasurementDeterminationTypeChoicePair::OppositeAngledLinesMeasurementDeterminationTypeChoicePair(
 whichOne OppositeAngledLinesMeasurementDeterminationTypeTypeIn,
 OppositeAngledLinesMeasurementDeterminationTypeVal * OppositeAngledLinesMeasurementDeterminationTypeValueIn)
{
  OppositeAngledLinesMeasurementDeterminationTypeType = OppositeAngledLinesMeasurementDeterminationTypeTypeIn;
  OppositeAngledLinesMeasurementDeterminationTypeValue = OppositeAngledLinesMeasurementDeterminationTypeValueIn;
}

OppositeAngledLinesMeasurementDeterminationTypeChoicePair::~OppositeAngledLinesMeasurementDeterminationTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (OppositeAngledLinesMeasurementDeterminationTypeType == CheckedE)
    delete OppositeAngledLinesMeasurementDeterminationTypeValue->Checked;
  else if (OppositeAngledLinesMeasurementDeterminationTypeType == SetE)
    delete OppositeAngledLinesMeasurementDeterminationTypeValue->Set;
  delete OppositeAngledLinesMeasurementDeterminationTypeValue;
  #endif
}

void OppositeAngledLinesMeasurementDeterminationTypeChoicePair::printSelf(FILE * outFile)
{
  if (OppositeAngledLinesMeasurementDeterminationTypeType == CheckedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Checked");
      OppositeAngledLinesMeasurementDeterminationTypeValue->Checked->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Checked>\n");
    }
  else if (OppositeAngledLinesMeasurementDeterminationTypeType == SetE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Set");
      OppositeAngledLinesMeasurementDeterminationTypeValue->Set->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class OppositeAngledLinesProjectionType

*/

OppositeAngledLinesProjectionType::OppositeAngledLinesProjectionType() :
  ConstructionMethodBaseType()
{
  ProjectionPlane = 0;
  ProjectionOppositeAngledLines = 0;
}

OppositeAngledLinesProjectionType::OppositeAngledLinesProjectionType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * ProjectionPlaneIn,
 BaseFeatureType * ProjectionOppositeAngledLinesIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  ProjectionPlane = ProjectionPlaneIn;
  ProjectionOppositeAngledLines = ProjectionOppositeAngledLinesIn;
}

OppositeAngledLinesProjectionType::~OppositeAngledLinesProjectionType()
{
  #ifndef NODESTRUCT
  delete ProjectionPlane;
  delete ProjectionOppositeAngledLines;
  #endif
}

void OppositeAngledLinesProjectionType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ProjectionPlane");
  ProjectionPlane->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ProjectionPlane>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<ProjectionOppositeAngledLines");
  ProjectionOppositeAngledLines->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ProjectionOppositeAngledLines>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * OppositeAngledLinesProjectionType::getProjectionPlane()
{return ProjectionPlane;}

void OppositeAngledLinesProjectionType::setProjectionPlane(BaseFeatureType * ProjectionPlaneIn)
{ProjectionPlane = ProjectionPlaneIn;}

BaseFeatureType * OppositeAngledLinesProjectionType::getProjectionOppositeAngledLines()
{return ProjectionOppositeAngledLines;}

void OppositeAngledLinesProjectionType::setProjectionOppositeAngledLines(BaseFeatureType * ProjectionOppositeAngledLinesIn)
{ProjectionOppositeAngledLines = ProjectionOppositeAngledLinesIn;}

/* ***************************************************************** */

/* class OppositeAngledLinesRecompType

*/

OppositeAngledLinesRecompType::OppositeAngledLinesRecompType() :
  ConstructionMethodBaseType()
{
  BaseFeaturePointList = 0;
}

OppositeAngledLinesRecompType::OppositeAngledLinesRecompType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeaturePointListType * BaseFeaturePointListIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeaturePointList = BaseFeaturePointListIn;
}

OppositeAngledLinesRecompType::~OppositeAngledLinesRecompType()
{
  #ifndef NODESTRUCT
  delete BaseFeaturePointList;
  #endif
}

void OppositeAngledLinesRecompType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeaturePointList");
  BaseFeaturePointList->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeaturePointList>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeaturePointListType * OppositeAngledLinesRecompType::getBaseFeaturePointList()
{return BaseFeaturePointList;}

void OppositeAngledLinesRecompType::setBaseFeaturePointList(BaseFeaturePointListType * BaseFeaturePointListIn)
{BaseFeaturePointList = BaseFeaturePointListIn;}

/* ***************************************************************** */

/* class OppositeAngledLinesTransformType

*/

OppositeAngledLinesTransformType::OppositeAngledLinesTransformType() :
  ConstructionMethodBaseType()
{
  BaseOppositeAngledLines = 0;
  Transformation = 0;
}

OppositeAngledLinesTransformType::OppositeAngledLinesTransformType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseOppositeAngledLinesIn,
 TransformationReferenceType * TransformationIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseOppositeAngledLines = BaseOppositeAngledLinesIn;
  Transformation = TransformationIn;
}

OppositeAngledLinesTransformType::~OppositeAngledLinesTransformType()
{
  #ifndef NODESTRUCT
  delete BaseOppositeAngledLines;
  delete Transformation;
  #endif
}

void OppositeAngledLinesTransformType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseOppositeAngledLines");
  BaseOppositeAngledLines->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseOppositeAngledLines>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Transformation");
  Transformation->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Transformation>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * OppositeAngledLinesTransformType::getBaseOppositeAngledLines()
{return BaseOppositeAngledLines;}

void OppositeAngledLinesTransformType::setBaseOppositeAngledLines(BaseFeatureType * BaseOppositeAngledLinesIn)
{BaseOppositeAngledLines = BaseOppositeAngledLinesIn;}

TransformationReferenceType * OppositeAngledLinesTransformType::getTransformation()
{return Transformation;}

void OppositeAngledLinesTransformType::setTransformation(TransformationReferenceType * TransformationIn)
{Transformation = TransformationIn;}

/* ***************************************************************** */

/* class OppositeAngledPlanesBestFitType

*/

OppositeAngledPlanesBestFitType::OppositeAngledPlanesBestFitType() :
  ConstructionMethodBaseType()
{
  n = 0;
  BaseFeature = 0;
}

OppositeAngledPlanesBestFitType::OppositeAngledPlanesBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = 0;
  BaseFeature = BaseFeatureIn;
}

OppositeAngledPlanesBestFitType::OppositeAngledPlanesBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 NaturalType * nIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = nIn;
  BaseFeature = BaseFeatureIn;
}

OppositeAngledPlanesBestFitType::~OppositeAngledPlanesBestFitType()
{
  #ifndef NODESTRUCT
  delete n;
  delete BaseFeature;
  #endif
}

void OppositeAngledPlanesBestFitType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  {
    if (!BaseFeature)
      {
        fprintf(stderr, "BaseFeature list is missing\n");
        exit(1);
      }
    if (BaseFeature->size() == 0)
      {
        fprintf(stderr, "BaseFeature list is empty\n");
        exit(1);
      }
    if (BaseFeature->size() < 6)
      {
        fprintf(stderr,
                "size of BaseFeature list (%d) less than minimum required (6)\n",
                (int)BaseFeature->size());
        exit(1);
      }
    std::list<SequencedBaseFeatureType *>::iterator iter;
    for (iter = BaseFeature->begin();
         iter != BaseFeature->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<BaseFeature");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</BaseFeature>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool OppositeAngledPlanesBestFitType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in OppositeAngledPlanesBestFitType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in OppositeAngledPlanesBestFitType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OppositeAngledPlanesBestFitType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in OppositeAngledPlanesBestFitType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * OppositeAngledPlanesBestFitType::getn()
{return n;}

void OppositeAngledPlanesBestFitType::setn(NaturalType * nIn)
{n = nIn;}

SequencedBaseFeatureTypeLisd * OppositeAngledPlanesBestFitType::getBaseFeature()
{return BaseFeature;}

void OppositeAngledPlanesBestFitType::setBaseFeature(SequencedBaseFeatureTypeLisd * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class OppositeAngledPlanesCastType

*/

OppositeAngledPlanesCastType::OppositeAngledPlanesCastType() :
  ConstructionMethodBaseType()
{
  BaseFeature = 0;
}

OppositeAngledPlanesCastType::OppositeAngledPlanesCastType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeature = BaseFeatureIn;
}

OppositeAngledPlanesCastType::~OppositeAngledPlanesCastType()
{
  #ifndef NODESTRUCT
  delete BaseFeature;
  #endif
}

void OppositeAngledPlanesCastType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeature");
  BaseFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * OppositeAngledPlanesCastType::getBaseFeature()
{return BaseFeature;}

void OppositeAngledPlanesCastType::setBaseFeature(BaseFeatureType * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class OppositeAngledPlanesCheckedFeatureType

*/

OppositeAngledPlanesCheckedFeatureType::OppositeAngledPlanesCheckedFeatureType()
{
  CheckDetails = 0;
}

OppositeAngledPlanesCheckedFeatureType::OppositeAngledPlanesCheckedFeatureType(
 OppositeAngledPlanesCheckedType * CheckDetailsIn)
{
  CheckDetails = CheckDetailsIn;
}

OppositeAngledPlanesCheckedFeatureType::~OppositeAngledPlanesCheckedFeatureType()
{
  #ifndef NODESTRUCT
  delete CheckDetails;
  #endif
}

void OppositeAngledPlanesCheckedFeatureType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (CheckDetails)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CheckDetails");
      CheckDetails->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CheckDetails>\n");
    }
  doSpaces(-INDENT, outFile);
}

OppositeAngledPlanesCheckedType * OppositeAngledPlanesCheckedFeatureType::getCheckDetails()
{return CheckDetails;}

void OppositeAngledPlanesCheckedFeatureType::setCheckDetails(OppositeAngledPlanesCheckedType * CheckDetailsIn)
{CheckDetails = CheckDetailsIn;}

/* ***************************************************************** */

/* class OppositeAngledPlanesCheckedType

*/

OppositeAngledPlanesCheckedType::OppositeAngledPlanesCheckedType()
{
  OppositeAngledPlanesCheckedTypePair = 0;
}

OppositeAngledPlanesCheckedType::OppositeAngledPlanesCheckedType(
 OppositeAngledPlanesCheckedTypeChoicePair * OppositeAngledPlanesCheckedTypePairIn)
{
  OppositeAngledPlanesCheckedTypePair = OppositeAngledPlanesCheckedTypePairIn;
}

OppositeAngledPlanesCheckedType::~OppositeAngledPlanesCheckedType()
{
  #ifndef NODESTRUCT
  delete OppositeAngledPlanesCheckedTypePair;
  #endif
}

void OppositeAngledPlanesCheckedType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  OppositeAngledPlanesCheckedTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

OppositeAngledPlanesCheckedTypeChoicePair * OppositeAngledPlanesCheckedType::getOppositeAngledPlanesCheckedTypePair()
{return OppositeAngledPlanesCheckedTypePair;}

void OppositeAngledPlanesCheckedType::setOppositeAngledPlanesCheckedTypePair(OppositeAngledPlanesCheckedTypeChoicePair * OppositeAngledPlanesCheckedTypePairIn)
{OppositeAngledPlanesCheckedTypePair = OppositeAngledPlanesCheckedTypePairIn;}
OppositeAngledPlanesCheckedTypeChoicePair::OppositeAngledPlanesCheckedTypeChoicePair() {}

OppositeAngledPlanesCheckedTypeChoicePair::OppositeAngledPlanesCheckedTypeChoicePair(
 whichOne OppositeAngledPlanesCheckedTypeTypeIn,
 OppositeAngledPlanesCheckedTypeVal * OppositeAngledPlanesCheckedTypeValueIn)
{
  OppositeAngledPlanesCheckedTypeType = OppositeAngledPlanesCheckedTypeTypeIn;
  OppositeAngledPlanesCheckedTypeValue = OppositeAngledPlanesCheckedTypeValueIn;
}

OppositeAngledPlanesCheckedTypeChoicePair::~OppositeAngledPlanesCheckedTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (OppositeAngledPlanesCheckedTypeType == MeasuredE)
    delete OppositeAngledPlanesCheckedTypeValue->Measured;
  else if (OppositeAngledPlanesCheckedTypeType == ConstructedE)
    delete OppositeAngledPlanesCheckedTypeValue->Constructed;
  delete OppositeAngledPlanesCheckedTypeValue;
  #endif
}

void OppositeAngledPlanesCheckedTypeChoicePair::printSelf(FILE * outFile)
{
  if (OppositeAngledPlanesCheckedTypeType == MeasuredE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Measured");
      OppositeAngledPlanesCheckedTypeValue->Measured->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Measured>\n");
    }
  else if (OppositeAngledPlanesCheckedTypeType == ConstructedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      OppositeAngledPlanesCheckedTypeValue->Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
}

/* ***************************************************************** */

/* class OppositeAngledPlanesConstructionMethodType

*/

OppositeAngledPlanesConstructionMethodType::OppositeAngledPlanesConstructionMethodType()
{
  OppositeAngledPlanesConstructionMethodTypePair = 0;
}

OppositeAngledPlanesConstructionMethodType::OppositeAngledPlanesConstructionMethodType(
 OppositeAngledPlanesConstructionMethodTypeChoicePair * OppositeAngledPlanesConstructionMethodTypePairIn)
{
  OppositeAngledPlanesConstructionMethodTypePair = OppositeAngledPlanesConstructionMethodTypePairIn;
}

OppositeAngledPlanesConstructionMethodType::~OppositeAngledPlanesConstructionMethodType()
{
  #ifndef NODESTRUCT
  delete OppositeAngledPlanesConstructionMethodTypePair;
  #endif
}

void OppositeAngledPlanesConstructionMethodType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (OppositeAngledPlanesConstructionMethodTypePair)
    {
      OppositeAngledPlanesConstructionMethodTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

OppositeAngledPlanesConstructionMethodTypeChoicePair * OppositeAngledPlanesConstructionMethodType::getOppositeAngledPlanesConstructionMethodTypePair()
{return OppositeAngledPlanesConstructionMethodTypePair;}

void OppositeAngledPlanesConstructionMethodType::setOppositeAngledPlanesConstructionMethodTypePair(OppositeAngledPlanesConstructionMethodTypeChoicePair * OppositeAngledPlanesConstructionMethodTypePairIn)
{OppositeAngledPlanesConstructionMethodTypePair = OppositeAngledPlanesConstructionMethodTypePairIn;}
OppositeAngledPlanesConstructionMethodTypeChoicePair::OppositeAngledPlanesConstructionMethodTypeChoicePair() {}

OppositeAngledPlanesConstructionMethodTypeChoicePair::OppositeAngledPlanesConstructionMethodTypeChoicePair(
 whichOne OppositeAngledPlanesConstructionMethodTypeTypeIn,
 OppositeAngledPlanesConstructionMethodTypeVal * OppositeAngledPlanesConstructionMethodTypeValueIn)
{
  OppositeAngledPlanesConstructionMethodTypeType = OppositeAngledPlanesConstructionMethodTypeTypeIn;
  OppositeAngledPlanesConstructionMethodTypeValue = OppositeAngledPlanesConstructionMethodTypeValueIn;
}

OppositeAngledPlanesConstructionMethodTypeChoicePair::~OppositeAngledPlanesConstructionMethodTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (OppositeAngledPlanesConstructionMethodTypeType == BestFitE)
    delete OppositeAngledPlanesConstructionMethodTypeValue->BestFit;
  else if (OppositeAngledPlanesConstructionMethodTypeType == RecompensatedE)
    delete OppositeAngledPlanesConstructionMethodTypeValue->Recompensated;
  else if (OppositeAngledPlanesConstructionMethodTypeType == CopyE)
    delete OppositeAngledPlanesConstructionMethodTypeValue->Copy;
  else if (OppositeAngledPlanesConstructionMethodTypeType == CastE)
    delete OppositeAngledPlanesConstructionMethodTypeValue->Cast;
  else if (OppositeAngledPlanesConstructionMethodTypeType == TransformE)
    delete OppositeAngledPlanesConstructionMethodTypeValue->Transform;
  else if (OppositeAngledPlanesConstructionMethodTypeType == FromScanE)
    delete OppositeAngledPlanesConstructionMethodTypeValue->FromScan;
  delete OppositeAngledPlanesConstructionMethodTypeValue;
  #endif
}

void OppositeAngledPlanesConstructionMethodTypeChoicePair::printSelf(FILE * outFile)
{
  if (OppositeAngledPlanesConstructionMethodTypeType == BestFitE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BestFit");
      OppositeAngledPlanesConstructionMethodTypeValue->BestFit->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BestFit>\n");
    }
  else if (OppositeAngledPlanesConstructionMethodTypeType == RecompensatedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Recompensated");
      OppositeAngledPlanesConstructionMethodTypeValue->Recompensated->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Recompensated>\n");
    }
  else if (OppositeAngledPlanesConstructionMethodTypeType == CopyE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Copy");
      OppositeAngledPlanesConstructionMethodTypeValue->Copy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Copy>\n");
    }
  else if (OppositeAngledPlanesConstructionMethodTypeType == CastE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Cast");
      OppositeAngledPlanesConstructionMethodTypeValue->Cast->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Cast>\n");
    }
  else if (OppositeAngledPlanesConstructionMethodTypeType == TransformE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Transform");
      OppositeAngledPlanesConstructionMethodTypeValue->Transform->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Transform>\n");
    }
  else if (OppositeAngledPlanesConstructionMethodTypeType == FromScanE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FromScan");
      OppositeAngledPlanesConstructionMethodTypeValue->FromScan->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FromScan>\n");
    }
}

/* ***************************************************************** */

/* class OppositeAngledPlanesCopyType

*/

OppositeAngledPlanesCopyType::OppositeAngledPlanesCopyType() :
  ConstructionMethodBaseType()
{
  BaseOppositeAngledPlanes = 0;
}

OppositeAngledPlanesCopyType::OppositeAngledPlanesCopyType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseOppositeAngledPlanesIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseOppositeAngledPlanes = BaseOppositeAngledPlanesIn;
}

OppositeAngledPlanesCopyType::~OppositeAngledPlanesCopyType()
{
  #ifndef NODESTRUCT
  delete BaseOppositeAngledPlanes;
  #endif
}

void OppositeAngledPlanesCopyType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseOppositeAngledPlanes");
  BaseOppositeAngledPlanes->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseOppositeAngledPlanes>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * OppositeAngledPlanesCopyType::getBaseOppositeAngledPlanes()
{return BaseOppositeAngledPlanes;}

void OppositeAngledPlanesCopyType::setBaseOppositeAngledPlanes(BaseFeatureType * BaseOppositeAngledPlanesIn)
{BaseOppositeAngledPlanes = BaseOppositeAngledPlanesIn;}

/* ***************************************************************** */

/* class OppositeAngledPlanesFeatureDefinitionType

*/

OppositeAngledPlanesFeatureDefinitionType::OppositeAngledPlanesFeatureDefinitionType() :
  SurfaceFeatureDefinitionBaseType()
{
  InternalExternal = 0;
  Width = 0;
  Length = 0;
  EndType = 0;
  Depth = 0;
  Bottom = 0;
  SingleOpenEnd = 0;
  EndRadius1 = 0;
  EndRadius2 = 0;
  OppositeAngledP_1094 = 0;
}

OppositeAngledPlanesFeatureDefinitionType::OppositeAngledPlanesFeatureDefinitionType(
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * WidthIn,
 LinearValueType * LengthIn,
 SlotEndType * EndTypeIn,
 LinearValueType * DepthIn,
 BottomType * BottomIn,
 XmlBoolean * SingleOpenEndIn,
 EndRadiusType * EndRadius1In,
 EndRadiusType * EndRadius2In,
 OppositeAngledP_1094_Type * OppositeAngledP_1094In) :
  SurfaceFeatureDefinitionBaseType(
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  Width = WidthIn;
  Length = LengthIn;
  EndType = EndTypeIn;
  Depth = DepthIn;
  Bottom = BottomIn;
  SingleOpenEnd = SingleOpenEndIn;
  EndRadius1 = EndRadius1In;
  EndRadius2 = EndRadius2In;
  OppositeAngledP_1094 = OppositeAngledP_1094In;
}

OppositeAngledPlanesFeatureDefinitionType::OppositeAngledPlanesFeatureDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * WidthIn,
 LinearValueType * LengthIn,
 SlotEndType * EndTypeIn,
 LinearValueType * DepthIn,
 BottomType * BottomIn,
 XmlBoolean * SingleOpenEndIn,
 EndRadiusType * EndRadius1In,
 EndRadiusType * EndRadius2In,
 OppositeAngledP_1094_Type * OppositeAngledP_1094In) :
  SurfaceFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  Width = WidthIn;
  Length = LengthIn;
  EndType = EndTypeIn;
  Depth = DepthIn;
  Bottom = BottomIn;
  SingleOpenEnd = SingleOpenEndIn;
  EndRadius1 = EndRadius1In;
  EndRadius2 = EndRadius2In;
  OppositeAngledP_1094 = OppositeAngledP_1094In;
}

OppositeAngledPlanesFeatureDefinitionType::~OppositeAngledPlanesFeatureDefinitionType()
{
  #ifndef NODESTRUCT
  delete InternalExternal;
  delete Width;
  delete Length;
  delete EndType;
  delete Depth;
  delete Bottom;
  delete SingleOpenEnd;
  delete EndRadius1;
  delete EndRadius2;
  delete OppositeAngledP_1094;
  #endif
}

void OppositeAngledPlanesFeatureDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<InternalExternal");
  InternalExternal->printSelf(outFile);
  fprintf(outFile, "</InternalExternal>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Width");
  Width->printSelf(outFile);
  fprintf(outFile, "</Width>\n");
  if (Length)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Length");
      Length->printSelf(outFile);
      fprintf(outFile, "</Length>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<EndType");
  EndType->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</EndType>\n");
  if (Depth)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Depth");
      Depth->printSelf(outFile);
      fprintf(outFile, "</Depth>\n");
    }
  if (Bottom)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Bottom");
      Bottom->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Bottom>\n");
    }
  if (SingleOpenEnd)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SingleOpenEnd");
      SingleOpenEnd->printSelf(outFile);
      fprintf(outFile, "</SingleOpenEnd>\n");
    }
  if (EndRadius1)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EndRadius1");
      EndRadius1->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EndRadius1>\n");
    }
  if (EndRadius2)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EndRadius2");
      EndRadius2->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EndRadius2>\n");
    }
  OppositeAngledP_1094->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

bool OppositeAngledPlanesFeatureDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OppositeAngledPlanesFeatureDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OppositeAngledPlanesFeatureDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OppositeAngledPlanesFeatureDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OppositeAngledPlanesFeatureDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

InternalExternalEnumType * OppositeAngledPlanesFeatureDefinitionType::getInternalExternal()
{return InternalExternal;}

void OppositeAngledPlanesFeatureDefinitionType::setInternalExternal(InternalExternalEnumType * InternalExternalIn)
{InternalExternal = InternalExternalIn;}

LinearValueType * OppositeAngledPlanesFeatureDefinitionType::getWidth()
{return Width;}

void OppositeAngledPlanesFeatureDefinitionType::setWidth(LinearValueType * WidthIn)
{Width = WidthIn;}

LinearValueType * OppositeAngledPlanesFeatureDefinitionType::getLength()
{return Length;}

void OppositeAngledPlanesFeatureDefinitionType::setLength(LinearValueType * LengthIn)
{Length = LengthIn;}

SlotEndType * OppositeAngledPlanesFeatureDefinitionType::getEndType()
{return EndType;}

void OppositeAngledPlanesFeatureDefinitionType::setEndType(SlotEndType * EndTypeIn)
{EndType = EndTypeIn;}

LinearValueType * OppositeAngledPlanesFeatureDefinitionType::getDepth()
{return Depth;}

void OppositeAngledPlanesFeatureDefinitionType::setDepth(LinearValueType * DepthIn)
{Depth = DepthIn;}

BottomType * OppositeAngledPlanesFeatureDefinitionType::getBottom()
{return Bottom;}

void OppositeAngledPlanesFeatureDefinitionType::setBottom(BottomType * BottomIn)
{Bottom = BottomIn;}

XmlBoolean * OppositeAngledPlanesFeatureDefinitionType::getSingleOpenEnd()
{return SingleOpenEnd;}

void OppositeAngledPlanesFeatureDefinitionType::setSingleOpenEnd(XmlBoolean * SingleOpenEndIn)
{SingleOpenEnd = SingleOpenEndIn;}

EndRadiusType * OppositeAngledPlanesFeatureDefinitionType::getEndRadius1()
{return EndRadius1;}

void OppositeAngledPlanesFeatureDefinitionType::setEndRadius1(EndRadiusType * EndRadius1In)
{EndRadius1 = EndRadius1In;}

EndRadiusType * OppositeAngledPlanesFeatureDefinitionType::getEndRadius2()
{return EndRadius2;}

void OppositeAngledPlanesFeatureDefinitionType::setEndRadius2(EndRadiusType * EndRadius2In)
{EndRadius2 = EndRadius2In;}

OppositeAngledP_1094_Type * OppositeAngledPlanesFeatureDefinitionType::getOppositeAngledP_1094()
{return OppositeAngledP_1094;}

void OppositeAngledPlanesFeatureDefinitionType::setOppositeAngledP_1094(OppositeAngledP_1094_Type * OppositeAngledP_1094In)
{OppositeAngledP_1094 = OppositeAngledP_1094In;}

/* ***************************************************************** */

/* class OppositeAngledPlanesFeatureItemType

*/

OppositeAngledPlanesFeatureItemType::OppositeAngledPlanesFeatureItemType() :
  SurfaceFeatureItemBaseType()
{
  DeterminationMode = 0;
}

OppositeAngledPlanesFeatureItemType::OppositeAngledPlanesFeatureItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 OppositeAngledPlanesMeasurementDeterminationType * DeterminationModeIn) :
  SurfaceFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

OppositeAngledPlanesFeatureItemType::OppositeAngledPlanesFeatureItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 OppositeAngledPlanesMeasurementDeterminationType * DeterminationModeIn) :
  SurfaceFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

OppositeAngledPlanesFeatureItemType::~OppositeAngledPlanesFeatureItemType()
{
  #ifndef NODESTRUCT
  delete DeterminationMode;
  #endif
}

void OppositeAngledPlanesFeatureItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<DeterminationMode");
  DeterminationMode->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeterminationMode>\n");
  doSpaces(-INDENT, outFile);
}

bool OppositeAngledPlanesFeatureItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OppositeAngledPlanesFeatureItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OppositeAngledPlanesFeatureItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OppositeAngledPlanesFeatureItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OppositeAngledPlanesFeatureItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

OppositeAngledPlanesMeasurementDeterminationType * OppositeAngledPlanesFeatureItemType::getDeterminationMode()
{return DeterminationMode;}

void OppositeAngledPlanesFeatureItemType::setDeterminationMode(OppositeAngledPlanesMeasurementDeterminationType * DeterminationModeIn)
{DeterminationMode = DeterminationModeIn;}

/* ***************************************************************** */

/* class OppositeAngledPlanesFeatureMeasurementType

*/

OppositeAngledPlanesFeatureMeasurementType::OppositeAngledPlanesFeatureMeasurementType() :
  SurfaceFeatureMeasurementBaseType()
{
  CenterPlane = 0;
  LengthVector = 0;
  DepthVector = 0;
  Width = 0;
  WidthMin = 0;
  WidthMax = 0;
  Length = 0;
  LengthMin = 0;
  LengthMax = 0;
  Depth = 0;
  OppositeAngledP_1095 = 0;
  EndRadius1 = 0;
  EndRadius2 = 0;
  Form = 0;
}

OppositeAngledPlanesFeatureMeasurementType::OppositeAngledPlanesFeatureMeasurementType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredPlaneType * CenterPlaneIn,
 MeasuredUnitVectorType * LengthVectorIn,
 MeasuredUnitVectorType * DepthVectorIn,
 MeasuredLinearValueType * WidthIn,
 MeasuredLinearValueType * WidthMinIn,
 MeasuredLinearValueType * WidthMaxIn,
 MeasuredLinearValueType * LengthIn,
 MeasuredLinearValueType * LengthMinIn,
 MeasuredLinearValueType * LengthMaxIn,
 MeasuredLinearValueType * DepthIn,
 OppositeAngledP_1095_Type * OppositeAngledP_1095In,
 MeasuredEndRadiusType * EndRadius1In,
 MeasuredEndRadiusType * EndRadius2In,
 MeasuredLinearValueType * FormIn) :
  SurfaceFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  CenterPlane = CenterPlaneIn;
  LengthVector = LengthVectorIn;
  DepthVector = DepthVectorIn;
  Width = WidthIn;
  WidthMin = WidthMinIn;
  WidthMax = WidthMaxIn;
  Length = LengthIn;
  LengthMin = LengthMinIn;
  LengthMax = LengthMaxIn;
  Depth = DepthIn;
  OppositeAngledP_1095 = OppositeAngledP_1095In;
  EndRadius1 = EndRadius1In;
  EndRadius2 = EndRadius2In;
  Form = FormIn;
}

OppositeAngledPlanesFeatureMeasurementType::OppositeAngledPlanesFeatureMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredPlaneType * CenterPlaneIn,
 MeasuredUnitVectorType * LengthVectorIn,
 MeasuredUnitVectorType * DepthVectorIn,
 MeasuredLinearValueType * WidthIn,
 MeasuredLinearValueType * WidthMinIn,
 MeasuredLinearValueType * WidthMaxIn,
 MeasuredLinearValueType * LengthIn,
 MeasuredLinearValueType * LengthMinIn,
 MeasuredLinearValueType * LengthMaxIn,
 MeasuredLinearValueType * DepthIn,
 OppositeAngledP_1095_Type * OppositeAngledP_1095In,
 MeasuredEndRadiusType * EndRadius1In,
 MeasuredEndRadiusType * EndRadius2In,
 MeasuredLinearValueType * FormIn) :
  SurfaceFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  CenterPlane = CenterPlaneIn;
  LengthVector = LengthVectorIn;
  DepthVector = DepthVectorIn;
  Width = WidthIn;
  WidthMin = WidthMinIn;
  WidthMax = WidthMaxIn;
  Length = LengthIn;
  LengthMin = LengthMinIn;
  LengthMax = LengthMaxIn;
  Depth = DepthIn;
  OppositeAngledP_1095 = OppositeAngledP_1095In;
  EndRadius1 = EndRadius1In;
  EndRadius2 = EndRadius2In;
  Form = FormIn;
}

OppositeAngledPlanesFeatureMeasurementType::~OppositeAngledPlanesFeatureMeasurementType()
{
  #ifndef NODESTRUCT
  delete CenterPlane;
  delete LengthVector;
  delete DepthVector;
  delete Width;
  delete WidthMin;
  delete WidthMax;
  delete Length;
  delete LengthMin;
  delete LengthMax;
  delete Depth;
  delete OppositeAngledP_1095;
  delete EndRadius1;
  delete EndRadius2;
  delete Form;
  #endif
}

void OppositeAngledPlanesFeatureMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  if (CenterPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CenterPlane");
      CenterPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CenterPlane>\n");
    }
  if (LengthVector)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LengthVector");
      LengthVector->printSelf(outFile);
      fprintf(outFile, "</LengthVector>\n");
    }
  if (DepthVector)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DepthVector");
      DepthVector->printSelf(outFile);
      fprintf(outFile, "</DepthVector>\n");
    }
  if (Width)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Width");
      Width->printSelf(outFile);
      fprintf(outFile, "</Width>\n");
    }
  if (WidthMin)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WidthMin");
      WidthMin->printSelf(outFile);
      fprintf(outFile, "</WidthMin>\n");
    }
  if (WidthMax)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WidthMax");
      WidthMax->printSelf(outFile);
      fprintf(outFile, "</WidthMax>\n");
    }
  if (Length)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Length");
      Length->printSelf(outFile);
      fprintf(outFile, "</Length>\n");
    }
  if (LengthMin)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LengthMin");
      LengthMin->printSelf(outFile);
      fprintf(outFile, "</LengthMin>\n");
    }
  if (LengthMax)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LengthMax");
      LengthMax->printSelf(outFile);
      fprintf(outFile, "</LengthMax>\n");
    }
  if (Depth)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Depth");
      Depth->printSelf(outFile);
      fprintf(outFile, "</Depth>\n");
    }
  if (OppositeAngledP_1095)
    {
  OppositeAngledP_1095->printSelf(outFile);
    }
  if (EndRadius1)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EndRadius1");
      EndRadius1->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EndRadius1>\n");
    }
  if (EndRadius2)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EndRadius2");
      EndRadius2->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EndRadius2>\n");
    }
  if (Form)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Form");
      Form->printSelf(outFile);
      fprintf(outFile, "</Form>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool OppositeAngledPlanesFeatureMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OppositeAngledPlanesFeatureMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OppositeAngledPlanesFeatureMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OppositeAngledPlanesFeatureMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OppositeAngledPlanesFeatureMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredPlaneType * OppositeAngledPlanesFeatureMeasurementType::getCenterPlane()
{return CenterPlane;}

void OppositeAngledPlanesFeatureMeasurementType::setCenterPlane(MeasuredPlaneType * CenterPlaneIn)
{CenterPlane = CenterPlaneIn;}

MeasuredUnitVectorType * OppositeAngledPlanesFeatureMeasurementType::getLengthVector()
{return LengthVector;}

void OppositeAngledPlanesFeatureMeasurementType::setLengthVector(MeasuredUnitVectorType * LengthVectorIn)
{LengthVector = LengthVectorIn;}

MeasuredUnitVectorType * OppositeAngledPlanesFeatureMeasurementType::getDepthVector()
{return DepthVector;}

void OppositeAngledPlanesFeatureMeasurementType::setDepthVector(MeasuredUnitVectorType * DepthVectorIn)
{DepthVector = DepthVectorIn;}

MeasuredLinearValueType * OppositeAngledPlanesFeatureMeasurementType::getWidth()
{return Width;}

void OppositeAngledPlanesFeatureMeasurementType::setWidth(MeasuredLinearValueType * WidthIn)
{Width = WidthIn;}

MeasuredLinearValueType * OppositeAngledPlanesFeatureMeasurementType::getWidthMin()
{return WidthMin;}

void OppositeAngledPlanesFeatureMeasurementType::setWidthMin(MeasuredLinearValueType * WidthMinIn)
{WidthMin = WidthMinIn;}

MeasuredLinearValueType * OppositeAngledPlanesFeatureMeasurementType::getWidthMax()
{return WidthMax;}

void OppositeAngledPlanesFeatureMeasurementType::setWidthMax(MeasuredLinearValueType * WidthMaxIn)
{WidthMax = WidthMaxIn;}

MeasuredLinearValueType * OppositeAngledPlanesFeatureMeasurementType::getLength()
{return Length;}

void OppositeAngledPlanesFeatureMeasurementType::setLength(MeasuredLinearValueType * LengthIn)
{Length = LengthIn;}

MeasuredLinearValueType * OppositeAngledPlanesFeatureMeasurementType::getLengthMin()
{return LengthMin;}

void OppositeAngledPlanesFeatureMeasurementType::setLengthMin(MeasuredLinearValueType * LengthMinIn)
{LengthMin = LengthMinIn;}

MeasuredLinearValueType * OppositeAngledPlanesFeatureMeasurementType::getLengthMax()
{return LengthMax;}

void OppositeAngledPlanesFeatureMeasurementType::setLengthMax(MeasuredLinearValueType * LengthMaxIn)
{LengthMax = LengthMaxIn;}

MeasuredLinearValueType * OppositeAngledPlanesFeatureMeasurementType::getDepth()
{return Depth;}

void OppositeAngledPlanesFeatureMeasurementType::setDepth(MeasuredLinearValueType * DepthIn)
{Depth = DepthIn;}

OppositeAngledP_1095_Type * OppositeAngledPlanesFeatureMeasurementType::getOppositeAngledP_1095()
{return OppositeAngledP_1095;}

void OppositeAngledPlanesFeatureMeasurementType::setOppositeAngledP_1095(OppositeAngledP_1095_Type * OppositeAngledP_1095In)
{OppositeAngledP_1095 = OppositeAngledP_1095In;}

MeasuredEndRadiusType * OppositeAngledPlanesFeatureMeasurementType::getEndRadius1()
{return EndRadius1;}

void OppositeAngledPlanesFeatureMeasurementType::setEndRadius1(MeasuredEndRadiusType * EndRadius1In)
{EndRadius1 = EndRadius1In;}

MeasuredEndRadiusType * OppositeAngledPlanesFeatureMeasurementType::getEndRadius2()
{return EndRadius2;}

void OppositeAngledPlanesFeatureMeasurementType::setEndRadius2(MeasuredEndRadiusType * EndRadius2In)
{EndRadius2 = EndRadius2In;}

MeasuredLinearValueType * OppositeAngledPlanesFeatureMeasurementType::getForm()
{return Form;}

void OppositeAngledPlanesFeatureMeasurementType::setForm(MeasuredLinearValueType * FormIn)
{Form = FormIn;}

/* ***************************************************************** */

/* class OppositeAngledPlanesFeatureNominalType

*/

OppositeAngledPlanesFeatureNominalType::OppositeAngledPlanesFeatureNominalType() :
  SurfaceFeatureNominalBaseType()
{
  CenterPlane = 0;
  LengthVector = 0;
  DepthVector = 0;
  DraftVector = 0;
  Constructed = 0;
}

OppositeAngledPlanesFeatureNominalType::OppositeAngledPlanesFeatureNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 PlaneType * CenterPlaneIn,
 UnitVectorType * LengthVectorIn,
 UnitVectorType * DepthVectorIn,
 UnitVectorType * DraftVectorIn,
 OppositeAngledPlanesConstructionMethodType * ConstructedIn) :
  SurfaceFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  CenterPlane = CenterPlaneIn;
  LengthVector = LengthVectorIn;
  DepthVector = DepthVectorIn;
  DraftVector = DraftVectorIn;
  Constructed = ConstructedIn;
}

OppositeAngledPlanesFeatureNominalType::OppositeAngledPlanesFeatureNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 PlaneType * CenterPlaneIn,
 UnitVectorType * LengthVectorIn,
 UnitVectorType * DepthVectorIn,
 UnitVectorType * DraftVectorIn,
 OppositeAngledPlanesConstructionMethodType * ConstructedIn) :
  SurfaceFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  CenterPlane = CenterPlaneIn;
  LengthVector = LengthVectorIn;
  DepthVector = DepthVectorIn;
  DraftVector = DraftVectorIn;
  Constructed = ConstructedIn;
}

OppositeAngledPlanesFeatureNominalType::~OppositeAngledPlanesFeatureNominalType()
{
  #ifndef NODESTRUCT
  delete CenterPlane;
  delete LengthVector;
  delete DepthVector;
  delete DraftVector;
  delete Constructed;
  #endif
}

void OppositeAngledPlanesFeatureNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CenterPlane");
  CenterPlane->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</CenterPlane>\n");
  if (LengthVector)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LengthVector");
      LengthVector->printSelf(outFile);
      fprintf(outFile, "</LengthVector>\n");
    }
  if (DepthVector)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DepthVector");
      DepthVector->printSelf(outFile);
      fprintf(outFile, "</DepthVector>\n");
    }
  if (DraftVector)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DraftVector");
      DraftVector->printSelf(outFile);
      fprintf(outFile, "</DraftVector>\n");
    }
  if (Constructed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool OppositeAngledPlanesFeatureNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OppositeAngledPlanesFeatureNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OppositeAngledPlanesFeatureNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OppositeAngledPlanesFeatureNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OppositeAngledPlanesFeatureNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

PlaneType * OppositeAngledPlanesFeatureNominalType::getCenterPlane()
{return CenterPlane;}

void OppositeAngledPlanesFeatureNominalType::setCenterPlane(PlaneType * CenterPlaneIn)
{CenterPlane = CenterPlaneIn;}

UnitVectorType * OppositeAngledPlanesFeatureNominalType::getLengthVector()
{return LengthVector;}

void OppositeAngledPlanesFeatureNominalType::setLengthVector(UnitVectorType * LengthVectorIn)
{LengthVector = LengthVectorIn;}

UnitVectorType * OppositeAngledPlanesFeatureNominalType::getDepthVector()
{return DepthVector;}

void OppositeAngledPlanesFeatureNominalType::setDepthVector(UnitVectorType * DepthVectorIn)
{DepthVector = DepthVectorIn;}

UnitVectorType * OppositeAngledPlanesFeatureNominalType::getDraftVector()
{return DraftVector;}

void OppositeAngledPlanesFeatureNominalType::setDraftVector(UnitVectorType * DraftVectorIn)
{DraftVector = DraftVectorIn;}

OppositeAngledPlanesConstructionMethodType * OppositeAngledPlanesFeatureNominalType::getConstructed()
{return Constructed;}

void OppositeAngledPlanesFeatureNominalType::setConstructed(OppositeAngledPlanesConstructionMethodType * ConstructedIn)
{Constructed = ConstructedIn;}

/* ***************************************************************** */

/* class OppositeAngledPlanesFromScanType

*/

OppositeAngledPlanesFromScanType::OppositeAngledPlanesFromScanType() :
  ConstructionMethodBaseType()
{
  SurfaceFeature = 0;
  SearchRadius = 0;
}

OppositeAngledPlanesFromScanType::OppositeAngledPlanesFromScanType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * SurfaceFeatureIn,
 LinearValueType * SearchRadiusIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  SurfaceFeature = SurfaceFeatureIn;
  SearchRadius = SearchRadiusIn;
}

OppositeAngledPlanesFromScanType::~OppositeAngledPlanesFromScanType()
{
  #ifndef NODESTRUCT
  delete SurfaceFeature;
  delete SearchRadius;
  #endif
}

void OppositeAngledPlanesFromScanType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<SurfaceFeature");
  SurfaceFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</SurfaceFeature>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<SearchRadius");
  SearchRadius->printSelf(outFile);
  fprintf(outFile, "</SearchRadius>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * OppositeAngledPlanesFromScanType::getSurfaceFeature()
{return SurfaceFeature;}

void OppositeAngledPlanesFromScanType::setSurfaceFeature(BaseFeatureType * SurfaceFeatureIn)
{SurfaceFeature = SurfaceFeatureIn;}

LinearValueType * OppositeAngledPlanesFromScanType::getSearchRadius()
{return SearchRadius;}

void OppositeAngledPlanesFromScanType::setSearchRadius(LinearValueType * SearchRadiusIn)
{SearchRadius = SearchRadiusIn;}

/* ***************************************************************** */

/* class OppositeAngledPlanesMeasurementDeterminationType

*/

OppositeAngledPlanesMeasurementDeterminationType::OppositeAngledPlanesMeasurementDeterminationType()
{
  OppositeAngledPlanesMeasurementDeterminationTypePair = 0;
}

OppositeAngledPlanesMeasurementDeterminationType::OppositeAngledPlanesMeasurementDeterminationType(
 OppositeAngledPlanesMeasurementDeterminationTypeChoicePair * OppositeAngledPlanesMeasurementDeterminationTypePairIn)
{
  OppositeAngledPlanesMeasurementDeterminationTypePair = OppositeAngledPlanesMeasurementDeterminationTypePairIn;
}

OppositeAngledPlanesMeasurementDeterminationType::~OppositeAngledPlanesMeasurementDeterminationType()
{
  #ifndef NODESTRUCT
  delete OppositeAngledPlanesMeasurementDeterminationTypePair;
  #endif
}

void OppositeAngledPlanesMeasurementDeterminationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  OppositeAngledPlanesMeasurementDeterminationTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

OppositeAngledPlanesMeasurementDeterminationTypeChoicePair * OppositeAngledPlanesMeasurementDeterminationType::getOppositeAngledPlanesMeasurementDeterminationTypePair()
{return OppositeAngledPlanesMeasurementDeterminationTypePair;}

void OppositeAngledPlanesMeasurementDeterminationType::setOppositeAngledPlanesMeasurementDeterminationTypePair(OppositeAngledPlanesMeasurementDeterminationTypeChoicePair * OppositeAngledPlanesMeasurementDeterminationTypePairIn)
{OppositeAngledPlanesMeasurementDeterminationTypePair = OppositeAngledPlanesMeasurementDeterminationTypePairIn;}
OppositeAngledPlanesMeasurementDeterminationTypeChoicePair::OppositeAngledPlanesMeasurementDeterminationTypeChoicePair() {}

OppositeAngledPlanesMeasurementDeterminationTypeChoicePair::OppositeAngledPlanesMeasurementDeterminationTypeChoicePair(
 whichOne OppositeAngledPlanesMeasurementDeterminationTypeTypeIn,
 OppositeAngledPlanesMeasurementDeterminationTypeVal * OppositeAngledPlanesMeasurementDeterminationTypeValueIn)
{
  OppositeAngledPlanesMeasurementDeterminationTypeType = OppositeAngledPlanesMeasurementDeterminationTypeTypeIn;
  OppositeAngledPlanesMeasurementDeterminationTypeValue = OppositeAngledPlanesMeasurementDeterminationTypeValueIn;
}

OppositeAngledPlanesMeasurementDeterminationTypeChoicePair::~OppositeAngledPlanesMeasurementDeterminationTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (OppositeAngledPlanesMeasurementDeterminationTypeType == CheckedE)
    delete OppositeAngledPlanesMeasurementDeterminationTypeValue->Checked;
  else if (OppositeAngledPlanesMeasurementDeterminationTypeType == SetE)
    delete OppositeAngledPlanesMeasurementDeterminationTypeValue->Set;
  delete OppositeAngledPlanesMeasurementDeterminationTypeValue;
  #endif
}

void OppositeAngledPlanesMeasurementDeterminationTypeChoicePair::printSelf(FILE * outFile)
{
  if (OppositeAngledPlanesMeasurementDeterminationTypeType == CheckedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Checked");
      OppositeAngledPlanesMeasurementDeterminationTypeValue->Checked->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Checked>\n");
    }
  else if (OppositeAngledPlanesMeasurementDeterminationTypeType == SetE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Set");
      OppositeAngledPlanesMeasurementDeterminationTypeValue->Set->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class OppositeAngledPlanesRecompType

*/

OppositeAngledPlanesRecompType::OppositeAngledPlanesRecompType() :
  ConstructionMethodBaseType()
{
  BaseFeaturePointList = 0;
}

OppositeAngledPlanesRecompType::OppositeAngledPlanesRecompType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeaturePointListType * BaseFeaturePointListIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeaturePointList = BaseFeaturePointListIn;
}

OppositeAngledPlanesRecompType::~OppositeAngledPlanesRecompType()
{
  #ifndef NODESTRUCT
  delete BaseFeaturePointList;
  #endif
}

void OppositeAngledPlanesRecompType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeaturePointList");
  BaseFeaturePointList->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeaturePointList>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeaturePointListType * OppositeAngledPlanesRecompType::getBaseFeaturePointList()
{return BaseFeaturePointList;}

void OppositeAngledPlanesRecompType::setBaseFeaturePointList(BaseFeaturePointListType * BaseFeaturePointListIn)
{BaseFeaturePointList = BaseFeaturePointListIn;}

/* ***************************************************************** */

/* class OppositeAngledPlanesTransformType

*/

OppositeAngledPlanesTransformType::OppositeAngledPlanesTransformType() :
  ConstructionMethodBaseType()
{
  BaseOppositeAngledPlanes = 0;
  Transformation = 0;
}

OppositeAngledPlanesTransformType::OppositeAngledPlanesTransformType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseOppositeAngledPlanesIn,
 TransformationReferenceType * TransformationIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseOppositeAngledPlanes = BaseOppositeAngledPlanesIn;
  Transformation = TransformationIn;
}

OppositeAngledPlanesTransformType::~OppositeAngledPlanesTransformType()
{
  #ifndef NODESTRUCT
  delete BaseOppositeAngledPlanes;
  delete Transformation;
  #endif
}

void OppositeAngledPlanesTransformType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseOppositeAngledPlanes");
  BaseOppositeAngledPlanes->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseOppositeAngledPlanes>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Transformation");
  Transformation->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Transformation>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * OppositeAngledPlanesTransformType::getBaseOppositeAngledPlanes()
{return BaseOppositeAngledPlanes;}

void OppositeAngledPlanesTransformType::setBaseOppositeAngledPlanes(BaseFeatureType * BaseOppositeAngledPlanesIn)
{BaseOppositeAngledPlanes = BaseOppositeAngledPlanesIn;}

TransformationReferenceType * OppositeAngledPlanesTransformType::getTransformation()
{return Transformation;}

void OppositeAngledPlanesTransformType::setTransformation(TransformationReferenceType * TransformationIn)
{Transformation = TransformationIn;}

/* ***************************************************************** */

/* class OppositeParallelLinesBestFitType

*/

OppositeParallelLinesBestFitType::OppositeParallelLinesBestFitType() :
  ConstructionMethodBaseType()
{
  n = 0;
  BaseFeature = 0;
}

OppositeParallelLinesBestFitType::OppositeParallelLinesBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = 0;
  BaseFeature = BaseFeatureIn;
}

OppositeParallelLinesBestFitType::OppositeParallelLinesBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 NaturalType * nIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = nIn;
  BaseFeature = BaseFeatureIn;
}

OppositeParallelLinesBestFitType::~OppositeParallelLinesBestFitType()
{
  #ifndef NODESTRUCT
  delete n;
  delete BaseFeature;
  #endif
}

void OppositeParallelLinesBestFitType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  {
    if (!BaseFeature)
      {
        fprintf(stderr, "BaseFeature list is missing\n");
        exit(1);
      }
    if (BaseFeature->size() == 0)
      {
        fprintf(stderr, "BaseFeature list is empty\n");
        exit(1);
      }
    if (BaseFeature->size() < 3)
      {
        fprintf(stderr,
                "size of BaseFeature list (%d) less than minimum required (3)\n",
                (int)BaseFeature->size());
        exit(1);
      }
    std::list<SequencedBaseFeatureType *>::iterator iter;
    for (iter = BaseFeature->begin();
         iter != BaseFeature->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<BaseFeature");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</BaseFeature>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool OppositeParallelLinesBestFitType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in OppositeParallelLinesBestFitType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in OppositeParallelLinesBestFitType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OppositeParallelLinesBestFitType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in OppositeParallelLinesBestFitType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * OppositeParallelLinesBestFitType::getn()
{return n;}

void OppositeParallelLinesBestFitType::setn(NaturalType * nIn)
{n = nIn;}

SequencedBaseFeatureTypeLisd * OppositeParallelLinesBestFitType::getBaseFeature()
{return BaseFeature;}

void OppositeParallelLinesBestFitType::setBaseFeature(SequencedBaseFeatureTypeLisd * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class OppositeParallelLinesCastType

*/

OppositeParallelLinesCastType::OppositeParallelLinesCastType() :
  ConstructionMethodBaseType()
{
  BaseFeature = 0;
}

OppositeParallelLinesCastType::OppositeParallelLinesCastType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeature = BaseFeatureIn;
}

OppositeParallelLinesCastType::~OppositeParallelLinesCastType()
{
  #ifndef NODESTRUCT
  delete BaseFeature;
  #endif
}

void OppositeParallelLinesCastType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeature");
  BaseFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * OppositeParallelLinesCastType::getBaseFeature()
{return BaseFeature;}

void OppositeParallelLinesCastType::setBaseFeature(BaseFeatureType * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class OppositeParallelLinesCheckedFeatureType

*/

OppositeParallelLinesCheckedFeatureType::OppositeParallelLinesCheckedFeatureType()
{
  CheckDetails = 0;
}

OppositeParallelLinesCheckedFeatureType::OppositeParallelLinesCheckedFeatureType(
 OppositeParallelLinesCheckedType * CheckDetailsIn)
{
  CheckDetails = CheckDetailsIn;
}

OppositeParallelLinesCheckedFeatureType::~OppositeParallelLinesCheckedFeatureType()
{
  #ifndef NODESTRUCT
  delete CheckDetails;
  #endif
}

void OppositeParallelLinesCheckedFeatureType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (CheckDetails)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CheckDetails");
      CheckDetails->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CheckDetails>\n");
    }
  doSpaces(-INDENT, outFile);
}

OppositeParallelLinesCheckedType * OppositeParallelLinesCheckedFeatureType::getCheckDetails()
{return CheckDetails;}

void OppositeParallelLinesCheckedFeatureType::setCheckDetails(OppositeParallelLinesCheckedType * CheckDetailsIn)
{CheckDetails = CheckDetailsIn;}

/* ***************************************************************** */

/* class OppositeParallelLinesCheckedType

*/

OppositeParallelLinesCheckedType::OppositeParallelLinesCheckedType()
{
  OppositeParallelLinesCheckedTypePair = 0;
}

OppositeParallelLinesCheckedType::OppositeParallelLinesCheckedType(
 OppositeParallelLinesCheckedTypeChoicePair * OppositeParallelLinesCheckedTypePairIn)
{
  OppositeParallelLinesCheckedTypePair = OppositeParallelLinesCheckedTypePairIn;
}

OppositeParallelLinesCheckedType::~OppositeParallelLinesCheckedType()
{
  #ifndef NODESTRUCT
  delete OppositeParallelLinesCheckedTypePair;
  #endif
}

void OppositeParallelLinesCheckedType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  OppositeParallelLinesCheckedTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

OppositeParallelLinesCheckedTypeChoicePair * OppositeParallelLinesCheckedType::getOppositeParallelLinesCheckedTypePair()
{return OppositeParallelLinesCheckedTypePair;}

void OppositeParallelLinesCheckedType::setOppositeParallelLinesCheckedTypePair(OppositeParallelLinesCheckedTypeChoicePair * OppositeParallelLinesCheckedTypePairIn)
{OppositeParallelLinesCheckedTypePair = OppositeParallelLinesCheckedTypePairIn;}
OppositeParallelLinesCheckedTypeChoicePair::OppositeParallelLinesCheckedTypeChoicePair() {}

OppositeParallelLinesCheckedTypeChoicePair::OppositeParallelLinesCheckedTypeChoicePair(
 whichOne OppositeParallelLinesCheckedTypeTypeIn,
 OppositeParallelLinesCheckedTypeVal * OppositeParallelLinesCheckedTypeValueIn)
{
  OppositeParallelLinesCheckedTypeType = OppositeParallelLinesCheckedTypeTypeIn;
  OppositeParallelLinesCheckedTypeValue = OppositeParallelLinesCheckedTypeValueIn;
}

OppositeParallelLinesCheckedTypeChoicePair::~OppositeParallelLinesCheckedTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (OppositeParallelLinesCheckedTypeType == MeasuredE)
    delete OppositeParallelLinesCheckedTypeValue->Measured;
  else if (OppositeParallelLinesCheckedTypeType == ConstructedE)
    delete OppositeParallelLinesCheckedTypeValue->Constructed;
  delete OppositeParallelLinesCheckedTypeValue;
  #endif
}

void OppositeParallelLinesCheckedTypeChoicePair::printSelf(FILE * outFile)
{
  if (OppositeParallelLinesCheckedTypeType == MeasuredE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Measured");
      OppositeParallelLinesCheckedTypeValue->Measured->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Measured>\n");
    }
  else if (OppositeParallelLinesCheckedTypeType == ConstructedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      OppositeParallelLinesCheckedTypeValue->Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
}

/* ***************************************************************** */

/* class OppositeParallelLinesConstructionMethodType

*/

OppositeParallelLinesConstructionMethodType::OppositeParallelLinesConstructionMethodType()
{
  OppositeParallelLinesConstructionMethodTypePair = 0;
}

OppositeParallelLinesConstructionMethodType::OppositeParallelLinesConstructionMethodType(
 OppositeParallelLinesConstructionMethodTypeChoicePair * OppositeParallelLinesConstructionMethodTypePairIn)
{
  OppositeParallelLinesConstructionMethodTypePair = OppositeParallelLinesConstructionMethodTypePairIn;
}

OppositeParallelLinesConstructionMethodType::~OppositeParallelLinesConstructionMethodType()
{
  #ifndef NODESTRUCT
  delete OppositeParallelLinesConstructionMethodTypePair;
  #endif
}

void OppositeParallelLinesConstructionMethodType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (OppositeParallelLinesConstructionMethodTypePair)
    {
      OppositeParallelLinesConstructionMethodTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

OppositeParallelLinesConstructionMethodTypeChoicePair * OppositeParallelLinesConstructionMethodType::getOppositeParallelLinesConstructionMethodTypePair()
{return OppositeParallelLinesConstructionMethodTypePair;}

void OppositeParallelLinesConstructionMethodType::setOppositeParallelLinesConstructionMethodTypePair(OppositeParallelLinesConstructionMethodTypeChoicePair * OppositeParallelLinesConstructionMethodTypePairIn)
{OppositeParallelLinesConstructionMethodTypePair = OppositeParallelLinesConstructionMethodTypePairIn;}
OppositeParallelLinesConstructionMethodTypeChoicePair::OppositeParallelLinesConstructionMethodTypeChoicePair() {}

OppositeParallelLinesConstructionMethodTypeChoicePair::OppositeParallelLinesConstructionMethodTypeChoicePair(
 whichOne OppositeParallelLinesConstructionMethodTypeTypeIn,
 OppositeParallelLinesConstructionMethodTypeVal * OppositeParallelLinesConstructionMethodTypeValueIn)
{
  OppositeParallelLinesConstructionMethodTypeType = OppositeParallelLinesConstructionMethodTypeTypeIn;
  OppositeParallelLinesConstructionMethodTypeValue = OppositeParallelLinesConstructionMethodTypeValueIn;
}

OppositeParallelLinesConstructionMethodTypeChoicePair::~OppositeParallelLinesConstructionMethodTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (OppositeParallelLinesConstructionMethodTypeType == BestFitE)
    delete OppositeParallelLinesConstructionMethodTypeValue->BestFit;
  else if (OppositeParallelLinesConstructionMethodTypeType == RecompensatedE)
    delete OppositeParallelLinesConstructionMethodTypeValue->Recompensated;
  else if (OppositeParallelLinesConstructionMethodTypeType == IntersectionE)
    delete OppositeParallelLinesConstructionMethodTypeValue->Intersection;
  else if (OppositeParallelLinesConstructionMethodTypeType == ProjectionE)
    delete OppositeParallelLinesConstructionMethodTypeValue->Projection;
  else if (OppositeParallelLinesConstructionMethodTypeType == CopyE)
    delete OppositeParallelLinesConstructionMethodTypeValue->Copy;
  else if (OppositeParallelLinesConstructionMethodTypeType == CastE)
    delete OppositeParallelLinesConstructionMethodTypeValue->Cast;
  else if (OppositeParallelLinesConstructionMethodTypeType == TransformE)
    delete OppositeParallelLinesConstructionMethodTypeValue->Transform;
  else if (OppositeParallelLinesConstructionMethodTypeType == FromScanE)
    delete OppositeParallelLinesConstructionMethodTypeValue->FromScan;
  delete OppositeParallelLinesConstructionMethodTypeValue;
  #endif
}

void OppositeParallelLinesConstructionMethodTypeChoicePair::printSelf(FILE * outFile)
{
  if (OppositeParallelLinesConstructionMethodTypeType == BestFitE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BestFit");
      OppositeParallelLinesConstructionMethodTypeValue->BestFit->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BestFit>\n");
    }
  else if (OppositeParallelLinesConstructionMethodTypeType == RecompensatedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Recompensated");
      OppositeParallelLinesConstructionMethodTypeValue->Recompensated->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Recompensated>\n");
    }
  else if (OppositeParallelLinesConstructionMethodTypeType == IntersectionE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Intersection");
      OppositeParallelLinesConstructionMethodTypeValue->Intersection->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Intersection>\n");
    }
  else if (OppositeParallelLinesConstructionMethodTypeType == ProjectionE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Projection");
      OppositeParallelLinesConstructionMethodTypeValue->Projection->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Projection>\n");
    }
  else if (OppositeParallelLinesConstructionMethodTypeType == CopyE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Copy");
      OppositeParallelLinesConstructionMethodTypeValue->Copy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Copy>\n");
    }
  else if (OppositeParallelLinesConstructionMethodTypeType == CastE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Cast");
      OppositeParallelLinesConstructionMethodTypeValue->Cast->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Cast>\n");
    }
  else if (OppositeParallelLinesConstructionMethodTypeType == TransformE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Transform");
      OppositeParallelLinesConstructionMethodTypeValue->Transform->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Transform>\n");
    }
  else if (OppositeParallelLinesConstructionMethodTypeType == FromScanE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FromScan");
      OppositeParallelLinesConstructionMethodTypeValue->FromScan->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FromScan>\n");
    }
}

/* ***************************************************************** */

/* class OppositeParallelLinesCopyType

*/

OppositeParallelLinesCopyType::OppositeParallelLinesCopyType() :
  ConstructionMethodBaseType()
{
  BaseOppositeParallelLines = 0;
}

OppositeParallelLinesCopyType::OppositeParallelLinesCopyType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseOppositeParallelLinesIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseOppositeParallelLines = BaseOppositeParallelLinesIn;
}

OppositeParallelLinesCopyType::~OppositeParallelLinesCopyType()
{
  #ifndef NODESTRUCT
  delete BaseOppositeParallelLines;
  #endif
}

void OppositeParallelLinesCopyType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseOppositeParallelLines");
  BaseOppositeParallelLines->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseOppositeParallelLines>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * OppositeParallelLinesCopyType::getBaseOppositeParallelLines()
{return BaseOppositeParallelLines;}

void OppositeParallelLinesCopyType::setBaseOppositeParallelLines(BaseFeatureType * BaseOppositeParallelLinesIn)
{BaseOppositeParallelLines = BaseOppositeParallelLinesIn;}

/* ***************************************************************** */

/* class OppositeParallelLinesFeatureDefinitionType

*/

OppositeParallelLinesFeatureDefinitionType::OppositeParallelLinesFeatureDefinitionType() :
  CurveFeatureDefinitionBaseType()
{
  InternalExternal = 0;
  Width = 0;
  Length = 0;
  EndType = 0;
  SingleOpenEnd = 0;
  EndRadius1 = 0;
  EndRadius2 = 0;
}

OppositeParallelLinesFeatureDefinitionType::OppositeParallelLinesFeatureDefinitionType(
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * WidthIn,
 LinearValueType * LengthIn,
 SlotEndType * EndTypeIn,
 XmlBoolean * SingleOpenEndIn,
 EndRadiusType * EndRadius1In,
 EndRadiusType * EndRadius2In) :
  CurveFeatureDefinitionBaseType(
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  Width = WidthIn;
  Length = LengthIn;
  EndType = EndTypeIn;
  SingleOpenEnd = SingleOpenEndIn;
  EndRadius1 = EndRadius1In;
  EndRadius2 = EndRadius2In;
}

OppositeParallelLinesFeatureDefinitionType::OppositeParallelLinesFeatureDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * WidthIn,
 LinearValueType * LengthIn,
 SlotEndType * EndTypeIn,
 XmlBoolean * SingleOpenEndIn,
 EndRadiusType * EndRadius1In,
 EndRadiusType * EndRadius2In) :
  CurveFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  Width = WidthIn;
  Length = LengthIn;
  EndType = EndTypeIn;
  SingleOpenEnd = SingleOpenEndIn;
  EndRadius1 = EndRadius1In;
  EndRadius2 = EndRadius2In;
}

OppositeParallelLinesFeatureDefinitionType::~OppositeParallelLinesFeatureDefinitionType()
{
  #ifndef NODESTRUCT
  delete InternalExternal;
  delete Width;
  delete Length;
  delete EndType;
  delete SingleOpenEnd;
  delete EndRadius1;
  delete EndRadius2;
  #endif
}

void OppositeParallelLinesFeatureDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<InternalExternal");
  InternalExternal->printSelf(outFile);
  fprintf(outFile, "</InternalExternal>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Width");
  Width->printSelf(outFile);
  fprintf(outFile, "</Width>\n");
  if (Length)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Length");
      Length->printSelf(outFile);
      fprintf(outFile, "</Length>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<EndType");
  EndType->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</EndType>\n");
  if (SingleOpenEnd)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SingleOpenEnd");
      SingleOpenEnd->printSelf(outFile);
      fprintf(outFile, "</SingleOpenEnd>\n");
    }
  if (EndRadius1)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EndRadius1");
      EndRadius1->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EndRadius1>\n");
    }
  if (EndRadius2)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EndRadius2");
      EndRadius2->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EndRadius2>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool OppositeParallelLinesFeatureDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OppositeParallelLinesFeatureDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OppositeParallelLinesFeatureDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OppositeParallelLinesFeatureDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OppositeParallelLinesFeatureDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

InternalExternalEnumType * OppositeParallelLinesFeatureDefinitionType::getInternalExternal()
{return InternalExternal;}

void OppositeParallelLinesFeatureDefinitionType::setInternalExternal(InternalExternalEnumType * InternalExternalIn)
{InternalExternal = InternalExternalIn;}

LinearValueType * OppositeParallelLinesFeatureDefinitionType::getWidth()
{return Width;}

void OppositeParallelLinesFeatureDefinitionType::setWidth(LinearValueType * WidthIn)
{Width = WidthIn;}

LinearValueType * OppositeParallelLinesFeatureDefinitionType::getLength()
{return Length;}

void OppositeParallelLinesFeatureDefinitionType::setLength(LinearValueType * LengthIn)
{Length = LengthIn;}

SlotEndType * OppositeParallelLinesFeatureDefinitionType::getEndType()
{return EndType;}

void OppositeParallelLinesFeatureDefinitionType::setEndType(SlotEndType * EndTypeIn)
{EndType = EndTypeIn;}

XmlBoolean * OppositeParallelLinesFeatureDefinitionType::getSingleOpenEnd()
{return SingleOpenEnd;}

void OppositeParallelLinesFeatureDefinitionType::setSingleOpenEnd(XmlBoolean * SingleOpenEndIn)
{SingleOpenEnd = SingleOpenEndIn;}

EndRadiusType * OppositeParallelLinesFeatureDefinitionType::getEndRadius1()
{return EndRadius1;}

void OppositeParallelLinesFeatureDefinitionType::setEndRadius1(EndRadiusType * EndRadius1In)
{EndRadius1 = EndRadius1In;}

EndRadiusType * OppositeParallelLinesFeatureDefinitionType::getEndRadius2()
{return EndRadius2;}

void OppositeParallelLinesFeatureDefinitionType::setEndRadius2(EndRadiusType * EndRadius2In)
{EndRadius2 = EndRadius2In;}

/* ***************************************************************** */

/* class OppositeParallelLinesFeatureItemType

*/

OppositeParallelLinesFeatureItemType::OppositeParallelLinesFeatureItemType() :
  CurveFeatureItemBaseType()
{
  DeterminationMode = 0;
}

OppositeParallelLinesFeatureItemType::OppositeParallelLinesFeatureItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 OppositeParallelLinesMeasurementDeterminationType * DeterminationModeIn) :
  CurveFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

OppositeParallelLinesFeatureItemType::OppositeParallelLinesFeatureItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 OppositeParallelLinesMeasurementDeterminationType * DeterminationModeIn) :
  CurveFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

OppositeParallelLinesFeatureItemType::~OppositeParallelLinesFeatureItemType()
{
  #ifndef NODESTRUCT
  delete DeterminationMode;
  #endif
}

void OppositeParallelLinesFeatureItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<DeterminationMode");
  DeterminationMode->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeterminationMode>\n");
  doSpaces(-INDENT, outFile);
}

bool OppositeParallelLinesFeatureItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OppositeParallelLinesFeatureItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OppositeParallelLinesFeatureItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OppositeParallelLinesFeatureItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OppositeParallelLinesFeatureItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

OppositeParallelLinesMeasurementDeterminationType * OppositeParallelLinesFeatureItemType::getDeterminationMode()
{return DeterminationMode;}

void OppositeParallelLinesFeatureItemType::setDeterminationMode(OppositeParallelLinesMeasurementDeterminationType * DeterminationModeIn)
{DeterminationMode = DeterminationModeIn;}

/* ***************************************************************** */

/* class OppositeParallelLinesFeatureMeasurementType

*/

OppositeParallelLinesFeatureMeasurementType::OppositeParallelLinesFeatureMeasurementType() :
  CurveFeatureMeasurementBaseType()
{
  CenterLine = 0;
  Normal = 0;
  Width = 0;
  WidthMin = 0;
  WidthMax = 0;
  Length = 0;
  LengthMin = 0;
  LengthMax = 0;
  EndRadius1 = 0;
  EndRadius2 = 0;
  Form = 0;
}

OppositeParallelLinesFeatureMeasurementType::OppositeParallelLinesFeatureMeasurementType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredPointAndVectorType * CenterLineIn,
 MeasuredUnitVectorType * NormalIn,
 MeasuredLinearValueType * WidthIn,
 MeasuredLinearValueType * WidthMinIn,
 MeasuredLinearValueType * WidthMaxIn,
 MeasuredLinearValueType * LengthIn,
 MeasuredLinearValueType * LengthMinIn,
 MeasuredLinearValueType * LengthMaxIn,
 MeasuredEndRadiusType * EndRadius1In,
 MeasuredEndRadiusType * EndRadius2In,
 MeasuredLinearValueType * FormIn) :
  CurveFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  CenterLine = CenterLineIn;
  Normal = NormalIn;
  Width = WidthIn;
  WidthMin = WidthMinIn;
  WidthMax = WidthMaxIn;
  Length = LengthIn;
  LengthMin = LengthMinIn;
  LengthMax = LengthMaxIn;
  EndRadius1 = EndRadius1In;
  EndRadius2 = EndRadius2In;
  Form = FormIn;
}

OppositeParallelLinesFeatureMeasurementType::OppositeParallelLinesFeatureMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredPointAndVectorType * CenterLineIn,
 MeasuredUnitVectorType * NormalIn,
 MeasuredLinearValueType * WidthIn,
 MeasuredLinearValueType * WidthMinIn,
 MeasuredLinearValueType * WidthMaxIn,
 MeasuredLinearValueType * LengthIn,
 MeasuredLinearValueType * LengthMinIn,
 MeasuredLinearValueType * LengthMaxIn,
 MeasuredEndRadiusType * EndRadius1In,
 MeasuredEndRadiusType * EndRadius2In,
 MeasuredLinearValueType * FormIn) :
  CurveFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  CenterLine = CenterLineIn;
  Normal = NormalIn;
  Width = WidthIn;
  WidthMin = WidthMinIn;
  WidthMax = WidthMaxIn;
  Length = LengthIn;
  LengthMin = LengthMinIn;
  LengthMax = LengthMaxIn;
  EndRadius1 = EndRadius1In;
  EndRadius2 = EndRadius2In;
  Form = FormIn;
}

OppositeParallelLinesFeatureMeasurementType::~OppositeParallelLinesFeatureMeasurementType()
{
  #ifndef NODESTRUCT
  delete CenterLine;
  delete Normal;
  delete Width;
  delete WidthMin;
  delete WidthMax;
  delete Length;
  delete LengthMin;
  delete LengthMax;
  delete EndRadius1;
  delete EndRadius2;
  delete Form;
  #endif
}

void OppositeParallelLinesFeatureMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  if (CenterLine)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CenterLine");
      CenterLine->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CenterLine>\n");
    }
  if (Normal)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Normal");
      Normal->printSelf(outFile);
      fprintf(outFile, "</Normal>\n");
    }
  if (Width)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Width");
      Width->printSelf(outFile);
      fprintf(outFile, "</Width>\n");
    }
  if (WidthMin)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WidthMin");
      WidthMin->printSelf(outFile);
      fprintf(outFile, "</WidthMin>\n");
    }
  if (WidthMax)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WidthMax");
      WidthMax->printSelf(outFile);
      fprintf(outFile, "</WidthMax>\n");
    }
  if (Length)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Length");
      Length->printSelf(outFile);
      fprintf(outFile, "</Length>\n");
    }
  if (LengthMin)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LengthMin");
      LengthMin->printSelf(outFile);
      fprintf(outFile, "</LengthMin>\n");
    }
  if (LengthMax)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LengthMax");
      LengthMax->printSelf(outFile);
      fprintf(outFile, "</LengthMax>\n");
    }
  if (EndRadius1)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EndRadius1");
      EndRadius1->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EndRadius1>\n");
    }
  if (EndRadius2)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EndRadius2");
      EndRadius2->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EndRadius2>\n");
    }
  if (Form)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Form");
      Form->printSelf(outFile);
      fprintf(outFile, "</Form>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool OppositeParallelLinesFeatureMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OppositeParallelLinesFeatureMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OppositeParallelLinesFeatureMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OppositeParallelLinesFeatureMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OppositeParallelLinesFeatureMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredPointAndVectorType * OppositeParallelLinesFeatureMeasurementType::getCenterLine()
{return CenterLine;}

void OppositeParallelLinesFeatureMeasurementType::setCenterLine(MeasuredPointAndVectorType * CenterLineIn)
{CenterLine = CenterLineIn;}

MeasuredUnitVectorType * OppositeParallelLinesFeatureMeasurementType::getNormal()
{return Normal;}

void OppositeParallelLinesFeatureMeasurementType::setNormal(MeasuredUnitVectorType * NormalIn)
{Normal = NormalIn;}

MeasuredLinearValueType * OppositeParallelLinesFeatureMeasurementType::getWidth()
{return Width;}

void OppositeParallelLinesFeatureMeasurementType::setWidth(MeasuredLinearValueType * WidthIn)
{Width = WidthIn;}

MeasuredLinearValueType * OppositeParallelLinesFeatureMeasurementType::getWidthMin()
{return WidthMin;}

void OppositeParallelLinesFeatureMeasurementType::setWidthMin(MeasuredLinearValueType * WidthMinIn)
{WidthMin = WidthMinIn;}

MeasuredLinearValueType * OppositeParallelLinesFeatureMeasurementType::getWidthMax()
{return WidthMax;}

void OppositeParallelLinesFeatureMeasurementType::setWidthMax(MeasuredLinearValueType * WidthMaxIn)
{WidthMax = WidthMaxIn;}

MeasuredLinearValueType * OppositeParallelLinesFeatureMeasurementType::getLength()
{return Length;}

void OppositeParallelLinesFeatureMeasurementType::setLength(MeasuredLinearValueType * LengthIn)
{Length = LengthIn;}

MeasuredLinearValueType * OppositeParallelLinesFeatureMeasurementType::getLengthMin()
{return LengthMin;}

void OppositeParallelLinesFeatureMeasurementType::setLengthMin(MeasuredLinearValueType * LengthMinIn)
{LengthMin = LengthMinIn;}

MeasuredLinearValueType * OppositeParallelLinesFeatureMeasurementType::getLengthMax()
{return LengthMax;}

void OppositeParallelLinesFeatureMeasurementType::setLengthMax(MeasuredLinearValueType * LengthMaxIn)
{LengthMax = LengthMaxIn;}

MeasuredEndRadiusType * OppositeParallelLinesFeatureMeasurementType::getEndRadius1()
{return EndRadius1;}

void OppositeParallelLinesFeatureMeasurementType::setEndRadius1(MeasuredEndRadiusType * EndRadius1In)
{EndRadius1 = EndRadius1In;}

MeasuredEndRadiusType * OppositeParallelLinesFeatureMeasurementType::getEndRadius2()
{return EndRadius2;}

void OppositeParallelLinesFeatureMeasurementType::setEndRadius2(MeasuredEndRadiusType * EndRadius2In)
{EndRadius2 = EndRadius2In;}

MeasuredLinearValueType * OppositeParallelLinesFeatureMeasurementType::getForm()
{return Form;}

void OppositeParallelLinesFeatureMeasurementType::setForm(MeasuredLinearValueType * FormIn)
{Form = FormIn;}

/* ***************************************************************** */

/* class OppositeParallelLinesFeatureNominalType

*/

OppositeParallelLinesFeatureNominalType::OppositeParallelLinesFeatureNominalType() :
  CurveFeatureNominalBaseType()
{
  CenterLine = 0;
  Normal = 0;
  Constructed = 0;
}

OppositeParallelLinesFeatureNominalType::OppositeParallelLinesFeatureNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 PointAndVectorType * CenterLineIn,
 UnitVectorType * NormalIn,
 OppositeParallelLinesConstructionMethodType * ConstructedIn) :
  CurveFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    SurfaceFeatureNominalIdIn)
{
  CenterLine = CenterLineIn;
  Normal = NormalIn;
  Constructed = ConstructedIn;
}

OppositeParallelLinesFeatureNominalType::OppositeParallelLinesFeatureNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 PointAndVectorType * CenterLineIn,
 UnitVectorType * NormalIn,
 OppositeParallelLinesConstructionMethodType * ConstructedIn) :
  CurveFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    SurfaceFeatureNominalIdIn)
{
  CenterLine = CenterLineIn;
  Normal = NormalIn;
  Constructed = ConstructedIn;
}

OppositeParallelLinesFeatureNominalType::~OppositeParallelLinesFeatureNominalType()
{
  #ifndef NODESTRUCT
  delete CenterLine;
  delete Normal;
  delete Constructed;
  #endif
}

void OppositeParallelLinesFeatureNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (SurfaceFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SurfaceFeatureNominalId");
      SurfaceFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</SurfaceFeatureNominalId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CenterLine");
  CenterLine->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</CenterLine>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Normal");
  Normal->printSelf(outFile);
  fprintf(outFile, "</Normal>\n");
  if (Constructed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool OppositeParallelLinesFeatureNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OppositeParallelLinesFeatureNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OppositeParallelLinesFeatureNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OppositeParallelLinesFeatureNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OppositeParallelLinesFeatureNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

PointAndVectorType * OppositeParallelLinesFeatureNominalType::getCenterLine()
{return CenterLine;}

void OppositeParallelLinesFeatureNominalType::setCenterLine(PointAndVectorType * CenterLineIn)
{CenterLine = CenterLineIn;}

UnitVectorType * OppositeParallelLinesFeatureNominalType::getNormal()
{return Normal;}

void OppositeParallelLinesFeatureNominalType::setNormal(UnitVectorType * NormalIn)
{Normal = NormalIn;}

OppositeParallelLinesConstructionMethodType * OppositeParallelLinesFeatureNominalType::getConstructed()
{return Constructed;}

void OppositeParallelLinesFeatureNominalType::setConstructed(OppositeParallelLinesConstructionMethodType * ConstructedIn)
{Constructed = ConstructedIn;}

/* ***************************************************************** */

/* class OppositeParallelLinesFromScanType

*/

OppositeParallelLinesFromScanType::OppositeParallelLinesFromScanType() :
  ConstructionMethodBaseType()
{
  SurfaceFeature = 0;
  SearchRadius = 0;
  Depth = 0;
}

OppositeParallelLinesFromScanType::OppositeParallelLinesFromScanType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * SurfaceFeatureIn,
 LinearValueType * SearchRadiusIn,
 LinearValueType * DepthIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  SurfaceFeature = SurfaceFeatureIn;
  SearchRadius = SearchRadiusIn;
  Depth = DepthIn;
}

OppositeParallelLinesFromScanType::~OppositeParallelLinesFromScanType()
{
  #ifndef NODESTRUCT
  delete SurfaceFeature;
  delete SearchRadius;
  delete Depth;
  #endif
}

void OppositeParallelLinesFromScanType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<SurfaceFeature");
  SurfaceFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</SurfaceFeature>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<SearchRadius");
  SearchRadius->printSelf(outFile);
  fprintf(outFile, "</SearchRadius>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Depth");
  Depth->printSelf(outFile);
  fprintf(outFile, "</Depth>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * OppositeParallelLinesFromScanType::getSurfaceFeature()
{return SurfaceFeature;}

void OppositeParallelLinesFromScanType::setSurfaceFeature(BaseFeatureType * SurfaceFeatureIn)
{SurfaceFeature = SurfaceFeatureIn;}

LinearValueType * OppositeParallelLinesFromScanType::getSearchRadius()
{return SearchRadius;}

void OppositeParallelLinesFromScanType::setSearchRadius(LinearValueType * SearchRadiusIn)
{SearchRadius = SearchRadiusIn;}

LinearValueType * OppositeParallelLinesFromScanType::getDepth()
{return Depth;}

void OppositeParallelLinesFromScanType::setDepth(LinearValueType * DepthIn)
{Depth = DepthIn;}

/* ***************************************************************** */

/* class OppositeParallelLinesIntersectionType

*/

OppositeParallelLinesIntersectionType::OppositeParallelLinesIntersectionType() :
  ConstructionMethodBaseType()
{
  IntersectionPlane = 0;
  IntersectionFeature = 0;
}

OppositeParallelLinesIntersectionType::OppositeParallelLinesIntersectionType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * IntersectionPlaneIn,
 BaseFeatureType * IntersectionFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  IntersectionPlane = IntersectionPlaneIn;
  IntersectionFeature = IntersectionFeatureIn;
}

OppositeParallelLinesIntersectionType::~OppositeParallelLinesIntersectionType()
{
  #ifndef NODESTRUCT
  delete IntersectionPlane;
  delete IntersectionFeature;
  #endif
}

void OppositeParallelLinesIntersectionType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<IntersectionPlane");
  IntersectionPlane->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</IntersectionPlane>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<IntersectionFeature");
  IntersectionFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</IntersectionFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * OppositeParallelLinesIntersectionType::getIntersectionPlane()
{return IntersectionPlane;}

void OppositeParallelLinesIntersectionType::setIntersectionPlane(BaseFeatureType * IntersectionPlaneIn)
{IntersectionPlane = IntersectionPlaneIn;}

BaseFeatureType * OppositeParallelLinesIntersectionType::getIntersectionFeature()
{return IntersectionFeature;}

void OppositeParallelLinesIntersectionType::setIntersectionFeature(BaseFeatureType * IntersectionFeatureIn)
{IntersectionFeature = IntersectionFeatureIn;}

/* ***************************************************************** */

/* class OppositeParallelLinesMeasurementDeterminationType

*/

OppositeParallelLinesMeasurementDeterminationType::OppositeParallelLinesMeasurementDeterminationType()
{
  OppositeParallelLinesMeasurementDeterminationTypePair = 0;
}

OppositeParallelLinesMeasurementDeterminationType::OppositeParallelLinesMeasurementDeterminationType(
 OppositeParallelLinesMeasurementDeterminationTypeChoicePair * OppositeParallelLinesMeasurementDeterminationTypePairIn)
{
  OppositeParallelLinesMeasurementDeterminationTypePair = OppositeParallelLinesMeasurementDeterminationTypePairIn;
}

OppositeParallelLinesMeasurementDeterminationType::~OppositeParallelLinesMeasurementDeterminationType()
{
  #ifndef NODESTRUCT
  delete OppositeParallelLinesMeasurementDeterminationTypePair;
  #endif
}

void OppositeParallelLinesMeasurementDeterminationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  OppositeParallelLinesMeasurementDeterminationTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

OppositeParallelLinesMeasurementDeterminationTypeChoicePair * OppositeParallelLinesMeasurementDeterminationType::getOppositeParallelLinesMeasurementDeterminationTypePair()
{return OppositeParallelLinesMeasurementDeterminationTypePair;}

void OppositeParallelLinesMeasurementDeterminationType::setOppositeParallelLinesMeasurementDeterminationTypePair(OppositeParallelLinesMeasurementDeterminationTypeChoicePair * OppositeParallelLinesMeasurementDeterminationTypePairIn)
{OppositeParallelLinesMeasurementDeterminationTypePair = OppositeParallelLinesMeasurementDeterminationTypePairIn;}
OppositeParallelLinesMeasurementDeterminationTypeChoicePair::OppositeParallelLinesMeasurementDeterminationTypeChoicePair() {}

OppositeParallelLinesMeasurementDeterminationTypeChoicePair::OppositeParallelLinesMeasurementDeterminationTypeChoicePair(
 whichOne OppositeParallelLinesMeasurementDeterminationTypeTypeIn,
 OppositeParallelLinesMeasurementDeterminationTypeVal * OppositeParallelLinesMeasurementDeterminationTypeValueIn)
{
  OppositeParallelLinesMeasurementDeterminationTypeType = OppositeParallelLinesMeasurementDeterminationTypeTypeIn;
  OppositeParallelLinesMeasurementDeterminationTypeValue = OppositeParallelLinesMeasurementDeterminationTypeValueIn;
}

OppositeParallelLinesMeasurementDeterminationTypeChoicePair::~OppositeParallelLinesMeasurementDeterminationTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (OppositeParallelLinesMeasurementDeterminationTypeType == CheckedE)
    delete OppositeParallelLinesMeasurementDeterminationTypeValue->Checked;
  else if (OppositeParallelLinesMeasurementDeterminationTypeType == SetE)
    delete OppositeParallelLinesMeasurementDeterminationTypeValue->Set;
  delete OppositeParallelLinesMeasurementDeterminationTypeValue;
  #endif
}

void OppositeParallelLinesMeasurementDeterminationTypeChoicePair::printSelf(FILE * outFile)
{
  if (OppositeParallelLinesMeasurementDeterminationTypeType == CheckedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Checked");
      OppositeParallelLinesMeasurementDeterminationTypeValue->Checked->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Checked>\n");
    }
  else if (OppositeParallelLinesMeasurementDeterminationTypeType == SetE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Set");
      OppositeParallelLinesMeasurementDeterminationTypeValue->Set->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class OppositeParallelLinesProjectionType

*/

OppositeParallelLinesProjectionType::OppositeParallelLinesProjectionType() :
  ConstructionMethodBaseType()
{
  ProjectionPlane = 0;
  ProjectionOppositeParallelLines = 0;
}

OppositeParallelLinesProjectionType::OppositeParallelLinesProjectionType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * ProjectionPlaneIn,
 BaseFeatureType * ProjectionOppositeParallelLinesIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  ProjectionPlane = ProjectionPlaneIn;
  ProjectionOppositeParallelLines = ProjectionOppositeParallelLinesIn;
}

OppositeParallelLinesProjectionType::~OppositeParallelLinesProjectionType()
{
  #ifndef NODESTRUCT
  delete ProjectionPlane;
  delete ProjectionOppositeParallelLines;
  #endif
}

void OppositeParallelLinesProjectionType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ProjectionPlane");
  ProjectionPlane->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ProjectionPlane>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<ProjectionOppositeParallelLines");
  ProjectionOppositeParallelLines->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ProjectionOppositeParallelLines>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * OppositeParallelLinesProjectionType::getProjectionPlane()
{return ProjectionPlane;}

void OppositeParallelLinesProjectionType::setProjectionPlane(BaseFeatureType * ProjectionPlaneIn)
{ProjectionPlane = ProjectionPlaneIn;}

BaseFeatureType * OppositeParallelLinesProjectionType::getProjectionOppositeParallelLines()
{return ProjectionOppositeParallelLines;}

void OppositeParallelLinesProjectionType::setProjectionOppositeParallelLines(BaseFeatureType * ProjectionOppositeParallelLinesIn)
{ProjectionOppositeParallelLines = ProjectionOppositeParallelLinesIn;}

/* ***************************************************************** */

/* class OppositeParallelLinesRecompType

*/

OppositeParallelLinesRecompType::OppositeParallelLinesRecompType() :
  ConstructionMethodBaseType()
{
  BaseFeaturePointList = 0;
}

OppositeParallelLinesRecompType::OppositeParallelLinesRecompType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeaturePointListType * BaseFeaturePointListIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeaturePointList = BaseFeaturePointListIn;
}

OppositeParallelLinesRecompType::~OppositeParallelLinesRecompType()
{
  #ifndef NODESTRUCT
  delete BaseFeaturePointList;
  #endif
}

void OppositeParallelLinesRecompType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeaturePointList");
  BaseFeaturePointList->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeaturePointList>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeaturePointListType * OppositeParallelLinesRecompType::getBaseFeaturePointList()
{return BaseFeaturePointList;}

void OppositeParallelLinesRecompType::setBaseFeaturePointList(BaseFeaturePointListType * BaseFeaturePointListIn)
{BaseFeaturePointList = BaseFeaturePointListIn;}

/* ***************************************************************** */

/* class OppositeParallelLinesTransformType

*/

OppositeParallelLinesTransformType::OppositeParallelLinesTransformType() :
  ConstructionMethodBaseType()
{
  BaseOppositeParallelLines = 0;
  Transformation = 0;
}

OppositeParallelLinesTransformType::OppositeParallelLinesTransformType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseOppositeParallelLinesIn,
 TransformationReferenceType * TransformationIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseOppositeParallelLines = BaseOppositeParallelLinesIn;
  Transformation = TransformationIn;
}

OppositeParallelLinesTransformType::~OppositeParallelLinesTransformType()
{
  #ifndef NODESTRUCT
  delete BaseOppositeParallelLines;
  delete Transformation;
  #endif
}

void OppositeParallelLinesTransformType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseOppositeParallelLines");
  BaseOppositeParallelLines->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseOppositeParallelLines>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Transformation");
  Transformation->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Transformation>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * OppositeParallelLinesTransformType::getBaseOppositeParallelLines()
{return BaseOppositeParallelLines;}

void OppositeParallelLinesTransformType::setBaseOppositeParallelLines(BaseFeatureType * BaseOppositeParallelLinesIn)
{BaseOppositeParallelLines = BaseOppositeParallelLinesIn;}

TransformationReferenceType * OppositeParallelLinesTransformType::getTransformation()
{return Transformation;}

void OppositeParallelLinesTransformType::setTransformation(TransformationReferenceType * TransformationIn)
{Transformation = TransformationIn;}

/* ***************************************************************** */

/* class OppositeParallelPlanesBestFitType

*/

OppositeParallelPlanesBestFitType::OppositeParallelPlanesBestFitType() :
  ConstructionMethodBaseType()
{
  n = 0;
  BaseFeature = 0;
}

OppositeParallelPlanesBestFitType::OppositeParallelPlanesBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = 0;
  BaseFeature = BaseFeatureIn;
}

OppositeParallelPlanesBestFitType::OppositeParallelPlanesBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 NaturalType * nIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = nIn;
  BaseFeature = BaseFeatureIn;
}

OppositeParallelPlanesBestFitType::~OppositeParallelPlanesBestFitType()
{
  #ifndef NODESTRUCT
  delete n;
  delete BaseFeature;
  #endif
}

void OppositeParallelPlanesBestFitType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  {
    if (!BaseFeature)
      {
        fprintf(stderr, "BaseFeature list is missing\n");
        exit(1);
      }
    if (BaseFeature->size() == 0)
      {
        fprintf(stderr, "BaseFeature list is empty\n");
        exit(1);
      }
    if (BaseFeature->size() < 4)
      {
        fprintf(stderr,
                "size of BaseFeature list (%d) less than minimum required (4)\n",
                (int)BaseFeature->size());
        exit(1);
      }
    std::list<SequencedBaseFeatureType *>::iterator iter;
    for (iter = BaseFeature->begin();
         iter != BaseFeature->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<BaseFeature");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</BaseFeature>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool OppositeParallelPlanesBestFitType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in OppositeParallelPlanesBestFitType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in OppositeParallelPlanesBestFitType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OppositeParallelPlanesBestFitType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in OppositeParallelPlanesBestFitType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * OppositeParallelPlanesBestFitType::getn()
{return n;}

void OppositeParallelPlanesBestFitType::setn(NaturalType * nIn)
{n = nIn;}

SequencedBaseFeatureTypeLisd * OppositeParallelPlanesBestFitType::getBaseFeature()
{return BaseFeature;}

void OppositeParallelPlanesBestFitType::setBaseFeature(SequencedBaseFeatureTypeLisd * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class OppositeParallelPlanesCastType

*/

OppositeParallelPlanesCastType::OppositeParallelPlanesCastType() :
  ConstructionMethodBaseType()
{
  BaseFeature = 0;
}

OppositeParallelPlanesCastType::OppositeParallelPlanesCastType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeature = BaseFeatureIn;
}

OppositeParallelPlanesCastType::~OppositeParallelPlanesCastType()
{
  #ifndef NODESTRUCT
  delete BaseFeature;
  #endif
}

void OppositeParallelPlanesCastType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeature");
  BaseFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * OppositeParallelPlanesCastType::getBaseFeature()
{return BaseFeature;}

void OppositeParallelPlanesCastType::setBaseFeature(BaseFeatureType * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class OppositeParallelPlanesCheckedFeatureType

*/

OppositeParallelPlanesCheckedFeatureType::OppositeParallelPlanesCheckedFeatureType()
{
  CheckDetails = 0;
}

OppositeParallelPlanesCheckedFeatureType::OppositeParallelPlanesCheckedFeatureType(
 OppositeParallelPlanesCheckedType * CheckDetailsIn)
{
  CheckDetails = CheckDetailsIn;
}

OppositeParallelPlanesCheckedFeatureType::~OppositeParallelPlanesCheckedFeatureType()
{
  #ifndef NODESTRUCT
  delete CheckDetails;
  #endif
}

void OppositeParallelPlanesCheckedFeatureType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (CheckDetails)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CheckDetails");
      CheckDetails->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CheckDetails>\n");
    }
  doSpaces(-INDENT, outFile);
}

OppositeParallelPlanesCheckedType * OppositeParallelPlanesCheckedFeatureType::getCheckDetails()
{return CheckDetails;}

void OppositeParallelPlanesCheckedFeatureType::setCheckDetails(OppositeParallelPlanesCheckedType * CheckDetailsIn)
{CheckDetails = CheckDetailsIn;}

/* ***************************************************************** */

/* class OppositeParallelPlanesCheckedType

*/

OppositeParallelPlanesCheckedType::OppositeParallelPlanesCheckedType()
{
  OppositeParallelPlanesCheckedTypePair = 0;
}

OppositeParallelPlanesCheckedType::OppositeParallelPlanesCheckedType(
 OppositeParallelPlanesCheckedTypeChoicePair * OppositeParallelPlanesCheckedTypePairIn)
{
  OppositeParallelPlanesCheckedTypePair = OppositeParallelPlanesCheckedTypePairIn;
}

OppositeParallelPlanesCheckedType::~OppositeParallelPlanesCheckedType()
{
  #ifndef NODESTRUCT
  delete OppositeParallelPlanesCheckedTypePair;
  #endif
}

void OppositeParallelPlanesCheckedType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  OppositeParallelPlanesCheckedTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

OppositeParallelPlanesCheckedTypeChoicePair * OppositeParallelPlanesCheckedType::getOppositeParallelPlanesCheckedTypePair()
{return OppositeParallelPlanesCheckedTypePair;}

void OppositeParallelPlanesCheckedType::setOppositeParallelPlanesCheckedTypePair(OppositeParallelPlanesCheckedTypeChoicePair * OppositeParallelPlanesCheckedTypePairIn)
{OppositeParallelPlanesCheckedTypePair = OppositeParallelPlanesCheckedTypePairIn;}
OppositeParallelPlanesCheckedTypeChoicePair::OppositeParallelPlanesCheckedTypeChoicePair() {}

OppositeParallelPlanesCheckedTypeChoicePair::OppositeParallelPlanesCheckedTypeChoicePair(
 whichOne OppositeParallelPlanesCheckedTypeTypeIn,
 OppositeParallelPlanesCheckedTypeVal * OppositeParallelPlanesCheckedTypeValueIn)
{
  OppositeParallelPlanesCheckedTypeType = OppositeParallelPlanesCheckedTypeTypeIn;
  OppositeParallelPlanesCheckedTypeValue = OppositeParallelPlanesCheckedTypeValueIn;
}

OppositeParallelPlanesCheckedTypeChoicePair::~OppositeParallelPlanesCheckedTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (OppositeParallelPlanesCheckedTypeType == MeasuredE)
    delete OppositeParallelPlanesCheckedTypeValue->Measured;
  else if (OppositeParallelPlanesCheckedTypeType == ConstructedE)
    delete OppositeParallelPlanesCheckedTypeValue->Constructed;
  delete OppositeParallelPlanesCheckedTypeValue;
  #endif
}

void OppositeParallelPlanesCheckedTypeChoicePair::printSelf(FILE * outFile)
{
  if (OppositeParallelPlanesCheckedTypeType == MeasuredE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Measured");
      OppositeParallelPlanesCheckedTypeValue->Measured->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Measured>\n");
    }
  else if (OppositeParallelPlanesCheckedTypeType == ConstructedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      OppositeParallelPlanesCheckedTypeValue->Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
}

/* ***************************************************************** */

/* class OppositeParallelPlanesConstructionMethodType

*/

OppositeParallelPlanesConstructionMethodType::OppositeParallelPlanesConstructionMethodType()
{
  OppositeParallelPlanesConstructionMethodTypePair = 0;
}

OppositeParallelPlanesConstructionMethodType::OppositeParallelPlanesConstructionMethodType(
 OppositeParallelPlanesConstructionMethodTypeChoicePair * OppositeParallelPlanesConstructionMethodTypePairIn)
{
  OppositeParallelPlanesConstructionMethodTypePair = OppositeParallelPlanesConstructionMethodTypePairIn;
}

OppositeParallelPlanesConstructionMethodType::~OppositeParallelPlanesConstructionMethodType()
{
  #ifndef NODESTRUCT
  delete OppositeParallelPlanesConstructionMethodTypePair;
  #endif
}

void OppositeParallelPlanesConstructionMethodType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (OppositeParallelPlanesConstructionMethodTypePair)
    {
      OppositeParallelPlanesConstructionMethodTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

OppositeParallelPlanesConstructionMethodTypeChoicePair * OppositeParallelPlanesConstructionMethodType::getOppositeParallelPlanesConstructionMethodTypePair()
{return OppositeParallelPlanesConstructionMethodTypePair;}

void OppositeParallelPlanesConstructionMethodType::setOppositeParallelPlanesConstructionMethodTypePair(OppositeParallelPlanesConstructionMethodTypeChoicePair * OppositeParallelPlanesConstructionMethodTypePairIn)
{OppositeParallelPlanesConstructionMethodTypePair = OppositeParallelPlanesConstructionMethodTypePairIn;}
OppositeParallelPlanesConstructionMethodTypeChoicePair::OppositeParallelPlanesConstructionMethodTypeChoicePair() {}

OppositeParallelPlanesConstructionMethodTypeChoicePair::OppositeParallelPlanesConstructionMethodTypeChoicePair(
 whichOne OppositeParallelPlanesConstructionMethodTypeTypeIn,
 OppositeParallelPlanesConstructionMethodTypeVal * OppositeParallelPlanesConstructionMethodTypeValueIn)
{
  OppositeParallelPlanesConstructionMethodTypeType = OppositeParallelPlanesConstructionMethodTypeTypeIn;
  OppositeParallelPlanesConstructionMethodTypeValue = OppositeParallelPlanesConstructionMethodTypeValueIn;
}

OppositeParallelPlanesConstructionMethodTypeChoicePair::~OppositeParallelPlanesConstructionMethodTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (OppositeParallelPlanesConstructionMethodTypeType == BestFitE)
    delete OppositeParallelPlanesConstructionMethodTypeValue->BestFit;
  else if (OppositeParallelPlanesConstructionMethodTypeType == RecompensatedE)
    delete OppositeParallelPlanesConstructionMethodTypeValue->Recompensated;
  else if (OppositeParallelPlanesConstructionMethodTypeType == CopyE)
    delete OppositeParallelPlanesConstructionMethodTypeValue->Copy;
  else if (OppositeParallelPlanesConstructionMethodTypeType == CastE)
    delete OppositeParallelPlanesConstructionMethodTypeValue->Cast;
  else if (OppositeParallelPlanesConstructionMethodTypeType == TransformE)
    delete OppositeParallelPlanesConstructionMethodTypeValue->Transform;
  else if (OppositeParallelPlanesConstructionMethodTypeType == FromScanE)
    delete OppositeParallelPlanesConstructionMethodTypeValue->FromScan;
  delete OppositeParallelPlanesConstructionMethodTypeValue;
  #endif
}

void OppositeParallelPlanesConstructionMethodTypeChoicePair::printSelf(FILE * outFile)
{
  if (OppositeParallelPlanesConstructionMethodTypeType == BestFitE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BestFit");
      OppositeParallelPlanesConstructionMethodTypeValue->BestFit->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BestFit>\n");
    }
  else if (OppositeParallelPlanesConstructionMethodTypeType == RecompensatedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Recompensated");
      OppositeParallelPlanesConstructionMethodTypeValue->Recompensated->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Recompensated>\n");
    }
  else if (OppositeParallelPlanesConstructionMethodTypeType == CopyE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Copy");
      OppositeParallelPlanesConstructionMethodTypeValue->Copy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Copy>\n");
    }
  else if (OppositeParallelPlanesConstructionMethodTypeType == CastE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Cast");
      OppositeParallelPlanesConstructionMethodTypeValue->Cast->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Cast>\n");
    }
  else if (OppositeParallelPlanesConstructionMethodTypeType == TransformE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Transform");
      OppositeParallelPlanesConstructionMethodTypeValue->Transform->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Transform>\n");
    }
  else if (OppositeParallelPlanesConstructionMethodTypeType == FromScanE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FromScan");
      OppositeParallelPlanesConstructionMethodTypeValue->FromScan->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FromScan>\n");
    }
}

/* ***************************************************************** */

/* class OppositeParallelPlanesCopyType

*/

OppositeParallelPlanesCopyType::OppositeParallelPlanesCopyType() :
  ConstructionMethodBaseType()
{
  BaseOppositeParallelPlanes = 0;
}

OppositeParallelPlanesCopyType::OppositeParallelPlanesCopyType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseOppositeParallelPlanesIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseOppositeParallelPlanes = BaseOppositeParallelPlanesIn;
}

OppositeParallelPlanesCopyType::~OppositeParallelPlanesCopyType()
{
  #ifndef NODESTRUCT
  delete BaseOppositeParallelPlanes;
  #endif
}

void OppositeParallelPlanesCopyType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseOppositeParallelPlanes");
  BaseOppositeParallelPlanes->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseOppositeParallelPlanes>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * OppositeParallelPlanesCopyType::getBaseOppositeParallelPlanes()
{return BaseOppositeParallelPlanes;}

void OppositeParallelPlanesCopyType::setBaseOppositeParallelPlanes(BaseFeatureType * BaseOppositeParallelPlanesIn)
{BaseOppositeParallelPlanes = BaseOppositeParallelPlanesIn;}

/* ***************************************************************** */

/* class OppositeParallelPlanesFeatureDefinitionType

*/

OppositeParallelPlanesFeatureDefinitionType::OppositeParallelPlanesFeatureDefinitionType() :
  SurfaceFeatureDefinitionBaseType()
{
  InternalExternal = 0;
  Width = 0;
  Length = 0;
  EndType = 0;
  Depth = 0;
  Bottom = 0;
  SingleOpenEnd = 0;
  EndRadius1 = 0;
  EndRadius2 = 0;
}

OppositeParallelPlanesFeatureDefinitionType::OppositeParallelPlanesFeatureDefinitionType(
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * WidthIn,
 LinearValueType * LengthIn,
 SlotEndType * EndTypeIn,
 LinearValueType * DepthIn,
 BottomType * BottomIn,
 XmlBoolean * SingleOpenEndIn,
 EndRadiusType * EndRadius1In,
 EndRadiusType * EndRadius2In) :
  SurfaceFeatureDefinitionBaseType(
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  Width = WidthIn;
  Length = LengthIn;
  EndType = EndTypeIn;
  Depth = DepthIn;
  Bottom = BottomIn;
  SingleOpenEnd = SingleOpenEndIn;
  EndRadius1 = EndRadius1In;
  EndRadius2 = EndRadius2In;
}

OppositeParallelPlanesFeatureDefinitionType::OppositeParallelPlanesFeatureDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * WidthIn,
 LinearValueType * LengthIn,
 SlotEndType * EndTypeIn,
 LinearValueType * DepthIn,
 BottomType * BottomIn,
 XmlBoolean * SingleOpenEndIn,
 EndRadiusType * EndRadius1In,
 EndRadiusType * EndRadius2In) :
  SurfaceFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  Width = WidthIn;
  Length = LengthIn;
  EndType = EndTypeIn;
  Depth = DepthIn;
  Bottom = BottomIn;
  SingleOpenEnd = SingleOpenEndIn;
  EndRadius1 = EndRadius1In;
  EndRadius2 = EndRadius2In;
}

OppositeParallelPlanesFeatureDefinitionType::~OppositeParallelPlanesFeatureDefinitionType()
{
  #ifndef NODESTRUCT
  delete InternalExternal;
  delete Width;
  delete Length;
  delete EndType;
  delete Depth;
  delete Bottom;
  delete SingleOpenEnd;
  delete EndRadius1;
  delete EndRadius2;
  #endif
}

void OppositeParallelPlanesFeatureDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<InternalExternal");
  InternalExternal->printSelf(outFile);
  fprintf(outFile, "</InternalExternal>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Width");
  Width->printSelf(outFile);
  fprintf(outFile, "</Width>\n");
  if (Length)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Length");
      Length->printSelf(outFile);
      fprintf(outFile, "</Length>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<EndType");
  EndType->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</EndType>\n");
  if (Depth)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Depth");
      Depth->printSelf(outFile);
      fprintf(outFile, "</Depth>\n");
    }
  if (Bottom)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Bottom");
      Bottom->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Bottom>\n");
    }
  if (SingleOpenEnd)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SingleOpenEnd");
      SingleOpenEnd->printSelf(outFile);
      fprintf(outFile, "</SingleOpenEnd>\n");
    }
  if (EndRadius1)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EndRadius1");
      EndRadius1->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EndRadius1>\n");
    }
  if (EndRadius2)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EndRadius2");
      EndRadius2->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EndRadius2>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool OppositeParallelPlanesFeatureDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OppositeParallelPlanesFeatureDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OppositeParallelPlanesFeatureDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OppositeParallelPlanesFeatureDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OppositeParallelPlanesFeatureDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

InternalExternalEnumType * OppositeParallelPlanesFeatureDefinitionType::getInternalExternal()
{return InternalExternal;}

void OppositeParallelPlanesFeatureDefinitionType::setInternalExternal(InternalExternalEnumType * InternalExternalIn)
{InternalExternal = InternalExternalIn;}

LinearValueType * OppositeParallelPlanesFeatureDefinitionType::getWidth()
{return Width;}

void OppositeParallelPlanesFeatureDefinitionType::setWidth(LinearValueType * WidthIn)
{Width = WidthIn;}

LinearValueType * OppositeParallelPlanesFeatureDefinitionType::getLength()
{return Length;}

void OppositeParallelPlanesFeatureDefinitionType::setLength(LinearValueType * LengthIn)
{Length = LengthIn;}

SlotEndType * OppositeParallelPlanesFeatureDefinitionType::getEndType()
{return EndType;}

void OppositeParallelPlanesFeatureDefinitionType::setEndType(SlotEndType * EndTypeIn)
{EndType = EndTypeIn;}

LinearValueType * OppositeParallelPlanesFeatureDefinitionType::getDepth()
{return Depth;}

void OppositeParallelPlanesFeatureDefinitionType::setDepth(LinearValueType * DepthIn)
{Depth = DepthIn;}

BottomType * OppositeParallelPlanesFeatureDefinitionType::getBottom()
{return Bottom;}

void OppositeParallelPlanesFeatureDefinitionType::setBottom(BottomType * BottomIn)
{Bottom = BottomIn;}

XmlBoolean * OppositeParallelPlanesFeatureDefinitionType::getSingleOpenEnd()
{return SingleOpenEnd;}

void OppositeParallelPlanesFeatureDefinitionType::setSingleOpenEnd(XmlBoolean * SingleOpenEndIn)
{SingleOpenEnd = SingleOpenEndIn;}

EndRadiusType * OppositeParallelPlanesFeatureDefinitionType::getEndRadius1()
{return EndRadius1;}

void OppositeParallelPlanesFeatureDefinitionType::setEndRadius1(EndRadiusType * EndRadius1In)
{EndRadius1 = EndRadius1In;}

EndRadiusType * OppositeParallelPlanesFeatureDefinitionType::getEndRadius2()
{return EndRadius2;}

void OppositeParallelPlanesFeatureDefinitionType::setEndRadius2(EndRadiusType * EndRadius2In)
{EndRadius2 = EndRadius2In;}

/* ***************************************************************** */

/* class OppositeParallelPlanesFeatureItemType

*/

OppositeParallelPlanesFeatureItemType::OppositeParallelPlanesFeatureItemType() :
  SurfaceFeatureItemBaseType()
{
  DeterminationMode = 0;
}

OppositeParallelPlanesFeatureItemType::OppositeParallelPlanesFeatureItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 OppositeParallelPlanesMeasurementDeterminationType * DeterminationModeIn) :
  SurfaceFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

OppositeParallelPlanesFeatureItemType::OppositeParallelPlanesFeatureItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 OppositeParallelPlanesMeasurementDeterminationType * DeterminationModeIn) :
  SurfaceFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

OppositeParallelPlanesFeatureItemType::~OppositeParallelPlanesFeatureItemType()
{
  #ifndef NODESTRUCT
  delete DeterminationMode;
  #endif
}

void OppositeParallelPlanesFeatureItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<DeterminationMode");
  DeterminationMode->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeterminationMode>\n");
  doSpaces(-INDENT, outFile);
}

bool OppositeParallelPlanesFeatureItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OppositeParallelPlanesFeatureItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OppositeParallelPlanesFeatureItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OppositeParallelPlanesFeatureItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OppositeParallelPlanesFeatureItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

OppositeParallelPlanesMeasurementDeterminationType * OppositeParallelPlanesFeatureItemType::getDeterminationMode()
{return DeterminationMode;}

void OppositeParallelPlanesFeatureItemType::setDeterminationMode(OppositeParallelPlanesMeasurementDeterminationType * DeterminationModeIn)
{DeterminationMode = DeterminationModeIn;}

/* ***************************************************************** */

/* class OppositeParallelPlanesFeatureMeasurementType

*/

OppositeParallelPlanesFeatureMeasurementType::OppositeParallelPlanesFeatureMeasurementType() :
  SurfaceFeatureMeasurementBaseType()
{
  CenterPlane = 0;
  LengthVector = 0;
  DepthVector = 0;
  Width = 0;
  WidthMin = 0;
  WidthMax = 0;
  Length = 0;
  LengthMin = 0;
  LengthMax = 0;
  Depth = 0;
  EndRadius1 = 0;
  EndRadius2 = 0;
  Form = 0;
}

OppositeParallelPlanesFeatureMeasurementType::OppositeParallelPlanesFeatureMeasurementType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredPlaneType * CenterPlaneIn,
 MeasuredUnitVectorType * LengthVectorIn,
 MeasuredUnitVectorType * DepthVectorIn,
 MeasuredLinearValueType * WidthIn,
 MeasuredLinearValueType * WidthMinIn,
 MeasuredLinearValueType * WidthMaxIn,
 MeasuredLinearValueType * LengthIn,
 MeasuredLinearValueType * LengthMinIn,
 MeasuredLinearValueType * LengthMaxIn,
 MeasuredLinearValueType * DepthIn,
 MeasuredEndRadiusType * EndRadius1In,
 MeasuredEndRadiusType * EndRadius2In,
 MeasuredLinearValueType * FormIn) :
  SurfaceFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  CenterPlane = CenterPlaneIn;
  LengthVector = LengthVectorIn;
  DepthVector = DepthVectorIn;
  Width = WidthIn;
  WidthMin = WidthMinIn;
  WidthMax = WidthMaxIn;
  Length = LengthIn;
  LengthMin = LengthMinIn;
  LengthMax = LengthMaxIn;
  Depth = DepthIn;
  EndRadius1 = EndRadius1In;
  EndRadius2 = EndRadius2In;
  Form = FormIn;
}

OppositeParallelPlanesFeatureMeasurementType::OppositeParallelPlanesFeatureMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredPlaneType * CenterPlaneIn,
 MeasuredUnitVectorType * LengthVectorIn,
 MeasuredUnitVectorType * DepthVectorIn,
 MeasuredLinearValueType * WidthIn,
 MeasuredLinearValueType * WidthMinIn,
 MeasuredLinearValueType * WidthMaxIn,
 MeasuredLinearValueType * LengthIn,
 MeasuredLinearValueType * LengthMinIn,
 MeasuredLinearValueType * LengthMaxIn,
 MeasuredLinearValueType * DepthIn,
 MeasuredEndRadiusType * EndRadius1In,
 MeasuredEndRadiusType * EndRadius2In,
 MeasuredLinearValueType * FormIn) :
  SurfaceFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  CenterPlane = CenterPlaneIn;
  LengthVector = LengthVectorIn;
  DepthVector = DepthVectorIn;
  Width = WidthIn;
  WidthMin = WidthMinIn;
  WidthMax = WidthMaxIn;
  Length = LengthIn;
  LengthMin = LengthMinIn;
  LengthMax = LengthMaxIn;
  Depth = DepthIn;
  EndRadius1 = EndRadius1In;
  EndRadius2 = EndRadius2In;
  Form = FormIn;
}

OppositeParallelPlanesFeatureMeasurementType::~OppositeParallelPlanesFeatureMeasurementType()
{
  #ifndef NODESTRUCT
  delete CenterPlane;
  delete LengthVector;
  delete DepthVector;
  delete Width;
  delete WidthMin;
  delete WidthMax;
  delete Length;
  delete LengthMin;
  delete LengthMax;
  delete Depth;
  delete EndRadius1;
  delete EndRadius2;
  delete Form;
  #endif
}

void OppositeParallelPlanesFeatureMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  if (CenterPlane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CenterPlane");
      CenterPlane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CenterPlane>\n");
    }
  if (LengthVector)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LengthVector");
      LengthVector->printSelf(outFile);
      fprintf(outFile, "</LengthVector>\n");
    }
  if (DepthVector)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DepthVector");
      DepthVector->printSelf(outFile);
      fprintf(outFile, "</DepthVector>\n");
    }
  if (Width)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Width");
      Width->printSelf(outFile);
      fprintf(outFile, "</Width>\n");
    }
  if (WidthMin)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WidthMin");
      WidthMin->printSelf(outFile);
      fprintf(outFile, "</WidthMin>\n");
    }
  if (WidthMax)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WidthMax");
      WidthMax->printSelf(outFile);
      fprintf(outFile, "</WidthMax>\n");
    }
  if (Length)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Length");
      Length->printSelf(outFile);
      fprintf(outFile, "</Length>\n");
    }
  if (LengthMin)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LengthMin");
      LengthMin->printSelf(outFile);
      fprintf(outFile, "</LengthMin>\n");
    }
  if (LengthMax)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LengthMax");
      LengthMax->printSelf(outFile);
      fprintf(outFile, "</LengthMax>\n");
    }
  if (Depth)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Depth");
      Depth->printSelf(outFile);
      fprintf(outFile, "</Depth>\n");
    }
  if (EndRadius1)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EndRadius1");
      EndRadius1->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EndRadius1>\n");
    }
  if (EndRadius2)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EndRadius2");
      EndRadius2->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EndRadius2>\n");
    }
  if (Form)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Form");
      Form->printSelf(outFile);
      fprintf(outFile, "</Form>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool OppositeParallelPlanesFeatureMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OppositeParallelPlanesFeatureMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OppositeParallelPlanesFeatureMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OppositeParallelPlanesFeatureMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OppositeParallelPlanesFeatureMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredPlaneType * OppositeParallelPlanesFeatureMeasurementType::getCenterPlane()
{return CenterPlane;}

void OppositeParallelPlanesFeatureMeasurementType::setCenterPlane(MeasuredPlaneType * CenterPlaneIn)
{CenterPlane = CenterPlaneIn;}

MeasuredUnitVectorType * OppositeParallelPlanesFeatureMeasurementType::getLengthVector()
{return LengthVector;}

void OppositeParallelPlanesFeatureMeasurementType::setLengthVector(MeasuredUnitVectorType * LengthVectorIn)
{LengthVector = LengthVectorIn;}

MeasuredUnitVectorType * OppositeParallelPlanesFeatureMeasurementType::getDepthVector()
{return DepthVector;}

void OppositeParallelPlanesFeatureMeasurementType::setDepthVector(MeasuredUnitVectorType * DepthVectorIn)
{DepthVector = DepthVectorIn;}

MeasuredLinearValueType * OppositeParallelPlanesFeatureMeasurementType::getWidth()
{return Width;}

void OppositeParallelPlanesFeatureMeasurementType::setWidth(MeasuredLinearValueType * WidthIn)
{Width = WidthIn;}

MeasuredLinearValueType * OppositeParallelPlanesFeatureMeasurementType::getWidthMin()
{return WidthMin;}

void OppositeParallelPlanesFeatureMeasurementType::setWidthMin(MeasuredLinearValueType * WidthMinIn)
{WidthMin = WidthMinIn;}

MeasuredLinearValueType * OppositeParallelPlanesFeatureMeasurementType::getWidthMax()
{return WidthMax;}

void OppositeParallelPlanesFeatureMeasurementType::setWidthMax(MeasuredLinearValueType * WidthMaxIn)
{WidthMax = WidthMaxIn;}

MeasuredLinearValueType * OppositeParallelPlanesFeatureMeasurementType::getLength()
{return Length;}

void OppositeParallelPlanesFeatureMeasurementType::setLength(MeasuredLinearValueType * LengthIn)
{Length = LengthIn;}

MeasuredLinearValueType * OppositeParallelPlanesFeatureMeasurementType::getLengthMin()
{return LengthMin;}

void OppositeParallelPlanesFeatureMeasurementType::setLengthMin(MeasuredLinearValueType * LengthMinIn)
{LengthMin = LengthMinIn;}

MeasuredLinearValueType * OppositeParallelPlanesFeatureMeasurementType::getLengthMax()
{return LengthMax;}

void OppositeParallelPlanesFeatureMeasurementType::setLengthMax(MeasuredLinearValueType * LengthMaxIn)
{LengthMax = LengthMaxIn;}

MeasuredLinearValueType * OppositeParallelPlanesFeatureMeasurementType::getDepth()
{return Depth;}

void OppositeParallelPlanesFeatureMeasurementType::setDepth(MeasuredLinearValueType * DepthIn)
{Depth = DepthIn;}

MeasuredEndRadiusType * OppositeParallelPlanesFeatureMeasurementType::getEndRadius1()
{return EndRadius1;}

void OppositeParallelPlanesFeatureMeasurementType::setEndRadius1(MeasuredEndRadiusType * EndRadius1In)
{EndRadius1 = EndRadius1In;}

MeasuredEndRadiusType * OppositeParallelPlanesFeatureMeasurementType::getEndRadius2()
{return EndRadius2;}

void OppositeParallelPlanesFeatureMeasurementType::setEndRadius2(MeasuredEndRadiusType * EndRadius2In)
{EndRadius2 = EndRadius2In;}

MeasuredLinearValueType * OppositeParallelPlanesFeatureMeasurementType::getForm()
{return Form;}

void OppositeParallelPlanesFeatureMeasurementType::setForm(MeasuredLinearValueType * FormIn)
{Form = FormIn;}

/* ***************************************************************** */

/* class OppositeParallelPlanesFeatureNominalType

*/

OppositeParallelPlanesFeatureNominalType::OppositeParallelPlanesFeatureNominalType() :
  SurfaceFeatureNominalBaseType()
{
  CenterPlane = 0;
  LengthVector = 0;
  DepthVector = 0;
  Constructed = 0;
}

OppositeParallelPlanesFeatureNominalType::OppositeParallelPlanesFeatureNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 PlaneType * CenterPlaneIn,
 UnitVectorType * LengthVectorIn,
 UnitVectorType * DepthVectorIn,
 OppositeParallelPlanesConstructionMethodType * ConstructedIn) :
  SurfaceFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  CenterPlane = CenterPlaneIn;
  LengthVector = LengthVectorIn;
  DepthVector = DepthVectorIn;
  Constructed = ConstructedIn;
}

OppositeParallelPlanesFeatureNominalType::OppositeParallelPlanesFeatureNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 PlaneType * CenterPlaneIn,
 UnitVectorType * LengthVectorIn,
 UnitVectorType * DepthVectorIn,
 OppositeParallelPlanesConstructionMethodType * ConstructedIn) :
  SurfaceFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  CenterPlane = CenterPlaneIn;
  LengthVector = LengthVectorIn;
  DepthVector = DepthVectorIn;
  Constructed = ConstructedIn;
}

OppositeParallelPlanesFeatureNominalType::~OppositeParallelPlanesFeatureNominalType()
{
  #ifndef NODESTRUCT
  delete CenterPlane;
  delete LengthVector;
  delete DepthVector;
  delete Constructed;
  #endif
}

void OppositeParallelPlanesFeatureNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CenterPlane");
  CenterPlane->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</CenterPlane>\n");
  if (LengthVector)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LengthVector");
      LengthVector->printSelf(outFile);
      fprintf(outFile, "</LengthVector>\n");
    }
  if (DepthVector)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DepthVector");
      DepthVector->printSelf(outFile);
      fprintf(outFile, "</DepthVector>\n");
    }
  if (Constructed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool OppositeParallelPlanesFeatureNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OppositeParallelPlanesFeatureNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OppositeParallelPlanesFeatureNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OppositeParallelPlanesFeatureNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OppositeParallelPlanesFeatureNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

PlaneType * OppositeParallelPlanesFeatureNominalType::getCenterPlane()
{return CenterPlane;}

void OppositeParallelPlanesFeatureNominalType::setCenterPlane(PlaneType * CenterPlaneIn)
{CenterPlane = CenterPlaneIn;}

UnitVectorType * OppositeParallelPlanesFeatureNominalType::getLengthVector()
{return LengthVector;}

void OppositeParallelPlanesFeatureNominalType::setLengthVector(UnitVectorType * LengthVectorIn)
{LengthVector = LengthVectorIn;}

UnitVectorType * OppositeParallelPlanesFeatureNominalType::getDepthVector()
{return DepthVector;}

void OppositeParallelPlanesFeatureNominalType::setDepthVector(UnitVectorType * DepthVectorIn)
{DepthVector = DepthVectorIn;}

OppositeParallelPlanesConstructionMethodType * OppositeParallelPlanesFeatureNominalType::getConstructed()
{return Constructed;}

void OppositeParallelPlanesFeatureNominalType::setConstructed(OppositeParallelPlanesConstructionMethodType * ConstructedIn)
{Constructed = ConstructedIn;}

/* ***************************************************************** */

/* class OppositeParallelPlanesFromScanType

*/

OppositeParallelPlanesFromScanType::OppositeParallelPlanesFromScanType() :
  ConstructionMethodBaseType()
{
  SurfaceFeature = 0;
  SearchRadius = 0;
}

OppositeParallelPlanesFromScanType::OppositeParallelPlanesFromScanType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * SurfaceFeatureIn,
 LinearValueType * SearchRadiusIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  SurfaceFeature = SurfaceFeatureIn;
  SearchRadius = SearchRadiusIn;
}

OppositeParallelPlanesFromScanType::~OppositeParallelPlanesFromScanType()
{
  #ifndef NODESTRUCT
  delete SurfaceFeature;
  delete SearchRadius;
  #endif
}

void OppositeParallelPlanesFromScanType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<SurfaceFeature");
  SurfaceFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</SurfaceFeature>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<SearchRadius");
  SearchRadius->printSelf(outFile);
  fprintf(outFile, "</SearchRadius>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * OppositeParallelPlanesFromScanType::getSurfaceFeature()
{return SurfaceFeature;}

void OppositeParallelPlanesFromScanType::setSurfaceFeature(BaseFeatureType * SurfaceFeatureIn)
{SurfaceFeature = SurfaceFeatureIn;}

LinearValueType * OppositeParallelPlanesFromScanType::getSearchRadius()
{return SearchRadius;}

void OppositeParallelPlanesFromScanType::setSearchRadius(LinearValueType * SearchRadiusIn)
{SearchRadius = SearchRadiusIn;}

/* ***************************************************************** */

/* class OppositeParallelPlanesMeasurementDeterminationType

*/

OppositeParallelPlanesMeasurementDeterminationType::OppositeParallelPlanesMeasurementDeterminationType()
{
  OppositeParallelPlanesMeasurementDeterminationTypePair = 0;
}

OppositeParallelPlanesMeasurementDeterminationType::OppositeParallelPlanesMeasurementDeterminationType(
 OppositeParallelPlanesMeasurementDeterminationTypeChoicePair * OppositeParallelPlanesMeasurementDeterminationTypePairIn)
{
  OppositeParallelPlanesMeasurementDeterminationTypePair = OppositeParallelPlanesMeasurementDeterminationTypePairIn;
}

OppositeParallelPlanesMeasurementDeterminationType::~OppositeParallelPlanesMeasurementDeterminationType()
{
  #ifndef NODESTRUCT
  delete OppositeParallelPlanesMeasurementDeterminationTypePair;
  #endif
}

void OppositeParallelPlanesMeasurementDeterminationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  OppositeParallelPlanesMeasurementDeterminationTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

OppositeParallelPlanesMeasurementDeterminationTypeChoicePair * OppositeParallelPlanesMeasurementDeterminationType::getOppositeParallelPlanesMeasurementDeterminationTypePair()
{return OppositeParallelPlanesMeasurementDeterminationTypePair;}

void OppositeParallelPlanesMeasurementDeterminationType::setOppositeParallelPlanesMeasurementDeterminationTypePair(OppositeParallelPlanesMeasurementDeterminationTypeChoicePair * OppositeParallelPlanesMeasurementDeterminationTypePairIn)
{OppositeParallelPlanesMeasurementDeterminationTypePair = OppositeParallelPlanesMeasurementDeterminationTypePairIn;}
OppositeParallelPlanesMeasurementDeterminationTypeChoicePair::OppositeParallelPlanesMeasurementDeterminationTypeChoicePair() {}

OppositeParallelPlanesMeasurementDeterminationTypeChoicePair::OppositeParallelPlanesMeasurementDeterminationTypeChoicePair(
 whichOne OppositeParallelPlanesMeasurementDeterminationTypeTypeIn,
 OppositeParallelPlanesMeasurementDeterminationTypeVal * OppositeParallelPlanesMeasurementDeterminationTypeValueIn)
{
  OppositeParallelPlanesMeasurementDeterminationTypeType = OppositeParallelPlanesMeasurementDeterminationTypeTypeIn;
  OppositeParallelPlanesMeasurementDeterminationTypeValue = OppositeParallelPlanesMeasurementDeterminationTypeValueIn;
}

OppositeParallelPlanesMeasurementDeterminationTypeChoicePair::~OppositeParallelPlanesMeasurementDeterminationTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (OppositeParallelPlanesMeasurementDeterminationTypeType == CheckedE)
    delete OppositeParallelPlanesMeasurementDeterminationTypeValue->Checked;
  else if (OppositeParallelPlanesMeasurementDeterminationTypeType == SetE)
    delete OppositeParallelPlanesMeasurementDeterminationTypeValue->Set;
  delete OppositeParallelPlanesMeasurementDeterminationTypeValue;
  #endif
}

void OppositeParallelPlanesMeasurementDeterminationTypeChoicePair::printSelf(FILE * outFile)
{
  if (OppositeParallelPlanesMeasurementDeterminationTypeType == CheckedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Checked");
      OppositeParallelPlanesMeasurementDeterminationTypeValue->Checked->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Checked>\n");
    }
  else if (OppositeParallelPlanesMeasurementDeterminationTypeType == SetE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Set");
      OppositeParallelPlanesMeasurementDeterminationTypeValue->Set->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class OppositeParallelPlanesRecompType

*/

OppositeParallelPlanesRecompType::OppositeParallelPlanesRecompType() :
  ConstructionMethodBaseType()
{
  BaseFeaturePointList = 0;
}

OppositeParallelPlanesRecompType::OppositeParallelPlanesRecompType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeaturePointListType * BaseFeaturePointListIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeaturePointList = BaseFeaturePointListIn;
}

OppositeParallelPlanesRecompType::~OppositeParallelPlanesRecompType()
{
  #ifndef NODESTRUCT
  delete BaseFeaturePointList;
  #endif
}

void OppositeParallelPlanesRecompType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeaturePointList");
  BaseFeaturePointList->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeaturePointList>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeaturePointListType * OppositeParallelPlanesRecompType::getBaseFeaturePointList()
{return BaseFeaturePointList;}

void OppositeParallelPlanesRecompType::setBaseFeaturePointList(BaseFeaturePointListType * BaseFeaturePointListIn)
{BaseFeaturePointList = BaseFeaturePointListIn;}

/* ***************************************************************** */

/* class OppositeParallelPlanesTransformType

*/

OppositeParallelPlanesTransformType::OppositeParallelPlanesTransformType() :
  ConstructionMethodBaseType()
{
  BaseOppositeParallelPlanes = 0;
  Transformation = 0;
}

OppositeParallelPlanesTransformType::OppositeParallelPlanesTransformType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseOppositeParallelPlanesIn,
 TransformationReferenceType * TransformationIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseOppositeParallelPlanes = BaseOppositeParallelPlanesIn;
  Transformation = TransformationIn;
}

OppositeParallelPlanesTransformType::~OppositeParallelPlanesTransformType()
{
  #ifndef NODESTRUCT
  delete BaseOppositeParallelPlanes;
  delete Transformation;
  #endif
}

void OppositeParallelPlanesTransformType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseOppositeParallelPlanes");
  BaseOppositeParallelPlanes->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseOppositeParallelPlanes>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Transformation");
  Transformation->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Transformation>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * OppositeParallelPlanesTransformType::getBaseOppositeParallelPlanes()
{return BaseOppositeParallelPlanes;}

void OppositeParallelPlanesTransformType::setBaseOppositeParallelPlanes(BaseFeatureType * BaseOppositeParallelPlanesIn)
{BaseOppositeParallelPlanes = BaseOppositeParallelPlanesIn;}

TransformationReferenceType * OppositeParallelPlanesTransformType::getTransformation()
{return Transformation;}

void OppositeParallelPlanesTransformType::setTransformation(TransformationReferenceType * TransformationIn)
{Transformation = TransformationIn;}

/* ***************************************************************** */

/* class OtherCurveCheckedFeatureType

*/

OtherCurveCheckedFeatureType::OtherCurveCheckedFeatureType()
{
  CheckDetails = 0;
}

OtherCurveCheckedFeatureType::OtherCurveCheckedFeatureType(
 OtherCurveCheckedType * CheckDetailsIn)
{
  CheckDetails = CheckDetailsIn;
}

OtherCurveCheckedFeatureType::~OtherCurveCheckedFeatureType()
{
  #ifndef NODESTRUCT
  delete CheckDetails;
  #endif
}

void OtherCurveCheckedFeatureType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (CheckDetails)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CheckDetails");
      CheckDetails->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CheckDetails>\n");
    }
  doSpaces(-INDENT, outFile);
}

OtherCurveCheckedType * OtherCurveCheckedFeatureType::getCheckDetails()
{return CheckDetails;}

void OtherCurveCheckedFeatureType::setCheckDetails(OtherCurveCheckedType * CheckDetailsIn)
{CheckDetails = CheckDetailsIn;}

/* ***************************************************************** */

/* class OtherCurveCheckedType

*/

OtherCurveCheckedType::OtherCurveCheckedType()
{
  OtherCurveCheckedTypePair = 0;
}

OtherCurveCheckedType::OtherCurveCheckedType(
 OtherCurveCheckedTypeChoicePair * OtherCurveCheckedTypePairIn)
{
  OtherCurveCheckedTypePair = OtherCurveCheckedTypePairIn;
}

OtherCurveCheckedType::~OtherCurveCheckedType()
{
  #ifndef NODESTRUCT
  delete OtherCurveCheckedTypePair;
  #endif
}

void OtherCurveCheckedType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  OtherCurveCheckedTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

OtherCurveCheckedTypeChoicePair * OtherCurveCheckedType::getOtherCurveCheckedTypePair()
{return OtherCurveCheckedTypePair;}

void OtherCurveCheckedType::setOtherCurveCheckedTypePair(OtherCurveCheckedTypeChoicePair * OtherCurveCheckedTypePairIn)
{OtherCurveCheckedTypePair = OtherCurveCheckedTypePairIn;}
OtherCurveCheckedTypeChoicePair::OtherCurveCheckedTypeChoicePair() {}

OtherCurveCheckedTypeChoicePair::OtherCurveCheckedTypeChoicePair(
 whichOne OtherCurveCheckedTypeTypeIn,
 OtherCurveCheckedTypeVal * OtherCurveCheckedTypeValueIn)
{
  OtherCurveCheckedTypeType = OtherCurveCheckedTypeTypeIn;
  OtherCurveCheckedTypeValue = OtherCurveCheckedTypeValueIn;
}

OtherCurveCheckedTypeChoicePair::~OtherCurveCheckedTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (OtherCurveCheckedTypeType == MeasuredE)
    delete OtherCurveCheckedTypeValue->Measured;
  else if (OtherCurveCheckedTypeType == ConstructedE)
    delete OtherCurveCheckedTypeValue->Constructed;
  delete OtherCurveCheckedTypeValue;
  #endif
}

void OtherCurveCheckedTypeChoicePair::printSelf(FILE * outFile)
{
  if (OtherCurveCheckedTypeType == MeasuredE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Measured");
      OtherCurveCheckedTypeValue->Measured->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Measured>\n");
    }
  else if (OtherCurveCheckedTypeType == ConstructedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      OtherCurveCheckedTypeValue->Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
}

/* ***************************************************************** */

/* class OtherCurveConstructionMethodType

*/

OtherCurveConstructionMethodType::OtherCurveConstructionMethodType()
{
  OtherCurveConstructionMethodTypePair = 0;
}

OtherCurveConstructionMethodType::OtherCurveConstructionMethodType(
 OtherCurveConstructionMethodTypeChoicePair * OtherCurveConstructionMethodTypePairIn)
{
  OtherCurveConstructionMethodTypePair = OtherCurveConstructionMethodTypePairIn;
}

OtherCurveConstructionMethodType::~OtherCurveConstructionMethodType()
{
  #ifndef NODESTRUCT
  delete OtherCurveConstructionMethodTypePair;
  #endif
}

void OtherCurveConstructionMethodType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (OtherCurveConstructionMethodTypePair)
    {
      OtherCurveConstructionMethodTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

OtherCurveConstructionMethodTypeChoicePair * OtherCurveConstructionMethodType::getOtherCurveConstructionMethodTypePair()
{return OtherCurveConstructionMethodTypePair;}

void OtherCurveConstructionMethodType::setOtherCurveConstructionMethodTypePair(OtherCurveConstructionMethodTypeChoicePair * OtherCurveConstructionMethodTypePairIn)
{OtherCurveConstructionMethodTypePair = OtherCurveConstructionMethodTypePairIn;}
OtherCurveConstructionMethodTypeChoicePair::OtherCurveConstructionMethodTypeChoicePair() {}

OtherCurveConstructionMethodTypeChoicePair::OtherCurveConstructionMethodTypeChoicePair(
 whichOne OtherCurveConstructionMethodTypeTypeIn,
 OtherCurveConstructionMethodTypeVal * OtherCurveConstructionMethodTypeValueIn)
{
  OtherCurveConstructionMethodTypeType = OtherCurveConstructionMethodTypeTypeIn;
  OtherCurveConstructionMethodTypeValue = OtherCurveConstructionMethodTypeValueIn;
}

OtherCurveConstructionMethodTypeChoicePair::~OtherCurveConstructionMethodTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (OtherCurveConstructionMethodTypeType == CopyE)
    delete OtherCurveConstructionMethodTypeValue->Copy;
  delete OtherCurveConstructionMethodTypeValue;
  #endif
}

void OtherCurveConstructionMethodTypeChoicePair::printSelf(FILE * outFile)
{
  if (OtherCurveConstructionMethodTypeType == CopyE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Copy");
      OtherCurveConstructionMethodTypeValue->Copy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Copy>\n");
    }
}

/* ***************************************************************** */

/* class OtherCurveFeatureCopyType

*/

OtherCurveFeatureCopyType::OtherCurveFeatureCopyType() :
  ConstructionMethodBaseType()
{
  BaseOtherCurveFeature = 0;
}

OtherCurveFeatureCopyType::OtherCurveFeatureCopyType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseOtherCurveFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseOtherCurveFeature = BaseOtherCurveFeatureIn;
}

OtherCurveFeatureCopyType::~OtherCurveFeatureCopyType()
{
  #ifndef NODESTRUCT
  delete BaseOtherCurveFeature;
  #endif
}

void OtherCurveFeatureCopyType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseOtherCurveFeature");
  BaseOtherCurveFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseOtherCurveFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * OtherCurveFeatureCopyType::getBaseOtherCurveFeature()
{return BaseOtherCurveFeature;}

void OtherCurveFeatureCopyType::setBaseOtherCurveFeature(BaseFeatureType * BaseOtherCurveFeatureIn)
{BaseOtherCurveFeature = BaseOtherCurveFeatureIn;}

/* ***************************************************************** */

/* class OtherCurveFeatureDefinitionType

*/

OtherCurveFeatureDefinitionType::OtherCurveFeatureDefinitionType() :
  CurveFeatureDefinitionBaseType()
{
}

OtherCurveFeatureDefinitionType::OtherCurveFeatureDefinitionType(
 AttributesType * AttributesIn) :
  CurveFeatureDefinitionBaseType(
    AttributesIn)
{
}

OtherCurveFeatureDefinitionType::OtherCurveFeatureDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn) :
  CurveFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
}

OtherCurveFeatureDefinitionType::~OtherCurveFeatureDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void OtherCurveFeatureDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool OtherCurveFeatureDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OtherCurveFeatureDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OtherCurveFeatureDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OtherCurveFeatureDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OtherCurveFeatureDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class OtherCurveFeatureItemType

*/

OtherCurveFeatureItemType::OtherCurveFeatureItemType() :
  CurveFeatureItemBaseType()
{
  DeterminationMode = 0;
}

OtherCurveFeatureItemType::OtherCurveFeatureItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 OtherCurveMeasurementDeterminationType * DeterminationModeIn) :
  CurveFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

OtherCurveFeatureItemType::OtherCurveFeatureItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 OtherCurveMeasurementDeterminationType * DeterminationModeIn) :
  CurveFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

OtherCurveFeatureItemType::~OtherCurveFeatureItemType()
{
  #ifndef NODESTRUCT
  delete DeterminationMode;
  #endif
}

void OtherCurveFeatureItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<DeterminationMode");
  DeterminationMode->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeterminationMode>\n");
  doSpaces(-INDENT, outFile);
}

bool OtherCurveFeatureItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OtherCurveFeatureItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OtherCurveFeatureItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OtherCurveFeatureItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OtherCurveFeatureItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

OtherCurveMeasurementDeterminationType * OtherCurveFeatureItemType::getDeterminationMode()
{return DeterminationMode;}

void OtherCurveFeatureItemType::setDeterminationMode(OtherCurveMeasurementDeterminationType * DeterminationModeIn)
{DeterminationMode = DeterminationModeIn;}

/* ***************************************************************** */

/* class OtherCurveFeatureMeasurementType

*/

OtherCurveFeatureMeasurementType::OtherCurveFeatureMeasurementType() :
  CurveFeatureMeasurementBaseType()
{
}

OtherCurveFeatureMeasurementType::OtherCurveFeatureMeasurementType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn) :
  CurveFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
}

OtherCurveFeatureMeasurementType::OtherCurveFeatureMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn) :
  CurveFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
}

OtherCurveFeatureMeasurementType::~OtherCurveFeatureMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void OtherCurveFeatureMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool OtherCurveFeatureMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OtherCurveFeatureMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OtherCurveFeatureMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OtherCurveFeatureMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OtherCurveFeatureMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class OtherCurveFeatureNominalType

*/

OtherCurveFeatureNominalType::OtherCurveFeatureNominalType() :
  CurveFeatureNominalBaseType()
{
  Constructed = 0;
}

OtherCurveFeatureNominalType::OtherCurveFeatureNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 OtherCurveConstructionMethodType * ConstructedIn) :
  CurveFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    SurfaceFeatureNominalIdIn)
{
  Constructed = ConstructedIn;
}

OtherCurveFeatureNominalType::OtherCurveFeatureNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 OtherCurveConstructionMethodType * ConstructedIn) :
  CurveFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    SurfaceFeatureNominalIdIn)
{
  Constructed = ConstructedIn;
}

OtherCurveFeatureNominalType::~OtherCurveFeatureNominalType()
{
  #ifndef NODESTRUCT
  delete Constructed;
  #endif
}

void OtherCurveFeatureNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (SurfaceFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SurfaceFeatureNominalId");
      SurfaceFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</SurfaceFeatureNominalId>\n");
    }
  if (Constructed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool OtherCurveFeatureNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OtherCurveFeatureNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OtherCurveFeatureNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OtherCurveFeatureNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OtherCurveFeatureNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

OtherCurveConstructionMethodType * OtherCurveFeatureNominalType::getConstructed()
{return Constructed;}

void OtherCurveFeatureNominalType::setConstructed(OtherCurveConstructionMethodType * ConstructedIn)
{Constructed = ConstructedIn;}

/* ***************************************************************** */

/* class OtherCurveMeasurementDeterminationType

*/

OtherCurveMeasurementDeterminationType::OtherCurveMeasurementDeterminationType()
{
  OtherCurveMeasurementDeterminationTypePair = 0;
}

OtherCurveMeasurementDeterminationType::OtherCurveMeasurementDeterminationType(
 OtherCurveMeasurementDeterminationTypeChoicePair * OtherCurveMeasurementDeterminationTypePairIn)
{
  OtherCurveMeasurementDeterminationTypePair = OtherCurveMeasurementDeterminationTypePairIn;
}

OtherCurveMeasurementDeterminationType::~OtherCurveMeasurementDeterminationType()
{
  #ifndef NODESTRUCT
  delete OtherCurveMeasurementDeterminationTypePair;
  #endif
}

void OtherCurveMeasurementDeterminationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  OtherCurveMeasurementDeterminationTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

OtherCurveMeasurementDeterminationTypeChoicePair * OtherCurveMeasurementDeterminationType::getOtherCurveMeasurementDeterminationTypePair()
{return OtherCurveMeasurementDeterminationTypePair;}

void OtherCurveMeasurementDeterminationType::setOtherCurveMeasurementDeterminationTypePair(OtherCurveMeasurementDeterminationTypeChoicePair * OtherCurveMeasurementDeterminationTypePairIn)
{OtherCurveMeasurementDeterminationTypePair = OtherCurveMeasurementDeterminationTypePairIn;}
OtherCurveMeasurementDeterminationTypeChoicePair::OtherCurveMeasurementDeterminationTypeChoicePair() {}

OtherCurveMeasurementDeterminationTypeChoicePair::OtherCurveMeasurementDeterminationTypeChoicePair(
 whichOne OtherCurveMeasurementDeterminationTypeTypeIn,
 OtherCurveMeasurementDeterminationTypeVal * OtherCurveMeasurementDeterminationTypeValueIn)
{
  OtherCurveMeasurementDeterminationTypeType = OtherCurveMeasurementDeterminationTypeTypeIn;
  OtherCurveMeasurementDeterminationTypeValue = OtherCurveMeasurementDeterminationTypeValueIn;
}

OtherCurveMeasurementDeterminationTypeChoicePair::~OtherCurveMeasurementDeterminationTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (OtherCurveMeasurementDeterminationTypeType == CheckedE)
    delete OtherCurveMeasurementDeterminationTypeValue->Checked;
  else if (OtherCurveMeasurementDeterminationTypeType == SetE)
    delete OtherCurveMeasurementDeterminationTypeValue->Set;
  delete OtherCurveMeasurementDeterminationTypeValue;
  #endif
}

void OtherCurveMeasurementDeterminationTypeChoicePair::printSelf(FILE * outFile)
{
  if (OtherCurveMeasurementDeterminationTypeType == CheckedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Checked");
      OtherCurveMeasurementDeterminationTypeValue->Checked->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Checked>\n");
    }
  else if (OtherCurveMeasurementDeterminationTypeType == SetE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Set");
      OtherCurveMeasurementDeterminationTypeValue->Set->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class OtherNonShapeFeatureDefinitionType

*/

OtherNonShapeFeatureDefinitionType::OtherNonShapeFeatureDefinitionType() :
  NonShapeFeatureDefinitionBaseType()
{
  Description = 0;
}

OtherNonShapeFeatureDefinitionType::OtherNonShapeFeatureDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn) :
  NonShapeFeatureDefinitionBaseType(
    AttributesIn)
{
  Description = DescriptionIn;
}

OtherNonShapeFeatureDefinitionType::OtherNonShapeFeatureDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn) :
  NonShapeFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
  Description = DescriptionIn;
}

OtherNonShapeFeatureDefinitionType::~OtherNonShapeFeatureDefinitionType()
{
  #ifndef NODESTRUCT
  delete Description;
  #endif
}

void OtherNonShapeFeatureDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Description");
  Description->printSelf(outFile);
  fprintf(outFile, "</Description>\n");
  doSpaces(-INDENT, outFile);
}

bool OtherNonShapeFeatureDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OtherNonShapeFeatureDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OtherNonShapeFeatureDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OtherNonShapeFeatureDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OtherNonShapeFeatureDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

XmlString * OtherNonShapeFeatureDefinitionType::getDescription()
{return Description;}

void OtherNonShapeFeatureDefinitionType::setDescription(XmlString * DescriptionIn)
{Description = DescriptionIn;}

/* ***************************************************************** */

/* class OtherNonShapeFeatureItemType

*/

OtherNonShapeFeatureItemType::OtherNonShapeFeatureItemType() :
  NonShapeFeatureItemBaseType()
{
}

OtherNonShapeFeatureItemType::OtherNonShapeFeatureItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn) :
  NonShapeFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn)
{
}

OtherNonShapeFeatureItemType::OtherNonShapeFeatureItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn) :
  NonShapeFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn)
{
}

OtherNonShapeFeatureItemType::~OtherNonShapeFeatureItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void OtherNonShapeFeatureItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool OtherNonShapeFeatureItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OtherNonShapeFeatureItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OtherNonShapeFeatureItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OtherNonShapeFeatureItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OtherNonShapeFeatureItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class OtherNonShapeFeatureMeasurementType

*/

OtherNonShapeFeatureMeasurementType::OtherNonShapeFeatureMeasurementType() :
  NonShapeFeatureMeasurementBaseType()
{
}

OtherNonShapeFeatureMeasurementType::OtherNonShapeFeatureMeasurementType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn) :
  NonShapeFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn)
{
}

OtherNonShapeFeatureMeasurementType::OtherNonShapeFeatureMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn) :
  NonShapeFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn)
{
}

OtherNonShapeFeatureMeasurementType::~OtherNonShapeFeatureMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void OtherNonShapeFeatureMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool OtherNonShapeFeatureMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OtherNonShapeFeatureMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OtherNonShapeFeatureMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OtherNonShapeFeatureMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OtherNonShapeFeatureMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class OtherNonShapeFeatureNominalType

*/

OtherNonShapeFeatureNominalType::OtherNonShapeFeatureNominalType() :
  NonShapeFeatureNominalBaseType()
{
  ReferenceFeatureNominalIds = 0;
}

OtherNonShapeFeatureNominalType::OtherNonShapeFeatureNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 ArrayReferenceFullType * ReferenceFeatureNominalIdsIn) :
  NonShapeFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn)
{
  ReferenceFeatureNominalIds = ReferenceFeatureNominalIdsIn;
}

OtherNonShapeFeatureNominalType::OtherNonShapeFeatureNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 ArrayReferenceFullType * ReferenceFeatureNominalIdsIn) :
  NonShapeFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn)
{
  ReferenceFeatureNominalIds = ReferenceFeatureNominalIdsIn;
}

OtherNonShapeFeatureNominalType::~OtherNonShapeFeatureNominalType()
{
  #ifndef NODESTRUCT
  delete ReferenceFeatureNominalIds;
  #endif
}

void OtherNonShapeFeatureNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (ReferenceFeatureNominalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ReferenceFeatureNominalIds");
      ReferenceFeatureNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ReferenceFeatureNominalIds>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool OtherNonShapeFeatureNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OtherNonShapeFeatureNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OtherNonShapeFeatureNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OtherNonShapeFeatureNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OtherNonShapeFeatureNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

ArrayReferenceFullType * OtherNonShapeFeatureNominalType::getReferenceFeatureNominalIds()
{return ReferenceFeatureNominalIds;}

void OtherNonShapeFeatureNominalType::setReferenceFeatureNominalIds(ArrayReferenceFullType * ReferenceFeatureNominalIdsIn)
{ReferenceFeatureNominalIds = ReferenceFeatureNominalIdsIn;}

/* ***************************************************************** */

/* class OtherShapeCheckedFeatureType

*/

OtherShapeCheckedFeatureType::OtherShapeCheckedFeatureType()
{
  CheckDetails = 0;
}

OtherShapeCheckedFeatureType::OtherShapeCheckedFeatureType(
 OtherShapeCheckedType * CheckDetailsIn)
{
  CheckDetails = CheckDetailsIn;
}

OtherShapeCheckedFeatureType::~OtherShapeCheckedFeatureType()
{
  #ifndef NODESTRUCT
  delete CheckDetails;
  #endif
}

void OtherShapeCheckedFeatureType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (CheckDetails)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CheckDetails");
      CheckDetails->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CheckDetails>\n");
    }
  doSpaces(-INDENT, outFile);
}

OtherShapeCheckedType * OtherShapeCheckedFeatureType::getCheckDetails()
{return CheckDetails;}

void OtherShapeCheckedFeatureType::setCheckDetails(OtherShapeCheckedType * CheckDetailsIn)
{CheckDetails = CheckDetailsIn;}

/* ***************************************************************** */

/* class OtherShapeCheckedType

*/

OtherShapeCheckedType::OtherShapeCheckedType()
{
  OtherShapeCheckedTypePair = 0;
}

OtherShapeCheckedType::OtherShapeCheckedType(
 OtherShapeCheckedTypeChoicePair * OtherShapeCheckedTypePairIn)
{
  OtherShapeCheckedTypePair = OtherShapeCheckedTypePairIn;
}

OtherShapeCheckedType::~OtherShapeCheckedType()
{
  #ifndef NODESTRUCT
  delete OtherShapeCheckedTypePair;
  #endif
}

void OtherShapeCheckedType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  OtherShapeCheckedTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

OtherShapeCheckedTypeChoicePair * OtherShapeCheckedType::getOtherShapeCheckedTypePair()
{return OtherShapeCheckedTypePair;}

void OtherShapeCheckedType::setOtherShapeCheckedTypePair(OtherShapeCheckedTypeChoicePair * OtherShapeCheckedTypePairIn)
{OtherShapeCheckedTypePair = OtherShapeCheckedTypePairIn;}
OtherShapeCheckedTypeChoicePair::OtherShapeCheckedTypeChoicePair() {}

OtherShapeCheckedTypeChoicePair::OtherShapeCheckedTypeChoicePair(
 whichOne OtherShapeCheckedTypeTypeIn,
 OtherShapeCheckedTypeVal * OtherShapeCheckedTypeValueIn)
{
  OtherShapeCheckedTypeType = OtherShapeCheckedTypeTypeIn;
  OtherShapeCheckedTypeValue = OtherShapeCheckedTypeValueIn;
}

OtherShapeCheckedTypeChoicePair::~OtherShapeCheckedTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (OtherShapeCheckedTypeType == MeasuredE)
    delete OtherShapeCheckedTypeValue->Measured;
  else if (OtherShapeCheckedTypeType == ConstructedE)
    delete OtherShapeCheckedTypeValue->Constructed;
  delete OtherShapeCheckedTypeValue;
  #endif
}

void OtherShapeCheckedTypeChoicePair::printSelf(FILE * outFile)
{
  if (OtherShapeCheckedTypeType == MeasuredE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Measured");
      OtherShapeCheckedTypeValue->Measured->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Measured>\n");
    }
  else if (OtherShapeCheckedTypeType == ConstructedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      OtherShapeCheckedTypeValue->Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
}

/* ***************************************************************** */

/* class OtherShapeConstructionMethodType

*/

OtherShapeConstructionMethodType::OtherShapeConstructionMethodType()
{
  OtherShapeConstructionMethodTypePair = 0;
}

OtherShapeConstructionMethodType::OtherShapeConstructionMethodType(
 OtherShapeConstructionMethodTypeChoicePair * OtherShapeConstructionMethodTypePairIn)
{
  OtherShapeConstructionMethodTypePair = OtherShapeConstructionMethodTypePairIn;
}

OtherShapeConstructionMethodType::~OtherShapeConstructionMethodType()
{
  #ifndef NODESTRUCT
  delete OtherShapeConstructionMethodTypePair;
  #endif
}

void OtherShapeConstructionMethodType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (OtherShapeConstructionMethodTypePair)
    {
      OtherShapeConstructionMethodTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

OtherShapeConstructionMethodTypeChoicePair * OtherShapeConstructionMethodType::getOtherShapeConstructionMethodTypePair()
{return OtherShapeConstructionMethodTypePair;}

void OtherShapeConstructionMethodType::setOtherShapeConstructionMethodTypePair(OtherShapeConstructionMethodTypeChoicePair * OtherShapeConstructionMethodTypePairIn)
{OtherShapeConstructionMethodTypePair = OtherShapeConstructionMethodTypePairIn;}
OtherShapeConstructionMethodTypeChoicePair::OtherShapeConstructionMethodTypeChoicePair() {}

OtherShapeConstructionMethodTypeChoicePair::OtherShapeConstructionMethodTypeChoicePair(
 whichOne OtherShapeConstructionMethodTypeTypeIn,
 OtherShapeConstructionMethodTypeVal * OtherShapeConstructionMethodTypeValueIn)
{
  OtherShapeConstructionMethodTypeType = OtherShapeConstructionMethodTypeTypeIn;
  OtherShapeConstructionMethodTypeValue = OtherShapeConstructionMethodTypeValueIn;
}

OtherShapeConstructionMethodTypeChoicePair::~OtherShapeConstructionMethodTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (OtherShapeConstructionMethodTypeType == CopyE)
    delete OtherShapeConstructionMethodTypeValue->Copy;
  delete OtherShapeConstructionMethodTypeValue;
  #endif
}

void OtherShapeConstructionMethodTypeChoicePair::printSelf(FILE * outFile)
{
  if (OtherShapeConstructionMethodTypeType == CopyE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Copy");
      OtherShapeConstructionMethodTypeValue->Copy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Copy>\n");
    }
}

/* ***************************************************************** */

/* class OtherShapeFeatureCopyType

*/

OtherShapeFeatureCopyType::OtherShapeFeatureCopyType() :
  ConstructionMethodBaseType()
{
  BaseOtherShapeFeature = 0;
}

OtherShapeFeatureCopyType::OtherShapeFeatureCopyType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseOtherShapeFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseOtherShapeFeature = BaseOtherShapeFeatureIn;
}

OtherShapeFeatureCopyType::~OtherShapeFeatureCopyType()
{
  #ifndef NODESTRUCT
  delete BaseOtherShapeFeature;
  #endif
}

void OtherShapeFeatureCopyType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseOtherShapeFeature");
  BaseOtherShapeFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseOtherShapeFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * OtherShapeFeatureCopyType::getBaseOtherShapeFeature()
{return BaseOtherShapeFeature;}

void OtherShapeFeatureCopyType::setBaseOtherShapeFeature(BaseFeatureType * BaseOtherShapeFeatureIn)
{BaseOtherShapeFeature = BaseOtherShapeFeatureIn;}

/* ***************************************************************** */

/* class OtherShapeFeatureDefinitionType

*/

OtherShapeFeatureDefinitionType::OtherShapeFeatureDefinitionType() :
  ShapeFeatureDefinitionBaseType()
{
  Description = 0;
}

OtherShapeFeatureDefinitionType::OtherShapeFeatureDefinitionType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn) :
  ShapeFeatureDefinitionBaseType(
    AttributesIn)
{
  Description = DescriptionIn;
}

OtherShapeFeatureDefinitionType::OtherShapeFeatureDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlString * DescriptionIn) :
  ShapeFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
  Description = DescriptionIn;
}

OtherShapeFeatureDefinitionType::~OtherShapeFeatureDefinitionType()
{
  #ifndef NODESTRUCT
  delete Description;
  #endif
}

void OtherShapeFeatureDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Description");
  Description->printSelf(outFile);
  fprintf(outFile, "</Description>\n");
  doSpaces(-INDENT, outFile);
}

bool OtherShapeFeatureDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OtherShapeFeatureDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OtherShapeFeatureDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OtherShapeFeatureDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OtherShapeFeatureDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

XmlString * OtherShapeFeatureDefinitionType::getDescription()
{return Description;}

void OtherShapeFeatureDefinitionType::setDescription(XmlString * DescriptionIn)
{Description = DescriptionIn;}

/* ***************************************************************** */

/* class OtherShapeFeatureItemType

*/

OtherShapeFeatureItemType::OtherShapeFeatureItemType() :
  ShapeFeatureItemBaseType()
{
  DeterminationMode = 0;
}

OtherShapeFeatureItemType::OtherShapeFeatureItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 OtherShapeMeasurementDeterminationType * DeterminationModeIn) :
  ShapeFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

OtherShapeFeatureItemType::OtherShapeFeatureItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 OtherShapeMeasurementDeterminationType * DeterminationModeIn) :
  ShapeFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

OtherShapeFeatureItemType::~OtherShapeFeatureItemType()
{
  #ifndef NODESTRUCT
  delete DeterminationMode;
  #endif
}

void OtherShapeFeatureItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<DeterminationMode");
  DeterminationMode->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeterminationMode>\n");
  doSpaces(-INDENT, outFile);
}

bool OtherShapeFeatureItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OtherShapeFeatureItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OtherShapeFeatureItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OtherShapeFeatureItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OtherShapeFeatureItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

OtherShapeMeasurementDeterminationType * OtherShapeFeatureItemType::getDeterminationMode()
{return DeterminationMode;}

void OtherShapeFeatureItemType::setDeterminationMode(OtherShapeMeasurementDeterminationType * DeterminationModeIn)
{DeterminationMode = DeterminationModeIn;}

/* ***************************************************************** */

/* class OtherShapeFeatureMeasurementType

*/

OtherShapeFeatureMeasurementType::OtherShapeFeatureMeasurementType() :
  ShapeFeatureMeasurementBaseType()
{
}

OtherShapeFeatureMeasurementType::OtherShapeFeatureMeasurementType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn) :
  ShapeFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
}

OtherShapeFeatureMeasurementType::OtherShapeFeatureMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn) :
  ShapeFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
}

OtherShapeFeatureMeasurementType::~OtherShapeFeatureMeasurementType()
{
  #ifndef NODESTRUCT
  #endif
}

void OtherShapeFeatureMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool OtherShapeFeatureMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OtherShapeFeatureMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OtherShapeFeatureMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OtherShapeFeatureMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OtherShapeFeatureMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class OtherShapeFeatureNominalType

*/

OtherShapeFeatureNominalType::OtherShapeFeatureNominalType() :
  ShapeFeatureNominalBaseType()
{
  Constructed = 0;
}

OtherShapeFeatureNominalType::OtherShapeFeatureNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 OtherShapeConstructionMethodType * ConstructedIn) :
  ShapeFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  Constructed = ConstructedIn;
}

OtherShapeFeatureNominalType::OtherShapeFeatureNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 OtherShapeConstructionMethodType * ConstructedIn) :
  ShapeFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  Constructed = ConstructedIn;
}

OtherShapeFeatureNominalType::~OtherShapeFeatureNominalType()
{
  #ifndef NODESTRUCT
  delete Constructed;
  #endif
}

void OtherShapeFeatureNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (Constructed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool OtherShapeFeatureNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OtherShapeFeatureNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OtherShapeFeatureNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OtherShapeFeatureNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OtherShapeFeatureNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

OtherShapeConstructionMethodType * OtherShapeFeatureNominalType::getConstructed()
{return Constructed;}

void OtherShapeFeatureNominalType::setConstructed(OtherShapeConstructionMethodType * ConstructedIn)
{Constructed = ConstructedIn;}

/* ***************************************************************** */

/* class OtherShapeMeasurementDeterminationType

*/

OtherShapeMeasurementDeterminationType::OtherShapeMeasurementDeterminationType()
{
  OtherShapeMeasurementDeterminationTypePair = 0;
}

OtherShapeMeasurementDeterminationType::OtherShapeMeasurementDeterminationType(
 OtherShapeMeasurementDeterminationTypeChoicePair * OtherShapeMeasurementDeterminationTypePairIn)
{
  OtherShapeMeasurementDeterminationTypePair = OtherShapeMeasurementDeterminationTypePairIn;
}

OtherShapeMeasurementDeterminationType::~OtherShapeMeasurementDeterminationType()
{
  #ifndef NODESTRUCT
  delete OtherShapeMeasurementDeterminationTypePair;
  #endif
}

void OtherShapeMeasurementDeterminationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  OtherShapeMeasurementDeterminationTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

OtherShapeMeasurementDeterminationTypeChoicePair * OtherShapeMeasurementDeterminationType::getOtherShapeMeasurementDeterminationTypePair()
{return OtherShapeMeasurementDeterminationTypePair;}

void OtherShapeMeasurementDeterminationType::setOtherShapeMeasurementDeterminationTypePair(OtherShapeMeasurementDeterminationTypeChoicePair * OtherShapeMeasurementDeterminationTypePairIn)
{OtherShapeMeasurementDeterminationTypePair = OtherShapeMeasurementDeterminationTypePairIn;}
OtherShapeMeasurementDeterminationTypeChoicePair::OtherShapeMeasurementDeterminationTypeChoicePair() {}

OtherShapeMeasurementDeterminationTypeChoicePair::OtherShapeMeasurementDeterminationTypeChoicePair(
 whichOne OtherShapeMeasurementDeterminationTypeTypeIn,
 OtherShapeMeasurementDeterminationTypeVal * OtherShapeMeasurementDeterminationTypeValueIn)
{
  OtherShapeMeasurementDeterminationTypeType = OtherShapeMeasurementDeterminationTypeTypeIn;
  OtherShapeMeasurementDeterminationTypeValue = OtherShapeMeasurementDeterminationTypeValueIn;
}

OtherShapeMeasurementDeterminationTypeChoicePair::~OtherShapeMeasurementDeterminationTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (OtherShapeMeasurementDeterminationTypeType == CheckedE)
    delete OtherShapeMeasurementDeterminationTypeValue->Checked;
  else if (OtherShapeMeasurementDeterminationTypeType == SetE)
    delete OtherShapeMeasurementDeterminationTypeValue->Set;
  delete OtherShapeMeasurementDeterminationTypeValue;
  #endif
}

void OtherShapeMeasurementDeterminationTypeChoicePair::printSelf(FILE * outFile)
{
  if (OtherShapeMeasurementDeterminationTypeType == CheckedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Checked");
      OtherShapeMeasurementDeterminationTypeValue->Checked->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Checked>\n");
    }
  else if (OtherShapeMeasurementDeterminationTypeType == SetE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Set");
      OtherShapeMeasurementDeterminationTypeValue->Set->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class OtherSurfaceCheckedFeatureType

*/

OtherSurfaceCheckedFeatureType::OtherSurfaceCheckedFeatureType()
{
  CheckDetails = 0;
}

OtherSurfaceCheckedFeatureType::OtherSurfaceCheckedFeatureType(
 OtherSurfaceCheckedType * CheckDetailsIn)
{
  CheckDetails = CheckDetailsIn;
}

OtherSurfaceCheckedFeatureType::~OtherSurfaceCheckedFeatureType()
{
  #ifndef NODESTRUCT
  delete CheckDetails;
  #endif
}

void OtherSurfaceCheckedFeatureType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (CheckDetails)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CheckDetails");
      CheckDetails->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CheckDetails>\n");
    }
  doSpaces(-INDENT, outFile);
}

OtherSurfaceCheckedType * OtherSurfaceCheckedFeatureType::getCheckDetails()
{return CheckDetails;}

void OtherSurfaceCheckedFeatureType::setCheckDetails(OtherSurfaceCheckedType * CheckDetailsIn)
{CheckDetails = CheckDetailsIn;}

/* ***************************************************************** */

/* class OtherSurfaceCheckedType

*/

OtherSurfaceCheckedType::OtherSurfaceCheckedType()
{
  OtherSurfaceCheckedTypePair = 0;
}

OtherSurfaceCheckedType::OtherSurfaceCheckedType(
 OtherSurfaceCheckedTypeChoicePair * OtherSurfaceCheckedTypePairIn)
{
  OtherSurfaceCheckedTypePair = OtherSurfaceCheckedTypePairIn;
}

OtherSurfaceCheckedType::~OtherSurfaceCheckedType()
{
  #ifndef NODESTRUCT
  delete OtherSurfaceCheckedTypePair;
  #endif
}

void OtherSurfaceCheckedType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  OtherSurfaceCheckedTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

OtherSurfaceCheckedTypeChoicePair * OtherSurfaceCheckedType::getOtherSurfaceCheckedTypePair()
{return OtherSurfaceCheckedTypePair;}

void OtherSurfaceCheckedType::setOtherSurfaceCheckedTypePair(OtherSurfaceCheckedTypeChoicePair * OtherSurfaceCheckedTypePairIn)
{OtherSurfaceCheckedTypePair = OtherSurfaceCheckedTypePairIn;}
OtherSurfaceCheckedTypeChoicePair::OtherSurfaceCheckedTypeChoicePair() {}

OtherSurfaceCheckedTypeChoicePair::OtherSurfaceCheckedTypeChoicePair(
 whichOne OtherSurfaceCheckedTypeTypeIn,
 OtherSurfaceCheckedTypeVal * OtherSurfaceCheckedTypeValueIn)
{
  OtherSurfaceCheckedTypeType = OtherSurfaceCheckedTypeTypeIn;
  OtherSurfaceCheckedTypeValue = OtherSurfaceCheckedTypeValueIn;
}

OtherSurfaceCheckedTypeChoicePair::~OtherSurfaceCheckedTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (OtherSurfaceCheckedTypeType == MeasuredE)
    delete OtherSurfaceCheckedTypeValue->Measured;
  else if (OtherSurfaceCheckedTypeType == ConstructedE)
    delete OtherSurfaceCheckedTypeValue->Constructed;
  delete OtherSurfaceCheckedTypeValue;
  #endif
}

void OtherSurfaceCheckedTypeChoicePair::printSelf(FILE * outFile)
{
  if (OtherSurfaceCheckedTypeType == MeasuredE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Measured");
      OtherSurfaceCheckedTypeValue->Measured->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Measured>\n");
    }
  else if (OtherSurfaceCheckedTypeType == ConstructedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      OtherSurfaceCheckedTypeValue->Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
}

/* ***************************************************************** */

/* class OtherSurfaceConstructionMethodType

*/

OtherSurfaceConstructionMethodType::OtherSurfaceConstructionMethodType()
{
  OtherSurfaceConstructionMethodTypePair = 0;
}

OtherSurfaceConstructionMethodType::OtherSurfaceConstructionMethodType(
 OtherSurfaceConstructionMethodTypeChoicePair * OtherSurfaceConstructionMethodTypePairIn)
{
  OtherSurfaceConstructionMethodTypePair = OtherSurfaceConstructionMethodTypePairIn;
}

OtherSurfaceConstructionMethodType::~OtherSurfaceConstructionMethodType()
{
  #ifndef NODESTRUCT
  delete OtherSurfaceConstructionMethodTypePair;
  #endif
}

void OtherSurfaceConstructionMethodType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (OtherSurfaceConstructionMethodTypePair)
    {
      OtherSurfaceConstructionMethodTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

OtherSurfaceConstructionMethodTypeChoicePair * OtherSurfaceConstructionMethodType::getOtherSurfaceConstructionMethodTypePair()
{return OtherSurfaceConstructionMethodTypePair;}

void OtherSurfaceConstructionMethodType::setOtherSurfaceConstructionMethodTypePair(OtherSurfaceConstructionMethodTypeChoicePair * OtherSurfaceConstructionMethodTypePairIn)
{OtherSurfaceConstructionMethodTypePair = OtherSurfaceConstructionMethodTypePairIn;}
OtherSurfaceConstructionMethodTypeChoicePair::OtherSurfaceConstructionMethodTypeChoicePair() {}

OtherSurfaceConstructionMethodTypeChoicePair::OtherSurfaceConstructionMethodTypeChoicePair(
 whichOne OtherSurfaceConstructionMethodTypeTypeIn,
 OtherSurfaceConstructionMethodTypeVal * OtherSurfaceConstructionMethodTypeValueIn)
{
  OtherSurfaceConstructionMethodTypeType = OtherSurfaceConstructionMethodTypeTypeIn;
  OtherSurfaceConstructionMethodTypeValue = OtherSurfaceConstructionMethodTypeValueIn;
}

OtherSurfaceConstructionMethodTypeChoicePair::~OtherSurfaceConstructionMethodTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (OtherSurfaceConstructionMethodTypeType == CopyE)
    delete OtherSurfaceConstructionMethodTypeValue->Copy;
  delete OtherSurfaceConstructionMethodTypeValue;
  #endif
}

void OtherSurfaceConstructionMethodTypeChoicePair::printSelf(FILE * outFile)
{
  if (OtherSurfaceConstructionMethodTypeType == CopyE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Copy");
      OtherSurfaceConstructionMethodTypeValue->Copy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Copy>\n");
    }
}

/* ***************************************************************** */

/* class OtherSurfaceFeatureCopyType

*/

OtherSurfaceFeatureCopyType::OtherSurfaceFeatureCopyType() :
  ConstructionMethodBaseType()
{
  BaseOtherSurfaceFeature = 0;
}

OtherSurfaceFeatureCopyType::OtherSurfaceFeatureCopyType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseOtherSurfaceFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseOtherSurfaceFeature = BaseOtherSurfaceFeatureIn;
}

OtherSurfaceFeatureCopyType::~OtherSurfaceFeatureCopyType()
{
  #ifndef NODESTRUCT
  delete BaseOtherSurfaceFeature;
  #endif
}

void OtherSurfaceFeatureCopyType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseOtherSurfaceFeature");
  BaseOtherSurfaceFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseOtherSurfaceFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * OtherSurfaceFeatureCopyType::getBaseOtherSurfaceFeature()
{return BaseOtherSurfaceFeature;}

void OtherSurfaceFeatureCopyType::setBaseOtherSurfaceFeature(BaseFeatureType * BaseOtherSurfaceFeatureIn)
{BaseOtherSurfaceFeature = BaseOtherSurfaceFeatureIn;}

/* ***************************************************************** */

/* class OtherSurfaceFeatureDefinitionType

*/

OtherSurfaceFeatureDefinitionType::OtherSurfaceFeatureDefinitionType() :
  SurfaceFeatureDefinitionBaseType()
{
}

OtherSurfaceFeatureDefinitionType::OtherSurfaceFeatureDefinitionType(
 AttributesType * AttributesIn) :
  SurfaceFeatureDefinitionBaseType(
    AttributesIn)
{
}

OtherSurfaceFeatureDefinitionType::OtherSurfaceFeatureDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn) :
  SurfaceFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
}

OtherSurfaceFeatureDefinitionType::~OtherSurfaceFeatureDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void OtherSurfaceFeatureDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool OtherSurfaceFeatureDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OtherSurfaceFeatureDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OtherSurfaceFeatureDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OtherSurfaceFeatureDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OtherSurfaceFeatureDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class OtherSurfaceFeatureItemType

*/

OtherSurfaceFeatureItemType::OtherSurfaceFeatureItemType() :
  SurfaceFeatureItemBaseType()
{
  DeterminationMode = 0;
}

OtherSurfaceFeatureItemType::OtherSurfaceFeatureItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 OtherSurfaceMeasurementDeterminationType * DeterminationModeIn) :
  SurfaceFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

OtherSurfaceFeatureItemType::OtherSurfaceFeatureItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 OtherSurfaceMeasurementDeterminationType * DeterminationModeIn) :
  SurfaceFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

OtherSurfaceFeatureItemType::~OtherSurfaceFeatureItemType()
{
  #ifndef NODESTRUCT
  delete DeterminationMode;
  #endif
}

void OtherSurfaceFeatureItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<DeterminationMode");
  DeterminationMode->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeterminationMode>\n");
  doSpaces(-INDENT, outFile);
}

bool OtherSurfaceFeatureItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OtherSurfaceFeatureItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OtherSurfaceFeatureItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OtherSurfaceFeatureItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OtherSurfaceFeatureItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

OtherSurfaceMeasurementDeterminationType * OtherSurfaceFeatureItemType::getDeterminationMode()
{return DeterminationMode;}

void OtherSurfaceFeatureItemType::setDeterminationMode(OtherSurfaceMeasurementDeterminationType * DeterminationModeIn)
{DeterminationMode = DeterminationModeIn;}

/* ***************************************************************** */

/* class OtherSurfaceFeatureMeasurementType

*/

OtherSurfaceFeatureMeasurementType::OtherSurfaceFeatureMeasurementType() :
  SurfaceFeatureMeasurementBaseType()
{
  PolyLine = 0;
}

OtherSurfaceFeatureMeasurementType::OtherSurfaceFeatureMeasurementType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 PolyLineType * PolyLineIn) :
  SurfaceFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  PolyLine = PolyLineIn;
}

OtherSurfaceFeatureMeasurementType::OtherSurfaceFeatureMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 PolyLineType * PolyLineIn) :
  SurfaceFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  PolyLine = PolyLineIn;
}

OtherSurfaceFeatureMeasurementType::~OtherSurfaceFeatureMeasurementType()
{
  #ifndef NODESTRUCT
  delete PolyLine;
  #endif
}

void OtherSurfaceFeatureMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  if (PolyLine)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PolyLine");
      PolyLine->printSelf(outFile);
      fprintf(outFile, "</PolyLine>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool OtherSurfaceFeatureMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OtherSurfaceFeatureMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OtherSurfaceFeatureMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OtherSurfaceFeatureMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OtherSurfaceFeatureMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

PolyLineType * OtherSurfaceFeatureMeasurementType::getPolyLine()
{return PolyLine;}

void OtherSurfaceFeatureMeasurementType::setPolyLine(PolyLineType * PolyLineIn)
{PolyLine = PolyLineIn;}

/* ***************************************************************** */

/* class OtherSurfaceFeatureNominalType

*/

OtherSurfaceFeatureNominalType::OtherSurfaceFeatureNominalType() :
  SurfaceFeatureNominalBaseType()
{
  OtherSurfaceFeatureNominalTypePair = 0;
}

OtherSurfaceFeatureNominalType::OtherSurfaceFeatureNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 OtherSurfaceFeatureNominalTypeChoicePair * OtherSurfaceFeatureNominalTypePairIn) :
  SurfaceFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  OtherSurfaceFeatureNominalTypePair = OtherSurfaceFeatureNominalTypePairIn;
}

OtherSurfaceFeatureNominalType::OtherSurfaceFeatureNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 OtherSurfaceFeatureNominalTypeChoicePair * OtherSurfaceFeatureNominalTypePairIn) :
  SurfaceFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  OtherSurfaceFeatureNominalTypePair = OtherSurfaceFeatureNominalTypePairIn;
}

OtherSurfaceFeatureNominalType::~OtherSurfaceFeatureNominalType()
{
  #ifndef NODESTRUCT
  delete OtherSurfaceFeatureNominalTypePair;
  #endif
}

void OtherSurfaceFeatureNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (OtherSurfaceFeatureNominalTypePair)
    {
      OtherSurfaceFeatureNominalTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}
OtherSurfaceFeatureNominalTypeChoicePair * OtherSurfaceFeatureNominalType::getOtherSurfaceFeatureNominalTypeChoicePair()
{return OtherSurfaceFeatureNominalTypePair;}

void OtherSurfaceFeatureNominalType::setOtherSurfaceFeatureNominalTypeChoicePair(OtherSurfaceFeatureNominalTypeChoicePair * OtherSurfaceFeatureNominalTypePairIn)
{OtherSurfaceFeatureNominalTypePair = OtherSurfaceFeatureNominalTypePairIn;}

/* ***************************************************************** */

OtherSurfaceFeatureNominalTypeChoicePair::OtherSurfaceFeatureNominalTypeChoicePair() {}

OtherSurfaceFeatureNominalTypeChoicePair::OtherSurfaceFeatureNominalTypeChoicePair(
 whichOne OtherSurfaceFeatureNominalTypeTypeIn,
 OtherSurfaceFeatureNominalTypeVal * OtherSurfaceFeatureNominalTypeValueIn)
{
  OtherSurfaceFeatureNominalTypeType = OtherSurfaceFeatureNominalTypeTypeIn;
  OtherSurfaceFeatureNominalTypeValue = OtherSurfaceFeatureNominalTypeValueIn;
}

OtherSurfaceFeatureNominalTypeChoicePair::~OtherSurfaceFeatureNominalTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (OtherSurfaceFeatureNominalTypeType == PolyLineE)
    delete OtherSurfaceFeatureNominalTypeValue->PolyLine;
  else if (OtherSurfaceFeatureNominalTypeType == ClosedSurfaceE)
    delete OtherSurfaceFeatureNominalTypeValue->ClosedSurface;
  else if (OtherSurfaceFeatureNominalTypeType == ConstructedE)
    delete OtherSurfaceFeatureNominalTypeValue->Constructed;
  delete OtherSurfaceFeatureNominalTypeValue;
  #endif
}

void OtherSurfaceFeatureNominalTypeChoicePair::printSelf(FILE * outFile)
{
  if (OtherSurfaceFeatureNominalTypeType == PolyLineE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PolyLine");
      OtherSurfaceFeatureNominalTypeValue->PolyLine->printSelf(outFile);
      fprintf(outFile, "</PolyLine>\n");
    }
  else if (OtherSurfaceFeatureNominalTypeType == ClosedSurfaceE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ClosedSurface");
      OtherSurfaceFeatureNominalTypeValue->ClosedSurface->printSelf(outFile);
      fprintf(outFile, "</ClosedSurface>\n");
    }
  else if (OtherSurfaceFeatureNominalTypeType == ConstructedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      OtherSurfaceFeatureNominalTypeValue->Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
}

bool OtherSurfaceFeatureNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OtherSurfaceFeatureNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OtherSurfaceFeatureNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OtherSurfaceFeatureNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OtherSurfaceFeatureNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class OtherSurfaceMeasurementDeterminationType

*/

OtherSurfaceMeasurementDeterminationType::OtherSurfaceMeasurementDeterminationType()
{
  OtherSurfaceMeasurementDeterminationTypePair = 0;
}

OtherSurfaceMeasurementDeterminationType::OtherSurfaceMeasurementDeterminationType(
 OtherSurfaceMeasurementDeterminationTypeChoicePair * OtherSurfaceMeasurementDeterminationTypePairIn)
{
  OtherSurfaceMeasurementDeterminationTypePair = OtherSurfaceMeasurementDeterminationTypePairIn;
}

OtherSurfaceMeasurementDeterminationType::~OtherSurfaceMeasurementDeterminationType()
{
  #ifndef NODESTRUCT
  delete OtherSurfaceMeasurementDeterminationTypePair;
  #endif
}

void OtherSurfaceMeasurementDeterminationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  OtherSurfaceMeasurementDeterminationTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

OtherSurfaceMeasurementDeterminationTypeChoicePair * OtherSurfaceMeasurementDeterminationType::getOtherSurfaceMeasurementDeterminationTypePair()
{return OtherSurfaceMeasurementDeterminationTypePair;}

void OtherSurfaceMeasurementDeterminationType::setOtherSurfaceMeasurementDeterminationTypePair(OtherSurfaceMeasurementDeterminationTypeChoicePair * OtherSurfaceMeasurementDeterminationTypePairIn)
{OtherSurfaceMeasurementDeterminationTypePair = OtherSurfaceMeasurementDeterminationTypePairIn;}
OtherSurfaceMeasurementDeterminationTypeChoicePair::OtherSurfaceMeasurementDeterminationTypeChoicePair() {}

OtherSurfaceMeasurementDeterminationTypeChoicePair::OtherSurfaceMeasurementDeterminationTypeChoicePair(
 whichOne OtherSurfaceMeasurementDeterminationTypeTypeIn,
 OtherSurfaceMeasurementDeterminationTypeVal * OtherSurfaceMeasurementDeterminationTypeValueIn)
{
  OtherSurfaceMeasurementDeterminationTypeType = OtherSurfaceMeasurementDeterminationTypeTypeIn;
  OtherSurfaceMeasurementDeterminationTypeValue = OtherSurfaceMeasurementDeterminationTypeValueIn;
}

OtherSurfaceMeasurementDeterminationTypeChoicePair::~OtherSurfaceMeasurementDeterminationTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (OtherSurfaceMeasurementDeterminationTypeType == CheckedE)
    delete OtherSurfaceMeasurementDeterminationTypeValue->Checked;
  else if (OtherSurfaceMeasurementDeterminationTypeType == SetE)
    delete OtherSurfaceMeasurementDeterminationTypeValue->Set;
  delete OtherSurfaceMeasurementDeterminationTypeValue;
  #endif
}

void OtherSurfaceMeasurementDeterminationTypeChoicePair::printSelf(FILE * outFile)
{
  if (OtherSurfaceMeasurementDeterminationTypeType == CheckedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Checked");
      OtherSurfaceMeasurementDeterminationTypeValue->Checked->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Checked>\n");
    }
  else if (OtherSurfaceMeasurementDeterminationTypeType == SetE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Set");
      OtherSurfaceMeasurementDeterminationTypeValue->Set->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class PatternFeatureCircleDefinitionType

*/

PatternFeatureCircleDefinitionType::PatternFeatureCircleDefinitionType() :
  PatternFeatureDefinitionBaseType()
{
  Diameter = 0;
  FeatureDirection = 0;
  NumberOfFeatures = 0;
}

PatternFeatureCircleDefinitionType::PatternFeatureCircleDefinitionType(
 AttributesType * AttributesIn,
 XmlBoolean * IsProfileGroupIn,
 XmlBoolean * IsRunoutGroupIn,
 GroupFeatureDef_1080_Type * GroupFeatureDef_1080In,
 LinearValueType * DiameterIn,
 UnitVectorType * FeatureDirectionIn,
 NaturalType * NumberOfFeaturesIn) :
  PatternFeatureDefinitionBaseType(
    AttributesIn,
    IsProfileGroupIn,
    IsRunoutGroupIn,
    GroupFeatureDef_1080In)
{
  Diameter = DiameterIn;
  FeatureDirection = FeatureDirectionIn;
  NumberOfFeatures = NumberOfFeaturesIn;
}

PatternFeatureCircleDefinitionType::PatternFeatureCircleDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlBoolean * IsProfileGroupIn,
 XmlBoolean * IsRunoutGroupIn,
 GroupFeatureDef_1080_Type * GroupFeatureDef_1080In,
 LinearValueType * DiameterIn,
 UnitVectorType * FeatureDirectionIn,
 NaturalType * NumberOfFeaturesIn) :
  PatternFeatureDefinitionBaseType(
    idIn,
    AttributesIn,
    IsProfileGroupIn,
    IsRunoutGroupIn,
    GroupFeatureDef_1080In)
{
  Diameter = DiameterIn;
  FeatureDirection = FeatureDirectionIn;
  NumberOfFeatures = NumberOfFeaturesIn;
}

PatternFeatureCircleDefinitionType::~PatternFeatureCircleDefinitionType()
{
  #ifndef NODESTRUCT
  delete Diameter;
  delete FeatureDirection;
  delete NumberOfFeatures;
  #endif
}

void PatternFeatureCircleDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (IsProfileGroup)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IsProfileGroup");
      IsProfileGroup->printSelf(outFile);
      fprintf(outFile, "</IsProfileGroup>\n");
    }
  if (IsRunoutGroup)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IsRunoutGroup");
      IsRunoutGroup->printSelf(outFile);
      fprintf(outFile, "</IsRunoutGroup>\n");
    }
  if (GroupFeatureDef_1080)
    {
  GroupFeatureDef_1080->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Diameter");
  Diameter->printSelf(outFile);
  fprintf(outFile, "</Diameter>\n");
  if (FeatureDirection)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureDirection");
      FeatureDirection->printSelf(outFile);
      fprintf(outFile, "</FeatureDirection>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<NumberOfFeatures");
  NumberOfFeatures->printSelf(outFile);
  fprintf(outFile, "</NumberOfFeatures>\n");
  doSpaces(-INDENT, outFile);
}

bool PatternFeatureCircleDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PatternFeatureCircleDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PatternFeatureCircleDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PatternFeatureCircleDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PatternFeatureCircleDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LinearValueType * PatternFeatureCircleDefinitionType::getDiameter()
{return Diameter;}

void PatternFeatureCircleDefinitionType::setDiameter(LinearValueType * DiameterIn)
{Diameter = DiameterIn;}

UnitVectorType * PatternFeatureCircleDefinitionType::getFeatureDirection()
{return FeatureDirection;}

void PatternFeatureCircleDefinitionType::setFeatureDirection(UnitVectorType * FeatureDirectionIn)
{FeatureDirection = FeatureDirectionIn;}

NaturalType * PatternFeatureCircleDefinitionType::getNumberOfFeatures()
{return NumberOfFeatures;}

void PatternFeatureCircleDefinitionType::setNumberOfFeatures(NaturalType * NumberOfFeaturesIn)
{NumberOfFeatures = NumberOfFeaturesIn;}

/* ***************************************************************** */

/* class PatternFeatureCircleItemType

*/

PatternFeatureCircleItemType::PatternFeatureCircleItemType() :
  PatternFeatureItemBaseType()
{
}

PatternFeatureCircleItemType::PatternFeatureCircleItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  PatternFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
}

PatternFeatureCircleItemType::PatternFeatureCircleItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  PatternFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
}

PatternFeatureCircleItemType::~PatternFeatureCircleItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void PatternFeatureCircleItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool PatternFeatureCircleItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PatternFeatureCircleItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PatternFeatureCircleItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PatternFeatureCircleItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PatternFeatureCircleItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class PatternFeatureCircleNominalType

*/

PatternFeatureCircleNominalType::PatternFeatureCircleNominalType() :
  PatternFeatureNominalBaseType()
{
  Normal = 0;
  Center = 0;
  FirstFeatureLocation = 0;
}

PatternFeatureCircleNominalType::PatternFeatureCircleNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 UnitVectorType * NormalIn,
 PointType * CenterIn,
 QIFReferenceType * FirstFeatureLocationIn) :
  PatternFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    FeatureNominalIdsIn)
{
  Normal = NormalIn;
  Center = CenterIn;
  FirstFeatureLocation = FirstFeatureLocationIn;
}

PatternFeatureCircleNominalType::PatternFeatureCircleNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 UnitVectorType * NormalIn,
 PointType * CenterIn,
 QIFReferenceType * FirstFeatureLocationIn) :
  PatternFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    FeatureNominalIdsIn)
{
  Normal = NormalIn;
  Center = CenterIn;
  FirstFeatureLocation = FirstFeatureLocationIn;
}

PatternFeatureCircleNominalType::~PatternFeatureCircleNominalType()
{
  #ifndef NODESTRUCT
  delete Normal;
  delete Center;
  delete FirstFeatureLocation;
  #endif
}

void PatternFeatureCircleNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalIds");
  FeatureNominalIds->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</FeatureNominalIds>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Normal");
  Normal->printSelf(outFile);
  fprintf(outFile, "</Normal>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Center");
  Center->printSelf(outFile);
  fprintf(outFile, "</Center>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<FirstFeatureLocation");
  FirstFeatureLocation->printSelf(outFile);
  fprintf(outFile, "</FirstFeatureLocation>\n");
  doSpaces(-INDENT, outFile);
}

bool PatternFeatureCircleNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PatternFeatureCircleNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PatternFeatureCircleNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PatternFeatureCircleNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PatternFeatureCircleNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

UnitVectorType * PatternFeatureCircleNominalType::getNormal()
{return Normal;}

void PatternFeatureCircleNominalType::setNormal(UnitVectorType * NormalIn)
{Normal = NormalIn;}

PointType * PatternFeatureCircleNominalType::getCenter()
{return Center;}

void PatternFeatureCircleNominalType::setCenter(PointType * CenterIn)
{Center = CenterIn;}

QIFReferenceType * PatternFeatureCircleNominalType::getFirstFeatureLocation()
{return FirstFeatureLocation;}

void PatternFeatureCircleNominalType::setFirstFeatureLocation(QIFReferenceType * FirstFeatureLocationIn)
{FirstFeatureLocation = FirstFeatureLocationIn;}

/* ***************************************************************** */

/* class PatternFeatureCircularArcDefinitionType

*/

PatternFeatureCircularArcDefinitionType::PatternFeatureCircularArcDefinitionType() :
  PatternFeatureDefinitionBaseType()
{
  ArcRadius = 0;
  IncrementalArc = 0;
  FeatureDirection = 0;
  NumberOfFeatures = 0;
}

PatternFeatureCircularArcDefinitionType::PatternFeatureCircularArcDefinitionType(
 AttributesType * AttributesIn,
 XmlBoolean * IsProfileGroupIn,
 XmlBoolean * IsRunoutGroupIn,
 GroupFeatureDef_1080_Type * GroupFeatureDef_1080In,
 LinearValueType * ArcRadiusIn,
 AngularValueType * IncrementalArcIn,
 UnitVectorType * FeatureDirectionIn,
 NaturalType * NumberOfFeaturesIn) :
  PatternFeatureDefinitionBaseType(
    AttributesIn,
    IsProfileGroupIn,
    IsRunoutGroupIn,
    GroupFeatureDef_1080In)
{
  ArcRadius = ArcRadiusIn;
  IncrementalArc = IncrementalArcIn;
  FeatureDirection = FeatureDirectionIn;
  NumberOfFeatures = NumberOfFeaturesIn;
}

PatternFeatureCircularArcDefinitionType::PatternFeatureCircularArcDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlBoolean * IsProfileGroupIn,
 XmlBoolean * IsRunoutGroupIn,
 GroupFeatureDef_1080_Type * GroupFeatureDef_1080In,
 LinearValueType * ArcRadiusIn,
 AngularValueType * IncrementalArcIn,
 UnitVectorType * FeatureDirectionIn,
 NaturalType * NumberOfFeaturesIn) :
  PatternFeatureDefinitionBaseType(
    idIn,
    AttributesIn,
    IsProfileGroupIn,
    IsRunoutGroupIn,
    GroupFeatureDef_1080In)
{
  ArcRadius = ArcRadiusIn;
  IncrementalArc = IncrementalArcIn;
  FeatureDirection = FeatureDirectionIn;
  NumberOfFeatures = NumberOfFeaturesIn;
}

PatternFeatureCircularArcDefinitionType::~PatternFeatureCircularArcDefinitionType()
{
  #ifndef NODESTRUCT
  delete ArcRadius;
  delete IncrementalArc;
  delete FeatureDirection;
  delete NumberOfFeatures;
  #endif
}

void PatternFeatureCircularArcDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (IsProfileGroup)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IsProfileGroup");
      IsProfileGroup->printSelf(outFile);
      fprintf(outFile, "</IsProfileGroup>\n");
    }
  if (IsRunoutGroup)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IsRunoutGroup");
      IsRunoutGroup->printSelf(outFile);
      fprintf(outFile, "</IsRunoutGroup>\n");
    }
  if (GroupFeatureDef_1080)
    {
  GroupFeatureDef_1080->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ArcRadius");
  ArcRadius->printSelf(outFile);
  fprintf(outFile, "</ArcRadius>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<IncrementalArc");
  IncrementalArc->printSelf(outFile);
  fprintf(outFile, "</IncrementalArc>\n");
  if (FeatureDirection)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureDirection");
      FeatureDirection->printSelf(outFile);
      fprintf(outFile, "</FeatureDirection>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<NumberOfFeatures");
  NumberOfFeatures->printSelf(outFile);
  fprintf(outFile, "</NumberOfFeatures>\n");
  doSpaces(-INDENT, outFile);
}

bool PatternFeatureCircularArcDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PatternFeatureCircularArcDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PatternFeatureCircularArcDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PatternFeatureCircularArcDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PatternFeatureCircularArcDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LinearValueType * PatternFeatureCircularArcDefinitionType::getArcRadius()
{return ArcRadius;}

void PatternFeatureCircularArcDefinitionType::setArcRadius(LinearValueType * ArcRadiusIn)
{ArcRadius = ArcRadiusIn;}

AngularValueType * PatternFeatureCircularArcDefinitionType::getIncrementalArc()
{return IncrementalArc;}

void PatternFeatureCircularArcDefinitionType::setIncrementalArc(AngularValueType * IncrementalArcIn)
{IncrementalArc = IncrementalArcIn;}

UnitVectorType * PatternFeatureCircularArcDefinitionType::getFeatureDirection()
{return FeatureDirection;}

void PatternFeatureCircularArcDefinitionType::setFeatureDirection(UnitVectorType * FeatureDirectionIn)
{FeatureDirection = FeatureDirectionIn;}

NaturalType * PatternFeatureCircularArcDefinitionType::getNumberOfFeatures()
{return NumberOfFeatures;}

void PatternFeatureCircularArcDefinitionType::setNumberOfFeatures(NaturalType * NumberOfFeaturesIn)
{NumberOfFeatures = NumberOfFeaturesIn;}

/* ***************************************************************** */

/* class PatternFeatureCircularArcItemType

*/

PatternFeatureCircularArcItemType::PatternFeatureCircularArcItemType() :
  PatternFeatureItemBaseType()
{
}

PatternFeatureCircularArcItemType::PatternFeatureCircularArcItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  PatternFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
}

PatternFeatureCircularArcItemType::PatternFeatureCircularArcItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  PatternFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
}

PatternFeatureCircularArcItemType::~PatternFeatureCircularArcItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void PatternFeatureCircularArcItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool PatternFeatureCircularArcItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PatternFeatureCircularArcItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PatternFeatureCircularArcItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PatternFeatureCircularArcItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PatternFeatureCircularArcItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class PatternFeatureCircularArcNominalType

*/

PatternFeatureCircularArcNominalType::PatternFeatureCircularArcNominalType() :
  PatternFeatureNominalBaseType()
{
  Normal = 0;
  Center = 0;
  FirstFeatureLocation = 0;
}

PatternFeatureCircularArcNominalType::PatternFeatureCircularArcNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 UnitVectorType * NormalIn,
 PointType * CenterIn,
 QIFReferenceType * FirstFeatureLocationIn) :
  PatternFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    FeatureNominalIdsIn)
{
  Normal = NormalIn;
  Center = CenterIn;
  FirstFeatureLocation = FirstFeatureLocationIn;
}

PatternFeatureCircularArcNominalType::PatternFeatureCircularArcNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 UnitVectorType * NormalIn,
 PointType * CenterIn,
 QIFReferenceType * FirstFeatureLocationIn) :
  PatternFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    FeatureNominalIdsIn)
{
  Normal = NormalIn;
  Center = CenterIn;
  FirstFeatureLocation = FirstFeatureLocationIn;
}

PatternFeatureCircularArcNominalType::~PatternFeatureCircularArcNominalType()
{
  #ifndef NODESTRUCT
  delete Normal;
  delete Center;
  delete FirstFeatureLocation;
  #endif
}

void PatternFeatureCircularArcNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalIds");
  FeatureNominalIds->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</FeatureNominalIds>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Normal");
  Normal->printSelf(outFile);
  fprintf(outFile, "</Normal>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Center");
  Center->printSelf(outFile);
  fprintf(outFile, "</Center>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<FirstFeatureLocation");
  FirstFeatureLocation->printSelf(outFile);
  fprintf(outFile, "</FirstFeatureLocation>\n");
  doSpaces(-INDENT, outFile);
}

bool PatternFeatureCircularArcNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PatternFeatureCircularArcNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PatternFeatureCircularArcNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PatternFeatureCircularArcNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PatternFeatureCircularArcNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

UnitVectorType * PatternFeatureCircularArcNominalType::getNormal()
{return Normal;}

void PatternFeatureCircularArcNominalType::setNormal(UnitVectorType * NormalIn)
{Normal = NormalIn;}

PointType * PatternFeatureCircularArcNominalType::getCenter()
{return Center;}

void PatternFeatureCircularArcNominalType::setCenter(PointType * CenterIn)
{Center = CenterIn;}

QIFReferenceType * PatternFeatureCircularArcNominalType::getFirstFeatureLocation()
{return FirstFeatureLocation;}

void PatternFeatureCircularArcNominalType::setFirstFeatureLocation(QIFReferenceType * FirstFeatureLocationIn)
{FirstFeatureLocation = FirstFeatureLocationIn;}

/* ***************************************************************** */

/* class PatternFeatureDefinitionBaseType

*/

PatternFeatureDefinitionBaseType::PatternFeatureDefinitionBaseType() :
  GroupFeatureDefinitionType()
{
}

PatternFeatureDefinitionBaseType::PatternFeatureDefinitionBaseType(
 AttributesType * AttributesIn,
 XmlBoolean * IsProfileGroupIn,
 XmlBoolean * IsRunoutGroupIn,
 GroupFeatureDef_1080_Type * GroupFeatureDef_1080In) :
  GroupFeatureDefinitionType(
    AttributesIn,
    IsProfileGroupIn,
    IsRunoutGroupIn,
    GroupFeatureDef_1080In)
{
}

PatternFeatureDefinitionBaseType::PatternFeatureDefinitionBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlBoolean * IsProfileGroupIn,
 XmlBoolean * IsRunoutGroupIn,
 GroupFeatureDef_1080_Type * GroupFeatureDef_1080In) :
  GroupFeatureDefinitionType(
    idIn,
    AttributesIn,
    IsProfileGroupIn,
    IsRunoutGroupIn,
    GroupFeatureDef_1080In)
{
}

PatternFeatureDefinitionBaseType::~PatternFeatureDefinitionBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void PatternFeatureDefinitionBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (IsProfileGroup)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IsProfileGroup");
      IsProfileGroup->printSelf(outFile);
      fprintf(outFile, "</IsProfileGroup>\n");
    }
  if (IsRunoutGroup)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IsRunoutGroup");
      IsRunoutGroup->printSelf(outFile);
      fprintf(outFile, "</IsRunoutGroup>\n");
    }
  if (GroupFeatureDef_1080)
    {
  GroupFeatureDef_1080->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool PatternFeatureDefinitionBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PatternFeatureDefinitionBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PatternFeatureDefinitionBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PatternFeatureDefinitionBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PatternFeatureDefinitionBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class PatternFeatureItemBaseType

*/

PatternFeatureItemBaseType::PatternFeatureItemBaseType() :
  GroupFeatureItemType()
{
}

PatternFeatureItemBaseType::PatternFeatureItemBaseType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  GroupFeatureItemType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
}

PatternFeatureItemBaseType::PatternFeatureItemBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  GroupFeatureItemType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
}

PatternFeatureItemBaseType::~PatternFeatureItemBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void PatternFeatureItemBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool PatternFeatureItemBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PatternFeatureItemBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PatternFeatureItemBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PatternFeatureItemBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PatternFeatureItemBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class PatternFeatureLinearDefinitionType

*/

PatternFeatureLinearDefinitionType::PatternFeatureLinearDefinitionType() :
  PatternFeatureDefinitionBaseType()
{
  LineDirection = 0;
  IncrementalDistance = 0;
  FeatureDirection = 0;
  NumberOfFeatures = 0;
}

PatternFeatureLinearDefinitionType::PatternFeatureLinearDefinitionType(
 AttributesType * AttributesIn,
 XmlBoolean * IsProfileGroupIn,
 XmlBoolean * IsRunoutGroupIn,
 GroupFeatureDef_1080_Type * GroupFeatureDef_1080In,
 UnitVectorType * LineDirectionIn,
 LinearValueType * IncrementalDistanceIn,
 UnitVectorType * FeatureDirectionIn,
 NaturalType * NumberOfFeaturesIn) :
  PatternFeatureDefinitionBaseType(
    AttributesIn,
    IsProfileGroupIn,
    IsRunoutGroupIn,
    GroupFeatureDef_1080In)
{
  LineDirection = LineDirectionIn;
  IncrementalDistance = IncrementalDistanceIn;
  FeatureDirection = FeatureDirectionIn;
  NumberOfFeatures = NumberOfFeaturesIn;
}

PatternFeatureLinearDefinitionType::PatternFeatureLinearDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlBoolean * IsProfileGroupIn,
 XmlBoolean * IsRunoutGroupIn,
 GroupFeatureDef_1080_Type * GroupFeatureDef_1080In,
 UnitVectorType * LineDirectionIn,
 LinearValueType * IncrementalDistanceIn,
 UnitVectorType * FeatureDirectionIn,
 NaturalType * NumberOfFeaturesIn) :
  PatternFeatureDefinitionBaseType(
    idIn,
    AttributesIn,
    IsProfileGroupIn,
    IsRunoutGroupIn,
    GroupFeatureDef_1080In)
{
  LineDirection = LineDirectionIn;
  IncrementalDistance = IncrementalDistanceIn;
  FeatureDirection = FeatureDirectionIn;
  NumberOfFeatures = NumberOfFeaturesIn;
}

PatternFeatureLinearDefinitionType::~PatternFeatureLinearDefinitionType()
{
  #ifndef NODESTRUCT
  delete LineDirection;
  delete IncrementalDistance;
  delete FeatureDirection;
  delete NumberOfFeatures;
  #endif
}

void PatternFeatureLinearDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (IsProfileGroup)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IsProfileGroup");
      IsProfileGroup->printSelf(outFile);
      fprintf(outFile, "</IsProfileGroup>\n");
    }
  if (IsRunoutGroup)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IsRunoutGroup");
      IsRunoutGroup->printSelf(outFile);
      fprintf(outFile, "</IsRunoutGroup>\n");
    }
  if (GroupFeatureDef_1080)
    {
  GroupFeatureDef_1080->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<LineDirection");
  LineDirection->printSelf(outFile);
  fprintf(outFile, "</LineDirection>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<IncrementalDistance");
  IncrementalDistance->printSelf(outFile);
  fprintf(outFile, "</IncrementalDistance>\n");
  if (FeatureDirection)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureDirection");
      FeatureDirection->printSelf(outFile);
      fprintf(outFile, "</FeatureDirection>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<NumberOfFeatures");
  NumberOfFeatures->printSelf(outFile);
  fprintf(outFile, "</NumberOfFeatures>\n");
  doSpaces(-INDENT, outFile);
}

bool PatternFeatureLinearDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PatternFeatureLinearDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PatternFeatureLinearDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PatternFeatureLinearDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PatternFeatureLinearDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

UnitVectorType * PatternFeatureLinearDefinitionType::getLineDirection()
{return LineDirection;}

void PatternFeatureLinearDefinitionType::setLineDirection(UnitVectorType * LineDirectionIn)
{LineDirection = LineDirectionIn;}

LinearValueType * PatternFeatureLinearDefinitionType::getIncrementalDistance()
{return IncrementalDistance;}

void PatternFeatureLinearDefinitionType::setIncrementalDistance(LinearValueType * IncrementalDistanceIn)
{IncrementalDistance = IncrementalDistanceIn;}

UnitVectorType * PatternFeatureLinearDefinitionType::getFeatureDirection()
{return FeatureDirection;}

void PatternFeatureLinearDefinitionType::setFeatureDirection(UnitVectorType * FeatureDirectionIn)
{FeatureDirection = FeatureDirectionIn;}

NaturalType * PatternFeatureLinearDefinitionType::getNumberOfFeatures()
{return NumberOfFeatures;}

void PatternFeatureLinearDefinitionType::setNumberOfFeatures(NaturalType * NumberOfFeaturesIn)
{NumberOfFeatures = NumberOfFeaturesIn;}

/* ***************************************************************** */

/* class PatternFeatureLinearItemType

*/

PatternFeatureLinearItemType::PatternFeatureLinearItemType() :
  PatternFeatureItemBaseType()
{
}

PatternFeatureLinearItemType::PatternFeatureLinearItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  PatternFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
}

PatternFeatureLinearItemType::PatternFeatureLinearItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  PatternFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
}

PatternFeatureLinearItemType::~PatternFeatureLinearItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void PatternFeatureLinearItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool PatternFeatureLinearItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PatternFeatureLinearItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PatternFeatureLinearItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PatternFeatureLinearItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PatternFeatureLinearItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class PatternFeatureLinearNominalType

*/

PatternFeatureLinearNominalType::PatternFeatureLinearNominalType() :
  PatternFeatureNominalBaseType()
{
  FirstFeatureLocation = 0;
}

PatternFeatureLinearNominalType::PatternFeatureLinearNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 QIFReferenceType * FirstFeatureLocationIn) :
  PatternFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    FeatureNominalIdsIn)
{
  FirstFeatureLocation = FirstFeatureLocationIn;
}

PatternFeatureLinearNominalType::PatternFeatureLinearNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 QIFReferenceType * FirstFeatureLocationIn) :
  PatternFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    FeatureNominalIdsIn)
{
  FirstFeatureLocation = FirstFeatureLocationIn;
}

PatternFeatureLinearNominalType::~PatternFeatureLinearNominalType()
{
  #ifndef NODESTRUCT
  delete FirstFeatureLocation;
  #endif
}

void PatternFeatureLinearNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalIds");
  FeatureNominalIds->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</FeatureNominalIds>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<FirstFeatureLocation");
  FirstFeatureLocation->printSelf(outFile);
  fprintf(outFile, "</FirstFeatureLocation>\n");
  doSpaces(-INDENT, outFile);
}

bool PatternFeatureLinearNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PatternFeatureLinearNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PatternFeatureLinearNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PatternFeatureLinearNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PatternFeatureLinearNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

QIFReferenceType * PatternFeatureLinearNominalType::getFirstFeatureLocation()
{return FirstFeatureLocation;}

void PatternFeatureLinearNominalType::setFirstFeatureLocation(QIFReferenceType * FirstFeatureLocationIn)
{FirstFeatureLocation = FirstFeatureLocationIn;}

/* ***************************************************************** */

/* class PatternFeatureNominalBaseType

*/

PatternFeatureNominalBaseType::PatternFeatureNominalBaseType() :
  GroupFeatureNominalType()
{
}

PatternFeatureNominalBaseType::PatternFeatureNominalBaseType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureNominalIdsIn) :
  GroupFeatureNominalType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    FeatureNominalIdsIn)
{
}

PatternFeatureNominalBaseType::PatternFeatureNominalBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureNominalIdsIn) :
  GroupFeatureNominalType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    FeatureNominalIdsIn)
{
}

PatternFeatureNominalBaseType::~PatternFeatureNominalBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void PatternFeatureNominalBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalIds");
  FeatureNominalIds->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</FeatureNominalIds>\n");
  doSpaces(-INDENT, outFile);
}

bool PatternFeatureNominalBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PatternFeatureNominalBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PatternFeatureNominalBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PatternFeatureNominalBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PatternFeatureNominalBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class PatternFeatureParallelogramDefinitionType

*/

PatternFeatureParallelogramDefinitionType::PatternFeatureParallelogramDefinitionType() :
  PatternFeatureDefinitionBaseType()
{
  AlongRowDirection = 0;
  IncrementalRowDistance = 0;
  BetweenRowDirection = 0;
  RowSeparationDistance = 0;
  FeatureDirection = 0;
  NumberOfFeaturesPerRow = 0;
  NumberOfRows = 0;
}

PatternFeatureParallelogramDefinitionType::PatternFeatureParallelogramDefinitionType(
 AttributesType * AttributesIn,
 XmlBoolean * IsProfileGroupIn,
 XmlBoolean * IsRunoutGroupIn,
 GroupFeatureDef_1080_Type * GroupFeatureDef_1080In,
 VectorType * AlongRowDirectionIn,
 LinearValueType * IncrementalRowDistanceIn,
 VectorType * BetweenRowDirectionIn,
 LinearValueType * RowSeparationDistanceIn,
 UnitVectorType * FeatureDirectionIn,
 NaturalType * NumberOfFeaturesPerRowIn,
 NaturalType * NumberOfRowsIn) :
  PatternFeatureDefinitionBaseType(
    AttributesIn,
    IsProfileGroupIn,
    IsRunoutGroupIn,
    GroupFeatureDef_1080In)
{
  AlongRowDirection = AlongRowDirectionIn;
  IncrementalRowDistance = IncrementalRowDistanceIn;
  BetweenRowDirection = BetweenRowDirectionIn;
  RowSeparationDistance = RowSeparationDistanceIn;
  FeatureDirection = FeatureDirectionIn;
  NumberOfFeaturesPerRow = NumberOfFeaturesPerRowIn;
  NumberOfRows = NumberOfRowsIn;
}

PatternFeatureParallelogramDefinitionType::PatternFeatureParallelogramDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlBoolean * IsProfileGroupIn,
 XmlBoolean * IsRunoutGroupIn,
 GroupFeatureDef_1080_Type * GroupFeatureDef_1080In,
 VectorType * AlongRowDirectionIn,
 LinearValueType * IncrementalRowDistanceIn,
 VectorType * BetweenRowDirectionIn,
 LinearValueType * RowSeparationDistanceIn,
 UnitVectorType * FeatureDirectionIn,
 NaturalType * NumberOfFeaturesPerRowIn,
 NaturalType * NumberOfRowsIn) :
  PatternFeatureDefinitionBaseType(
    idIn,
    AttributesIn,
    IsProfileGroupIn,
    IsRunoutGroupIn,
    GroupFeatureDef_1080In)
{
  AlongRowDirection = AlongRowDirectionIn;
  IncrementalRowDistance = IncrementalRowDistanceIn;
  BetweenRowDirection = BetweenRowDirectionIn;
  RowSeparationDistance = RowSeparationDistanceIn;
  FeatureDirection = FeatureDirectionIn;
  NumberOfFeaturesPerRow = NumberOfFeaturesPerRowIn;
  NumberOfRows = NumberOfRowsIn;
}

PatternFeatureParallelogramDefinitionType::~PatternFeatureParallelogramDefinitionType()
{
  #ifndef NODESTRUCT
  delete AlongRowDirection;
  delete IncrementalRowDistance;
  delete BetweenRowDirection;
  delete RowSeparationDistance;
  delete FeatureDirection;
  delete NumberOfFeaturesPerRow;
  delete NumberOfRows;
  #endif
}

void PatternFeatureParallelogramDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (IsProfileGroup)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IsProfileGroup");
      IsProfileGroup->printSelf(outFile);
      fprintf(outFile, "</IsProfileGroup>\n");
    }
  if (IsRunoutGroup)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IsRunoutGroup");
      IsRunoutGroup->printSelf(outFile);
      fprintf(outFile, "</IsRunoutGroup>\n");
    }
  if (GroupFeatureDef_1080)
    {
  GroupFeatureDef_1080->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<AlongRowDirection");
  AlongRowDirection->printSelf(outFile);
  fprintf(outFile, "</AlongRowDirection>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<IncrementalRowDistance");
  IncrementalRowDistance->printSelf(outFile);
  fprintf(outFile, "</IncrementalRowDistance>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<BetweenRowDirection");
  BetweenRowDirection->printSelf(outFile);
  fprintf(outFile, "</BetweenRowDirection>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<RowSeparationDistance");
  RowSeparationDistance->printSelf(outFile);
  fprintf(outFile, "</RowSeparationDistance>\n");
  if (FeatureDirection)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureDirection");
      FeatureDirection->printSelf(outFile);
      fprintf(outFile, "</FeatureDirection>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<NumberOfFeaturesPerRow");
  NumberOfFeaturesPerRow->printSelf(outFile);
  fprintf(outFile, "</NumberOfFeaturesPerRow>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<NumberOfRows");
  NumberOfRows->printSelf(outFile);
  fprintf(outFile, "</NumberOfRows>\n");
  doSpaces(-INDENT, outFile);
}

bool PatternFeatureParallelogramDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PatternFeatureParallelogramDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PatternFeatureParallelogramDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PatternFeatureParallelogramDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PatternFeatureParallelogramDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

VectorType * PatternFeatureParallelogramDefinitionType::getAlongRowDirection()
{return AlongRowDirection;}

void PatternFeatureParallelogramDefinitionType::setAlongRowDirection(VectorType * AlongRowDirectionIn)
{AlongRowDirection = AlongRowDirectionIn;}

LinearValueType * PatternFeatureParallelogramDefinitionType::getIncrementalRowDistance()
{return IncrementalRowDistance;}

void PatternFeatureParallelogramDefinitionType::setIncrementalRowDistance(LinearValueType * IncrementalRowDistanceIn)
{IncrementalRowDistance = IncrementalRowDistanceIn;}

VectorType * PatternFeatureParallelogramDefinitionType::getBetweenRowDirection()
{return BetweenRowDirection;}

void PatternFeatureParallelogramDefinitionType::setBetweenRowDirection(VectorType * BetweenRowDirectionIn)
{BetweenRowDirection = BetweenRowDirectionIn;}

LinearValueType * PatternFeatureParallelogramDefinitionType::getRowSeparationDistance()
{return RowSeparationDistance;}

void PatternFeatureParallelogramDefinitionType::setRowSeparationDistance(LinearValueType * RowSeparationDistanceIn)
{RowSeparationDistance = RowSeparationDistanceIn;}

UnitVectorType * PatternFeatureParallelogramDefinitionType::getFeatureDirection()
{return FeatureDirection;}

void PatternFeatureParallelogramDefinitionType::setFeatureDirection(UnitVectorType * FeatureDirectionIn)
{FeatureDirection = FeatureDirectionIn;}

NaturalType * PatternFeatureParallelogramDefinitionType::getNumberOfFeaturesPerRow()
{return NumberOfFeaturesPerRow;}

void PatternFeatureParallelogramDefinitionType::setNumberOfFeaturesPerRow(NaturalType * NumberOfFeaturesPerRowIn)
{NumberOfFeaturesPerRow = NumberOfFeaturesPerRowIn;}

NaturalType * PatternFeatureParallelogramDefinitionType::getNumberOfRows()
{return NumberOfRows;}

void PatternFeatureParallelogramDefinitionType::setNumberOfRows(NaturalType * NumberOfRowsIn)
{NumberOfRows = NumberOfRowsIn;}

/* ***************************************************************** */

/* class PatternFeatureParallelogramItemType

*/

PatternFeatureParallelogramItemType::PatternFeatureParallelogramItemType() :
  PatternFeatureItemBaseType()
{
}

PatternFeatureParallelogramItemType::PatternFeatureParallelogramItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  PatternFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
}

PatternFeatureParallelogramItemType::PatternFeatureParallelogramItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  PatternFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
}

PatternFeatureParallelogramItemType::~PatternFeatureParallelogramItemType()
{
  #ifndef NODESTRUCT
  #endif
}

void PatternFeatureParallelogramItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool PatternFeatureParallelogramItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PatternFeatureParallelogramItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PatternFeatureParallelogramItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PatternFeatureParallelogramItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PatternFeatureParallelogramItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class PatternFeatureParallelogramNominalType

*/

PatternFeatureParallelogramNominalType::PatternFeatureParallelogramNominalType() :
  PatternFeatureNominalBaseType()
{
  FirstFeatureLocation = 0;
}

PatternFeatureParallelogramNominalType::PatternFeatureParallelogramNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 QIFReferenceType * FirstFeatureLocationIn) :
  PatternFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    FeatureNominalIdsIn)
{
  FirstFeatureLocation = FirstFeatureLocationIn;
}

PatternFeatureParallelogramNominalType::PatternFeatureParallelogramNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 ArrayReferenceFullType * FeatureNominalIdsIn,
 QIFReferenceType * FirstFeatureLocationIn) :
  PatternFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    FeatureNominalIdsIn)
{
  FirstFeatureLocation = FirstFeatureLocationIn;
}

PatternFeatureParallelogramNominalType::~PatternFeatureParallelogramNominalType()
{
  #ifndef NODESTRUCT
  delete FirstFeatureLocation;
  #endif
}

void PatternFeatureParallelogramNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalIds");
  FeatureNominalIds->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</FeatureNominalIds>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<FirstFeatureLocation");
  FirstFeatureLocation->printSelf(outFile);
  fprintf(outFile, "</FirstFeatureLocation>\n");
  doSpaces(-INDENT, outFile);
}

bool PatternFeatureParallelogramNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PatternFeatureParallelogramNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PatternFeatureParallelogramNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PatternFeatureParallelogramNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PatternFeatureParallelogramNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

QIFReferenceType * PatternFeatureParallelogramNominalType::getFirstFeatureLocation()
{return FirstFeatureLocation;}

void PatternFeatureParallelogramNominalType::setFirstFeatureLocation(QIFReferenceType * FirstFeatureLocationIn)
{FirstFeatureLocation = FirstFeatureLocationIn;}

/* ***************************************************************** */

/* class PlaneBestFitType

*/

PlaneBestFitType::PlaneBestFitType() :
  ConstructionMethodBaseType()
{
  n = 0;
  BaseFeature = 0;
}

PlaneBestFitType::PlaneBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = 0;
  BaseFeature = BaseFeatureIn;
}

PlaneBestFitType::PlaneBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 NaturalType * nIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = nIn;
  BaseFeature = BaseFeatureIn;
}

PlaneBestFitType::~PlaneBestFitType()
{
  #ifndef NODESTRUCT
  delete n;
  delete BaseFeature;
  #endif
}

void PlaneBestFitType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  {
    if (!BaseFeature)
      {
        fprintf(stderr, "BaseFeature list is missing\n");
        exit(1);
      }
    if (BaseFeature->size() == 0)
      {
        fprintf(stderr, "BaseFeature list is empty\n");
        exit(1);
      }
    if (BaseFeature->size() < 3)
      {
        fprintf(stderr,
                "size of BaseFeature list (%d) less than minimum required (3)\n",
                (int)BaseFeature->size());
        exit(1);
      }
    std::list<SequencedBaseFeatureType *>::iterator iter;
    for (iter = BaseFeature->begin();
         iter != BaseFeature->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<BaseFeature");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</BaseFeature>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool PlaneBestFitType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in PlaneBestFitType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in PlaneBestFitType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PlaneBestFitType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in PlaneBestFitType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * PlaneBestFitType::getn()
{return n;}

void PlaneBestFitType::setn(NaturalType * nIn)
{n = nIn;}

SequencedBaseFeatureTypeLisd * PlaneBestFitType::getBaseFeature()
{return BaseFeature;}

void PlaneBestFitType::setBaseFeature(SequencedBaseFeatureTypeLisd * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class PlaneCastType

*/

PlaneCastType::PlaneCastType() :
  ConstructionMethodBaseType()
{
  BaseFeature = 0;
}

PlaneCastType::PlaneCastType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeature = BaseFeatureIn;
}

PlaneCastType::~PlaneCastType()
{
  #ifndef NODESTRUCT
  delete BaseFeature;
  #endif
}

void PlaneCastType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeature");
  BaseFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * PlaneCastType::getBaseFeature()
{return BaseFeature;}

void PlaneCastType::setBaseFeature(BaseFeatureType * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class PlaneCheckedFeatureType

*/

PlaneCheckedFeatureType::PlaneCheckedFeatureType()
{
  CheckDetails = 0;
}

PlaneCheckedFeatureType::PlaneCheckedFeatureType(
 PlaneCheckedType * CheckDetailsIn)
{
  CheckDetails = CheckDetailsIn;
}

PlaneCheckedFeatureType::~PlaneCheckedFeatureType()
{
  #ifndef NODESTRUCT
  delete CheckDetails;
  #endif
}

void PlaneCheckedFeatureType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (CheckDetails)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CheckDetails");
      CheckDetails->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CheckDetails>\n");
    }
  doSpaces(-INDENT, outFile);
}

PlaneCheckedType * PlaneCheckedFeatureType::getCheckDetails()
{return CheckDetails;}

void PlaneCheckedFeatureType::setCheckDetails(PlaneCheckedType * CheckDetailsIn)
{CheckDetails = CheckDetailsIn;}

/* ***************************************************************** */

/* class PlaneCheckedType

*/

PlaneCheckedType::PlaneCheckedType()
{
  PlaneCheckedTypePair = 0;
}

PlaneCheckedType::PlaneCheckedType(
 PlaneCheckedTypeChoicePair * PlaneCheckedTypePairIn)
{
  PlaneCheckedTypePair = PlaneCheckedTypePairIn;
}

PlaneCheckedType::~PlaneCheckedType()
{
  #ifndef NODESTRUCT
  delete PlaneCheckedTypePair;
  #endif
}

void PlaneCheckedType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  PlaneCheckedTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

PlaneCheckedTypeChoicePair * PlaneCheckedType::getPlaneCheckedTypePair()
{return PlaneCheckedTypePair;}

void PlaneCheckedType::setPlaneCheckedTypePair(PlaneCheckedTypeChoicePair * PlaneCheckedTypePairIn)
{PlaneCheckedTypePair = PlaneCheckedTypePairIn;}
PlaneCheckedTypeChoicePair::PlaneCheckedTypeChoicePair() {}

PlaneCheckedTypeChoicePair::PlaneCheckedTypeChoicePair(
 whichOne PlaneCheckedTypeTypeIn,
 PlaneCheckedTypeVal * PlaneCheckedTypeValueIn)
{
  PlaneCheckedTypeType = PlaneCheckedTypeTypeIn;
  PlaneCheckedTypeValue = PlaneCheckedTypeValueIn;
}

PlaneCheckedTypeChoicePair::~PlaneCheckedTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (PlaneCheckedTypeType == MeasuredE)
    delete PlaneCheckedTypeValue->Measured;
  else if (PlaneCheckedTypeType == ConstructedE)
    delete PlaneCheckedTypeValue->Constructed;
  delete PlaneCheckedTypeValue;
  #endif
}

void PlaneCheckedTypeChoicePair::printSelf(FILE * outFile)
{
  if (PlaneCheckedTypeType == MeasuredE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Measured");
      PlaneCheckedTypeValue->Measured->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Measured>\n");
    }
  else if (PlaneCheckedTypeType == ConstructedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      PlaneCheckedTypeValue->Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
}

/* ***************************************************************** */

/* class PlaneConstructionMethodType

*/

PlaneConstructionMethodType::PlaneConstructionMethodType()
{
  PlaneConstructionMethodTypePair = 0;
}

PlaneConstructionMethodType::PlaneConstructionMethodType(
 PlaneConstructionMethodTypeChoicePair * PlaneConstructionMethodTypePairIn)
{
  PlaneConstructionMethodTypePair = PlaneConstructionMethodTypePairIn;
}

PlaneConstructionMethodType::~PlaneConstructionMethodType()
{
  #ifndef NODESTRUCT
  delete PlaneConstructionMethodTypePair;
  #endif
}

void PlaneConstructionMethodType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (PlaneConstructionMethodTypePair)
    {
      PlaneConstructionMethodTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

PlaneConstructionMethodTypeChoicePair * PlaneConstructionMethodType::getPlaneConstructionMethodTypePair()
{return PlaneConstructionMethodTypePair;}

void PlaneConstructionMethodType::setPlaneConstructionMethodTypePair(PlaneConstructionMethodTypeChoicePair * PlaneConstructionMethodTypePairIn)
{PlaneConstructionMethodTypePair = PlaneConstructionMethodTypePairIn;}
PlaneConstructionMethodTypeChoicePair::PlaneConstructionMethodTypeChoicePair() {}

PlaneConstructionMethodTypeChoicePair::PlaneConstructionMethodTypeChoicePair(
 whichOne PlaneConstructionMethodTypeTypeIn,
 PlaneConstructionMethodTypeVal * PlaneConstructionMethodTypeValueIn)
{
  PlaneConstructionMethodTypeType = PlaneConstructionMethodTypeTypeIn;
  PlaneConstructionMethodTypeValue = PlaneConstructionMethodTypeValueIn;
}

PlaneConstructionMethodTypeChoicePair::~PlaneConstructionMethodTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (PlaneConstructionMethodTypeType == BestFitE)
    delete PlaneConstructionMethodTypeValue->BestFit;
  else if (PlaneConstructionMethodTypeType == RecompensatedE)
    delete PlaneConstructionMethodTypeValue->Recompensated;
  else if (PlaneConstructionMethodTypeType == MidplaneE)
    delete PlaneConstructionMethodTypeValue->Midplane;
  else if (PlaneConstructionMethodTypeType == OffsetE)
    delete PlaneConstructionMethodTypeValue->Offset;
  else if (PlaneConstructionMethodTypeType == PerpendicularE)
    delete PlaneConstructionMethodTypeValue->Perpendicular;
  else if (PlaneConstructionMethodTypeType == ParallelE)
    delete PlaneConstructionMethodTypeValue->Parallel;
  else if (PlaneConstructionMethodTypeType == CopyE)
    delete PlaneConstructionMethodTypeValue->Copy;
  else if (PlaneConstructionMethodTypeType == CastE)
    delete PlaneConstructionMethodTypeValue->Cast;
  else if (PlaneConstructionMethodTypeType == TangentThroughE)
    delete PlaneConstructionMethodTypeValue->TangentThrough;
  else if (PlaneConstructionMethodTypeType == ThroughE)
    delete PlaneConstructionMethodTypeValue->Through;
  else if (PlaneConstructionMethodTypeType == TransformE)
    delete PlaneConstructionMethodTypeValue->Transform;
  else if (PlaneConstructionMethodTypeType == ExtractE)
    delete PlaneConstructionMethodTypeValue->Extract;
  delete PlaneConstructionMethodTypeValue;
  #endif
}

void PlaneConstructionMethodTypeChoicePair::printSelf(FILE * outFile)
{
  if (PlaneConstructionMethodTypeType == BestFitE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BestFit");
      PlaneConstructionMethodTypeValue->BestFit->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BestFit>\n");
    }
  else if (PlaneConstructionMethodTypeType == RecompensatedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Recompensated");
      PlaneConstructionMethodTypeValue->Recompensated->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Recompensated>\n");
    }
  else if (PlaneConstructionMethodTypeType == MidplaneE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Midplane");
      PlaneConstructionMethodTypeValue->Midplane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Midplane>\n");
    }
  else if (PlaneConstructionMethodTypeType == OffsetE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Offset");
      PlaneConstructionMethodTypeValue->Offset->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Offset>\n");
    }
  else if (PlaneConstructionMethodTypeType == PerpendicularE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Perpendicular");
      PlaneConstructionMethodTypeValue->Perpendicular->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Perpendicular>\n");
    }
  else if (PlaneConstructionMethodTypeType == ParallelE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Parallel");
      PlaneConstructionMethodTypeValue->Parallel->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Parallel>\n");
    }
  else if (PlaneConstructionMethodTypeType == CopyE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Copy");
      PlaneConstructionMethodTypeValue->Copy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Copy>\n");
    }
  else if (PlaneConstructionMethodTypeType == CastE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Cast");
      PlaneConstructionMethodTypeValue->Cast->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Cast>\n");
    }
  else if (PlaneConstructionMethodTypeType == TangentThroughE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TangentThrough");
      PlaneConstructionMethodTypeValue->TangentThrough->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</TangentThrough>\n");
    }
  else if (PlaneConstructionMethodTypeType == ThroughE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Through");
      PlaneConstructionMethodTypeValue->Through->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Through>\n");
    }
  else if (PlaneConstructionMethodTypeType == TransformE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Transform");
      PlaneConstructionMethodTypeValue->Transform->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Transform>\n");
    }
  else if (PlaneConstructionMethodTypeType == ExtractE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Extract");
      PlaneConstructionMethodTypeValue->Extract->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Extract>\n");
    }
}

/* ***************************************************************** */

/* class PlaneCopyType

*/

PlaneCopyType::PlaneCopyType() :
  ConstructionMethodBaseType()
{
  BasePlane = 0;
}

PlaneCopyType::PlaneCopyType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BasePlaneIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BasePlane = BasePlaneIn;
}

PlaneCopyType::~PlaneCopyType()
{
  #ifndef NODESTRUCT
  delete BasePlane;
  #endif
}

void PlaneCopyType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BasePlane");
  BasePlane->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BasePlane>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * PlaneCopyType::getBasePlane()
{return BasePlane;}

void PlaneCopyType::setBasePlane(BaseFeatureType * BasePlaneIn)
{BasePlane = BasePlaneIn;}

/* ***************************************************************** */

/* class PlaneExtractType

*/

PlaneExtractType::PlaneExtractType() :
  ConstructionMethodBaseType()
{
  SurfaceFeature = 0;
}

PlaneExtractType::PlaneExtractType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * SurfaceFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  SurfaceFeature = SurfaceFeatureIn;
}

PlaneExtractType::~PlaneExtractType()
{
  #ifndef NODESTRUCT
  delete SurfaceFeature;
  #endif
}

void PlaneExtractType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<SurfaceFeature");
  SurfaceFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</SurfaceFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * PlaneExtractType::getSurfaceFeature()
{return SurfaceFeature;}

void PlaneExtractType::setSurfaceFeature(BaseFeatureType * SurfaceFeatureIn)
{SurfaceFeature = SurfaceFeatureIn;}

/* ***************************************************************** */

/* class PlaneFeatureDefinitionType

*/

PlaneFeatureDefinitionType::PlaneFeatureDefinitionType() :
  SurfaceFeatureDefinitionBaseType()
{
}

PlaneFeatureDefinitionType::PlaneFeatureDefinitionType(
 AttributesType * AttributesIn) :
  SurfaceFeatureDefinitionBaseType(
    AttributesIn)
{
}

PlaneFeatureDefinitionType::PlaneFeatureDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn) :
  SurfaceFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
}

PlaneFeatureDefinitionType::~PlaneFeatureDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void PlaneFeatureDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool PlaneFeatureDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PlaneFeatureDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PlaneFeatureDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PlaneFeatureDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PlaneFeatureDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class PlaneFeatureItemType

*/

PlaneFeatureItemType::PlaneFeatureItemType() :
  SurfaceFeatureItemBaseType()
{
  DeterminationMode = 0;
}

PlaneFeatureItemType::PlaneFeatureItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 PlaneMeasurementDeterminationType * DeterminationModeIn) :
  SurfaceFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

PlaneFeatureItemType::PlaneFeatureItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 PlaneMeasurementDeterminationType * DeterminationModeIn) :
  SurfaceFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

PlaneFeatureItemType::~PlaneFeatureItemType()
{
  #ifndef NODESTRUCT
  delete DeterminationMode;
  #endif
}

void PlaneFeatureItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<DeterminationMode");
  DeterminationMode->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeterminationMode>\n");
  doSpaces(-INDENT, outFile);
}

bool PlaneFeatureItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PlaneFeatureItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PlaneFeatureItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PlaneFeatureItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PlaneFeatureItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

PlaneMeasurementDeterminationType * PlaneFeatureItemType::getDeterminationMode()
{return DeterminationMode;}

void PlaneFeatureItemType::setDeterminationMode(PlaneMeasurementDeterminationType * DeterminationModeIn)
{DeterminationMode = DeterminationModeIn;}

/* ***************************************************************** */

/* class PlaneFeatureMeasurementType

*/

PlaneFeatureMeasurementType::PlaneFeatureMeasurementType() :
  SurfaceFeatureMeasurementBaseType()
{
  Location = 0;
  Normal = 0;
  PolyLine = 0;
  Form = 0;
}

PlaneFeatureMeasurementType::PlaneFeatureMeasurementType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredPointType * LocationIn,
 MeasuredUnitVectorType * NormalIn,
 PolyLineType * PolyLineIn,
 MeasuredLinearValueType * FormIn) :
  SurfaceFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Location = LocationIn;
  Normal = NormalIn;
  PolyLine = PolyLineIn;
  Form = FormIn;
}

PlaneFeatureMeasurementType::PlaneFeatureMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredPointType * LocationIn,
 MeasuredUnitVectorType * NormalIn,
 PolyLineType * PolyLineIn,
 MeasuredLinearValueType * FormIn) :
  SurfaceFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Location = LocationIn;
  Normal = NormalIn;
  PolyLine = PolyLineIn;
  Form = FormIn;
}

PlaneFeatureMeasurementType::~PlaneFeatureMeasurementType()
{
  #ifndef NODESTRUCT
  delete Location;
  delete Normal;
  delete PolyLine;
  delete Form;
  #endif
}

void PlaneFeatureMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  if (Location)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Location");
      Location->printSelf(outFile);
      fprintf(outFile, "</Location>\n");
    }
  if (Normal)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Normal");
      Normal->printSelf(outFile);
      fprintf(outFile, "</Normal>\n");
    }
  if (PolyLine)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PolyLine");
      PolyLine->printSelf(outFile);
      fprintf(outFile, "</PolyLine>\n");
    }
  if (Form)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Form");
      Form->printSelf(outFile);
      fprintf(outFile, "</Form>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool PlaneFeatureMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PlaneFeatureMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PlaneFeatureMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PlaneFeatureMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PlaneFeatureMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredPointType * PlaneFeatureMeasurementType::getLocation()
{return Location;}

void PlaneFeatureMeasurementType::setLocation(MeasuredPointType * LocationIn)
{Location = LocationIn;}

MeasuredUnitVectorType * PlaneFeatureMeasurementType::getNormal()
{return Normal;}

void PlaneFeatureMeasurementType::setNormal(MeasuredUnitVectorType * NormalIn)
{Normal = NormalIn;}

PolyLineType * PlaneFeatureMeasurementType::getPolyLine()
{return PolyLine;}

void PlaneFeatureMeasurementType::setPolyLine(PolyLineType * PolyLineIn)
{PolyLine = PolyLineIn;}

MeasuredLinearValueType * PlaneFeatureMeasurementType::getForm()
{return Form;}

void PlaneFeatureMeasurementType::setForm(MeasuredLinearValueType * FormIn)
{Form = FormIn;}

/* ***************************************************************** */

/* class PlaneFeatureNominalType

*/

PlaneFeatureNominalType::PlaneFeatureNominalType() :
  SurfaceFeatureNominalBaseType()
{
  Location = 0;
  Normal = 0;
  PlaneFeatureNom_1096 = 0;
  Constructed = 0;
}

PlaneFeatureNominalType::PlaneFeatureNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 PointType * LocationIn,
 UnitVectorType * NormalIn,
 PlaneFeatureNom_1096_Type * PlaneFeatureNom_1096In,
 PlaneConstructionMethodType * ConstructedIn) :
  SurfaceFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  Location = LocationIn;
  Normal = NormalIn;
  PlaneFeatureNom_1096 = PlaneFeatureNom_1096In;
  Constructed = ConstructedIn;
}

PlaneFeatureNominalType::PlaneFeatureNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 PointType * LocationIn,
 UnitVectorType * NormalIn,
 PlaneFeatureNom_1096_Type * PlaneFeatureNom_1096In,
 PlaneConstructionMethodType * ConstructedIn) :
  SurfaceFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  Location = LocationIn;
  Normal = NormalIn;
  PlaneFeatureNom_1096 = PlaneFeatureNom_1096In;
  Constructed = ConstructedIn;
}

PlaneFeatureNominalType::~PlaneFeatureNominalType()
{
  #ifndef NODESTRUCT
  delete Location;
  delete Normal;
  delete PlaneFeatureNom_1096;
  delete Constructed;
  #endif
}

void PlaneFeatureNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Location");
  Location->printSelf(outFile);
  fprintf(outFile, "</Location>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Normal");
  Normal->printSelf(outFile);
  fprintf(outFile, "</Normal>\n");
  if (PlaneFeatureNom_1096)
    {
  PlaneFeatureNom_1096->printSelf(outFile);
    }
  if (Constructed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool PlaneFeatureNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PlaneFeatureNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PlaneFeatureNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PlaneFeatureNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PlaneFeatureNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

PointType * PlaneFeatureNominalType::getLocation()
{return Location;}

void PlaneFeatureNominalType::setLocation(PointType * LocationIn)
{Location = LocationIn;}

UnitVectorType * PlaneFeatureNominalType::getNormal()
{return Normal;}

void PlaneFeatureNominalType::setNormal(UnitVectorType * NormalIn)
{Normal = NormalIn;}

PlaneFeatureNom_1096_Type * PlaneFeatureNominalType::getPlaneFeatureNom_1096()
{return PlaneFeatureNom_1096;}

void PlaneFeatureNominalType::setPlaneFeatureNom_1096(PlaneFeatureNom_1096_Type * PlaneFeatureNom_1096In)
{PlaneFeatureNom_1096 = PlaneFeatureNom_1096In;}

PlaneConstructionMethodType * PlaneFeatureNominalType::getConstructed()
{return Constructed;}

void PlaneFeatureNominalType::setConstructed(PlaneConstructionMethodType * ConstructedIn)
{Constructed = ConstructedIn;}

/* ***************************************************************** */

/* class PlaneMeasurementDeterminationType

*/

PlaneMeasurementDeterminationType::PlaneMeasurementDeterminationType()
{
  PlaneMeasurementDeterminationTypePair = 0;
}

PlaneMeasurementDeterminationType::PlaneMeasurementDeterminationType(
 PlaneMeasurementDeterminationTypeChoicePair * PlaneMeasurementDeterminationTypePairIn)
{
  PlaneMeasurementDeterminationTypePair = PlaneMeasurementDeterminationTypePairIn;
}

PlaneMeasurementDeterminationType::~PlaneMeasurementDeterminationType()
{
  #ifndef NODESTRUCT
  delete PlaneMeasurementDeterminationTypePair;
  #endif
}

void PlaneMeasurementDeterminationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  PlaneMeasurementDeterminationTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

PlaneMeasurementDeterminationTypeChoicePair * PlaneMeasurementDeterminationType::getPlaneMeasurementDeterminationTypePair()
{return PlaneMeasurementDeterminationTypePair;}

void PlaneMeasurementDeterminationType::setPlaneMeasurementDeterminationTypePair(PlaneMeasurementDeterminationTypeChoicePair * PlaneMeasurementDeterminationTypePairIn)
{PlaneMeasurementDeterminationTypePair = PlaneMeasurementDeterminationTypePairIn;}
PlaneMeasurementDeterminationTypeChoicePair::PlaneMeasurementDeterminationTypeChoicePair() {}

PlaneMeasurementDeterminationTypeChoicePair::PlaneMeasurementDeterminationTypeChoicePair(
 whichOne PlaneMeasurementDeterminationTypeTypeIn,
 PlaneMeasurementDeterminationTypeVal * PlaneMeasurementDeterminationTypeValueIn)
{
  PlaneMeasurementDeterminationTypeType = PlaneMeasurementDeterminationTypeTypeIn;
  PlaneMeasurementDeterminationTypeValue = PlaneMeasurementDeterminationTypeValueIn;
}

PlaneMeasurementDeterminationTypeChoicePair::~PlaneMeasurementDeterminationTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (PlaneMeasurementDeterminationTypeType == CheckedE)
    delete PlaneMeasurementDeterminationTypeValue->Checked;
  else if (PlaneMeasurementDeterminationTypeType == SetE)
    delete PlaneMeasurementDeterminationTypeValue->Set;
  delete PlaneMeasurementDeterminationTypeValue;
  #endif
}

void PlaneMeasurementDeterminationTypeChoicePair::printSelf(FILE * outFile)
{
  if (PlaneMeasurementDeterminationTypeType == CheckedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Checked");
      PlaneMeasurementDeterminationTypeValue->Checked->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Checked>\n");
    }
  else if (PlaneMeasurementDeterminationTypeType == SetE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Set");
      PlaneMeasurementDeterminationTypeValue->Set->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class PlaneMidplaneType

*/

PlaneMidplaneType::PlaneMidplaneType() :
  ConstructionMethodBaseType()
{
  BasePlane = 0;
}

PlaneMidplaneType::PlaneMidplaneType(
 XmlBoolean * NominalsCalculatedIn,
 SequencedBaseFeatureTypeLisd * BasePlaneIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BasePlane = BasePlaneIn;
}

PlaneMidplaneType::~PlaneMidplaneType()
{
  #ifndef NODESTRUCT
  delete BasePlane;
  #endif
}

void PlaneMidplaneType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  {
    if (!BasePlane)
      {
        fprintf(stderr, "BasePlane list is missing\n");
        exit(1);
      }
    if (BasePlane->size() == 0)
      {
        fprintf(stderr, "BasePlane list is empty\n");
        exit(1);
      }
    if (BasePlane->size() > 2)
      {
        fprintf(stderr,
                "size of BasePlane list (%d) greater than maximum allowed (2)\n",
                (int)BasePlane->size());
        exit(1);
      }
    if (BasePlane->size() < 2)
      {
        fprintf(stderr,
                "size of BasePlane list (%d) less than minimum required (2)\n",
                (int)BasePlane->size());
        exit(1);
      }
    std::list<SequencedBaseFeatureType *>::iterator iter;
    for (iter = BasePlane->begin();
         iter != BasePlane->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<BasePlane");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</BasePlane>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

SequencedBaseFeatureTypeLisd * PlaneMidplaneType::getBasePlane()
{return BasePlane;}

void PlaneMidplaneType::setBasePlane(SequencedBaseFeatureTypeLisd * BasePlaneIn)
{BasePlane = BasePlaneIn;}

/* ***************************************************************** */

/* class PlaneOffsetType

*/

PlaneOffsetType::PlaneOffsetType() :
  ConstructionMethodBaseType()
{
  BasePlane = 0;
  Offset = 0;
}

PlaneOffsetType::PlaneOffsetType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BasePlaneIn,
 LinearValueType * OffsetIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BasePlane = BasePlaneIn;
  Offset = OffsetIn;
}

PlaneOffsetType::~PlaneOffsetType()
{
  #ifndef NODESTRUCT
  delete BasePlane;
  delete Offset;
  #endif
}

void PlaneOffsetType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BasePlane");
  BasePlane->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BasePlane>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Offset");
  Offset->printSelf(outFile);
  fprintf(outFile, "</Offset>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * PlaneOffsetType::getBasePlane()
{return BasePlane;}

void PlaneOffsetType::setBasePlane(BaseFeatureType * BasePlaneIn)
{BasePlane = BasePlaneIn;}

LinearValueType * PlaneOffsetType::getOffset()
{return Offset;}

void PlaneOffsetType::setOffset(LinearValueType * OffsetIn)
{Offset = OffsetIn;}

/* ***************************************************************** */

/* class PlaneParallelType

*/

PlaneParallelType::PlaneParallelType() :
  ConstructionMethodBaseType()
{
  ParallelFeature = 0;
  PointFeature = 0;
}

PlaneParallelType::PlaneParallelType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * ParallelFeatureIn,
 BaseFeatureType * PointFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  ParallelFeature = ParallelFeatureIn;
  PointFeature = PointFeatureIn;
}

PlaneParallelType::~PlaneParallelType()
{
  #ifndef NODESTRUCT
  delete ParallelFeature;
  delete PointFeature;
  #endif
}

void PlaneParallelType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ParallelFeature");
  ParallelFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ParallelFeature>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<PointFeature");
  PointFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</PointFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * PlaneParallelType::getParallelFeature()
{return ParallelFeature;}

void PlaneParallelType::setParallelFeature(BaseFeatureType * ParallelFeatureIn)
{ParallelFeature = ParallelFeatureIn;}

BaseFeatureType * PlaneParallelType::getPointFeature()
{return PointFeature;}

void PlaneParallelType::setPointFeature(BaseFeatureType * PointFeatureIn)
{PointFeature = PointFeatureIn;}

/* ***************************************************************** */

/* class PlanePerpendicularType

*/

PlanePerpendicularType::PlanePerpendicularType() :
  ConstructionMethodBaseType()
{
  PerpendicularFeature = 0;
  PointFeature = 0;
}

PlanePerpendicularType::PlanePerpendicularType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * PerpendicularFeatureIn,
 BaseFeatureType * PointFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  PerpendicularFeature = PerpendicularFeatureIn;
  PointFeature = PointFeatureIn;
}

PlanePerpendicularType::~PlanePerpendicularType()
{
  #ifndef NODESTRUCT
  delete PerpendicularFeature;
  delete PointFeature;
  #endif
}

void PlanePerpendicularType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<PerpendicularFeature");
  PerpendicularFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</PerpendicularFeature>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<PointFeature");
  PointFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</PointFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * PlanePerpendicularType::getPerpendicularFeature()
{return PerpendicularFeature;}

void PlanePerpendicularType::setPerpendicularFeature(BaseFeatureType * PerpendicularFeatureIn)
{PerpendicularFeature = PerpendicularFeatureIn;}

BaseFeatureType * PlanePerpendicularType::getPointFeature()
{return PointFeature;}

void PlanePerpendicularType::setPointFeature(BaseFeatureType * PointFeatureIn)
{PointFeature = PointFeatureIn;}

/* ***************************************************************** */

/* class PlaneRecompType

*/

PlaneRecompType::PlaneRecompType() :
  ConstructionMethodBaseType()
{
  BaseFeaturePointList = 0;
}

PlaneRecompType::PlaneRecompType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeaturePointListType * BaseFeaturePointListIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeaturePointList = BaseFeaturePointListIn;
}

PlaneRecompType::~PlaneRecompType()
{
  #ifndef NODESTRUCT
  delete BaseFeaturePointList;
  #endif
}

void PlaneRecompType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeaturePointList");
  BaseFeaturePointList->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeaturePointList>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeaturePointListType * PlaneRecompType::getBaseFeaturePointList()
{return BaseFeaturePointList;}

void PlaneRecompType::setBaseFeaturePointList(BaseFeaturePointListType * BaseFeaturePointListIn)
{BaseFeaturePointList = BaseFeaturePointListIn;}

/* ***************************************************************** */

/* class PlaneTangentThroughType

*/

PlaneTangentThroughType::PlaneTangentThroughType() :
  ConstructionMethodBaseType()
{
  TangentFeature = 0;
  PointFeature = 0;
}

PlaneTangentThroughType::PlaneTangentThroughType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * TangentFeatureIn,
 BaseFeatureType * PointFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  TangentFeature = TangentFeatureIn;
  PointFeature = PointFeatureIn;
}

PlaneTangentThroughType::~PlaneTangentThroughType()
{
  #ifndef NODESTRUCT
  delete TangentFeature;
  delete PointFeature;
  #endif
}

void PlaneTangentThroughType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<TangentFeature");
  TangentFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</TangentFeature>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<PointFeature");
  PointFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</PointFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * PlaneTangentThroughType::getTangentFeature()
{return TangentFeature;}

void PlaneTangentThroughType::setTangentFeature(BaseFeatureType * TangentFeatureIn)
{TangentFeature = TangentFeatureIn;}

BaseFeatureType * PlaneTangentThroughType::getPointFeature()
{return PointFeature;}

void PlaneTangentThroughType::setPointFeature(BaseFeatureType * PointFeatureIn)
{PointFeature = PointFeatureIn;}

/* ***************************************************************** */

/* class PlaneThroughType

*/

PlaneThroughType::PlaneThroughType() :
  ConstructionMethodBaseType()
{
  BaseFeature = 0;
}

PlaneThroughType::PlaneThroughType(
 XmlBoolean * NominalsCalculatedIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeature = BaseFeatureIn;
}

PlaneThroughType::~PlaneThroughType()
{
  #ifndef NODESTRUCT
  delete BaseFeature;
  #endif
}

void PlaneThroughType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  {
    if (!BaseFeature)
      {
        fprintf(stderr, "BaseFeature list is missing\n");
        exit(1);
      }
    if (BaseFeature->size() == 0)
      {
        fprintf(stderr, "BaseFeature list is empty\n");
        exit(1);
      }
    if (BaseFeature->size() > 2)
      {
        fprintf(stderr,
                "size of BaseFeature list (%d) greater than maximum allowed (2)\n",
                (int)BaseFeature->size());
        exit(1);
      }
    if (BaseFeature->size() < 2)
      {
        fprintf(stderr,
                "size of BaseFeature list (%d) less than minimum required (2)\n",
                (int)BaseFeature->size());
        exit(1);
      }
    std::list<SequencedBaseFeatureType *>::iterator iter;
    for (iter = BaseFeature->begin();
         iter != BaseFeature->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<BaseFeature");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</BaseFeature>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

SequencedBaseFeatureTypeLisd * PlaneThroughType::getBaseFeature()
{return BaseFeature;}

void PlaneThroughType::setBaseFeature(SequencedBaseFeatureTypeLisd * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class PlaneTransformType

*/

PlaneTransformType::PlaneTransformType() :
  ConstructionMethodBaseType()
{
  BasePlane = 0;
  Transformation = 0;
}

PlaneTransformType::PlaneTransformType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BasePlaneIn,
 TransformationReferenceType * TransformationIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BasePlane = BasePlaneIn;
  Transformation = TransformationIn;
}

PlaneTransformType::~PlaneTransformType()
{
  #ifndef NODESTRUCT
  delete BasePlane;
  delete Transformation;
  #endif
}

void PlaneTransformType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BasePlane");
  BasePlane->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BasePlane>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Transformation");
  Transformation->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Transformation>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * PlaneTransformType::getBasePlane()
{return BasePlane;}

void PlaneTransformType::setBasePlane(BaseFeatureType * BasePlaneIn)
{BasePlane = BasePlaneIn;}

TransformationReferenceType * PlaneTransformType::getTransformation()
{return Transformation;}

void PlaneTransformType::setTransformation(TransformationReferenceType * TransformationIn)
{Transformation = TransformationIn;}

/* ***************************************************************** */

/* class PointCheckedFeatureType

*/

PointCheckedFeatureType::PointCheckedFeatureType()
{
  CheckDetails = 0;
}

PointCheckedFeatureType::PointCheckedFeatureType(
 PointCheckedType * CheckDetailsIn)
{
  CheckDetails = CheckDetailsIn;
}

PointCheckedFeatureType::~PointCheckedFeatureType()
{
  #ifndef NODESTRUCT
  delete CheckDetails;
  #endif
}

void PointCheckedFeatureType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (CheckDetails)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CheckDetails");
      CheckDetails->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CheckDetails>\n");
    }
  doSpaces(-INDENT, outFile);
}

PointCheckedType * PointCheckedFeatureType::getCheckDetails()
{return CheckDetails;}

void PointCheckedFeatureType::setCheckDetails(PointCheckedType * CheckDetailsIn)
{CheckDetails = CheckDetailsIn;}

/* ***************************************************************** */

/* class PointCheckedType

*/

PointCheckedType::PointCheckedType()
{
  PointCheckedTypePair = 0;
}

PointCheckedType::PointCheckedType(
 PointCheckedTypeChoicePair * PointCheckedTypePairIn)
{
  PointCheckedTypePair = PointCheckedTypePairIn;
}

PointCheckedType::~PointCheckedType()
{
  #ifndef NODESTRUCT
  delete PointCheckedTypePair;
  #endif
}

void PointCheckedType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  PointCheckedTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

PointCheckedTypeChoicePair * PointCheckedType::getPointCheckedTypePair()
{return PointCheckedTypePair;}

void PointCheckedType::setPointCheckedTypePair(PointCheckedTypeChoicePair * PointCheckedTypePairIn)
{PointCheckedTypePair = PointCheckedTypePairIn;}
PointCheckedTypeChoicePair::PointCheckedTypeChoicePair() {}

PointCheckedTypeChoicePair::PointCheckedTypeChoicePair(
 whichOne PointCheckedTypeTypeIn,
 PointCheckedTypeVal * PointCheckedTypeValueIn)
{
  PointCheckedTypeType = PointCheckedTypeTypeIn;
  PointCheckedTypeValue = PointCheckedTypeValueIn;
}

PointCheckedTypeChoicePair::~PointCheckedTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (PointCheckedTypeType == MeasuredE)
    delete PointCheckedTypeValue->Measured;
  else if (PointCheckedTypeType == ConstructedE)
    delete PointCheckedTypeValue->Constructed;
  delete PointCheckedTypeValue;
  #endif
}

void PointCheckedTypeChoicePair::printSelf(FILE * outFile)
{
  if (PointCheckedTypeType == MeasuredE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Measured");
      PointCheckedTypeValue->Measured->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Measured>\n");
    }
  else if (PointCheckedTypeType == ConstructedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      PointCheckedTypeValue->Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
}

/* ***************************************************************** */

/* class PointConstructionMethodType

*/

PointConstructionMethodType::PointConstructionMethodType()
{
  PointConstructionMethodTypePair = 0;
}

PointConstructionMethodType::PointConstructionMethodType(
 PointConstructionMethodTypeChoicePair * PointConstructionMethodTypePairIn)
{
  PointConstructionMethodTypePair = PointConstructionMethodTypePairIn;
}

PointConstructionMethodType::~PointConstructionMethodType()
{
  #ifndef NODESTRUCT
  delete PointConstructionMethodTypePair;
  #endif
}

void PointConstructionMethodType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (PointConstructionMethodTypePair)
    {
      PointConstructionMethodTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

PointConstructionMethodTypeChoicePair * PointConstructionMethodType::getPointConstructionMethodTypePair()
{return PointConstructionMethodTypePair;}

void PointConstructionMethodType::setPointConstructionMethodTypePair(PointConstructionMethodTypeChoicePair * PointConstructionMethodTypePairIn)
{PointConstructionMethodTypePair = PointConstructionMethodTypePairIn;}
PointConstructionMethodTypeChoicePair::PointConstructionMethodTypeChoicePair() {}

PointConstructionMethodTypeChoicePair::PointConstructionMethodTypeChoicePair(
 whichOne PointConstructionMethodTypeTypeIn,
 PointConstructionMethodTypeVal * PointConstructionMethodTypeValueIn)
{
  PointConstructionMethodTypeType = PointConstructionMethodTypeTypeIn;
  PointConstructionMethodTypeValue = PointConstructionMethodTypeValueIn;
}

PointConstructionMethodTypeChoicePair::~PointConstructionMethodTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (PointConstructionMethodTypeType == IntersectionE)
    delete PointConstructionMethodTypeValue->Intersection;
  else if (PointConstructionMethodTypeType == ProjectionE)
    delete PointConstructionMethodTypeValue->Projection;
  else if (PointConstructionMethodTypeType == CopyE)
    delete PointConstructionMethodTypeValue->Copy;
  else if (PointConstructionMethodTypeType == CastE)
    delete PointConstructionMethodTypeValue->Cast;
  else if (PointConstructionMethodTypeType == TransformE)
    delete PointConstructionMethodTypeValue->Transform;
  else if (PointConstructionMethodTypeType == FromConeE)
    delete PointConstructionMethodTypeValue->FromCone;
  else if (PointConstructionMethodTypeType == FromScanE)
    delete PointConstructionMethodTypeValue->FromScan;
  else if (PointConstructionMethodTypeType == CenterOfGravityE)
    delete PointConstructionMethodTypeValue->CenterOfGravity;
  else if (PointConstructionMethodTypeType == PierceE)
    delete PointConstructionMethodTypeValue->Pierce;
  else if (PointConstructionMethodTypeType == MidPointE)
    delete PointConstructionMethodTypeValue->MidPoint;
  else if (PointConstructionMethodTypeType == MovePointE)
    delete PointConstructionMethodTypeValue->MovePoint;
  else if (PointConstructionMethodTypeType == MovePointVectorE)
    delete PointConstructionMethodTypeValue->MovePointVector;
  else if (PointConstructionMethodTypeType == MovePointAxisE)
    delete PointConstructionMethodTypeValue->MovePointAxis;
  else if (PointConstructionMethodTypeType == ExtremeE)
    delete PointConstructionMethodTypeValue->Extreme;
  delete PointConstructionMethodTypeValue;
  #endif
}

void PointConstructionMethodTypeChoicePair::printSelf(FILE * outFile)
{
  if (PointConstructionMethodTypeType == IntersectionE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Intersection");
      PointConstructionMethodTypeValue->Intersection->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Intersection>\n");
    }
  else if (PointConstructionMethodTypeType == ProjectionE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Projection");
      PointConstructionMethodTypeValue->Projection->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Projection>\n");
    }
  else if (PointConstructionMethodTypeType == CopyE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Copy");
      PointConstructionMethodTypeValue->Copy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Copy>\n");
    }
  else if (PointConstructionMethodTypeType == CastE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Cast");
      PointConstructionMethodTypeValue->Cast->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Cast>\n");
    }
  else if (PointConstructionMethodTypeType == TransformE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Transform");
      PointConstructionMethodTypeValue->Transform->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Transform>\n");
    }
  else if (PointConstructionMethodTypeType == FromConeE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FromCone");
      PointConstructionMethodTypeValue->FromCone->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FromCone>\n");
    }
  else if (PointConstructionMethodTypeType == FromScanE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FromScan");
      PointConstructionMethodTypeValue->FromScan->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FromScan>\n");
    }
  else if (PointConstructionMethodTypeType == CenterOfGravityE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CenterOfGravity");
      PointConstructionMethodTypeValue->CenterOfGravity->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CenterOfGravity>\n");
    }
  else if (PointConstructionMethodTypeType == PierceE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Pierce");
      PointConstructionMethodTypeValue->Pierce->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Pierce>\n");
    }
  else if (PointConstructionMethodTypeType == MidPointE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MidPoint");
      PointConstructionMethodTypeValue->MidPoint->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MidPoint>\n");
    }
  else if (PointConstructionMethodTypeType == MovePointE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MovePoint");
      PointConstructionMethodTypeValue->MovePoint->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MovePoint>\n");
    }
  else if (PointConstructionMethodTypeType == MovePointVectorE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MovePointVector");
      PointConstructionMethodTypeValue->MovePointVector->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MovePointVector>\n");
    }
  else if (PointConstructionMethodTypeType == MovePointAxisE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MovePointAxis");
      PointConstructionMethodTypeValue->MovePointAxis->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MovePointAxis>\n");
    }
  else if (PointConstructionMethodTypeType == ExtremeE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Extreme");
      PointConstructionMethodTypeValue->Extreme->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Extreme>\n");
    }
}

/* ***************************************************************** */

/* class PointDefinedCurveBestFitType

*/

PointDefinedCurveBestFitType::PointDefinedCurveBestFitType() :
  ConstructionMethodBaseType()
{
  n = 0;
  BaseFeature = 0;
}

PointDefinedCurveBestFitType::PointDefinedCurveBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = 0;
  BaseFeature = BaseFeatureIn;
}

PointDefinedCurveBestFitType::PointDefinedCurveBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 NaturalType * nIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = nIn;
  BaseFeature = BaseFeatureIn;
}

PointDefinedCurveBestFitType::~PointDefinedCurveBestFitType()
{
  #ifndef NODESTRUCT
  delete n;
  delete BaseFeature;
  #endif
}

void PointDefinedCurveBestFitType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  {
    if (!BaseFeature)
      {
        fprintf(stderr, "BaseFeature list is missing\n");
        exit(1);
      }
    if (BaseFeature->size() == 0)
      {
        fprintf(stderr, "BaseFeature list is empty\n");
        exit(1);
      }
    if (BaseFeature->size() < 3)
      {
        fprintf(stderr,
                "size of BaseFeature list (%d) less than minimum required (3)\n",
                (int)BaseFeature->size());
        exit(1);
      }
    std::list<SequencedBaseFeatureType *>::iterator iter;
    for (iter = BaseFeature->begin();
         iter != BaseFeature->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<BaseFeature");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</BaseFeature>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool PointDefinedCurveBestFitType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in PointDefinedCurveBestFitType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in PointDefinedCurveBestFitType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PointDefinedCurveBestFitType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in PointDefinedCurveBestFitType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * PointDefinedCurveBestFitType::getn()
{return n;}

void PointDefinedCurveBestFitType::setn(NaturalType * nIn)
{n = nIn;}

SequencedBaseFeatureTypeLisd * PointDefinedCurveBestFitType::getBaseFeature()
{return BaseFeature;}

void PointDefinedCurveBestFitType::setBaseFeature(SequencedBaseFeatureTypeLisd * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class PointDefinedCurveCheckedFeatureType

*/

PointDefinedCurveCheckedFeatureType::PointDefinedCurveCheckedFeatureType()
{
  CheckDetails = 0;
}

PointDefinedCurveCheckedFeatureType::PointDefinedCurveCheckedFeatureType(
 PointDefinedCurveCheckedType * CheckDetailsIn)
{
  CheckDetails = CheckDetailsIn;
}

PointDefinedCurveCheckedFeatureType::~PointDefinedCurveCheckedFeatureType()
{
  #ifndef NODESTRUCT
  delete CheckDetails;
  #endif
}

void PointDefinedCurveCheckedFeatureType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (CheckDetails)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CheckDetails");
      CheckDetails->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CheckDetails>\n");
    }
  doSpaces(-INDENT, outFile);
}

PointDefinedCurveCheckedType * PointDefinedCurveCheckedFeatureType::getCheckDetails()
{return CheckDetails;}

void PointDefinedCurveCheckedFeatureType::setCheckDetails(PointDefinedCurveCheckedType * CheckDetailsIn)
{CheckDetails = CheckDetailsIn;}

/* ***************************************************************** */

/* class PointDefinedCurveCheckedType

*/

PointDefinedCurveCheckedType::PointDefinedCurveCheckedType()
{
  PointDefinedCurveCheckedTypePair = 0;
}

PointDefinedCurveCheckedType::PointDefinedCurveCheckedType(
 PointDefinedCurveCheckedTypeChoicePair * PointDefinedCurveCheckedTypePairIn)
{
  PointDefinedCurveCheckedTypePair = PointDefinedCurveCheckedTypePairIn;
}

PointDefinedCurveCheckedType::~PointDefinedCurveCheckedType()
{
  #ifndef NODESTRUCT
  delete PointDefinedCurveCheckedTypePair;
  #endif
}

void PointDefinedCurveCheckedType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  PointDefinedCurveCheckedTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

PointDefinedCurveCheckedTypeChoicePair * PointDefinedCurveCheckedType::getPointDefinedCurveCheckedTypePair()
{return PointDefinedCurveCheckedTypePair;}

void PointDefinedCurveCheckedType::setPointDefinedCurveCheckedTypePair(PointDefinedCurveCheckedTypeChoicePair * PointDefinedCurveCheckedTypePairIn)
{PointDefinedCurveCheckedTypePair = PointDefinedCurveCheckedTypePairIn;}
PointDefinedCurveCheckedTypeChoicePair::PointDefinedCurveCheckedTypeChoicePair() {}

PointDefinedCurveCheckedTypeChoicePair::PointDefinedCurveCheckedTypeChoicePair(
 whichOne PointDefinedCurveCheckedTypeTypeIn,
 PointDefinedCurveCheckedTypeVal * PointDefinedCurveCheckedTypeValueIn)
{
  PointDefinedCurveCheckedTypeType = PointDefinedCurveCheckedTypeTypeIn;
  PointDefinedCurveCheckedTypeValue = PointDefinedCurveCheckedTypeValueIn;
}

PointDefinedCurveCheckedTypeChoicePair::~PointDefinedCurveCheckedTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (PointDefinedCurveCheckedTypeType == MeasuredE)
    delete PointDefinedCurveCheckedTypeValue->Measured;
  else if (PointDefinedCurveCheckedTypeType == ConstructedE)
    delete PointDefinedCurveCheckedTypeValue->Constructed;
  delete PointDefinedCurveCheckedTypeValue;
  #endif
}

void PointDefinedCurveCheckedTypeChoicePair::printSelf(FILE * outFile)
{
  if (PointDefinedCurveCheckedTypeType == MeasuredE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Measured");
      PointDefinedCurveCheckedTypeValue->Measured->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Measured>\n");
    }
  else if (PointDefinedCurveCheckedTypeType == ConstructedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      PointDefinedCurveCheckedTypeValue->Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
}

/* ***************************************************************** */

/* class PointDefinedCurveConstructionMethodType

*/

PointDefinedCurveConstructionMethodType::PointDefinedCurveConstructionMethodType()
{
  PointDefinedCurveConstructionMethodTypePair = 0;
}

PointDefinedCurveConstructionMethodType::PointDefinedCurveConstructionMethodType(
 PointDefinedCurveConstructionMethodTypeChoicePair * PointDefinedCurveConstructionMethodTypePairIn)
{
  PointDefinedCurveConstructionMethodTypePair = PointDefinedCurveConstructionMethodTypePairIn;
}

PointDefinedCurveConstructionMethodType::~PointDefinedCurveConstructionMethodType()
{
  #ifndef NODESTRUCT
  delete PointDefinedCurveConstructionMethodTypePair;
  #endif
}

void PointDefinedCurveConstructionMethodType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (PointDefinedCurveConstructionMethodTypePair)
    {
      PointDefinedCurveConstructionMethodTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

PointDefinedCurveConstructionMethodTypeChoicePair * PointDefinedCurveConstructionMethodType::getPointDefinedCurveConstructionMethodTypePair()
{return PointDefinedCurveConstructionMethodTypePair;}

void PointDefinedCurveConstructionMethodType::setPointDefinedCurveConstructionMethodTypePair(PointDefinedCurveConstructionMethodTypeChoicePair * PointDefinedCurveConstructionMethodTypePairIn)
{PointDefinedCurveConstructionMethodTypePair = PointDefinedCurveConstructionMethodTypePairIn;}
PointDefinedCurveConstructionMethodTypeChoicePair::PointDefinedCurveConstructionMethodTypeChoicePair() {}

PointDefinedCurveConstructionMethodTypeChoicePair::PointDefinedCurveConstructionMethodTypeChoicePair(
 whichOne PointDefinedCurveConstructionMethodTypeTypeIn,
 PointDefinedCurveConstructionMethodTypeVal * PointDefinedCurveConstructionMethodTypeValueIn)
{
  PointDefinedCurveConstructionMethodTypeType = PointDefinedCurveConstructionMethodTypeTypeIn;
  PointDefinedCurveConstructionMethodTypeValue = PointDefinedCurveConstructionMethodTypeValueIn;
}

PointDefinedCurveConstructionMethodTypeChoicePair::~PointDefinedCurveConstructionMethodTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (PointDefinedCurveConstructionMethodTypeType == BestFitE)
    delete PointDefinedCurveConstructionMethodTypeValue->BestFit;
  else if (PointDefinedCurveConstructionMethodTypeType == RecompensatedE)
    delete PointDefinedCurveConstructionMethodTypeValue->Recompensated;
  else if (PointDefinedCurveConstructionMethodTypeType == CopyE)
    delete PointDefinedCurveConstructionMethodTypeValue->Copy;
  else if (PointDefinedCurveConstructionMethodTypeType == TransformE)
    delete PointDefinedCurveConstructionMethodTypeValue->Transform;
  else if (PointDefinedCurveConstructionMethodTypeType == FromScanE)
    delete PointDefinedCurveConstructionMethodTypeValue->FromScan;
  else if (PointDefinedCurveConstructionMethodTypeType == ExtractE)
    delete PointDefinedCurveConstructionMethodTypeValue->Extract;
  delete PointDefinedCurveConstructionMethodTypeValue;
  #endif
}

void PointDefinedCurveConstructionMethodTypeChoicePair::printSelf(FILE * outFile)
{
  if (PointDefinedCurveConstructionMethodTypeType == BestFitE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BestFit");
      PointDefinedCurveConstructionMethodTypeValue->BestFit->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BestFit>\n");
    }
  else if (PointDefinedCurveConstructionMethodTypeType == RecompensatedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Recompensated");
      PointDefinedCurveConstructionMethodTypeValue->Recompensated->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Recompensated>\n");
    }
  else if (PointDefinedCurveConstructionMethodTypeType == CopyE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Copy");
      PointDefinedCurveConstructionMethodTypeValue->Copy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Copy>\n");
    }
  else if (PointDefinedCurveConstructionMethodTypeType == TransformE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Transform");
      PointDefinedCurveConstructionMethodTypeValue->Transform->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Transform>\n");
    }
  else if (PointDefinedCurveConstructionMethodTypeType == FromScanE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FromScan");
      PointDefinedCurveConstructionMethodTypeValue->FromScan->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FromScan>\n");
    }
  else if (PointDefinedCurveConstructionMethodTypeType == ExtractE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Extract");
      PointDefinedCurveConstructionMethodTypeValue->Extract->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Extract>\n");
    }
}

/* ***************************************************************** */

/* class PointDefinedCurveCopyType

*/

PointDefinedCurveCopyType::PointDefinedCurveCopyType() :
  ConstructionMethodBaseType()
{
  BasePointDefinedCurve = 0;
}

PointDefinedCurveCopyType::PointDefinedCurveCopyType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BasePointDefinedCurveIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BasePointDefinedCurve = BasePointDefinedCurveIn;
}

PointDefinedCurveCopyType::~PointDefinedCurveCopyType()
{
  #ifndef NODESTRUCT
  delete BasePointDefinedCurve;
  #endif
}

void PointDefinedCurveCopyType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BasePointDefinedCurve");
  BasePointDefinedCurve->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BasePointDefinedCurve>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * PointDefinedCurveCopyType::getBasePointDefinedCurve()
{return BasePointDefinedCurve;}

void PointDefinedCurveCopyType::setBasePointDefinedCurve(BaseFeatureType * BasePointDefinedCurveIn)
{BasePointDefinedCurve = BasePointDefinedCurveIn;}

/* ***************************************************************** */

/* class PointDefinedCurveExtractType

*/

PointDefinedCurveExtractType::PointDefinedCurveExtractType() :
  ConstructionMethodBaseType()
{
  CurveFeature = 0;
}

PointDefinedCurveExtractType::PointDefinedCurveExtractType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * CurveFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  CurveFeature = CurveFeatureIn;
}

PointDefinedCurveExtractType::~PointDefinedCurveExtractType()
{
  #ifndef NODESTRUCT
  delete CurveFeature;
  #endif
}

void PointDefinedCurveExtractType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CurveFeature");
  CurveFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</CurveFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * PointDefinedCurveExtractType::getCurveFeature()
{return CurveFeature;}

void PointDefinedCurveExtractType::setCurveFeature(BaseFeatureType * CurveFeatureIn)
{CurveFeature = CurveFeatureIn;}

/* ***************************************************************** */

/* class PointDefinedCurveFeatureDefinitionType

*/

PointDefinedCurveFeatureDefinitionType::PointDefinedCurveFeatureDefinitionType() :
  CurveFeatureDefinitionBaseType()
{
}

PointDefinedCurveFeatureDefinitionType::PointDefinedCurveFeatureDefinitionType(
 AttributesType * AttributesIn) :
  CurveFeatureDefinitionBaseType(
    AttributesIn)
{
}

PointDefinedCurveFeatureDefinitionType::PointDefinedCurveFeatureDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn) :
  CurveFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
}

PointDefinedCurveFeatureDefinitionType::~PointDefinedCurveFeatureDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void PointDefinedCurveFeatureDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool PointDefinedCurveFeatureDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PointDefinedCurveFeatureDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PointDefinedCurveFeatureDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PointDefinedCurveFeatureDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PointDefinedCurveFeatureDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class PointDefinedCurveFeatureItemType

*/

PointDefinedCurveFeatureItemType::PointDefinedCurveFeatureItemType() :
  CurveFeatureItemBaseType()
{
  DeterminationMode = 0;
}

PointDefinedCurveFeatureItemType::PointDefinedCurveFeatureItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 PointDefinedCurveMeasurementDeterminationType * DeterminationModeIn) :
  CurveFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

PointDefinedCurveFeatureItemType::PointDefinedCurveFeatureItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 PointDefinedCurveMeasurementDeterminationType * DeterminationModeIn) :
  CurveFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

PointDefinedCurveFeatureItemType::~PointDefinedCurveFeatureItemType()
{
  #ifndef NODESTRUCT
  delete DeterminationMode;
  #endif
}

void PointDefinedCurveFeatureItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<DeterminationMode");
  DeterminationMode->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeterminationMode>\n");
  doSpaces(-INDENT, outFile);
}

bool PointDefinedCurveFeatureItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PointDefinedCurveFeatureItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PointDefinedCurveFeatureItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PointDefinedCurveFeatureItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PointDefinedCurveFeatureItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

PointDefinedCurveMeasurementDeterminationType * PointDefinedCurveFeatureItemType::getDeterminationMode()
{return DeterminationMode;}

void PointDefinedCurveFeatureItemType::setDeterminationMode(PointDefinedCurveMeasurementDeterminationType * DeterminationModeIn)
{DeterminationMode = DeterminationModeIn;}

/* ***************************************************************** */

/* class PointDefinedCurveFeatureMeasurementType

*/

PointDefinedCurveFeatureMeasurementType::PointDefinedCurveFeatureMeasurementType() :
  CurveFeatureMeasurementBaseType()
{
  DefiningPoints = 0;
  Plane = 0;
  Form = 0;
}

PointDefinedCurveFeatureMeasurementType::PointDefinedCurveFeatureMeasurementType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 DefiningPointsMeasurementType * DefiningPointsIn,
 MeasuredPlaneType * PlaneIn,
 MeasuredLinearValueType * FormIn) :
  CurveFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  DefiningPoints = DefiningPointsIn;
  Plane = PlaneIn;
  Form = FormIn;
}

PointDefinedCurveFeatureMeasurementType::PointDefinedCurveFeatureMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 DefiningPointsMeasurementType * DefiningPointsIn,
 MeasuredPlaneType * PlaneIn,
 MeasuredLinearValueType * FormIn) :
  CurveFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  DefiningPoints = DefiningPointsIn;
  Plane = PlaneIn;
  Form = FormIn;
}

PointDefinedCurveFeatureMeasurementType::~PointDefinedCurveFeatureMeasurementType()
{
  #ifndef NODESTRUCT
  delete DefiningPoints;
  delete Plane;
  delete Form;
  #endif
}

void PointDefinedCurveFeatureMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  if (DefiningPoints)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DefiningPoints");
      DefiningPoints->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DefiningPoints>\n");
    }
  if (Plane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Plane");
      Plane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Plane>\n");
    }
  if (Form)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Form");
      Form->printSelf(outFile);
      fprintf(outFile, "</Form>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool PointDefinedCurveFeatureMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PointDefinedCurveFeatureMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PointDefinedCurveFeatureMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PointDefinedCurveFeatureMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PointDefinedCurveFeatureMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

DefiningPointsMeasurementType * PointDefinedCurveFeatureMeasurementType::getDefiningPoints()
{return DefiningPoints;}

void PointDefinedCurveFeatureMeasurementType::setDefiningPoints(DefiningPointsMeasurementType * DefiningPointsIn)
{DefiningPoints = DefiningPointsIn;}

MeasuredPlaneType * PointDefinedCurveFeatureMeasurementType::getPlane()
{return Plane;}

void PointDefinedCurveFeatureMeasurementType::setPlane(MeasuredPlaneType * PlaneIn)
{Plane = PlaneIn;}

MeasuredLinearValueType * PointDefinedCurveFeatureMeasurementType::getForm()
{return Form;}

void PointDefinedCurveFeatureMeasurementType::setForm(MeasuredLinearValueType * FormIn)
{Form = FormIn;}

/* ***************************************************************** */

/* class PointDefinedCurveFeatureNominalType

*/

PointDefinedCurveFeatureNominalType::PointDefinedCurveFeatureNominalType() :
  CurveFeatureNominalBaseType()
{
  DefiningPoints = 0;
  Plane = 0;
  Constructed = 0;
}

PointDefinedCurveFeatureNominalType::PointDefinedCurveFeatureNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 DefiningPointsNominalType * DefiningPointsIn,
 PlaneType * PlaneIn,
 PointDefinedCurveConstructionMethodType * ConstructedIn) :
  CurveFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    SurfaceFeatureNominalIdIn)
{
  DefiningPoints = DefiningPointsIn;
  Plane = PlaneIn;
  Constructed = ConstructedIn;
}

PointDefinedCurveFeatureNominalType::PointDefinedCurveFeatureNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceFullType * SurfaceFeatureNominalIdIn,
 DefiningPointsNominalType * DefiningPointsIn,
 PlaneType * PlaneIn,
 PointDefinedCurveConstructionMethodType * ConstructedIn) :
  CurveFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    SurfaceFeatureNominalIdIn)
{
  DefiningPoints = DefiningPointsIn;
  Plane = PlaneIn;
  Constructed = ConstructedIn;
}

PointDefinedCurveFeatureNominalType::~PointDefinedCurveFeatureNominalType()
{
  #ifndef NODESTRUCT
  delete DefiningPoints;
  delete Plane;
  delete Constructed;
  #endif
}

void PointDefinedCurveFeatureNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (SurfaceFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SurfaceFeatureNominalId");
      SurfaceFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</SurfaceFeatureNominalId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<DefiningPoints");
  DefiningPoints->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DefiningPoints>\n");
  if (Plane)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Plane");
      Plane->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Plane>\n");
    }
  if (Constructed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool PointDefinedCurveFeatureNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PointDefinedCurveFeatureNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PointDefinedCurveFeatureNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PointDefinedCurveFeatureNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PointDefinedCurveFeatureNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

DefiningPointsNominalType * PointDefinedCurveFeatureNominalType::getDefiningPoints()
{return DefiningPoints;}

void PointDefinedCurveFeatureNominalType::setDefiningPoints(DefiningPointsNominalType * DefiningPointsIn)
{DefiningPoints = DefiningPointsIn;}

PlaneType * PointDefinedCurveFeatureNominalType::getPlane()
{return Plane;}

void PointDefinedCurveFeatureNominalType::setPlane(PlaneType * PlaneIn)
{Plane = PlaneIn;}

PointDefinedCurveConstructionMethodType * PointDefinedCurveFeatureNominalType::getConstructed()
{return Constructed;}

void PointDefinedCurveFeatureNominalType::setConstructed(PointDefinedCurveConstructionMethodType * ConstructedIn)
{Constructed = ConstructedIn;}

/* ***************************************************************** */

/* class PointDefinedCurveFromScanType

*/

PointDefinedCurveFromScanType::PointDefinedCurveFromScanType() :
  ConstructionMethodBaseType()
{
  SurfaceFeature = 0;
  SearchRadius = 0;
}

PointDefinedCurveFromScanType::PointDefinedCurveFromScanType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * SurfaceFeatureIn,
 LinearValueType * SearchRadiusIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  SurfaceFeature = SurfaceFeatureIn;
  SearchRadius = SearchRadiusIn;
}

PointDefinedCurveFromScanType::~PointDefinedCurveFromScanType()
{
  #ifndef NODESTRUCT
  delete SurfaceFeature;
  delete SearchRadius;
  #endif
}

void PointDefinedCurveFromScanType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<SurfaceFeature");
  SurfaceFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</SurfaceFeature>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<SearchRadius");
  SearchRadius->printSelf(outFile);
  fprintf(outFile, "</SearchRadius>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * PointDefinedCurveFromScanType::getSurfaceFeature()
{return SurfaceFeature;}

void PointDefinedCurveFromScanType::setSurfaceFeature(BaseFeatureType * SurfaceFeatureIn)
{SurfaceFeature = SurfaceFeatureIn;}

LinearValueType * PointDefinedCurveFromScanType::getSearchRadius()
{return SearchRadius;}

void PointDefinedCurveFromScanType::setSearchRadius(LinearValueType * SearchRadiusIn)
{SearchRadius = SearchRadiusIn;}

/* ***************************************************************** */

/* class PointDefinedCurveMeasurementDeterminationType

*/

PointDefinedCurveMeasurementDeterminationType::PointDefinedCurveMeasurementDeterminationType()
{
  PointDefinedCurveMeasurementDeterminationTypePair = 0;
}

PointDefinedCurveMeasurementDeterminationType::PointDefinedCurveMeasurementDeterminationType(
 PointDefinedCurveMeasurementDeterminationTypeChoicePair * PointDefinedCurveMeasurementDeterminationTypePairIn)
{
  PointDefinedCurveMeasurementDeterminationTypePair = PointDefinedCurveMeasurementDeterminationTypePairIn;
}

PointDefinedCurveMeasurementDeterminationType::~PointDefinedCurveMeasurementDeterminationType()
{
  #ifndef NODESTRUCT
  delete PointDefinedCurveMeasurementDeterminationTypePair;
  #endif
}

void PointDefinedCurveMeasurementDeterminationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  PointDefinedCurveMeasurementDeterminationTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

PointDefinedCurveMeasurementDeterminationTypeChoicePair * PointDefinedCurveMeasurementDeterminationType::getPointDefinedCurveMeasurementDeterminationTypePair()
{return PointDefinedCurveMeasurementDeterminationTypePair;}

void PointDefinedCurveMeasurementDeterminationType::setPointDefinedCurveMeasurementDeterminationTypePair(PointDefinedCurveMeasurementDeterminationTypeChoicePair * PointDefinedCurveMeasurementDeterminationTypePairIn)
{PointDefinedCurveMeasurementDeterminationTypePair = PointDefinedCurveMeasurementDeterminationTypePairIn;}
PointDefinedCurveMeasurementDeterminationTypeChoicePair::PointDefinedCurveMeasurementDeterminationTypeChoicePair() {}

PointDefinedCurveMeasurementDeterminationTypeChoicePair::PointDefinedCurveMeasurementDeterminationTypeChoicePair(
 whichOne PointDefinedCurveMeasurementDeterminationTypeTypeIn,
 PointDefinedCurveMeasurementDeterminationTypeVal * PointDefinedCurveMeasurementDeterminationTypeValueIn)
{
  PointDefinedCurveMeasurementDeterminationTypeType = PointDefinedCurveMeasurementDeterminationTypeTypeIn;
  PointDefinedCurveMeasurementDeterminationTypeValue = PointDefinedCurveMeasurementDeterminationTypeValueIn;
}

PointDefinedCurveMeasurementDeterminationTypeChoicePair::~PointDefinedCurveMeasurementDeterminationTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (PointDefinedCurveMeasurementDeterminationTypeType == CheckedE)
    delete PointDefinedCurveMeasurementDeterminationTypeValue->Checked;
  else if (PointDefinedCurveMeasurementDeterminationTypeType == SetE)
    delete PointDefinedCurveMeasurementDeterminationTypeValue->Set;
  delete PointDefinedCurveMeasurementDeterminationTypeValue;
  #endif
}

void PointDefinedCurveMeasurementDeterminationTypeChoicePair::printSelf(FILE * outFile)
{
  if (PointDefinedCurveMeasurementDeterminationTypeType == CheckedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Checked");
      PointDefinedCurveMeasurementDeterminationTypeValue->Checked->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Checked>\n");
    }
  else if (PointDefinedCurveMeasurementDeterminationTypeType == SetE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Set");
      PointDefinedCurveMeasurementDeterminationTypeValue->Set->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class PointDefinedCurveRecompType

*/

PointDefinedCurveRecompType::PointDefinedCurveRecompType() :
  ConstructionMethodBaseType()
{
  BaseFeaturePointList = 0;
}

PointDefinedCurveRecompType::PointDefinedCurveRecompType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeaturePointListType * BaseFeaturePointListIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeaturePointList = BaseFeaturePointListIn;
}

PointDefinedCurveRecompType::~PointDefinedCurveRecompType()
{
  #ifndef NODESTRUCT
  delete BaseFeaturePointList;
  #endif
}

void PointDefinedCurveRecompType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeaturePointList");
  BaseFeaturePointList->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeaturePointList>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeaturePointListType * PointDefinedCurveRecompType::getBaseFeaturePointList()
{return BaseFeaturePointList;}

void PointDefinedCurveRecompType::setBaseFeaturePointList(BaseFeaturePointListType * BaseFeaturePointListIn)
{BaseFeaturePointList = BaseFeaturePointListIn;}

/* ***************************************************************** */

/* class PointDefinedCurveTransformType

*/

PointDefinedCurveTransformType::PointDefinedCurveTransformType() :
  ConstructionMethodBaseType()
{
  BasePointDefinedCurve = 0;
  Transformation = 0;
}

PointDefinedCurveTransformType::PointDefinedCurveTransformType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BasePointDefinedCurveIn,
 TransformationReferenceType * TransformationIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BasePointDefinedCurve = BasePointDefinedCurveIn;
  Transformation = TransformationIn;
}

PointDefinedCurveTransformType::~PointDefinedCurveTransformType()
{
  #ifndef NODESTRUCT
  delete BasePointDefinedCurve;
  delete Transformation;
  #endif
}

void PointDefinedCurveTransformType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BasePointDefinedCurve");
  BasePointDefinedCurve->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BasePointDefinedCurve>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Transformation");
  Transformation->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Transformation>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * PointDefinedCurveTransformType::getBasePointDefinedCurve()
{return BasePointDefinedCurve;}

void PointDefinedCurveTransformType::setBasePointDefinedCurve(BaseFeatureType * BasePointDefinedCurveIn)
{BasePointDefinedCurve = BasePointDefinedCurveIn;}

TransformationReferenceType * PointDefinedCurveTransformType::getTransformation()
{return Transformation;}

void PointDefinedCurveTransformType::setTransformation(TransformationReferenceType * TransformationIn)
{Transformation = TransformationIn;}

/* ***************************************************************** */

/* class PointDefinedSurfaceBestFitType

*/

PointDefinedSurfaceBestFitType::PointDefinedSurfaceBestFitType() :
  ConstructionMethodBaseType()
{
  n = 0;
  BaseFeature = 0;
}

PointDefinedSurfaceBestFitType::PointDefinedSurfaceBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = 0;
  BaseFeature = BaseFeatureIn;
}

PointDefinedSurfaceBestFitType::PointDefinedSurfaceBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 NaturalType * nIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = nIn;
  BaseFeature = BaseFeatureIn;
}

PointDefinedSurfaceBestFitType::~PointDefinedSurfaceBestFitType()
{
  #ifndef NODESTRUCT
  delete n;
  delete BaseFeature;
  #endif
}

void PointDefinedSurfaceBestFitType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  {
    if (!BaseFeature)
      {
        fprintf(stderr, "BaseFeature list is missing\n");
        exit(1);
      }
    if (BaseFeature->size() == 0)
      {
        fprintf(stderr, "BaseFeature list is empty\n");
        exit(1);
      }
    if (BaseFeature->size() < 3)
      {
        fprintf(stderr,
                "size of BaseFeature list (%d) less than minimum required (3)\n",
                (int)BaseFeature->size());
        exit(1);
      }
    std::list<SequencedBaseFeatureType *>::iterator iter;
    for (iter = BaseFeature->begin();
         iter != BaseFeature->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<BaseFeature");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</BaseFeature>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool PointDefinedSurfaceBestFitType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in PointDefinedSurfaceBestFitType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in PointDefinedSurfaceBestFitType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PointDefinedSurfaceBestFitType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in PointDefinedSurfaceBestFitType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * PointDefinedSurfaceBestFitType::getn()
{return n;}

void PointDefinedSurfaceBestFitType::setn(NaturalType * nIn)
{n = nIn;}

SequencedBaseFeatureTypeLisd * PointDefinedSurfaceBestFitType::getBaseFeature()
{return BaseFeature;}

void PointDefinedSurfaceBestFitType::setBaseFeature(SequencedBaseFeatureTypeLisd * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class PointDefinedSurfaceCheckedFeatureType

*/

PointDefinedSurfaceCheckedFeatureType::PointDefinedSurfaceCheckedFeatureType()
{
  CheckDetails = 0;
}

PointDefinedSurfaceCheckedFeatureType::PointDefinedSurfaceCheckedFeatureType(
 PointDefinedSurfaceCheckedType * CheckDetailsIn)
{
  CheckDetails = CheckDetailsIn;
}

PointDefinedSurfaceCheckedFeatureType::~PointDefinedSurfaceCheckedFeatureType()
{
  #ifndef NODESTRUCT
  delete CheckDetails;
  #endif
}

void PointDefinedSurfaceCheckedFeatureType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (CheckDetails)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CheckDetails");
      CheckDetails->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CheckDetails>\n");
    }
  doSpaces(-INDENT, outFile);
}

PointDefinedSurfaceCheckedType * PointDefinedSurfaceCheckedFeatureType::getCheckDetails()
{return CheckDetails;}

void PointDefinedSurfaceCheckedFeatureType::setCheckDetails(PointDefinedSurfaceCheckedType * CheckDetailsIn)
{CheckDetails = CheckDetailsIn;}

/* ***************************************************************** */

/* class PointDefinedSurfaceCheckedType

*/

PointDefinedSurfaceCheckedType::PointDefinedSurfaceCheckedType()
{
  PointDefinedSurfaceCheckedTypePair = 0;
}

PointDefinedSurfaceCheckedType::PointDefinedSurfaceCheckedType(
 PointDefinedSurfaceCheckedTypeChoicePair * PointDefinedSurfaceCheckedTypePairIn)
{
  PointDefinedSurfaceCheckedTypePair = PointDefinedSurfaceCheckedTypePairIn;
}

PointDefinedSurfaceCheckedType::~PointDefinedSurfaceCheckedType()
{
  #ifndef NODESTRUCT
  delete PointDefinedSurfaceCheckedTypePair;
  #endif
}

void PointDefinedSurfaceCheckedType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  PointDefinedSurfaceCheckedTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

PointDefinedSurfaceCheckedTypeChoicePair * PointDefinedSurfaceCheckedType::getPointDefinedSurfaceCheckedTypePair()
{return PointDefinedSurfaceCheckedTypePair;}

void PointDefinedSurfaceCheckedType::setPointDefinedSurfaceCheckedTypePair(PointDefinedSurfaceCheckedTypeChoicePair * PointDefinedSurfaceCheckedTypePairIn)
{PointDefinedSurfaceCheckedTypePair = PointDefinedSurfaceCheckedTypePairIn;}
PointDefinedSurfaceCheckedTypeChoicePair::PointDefinedSurfaceCheckedTypeChoicePair() {}

PointDefinedSurfaceCheckedTypeChoicePair::PointDefinedSurfaceCheckedTypeChoicePair(
 whichOne PointDefinedSurfaceCheckedTypeTypeIn,
 PointDefinedSurfaceCheckedTypeVal * PointDefinedSurfaceCheckedTypeValueIn)
{
  PointDefinedSurfaceCheckedTypeType = PointDefinedSurfaceCheckedTypeTypeIn;
  PointDefinedSurfaceCheckedTypeValue = PointDefinedSurfaceCheckedTypeValueIn;
}

PointDefinedSurfaceCheckedTypeChoicePair::~PointDefinedSurfaceCheckedTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (PointDefinedSurfaceCheckedTypeType == MeasuredE)
    delete PointDefinedSurfaceCheckedTypeValue->Measured;
  else if (PointDefinedSurfaceCheckedTypeType == ConstructedE)
    delete PointDefinedSurfaceCheckedTypeValue->Constructed;
  delete PointDefinedSurfaceCheckedTypeValue;
  #endif
}

void PointDefinedSurfaceCheckedTypeChoicePair::printSelf(FILE * outFile)
{
  if (PointDefinedSurfaceCheckedTypeType == MeasuredE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Measured");
      PointDefinedSurfaceCheckedTypeValue->Measured->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Measured>\n");
    }
  else if (PointDefinedSurfaceCheckedTypeType == ConstructedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      PointDefinedSurfaceCheckedTypeValue->Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
}

/* ***************************************************************** */

/* class PointDefinedSurfaceConstructionMethodType

*/

PointDefinedSurfaceConstructionMethodType::PointDefinedSurfaceConstructionMethodType()
{
  PointDefinedSurfaceConstructionMethodTypePair = 0;
}

PointDefinedSurfaceConstructionMethodType::PointDefinedSurfaceConstructionMethodType(
 PointDefinedSurfaceConstructionMethodTypeChoicePair * PointDefinedSurfaceConstructionMethodTypePairIn)
{
  PointDefinedSurfaceConstructionMethodTypePair = PointDefinedSurfaceConstructionMethodTypePairIn;
}

PointDefinedSurfaceConstructionMethodType::~PointDefinedSurfaceConstructionMethodType()
{
  #ifndef NODESTRUCT
  delete PointDefinedSurfaceConstructionMethodTypePair;
  #endif
}

void PointDefinedSurfaceConstructionMethodType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (PointDefinedSurfaceConstructionMethodTypePair)
    {
      PointDefinedSurfaceConstructionMethodTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

PointDefinedSurfaceConstructionMethodTypeChoicePair * PointDefinedSurfaceConstructionMethodType::getPointDefinedSurfaceConstructionMethodTypePair()
{return PointDefinedSurfaceConstructionMethodTypePair;}

void PointDefinedSurfaceConstructionMethodType::setPointDefinedSurfaceConstructionMethodTypePair(PointDefinedSurfaceConstructionMethodTypeChoicePair * PointDefinedSurfaceConstructionMethodTypePairIn)
{PointDefinedSurfaceConstructionMethodTypePair = PointDefinedSurfaceConstructionMethodTypePairIn;}
PointDefinedSurfaceConstructionMethodTypeChoicePair::PointDefinedSurfaceConstructionMethodTypeChoicePair() {}

PointDefinedSurfaceConstructionMethodTypeChoicePair::PointDefinedSurfaceConstructionMethodTypeChoicePair(
 whichOne PointDefinedSurfaceConstructionMethodTypeTypeIn,
 PointDefinedSurfaceConstructionMethodTypeVal * PointDefinedSurfaceConstructionMethodTypeValueIn)
{
  PointDefinedSurfaceConstructionMethodTypeType = PointDefinedSurfaceConstructionMethodTypeTypeIn;
  PointDefinedSurfaceConstructionMethodTypeValue = PointDefinedSurfaceConstructionMethodTypeValueIn;
}

PointDefinedSurfaceConstructionMethodTypeChoicePair::~PointDefinedSurfaceConstructionMethodTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (PointDefinedSurfaceConstructionMethodTypeType == BestFitE)
    delete PointDefinedSurfaceConstructionMethodTypeValue->BestFit;
  else if (PointDefinedSurfaceConstructionMethodTypeType == RecompensatedE)
    delete PointDefinedSurfaceConstructionMethodTypeValue->Recompensated;
  else if (PointDefinedSurfaceConstructionMethodTypeType == CopyE)
    delete PointDefinedSurfaceConstructionMethodTypeValue->Copy;
  else if (PointDefinedSurfaceConstructionMethodTypeType == TransformE)
    delete PointDefinedSurfaceConstructionMethodTypeValue->Transform;
  else if (PointDefinedSurfaceConstructionMethodTypeType == ExtractE)
    delete PointDefinedSurfaceConstructionMethodTypeValue->Extract;
  delete PointDefinedSurfaceConstructionMethodTypeValue;
  #endif
}

void PointDefinedSurfaceConstructionMethodTypeChoicePair::printSelf(FILE * outFile)
{
  if (PointDefinedSurfaceConstructionMethodTypeType == BestFitE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BestFit");
      PointDefinedSurfaceConstructionMethodTypeValue->BestFit->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BestFit>\n");
    }
  else if (PointDefinedSurfaceConstructionMethodTypeType == RecompensatedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Recompensated");
      PointDefinedSurfaceConstructionMethodTypeValue->Recompensated->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Recompensated>\n");
    }
  else if (PointDefinedSurfaceConstructionMethodTypeType == CopyE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Copy");
      PointDefinedSurfaceConstructionMethodTypeValue->Copy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Copy>\n");
    }
  else if (PointDefinedSurfaceConstructionMethodTypeType == TransformE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Transform");
      PointDefinedSurfaceConstructionMethodTypeValue->Transform->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Transform>\n");
    }
  else if (PointDefinedSurfaceConstructionMethodTypeType == ExtractE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Extract");
      PointDefinedSurfaceConstructionMethodTypeValue->Extract->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Extract>\n");
    }
}

/* ***************************************************************** */

/* class PointDefinedSurfaceCopyType

*/

PointDefinedSurfaceCopyType::PointDefinedSurfaceCopyType() :
  ConstructionMethodBaseType()
{
  BasePointDefinedSurface = 0;
}

PointDefinedSurfaceCopyType::PointDefinedSurfaceCopyType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BasePointDefinedSurfaceIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BasePointDefinedSurface = BasePointDefinedSurfaceIn;
}

PointDefinedSurfaceCopyType::~PointDefinedSurfaceCopyType()
{
  #ifndef NODESTRUCT
  delete BasePointDefinedSurface;
  #endif
}

void PointDefinedSurfaceCopyType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BasePointDefinedSurface");
  BasePointDefinedSurface->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BasePointDefinedSurface>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * PointDefinedSurfaceCopyType::getBasePointDefinedSurface()
{return BasePointDefinedSurface;}

void PointDefinedSurfaceCopyType::setBasePointDefinedSurface(BaseFeatureType * BasePointDefinedSurfaceIn)
{BasePointDefinedSurface = BasePointDefinedSurfaceIn;}

/* ***************************************************************** */

/* class PointDefinedSurfaceExtractType

*/

PointDefinedSurfaceExtractType::PointDefinedSurfaceExtractType() :
  ConstructionMethodBaseType()
{
  SurfaceFeature = 0;
}

PointDefinedSurfaceExtractType::PointDefinedSurfaceExtractType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * SurfaceFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  SurfaceFeature = SurfaceFeatureIn;
}

PointDefinedSurfaceExtractType::~PointDefinedSurfaceExtractType()
{
  #ifndef NODESTRUCT
  delete SurfaceFeature;
  #endif
}

void PointDefinedSurfaceExtractType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<SurfaceFeature");
  SurfaceFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</SurfaceFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * PointDefinedSurfaceExtractType::getSurfaceFeature()
{return SurfaceFeature;}

void PointDefinedSurfaceExtractType::setSurfaceFeature(BaseFeatureType * SurfaceFeatureIn)
{SurfaceFeature = SurfaceFeatureIn;}

/* ***************************************************************** */

/* class PointDefinedSurfaceFeatureDefinitionType

*/

PointDefinedSurfaceFeatureDefinitionType::PointDefinedSurfaceFeatureDefinitionType() :
  SurfaceFeatureDefinitionBaseType()
{
}

PointDefinedSurfaceFeatureDefinitionType::PointDefinedSurfaceFeatureDefinitionType(
 AttributesType * AttributesIn) :
  SurfaceFeatureDefinitionBaseType(
    AttributesIn)
{
}

PointDefinedSurfaceFeatureDefinitionType::PointDefinedSurfaceFeatureDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn) :
  SurfaceFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
}

PointDefinedSurfaceFeatureDefinitionType::~PointDefinedSurfaceFeatureDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void PointDefinedSurfaceFeatureDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool PointDefinedSurfaceFeatureDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PointDefinedSurfaceFeatureDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PointDefinedSurfaceFeatureDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PointDefinedSurfaceFeatureDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PointDefinedSurfaceFeatureDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class PointDefinedSurfaceFeatureItemType

*/

PointDefinedSurfaceFeatureItemType::PointDefinedSurfaceFeatureItemType() :
  SurfaceFeatureItemBaseType()
{
  DeterminationMode = 0;
}

PointDefinedSurfaceFeatureItemType::PointDefinedSurfaceFeatureItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 PointDefinedSurfaceMeasurementDeterminationType * DeterminationModeIn) :
  SurfaceFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

PointDefinedSurfaceFeatureItemType::PointDefinedSurfaceFeatureItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 PointDefinedSurfaceMeasurementDeterminationType * DeterminationModeIn) :
  SurfaceFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

PointDefinedSurfaceFeatureItemType::~PointDefinedSurfaceFeatureItemType()
{
  #ifndef NODESTRUCT
  delete DeterminationMode;
  #endif
}

void PointDefinedSurfaceFeatureItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<DeterminationMode");
  DeterminationMode->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeterminationMode>\n");
  doSpaces(-INDENT, outFile);
}

bool PointDefinedSurfaceFeatureItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PointDefinedSurfaceFeatureItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PointDefinedSurfaceFeatureItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PointDefinedSurfaceFeatureItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PointDefinedSurfaceFeatureItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

PointDefinedSurfaceMeasurementDeterminationType * PointDefinedSurfaceFeatureItemType::getDeterminationMode()
{return DeterminationMode;}

void PointDefinedSurfaceFeatureItemType::setDeterminationMode(PointDefinedSurfaceMeasurementDeterminationType * DeterminationModeIn)
{DeterminationMode = DeterminationModeIn;}

/* ***************************************************************** */

/* class PointDefinedSurfaceFeatureMeasurementType

*/

PointDefinedSurfaceFeatureMeasurementType::PointDefinedSurfaceFeatureMeasurementType() :
  SurfaceFeatureMeasurementBaseType()
{
  DefiningPoints = 0;
  Form = 0;
}

PointDefinedSurfaceFeatureMeasurementType::PointDefinedSurfaceFeatureMeasurementType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 DefiningPointsMeasurementType * DefiningPointsIn,
 MeasuredLinearValueType * FormIn) :
  SurfaceFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  DefiningPoints = DefiningPointsIn;
  Form = FormIn;
}

PointDefinedSurfaceFeatureMeasurementType::PointDefinedSurfaceFeatureMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 DefiningPointsMeasurementType * DefiningPointsIn,
 MeasuredLinearValueType * FormIn) :
  SurfaceFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  DefiningPoints = DefiningPointsIn;
  Form = FormIn;
}

PointDefinedSurfaceFeatureMeasurementType::~PointDefinedSurfaceFeatureMeasurementType()
{
  #ifndef NODESTRUCT
  delete DefiningPoints;
  delete Form;
  #endif
}

void PointDefinedSurfaceFeatureMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  if (DefiningPoints)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DefiningPoints");
      DefiningPoints->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DefiningPoints>\n");
    }
  if (Form)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Form");
      Form->printSelf(outFile);
      fprintf(outFile, "</Form>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool PointDefinedSurfaceFeatureMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PointDefinedSurfaceFeatureMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PointDefinedSurfaceFeatureMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PointDefinedSurfaceFeatureMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PointDefinedSurfaceFeatureMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

DefiningPointsMeasurementType * PointDefinedSurfaceFeatureMeasurementType::getDefiningPoints()
{return DefiningPoints;}

void PointDefinedSurfaceFeatureMeasurementType::setDefiningPoints(DefiningPointsMeasurementType * DefiningPointsIn)
{DefiningPoints = DefiningPointsIn;}

MeasuredLinearValueType * PointDefinedSurfaceFeatureMeasurementType::getForm()
{return Form;}

void PointDefinedSurfaceFeatureMeasurementType::setForm(MeasuredLinearValueType * FormIn)
{Form = FormIn;}

/* ***************************************************************** */

/* class PointDefinedSurfaceFeatureNominalType

*/

PointDefinedSurfaceFeatureNominalType::PointDefinedSurfaceFeatureNominalType() :
  SurfaceFeatureNominalBaseType()
{
  DefiningPoints = 0;
  Constructed = 0;
}

PointDefinedSurfaceFeatureNominalType::PointDefinedSurfaceFeatureNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 DefiningPointsNominalType * DefiningPointsIn,
 PointDefinedSurfaceConstructionMethodType * ConstructedIn) :
  SurfaceFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  DefiningPoints = DefiningPointsIn;
  Constructed = ConstructedIn;
}

PointDefinedSurfaceFeatureNominalType::PointDefinedSurfaceFeatureNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 DefiningPointsNominalType * DefiningPointsIn,
 PointDefinedSurfaceConstructionMethodType * ConstructedIn) :
  SurfaceFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  DefiningPoints = DefiningPointsIn;
  Constructed = ConstructedIn;
}

PointDefinedSurfaceFeatureNominalType::~PointDefinedSurfaceFeatureNominalType()
{
  #ifndef NODESTRUCT
  delete DefiningPoints;
  delete Constructed;
  #endif
}

void PointDefinedSurfaceFeatureNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<DefiningPoints");
  DefiningPoints->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DefiningPoints>\n");
  if (Constructed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool PointDefinedSurfaceFeatureNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PointDefinedSurfaceFeatureNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PointDefinedSurfaceFeatureNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PointDefinedSurfaceFeatureNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PointDefinedSurfaceFeatureNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

DefiningPointsNominalType * PointDefinedSurfaceFeatureNominalType::getDefiningPoints()
{return DefiningPoints;}

void PointDefinedSurfaceFeatureNominalType::setDefiningPoints(DefiningPointsNominalType * DefiningPointsIn)
{DefiningPoints = DefiningPointsIn;}

PointDefinedSurfaceConstructionMethodType * PointDefinedSurfaceFeatureNominalType::getConstructed()
{return Constructed;}

void PointDefinedSurfaceFeatureNominalType::setConstructed(PointDefinedSurfaceConstructionMethodType * ConstructedIn)
{Constructed = ConstructedIn;}

/* ***************************************************************** */

/* class PointDefinedSurfaceMeasurementDeterminationType

*/

PointDefinedSurfaceMeasurementDeterminationType::PointDefinedSurfaceMeasurementDeterminationType()
{
  PointDefinedSurfaceMeasurementDeterminationTypePair = 0;
}

PointDefinedSurfaceMeasurementDeterminationType::PointDefinedSurfaceMeasurementDeterminationType(
 PointDefinedSurfaceMeasurementDeterminationTypeChoicePair * PointDefinedSurfaceMeasurementDeterminationTypePairIn)
{
  PointDefinedSurfaceMeasurementDeterminationTypePair = PointDefinedSurfaceMeasurementDeterminationTypePairIn;
}

PointDefinedSurfaceMeasurementDeterminationType::~PointDefinedSurfaceMeasurementDeterminationType()
{
  #ifndef NODESTRUCT
  delete PointDefinedSurfaceMeasurementDeterminationTypePair;
  #endif
}

void PointDefinedSurfaceMeasurementDeterminationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  PointDefinedSurfaceMeasurementDeterminationTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

PointDefinedSurfaceMeasurementDeterminationTypeChoicePair * PointDefinedSurfaceMeasurementDeterminationType::getPointDefinedSurfaceMeasurementDeterminationTypePair()
{return PointDefinedSurfaceMeasurementDeterminationTypePair;}

void PointDefinedSurfaceMeasurementDeterminationType::setPointDefinedSurfaceMeasurementDeterminationTypePair(PointDefinedSurfaceMeasurementDeterminationTypeChoicePair * PointDefinedSurfaceMeasurementDeterminationTypePairIn)
{PointDefinedSurfaceMeasurementDeterminationTypePair = PointDefinedSurfaceMeasurementDeterminationTypePairIn;}
PointDefinedSurfaceMeasurementDeterminationTypeChoicePair::PointDefinedSurfaceMeasurementDeterminationTypeChoicePair() {}

PointDefinedSurfaceMeasurementDeterminationTypeChoicePair::PointDefinedSurfaceMeasurementDeterminationTypeChoicePair(
 whichOne PointDefinedSurfaceMeasurementDeterminationTypeTypeIn,
 PointDefinedSurfaceMeasurementDeterminationTypeVal * PointDefinedSurfaceMeasurementDeterminationTypeValueIn)
{
  PointDefinedSurfaceMeasurementDeterminationTypeType = PointDefinedSurfaceMeasurementDeterminationTypeTypeIn;
  PointDefinedSurfaceMeasurementDeterminationTypeValue = PointDefinedSurfaceMeasurementDeterminationTypeValueIn;
}

PointDefinedSurfaceMeasurementDeterminationTypeChoicePair::~PointDefinedSurfaceMeasurementDeterminationTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (PointDefinedSurfaceMeasurementDeterminationTypeType == CheckedE)
    delete PointDefinedSurfaceMeasurementDeterminationTypeValue->Checked;
  else if (PointDefinedSurfaceMeasurementDeterminationTypeType == SetE)
    delete PointDefinedSurfaceMeasurementDeterminationTypeValue->Set;
  delete PointDefinedSurfaceMeasurementDeterminationTypeValue;
  #endif
}

void PointDefinedSurfaceMeasurementDeterminationTypeChoicePair::printSelf(FILE * outFile)
{
  if (PointDefinedSurfaceMeasurementDeterminationTypeType == CheckedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Checked");
      PointDefinedSurfaceMeasurementDeterminationTypeValue->Checked->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Checked>\n");
    }
  else if (PointDefinedSurfaceMeasurementDeterminationTypeType == SetE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Set");
      PointDefinedSurfaceMeasurementDeterminationTypeValue->Set->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class PointDefinedSurfaceRecompType

*/

PointDefinedSurfaceRecompType::PointDefinedSurfaceRecompType() :
  ConstructionMethodBaseType()
{
  BaseFeaturePointList = 0;
}

PointDefinedSurfaceRecompType::PointDefinedSurfaceRecompType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeaturePointListType * BaseFeaturePointListIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeaturePointList = BaseFeaturePointListIn;
}

PointDefinedSurfaceRecompType::~PointDefinedSurfaceRecompType()
{
  #ifndef NODESTRUCT
  delete BaseFeaturePointList;
  #endif
}

void PointDefinedSurfaceRecompType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeaturePointList");
  BaseFeaturePointList->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeaturePointList>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeaturePointListType * PointDefinedSurfaceRecompType::getBaseFeaturePointList()
{return BaseFeaturePointList;}

void PointDefinedSurfaceRecompType::setBaseFeaturePointList(BaseFeaturePointListType * BaseFeaturePointListIn)
{BaseFeaturePointList = BaseFeaturePointListIn;}

/* ***************************************************************** */

/* class PointDefinedSurfaceTransformType

*/

PointDefinedSurfaceTransformType::PointDefinedSurfaceTransformType() :
  ConstructionMethodBaseType()
{
  BasePointDefinedSurface = 0;
  Transformation = 0;
}

PointDefinedSurfaceTransformType::PointDefinedSurfaceTransformType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BasePointDefinedSurfaceIn,
 TransformationReferenceType * TransformationIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BasePointDefinedSurface = BasePointDefinedSurfaceIn;
  Transformation = TransformationIn;
}

PointDefinedSurfaceTransformType::~PointDefinedSurfaceTransformType()
{
  #ifndef NODESTRUCT
  delete BasePointDefinedSurface;
  delete Transformation;
  #endif
}

void PointDefinedSurfaceTransformType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BasePointDefinedSurface");
  BasePointDefinedSurface->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BasePointDefinedSurface>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Transformation");
  Transformation->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Transformation>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * PointDefinedSurfaceTransformType::getBasePointDefinedSurface()
{return BasePointDefinedSurface;}

void PointDefinedSurfaceTransformType::setBasePointDefinedSurface(BaseFeatureType * BasePointDefinedSurfaceIn)
{BasePointDefinedSurface = BasePointDefinedSurfaceIn;}

TransformationReferenceType * PointDefinedSurfaceTransformType::getTransformation()
{return Transformation;}

void PointDefinedSurfaceTransformType::setTransformation(TransformationReferenceType * TransformationIn)
{Transformation = TransformationIn;}

/* ***************************************************************** */

/* class PointFeatureCastType

*/

PointFeatureCastType::PointFeatureCastType() :
  ConstructionMethodBaseType()
{
  BaseFeature = 0;
}

PointFeatureCastType::PointFeatureCastType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeature = BaseFeatureIn;
}

PointFeatureCastType::~PointFeatureCastType()
{
  #ifndef NODESTRUCT
  delete BaseFeature;
  #endif
}

void PointFeatureCastType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeature");
  BaseFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * PointFeatureCastType::getBaseFeature()
{return BaseFeature;}

void PointFeatureCastType::setBaseFeature(BaseFeatureType * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class PointFeatureCenterOfGravityType

*/

PointFeatureCenterOfGravityType::PointFeatureCenterOfGravityType() :
  ConstructionMethodBaseType()
{
  n = 0;
  BaseFeature = 0;
}

PointFeatureCenterOfGravityType::PointFeatureCenterOfGravityType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = 0;
  BaseFeature = BaseFeatureIn;
}

PointFeatureCenterOfGravityType::PointFeatureCenterOfGravityType(
 XmlBoolean * NominalsCalculatedIn,
 NaturalType * nIn,
 BaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = nIn;
  BaseFeature = BaseFeatureIn;
}

PointFeatureCenterOfGravityType::~PointFeatureCenterOfGravityType()
{
  #ifndef NODESTRUCT
  delete n;
  delete BaseFeature;
  #endif
}

void PointFeatureCenterOfGravityType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  {
    if (!BaseFeature)
      {
        fprintf(stderr, "BaseFeature list is missing\n");
        exit(1);
      }
    if (BaseFeature->size() == 0)
      {
        fprintf(stderr, "BaseFeature list is empty\n");
        exit(1);
      }
    if (BaseFeature->size() < 3)
      {
        fprintf(stderr,
                "size of BaseFeature list (%d) less than minimum required (3)\n",
                (int)BaseFeature->size());
        exit(1);
      }
    std::list<BaseFeatureType *>::iterator iter;
    for (iter = BaseFeature->begin();
         iter != BaseFeature->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<BaseFeature");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</BaseFeature>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool PointFeatureCenterOfGravityType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in PointFeatureCenterOfGravityType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in PointFeatureCenterOfGravityType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PointFeatureCenterOfGravityType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in PointFeatureCenterOfGravityType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * PointFeatureCenterOfGravityType::getn()
{return n;}

void PointFeatureCenterOfGravityType::setn(NaturalType * nIn)
{n = nIn;}

BaseFeatureTypeLisd * PointFeatureCenterOfGravityType::getBaseFeature()
{return BaseFeature;}

void PointFeatureCenterOfGravityType::setBaseFeature(BaseFeatureTypeLisd * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class PointFeatureCopyType

*/

PointFeatureCopyType::PointFeatureCopyType() :
  ConstructionMethodBaseType()
{
  BasePointFeature = 0;
}

PointFeatureCopyType::PointFeatureCopyType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BasePointFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BasePointFeature = BasePointFeatureIn;
}

PointFeatureCopyType::~PointFeatureCopyType()
{
  #ifndef NODESTRUCT
  delete BasePointFeature;
  #endif
}

void PointFeatureCopyType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BasePointFeature");
  BasePointFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BasePointFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * PointFeatureCopyType::getBasePointFeature()
{return BasePointFeature;}

void PointFeatureCopyType::setBasePointFeature(BaseFeatureType * BasePointFeatureIn)
{BasePointFeature = BasePointFeatureIn;}

/* ***************************************************************** */

/* class PointFeatureDefinitionBaseType

*/

PointFeatureDefinitionBaseType::PointFeatureDefinitionBaseType() :
  ShapeFeatureDefinitionBaseType()
{
}

PointFeatureDefinitionBaseType::PointFeatureDefinitionBaseType(
 AttributesType * AttributesIn) :
  ShapeFeatureDefinitionBaseType(
    AttributesIn)
{
}

PointFeatureDefinitionBaseType::PointFeatureDefinitionBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn) :
  ShapeFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
}

PointFeatureDefinitionBaseType::~PointFeatureDefinitionBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void PointFeatureDefinitionBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool PointFeatureDefinitionBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PointFeatureDefinitionBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PointFeatureDefinitionBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PointFeatureDefinitionBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PointFeatureDefinitionBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class PointFeatureDefinitionType

*/

PointFeatureDefinitionType::PointFeatureDefinitionType() :
  PointFeatureDefinitionBaseType()
{
}

PointFeatureDefinitionType::PointFeatureDefinitionType(
 AttributesType * AttributesIn) :
  PointFeatureDefinitionBaseType(
    AttributesIn)
{
}

PointFeatureDefinitionType::PointFeatureDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn) :
  PointFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
}

PointFeatureDefinitionType::~PointFeatureDefinitionType()
{
  #ifndef NODESTRUCT
  #endif
}

void PointFeatureDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool PointFeatureDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PointFeatureDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PointFeatureDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PointFeatureDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PointFeatureDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class PointFeatureExtremeType

*/

PointFeatureExtremeType::PointFeatureExtremeType() :
  ConstructionMethodBaseType()
{
  BaseFeature = 0;
  Minimum = 0;
  PointFeatureExt_1097 = 0;
}

PointFeatureExtremeType::PointFeatureExtremeType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseFeatureIn,
 XmlBoolean * MinimumIn,
 PointFeatureExt_1097_Type * PointFeatureExt_1097In) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeature = BaseFeatureIn;
  Minimum = MinimumIn;
  PointFeatureExt_1097 = PointFeatureExt_1097In;
}

PointFeatureExtremeType::~PointFeatureExtremeType()
{
  #ifndef NODESTRUCT
  delete BaseFeature;
  delete Minimum;
  delete PointFeatureExt_1097;
  #endif
}

void PointFeatureExtremeType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeature");
  BaseFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeature>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Minimum");
  Minimum->printSelf(outFile);
  fprintf(outFile, "</Minimum>\n");
  PointFeatureExt_1097->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * PointFeatureExtremeType::getBaseFeature()
{return BaseFeature;}

void PointFeatureExtremeType::setBaseFeature(BaseFeatureType * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

XmlBoolean * PointFeatureExtremeType::getMinimum()
{return Minimum;}

void PointFeatureExtremeType::setMinimum(XmlBoolean * MinimumIn)
{Minimum = MinimumIn;}

PointFeatureExt_1097_Type * PointFeatureExtremeType::getPointFeatureExt_1097()
{return PointFeatureExt_1097;}

void PointFeatureExtremeType::setPointFeatureExt_1097(PointFeatureExt_1097_Type * PointFeatureExt_1097In)
{PointFeatureExt_1097 = PointFeatureExt_1097In;}

/* ***************************************************************** */

/* class PointFeatureFromConeType

*/

PointFeatureFromConeType::PointFeatureFromConeType() :
  ConstructionMethodBaseType()
{
  BaseCone = 0;
}

PointFeatureFromConeType::PointFeatureFromConeType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseConeIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseCone = BaseConeIn;
}

PointFeatureFromConeType::~PointFeatureFromConeType()
{
  #ifndef NODESTRUCT
  delete BaseCone;
  #endif
}

void PointFeatureFromConeType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseCone");
  BaseCone->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseCone>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * PointFeatureFromConeType::getBaseCone()
{return BaseCone;}

void PointFeatureFromConeType::setBaseCone(BaseFeatureType * BaseConeIn)
{BaseCone = BaseConeIn;}

/* ***************************************************************** */

/* class PointFeatureFromScanType

*/

PointFeatureFromScanType::PointFeatureFromScanType() :
  ConstructionMethodBaseType()
{
  SurfaceFeature = 0;
  SearchRadius = 0;
  RetrievalMethod = 0;
}

PointFeatureFromScanType::PointFeatureFromScanType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * SurfaceFeatureIn,
 LinearValueType * SearchRadiusIn,
 RetrievalMethodEnumType * RetrievalMethodIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  SurfaceFeature = SurfaceFeatureIn;
  SearchRadius = SearchRadiusIn;
  RetrievalMethod = RetrievalMethodIn;
}

PointFeatureFromScanType::~PointFeatureFromScanType()
{
  #ifndef NODESTRUCT
  delete SurfaceFeature;
  delete SearchRadius;
  delete RetrievalMethod;
  #endif
}

void PointFeatureFromScanType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<SurfaceFeature");
  SurfaceFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</SurfaceFeature>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<SearchRadius");
  SearchRadius->printSelf(outFile);
  fprintf(outFile, "</SearchRadius>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<RetrievalMethod");
  RetrievalMethod->printSelf(outFile);
  fprintf(outFile, "</RetrievalMethod>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * PointFeatureFromScanType::getSurfaceFeature()
{return SurfaceFeature;}

void PointFeatureFromScanType::setSurfaceFeature(BaseFeatureType * SurfaceFeatureIn)
{SurfaceFeature = SurfaceFeatureIn;}

LinearValueType * PointFeatureFromScanType::getSearchRadius()
{return SearchRadius;}

void PointFeatureFromScanType::setSearchRadius(LinearValueType * SearchRadiusIn)
{SearchRadius = SearchRadiusIn;}

RetrievalMethodEnumType * PointFeatureFromScanType::getRetrievalMethod()
{return RetrievalMethod;}

void PointFeatureFromScanType::setRetrievalMethod(RetrievalMethodEnumType * RetrievalMethodIn)
{RetrievalMethod = RetrievalMethodIn;}

/* ***************************************************************** */

/* class PointFeatureIntersectionType

*/

PointFeatureIntersectionType::PointFeatureIntersectionType() :
  ConstructionMethodBaseType()
{
  IntersectionFeature = 0;
}

PointFeatureIntersectionType::PointFeatureIntersectionType(
 XmlBoolean * NominalsCalculatedIn,
 SequencedBaseFeatureTypeLisd * IntersectionFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  IntersectionFeature = IntersectionFeatureIn;
}

PointFeatureIntersectionType::~PointFeatureIntersectionType()
{
  #ifndef NODESTRUCT
  delete IntersectionFeature;
  #endif
}

void PointFeatureIntersectionType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  {
    if (!IntersectionFeature)
      {
        fprintf(stderr, "IntersectionFeature list is missing\n");
        exit(1);
      }
    if (IntersectionFeature->size() == 0)
      {
        fprintf(stderr, "IntersectionFeature list is empty\n");
        exit(1);
      }
    if (IntersectionFeature->size() > 2)
      {
        fprintf(stderr,
                "size of IntersectionFeature list (%d) greater than maximum allowed (2)\n",
                (int)IntersectionFeature->size());
        exit(1);
      }
    if (IntersectionFeature->size() < 2)
      {
        fprintf(stderr,
                "size of IntersectionFeature list (%d) less than minimum required (2)\n",
                (int)IntersectionFeature->size());
        exit(1);
      }
    std::list<SequencedBaseFeatureType *>::iterator iter;
    for (iter = IntersectionFeature->begin();
         iter != IntersectionFeature->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<IntersectionFeature");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</IntersectionFeature>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

SequencedBaseFeatureTypeLisd * PointFeatureIntersectionType::getIntersectionFeature()
{return IntersectionFeature;}

void PointFeatureIntersectionType::setIntersectionFeature(SequencedBaseFeatureTypeLisd * IntersectionFeatureIn)
{IntersectionFeature = IntersectionFeatureIn;}

/* ***************************************************************** */

/* class PointFeatureItemBaseType

*/

PointFeatureItemBaseType::PointFeatureItemBaseType() :
  ShapeFeatureItemBaseType()
{
}

PointFeatureItemBaseType::PointFeatureItemBaseType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  ShapeFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
}

PointFeatureItemBaseType::PointFeatureItemBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  ShapeFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
}

PointFeatureItemBaseType::~PointFeatureItemBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void PointFeatureItemBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool PointFeatureItemBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PointFeatureItemBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PointFeatureItemBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PointFeatureItemBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PointFeatureItemBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class PointFeatureItemType

*/

PointFeatureItemType::PointFeatureItemType() :
  PointFeatureItemBaseType()
{
  DeterminationMode = 0;
}

PointFeatureItemType::PointFeatureItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 PointMeasurementDeterminationType * DeterminationModeIn) :
  PointFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

PointFeatureItemType::PointFeatureItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 PointMeasurementDeterminationType * DeterminationModeIn) :
  PointFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

PointFeatureItemType::~PointFeatureItemType()
{
  #ifndef NODESTRUCT
  delete DeterminationMode;
  #endif
}

void PointFeatureItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<DeterminationMode");
  DeterminationMode->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeterminationMode>\n");
  doSpaces(-INDENT, outFile);
}

bool PointFeatureItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PointFeatureItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PointFeatureItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PointFeatureItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PointFeatureItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

PointMeasurementDeterminationType * PointFeatureItemType::getDeterminationMode()
{return DeterminationMode;}

void PointFeatureItemType::setDeterminationMode(PointMeasurementDeterminationType * DeterminationModeIn)
{DeterminationMode = DeterminationModeIn;}

/* ***************************************************************** */

/* class PointFeatureMeasurementBaseType

*/

PointFeatureMeasurementBaseType::PointFeatureMeasurementBaseType() :
  ShapeFeatureMeasurementBaseType()
{
}

PointFeatureMeasurementBaseType::PointFeatureMeasurementBaseType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn) :
  ShapeFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
}

PointFeatureMeasurementBaseType::PointFeatureMeasurementBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn) :
  ShapeFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
}

PointFeatureMeasurementBaseType::~PointFeatureMeasurementBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void PointFeatureMeasurementBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool PointFeatureMeasurementBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PointFeatureMeasurementBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PointFeatureMeasurementBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PointFeatureMeasurementBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PointFeatureMeasurementBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class PointFeatureMeasurementType

*/

PointFeatureMeasurementType::PointFeatureMeasurementType() :
  PointFeatureMeasurementBaseType()
{
  Location = 0;
  Normal = 0;
}

PointFeatureMeasurementType::PointFeatureMeasurementType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredPointType * LocationIn,
 MeasuredUnitVectorType * NormalIn) :
  PointFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Location = LocationIn;
  Normal = NormalIn;
}

PointFeatureMeasurementType::PointFeatureMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredPointType * LocationIn,
 MeasuredUnitVectorType * NormalIn) :
  PointFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Location = LocationIn;
  Normal = NormalIn;
}

PointFeatureMeasurementType::~PointFeatureMeasurementType()
{
  #ifndef NODESTRUCT
  delete Location;
  delete Normal;
  #endif
}

void PointFeatureMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  if (Location)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Location");
      Location->printSelf(outFile);
      fprintf(outFile, "</Location>\n");
    }
  if (Normal)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Normal");
      Normal->printSelf(outFile);
      fprintf(outFile, "</Normal>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool PointFeatureMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PointFeatureMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PointFeatureMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PointFeatureMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PointFeatureMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredPointType * PointFeatureMeasurementType::getLocation()
{return Location;}

void PointFeatureMeasurementType::setLocation(MeasuredPointType * LocationIn)
{Location = LocationIn;}

MeasuredUnitVectorType * PointFeatureMeasurementType::getNormal()
{return Normal;}

void PointFeatureMeasurementType::setNormal(MeasuredUnitVectorType * NormalIn)
{Normal = NormalIn;}

/* ***************************************************************** */

/* class PointFeatureMidPointType

*/

PointFeatureMidPointType::PointFeatureMidPointType() :
  ConstructionMethodBaseType()
{
  BaseFeature = 0;
}

PointFeatureMidPointType::PointFeatureMidPointType(
 XmlBoolean * NominalsCalculatedIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeature = BaseFeatureIn;
}

PointFeatureMidPointType::~PointFeatureMidPointType()
{
  #ifndef NODESTRUCT
  delete BaseFeature;
  #endif
}

void PointFeatureMidPointType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  {
    if (!BaseFeature)
      {
        fprintf(stderr, "BaseFeature list is missing\n");
        exit(1);
      }
    if (BaseFeature->size() == 0)
      {
        fprintf(stderr, "BaseFeature list is empty\n");
        exit(1);
      }
    if (BaseFeature->size() > 2)
      {
        fprintf(stderr,
                "size of BaseFeature list (%d) greater than maximum allowed (2)\n",
                (int)BaseFeature->size());
        exit(1);
      }
    if (BaseFeature->size() < 2)
      {
        fprintf(stderr,
                "size of BaseFeature list (%d) less than minimum required (2)\n",
                (int)BaseFeature->size());
        exit(1);
      }
    std::list<SequencedBaseFeatureType *>::iterator iter;
    for (iter = BaseFeature->begin();
         iter != BaseFeature->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<BaseFeature");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</BaseFeature>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

SequencedBaseFeatureTypeLisd * PointFeatureMidPointType::getBaseFeature()
{return BaseFeature;}

void PointFeatureMidPointType::setBaseFeature(SequencedBaseFeatureTypeLisd * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class PointFeatureMovePointAxisType

*/

PointFeatureMovePointAxisType::PointFeatureMovePointAxisType() :
  ConstructionMethodBaseType()
{
  BaseLocationFeature = 0;
  Distance = 0;
  BaseAxisFeature = 0;
}

PointFeatureMovePointAxisType::PointFeatureMovePointAxisType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseLocationFeatureIn,
 LinearValueType * DistanceIn,
 BaseFeatureType * BaseAxisFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseLocationFeature = BaseLocationFeatureIn;
  Distance = DistanceIn;
  BaseAxisFeature = BaseAxisFeatureIn;
}

PointFeatureMovePointAxisType::~PointFeatureMovePointAxisType()
{
  #ifndef NODESTRUCT
  delete BaseLocationFeature;
  delete Distance;
  delete BaseAxisFeature;
  #endif
}

void PointFeatureMovePointAxisType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseLocationFeature");
  BaseLocationFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseLocationFeature>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Distance");
  Distance->printSelf(outFile);
  fprintf(outFile, "</Distance>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseAxisFeature");
  BaseAxisFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseAxisFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * PointFeatureMovePointAxisType::getBaseLocationFeature()
{return BaseLocationFeature;}

void PointFeatureMovePointAxisType::setBaseLocationFeature(BaseFeatureType * BaseLocationFeatureIn)
{BaseLocationFeature = BaseLocationFeatureIn;}

LinearValueType * PointFeatureMovePointAxisType::getDistance()
{return Distance;}

void PointFeatureMovePointAxisType::setDistance(LinearValueType * DistanceIn)
{Distance = DistanceIn;}

BaseFeatureType * PointFeatureMovePointAxisType::getBaseAxisFeature()
{return BaseAxisFeature;}

void PointFeatureMovePointAxisType::setBaseAxisFeature(BaseFeatureType * BaseAxisFeatureIn)
{BaseAxisFeature = BaseAxisFeatureIn;}

/* ***************************************************************** */

/* class PointFeatureMovePointType

*/

PointFeatureMovePointType::PointFeatureMovePointType() :
  ConstructionMethodBaseType()
{
  BaseFeature = 0;
  PointFeatureMov_1098 = 0;
}

PointFeatureMovePointType::PointFeatureMovePointType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseFeatureIn,
 PointFeatureMov_1098_Type * PointFeatureMov_1098In) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeature = BaseFeatureIn;
  PointFeatureMov_1098 = PointFeatureMov_1098In;
}

PointFeatureMovePointType::~PointFeatureMovePointType()
{
  #ifndef NODESTRUCT
  delete BaseFeature;
  delete PointFeatureMov_1098;
  #endif
}

void PointFeatureMovePointType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeature");
  BaseFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeature>\n");
  PointFeatureMov_1098->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * PointFeatureMovePointType::getBaseFeature()
{return BaseFeature;}

void PointFeatureMovePointType::setBaseFeature(BaseFeatureType * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

PointFeatureMov_1098_Type * PointFeatureMovePointType::getPointFeatureMov_1098()
{return PointFeatureMov_1098;}

void PointFeatureMovePointType::setPointFeatureMov_1098(PointFeatureMov_1098_Type * PointFeatureMov_1098In)
{PointFeatureMov_1098 = PointFeatureMov_1098In;}

/* ***************************************************************** */

/* class PointFeatureMovePointVectorType

*/

PointFeatureMovePointVectorType::PointFeatureMovePointVectorType() :
  ConstructionMethodBaseType()
{
  BaseFeature = 0;
  Distance = 0;
  Vector = 0;
}

PointFeatureMovePointVectorType::PointFeatureMovePointVectorType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseFeatureIn,
 LinearValueType * DistanceIn,
 UnitVectorType * VectorIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeature = BaseFeatureIn;
  Distance = DistanceIn;
  Vector = VectorIn;
}

PointFeatureMovePointVectorType::~PointFeatureMovePointVectorType()
{
  #ifndef NODESTRUCT
  delete BaseFeature;
  delete Distance;
  delete Vector;
  #endif
}

void PointFeatureMovePointVectorType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeature");
  BaseFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeature>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Distance");
  Distance->printSelf(outFile);
  fprintf(outFile, "</Distance>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Vector");
  Vector->printSelf(outFile);
  fprintf(outFile, "</Vector>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * PointFeatureMovePointVectorType::getBaseFeature()
{return BaseFeature;}

void PointFeatureMovePointVectorType::setBaseFeature(BaseFeatureType * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

LinearValueType * PointFeatureMovePointVectorType::getDistance()
{return Distance;}

void PointFeatureMovePointVectorType::setDistance(LinearValueType * DistanceIn)
{Distance = DistanceIn;}

UnitVectorType * PointFeatureMovePointVectorType::getVector()
{return Vector;}

void PointFeatureMovePointVectorType::setVector(UnitVectorType * VectorIn)
{Vector = VectorIn;}

/* ***************************************************************** */

/* class PointFeatureNominalBaseType

*/

PointFeatureNominalBaseType::PointFeatureNominalBaseType() :
  ShapeFeatureNominalBaseType()
{
  PointFeatureNominalBaseTypePair = 0;
}

PointFeatureNominalBaseType::PointFeatureNominalBaseType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 PointFeatureNominalBaseTypeChoicePair * PointFeatureNominalBaseTypePairIn) :
  ShapeFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  PointFeatureNominalBaseTypePair = PointFeatureNominalBaseTypePairIn;
}

PointFeatureNominalBaseType::PointFeatureNominalBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 PointFeatureNominalBaseTypeChoicePair * PointFeatureNominalBaseTypePairIn) :
  ShapeFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  PointFeatureNominalBaseTypePair = PointFeatureNominalBaseTypePairIn;
}

PointFeatureNominalBaseType::~PointFeatureNominalBaseType()
{
  #ifndef NODESTRUCT
  delete PointFeatureNominalBaseTypePair;
  #endif
}

void PointFeatureNominalBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (PointFeatureNominalBaseTypePair)
    {
      PointFeatureNominalBaseTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}
PointFeatureNominalBaseTypeChoicePair * PointFeatureNominalBaseType::getPointFeatureNominalBaseTypeChoicePair()
{return PointFeatureNominalBaseTypePair;}

void PointFeatureNominalBaseType::setPointFeatureNominalBaseTypeChoicePair(PointFeatureNominalBaseTypeChoicePair * PointFeatureNominalBaseTypePairIn)
{PointFeatureNominalBaseTypePair = PointFeatureNominalBaseTypePairIn;}

/* ***************************************************************** */

PointFeatureNominalBaseTypeChoicePair::PointFeatureNominalBaseTypeChoicePair() {}

PointFeatureNominalBaseTypeChoicePair::PointFeatureNominalBaseTypeChoicePair(
 whichOne PointFeatureNominalBaseTypeTypeIn,
 PointFeatureNominalBaseTypeVal * PointFeatureNominalBaseTypeValueIn)
{
  PointFeatureNominalBaseTypeType = PointFeatureNominalBaseTypeTypeIn;
  PointFeatureNominalBaseTypeValue = PointFeatureNominalBaseTypeValueIn;
}

PointFeatureNominalBaseTypeChoicePair::~PointFeatureNominalBaseTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (PointFeatureNominalBaseTypeType == SurfaceFeatureNominalIdE)
    delete PointFeatureNominalBaseTypeValue->SurfaceFeatureNominalId;
  else if (PointFeatureNominalBaseTypeType == CurveFeatureNominalIdE)
    delete PointFeatureNominalBaseTypeValue->CurveFeatureNominalId;
  delete PointFeatureNominalBaseTypeValue;
  #endif
}

void PointFeatureNominalBaseTypeChoicePair::printSelf(FILE * outFile)
{
  if (PointFeatureNominalBaseTypeType == SurfaceFeatureNominalIdE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SurfaceFeatureNominalId");
      PointFeatureNominalBaseTypeValue->SurfaceFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</SurfaceFeatureNominalId>\n");
    }
  else if (PointFeatureNominalBaseTypeType == CurveFeatureNominalIdE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CurveFeatureNominalId");
      PointFeatureNominalBaseTypeValue->CurveFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</CurveFeatureNominalId>\n");
    }
}

bool PointFeatureNominalBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PointFeatureNominalBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PointFeatureNominalBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PointFeatureNominalBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PointFeatureNominalBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class PointFeatureNominalType

*/

PointFeatureNominalType::PointFeatureNominalType() :
  PointFeatureNominalBaseType()
{
  Location = 0;
  Normal = 0;
  Constructed = 0;
}

PointFeatureNominalType::PointFeatureNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 PointFeatureNominalBaseTypeChoicePair * PointFeatureNominalBaseTypePairIn,
 PointType * LocationIn,
 UnitVectorType * NormalIn,
 PointConstructionMethodType * ConstructedIn) :
  PointFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    PointFeatureNominalBaseTypePairIn)
{
  Location = LocationIn;
  Normal = NormalIn;
  Constructed = ConstructedIn;
}

PointFeatureNominalType::PointFeatureNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 PointFeatureNominalBaseTypeChoicePair * PointFeatureNominalBaseTypePairIn,
 PointType * LocationIn,
 UnitVectorType * NormalIn,
 PointConstructionMethodType * ConstructedIn) :
  PointFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    PointFeatureNominalBaseTypePairIn)
{
  Location = LocationIn;
  Normal = NormalIn;
  Constructed = ConstructedIn;
}

PointFeatureNominalType::~PointFeatureNominalType()
{
  #ifndef NODESTRUCT
  delete Location;
  delete Normal;
  delete Constructed;
  #endif
}

void PointFeatureNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (PointFeatureNominalBaseTypePair)
    {
      PointFeatureNominalBaseTypePair->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Location");
  Location->printSelf(outFile);
  fprintf(outFile, "</Location>\n");
  if (Normal)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Normal");
      Normal->printSelf(outFile);
      fprintf(outFile, "</Normal>\n");
    }
  if (Constructed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool PointFeatureNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PointFeatureNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PointFeatureNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PointFeatureNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PointFeatureNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

PointType * PointFeatureNominalType::getLocation()
{return Location;}

void PointFeatureNominalType::setLocation(PointType * LocationIn)
{Location = LocationIn;}

UnitVectorType * PointFeatureNominalType::getNormal()
{return Normal;}

void PointFeatureNominalType::setNormal(UnitVectorType * NormalIn)
{Normal = NormalIn;}

PointConstructionMethodType * PointFeatureNominalType::getConstructed()
{return Constructed;}

void PointFeatureNominalType::setConstructed(PointConstructionMethodType * ConstructedIn)
{Constructed = ConstructedIn;}

/* ***************************************************************** */

/* class PointFeaturePierceType

*/

PointFeaturePierceType::PointFeaturePierceType() :
  ConstructionMethodBaseType()
{
  SurfaceFeature = 0;
  CurveFeature = 0;
}

PointFeaturePierceType::PointFeaturePierceType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * SurfaceFeatureIn,
 BaseFeatureType * CurveFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  SurfaceFeature = SurfaceFeatureIn;
  CurveFeature = CurveFeatureIn;
}

PointFeaturePierceType::~PointFeaturePierceType()
{
  #ifndef NODESTRUCT
  delete SurfaceFeature;
  delete CurveFeature;
  #endif
}

void PointFeaturePierceType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<SurfaceFeature");
  SurfaceFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</SurfaceFeature>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CurveFeature");
  CurveFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</CurveFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * PointFeaturePierceType::getSurfaceFeature()
{return SurfaceFeature;}

void PointFeaturePierceType::setSurfaceFeature(BaseFeatureType * SurfaceFeatureIn)
{SurfaceFeature = SurfaceFeatureIn;}

BaseFeatureType * PointFeaturePierceType::getCurveFeature()
{return CurveFeature;}

void PointFeaturePierceType::setCurveFeature(BaseFeatureType * CurveFeatureIn)
{CurveFeature = CurveFeatureIn;}

/* ***************************************************************** */

/* class PointFeatureProjectionType

*/

PointFeatureProjectionType::PointFeatureProjectionType() :
  ConstructionMethodBaseType()
{
  ProjectionPlane = 0;
  ProjectionFeature = 0;
}

PointFeatureProjectionType::PointFeatureProjectionType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * ProjectionPlaneIn,
 BaseFeatureType * ProjectionFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  ProjectionPlane = ProjectionPlaneIn;
  ProjectionFeature = ProjectionFeatureIn;
}

PointFeatureProjectionType::~PointFeatureProjectionType()
{
  #ifndef NODESTRUCT
  delete ProjectionPlane;
  delete ProjectionFeature;
  #endif
}

void PointFeatureProjectionType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ProjectionPlane");
  ProjectionPlane->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ProjectionPlane>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<ProjectionFeature");
  ProjectionFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ProjectionFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * PointFeatureProjectionType::getProjectionPlane()
{return ProjectionPlane;}

void PointFeatureProjectionType::setProjectionPlane(BaseFeatureType * ProjectionPlaneIn)
{ProjectionPlane = ProjectionPlaneIn;}

BaseFeatureType * PointFeatureProjectionType::getProjectionFeature()
{return ProjectionFeature;}

void PointFeatureProjectionType::setProjectionFeature(BaseFeatureType * ProjectionFeatureIn)
{ProjectionFeature = ProjectionFeatureIn;}

/* ***************************************************************** */

/* class PointFeatureTransformType

*/

PointFeatureTransformType::PointFeatureTransformType() :
  ConstructionMethodBaseType()
{
  BasePointFeature = 0;
  Transformation = 0;
}

PointFeatureTransformType::PointFeatureTransformType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BasePointFeatureIn,
 TransformationReferenceType * TransformationIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BasePointFeature = BasePointFeatureIn;
  Transformation = TransformationIn;
}

PointFeatureTransformType::~PointFeatureTransformType()
{
  #ifndef NODESTRUCT
  delete BasePointFeature;
  delete Transformation;
  #endif
}

void PointFeatureTransformType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BasePointFeature");
  BasePointFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BasePointFeature>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Transformation");
  Transformation->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Transformation>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * PointFeatureTransformType::getBasePointFeature()
{return BasePointFeature;}

void PointFeatureTransformType::setBasePointFeature(BaseFeatureType * BasePointFeatureIn)
{BasePointFeature = BasePointFeatureIn;}

TransformationReferenceType * PointFeatureTransformType::getTransformation()
{return Transformation;}

void PointFeatureTransformType::setTransformation(TransformationReferenceType * TransformationIn)
{Transformation = TransformationIn;}

/* ***************************************************************** */

/* class PointIndexType

*/

PointIndexType::PointIndexType()
{
  PointIndexTypePair = 0;
}

PointIndexType::PointIndexType(
 PointIndexTypeChoicePair * PointIndexTypePairIn)
{
  PointIndexTypePair = PointIndexTypePairIn;
}

PointIndexType::~PointIndexType()
{
  #ifndef NODESTRUCT
  delete PointIndexTypePair;
  #endif
}

void PointIndexType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  PointIndexTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

PointIndexTypeChoicePair * PointIndexType::getPointIndexTypePair()
{return PointIndexTypePair;}

void PointIndexType::setPointIndexTypePair(PointIndexTypeChoicePair * PointIndexTypePairIn)
{PointIndexTypePair = PointIndexTypePairIn;}
PointIndexTypeChoicePair::PointIndexTypeChoicePair() {}

PointIndexTypeChoicePair::PointIndexTypeChoicePair(
 whichOne PointIndexTypeTypeIn,
 PointIndexTypeVal * PointIndexTypeValueIn)
{
  PointIndexTypeType = PointIndexTypeTypeIn;
  PointIndexTypeValue = PointIndexTypeValueIn;
}

PointIndexTypeChoicePair::~PointIndexTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (PointIndexTypeType == SingleE)
    delete PointIndexTypeValue->Single;
  else if (PointIndexTypeType == RangeE)
    delete PointIndexTypeValue->Range;
  else if (PointIndexTypeType == AllE)
    delete PointIndexTypeValue->All;
  delete PointIndexTypeValue;
  #endif
}

void PointIndexTypeChoicePair::printSelf(FILE * outFile)
{
  if (PointIndexTypeType == SingleE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Single");
      PointIndexTypeValue->Single->printSelf(outFile);
      fprintf(outFile, "</Single>\n");
    }
  else if (PointIndexTypeType == RangeE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Range");
      PointIndexTypeValue->Range->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Range>\n");
    }
  else if (PointIndexTypeType == AllE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<All");
      PointIndexTypeValue->All->printSelf(outFile);
      fprintf(outFile, "</All>\n");
    }
}

/* ***************************************************************** */

/* class PointListType

*/

PointListType::PointListType()
{
  n = 0;
  PointSetId = 0;
}

PointListType::PointListType(
 PointSetReferenceBaseTypeLisd * PointSetIdIn)
{
  n = 0;
  PointSetId = PointSetIdIn;
}

PointListType::PointListType(
 NaturalType * nIn,
 PointSetReferenceBaseTypeLisd * PointSetIdIn)
{
  n = nIn;
  PointSetId = PointSetIdIn;
}

PointListType::~PointListType()
{
  #ifndef NODESTRUCT
  delete n;
  delete PointSetId;
  #endif
}

void PointListType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!PointSetId)
      {
        fprintf(stderr, "PointSetId list is missing\n");
        exit(1);
      }
    if (PointSetId->size() == 0)
      {
        fprintf(stderr, "PointSetId list is empty\n");
        exit(1);
      }
    if (PointSetId->size() < 1)
      {
        fprintf(stderr,
                "size of PointSetId list (%d) less than minimum required (1)\n",
                (int)PointSetId->size());
        exit(1);
      }
    std::list<PointSetReferenceBaseType *>::iterator iter;
    for (iter = PointSetId->begin();
         iter != PointSetId->end(); iter++)
      {
        PointSetReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->getprintElement(), "WholePointSetId") == 0)
          {
            PointSetReferenceWholeType * typ;
            if ((typ = dynamic_cast<PointSetReferenceWholeType *>(basie)))
              {
                fprintf(outFile, "<WholePointSetId");
                typ->printSelf(outFile);
                fprintf(outFile, "</WholePointSetId>\n");
              }
            else
              {
                fprintf(stderr, "bad WholePointSetId element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "RangePointSetId") == 0)
          {
            PointSetReferenceRangeType * typ;
            if ((typ = dynamic_cast<PointSetReferenceRangeType *>(basie)))
              {
                fprintf(outFile, "<RangePointSetId");
                typ->printSelf(outFile);
                fprintf(outFile, "</RangePointSetId>\n");
              }
            else
              {
                fprintf(stderr, "bad RangePointSetId element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SinglePointSetId") == 0)
          {
            PointSetReferenceSingleType * typ;
            if ((typ = dynamic_cast<PointSetReferenceSingleType *>(basie)))
              {
                fprintf(outFile, "<SinglePointSetId");
                typ->printSelf(outFile);
                fprintf(outFile, "</SinglePointSetId>\n");
              }
            else
              {
                fprintf(stderr, "bad SinglePointSetId element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad PointSetId type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool PointListType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in PointListType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in PointListType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PointListType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in PointListType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * PointListType::getn()
{return n;}

void PointListType::setn(NaturalType * nIn)
{n = nIn;}

PointSetReferenceBaseTypeLisd * PointListType::getPointSetId()
{return PointSetId;}

void PointListType::setPointSetId(PointSetReferenceBaseTypeLisd * PointSetIdIn)
{PointSetId = PointSetIdIn;}

/* ***************************************************************** */

/* class PointMeasurementDeterminationType

*/

PointMeasurementDeterminationType::PointMeasurementDeterminationType()
{
  PointMeasurementDeterminationTypePair = 0;
}

PointMeasurementDeterminationType::PointMeasurementDeterminationType(
 PointMeasurementDeterminationTypeChoicePair * PointMeasurementDeterminationTypePairIn)
{
  PointMeasurementDeterminationTypePair = PointMeasurementDeterminationTypePairIn;
}

PointMeasurementDeterminationType::~PointMeasurementDeterminationType()
{
  #ifndef NODESTRUCT
  delete PointMeasurementDeterminationTypePair;
  #endif
}

void PointMeasurementDeterminationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  PointMeasurementDeterminationTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

PointMeasurementDeterminationTypeChoicePair * PointMeasurementDeterminationType::getPointMeasurementDeterminationTypePair()
{return PointMeasurementDeterminationTypePair;}

void PointMeasurementDeterminationType::setPointMeasurementDeterminationTypePair(PointMeasurementDeterminationTypeChoicePair * PointMeasurementDeterminationTypePairIn)
{PointMeasurementDeterminationTypePair = PointMeasurementDeterminationTypePairIn;}
PointMeasurementDeterminationTypeChoicePair::PointMeasurementDeterminationTypeChoicePair() {}

PointMeasurementDeterminationTypeChoicePair::PointMeasurementDeterminationTypeChoicePair(
 whichOne PointMeasurementDeterminationTypeTypeIn,
 PointMeasurementDeterminationTypeVal * PointMeasurementDeterminationTypeValueIn)
{
  PointMeasurementDeterminationTypeType = PointMeasurementDeterminationTypeTypeIn;
  PointMeasurementDeterminationTypeValue = PointMeasurementDeterminationTypeValueIn;
}

PointMeasurementDeterminationTypeChoicePair::~PointMeasurementDeterminationTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (PointMeasurementDeterminationTypeType == CheckedE)
    delete PointMeasurementDeterminationTypeValue->Checked;
  else if (PointMeasurementDeterminationTypeType == SetE)
    delete PointMeasurementDeterminationTypeValue->Set;
  delete PointMeasurementDeterminationTypeValue;
  #endif
}

void PointMeasurementDeterminationTypeChoicePair::printSelf(FILE * outFile)
{
  if (PointMeasurementDeterminationTypeType == CheckedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Checked");
      PointMeasurementDeterminationTypeValue->Checked->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Checked>\n");
    }
  else if (PointMeasurementDeterminationTypeType == SetE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Set");
      PointMeasurementDeterminationTypeValue->Set->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class PointRangeType

*/

PointRangeType::PointRangeType()
{
  Start = 0;
  Stop = 0;
}

PointRangeType::PointRangeType(
 NaturalType * StartIn,
 NaturalType * StopIn)
{
  Start = StartIn;
  Stop = StopIn;
}

PointRangeType::~PointRangeType()
{
  #ifndef NODESTRUCT
  delete Start;
  delete Stop;
  #endif
}

void PointRangeType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Start");
  Start->printSelf(outFile);
  fprintf(outFile, "</Start>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Stop");
  Stop->printSelf(outFile);
  fprintf(outFile, "</Stop>\n");
  doSpaces(-INDENT, outFile);
}

NaturalType * PointRangeType::getStart()
{return Start;}

void PointRangeType::setStart(NaturalType * StartIn)
{Start = StartIn;}

NaturalType * PointRangeType::getStop()
{return Stop;}

void PointRangeType::setStop(NaturalType * StopIn)
{Stop = StopIn;}

/* ***************************************************************** */

/* class PointSetNominalType

*/

PointSetNominalType::PointSetNominalType()
{
  decimalPlaces = 0;
  id = 0;
  linearUnit = 0;
  n = 0;
  significantFigures = 0;
  validity = 0;
  xDecimalPlaces = 0;
  xSignificantFigures = 0;
  xValidity = 0;
  yDecimalPlaces = 0;
  ySignificantFigures = 0;
  yValidity = 0;
  zDecimalPlaces = 0;
  zSignificantFigures = 0;
  zValidity = 0;
  MeasurePoint = 0;
}

PointSetNominalType::PointSetNominalType(
 MeasurePointNominalTypeLisd * MeasurePointIn)
{
  decimalPlaces = 0;
  id = 0;
  linearUnit = 0;
  n = 0;
  significantFigures = 0;
  validity = 0;
  xDecimalPlaces = 0;
  xSignificantFigures = 0;
  xValidity = 0;
  yDecimalPlaces = 0;
  ySignificantFigures = 0;
  yValidity = 0;
  zDecimalPlaces = 0;
  zSignificantFigures = 0;
  zValidity = 0;
  MeasurePoint = MeasurePointIn;
}

PointSetNominalType::PointSetNominalType(
 XmlNonNegativeInteger * decimalPlacesIn,
 QIFIdType * idIn,
 XmlToken * linearUnitIn,
 NaturalType * nIn,
 XmlNonNegativeInteger * significantFiguresIn,
 ValidityEnumType * validityIn,
 XmlNonNegativeInteger * xDecimalPlacesIn,
 XmlNonNegativeInteger * xSignificantFiguresIn,
 ValidityEnumType * xValidityIn,
 XmlNonNegativeInteger * yDecimalPlacesIn,
 XmlNonNegativeInteger * ySignificantFiguresIn,
 ValidityEnumType * yValidityIn,
 XmlNonNegativeInteger * zDecimalPlacesIn,
 XmlNonNegativeInteger * zSignificantFiguresIn,
 ValidityEnumType * zValidityIn,
 MeasurePointNominalTypeLisd * MeasurePointIn)
{
  decimalPlaces = decimalPlacesIn;
  id = idIn;
  linearUnit = linearUnitIn;
  n = nIn;
  significantFigures = significantFiguresIn;
  validity = validityIn;
  xDecimalPlaces = xDecimalPlacesIn;
  xSignificantFigures = xSignificantFiguresIn;
  xValidity = xValidityIn;
  yDecimalPlaces = yDecimalPlacesIn;
  ySignificantFigures = ySignificantFiguresIn;
  yValidity = yValidityIn;
  zDecimalPlaces = zDecimalPlacesIn;
  zSignificantFigures = zSignificantFiguresIn;
  zValidity = zValidityIn;
  MeasurePoint = MeasurePointIn;
}

PointSetNominalType::~PointSetNominalType()
{
  #ifndef NODESTRUCT
  delete decimalPlaces;
  delete id;
  delete linearUnit;
  delete n;
  delete significantFigures;
  delete validity;
  delete xDecimalPlaces;
  delete xSignificantFigures;
  delete xValidity;
  delete yDecimalPlaces;
  delete ySignificantFigures;
  delete yValidity;
  delete zDecimalPlaces;
  delete zSignificantFigures;
  delete zValidity;
  delete MeasurePoint;
  #endif
}

void PointSetNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (decimalPlaces)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "decimalPlaces=\"");
      decimalPlaces->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  if (linearUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "linearUnit=\"");
      linearUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  if (significantFigures)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "significantFigures=\"");
      significantFigures->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (validity)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "validity=\"");
      validity->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (xDecimalPlaces)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "xDecimalPlaces=\"");
      xDecimalPlaces->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (xSignificantFigures)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "xSignificantFigures=\"");
      xSignificantFigures->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (xValidity)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "xValidity=\"");
      xValidity->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (yDecimalPlaces)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "yDecimalPlaces=\"");
      yDecimalPlaces->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (ySignificantFigures)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "ySignificantFigures=\"");
      ySignificantFigures->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (yValidity)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "yValidity=\"");
      yValidity->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (zDecimalPlaces)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "zDecimalPlaces=\"");
      zDecimalPlaces->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (zSignificantFigures)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "zSignificantFigures=\"");
      zSignificantFigures->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  if (zValidity)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "zValidity=\"");
      zValidity->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!MeasurePoint)
      {
        fprintf(stderr, "MeasurePoint list is missing\n");
        exit(1);
      }
    if (MeasurePoint->size() == 0)
      {
        fprintf(stderr, "MeasurePoint list is empty\n");
        exit(1);
      }
    if (MeasurePoint->size() < 1)
      {
        fprintf(stderr,
                "size of MeasurePoint list (%d) less than minimum required (1)\n",
                (int)MeasurePoint->size());
        exit(1);
      }
    std::list<MeasurePointNominalType *>::iterator iter;
    for (iter = MeasurePoint->begin();
         iter != MeasurePoint->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<MeasurePoint");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</MeasurePoint>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool PointSetNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "decimalPlaces")
        {
          XmlNonNegativeInteger * decimalPlacesVal;
          if (this->decimalPlaces)
            {
              fprintf(stderr, "two values for decimalPlaces in PointSetNominalType\n");
              returnValue = true;
              break;
            }
          decimalPlacesVal = new XmlNonNegativeInteger(decl->getval().c_str());
          if (decimalPlacesVal->getbad())
            {
              delete decimalPlacesVal;
              fprintf(stderr, "bad value %s for decimalPlaces in PointSetNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->decimalPlaces = decimalPlacesVal;
        }
      else if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in PointSetNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in PointSetNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else if (decl->getname() == "linearUnit")
        {
          XmlToken * linearUnitVal;
          if (this->linearUnit)
            {
              fprintf(stderr, "two values for linearUnit in PointSetNominalType\n");
              returnValue = true;
              break;
            }
          linearUnitVal = new XmlToken(decl->getval().c_str());
          if (linearUnitVal->getbad())
            {
              delete linearUnitVal;
              fprintf(stderr, "bad value %s for linearUnit in PointSetNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->linearUnit = linearUnitVal;
        }
      else if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in PointSetNominalType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in PointSetNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else if (decl->getname() == "significantFigures")
        {
          XmlNonNegativeInteger * significantFiguresVal;
          if (this->significantFigures)
            {
              fprintf(stderr, "two values for significantFigures in PointSetNominalType\n");
              returnValue = true;
              break;
            }
          significantFiguresVal = new XmlNonNegativeInteger(decl->getval().c_str());
          if (significantFiguresVal->getbad())
            {
              delete significantFiguresVal;
              fprintf(stderr, "bad value %s for significantFigures in PointSetNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->significantFigures = significantFiguresVal;
        }
      else if (decl->getname() == "validity")
        {
          ValidityEnumType * validityVal;
          if (this->validity)
            {
              fprintf(stderr, "two values for validity in PointSetNominalType\n");
              returnValue = true;
              break;
            }
          validityVal = new ValidityEnumType(decl->getval().c_str());
          if (validityVal->getbad())
            {
              delete validityVal;
              fprintf(stderr, "bad value %s for validity in PointSetNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->validity = validityVal;
        }
      else if (decl->getname() == "xDecimalPlaces")
        {
          XmlNonNegativeInteger * xDecimalPlacesVal;
          if (this->xDecimalPlaces)
            {
              fprintf(stderr, "two values for xDecimalPlaces in PointSetNominalType\n");
              returnValue = true;
              break;
            }
          xDecimalPlacesVal = new XmlNonNegativeInteger(decl->getval().c_str());
          if (xDecimalPlacesVal->getbad())
            {
              delete xDecimalPlacesVal;
              fprintf(stderr, "bad value %s for xDecimalPlaces in PointSetNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->xDecimalPlaces = xDecimalPlacesVal;
        }
      else if (decl->getname() == "xSignificantFigures")
        {
          XmlNonNegativeInteger * xSignificantFiguresVal;
          if (this->xSignificantFigures)
            {
              fprintf(stderr, "two values for xSignificantFigures in PointSetNominalType\n");
              returnValue = true;
              break;
            }
          xSignificantFiguresVal = new XmlNonNegativeInteger(decl->getval().c_str());
          if (xSignificantFiguresVal->getbad())
            {
              delete xSignificantFiguresVal;
              fprintf(stderr, "bad value %s for xSignificantFigures in PointSetNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->xSignificantFigures = xSignificantFiguresVal;
        }
      else if (decl->getname() == "xValidity")
        {
          ValidityEnumType * xValidityVal;
          if (this->xValidity)
            {
              fprintf(stderr, "two values for xValidity in PointSetNominalType\n");
              returnValue = true;
              break;
            }
          xValidityVal = new ValidityEnumType(decl->getval().c_str());
          if (xValidityVal->getbad())
            {
              delete xValidityVal;
              fprintf(stderr, "bad value %s for xValidity in PointSetNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->xValidity = xValidityVal;
        }
      else if (decl->getname() == "yDecimalPlaces")
        {
          XmlNonNegativeInteger * yDecimalPlacesVal;
          if (this->yDecimalPlaces)
            {
              fprintf(stderr, "two values for yDecimalPlaces in PointSetNominalType\n");
              returnValue = true;
              break;
            }
          yDecimalPlacesVal = new XmlNonNegativeInteger(decl->getval().c_str());
          if (yDecimalPlacesVal->getbad())
            {
              delete yDecimalPlacesVal;
              fprintf(stderr, "bad value %s for yDecimalPlaces in PointSetNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->yDecimalPlaces = yDecimalPlacesVal;
        }
      else if (decl->getname() == "ySignificantFigures")
        {
          XmlNonNegativeInteger * ySignificantFiguresVal;
          if (this->ySignificantFigures)
            {
              fprintf(stderr, "two values for ySignificantFigures in PointSetNominalType\n");
              returnValue = true;
              break;
            }
          ySignificantFiguresVal = new XmlNonNegativeInteger(decl->getval().c_str());
          if (ySignificantFiguresVal->getbad())
            {
              delete ySignificantFiguresVal;
              fprintf(stderr, "bad value %s for ySignificantFigures in PointSetNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->ySignificantFigures = ySignificantFiguresVal;
        }
      else if (decl->getname() == "yValidity")
        {
          ValidityEnumType * yValidityVal;
          if (this->yValidity)
            {
              fprintf(stderr, "two values for yValidity in PointSetNominalType\n");
              returnValue = true;
              break;
            }
          yValidityVal = new ValidityEnumType(decl->getval().c_str());
          if (yValidityVal->getbad())
            {
              delete yValidityVal;
              fprintf(stderr, "bad value %s for yValidity in PointSetNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->yValidity = yValidityVal;
        }
      else if (decl->getname() == "zDecimalPlaces")
        {
          XmlNonNegativeInteger * zDecimalPlacesVal;
          if (this->zDecimalPlaces)
            {
              fprintf(stderr, "two values for zDecimalPlaces in PointSetNominalType\n");
              returnValue = true;
              break;
            }
          zDecimalPlacesVal = new XmlNonNegativeInteger(decl->getval().c_str());
          if (zDecimalPlacesVal->getbad())
            {
              delete zDecimalPlacesVal;
              fprintf(stderr, "bad value %s for zDecimalPlaces in PointSetNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->zDecimalPlaces = zDecimalPlacesVal;
        }
      else if (decl->getname() == "zSignificantFigures")
        {
          XmlNonNegativeInteger * zSignificantFiguresVal;
          if (this->zSignificantFigures)
            {
              fprintf(stderr, "two values for zSignificantFigures in PointSetNominalType\n");
              returnValue = true;
              break;
            }
          zSignificantFiguresVal = new XmlNonNegativeInteger(decl->getval().c_str());
          if (zSignificantFiguresVal->getbad())
            {
              delete zSignificantFiguresVal;
              fprintf(stderr, "bad value %s for zSignificantFigures in PointSetNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->zSignificantFigures = zSignificantFiguresVal;
        }
      else if (decl->getname() == "zValidity")
        {
          ValidityEnumType * zValidityVal;
          if (this->zValidity)
            {
              fprintf(stderr, "two values for zValidity in PointSetNominalType\n");
              returnValue = true;
              break;
            }
          zValidityVal = new ValidityEnumType(decl->getval().c_str());
          if (zValidityVal->getbad())
            {
              delete zValidityVal;
              fprintf(stderr, "bad value %s for zValidity in PointSetNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->zValidity = zValidityVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PointSetNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in PointSetNominalType\n");
      returnValue = true;
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in PointSetNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->decimalPlaces;
      this->decimalPlaces = 0;
      delete this->id;
      this->id = 0;
      delete this->linearUnit;
      this->linearUnit = 0;
      delete this->n;
      this->n = 0;
      delete this->significantFigures;
      this->significantFigures = 0;
      delete this->validity;
      this->validity = 0;
      delete this->xDecimalPlaces;
      this->xDecimalPlaces = 0;
      delete this->xSignificantFigures;
      this->xSignificantFigures = 0;
      delete this->xValidity;
      this->xValidity = 0;
      delete this->yDecimalPlaces;
      this->yDecimalPlaces = 0;
      delete this->ySignificantFigures;
      this->ySignificantFigures = 0;
      delete this->yValidity;
      this->yValidity = 0;
      delete this->zDecimalPlaces;
      this->zDecimalPlaces = 0;
      delete this->zSignificantFigures;
      this->zSignificantFigures = 0;
      delete this->zValidity;
      this->zValidity = 0;
    }
  return returnValue;
}

XmlNonNegativeInteger * PointSetNominalType::getdecimalPlaces()
{return decimalPlaces;}

void PointSetNominalType::setdecimalPlaces(XmlNonNegativeInteger * decimalPlacesIn)
{decimalPlaces = decimalPlacesIn;}

QIFIdType * PointSetNominalType::getid()
{return id;}

void PointSetNominalType::setid(QIFIdType * idIn)
{id = idIn;}

XmlToken * PointSetNominalType::getlinearUnit()
{return linearUnit;}

void PointSetNominalType::setlinearUnit(XmlToken * linearUnitIn)
{linearUnit = linearUnitIn;}

NaturalType * PointSetNominalType::getn()
{return n;}

void PointSetNominalType::setn(NaturalType * nIn)
{n = nIn;}

XmlNonNegativeInteger * PointSetNominalType::getsignificantFigures()
{return significantFigures;}

void PointSetNominalType::setsignificantFigures(XmlNonNegativeInteger * significantFiguresIn)
{significantFigures = significantFiguresIn;}

ValidityEnumType * PointSetNominalType::getvalidity()
{return validity;}

void PointSetNominalType::setvalidity(ValidityEnumType * validityIn)
{validity = validityIn;}

XmlNonNegativeInteger * PointSetNominalType::getxDecimalPlaces()
{return xDecimalPlaces;}

void PointSetNominalType::setxDecimalPlaces(XmlNonNegativeInteger * xDecimalPlacesIn)
{xDecimalPlaces = xDecimalPlacesIn;}

XmlNonNegativeInteger * PointSetNominalType::getxSignificantFigures()
{return xSignificantFigures;}

void PointSetNominalType::setxSignificantFigures(XmlNonNegativeInteger * xSignificantFiguresIn)
{xSignificantFigures = xSignificantFiguresIn;}

ValidityEnumType * PointSetNominalType::getxValidity()
{return xValidity;}

void PointSetNominalType::setxValidity(ValidityEnumType * xValidityIn)
{xValidity = xValidityIn;}

XmlNonNegativeInteger * PointSetNominalType::getyDecimalPlaces()
{return yDecimalPlaces;}

void PointSetNominalType::setyDecimalPlaces(XmlNonNegativeInteger * yDecimalPlacesIn)
{yDecimalPlaces = yDecimalPlacesIn;}

XmlNonNegativeInteger * PointSetNominalType::getySignificantFigures()
{return ySignificantFigures;}

void PointSetNominalType::setySignificantFigures(XmlNonNegativeInteger * ySignificantFiguresIn)
{ySignificantFigures = ySignificantFiguresIn;}

ValidityEnumType * PointSetNominalType::getyValidity()
{return yValidity;}

void PointSetNominalType::setyValidity(ValidityEnumType * yValidityIn)
{yValidity = yValidityIn;}

XmlNonNegativeInteger * PointSetNominalType::getzDecimalPlaces()
{return zDecimalPlaces;}

void PointSetNominalType::setzDecimalPlaces(XmlNonNegativeInteger * zDecimalPlacesIn)
{zDecimalPlaces = zDecimalPlacesIn;}

XmlNonNegativeInteger * PointSetNominalType::getzSignificantFigures()
{return zSignificantFigures;}

void PointSetNominalType::setzSignificantFigures(XmlNonNegativeInteger * zSignificantFiguresIn)
{zSignificantFigures = zSignificantFiguresIn;}

ValidityEnumType * PointSetNominalType::getzValidity()
{return zValidity;}

void PointSetNominalType::setzValidity(ValidityEnumType * zValidityIn)
{zValidity = zValidityIn;}

MeasurePointNominalTypeLisd * PointSetNominalType::getMeasurePoint()
{return MeasurePoint;}

void PointSetNominalType::setMeasurePoint(MeasurePointNominalTypeLisd * MeasurePointIn)
{MeasurePoint = MeasurePointIn;}

/* ***************************************************************** */

/* class PointSetNominalTypeLisd

*/

PointSetNominalTypeLisd::PointSetNominalTypeLisd() {}

PointSetNominalTypeLisd::PointSetNominalTypeLisd(PointSetNominalType * aPointSetNominalType)
{
  push_back(aPointSetNominalType);
}

PointSetNominalTypeLisd::~PointSetNominalTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<PointSetNominalType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void PointSetNominalTypeLisd::printSelf(FILE * outFile)
{
  std::list<PointSetNominalType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class SetFeatureType

*/

SetFeatureType::SetFeatureType()
{}

SetFeatureType::~SetFeatureType() {}

void SetFeatureType::printSelf(FILE * outFile)
{
  fprintf(outFile, "/>\n");
}

/* ***************************************************************** */

/* class ShapeFeatureDefinitionBaseType

*/

ShapeFeatureDefinitionBaseType::ShapeFeatureDefinitionBaseType() :
  FeatureDefinitionBaseType()
{
}

ShapeFeatureDefinitionBaseType::ShapeFeatureDefinitionBaseType(
 AttributesType * AttributesIn) :
  FeatureDefinitionBaseType(
    AttributesIn)
{
}

ShapeFeatureDefinitionBaseType::ShapeFeatureDefinitionBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn) :
  FeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
}

ShapeFeatureDefinitionBaseType::~ShapeFeatureDefinitionBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void ShapeFeatureDefinitionBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ShapeFeatureDefinitionBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ShapeFeatureDefinitionBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ShapeFeatureDefinitionBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ShapeFeatureDefinitionBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ShapeFeatureDefinitionBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class ShapeFeatureItemBaseType

*/

ShapeFeatureItemBaseType::ShapeFeatureItemBaseType() :
  FeatureItemBaseType()
{
  PointList = 0;
  SubstituteFeatureAlgorithm = 0;
  VirtualMeasurement = 0;
}

ShapeFeatureItemBaseType::ShapeFeatureItemBaseType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  FeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn)
{
  PointList = PointListIn;
  SubstituteFeatureAlgorithm = SubstituteFeatureAlgorithmIn;
  VirtualMeasurement = VirtualMeasurementIn;
}

ShapeFeatureItemBaseType::ShapeFeatureItemBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  FeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn)
{
  PointList = PointListIn;
  SubstituteFeatureAlgorithm = SubstituteFeatureAlgorithmIn;
  VirtualMeasurement = VirtualMeasurementIn;
}

ShapeFeatureItemBaseType::~ShapeFeatureItemBaseType()
{
  #ifndef NODESTRUCT
  delete PointList;
  delete SubstituteFeatureAlgorithm;
  delete VirtualMeasurement;
  #endif
}

void ShapeFeatureItemBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool ShapeFeatureItemBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ShapeFeatureItemBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ShapeFeatureItemBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ShapeFeatureItemBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ShapeFeatureItemBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

PointListType * ShapeFeatureItemBaseType::getPointList()
{return PointList;}

void ShapeFeatureItemBaseType::setPointList(PointListType * PointListIn)
{PointList = PointListIn;}

SubstituteFeatureAlgorithmType * ShapeFeatureItemBaseType::getSubstituteFeatureAlgorithm()
{return SubstituteFeatureAlgorithm;}

void ShapeFeatureItemBaseType::setSubstituteFeatureAlgorithm(SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn)
{SubstituteFeatureAlgorithm = SubstituteFeatureAlgorithmIn;}

VirtualMeasurementType * ShapeFeatureItemBaseType::getVirtualMeasurement()
{return VirtualMeasurement;}

void ShapeFeatureItemBaseType::setVirtualMeasurement(VirtualMeasurementType * VirtualMeasurementIn)
{VirtualMeasurement = VirtualMeasurementIn;}

/* ***************************************************************** */

/* class ShapeFeatureMeasurementBaseType

*/

ShapeFeatureMeasurementBaseType::ShapeFeatureMeasurementBaseType() :
  FeatureMeasurementBaseType()
{
  PointList = 0;
  SubstituteFeatureAlgorithm = 0;
  ProxyMeasurementId = 0;
}

ShapeFeatureMeasurementBaseType::ShapeFeatureMeasurementBaseType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn) :
  FeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn)
{
  PointList = PointListIn;
  SubstituteFeatureAlgorithm = SubstituteFeatureAlgorithmIn;
  ProxyMeasurementId = ProxyMeasurementIdIn;
}

ShapeFeatureMeasurementBaseType::ShapeFeatureMeasurementBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn) :
  FeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn)
{
  PointList = PointListIn;
  SubstituteFeatureAlgorithm = SubstituteFeatureAlgorithmIn;
  ProxyMeasurementId = ProxyMeasurementIdIn;
}

ShapeFeatureMeasurementBaseType::~ShapeFeatureMeasurementBaseType()
{
  #ifndef NODESTRUCT
  delete PointList;
  delete SubstituteFeatureAlgorithm;
  delete ProxyMeasurementId;
  #endif
}

void ShapeFeatureMeasurementBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ShapeFeatureMeasurementBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ShapeFeatureMeasurementBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ShapeFeatureMeasurementBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ShapeFeatureMeasurementBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ShapeFeatureMeasurementBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

PointListType * ShapeFeatureMeasurementBaseType::getPointList()
{return PointList;}

void ShapeFeatureMeasurementBaseType::setPointList(PointListType * PointListIn)
{PointList = PointListIn;}

SubstituteFeatureAlgorithmType * ShapeFeatureMeasurementBaseType::getSubstituteFeatureAlgorithm()
{return SubstituteFeatureAlgorithm;}

void ShapeFeatureMeasurementBaseType::setSubstituteFeatureAlgorithm(SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn)
{SubstituteFeatureAlgorithm = SubstituteFeatureAlgorithmIn;}

QIFReferenceType * ShapeFeatureMeasurementBaseType::getProxyMeasurementId()
{return ProxyMeasurementId;}

void ShapeFeatureMeasurementBaseType::setProxyMeasurementId(QIFReferenceType * ProxyMeasurementIdIn)
{ProxyMeasurementId = ProxyMeasurementIdIn;}

/* ***************************************************************** */

/* class ShapeFeatureNominalBaseType

*/

ShapeFeatureNominalBaseType::ShapeFeatureNominalBaseType() :
  FeatureNominalBaseType()
{
  PointList = 0;
  SubstituteFeatureAlgorithm = 0;
}

ShapeFeatureNominalBaseType::ShapeFeatureNominalBaseType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn) :
  FeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn)
{
  PointList = PointListIn;
  SubstituteFeatureAlgorithm = SubstituteFeatureAlgorithmIn;
}

ShapeFeatureNominalBaseType::ShapeFeatureNominalBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn) :
  FeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn)
{
  PointList = PointListIn;
  SubstituteFeatureAlgorithm = SubstituteFeatureAlgorithmIn;
}

ShapeFeatureNominalBaseType::~ShapeFeatureNominalBaseType()
{
  #ifndef NODESTRUCT
  delete PointList;
  delete SubstituteFeatureAlgorithm;
  #endif
}

void ShapeFeatureNominalBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ShapeFeatureNominalBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ShapeFeatureNominalBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ShapeFeatureNominalBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ShapeFeatureNominalBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ShapeFeatureNominalBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

PointListType * ShapeFeatureNominalBaseType::getPointList()
{return PointList;}

void ShapeFeatureNominalBaseType::setPointList(PointListType * PointListIn)
{PointList = PointListIn;}

SubstituteFeatureAlgorithmType * ShapeFeatureNominalBaseType::getSubstituteFeatureAlgorithm()
{return SubstituteFeatureAlgorithm;}

void ShapeFeatureNominalBaseType::setSubstituteFeatureAlgorithm(SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn)
{SubstituteFeatureAlgorithm = SubstituteFeatureAlgorithmIn;}

/* ***************************************************************** */

/* class SpecifiedFeatureDefinitionBaseType

*/

SpecifiedFeatureDefinitionBaseType::SpecifiedFeatureDefinitionBaseType() :
  ShapeFeatureDefinitionBaseType()
{
}

SpecifiedFeatureDefinitionBaseType::SpecifiedFeatureDefinitionBaseType(
 AttributesType * AttributesIn) :
  ShapeFeatureDefinitionBaseType(
    AttributesIn)
{
}

SpecifiedFeatureDefinitionBaseType::SpecifiedFeatureDefinitionBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn) :
  ShapeFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
}

SpecifiedFeatureDefinitionBaseType::~SpecifiedFeatureDefinitionBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void SpecifiedFeatureDefinitionBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SpecifiedFeatureDefinitionBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SpecifiedFeatureDefinitionBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SpecifiedFeatureDefinitionBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SpecifiedFeatureDefinitionBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SpecifiedFeatureDefinitionBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class SpecifiedFeatureItemBaseType

*/

SpecifiedFeatureItemBaseType::SpecifiedFeatureItemBaseType() :
  ShapeFeatureItemBaseType()
{
}

SpecifiedFeatureItemBaseType::SpecifiedFeatureItemBaseType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  ShapeFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
}

SpecifiedFeatureItemBaseType::SpecifiedFeatureItemBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  ShapeFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
}

SpecifiedFeatureItemBaseType::~SpecifiedFeatureItemBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void SpecifiedFeatureItemBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool SpecifiedFeatureItemBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SpecifiedFeatureItemBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SpecifiedFeatureItemBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SpecifiedFeatureItemBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SpecifiedFeatureItemBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class SpecifiedFeatureMeasurementBaseType

*/

SpecifiedFeatureMeasurementBaseType::SpecifiedFeatureMeasurementBaseType() :
  ShapeFeatureMeasurementBaseType()
{
}

SpecifiedFeatureMeasurementBaseType::SpecifiedFeatureMeasurementBaseType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn) :
  ShapeFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
}

SpecifiedFeatureMeasurementBaseType::SpecifiedFeatureMeasurementBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn) :
  ShapeFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
}

SpecifiedFeatureMeasurementBaseType::~SpecifiedFeatureMeasurementBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void SpecifiedFeatureMeasurementBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SpecifiedFeatureMeasurementBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SpecifiedFeatureMeasurementBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SpecifiedFeatureMeasurementBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SpecifiedFeatureMeasurementBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SpecifiedFeatureMeasurementBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class SpecifiedFeatureNominalBaseType

*/

SpecifiedFeatureNominalBaseType::SpecifiedFeatureNominalBaseType() :
  ShapeFeatureNominalBaseType()
{
}

SpecifiedFeatureNominalBaseType::SpecifiedFeatureNominalBaseType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn) :
  ShapeFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
}

SpecifiedFeatureNominalBaseType::SpecifiedFeatureNominalBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn) :
  ShapeFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
}

SpecifiedFeatureNominalBaseType::~SpecifiedFeatureNominalBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void SpecifiedFeatureNominalBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SpecifiedFeatureNominalBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SpecifiedFeatureNominalBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SpecifiedFeatureNominalBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SpecifiedFeatureNominalBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SpecifiedFeatureNominalBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class SphereBestFitType

*/

SphereBestFitType::SphereBestFitType() :
  ConstructionMethodBaseType()
{
  n = 0;
  BaseFeature = 0;
}

SphereBestFitType::SphereBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = 0;
  BaseFeature = BaseFeatureIn;
}

SphereBestFitType::SphereBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 NaturalType * nIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = nIn;
  BaseFeature = BaseFeatureIn;
}

SphereBestFitType::~SphereBestFitType()
{
  #ifndef NODESTRUCT
  delete n;
  delete BaseFeature;
  #endif
}

void SphereBestFitType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  {
    if (!BaseFeature)
      {
        fprintf(stderr, "BaseFeature list is missing\n");
        exit(1);
      }
    if (BaseFeature->size() == 0)
      {
        fprintf(stderr, "BaseFeature list is empty\n");
        exit(1);
      }
    if (BaseFeature->size() < 4)
      {
        fprintf(stderr,
                "size of BaseFeature list (%d) less than minimum required (4)\n",
                (int)BaseFeature->size());
        exit(1);
      }
    std::list<SequencedBaseFeatureType *>::iterator iter;
    for (iter = BaseFeature->begin();
         iter != BaseFeature->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<BaseFeature");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</BaseFeature>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool SphereBestFitType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in SphereBestFitType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in SphereBestFitType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SphereBestFitType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in SphereBestFitType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * SphereBestFitType::getn()
{return n;}

void SphereBestFitType::setn(NaturalType * nIn)
{n = nIn;}

SequencedBaseFeatureTypeLisd * SphereBestFitType::getBaseFeature()
{return BaseFeature;}

void SphereBestFitType::setBaseFeature(SequencedBaseFeatureTypeLisd * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class SphereCastType

*/

SphereCastType::SphereCastType() :
  ConstructionMethodBaseType()
{
  BaseFeature = 0;
}

SphereCastType::SphereCastType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeature = BaseFeatureIn;
}

SphereCastType::~SphereCastType()
{
  #ifndef NODESTRUCT
  delete BaseFeature;
  #endif
}

void SphereCastType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeature");
  BaseFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * SphereCastType::getBaseFeature()
{return BaseFeature;}

void SphereCastType::setBaseFeature(BaseFeatureType * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class SphereCheckedFeatureType

*/

SphereCheckedFeatureType::SphereCheckedFeatureType()
{
  CheckDetails = 0;
}

SphereCheckedFeatureType::SphereCheckedFeatureType(
 SphereCheckedType * CheckDetailsIn)
{
  CheckDetails = CheckDetailsIn;
}

SphereCheckedFeatureType::~SphereCheckedFeatureType()
{
  #ifndef NODESTRUCT
  delete CheckDetails;
  #endif
}

void SphereCheckedFeatureType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (CheckDetails)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CheckDetails");
      CheckDetails->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CheckDetails>\n");
    }
  doSpaces(-INDENT, outFile);
}

SphereCheckedType * SphereCheckedFeatureType::getCheckDetails()
{return CheckDetails;}

void SphereCheckedFeatureType::setCheckDetails(SphereCheckedType * CheckDetailsIn)
{CheckDetails = CheckDetailsIn;}

/* ***************************************************************** */

/* class SphereCheckedType

*/

SphereCheckedType::SphereCheckedType()
{
  SphereCheckedTypePair = 0;
}

SphereCheckedType::SphereCheckedType(
 SphereCheckedTypeChoicePair * SphereCheckedTypePairIn)
{
  SphereCheckedTypePair = SphereCheckedTypePairIn;
}

SphereCheckedType::~SphereCheckedType()
{
  #ifndef NODESTRUCT
  delete SphereCheckedTypePair;
  #endif
}

void SphereCheckedType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  SphereCheckedTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

SphereCheckedTypeChoicePair * SphereCheckedType::getSphereCheckedTypePair()
{return SphereCheckedTypePair;}

void SphereCheckedType::setSphereCheckedTypePair(SphereCheckedTypeChoicePair * SphereCheckedTypePairIn)
{SphereCheckedTypePair = SphereCheckedTypePairIn;}
SphereCheckedTypeChoicePair::SphereCheckedTypeChoicePair() {}

SphereCheckedTypeChoicePair::SphereCheckedTypeChoicePair(
 whichOne SphereCheckedTypeTypeIn,
 SphereCheckedTypeVal * SphereCheckedTypeValueIn)
{
  SphereCheckedTypeType = SphereCheckedTypeTypeIn;
  SphereCheckedTypeValue = SphereCheckedTypeValueIn;
}

SphereCheckedTypeChoicePair::~SphereCheckedTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (SphereCheckedTypeType == MeasuredE)
    delete SphereCheckedTypeValue->Measured;
  else if (SphereCheckedTypeType == ConstructedE)
    delete SphereCheckedTypeValue->Constructed;
  delete SphereCheckedTypeValue;
  #endif
}

void SphereCheckedTypeChoicePair::printSelf(FILE * outFile)
{
  if (SphereCheckedTypeType == MeasuredE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Measured");
      SphereCheckedTypeValue->Measured->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Measured>\n");
    }
  else if (SphereCheckedTypeType == ConstructedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      SphereCheckedTypeValue->Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
}

/* ***************************************************************** */

/* class SphereConstructionMethodType

*/

SphereConstructionMethodType::SphereConstructionMethodType()
{
  SphereConstructionMethodTypePair = 0;
}

SphereConstructionMethodType::SphereConstructionMethodType(
 SphereConstructionMethodTypeChoicePair * SphereConstructionMethodTypePairIn)
{
  SphereConstructionMethodTypePair = SphereConstructionMethodTypePairIn;
}

SphereConstructionMethodType::~SphereConstructionMethodType()
{
  #ifndef NODESTRUCT
  delete SphereConstructionMethodTypePair;
  #endif
}

void SphereConstructionMethodType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (SphereConstructionMethodTypePair)
    {
      SphereConstructionMethodTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

SphereConstructionMethodTypeChoicePair * SphereConstructionMethodType::getSphereConstructionMethodTypePair()
{return SphereConstructionMethodTypePair;}

void SphereConstructionMethodType::setSphereConstructionMethodTypePair(SphereConstructionMethodTypeChoicePair * SphereConstructionMethodTypePairIn)
{SphereConstructionMethodTypePair = SphereConstructionMethodTypePairIn;}
SphereConstructionMethodTypeChoicePair::SphereConstructionMethodTypeChoicePair() {}

SphereConstructionMethodTypeChoicePair::SphereConstructionMethodTypeChoicePair(
 whichOne SphereConstructionMethodTypeTypeIn,
 SphereConstructionMethodTypeVal * SphereConstructionMethodTypeValueIn)
{
  SphereConstructionMethodTypeType = SphereConstructionMethodTypeTypeIn;
  SphereConstructionMethodTypeValue = SphereConstructionMethodTypeValueIn;
}

SphereConstructionMethodTypeChoicePair::~SphereConstructionMethodTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (SphereConstructionMethodTypeType == BestFitE)
    delete SphereConstructionMethodTypeValue->BestFit;
  else if (SphereConstructionMethodTypeType == RecompensatedE)
    delete SphereConstructionMethodTypeValue->Recompensated;
  else if (SphereConstructionMethodTypeType == CopyE)
    delete SphereConstructionMethodTypeValue->Copy;
  else if (SphereConstructionMethodTypeType == CastE)
    delete SphereConstructionMethodTypeValue->Cast;
  else if (SphereConstructionMethodTypeType == TransformE)
    delete SphereConstructionMethodTypeValue->Transform;
  else if (SphereConstructionMethodTypeType == FromScanE)
    delete SphereConstructionMethodTypeValue->FromScan;
  delete SphereConstructionMethodTypeValue;
  #endif
}

void SphereConstructionMethodTypeChoicePair::printSelf(FILE * outFile)
{
  if (SphereConstructionMethodTypeType == BestFitE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BestFit");
      SphereConstructionMethodTypeValue->BestFit->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BestFit>\n");
    }
  else if (SphereConstructionMethodTypeType == RecompensatedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Recompensated");
      SphereConstructionMethodTypeValue->Recompensated->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Recompensated>\n");
    }
  else if (SphereConstructionMethodTypeType == CopyE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Copy");
      SphereConstructionMethodTypeValue->Copy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Copy>\n");
    }
  else if (SphereConstructionMethodTypeType == CastE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Cast");
      SphereConstructionMethodTypeValue->Cast->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Cast>\n");
    }
  else if (SphereConstructionMethodTypeType == TransformE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Transform");
      SphereConstructionMethodTypeValue->Transform->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Transform>\n");
    }
  else if (SphereConstructionMethodTypeType == FromScanE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FromScan");
      SphereConstructionMethodTypeValue->FromScan->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FromScan>\n");
    }
}

/* ***************************************************************** */

/* class SphereCopyType

*/

SphereCopyType::SphereCopyType() :
  ConstructionMethodBaseType()
{
  BaseSphere = 0;
}

SphereCopyType::SphereCopyType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseSphereIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseSphere = BaseSphereIn;
}

SphereCopyType::~SphereCopyType()
{
  #ifndef NODESTRUCT
  delete BaseSphere;
  #endif
}

void SphereCopyType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseSphere");
  BaseSphere->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseSphere>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * SphereCopyType::getBaseSphere()
{return BaseSphere;}

void SphereCopyType::setBaseSphere(BaseFeatureType * BaseSphereIn)
{BaseSphere = BaseSphereIn;}

/* ***************************************************************** */

/* class SphereFeatureDefinitionType

*/

SphereFeatureDefinitionType::SphereFeatureDefinitionType() :
  SurfaceFeatureDefinitionBaseType()
{
  InternalExternal = 0;
  Diameter = 0;
}

SphereFeatureDefinitionType::SphereFeatureDefinitionType(
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * DiameterIn) :
  SurfaceFeatureDefinitionBaseType(
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  Diameter = DiameterIn;
}

SphereFeatureDefinitionType::SphereFeatureDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * DiameterIn) :
  SurfaceFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  Diameter = DiameterIn;
}

SphereFeatureDefinitionType::~SphereFeatureDefinitionType()
{
  #ifndef NODESTRUCT
  delete InternalExternal;
  delete Diameter;
  #endif
}

void SphereFeatureDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<InternalExternal");
  InternalExternal->printSelf(outFile);
  fprintf(outFile, "</InternalExternal>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Diameter");
  Diameter->printSelf(outFile);
  fprintf(outFile, "</Diameter>\n");
  doSpaces(-INDENT, outFile);
}

bool SphereFeatureDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SphereFeatureDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SphereFeatureDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SphereFeatureDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SphereFeatureDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

InternalExternalEnumType * SphereFeatureDefinitionType::getInternalExternal()
{return InternalExternal;}

void SphereFeatureDefinitionType::setInternalExternal(InternalExternalEnumType * InternalExternalIn)
{InternalExternal = InternalExternalIn;}

LinearValueType * SphereFeatureDefinitionType::getDiameter()
{return Diameter;}

void SphereFeatureDefinitionType::setDiameter(LinearValueType * DiameterIn)
{Diameter = DiameterIn;}

/* ***************************************************************** */

/* class SphereFeatureItemType

*/

SphereFeatureItemType::SphereFeatureItemType() :
  SurfaceFeatureItemBaseType()
{
  DeterminationMode = 0;
}

SphereFeatureItemType::SphereFeatureItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 SphereMeasurementDeterminationType * DeterminationModeIn) :
  SurfaceFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

SphereFeatureItemType::SphereFeatureItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 SphereMeasurementDeterminationType * DeterminationModeIn) :
  SurfaceFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

SphereFeatureItemType::~SphereFeatureItemType()
{
  #ifndef NODESTRUCT
  delete DeterminationMode;
  #endif
}

void SphereFeatureItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<DeterminationMode");
  DeterminationMode->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeterminationMode>\n");
  doSpaces(-INDENT, outFile);
}

bool SphereFeatureItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SphereFeatureItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SphereFeatureItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SphereFeatureItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SphereFeatureItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

SphereMeasurementDeterminationType * SphereFeatureItemType::getDeterminationMode()
{return DeterminationMode;}

void SphereFeatureItemType::setDeterminationMode(SphereMeasurementDeterminationType * DeterminationModeIn)
{DeterminationMode = DeterminationModeIn;}

/* ***************************************************************** */

/* class SphereFeatureMeasurementType

*/

SphereFeatureMeasurementType::SphereFeatureMeasurementType() :
  SurfaceFeatureMeasurementBaseType()
{
  Location = 0;
  Diameter = 0;
  DiameterMin = 0;
  DiameterMax = 0;
  LatitudeLongitudeSweepMeasurementRange = 0;
  LatitudeLongitudeSweepFull = 0;
  Form = 0;
}

SphereFeatureMeasurementType::SphereFeatureMeasurementType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredPointType * LocationIn,
 MeasuredLinearValueType * DiameterIn,
 MeasuredLinearValueType * DiameterMinIn,
 MeasuredLinearValueType * DiameterMaxIn,
 OrientedLatitudeLongitudeSweepType * LatitudeLongitudeSweepMeasurementRangeIn,
 OrientedLatitudeLongitudeSweepType * LatitudeLongitudeSweepFullIn,
 MeasuredLinearValueType * FormIn) :
  SurfaceFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Location = LocationIn;
  Diameter = DiameterIn;
  DiameterMin = DiameterMinIn;
  DiameterMax = DiameterMaxIn;
  LatitudeLongitudeSweepMeasurementRange = LatitudeLongitudeSweepMeasurementRangeIn;
  LatitudeLongitudeSweepFull = LatitudeLongitudeSweepFullIn;
  Form = FormIn;
}

SphereFeatureMeasurementType::SphereFeatureMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredPointType * LocationIn,
 MeasuredLinearValueType * DiameterIn,
 MeasuredLinearValueType * DiameterMinIn,
 MeasuredLinearValueType * DiameterMaxIn,
 OrientedLatitudeLongitudeSweepType * LatitudeLongitudeSweepMeasurementRangeIn,
 OrientedLatitudeLongitudeSweepType * LatitudeLongitudeSweepFullIn,
 MeasuredLinearValueType * FormIn) :
  SurfaceFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Location = LocationIn;
  Diameter = DiameterIn;
  DiameterMin = DiameterMinIn;
  DiameterMax = DiameterMaxIn;
  LatitudeLongitudeSweepMeasurementRange = LatitudeLongitudeSweepMeasurementRangeIn;
  LatitudeLongitudeSweepFull = LatitudeLongitudeSweepFullIn;
  Form = FormIn;
}

SphereFeatureMeasurementType::~SphereFeatureMeasurementType()
{
  #ifndef NODESTRUCT
  delete Location;
  delete Diameter;
  delete DiameterMin;
  delete DiameterMax;
  delete LatitudeLongitudeSweepMeasurementRange;
  delete LatitudeLongitudeSweepFull;
  delete Form;
  #endif
}

void SphereFeatureMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  if (Location)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Location");
      Location->printSelf(outFile);
      fprintf(outFile, "</Location>\n");
    }
  if (Diameter)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Diameter");
      Diameter->printSelf(outFile);
      fprintf(outFile, "</Diameter>\n");
    }
  if (DiameterMin)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DiameterMin");
      DiameterMin->printSelf(outFile);
      fprintf(outFile, "</DiameterMin>\n");
    }
  if (DiameterMax)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DiameterMax");
      DiameterMax->printSelf(outFile);
      fprintf(outFile, "</DiameterMax>\n");
    }
  if (LatitudeLongitudeSweepMeasurementRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LatitudeLongitudeSweepMeasurementRange");
      LatitudeLongitudeSweepMeasurementRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LatitudeLongitudeSweepMeasurementRange>\n");
    }
  if (LatitudeLongitudeSweepFull)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LatitudeLongitudeSweepFull");
      LatitudeLongitudeSweepFull->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LatitudeLongitudeSweepFull>\n");
    }
  if (Form)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Form");
      Form->printSelf(outFile);
      fprintf(outFile, "</Form>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SphereFeatureMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SphereFeatureMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SphereFeatureMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SphereFeatureMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SphereFeatureMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredPointType * SphereFeatureMeasurementType::getLocation()
{return Location;}

void SphereFeatureMeasurementType::setLocation(MeasuredPointType * LocationIn)
{Location = LocationIn;}

MeasuredLinearValueType * SphereFeatureMeasurementType::getDiameter()
{return Diameter;}

void SphereFeatureMeasurementType::setDiameter(MeasuredLinearValueType * DiameterIn)
{Diameter = DiameterIn;}

MeasuredLinearValueType * SphereFeatureMeasurementType::getDiameterMin()
{return DiameterMin;}

void SphereFeatureMeasurementType::setDiameterMin(MeasuredLinearValueType * DiameterMinIn)
{DiameterMin = DiameterMinIn;}

MeasuredLinearValueType * SphereFeatureMeasurementType::getDiameterMax()
{return DiameterMax;}

void SphereFeatureMeasurementType::setDiameterMax(MeasuredLinearValueType * DiameterMaxIn)
{DiameterMax = DiameterMaxIn;}

OrientedLatitudeLongitudeSweepType * SphereFeatureMeasurementType::getLatitudeLongitudeSweepMeasurementRange()
{return LatitudeLongitudeSweepMeasurementRange;}

void SphereFeatureMeasurementType::setLatitudeLongitudeSweepMeasurementRange(OrientedLatitudeLongitudeSweepType * LatitudeLongitudeSweepMeasurementRangeIn)
{LatitudeLongitudeSweepMeasurementRange = LatitudeLongitudeSweepMeasurementRangeIn;}

OrientedLatitudeLongitudeSweepType * SphereFeatureMeasurementType::getLatitudeLongitudeSweepFull()
{return LatitudeLongitudeSweepFull;}

void SphereFeatureMeasurementType::setLatitudeLongitudeSweepFull(OrientedLatitudeLongitudeSweepType * LatitudeLongitudeSweepFullIn)
{LatitudeLongitudeSweepFull = LatitudeLongitudeSweepFullIn;}

MeasuredLinearValueType * SphereFeatureMeasurementType::getForm()
{return Form;}

void SphereFeatureMeasurementType::setForm(MeasuredLinearValueType * FormIn)
{Form = FormIn;}

/* ***************************************************************** */

/* class SphereFeatureNominalType

*/

SphereFeatureNominalType::SphereFeatureNominalType() :
  SurfaceFeatureNominalBaseType()
{
  Location = 0;
  LatitudeLongitudeSweep = 0;
  Constructed = 0;
}

SphereFeatureNominalType::SphereFeatureNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 PointType * LocationIn,
 OrientedLatitudeLongitudeSweepType * LatitudeLongitudeSweepIn,
 SphereConstructionMethodType * ConstructedIn) :
  SurfaceFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  Location = LocationIn;
  LatitudeLongitudeSweep = LatitudeLongitudeSweepIn;
  Constructed = ConstructedIn;
}

SphereFeatureNominalType::SphereFeatureNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 PointType * LocationIn,
 OrientedLatitudeLongitudeSweepType * LatitudeLongitudeSweepIn,
 SphereConstructionMethodType * ConstructedIn) :
  SurfaceFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  Location = LocationIn;
  LatitudeLongitudeSweep = LatitudeLongitudeSweepIn;
  Constructed = ConstructedIn;
}

SphereFeatureNominalType::~SphereFeatureNominalType()
{
  #ifndef NODESTRUCT
  delete Location;
  delete LatitudeLongitudeSweep;
  delete Constructed;
  #endif
}

void SphereFeatureNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Location");
  Location->printSelf(outFile);
  fprintf(outFile, "</Location>\n");
  if (LatitudeLongitudeSweep)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LatitudeLongitudeSweep");
      LatitudeLongitudeSweep->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LatitudeLongitudeSweep>\n");
    }
  if (Constructed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SphereFeatureNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SphereFeatureNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SphereFeatureNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SphereFeatureNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SphereFeatureNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

PointType * SphereFeatureNominalType::getLocation()
{return Location;}

void SphereFeatureNominalType::setLocation(PointType * LocationIn)
{Location = LocationIn;}

OrientedLatitudeLongitudeSweepType * SphereFeatureNominalType::getLatitudeLongitudeSweep()
{return LatitudeLongitudeSweep;}

void SphereFeatureNominalType::setLatitudeLongitudeSweep(OrientedLatitudeLongitudeSweepType * LatitudeLongitudeSweepIn)
{LatitudeLongitudeSweep = LatitudeLongitudeSweepIn;}

SphereConstructionMethodType * SphereFeatureNominalType::getConstructed()
{return Constructed;}

void SphereFeatureNominalType::setConstructed(SphereConstructionMethodType * ConstructedIn)
{Constructed = ConstructedIn;}

/* ***************************************************************** */

/* class SphereFromScanType

*/

SphereFromScanType::SphereFromScanType() :
  ConstructionMethodBaseType()
{
  SurfaceFeature = 0;
  SearchRadius = 0;
  Vector = 0;
}

SphereFromScanType::SphereFromScanType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * SurfaceFeatureIn,
 LinearValueType * SearchRadiusIn,
 UnitVectorType * VectorIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  SurfaceFeature = SurfaceFeatureIn;
  SearchRadius = SearchRadiusIn;
  Vector = VectorIn;
}

SphereFromScanType::~SphereFromScanType()
{
  #ifndef NODESTRUCT
  delete SurfaceFeature;
  delete SearchRadius;
  delete Vector;
  #endif
}

void SphereFromScanType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<SurfaceFeature");
  SurfaceFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</SurfaceFeature>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<SearchRadius");
  SearchRadius->printSelf(outFile);
  fprintf(outFile, "</SearchRadius>\n");
  if (Vector)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Vector");
      Vector->printSelf(outFile);
      fprintf(outFile, "</Vector>\n");
    }
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * SphereFromScanType::getSurfaceFeature()
{return SurfaceFeature;}

void SphereFromScanType::setSurfaceFeature(BaseFeatureType * SurfaceFeatureIn)
{SurfaceFeature = SurfaceFeatureIn;}

LinearValueType * SphereFromScanType::getSearchRadius()
{return SearchRadius;}

void SphereFromScanType::setSearchRadius(LinearValueType * SearchRadiusIn)
{SearchRadius = SearchRadiusIn;}

UnitVectorType * SphereFromScanType::getVector()
{return Vector;}

void SphereFromScanType::setVector(UnitVectorType * VectorIn)
{Vector = VectorIn;}

/* ***************************************************************** */

/* class SphereMeasurementDeterminationType

*/

SphereMeasurementDeterminationType::SphereMeasurementDeterminationType()
{
  SphereMeasurementDeterminationTypePair = 0;
}

SphereMeasurementDeterminationType::SphereMeasurementDeterminationType(
 SphereMeasurementDeterminationTypeChoicePair * SphereMeasurementDeterminationTypePairIn)
{
  SphereMeasurementDeterminationTypePair = SphereMeasurementDeterminationTypePairIn;
}

SphereMeasurementDeterminationType::~SphereMeasurementDeterminationType()
{
  #ifndef NODESTRUCT
  delete SphereMeasurementDeterminationTypePair;
  #endif
}

void SphereMeasurementDeterminationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  SphereMeasurementDeterminationTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

SphereMeasurementDeterminationTypeChoicePair * SphereMeasurementDeterminationType::getSphereMeasurementDeterminationTypePair()
{return SphereMeasurementDeterminationTypePair;}

void SphereMeasurementDeterminationType::setSphereMeasurementDeterminationTypePair(SphereMeasurementDeterminationTypeChoicePair * SphereMeasurementDeterminationTypePairIn)
{SphereMeasurementDeterminationTypePair = SphereMeasurementDeterminationTypePairIn;}
SphereMeasurementDeterminationTypeChoicePair::SphereMeasurementDeterminationTypeChoicePair() {}

SphereMeasurementDeterminationTypeChoicePair::SphereMeasurementDeterminationTypeChoicePair(
 whichOne SphereMeasurementDeterminationTypeTypeIn,
 SphereMeasurementDeterminationTypeVal * SphereMeasurementDeterminationTypeValueIn)
{
  SphereMeasurementDeterminationTypeType = SphereMeasurementDeterminationTypeTypeIn;
  SphereMeasurementDeterminationTypeValue = SphereMeasurementDeterminationTypeValueIn;
}

SphereMeasurementDeterminationTypeChoicePair::~SphereMeasurementDeterminationTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (SphereMeasurementDeterminationTypeType == CheckedE)
    delete SphereMeasurementDeterminationTypeValue->Checked;
  else if (SphereMeasurementDeterminationTypeType == SetE)
    delete SphereMeasurementDeterminationTypeValue->Set;
  delete SphereMeasurementDeterminationTypeValue;
  #endif
}

void SphereMeasurementDeterminationTypeChoicePair::printSelf(FILE * outFile)
{
  if (SphereMeasurementDeterminationTypeType == CheckedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Checked");
      SphereMeasurementDeterminationTypeValue->Checked->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Checked>\n");
    }
  else if (SphereMeasurementDeterminationTypeType == SetE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Set");
      SphereMeasurementDeterminationTypeValue->Set->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class SphereRecompType

*/

SphereRecompType::SphereRecompType() :
  ConstructionMethodBaseType()
{
  BaseFeaturePointList = 0;
}

SphereRecompType::SphereRecompType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeaturePointListType * BaseFeaturePointListIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeaturePointList = BaseFeaturePointListIn;
}

SphereRecompType::~SphereRecompType()
{
  #ifndef NODESTRUCT
  delete BaseFeaturePointList;
  #endif
}

void SphereRecompType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeaturePointList");
  BaseFeaturePointList->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeaturePointList>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeaturePointListType * SphereRecompType::getBaseFeaturePointList()
{return BaseFeaturePointList;}

void SphereRecompType::setBaseFeaturePointList(BaseFeaturePointListType * BaseFeaturePointListIn)
{BaseFeaturePointList = BaseFeaturePointListIn;}

/* ***************************************************************** */

/* class SphereTransformType

*/

SphereTransformType::SphereTransformType() :
  ConstructionMethodBaseType()
{
  BaseSphere = 0;
  Transformation = 0;
}

SphereTransformType::SphereTransformType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseSphereIn,
 TransformationReferenceType * TransformationIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseSphere = BaseSphereIn;
  Transformation = TransformationIn;
}

SphereTransformType::~SphereTransformType()
{
  #ifndef NODESTRUCT
  delete BaseSphere;
  delete Transformation;
  #endif
}

void SphereTransformType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseSphere");
  BaseSphere->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseSphere>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Transformation");
  Transformation->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Transformation>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * SphereTransformType::getBaseSphere()
{return BaseSphere;}

void SphereTransformType::setBaseSphere(BaseFeatureType * BaseSphereIn)
{BaseSphere = BaseSphereIn;}

TransformationReferenceType * SphereTransformType::getTransformation()
{return Transformation;}

void SphereTransformType::setTransformation(TransformationReferenceType * TransformationIn)
{Transformation = TransformationIn;}

/* ***************************************************************** */

/* class SphericalSegmentBestFitType

*/

SphericalSegmentBestFitType::SphericalSegmentBestFitType() :
  ConstructionMethodBaseType()
{
  n = 0;
  BaseFeature = 0;
}

SphericalSegmentBestFitType::SphericalSegmentBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = 0;
  BaseFeature = BaseFeatureIn;
}

SphericalSegmentBestFitType::SphericalSegmentBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 NaturalType * nIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = nIn;
  BaseFeature = BaseFeatureIn;
}

SphericalSegmentBestFitType::~SphericalSegmentBestFitType()
{
  #ifndef NODESTRUCT
  delete n;
  delete BaseFeature;
  #endif
}

void SphericalSegmentBestFitType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  {
    if (!BaseFeature)
      {
        fprintf(stderr, "BaseFeature list is missing\n");
        exit(1);
      }
    if (BaseFeature->size() == 0)
      {
        fprintf(stderr, "BaseFeature list is empty\n");
        exit(1);
      }
    if (BaseFeature->size() < 4)
      {
        fprintf(stderr,
                "size of BaseFeature list (%d) less than minimum required (4)\n",
                (int)BaseFeature->size());
        exit(1);
      }
    std::list<SequencedBaseFeatureType *>::iterator iter;
    for (iter = BaseFeature->begin();
         iter != BaseFeature->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<BaseFeature");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</BaseFeature>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool SphericalSegmentBestFitType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in SphericalSegmentBestFitType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in SphericalSegmentBestFitType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SphericalSegmentBestFitType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in SphericalSegmentBestFitType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * SphericalSegmentBestFitType::getn()
{return n;}

void SphericalSegmentBestFitType::setn(NaturalType * nIn)
{n = nIn;}

SequencedBaseFeatureTypeLisd * SphericalSegmentBestFitType::getBaseFeature()
{return BaseFeature;}

void SphericalSegmentBestFitType::setBaseFeature(SequencedBaseFeatureTypeLisd * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class SphericalSegmentCastType

*/

SphericalSegmentCastType::SphericalSegmentCastType() :
  ConstructionMethodBaseType()
{
  BaseFeature = 0;
}

SphericalSegmentCastType::SphericalSegmentCastType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeature = BaseFeatureIn;
}

SphericalSegmentCastType::~SphericalSegmentCastType()
{
  #ifndef NODESTRUCT
  delete BaseFeature;
  #endif
}

void SphericalSegmentCastType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeature");
  BaseFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * SphericalSegmentCastType::getBaseFeature()
{return BaseFeature;}

void SphericalSegmentCastType::setBaseFeature(BaseFeatureType * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class SphericalSegmentCheckedFeatureType

*/

SphericalSegmentCheckedFeatureType::SphericalSegmentCheckedFeatureType()
{
  CheckDetails = 0;
}

SphericalSegmentCheckedFeatureType::SphericalSegmentCheckedFeatureType(
 SphericalSegmentCheckedType * CheckDetailsIn)
{
  CheckDetails = CheckDetailsIn;
}

SphericalSegmentCheckedFeatureType::~SphericalSegmentCheckedFeatureType()
{
  #ifndef NODESTRUCT
  delete CheckDetails;
  #endif
}

void SphericalSegmentCheckedFeatureType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (CheckDetails)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CheckDetails");
      CheckDetails->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CheckDetails>\n");
    }
  doSpaces(-INDENT, outFile);
}

SphericalSegmentCheckedType * SphericalSegmentCheckedFeatureType::getCheckDetails()
{return CheckDetails;}

void SphericalSegmentCheckedFeatureType::setCheckDetails(SphericalSegmentCheckedType * CheckDetailsIn)
{CheckDetails = CheckDetailsIn;}

/* ***************************************************************** */

/* class SphericalSegmentCheckedType

*/

SphericalSegmentCheckedType::SphericalSegmentCheckedType()
{
  SphericalSegmentCheckedTypePair = 0;
}

SphericalSegmentCheckedType::SphericalSegmentCheckedType(
 SphericalSegmentCheckedTypeChoicePair * SphericalSegmentCheckedTypePairIn)
{
  SphericalSegmentCheckedTypePair = SphericalSegmentCheckedTypePairIn;
}

SphericalSegmentCheckedType::~SphericalSegmentCheckedType()
{
  #ifndef NODESTRUCT
  delete SphericalSegmentCheckedTypePair;
  #endif
}

void SphericalSegmentCheckedType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  SphericalSegmentCheckedTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

SphericalSegmentCheckedTypeChoicePair * SphericalSegmentCheckedType::getSphericalSegmentCheckedTypePair()
{return SphericalSegmentCheckedTypePair;}

void SphericalSegmentCheckedType::setSphericalSegmentCheckedTypePair(SphericalSegmentCheckedTypeChoicePair * SphericalSegmentCheckedTypePairIn)
{SphericalSegmentCheckedTypePair = SphericalSegmentCheckedTypePairIn;}
SphericalSegmentCheckedTypeChoicePair::SphericalSegmentCheckedTypeChoicePair() {}

SphericalSegmentCheckedTypeChoicePair::SphericalSegmentCheckedTypeChoicePair(
 whichOne SphericalSegmentCheckedTypeTypeIn,
 SphericalSegmentCheckedTypeVal * SphericalSegmentCheckedTypeValueIn)
{
  SphericalSegmentCheckedTypeType = SphericalSegmentCheckedTypeTypeIn;
  SphericalSegmentCheckedTypeValue = SphericalSegmentCheckedTypeValueIn;
}

SphericalSegmentCheckedTypeChoicePair::~SphericalSegmentCheckedTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (SphericalSegmentCheckedTypeType == MeasuredE)
    delete SphericalSegmentCheckedTypeValue->Measured;
  else if (SphericalSegmentCheckedTypeType == ConstructedE)
    delete SphericalSegmentCheckedTypeValue->Constructed;
  delete SphericalSegmentCheckedTypeValue;
  #endif
}

void SphericalSegmentCheckedTypeChoicePair::printSelf(FILE * outFile)
{
  if (SphericalSegmentCheckedTypeType == MeasuredE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Measured");
      SphericalSegmentCheckedTypeValue->Measured->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Measured>\n");
    }
  else if (SphericalSegmentCheckedTypeType == ConstructedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      SphericalSegmentCheckedTypeValue->Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
}

/* ***************************************************************** */

/* class SphericalSegmentConstructionMethodType

*/

SphericalSegmentConstructionMethodType::SphericalSegmentConstructionMethodType()
{
  SphericalSegmentConstructionMethodTypePair = 0;
}

SphericalSegmentConstructionMethodType::SphericalSegmentConstructionMethodType(
 SphericalSegmentConstructionMethodTypeChoicePair * SphericalSegmentConstructionMethodTypePairIn)
{
  SphericalSegmentConstructionMethodTypePair = SphericalSegmentConstructionMethodTypePairIn;
}

SphericalSegmentConstructionMethodType::~SphericalSegmentConstructionMethodType()
{
  #ifndef NODESTRUCT
  delete SphericalSegmentConstructionMethodTypePair;
  #endif
}

void SphericalSegmentConstructionMethodType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (SphericalSegmentConstructionMethodTypePair)
    {
      SphericalSegmentConstructionMethodTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

SphericalSegmentConstructionMethodTypeChoicePair * SphericalSegmentConstructionMethodType::getSphericalSegmentConstructionMethodTypePair()
{return SphericalSegmentConstructionMethodTypePair;}

void SphericalSegmentConstructionMethodType::setSphericalSegmentConstructionMethodTypePair(SphericalSegmentConstructionMethodTypeChoicePair * SphericalSegmentConstructionMethodTypePairIn)
{SphericalSegmentConstructionMethodTypePair = SphericalSegmentConstructionMethodTypePairIn;}
SphericalSegmentConstructionMethodTypeChoicePair::SphericalSegmentConstructionMethodTypeChoicePair() {}

SphericalSegmentConstructionMethodTypeChoicePair::SphericalSegmentConstructionMethodTypeChoicePair(
 whichOne SphericalSegmentConstructionMethodTypeTypeIn,
 SphericalSegmentConstructionMethodTypeVal * SphericalSegmentConstructionMethodTypeValueIn)
{
  SphericalSegmentConstructionMethodTypeType = SphericalSegmentConstructionMethodTypeTypeIn;
  SphericalSegmentConstructionMethodTypeValue = SphericalSegmentConstructionMethodTypeValueIn;
}

SphericalSegmentConstructionMethodTypeChoicePair::~SphericalSegmentConstructionMethodTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (SphericalSegmentConstructionMethodTypeType == BestFitE)
    delete SphericalSegmentConstructionMethodTypeValue->BestFit;
  else if (SphericalSegmentConstructionMethodTypeType == RecompensatedE)
    delete SphericalSegmentConstructionMethodTypeValue->Recompensated;
  else if (SphericalSegmentConstructionMethodTypeType == CopyE)
    delete SphericalSegmentConstructionMethodTypeValue->Copy;
  else if (SphericalSegmentConstructionMethodTypeType == CastE)
    delete SphericalSegmentConstructionMethodTypeValue->Cast;
  else if (SphericalSegmentConstructionMethodTypeType == TransformE)
    delete SphericalSegmentConstructionMethodTypeValue->Transform;
  delete SphericalSegmentConstructionMethodTypeValue;
  #endif
}

void SphericalSegmentConstructionMethodTypeChoicePair::printSelf(FILE * outFile)
{
  if (SphericalSegmentConstructionMethodTypeType == BestFitE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BestFit");
      SphericalSegmentConstructionMethodTypeValue->BestFit->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BestFit>\n");
    }
  else if (SphericalSegmentConstructionMethodTypeType == RecompensatedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Recompensated");
      SphericalSegmentConstructionMethodTypeValue->Recompensated->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Recompensated>\n");
    }
  else if (SphericalSegmentConstructionMethodTypeType == CopyE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Copy");
      SphericalSegmentConstructionMethodTypeValue->Copy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Copy>\n");
    }
  else if (SphericalSegmentConstructionMethodTypeType == CastE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Cast");
      SphericalSegmentConstructionMethodTypeValue->Cast->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Cast>\n");
    }
  else if (SphericalSegmentConstructionMethodTypeType == TransformE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Transform");
      SphericalSegmentConstructionMethodTypeValue->Transform->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Transform>\n");
    }
}

/* ***************************************************************** */

/* class SphericalSegmentCopyType

*/

SphericalSegmentCopyType::SphericalSegmentCopyType() :
  ConstructionMethodBaseType()
{
  BaseSphericalSegment = 0;
}

SphericalSegmentCopyType::SphericalSegmentCopyType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseSphericalSegmentIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseSphericalSegment = BaseSphericalSegmentIn;
}

SphericalSegmentCopyType::~SphericalSegmentCopyType()
{
  #ifndef NODESTRUCT
  delete BaseSphericalSegment;
  #endif
}

void SphericalSegmentCopyType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseSphericalSegment");
  BaseSphericalSegment->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseSphericalSegment>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * SphericalSegmentCopyType::getBaseSphericalSegment()
{return BaseSphericalSegment;}

void SphericalSegmentCopyType::setBaseSphericalSegment(BaseFeatureType * BaseSphericalSegmentIn)
{BaseSphericalSegment = BaseSphericalSegmentIn;}

/* ***************************************************************** */

/* class SphericalSegmentFeatureDefinitionType

*/

SphericalSegmentFeatureDefinitionType::SphericalSegmentFeatureDefinitionType() :
  SurfaceFeatureDefinitionBaseType()
{
  InternalExternal = 0;
  Diameter = 0;
}

SphericalSegmentFeatureDefinitionType::SphericalSegmentFeatureDefinitionType(
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * DiameterIn) :
  SurfaceFeatureDefinitionBaseType(
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  Diameter = DiameterIn;
}

SphericalSegmentFeatureDefinitionType::SphericalSegmentFeatureDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * DiameterIn) :
  SurfaceFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  Diameter = DiameterIn;
}

SphericalSegmentFeatureDefinitionType::~SphericalSegmentFeatureDefinitionType()
{
  #ifndef NODESTRUCT
  delete InternalExternal;
  delete Diameter;
  #endif
}

void SphericalSegmentFeatureDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<InternalExternal");
  InternalExternal->printSelf(outFile);
  fprintf(outFile, "</InternalExternal>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Diameter");
  Diameter->printSelf(outFile);
  fprintf(outFile, "</Diameter>\n");
  doSpaces(-INDENT, outFile);
}

bool SphericalSegmentFeatureDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SphericalSegmentFeatureDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SphericalSegmentFeatureDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SphericalSegmentFeatureDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SphericalSegmentFeatureDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

InternalExternalEnumType * SphericalSegmentFeatureDefinitionType::getInternalExternal()
{return InternalExternal;}

void SphericalSegmentFeatureDefinitionType::setInternalExternal(InternalExternalEnumType * InternalExternalIn)
{InternalExternal = InternalExternalIn;}

LinearValueType * SphericalSegmentFeatureDefinitionType::getDiameter()
{return Diameter;}

void SphericalSegmentFeatureDefinitionType::setDiameter(LinearValueType * DiameterIn)
{Diameter = DiameterIn;}

/* ***************************************************************** */

/* class SphericalSegmentFeatureItemType

*/

SphericalSegmentFeatureItemType::SphericalSegmentFeatureItemType() :
  SurfaceFeatureItemBaseType()
{
  DeterminationMode = 0;
}

SphericalSegmentFeatureItemType::SphericalSegmentFeatureItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 SphericalSegmentMeasurementDeterminationType * DeterminationModeIn) :
  SurfaceFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

SphericalSegmentFeatureItemType::SphericalSegmentFeatureItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 SphericalSegmentMeasurementDeterminationType * DeterminationModeIn) :
  SurfaceFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

SphericalSegmentFeatureItemType::~SphericalSegmentFeatureItemType()
{
  #ifndef NODESTRUCT
  delete DeterminationMode;
  #endif
}

void SphericalSegmentFeatureItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<DeterminationMode");
  DeterminationMode->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeterminationMode>\n");
  doSpaces(-INDENT, outFile);
}

bool SphericalSegmentFeatureItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SphericalSegmentFeatureItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SphericalSegmentFeatureItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SphericalSegmentFeatureItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SphericalSegmentFeatureItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

SphericalSegmentMeasurementDeterminationType * SphericalSegmentFeatureItemType::getDeterminationMode()
{return DeterminationMode;}

void SphericalSegmentFeatureItemType::setDeterminationMode(SphericalSegmentMeasurementDeterminationType * DeterminationModeIn)
{DeterminationMode = DeterminationModeIn;}

/* ***************************************************************** */

/* class SphericalSegmentFeatureMeasurementType

*/

SphericalSegmentFeatureMeasurementType::SphericalSegmentFeatureMeasurementType() :
  SurfaceFeatureMeasurementBaseType()
{
  Location = 0;
  Diameter = 0;
  DiameterMin = 0;
  DiameterMax = 0;
  LatitudeLongitudeSweepMeasurementRange = 0;
  LatitudeLongitudeSweepFull = 0;
  Form = 0;
}

SphericalSegmentFeatureMeasurementType::SphericalSegmentFeatureMeasurementType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredPointType * LocationIn,
 MeasuredLinearValueType * DiameterIn,
 MeasuredLinearValueType * DiameterMinIn,
 MeasuredLinearValueType * DiameterMaxIn,
 OrientedLatitudeLongitudeSweepType * LatitudeLongitudeSweepMeasurementRangeIn,
 OrientedLatitudeLongitudeSweepType * LatitudeLongitudeSweepFullIn,
 MeasuredLinearValueType * FormIn) :
  SurfaceFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Location = LocationIn;
  Diameter = DiameterIn;
  DiameterMin = DiameterMinIn;
  DiameterMax = DiameterMaxIn;
  LatitudeLongitudeSweepMeasurementRange = LatitudeLongitudeSweepMeasurementRangeIn;
  LatitudeLongitudeSweepFull = LatitudeLongitudeSweepFullIn;
  Form = FormIn;
}

SphericalSegmentFeatureMeasurementType::SphericalSegmentFeatureMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredPointType * LocationIn,
 MeasuredLinearValueType * DiameterIn,
 MeasuredLinearValueType * DiameterMinIn,
 MeasuredLinearValueType * DiameterMaxIn,
 OrientedLatitudeLongitudeSweepType * LatitudeLongitudeSweepMeasurementRangeIn,
 OrientedLatitudeLongitudeSweepType * LatitudeLongitudeSweepFullIn,
 MeasuredLinearValueType * FormIn) :
  SurfaceFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Location = LocationIn;
  Diameter = DiameterIn;
  DiameterMin = DiameterMinIn;
  DiameterMax = DiameterMaxIn;
  LatitudeLongitudeSweepMeasurementRange = LatitudeLongitudeSweepMeasurementRangeIn;
  LatitudeLongitudeSweepFull = LatitudeLongitudeSweepFullIn;
  Form = FormIn;
}

SphericalSegmentFeatureMeasurementType::~SphericalSegmentFeatureMeasurementType()
{
  #ifndef NODESTRUCT
  delete Location;
  delete Diameter;
  delete DiameterMin;
  delete DiameterMax;
  delete LatitudeLongitudeSweepMeasurementRange;
  delete LatitudeLongitudeSweepFull;
  delete Form;
  #endif
}

void SphericalSegmentFeatureMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  if (Location)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Location");
      Location->printSelf(outFile);
      fprintf(outFile, "</Location>\n");
    }
  if (Diameter)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Diameter");
      Diameter->printSelf(outFile);
      fprintf(outFile, "</Diameter>\n");
    }
  if (DiameterMin)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DiameterMin");
      DiameterMin->printSelf(outFile);
      fprintf(outFile, "</DiameterMin>\n");
    }
  if (DiameterMax)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DiameterMax");
      DiameterMax->printSelf(outFile);
      fprintf(outFile, "</DiameterMax>\n");
    }
  if (LatitudeLongitudeSweepMeasurementRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LatitudeLongitudeSweepMeasurementRange");
      LatitudeLongitudeSweepMeasurementRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LatitudeLongitudeSweepMeasurementRange>\n");
    }
  if (LatitudeLongitudeSweepFull)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LatitudeLongitudeSweepFull");
      LatitudeLongitudeSweepFull->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LatitudeLongitudeSweepFull>\n");
    }
  if (Form)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Form");
      Form->printSelf(outFile);
      fprintf(outFile, "</Form>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SphericalSegmentFeatureMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SphericalSegmentFeatureMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SphericalSegmentFeatureMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SphericalSegmentFeatureMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SphericalSegmentFeatureMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredPointType * SphericalSegmentFeatureMeasurementType::getLocation()
{return Location;}

void SphericalSegmentFeatureMeasurementType::setLocation(MeasuredPointType * LocationIn)
{Location = LocationIn;}

MeasuredLinearValueType * SphericalSegmentFeatureMeasurementType::getDiameter()
{return Diameter;}

void SphericalSegmentFeatureMeasurementType::setDiameter(MeasuredLinearValueType * DiameterIn)
{Diameter = DiameterIn;}

MeasuredLinearValueType * SphericalSegmentFeatureMeasurementType::getDiameterMin()
{return DiameterMin;}

void SphericalSegmentFeatureMeasurementType::setDiameterMin(MeasuredLinearValueType * DiameterMinIn)
{DiameterMin = DiameterMinIn;}

MeasuredLinearValueType * SphericalSegmentFeatureMeasurementType::getDiameterMax()
{return DiameterMax;}

void SphericalSegmentFeatureMeasurementType::setDiameterMax(MeasuredLinearValueType * DiameterMaxIn)
{DiameterMax = DiameterMaxIn;}

OrientedLatitudeLongitudeSweepType * SphericalSegmentFeatureMeasurementType::getLatitudeLongitudeSweepMeasurementRange()
{return LatitudeLongitudeSweepMeasurementRange;}

void SphericalSegmentFeatureMeasurementType::setLatitudeLongitudeSweepMeasurementRange(OrientedLatitudeLongitudeSweepType * LatitudeLongitudeSweepMeasurementRangeIn)
{LatitudeLongitudeSweepMeasurementRange = LatitudeLongitudeSweepMeasurementRangeIn;}

OrientedLatitudeLongitudeSweepType * SphericalSegmentFeatureMeasurementType::getLatitudeLongitudeSweepFull()
{return LatitudeLongitudeSweepFull;}

void SphericalSegmentFeatureMeasurementType::setLatitudeLongitudeSweepFull(OrientedLatitudeLongitudeSweepType * LatitudeLongitudeSweepFullIn)
{LatitudeLongitudeSweepFull = LatitudeLongitudeSweepFullIn;}

MeasuredLinearValueType * SphericalSegmentFeatureMeasurementType::getForm()
{return Form;}

void SphericalSegmentFeatureMeasurementType::setForm(MeasuredLinearValueType * FormIn)
{Form = FormIn;}

/* ***************************************************************** */

/* class SphericalSegmentFeatureNominalType

*/

SphericalSegmentFeatureNominalType::SphericalSegmentFeatureNominalType() :
  SurfaceFeatureNominalBaseType()
{
  Location = 0;
  LatitudeLongitudeSweep = 0;
  Constructed = 0;
}

SphericalSegmentFeatureNominalType::SphericalSegmentFeatureNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 PointType * LocationIn,
 OrientedLatitudeLongitudeSweepType * LatitudeLongitudeSweepIn,
 SphericalSegmentConstructionMethodType * ConstructedIn) :
  SurfaceFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  Location = LocationIn;
  LatitudeLongitudeSweep = LatitudeLongitudeSweepIn;
  Constructed = ConstructedIn;
}

SphericalSegmentFeatureNominalType::SphericalSegmentFeatureNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 PointType * LocationIn,
 OrientedLatitudeLongitudeSweepType * LatitudeLongitudeSweepIn,
 SphericalSegmentConstructionMethodType * ConstructedIn) :
  SurfaceFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  Location = LocationIn;
  LatitudeLongitudeSweep = LatitudeLongitudeSweepIn;
  Constructed = ConstructedIn;
}

SphericalSegmentFeatureNominalType::~SphericalSegmentFeatureNominalType()
{
  #ifndef NODESTRUCT
  delete Location;
  delete LatitudeLongitudeSweep;
  delete Constructed;
  #endif
}

void SphericalSegmentFeatureNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Location");
  Location->printSelf(outFile);
  fprintf(outFile, "</Location>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<LatitudeLongitudeSweep");
  LatitudeLongitudeSweep->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</LatitudeLongitudeSweep>\n");
  if (Constructed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SphericalSegmentFeatureNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SphericalSegmentFeatureNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SphericalSegmentFeatureNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SphericalSegmentFeatureNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SphericalSegmentFeatureNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

PointType * SphericalSegmentFeatureNominalType::getLocation()
{return Location;}

void SphericalSegmentFeatureNominalType::setLocation(PointType * LocationIn)
{Location = LocationIn;}

OrientedLatitudeLongitudeSweepType * SphericalSegmentFeatureNominalType::getLatitudeLongitudeSweep()
{return LatitudeLongitudeSweep;}

void SphericalSegmentFeatureNominalType::setLatitudeLongitudeSweep(OrientedLatitudeLongitudeSweepType * LatitudeLongitudeSweepIn)
{LatitudeLongitudeSweep = LatitudeLongitudeSweepIn;}

SphericalSegmentConstructionMethodType * SphericalSegmentFeatureNominalType::getConstructed()
{return Constructed;}

void SphericalSegmentFeatureNominalType::setConstructed(SphericalSegmentConstructionMethodType * ConstructedIn)
{Constructed = ConstructedIn;}

/* ***************************************************************** */

/* class SphericalSegmentMeasurementDeterminationType

*/

SphericalSegmentMeasurementDeterminationType::SphericalSegmentMeasurementDeterminationType()
{
  SphericalSegmentMeasurementDeterminationTypePair = 0;
}

SphericalSegmentMeasurementDeterminationType::SphericalSegmentMeasurementDeterminationType(
 SphericalSegmentMeasurementDeterminationTypeChoicePair * SphericalSegmentMeasurementDeterminationTypePairIn)
{
  SphericalSegmentMeasurementDeterminationTypePair = SphericalSegmentMeasurementDeterminationTypePairIn;
}

SphericalSegmentMeasurementDeterminationType::~SphericalSegmentMeasurementDeterminationType()
{
  #ifndef NODESTRUCT
  delete SphericalSegmentMeasurementDeterminationTypePair;
  #endif
}

void SphericalSegmentMeasurementDeterminationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  SphericalSegmentMeasurementDeterminationTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

SphericalSegmentMeasurementDeterminationTypeChoicePair * SphericalSegmentMeasurementDeterminationType::getSphericalSegmentMeasurementDeterminationTypePair()
{return SphericalSegmentMeasurementDeterminationTypePair;}

void SphericalSegmentMeasurementDeterminationType::setSphericalSegmentMeasurementDeterminationTypePair(SphericalSegmentMeasurementDeterminationTypeChoicePair * SphericalSegmentMeasurementDeterminationTypePairIn)
{SphericalSegmentMeasurementDeterminationTypePair = SphericalSegmentMeasurementDeterminationTypePairIn;}
SphericalSegmentMeasurementDeterminationTypeChoicePair::SphericalSegmentMeasurementDeterminationTypeChoicePair() {}

SphericalSegmentMeasurementDeterminationTypeChoicePair::SphericalSegmentMeasurementDeterminationTypeChoicePair(
 whichOne SphericalSegmentMeasurementDeterminationTypeTypeIn,
 SphericalSegmentMeasurementDeterminationTypeVal * SphericalSegmentMeasurementDeterminationTypeValueIn)
{
  SphericalSegmentMeasurementDeterminationTypeType = SphericalSegmentMeasurementDeterminationTypeTypeIn;
  SphericalSegmentMeasurementDeterminationTypeValue = SphericalSegmentMeasurementDeterminationTypeValueIn;
}

SphericalSegmentMeasurementDeterminationTypeChoicePair::~SphericalSegmentMeasurementDeterminationTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (SphericalSegmentMeasurementDeterminationTypeType == CheckedE)
    delete SphericalSegmentMeasurementDeterminationTypeValue->Checked;
  else if (SphericalSegmentMeasurementDeterminationTypeType == SetE)
    delete SphericalSegmentMeasurementDeterminationTypeValue->Set;
  delete SphericalSegmentMeasurementDeterminationTypeValue;
  #endif
}

void SphericalSegmentMeasurementDeterminationTypeChoicePair::printSelf(FILE * outFile)
{
  if (SphericalSegmentMeasurementDeterminationTypeType == CheckedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Checked");
      SphericalSegmentMeasurementDeterminationTypeValue->Checked->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Checked>\n");
    }
  else if (SphericalSegmentMeasurementDeterminationTypeType == SetE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Set");
      SphericalSegmentMeasurementDeterminationTypeValue->Set->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class SphericalSegmentRecompType

*/

SphericalSegmentRecompType::SphericalSegmentRecompType() :
  ConstructionMethodBaseType()
{
  BaseFeaturePointList = 0;
}

SphericalSegmentRecompType::SphericalSegmentRecompType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeaturePointListType * BaseFeaturePointListIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeaturePointList = BaseFeaturePointListIn;
}

SphericalSegmentRecompType::~SphericalSegmentRecompType()
{
  #ifndef NODESTRUCT
  delete BaseFeaturePointList;
  #endif
}

void SphericalSegmentRecompType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeaturePointList");
  BaseFeaturePointList->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeaturePointList>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeaturePointListType * SphericalSegmentRecompType::getBaseFeaturePointList()
{return BaseFeaturePointList;}

void SphericalSegmentRecompType::setBaseFeaturePointList(BaseFeaturePointListType * BaseFeaturePointListIn)
{BaseFeaturePointList = BaseFeaturePointListIn;}

/* ***************************************************************** */

/* class SphericalSegmentTransformType

*/

SphericalSegmentTransformType::SphericalSegmentTransformType() :
  ConstructionMethodBaseType()
{
  BaseSphericalSegment = 0;
  Transformation = 0;
}

SphericalSegmentTransformType::SphericalSegmentTransformType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseSphericalSegmentIn,
 TransformationReferenceType * TransformationIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseSphericalSegment = BaseSphericalSegmentIn;
  Transformation = TransformationIn;
}

SphericalSegmentTransformType::~SphericalSegmentTransformType()
{
  #ifndef NODESTRUCT
  delete BaseSphericalSegment;
  delete Transformation;
  #endif
}

void SphericalSegmentTransformType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseSphericalSegment");
  BaseSphericalSegment->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseSphericalSegment>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Transformation");
  Transformation->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Transformation>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * SphericalSegmentTransformType::getBaseSphericalSegment()
{return BaseSphericalSegment;}

void SphericalSegmentTransformType::setBaseSphericalSegment(BaseFeatureType * BaseSphericalSegmentIn)
{BaseSphericalSegment = BaseSphericalSegmentIn;}

TransformationReferenceType * SphericalSegmentTransformType::getTransformation()
{return Transformation;}

void SphericalSegmentTransformType::setTransformation(TransformationReferenceType * TransformationIn)
{Transformation = TransformationIn;}

/* ***************************************************************** */

/* class SurfaceFeatureDefinitionBaseType

*/

SurfaceFeatureDefinitionBaseType::SurfaceFeatureDefinitionBaseType() :
  ShapeFeatureDefinitionBaseType()
{
}

SurfaceFeatureDefinitionBaseType::SurfaceFeatureDefinitionBaseType(
 AttributesType * AttributesIn) :
  ShapeFeatureDefinitionBaseType(
    AttributesIn)
{
}

SurfaceFeatureDefinitionBaseType::SurfaceFeatureDefinitionBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn) :
  ShapeFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
}

SurfaceFeatureDefinitionBaseType::~SurfaceFeatureDefinitionBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void SurfaceFeatureDefinitionBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SurfaceFeatureDefinitionBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SurfaceFeatureDefinitionBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SurfaceFeatureDefinitionBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SurfaceFeatureDefinitionBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SurfaceFeatureDefinitionBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class SurfaceFeatureItemBaseType

*/

SurfaceFeatureItemBaseType::SurfaceFeatureItemBaseType() :
  ShapeFeatureItemBaseType()
{
}

SurfaceFeatureItemBaseType::SurfaceFeatureItemBaseType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  ShapeFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
}

SurfaceFeatureItemBaseType::SurfaceFeatureItemBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn) :
  ShapeFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
}

SurfaceFeatureItemBaseType::~SurfaceFeatureItemBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void SurfaceFeatureItemBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool SurfaceFeatureItemBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SurfaceFeatureItemBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SurfaceFeatureItemBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SurfaceFeatureItemBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SurfaceFeatureItemBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class SurfaceFeatureMeasurementBaseType

*/

SurfaceFeatureMeasurementBaseType::SurfaceFeatureMeasurementBaseType() :
  ShapeFeatureMeasurementBaseType()
{
}

SurfaceFeatureMeasurementBaseType::SurfaceFeatureMeasurementBaseType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn) :
  ShapeFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
}

SurfaceFeatureMeasurementBaseType::SurfaceFeatureMeasurementBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn) :
  ShapeFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
}

SurfaceFeatureMeasurementBaseType::~SurfaceFeatureMeasurementBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void SurfaceFeatureMeasurementBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SurfaceFeatureMeasurementBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SurfaceFeatureMeasurementBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SurfaceFeatureMeasurementBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SurfaceFeatureMeasurementBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SurfaceFeatureMeasurementBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class SurfaceFeatureNominalBaseType

*/

SurfaceFeatureNominalBaseType::SurfaceFeatureNominalBaseType() :
  ShapeFeatureNominalBaseType()
{
}

SurfaceFeatureNominalBaseType::SurfaceFeatureNominalBaseType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn) :
  ShapeFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
}

SurfaceFeatureNominalBaseType::SurfaceFeatureNominalBaseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn) :
  ShapeFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
}

SurfaceFeatureNominalBaseType::~SurfaceFeatureNominalBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void SurfaceFeatureNominalBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SurfaceFeatureNominalBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SurfaceFeatureNominalBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SurfaceFeatureNominalBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SurfaceFeatureNominalBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SurfaceFeatureNominalBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class SurfaceOfRevolutionBestFitType

*/

SurfaceOfRevolutionBestFitType::SurfaceOfRevolutionBestFitType() :
  ConstructionMethodBaseType()
{
  n = 0;
  BaseFeature = 0;
}

SurfaceOfRevolutionBestFitType::SurfaceOfRevolutionBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = 0;
  BaseFeature = BaseFeatureIn;
}

SurfaceOfRevolutionBestFitType::SurfaceOfRevolutionBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 NaturalType * nIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = nIn;
  BaseFeature = BaseFeatureIn;
}

SurfaceOfRevolutionBestFitType::~SurfaceOfRevolutionBestFitType()
{
  #ifndef NODESTRUCT
  delete n;
  delete BaseFeature;
  #endif
}

void SurfaceOfRevolutionBestFitType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  {
    if (!BaseFeature)
      {
        fprintf(stderr, "BaseFeature list is missing\n");
        exit(1);
      }
    if (BaseFeature->size() == 0)
      {
        fprintf(stderr, "BaseFeature list is empty\n");
        exit(1);
      }
    if (BaseFeature->size() < 6)
      {
        fprintf(stderr,
                "size of BaseFeature list (%d) less than minimum required (6)\n",
                (int)BaseFeature->size());
        exit(1);
      }
    std::list<SequencedBaseFeatureType *>::iterator iter;
    for (iter = BaseFeature->begin();
         iter != BaseFeature->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<BaseFeature");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</BaseFeature>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool SurfaceOfRevolutionBestFitType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in SurfaceOfRevolutionBestFitType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in SurfaceOfRevolutionBestFitType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SurfaceOfRevolutionBestFitType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in SurfaceOfRevolutionBestFitType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * SurfaceOfRevolutionBestFitType::getn()
{return n;}

void SurfaceOfRevolutionBestFitType::setn(NaturalType * nIn)
{n = nIn;}

SequencedBaseFeatureTypeLisd * SurfaceOfRevolutionBestFitType::getBaseFeature()
{return BaseFeature;}

void SurfaceOfRevolutionBestFitType::setBaseFeature(SequencedBaseFeatureTypeLisd * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class SurfaceOfRevolutionCastType

*/

SurfaceOfRevolutionCastType::SurfaceOfRevolutionCastType() :
  ConstructionMethodBaseType()
{
  BaseFeature = 0;
}

SurfaceOfRevolutionCastType::SurfaceOfRevolutionCastType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeature = BaseFeatureIn;
}

SurfaceOfRevolutionCastType::~SurfaceOfRevolutionCastType()
{
  #ifndef NODESTRUCT
  delete BaseFeature;
  #endif
}

void SurfaceOfRevolutionCastType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeature");
  BaseFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * SurfaceOfRevolutionCastType::getBaseFeature()
{return BaseFeature;}

void SurfaceOfRevolutionCastType::setBaseFeature(BaseFeatureType * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class SurfaceOfRevolutionCheckedFeatureType

*/

SurfaceOfRevolutionCheckedFeatureType::SurfaceOfRevolutionCheckedFeatureType()
{
  CheckDetails = 0;
}

SurfaceOfRevolutionCheckedFeatureType::SurfaceOfRevolutionCheckedFeatureType(
 SurfaceOfRevolutionCheckedType * CheckDetailsIn)
{
  CheckDetails = CheckDetailsIn;
}

SurfaceOfRevolutionCheckedFeatureType::~SurfaceOfRevolutionCheckedFeatureType()
{
  #ifndef NODESTRUCT
  delete CheckDetails;
  #endif
}

void SurfaceOfRevolutionCheckedFeatureType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (CheckDetails)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CheckDetails");
      CheckDetails->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CheckDetails>\n");
    }
  doSpaces(-INDENT, outFile);
}

SurfaceOfRevolutionCheckedType * SurfaceOfRevolutionCheckedFeatureType::getCheckDetails()
{return CheckDetails;}

void SurfaceOfRevolutionCheckedFeatureType::setCheckDetails(SurfaceOfRevolutionCheckedType * CheckDetailsIn)
{CheckDetails = CheckDetailsIn;}

/* ***************************************************************** */

/* class SurfaceOfRevolutionCheckedType

*/

SurfaceOfRevolutionCheckedType::SurfaceOfRevolutionCheckedType()
{
  SurfaceOfRevolutionCheckedTypePair = 0;
}

SurfaceOfRevolutionCheckedType::SurfaceOfRevolutionCheckedType(
 SurfaceOfRevolutionCheckedTypeChoicePair * SurfaceOfRevolutionCheckedTypePairIn)
{
  SurfaceOfRevolutionCheckedTypePair = SurfaceOfRevolutionCheckedTypePairIn;
}

SurfaceOfRevolutionCheckedType::~SurfaceOfRevolutionCheckedType()
{
  #ifndef NODESTRUCT
  delete SurfaceOfRevolutionCheckedTypePair;
  #endif
}

void SurfaceOfRevolutionCheckedType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  SurfaceOfRevolutionCheckedTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

SurfaceOfRevolutionCheckedTypeChoicePair * SurfaceOfRevolutionCheckedType::getSurfaceOfRevolutionCheckedTypePair()
{return SurfaceOfRevolutionCheckedTypePair;}

void SurfaceOfRevolutionCheckedType::setSurfaceOfRevolutionCheckedTypePair(SurfaceOfRevolutionCheckedTypeChoicePair * SurfaceOfRevolutionCheckedTypePairIn)
{SurfaceOfRevolutionCheckedTypePair = SurfaceOfRevolutionCheckedTypePairIn;}
SurfaceOfRevolutionCheckedTypeChoicePair::SurfaceOfRevolutionCheckedTypeChoicePair() {}

SurfaceOfRevolutionCheckedTypeChoicePair::SurfaceOfRevolutionCheckedTypeChoicePair(
 whichOne SurfaceOfRevolutionCheckedTypeTypeIn,
 SurfaceOfRevolutionCheckedTypeVal * SurfaceOfRevolutionCheckedTypeValueIn)
{
  SurfaceOfRevolutionCheckedTypeType = SurfaceOfRevolutionCheckedTypeTypeIn;
  SurfaceOfRevolutionCheckedTypeValue = SurfaceOfRevolutionCheckedTypeValueIn;
}

SurfaceOfRevolutionCheckedTypeChoicePair::~SurfaceOfRevolutionCheckedTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (SurfaceOfRevolutionCheckedTypeType == MeasuredE)
    delete SurfaceOfRevolutionCheckedTypeValue->Measured;
  else if (SurfaceOfRevolutionCheckedTypeType == ConstructedE)
    delete SurfaceOfRevolutionCheckedTypeValue->Constructed;
  delete SurfaceOfRevolutionCheckedTypeValue;
  #endif
}

void SurfaceOfRevolutionCheckedTypeChoicePair::printSelf(FILE * outFile)
{
  if (SurfaceOfRevolutionCheckedTypeType == MeasuredE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Measured");
      SurfaceOfRevolutionCheckedTypeValue->Measured->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Measured>\n");
    }
  else if (SurfaceOfRevolutionCheckedTypeType == ConstructedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      SurfaceOfRevolutionCheckedTypeValue->Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
}

/* ***************************************************************** */

/* class SurfaceOfRevolutionConstructionMethodType

*/

SurfaceOfRevolutionConstructionMethodType::SurfaceOfRevolutionConstructionMethodType()
{
  SurfaceOfRevolutionConstructionMethodTypePair = 0;
}

SurfaceOfRevolutionConstructionMethodType::SurfaceOfRevolutionConstructionMethodType(
 SurfaceOfRevolutionConstructionMethodTypeChoicePair * SurfaceOfRevolutionConstructionMethodTypePairIn)
{
  SurfaceOfRevolutionConstructionMethodTypePair = SurfaceOfRevolutionConstructionMethodTypePairIn;
}

SurfaceOfRevolutionConstructionMethodType::~SurfaceOfRevolutionConstructionMethodType()
{
  #ifndef NODESTRUCT
  delete SurfaceOfRevolutionConstructionMethodTypePair;
  #endif
}

void SurfaceOfRevolutionConstructionMethodType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (SurfaceOfRevolutionConstructionMethodTypePair)
    {
      SurfaceOfRevolutionConstructionMethodTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

SurfaceOfRevolutionConstructionMethodTypeChoicePair * SurfaceOfRevolutionConstructionMethodType::getSurfaceOfRevolutionConstructionMethodTypePair()
{return SurfaceOfRevolutionConstructionMethodTypePair;}

void SurfaceOfRevolutionConstructionMethodType::setSurfaceOfRevolutionConstructionMethodTypePair(SurfaceOfRevolutionConstructionMethodTypeChoicePair * SurfaceOfRevolutionConstructionMethodTypePairIn)
{SurfaceOfRevolutionConstructionMethodTypePair = SurfaceOfRevolutionConstructionMethodTypePairIn;}
SurfaceOfRevolutionConstructionMethodTypeChoicePair::SurfaceOfRevolutionConstructionMethodTypeChoicePair() {}

SurfaceOfRevolutionConstructionMethodTypeChoicePair::SurfaceOfRevolutionConstructionMethodTypeChoicePair(
 whichOne SurfaceOfRevolutionConstructionMethodTypeTypeIn,
 SurfaceOfRevolutionConstructionMethodTypeVal * SurfaceOfRevolutionConstructionMethodTypeValueIn)
{
  SurfaceOfRevolutionConstructionMethodTypeType = SurfaceOfRevolutionConstructionMethodTypeTypeIn;
  SurfaceOfRevolutionConstructionMethodTypeValue = SurfaceOfRevolutionConstructionMethodTypeValueIn;
}

SurfaceOfRevolutionConstructionMethodTypeChoicePair::~SurfaceOfRevolutionConstructionMethodTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (SurfaceOfRevolutionConstructionMethodTypeType == BestFitE)
    delete SurfaceOfRevolutionConstructionMethodTypeValue->BestFit;
  else if (SurfaceOfRevolutionConstructionMethodTypeType == RecompensatedE)
    delete SurfaceOfRevolutionConstructionMethodTypeValue->Recompensated;
  else if (SurfaceOfRevolutionConstructionMethodTypeType == CopyE)
    delete SurfaceOfRevolutionConstructionMethodTypeValue->Copy;
  else if (SurfaceOfRevolutionConstructionMethodTypeType == CastE)
    delete SurfaceOfRevolutionConstructionMethodTypeValue->Cast;
  else if (SurfaceOfRevolutionConstructionMethodTypeType == TransformE)
    delete SurfaceOfRevolutionConstructionMethodTypeValue->Transform;
  delete SurfaceOfRevolutionConstructionMethodTypeValue;
  #endif
}

void SurfaceOfRevolutionConstructionMethodTypeChoicePair::printSelf(FILE * outFile)
{
  if (SurfaceOfRevolutionConstructionMethodTypeType == BestFitE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BestFit");
      SurfaceOfRevolutionConstructionMethodTypeValue->BestFit->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BestFit>\n");
    }
  else if (SurfaceOfRevolutionConstructionMethodTypeType == RecompensatedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Recompensated");
      SurfaceOfRevolutionConstructionMethodTypeValue->Recompensated->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Recompensated>\n");
    }
  else if (SurfaceOfRevolutionConstructionMethodTypeType == CopyE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Copy");
      SurfaceOfRevolutionConstructionMethodTypeValue->Copy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Copy>\n");
    }
  else if (SurfaceOfRevolutionConstructionMethodTypeType == CastE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Cast");
      SurfaceOfRevolutionConstructionMethodTypeValue->Cast->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Cast>\n");
    }
  else if (SurfaceOfRevolutionConstructionMethodTypeType == TransformE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Transform");
      SurfaceOfRevolutionConstructionMethodTypeValue->Transform->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Transform>\n");
    }
}

/* ***************************************************************** */

/* class SurfaceOfRevolutionCopyType

*/

SurfaceOfRevolutionCopyType::SurfaceOfRevolutionCopyType() :
  ConstructionMethodBaseType()
{
  BaseSurfaceOfRevolution = 0;
}

SurfaceOfRevolutionCopyType::SurfaceOfRevolutionCopyType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseSurfaceOfRevolutionIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseSurfaceOfRevolution = BaseSurfaceOfRevolutionIn;
}

SurfaceOfRevolutionCopyType::~SurfaceOfRevolutionCopyType()
{
  #ifndef NODESTRUCT
  delete BaseSurfaceOfRevolution;
  #endif
}

void SurfaceOfRevolutionCopyType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseSurfaceOfRevolution");
  BaseSurfaceOfRevolution->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseSurfaceOfRevolution>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * SurfaceOfRevolutionCopyType::getBaseSurfaceOfRevolution()
{return BaseSurfaceOfRevolution;}

void SurfaceOfRevolutionCopyType::setBaseSurfaceOfRevolution(BaseFeatureType * BaseSurfaceOfRevolutionIn)
{BaseSurfaceOfRevolution = BaseSurfaceOfRevolutionIn;}

/* ***************************************************************** */

/* class SurfaceOfRevolutionFeatureDefinitionType

*/

SurfaceOfRevolutionFeatureDefinitionType::SurfaceOfRevolutionFeatureDefinitionType() :
  SurfaceFeatureDefinitionBaseType()
{
  InternalExternal = 0;
  Length = 0;
}

SurfaceOfRevolutionFeatureDefinitionType::SurfaceOfRevolutionFeatureDefinitionType(
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * LengthIn) :
  SurfaceFeatureDefinitionBaseType(
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  Length = LengthIn;
}

SurfaceOfRevolutionFeatureDefinitionType::SurfaceOfRevolutionFeatureDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * LengthIn) :
  SurfaceFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  Length = LengthIn;
}

SurfaceOfRevolutionFeatureDefinitionType::~SurfaceOfRevolutionFeatureDefinitionType()
{
  #ifndef NODESTRUCT
  delete InternalExternal;
  delete Length;
  #endif
}

void SurfaceOfRevolutionFeatureDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<InternalExternal");
  InternalExternal->printSelf(outFile);
  fprintf(outFile, "</InternalExternal>\n");
  if (Length)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Length");
      Length->printSelf(outFile);
      fprintf(outFile, "</Length>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SurfaceOfRevolutionFeatureDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SurfaceOfRevolutionFeatureDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SurfaceOfRevolutionFeatureDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SurfaceOfRevolutionFeatureDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SurfaceOfRevolutionFeatureDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

InternalExternalEnumType * SurfaceOfRevolutionFeatureDefinitionType::getInternalExternal()
{return InternalExternal;}

void SurfaceOfRevolutionFeatureDefinitionType::setInternalExternal(InternalExternalEnumType * InternalExternalIn)
{InternalExternal = InternalExternalIn;}

LinearValueType * SurfaceOfRevolutionFeatureDefinitionType::getLength()
{return Length;}

void SurfaceOfRevolutionFeatureDefinitionType::setLength(LinearValueType * LengthIn)
{Length = LengthIn;}

/* ***************************************************************** */

/* class SurfaceOfRevolutionFeatureItemType

*/

SurfaceOfRevolutionFeatureItemType::SurfaceOfRevolutionFeatureItemType() :
  SurfaceFeatureItemBaseType()
{
  DeterminationMode = 0;
}

SurfaceOfRevolutionFeatureItemType::SurfaceOfRevolutionFeatureItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 SurfaceOfRevolutionMeasurementDeterminationType * DeterminationModeIn) :
  SurfaceFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

SurfaceOfRevolutionFeatureItemType::SurfaceOfRevolutionFeatureItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 SurfaceOfRevolutionMeasurementDeterminationType * DeterminationModeIn) :
  SurfaceFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

SurfaceOfRevolutionFeatureItemType::~SurfaceOfRevolutionFeatureItemType()
{
  #ifndef NODESTRUCT
  delete DeterminationMode;
  #endif
}

void SurfaceOfRevolutionFeatureItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<DeterminationMode");
  DeterminationMode->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeterminationMode>\n");
  doSpaces(-INDENT, outFile);
}

bool SurfaceOfRevolutionFeatureItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SurfaceOfRevolutionFeatureItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SurfaceOfRevolutionFeatureItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SurfaceOfRevolutionFeatureItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SurfaceOfRevolutionFeatureItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

SurfaceOfRevolutionMeasurementDeterminationType * SurfaceOfRevolutionFeatureItemType::getDeterminationMode()
{return DeterminationMode;}

void SurfaceOfRevolutionFeatureItemType::setDeterminationMode(SurfaceOfRevolutionMeasurementDeterminationType * DeterminationModeIn)
{DeterminationMode = DeterminationModeIn;}

/* ***************************************************************** */

/* class SurfaceOfRevolutionFeatureMeasurementType

*/

SurfaceOfRevolutionFeatureMeasurementType::SurfaceOfRevolutionFeatureMeasurementType() :
  SurfaceFeatureMeasurementBaseType()
{
  Axis = 0;
  SweepMeasurementRange = 0;
  SweepFull = 0;
  Length = 0;
  Form = 0;
}

SurfaceOfRevolutionFeatureMeasurementType::SurfaceOfRevolutionFeatureMeasurementType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredAxisType * AxisIn,
 SweepType * SweepMeasurementRangeIn,
 SweepType * SweepFullIn,
 MeasuredLinearValueType * LengthIn,
 MeasuredLinearValueType * FormIn) :
  SurfaceFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Axis = AxisIn;
  SweepMeasurementRange = SweepMeasurementRangeIn;
  SweepFull = SweepFullIn;
  Length = LengthIn;
  Form = FormIn;
}

SurfaceOfRevolutionFeatureMeasurementType::SurfaceOfRevolutionFeatureMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredAxisType * AxisIn,
 SweepType * SweepMeasurementRangeIn,
 SweepType * SweepFullIn,
 MeasuredLinearValueType * LengthIn,
 MeasuredLinearValueType * FormIn) :
  SurfaceFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Axis = AxisIn;
  SweepMeasurementRange = SweepMeasurementRangeIn;
  SweepFull = SweepFullIn;
  Length = LengthIn;
  Form = FormIn;
}

SurfaceOfRevolutionFeatureMeasurementType::~SurfaceOfRevolutionFeatureMeasurementType()
{
  #ifndef NODESTRUCT
  delete Axis;
  delete SweepMeasurementRange;
  delete SweepFull;
  delete Length;
  delete Form;
  #endif
}

void SurfaceOfRevolutionFeatureMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  if (Axis)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Axis");
      Axis->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Axis>\n");
    }
  if (SweepMeasurementRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SweepMeasurementRange");
      SweepMeasurementRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SweepMeasurementRange>\n");
    }
  if (SweepFull)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SweepFull");
      SweepFull->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SweepFull>\n");
    }
  if (Length)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Length");
      Length->printSelf(outFile);
      fprintf(outFile, "</Length>\n");
    }
  if (Form)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Form");
      Form->printSelf(outFile);
      fprintf(outFile, "</Form>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SurfaceOfRevolutionFeatureMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SurfaceOfRevolutionFeatureMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SurfaceOfRevolutionFeatureMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SurfaceOfRevolutionFeatureMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SurfaceOfRevolutionFeatureMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredAxisType * SurfaceOfRevolutionFeatureMeasurementType::getAxis()
{return Axis;}

void SurfaceOfRevolutionFeatureMeasurementType::setAxis(MeasuredAxisType * AxisIn)
{Axis = AxisIn;}

SweepType * SurfaceOfRevolutionFeatureMeasurementType::getSweepMeasurementRange()
{return SweepMeasurementRange;}

void SurfaceOfRevolutionFeatureMeasurementType::setSweepMeasurementRange(SweepType * SweepMeasurementRangeIn)
{SweepMeasurementRange = SweepMeasurementRangeIn;}

SweepType * SurfaceOfRevolutionFeatureMeasurementType::getSweepFull()
{return SweepFull;}

void SurfaceOfRevolutionFeatureMeasurementType::setSweepFull(SweepType * SweepFullIn)
{SweepFull = SweepFullIn;}

MeasuredLinearValueType * SurfaceOfRevolutionFeatureMeasurementType::getLength()
{return Length;}

void SurfaceOfRevolutionFeatureMeasurementType::setLength(MeasuredLinearValueType * LengthIn)
{Length = LengthIn;}

MeasuredLinearValueType * SurfaceOfRevolutionFeatureMeasurementType::getForm()
{return Form;}

void SurfaceOfRevolutionFeatureMeasurementType::setForm(MeasuredLinearValueType * FormIn)
{Form = FormIn;}

/* ***************************************************************** */

/* class SurfaceOfRevolutionFeatureNominalType

*/

SurfaceOfRevolutionFeatureNominalType::SurfaceOfRevolutionFeatureNominalType() :
  SurfaceFeatureNominalBaseType()
{
  Axis = 0;
  Sweep = 0;
  ReferenceFeatureNominalId = 0;
  Constructed = 0;
}

SurfaceOfRevolutionFeatureNominalType::SurfaceOfRevolutionFeatureNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 AxisType * AxisIn,
 SweepType * SweepIn,
 QIFReferenceFullType * ReferenceFeatureNominalIdIn,
 SurfaceOfRevolutionConstructionMethodType * ConstructedIn) :
  SurfaceFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  Axis = AxisIn;
  Sweep = SweepIn;
  ReferenceFeatureNominalId = ReferenceFeatureNominalIdIn;
  Constructed = ConstructedIn;
}

SurfaceOfRevolutionFeatureNominalType::SurfaceOfRevolutionFeatureNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 AxisType * AxisIn,
 SweepType * SweepIn,
 QIFReferenceFullType * ReferenceFeatureNominalIdIn,
 SurfaceOfRevolutionConstructionMethodType * ConstructedIn) :
  SurfaceFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  Axis = AxisIn;
  Sweep = SweepIn;
  ReferenceFeatureNominalId = ReferenceFeatureNominalIdIn;
  Constructed = ConstructedIn;
}

SurfaceOfRevolutionFeatureNominalType::~SurfaceOfRevolutionFeatureNominalType()
{
  #ifndef NODESTRUCT
  delete Axis;
  delete Sweep;
  delete ReferenceFeatureNominalId;
  delete Constructed;
  #endif
}

void SurfaceOfRevolutionFeatureNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Axis");
  Axis->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Axis>\n");
  if (Sweep)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Sweep");
      Sweep->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Sweep>\n");
    }
  if (ReferenceFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ReferenceFeatureNominalId");
      ReferenceFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ReferenceFeatureNominalId>\n");
    }
  if (Constructed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SurfaceOfRevolutionFeatureNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SurfaceOfRevolutionFeatureNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SurfaceOfRevolutionFeatureNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SurfaceOfRevolutionFeatureNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SurfaceOfRevolutionFeatureNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

AxisType * SurfaceOfRevolutionFeatureNominalType::getAxis()
{return Axis;}

void SurfaceOfRevolutionFeatureNominalType::setAxis(AxisType * AxisIn)
{Axis = AxisIn;}

SweepType * SurfaceOfRevolutionFeatureNominalType::getSweep()
{return Sweep;}

void SurfaceOfRevolutionFeatureNominalType::setSweep(SweepType * SweepIn)
{Sweep = SweepIn;}

QIFReferenceFullType * SurfaceOfRevolutionFeatureNominalType::getReferenceFeatureNominalId()
{return ReferenceFeatureNominalId;}

void SurfaceOfRevolutionFeatureNominalType::setReferenceFeatureNominalId(QIFReferenceFullType * ReferenceFeatureNominalIdIn)
{ReferenceFeatureNominalId = ReferenceFeatureNominalIdIn;}

SurfaceOfRevolutionConstructionMethodType * SurfaceOfRevolutionFeatureNominalType::getConstructed()
{return Constructed;}

void SurfaceOfRevolutionFeatureNominalType::setConstructed(SurfaceOfRevolutionConstructionMethodType * ConstructedIn)
{Constructed = ConstructedIn;}

/* ***************************************************************** */

/* class SurfaceOfRevolutionMeasurementDeterminationType

*/

SurfaceOfRevolutionMeasurementDeterminationType::SurfaceOfRevolutionMeasurementDeterminationType()
{
  SurfaceOfRevolutionMeasurementDeterminationTypePair = 0;
}

SurfaceOfRevolutionMeasurementDeterminationType::SurfaceOfRevolutionMeasurementDeterminationType(
 SurfaceOfRevolutionMeasurementDeterminationTypeChoicePair * SurfaceOfRevolutionMeasurementDeterminationTypePairIn)
{
  SurfaceOfRevolutionMeasurementDeterminationTypePair = SurfaceOfRevolutionMeasurementDeterminationTypePairIn;
}

SurfaceOfRevolutionMeasurementDeterminationType::~SurfaceOfRevolutionMeasurementDeterminationType()
{
  #ifndef NODESTRUCT
  delete SurfaceOfRevolutionMeasurementDeterminationTypePair;
  #endif
}

void SurfaceOfRevolutionMeasurementDeterminationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  SurfaceOfRevolutionMeasurementDeterminationTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

SurfaceOfRevolutionMeasurementDeterminationTypeChoicePair * SurfaceOfRevolutionMeasurementDeterminationType::getSurfaceOfRevolutionMeasurementDeterminationTypePair()
{return SurfaceOfRevolutionMeasurementDeterminationTypePair;}

void SurfaceOfRevolutionMeasurementDeterminationType::setSurfaceOfRevolutionMeasurementDeterminationTypePair(SurfaceOfRevolutionMeasurementDeterminationTypeChoicePair * SurfaceOfRevolutionMeasurementDeterminationTypePairIn)
{SurfaceOfRevolutionMeasurementDeterminationTypePair = SurfaceOfRevolutionMeasurementDeterminationTypePairIn;}
SurfaceOfRevolutionMeasurementDeterminationTypeChoicePair::SurfaceOfRevolutionMeasurementDeterminationTypeChoicePair() {}

SurfaceOfRevolutionMeasurementDeterminationTypeChoicePair::SurfaceOfRevolutionMeasurementDeterminationTypeChoicePair(
 whichOne SurfaceOfRevolutionMeasurementDeterminationTypeTypeIn,
 SurfaceOfRevolutionMeasurementDeterminationTypeVal * SurfaceOfRevolutionMeasurementDeterminationTypeValueIn)
{
  SurfaceOfRevolutionMeasurementDeterminationTypeType = SurfaceOfRevolutionMeasurementDeterminationTypeTypeIn;
  SurfaceOfRevolutionMeasurementDeterminationTypeValue = SurfaceOfRevolutionMeasurementDeterminationTypeValueIn;
}

SurfaceOfRevolutionMeasurementDeterminationTypeChoicePair::~SurfaceOfRevolutionMeasurementDeterminationTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (SurfaceOfRevolutionMeasurementDeterminationTypeType == CheckedE)
    delete SurfaceOfRevolutionMeasurementDeterminationTypeValue->Checked;
  else if (SurfaceOfRevolutionMeasurementDeterminationTypeType == SetE)
    delete SurfaceOfRevolutionMeasurementDeterminationTypeValue->Set;
  delete SurfaceOfRevolutionMeasurementDeterminationTypeValue;
  #endif
}

void SurfaceOfRevolutionMeasurementDeterminationTypeChoicePair::printSelf(FILE * outFile)
{
  if (SurfaceOfRevolutionMeasurementDeterminationTypeType == CheckedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Checked");
      SurfaceOfRevolutionMeasurementDeterminationTypeValue->Checked->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Checked>\n");
    }
  else if (SurfaceOfRevolutionMeasurementDeterminationTypeType == SetE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Set");
      SurfaceOfRevolutionMeasurementDeterminationTypeValue->Set->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class SurfaceOfRevolutionRecompType

*/

SurfaceOfRevolutionRecompType::SurfaceOfRevolutionRecompType() :
  ConstructionMethodBaseType()
{
  BaseFeaturePointList = 0;
}

SurfaceOfRevolutionRecompType::SurfaceOfRevolutionRecompType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeaturePointListType * BaseFeaturePointListIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeaturePointList = BaseFeaturePointListIn;
}

SurfaceOfRevolutionRecompType::~SurfaceOfRevolutionRecompType()
{
  #ifndef NODESTRUCT
  delete BaseFeaturePointList;
  #endif
}

void SurfaceOfRevolutionRecompType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeaturePointList");
  BaseFeaturePointList->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeaturePointList>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeaturePointListType * SurfaceOfRevolutionRecompType::getBaseFeaturePointList()
{return BaseFeaturePointList;}

void SurfaceOfRevolutionRecompType::setBaseFeaturePointList(BaseFeaturePointListType * BaseFeaturePointListIn)
{BaseFeaturePointList = BaseFeaturePointListIn;}

/* ***************************************************************** */

/* class SurfaceOfRevolutionTransformType

*/

SurfaceOfRevolutionTransformType::SurfaceOfRevolutionTransformType() :
  ConstructionMethodBaseType()
{
  BaseSurfaceOfRevolution = 0;
  Transformation = 0;
}

SurfaceOfRevolutionTransformType::SurfaceOfRevolutionTransformType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseSurfaceOfRevolutionIn,
 TransformationReferenceType * TransformationIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseSurfaceOfRevolution = BaseSurfaceOfRevolutionIn;
  Transformation = TransformationIn;
}

SurfaceOfRevolutionTransformType::~SurfaceOfRevolutionTransformType()
{
  #ifndef NODESTRUCT
  delete BaseSurfaceOfRevolution;
  delete Transformation;
  #endif
}

void SurfaceOfRevolutionTransformType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseSurfaceOfRevolution");
  BaseSurfaceOfRevolution->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseSurfaceOfRevolution>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Transformation");
  Transformation->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Transformation>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * SurfaceOfRevolutionTransformType::getBaseSurfaceOfRevolution()
{return BaseSurfaceOfRevolution;}

void SurfaceOfRevolutionTransformType::setBaseSurfaceOfRevolution(BaseFeatureType * BaseSurfaceOfRevolutionIn)
{BaseSurfaceOfRevolution = BaseSurfaceOfRevolutionIn;}

TransformationReferenceType * SurfaceOfRevolutionTransformType::getTransformation()
{return Transformation;}

void SurfaceOfRevolutionTransformType::setTransformation(TransformationReferenceType * TransformationIn)
{Transformation = TransformationIn;}

/* ***************************************************************** */

/* class ThreadedFeatureBestFitType

*/

ThreadedFeatureBestFitType::ThreadedFeatureBestFitType() :
  ConstructionMethodBaseType()
{
  n = 0;
  BaseFeature = 0;
}

ThreadedFeatureBestFitType::ThreadedFeatureBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = 0;
  BaseFeature = BaseFeatureIn;
}

ThreadedFeatureBestFitType::ThreadedFeatureBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 NaturalType * nIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = nIn;
  BaseFeature = BaseFeatureIn;
}

ThreadedFeatureBestFitType::~ThreadedFeatureBestFitType()
{
  #ifndef NODESTRUCT
  delete n;
  delete BaseFeature;
  #endif
}

void ThreadedFeatureBestFitType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  {
    if (!BaseFeature)
      {
        fprintf(stderr, "BaseFeature list is missing\n");
        exit(1);
      }
    if (BaseFeature->size() == 0)
      {
        fprintf(stderr, "BaseFeature list is empty\n");
        exit(1);
      }
    if (BaseFeature->size() < 6)
      {
        fprintf(stderr,
                "size of BaseFeature list (%d) less than minimum required (6)\n",
                (int)BaseFeature->size());
        exit(1);
      }
    std::list<SequencedBaseFeatureType *>::iterator iter;
    for (iter = BaseFeature->begin();
         iter != BaseFeature->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<BaseFeature");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</BaseFeature>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool ThreadedFeatureBestFitType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in ThreadedFeatureBestFitType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in ThreadedFeatureBestFitType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ThreadedFeatureBestFitType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in ThreadedFeatureBestFitType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * ThreadedFeatureBestFitType::getn()
{return n;}

void ThreadedFeatureBestFitType::setn(NaturalType * nIn)
{n = nIn;}

SequencedBaseFeatureTypeLisd * ThreadedFeatureBestFitType::getBaseFeature()
{return BaseFeature;}

void ThreadedFeatureBestFitType::setBaseFeature(SequencedBaseFeatureTypeLisd * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class ThreadedFeatureCastType

*/

ThreadedFeatureCastType::ThreadedFeatureCastType() :
  ConstructionMethodBaseType()
{
  BaseFeature = 0;
}

ThreadedFeatureCastType::ThreadedFeatureCastType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeature = BaseFeatureIn;
}

ThreadedFeatureCastType::~ThreadedFeatureCastType()
{
  #ifndef NODESTRUCT
  delete BaseFeature;
  #endif
}

void ThreadedFeatureCastType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeature");
  BaseFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * ThreadedFeatureCastType::getBaseFeature()
{return BaseFeature;}

void ThreadedFeatureCastType::setBaseFeature(BaseFeatureType * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class ThreadedFeatureCheckedFeatureType

*/

ThreadedFeatureCheckedFeatureType::ThreadedFeatureCheckedFeatureType()
{
  CheckDetails = 0;
}

ThreadedFeatureCheckedFeatureType::ThreadedFeatureCheckedFeatureType(
 ThreadedFeatureCheckedType * CheckDetailsIn)
{
  CheckDetails = CheckDetailsIn;
}

ThreadedFeatureCheckedFeatureType::~ThreadedFeatureCheckedFeatureType()
{
  #ifndef NODESTRUCT
  delete CheckDetails;
  #endif
}

void ThreadedFeatureCheckedFeatureType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (CheckDetails)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CheckDetails");
      CheckDetails->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CheckDetails>\n");
    }
  doSpaces(-INDENT, outFile);
}

ThreadedFeatureCheckedType * ThreadedFeatureCheckedFeatureType::getCheckDetails()
{return CheckDetails;}

void ThreadedFeatureCheckedFeatureType::setCheckDetails(ThreadedFeatureCheckedType * CheckDetailsIn)
{CheckDetails = CheckDetailsIn;}

/* ***************************************************************** */

/* class ThreadedFeatureCheckedType

*/

ThreadedFeatureCheckedType::ThreadedFeatureCheckedType()
{
  ThreadedFeatureCheckedTypePair = 0;
}

ThreadedFeatureCheckedType::ThreadedFeatureCheckedType(
 ThreadedFeatureCheckedTypeChoicePair * ThreadedFeatureCheckedTypePairIn)
{
  ThreadedFeatureCheckedTypePair = ThreadedFeatureCheckedTypePairIn;
}

ThreadedFeatureCheckedType::~ThreadedFeatureCheckedType()
{
  #ifndef NODESTRUCT
  delete ThreadedFeatureCheckedTypePair;
  #endif
}

void ThreadedFeatureCheckedType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  ThreadedFeatureCheckedTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

ThreadedFeatureCheckedTypeChoicePair * ThreadedFeatureCheckedType::getThreadedFeatureCheckedTypePair()
{return ThreadedFeatureCheckedTypePair;}

void ThreadedFeatureCheckedType::setThreadedFeatureCheckedTypePair(ThreadedFeatureCheckedTypeChoicePair * ThreadedFeatureCheckedTypePairIn)
{ThreadedFeatureCheckedTypePair = ThreadedFeatureCheckedTypePairIn;}
ThreadedFeatureCheckedTypeChoicePair::ThreadedFeatureCheckedTypeChoicePair() {}

ThreadedFeatureCheckedTypeChoicePair::ThreadedFeatureCheckedTypeChoicePair(
 whichOne ThreadedFeatureCheckedTypeTypeIn,
 ThreadedFeatureCheckedTypeVal * ThreadedFeatureCheckedTypeValueIn)
{
  ThreadedFeatureCheckedTypeType = ThreadedFeatureCheckedTypeTypeIn;
  ThreadedFeatureCheckedTypeValue = ThreadedFeatureCheckedTypeValueIn;
}

ThreadedFeatureCheckedTypeChoicePair::~ThreadedFeatureCheckedTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (ThreadedFeatureCheckedTypeType == MeasuredE)
    delete ThreadedFeatureCheckedTypeValue->Measured;
  else if (ThreadedFeatureCheckedTypeType == ConstructedE)
    delete ThreadedFeatureCheckedTypeValue->Constructed;
  delete ThreadedFeatureCheckedTypeValue;
  #endif
}

void ThreadedFeatureCheckedTypeChoicePair::printSelf(FILE * outFile)
{
  if (ThreadedFeatureCheckedTypeType == MeasuredE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Measured");
      ThreadedFeatureCheckedTypeValue->Measured->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Measured>\n");
    }
  else if (ThreadedFeatureCheckedTypeType == ConstructedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      ThreadedFeatureCheckedTypeValue->Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
}

/* ***************************************************************** */

/* class ThreadedFeatureConstructionMethodType

*/

ThreadedFeatureConstructionMethodType::ThreadedFeatureConstructionMethodType()
{
  ThreadedFeatureConstructionMethodTypePair = 0;
}

ThreadedFeatureConstructionMethodType::ThreadedFeatureConstructionMethodType(
 ThreadedFeatureConstructionMethodTypeChoicePair * ThreadedFeatureConstructionMethodTypePairIn)
{
  ThreadedFeatureConstructionMethodTypePair = ThreadedFeatureConstructionMethodTypePairIn;
}

ThreadedFeatureConstructionMethodType::~ThreadedFeatureConstructionMethodType()
{
  #ifndef NODESTRUCT
  delete ThreadedFeatureConstructionMethodTypePair;
  #endif
}

void ThreadedFeatureConstructionMethodType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (ThreadedFeatureConstructionMethodTypePair)
    {
      ThreadedFeatureConstructionMethodTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

ThreadedFeatureConstructionMethodTypeChoicePair * ThreadedFeatureConstructionMethodType::getThreadedFeatureConstructionMethodTypePair()
{return ThreadedFeatureConstructionMethodTypePair;}

void ThreadedFeatureConstructionMethodType::setThreadedFeatureConstructionMethodTypePair(ThreadedFeatureConstructionMethodTypeChoicePair * ThreadedFeatureConstructionMethodTypePairIn)
{ThreadedFeatureConstructionMethodTypePair = ThreadedFeatureConstructionMethodTypePairIn;}
ThreadedFeatureConstructionMethodTypeChoicePair::ThreadedFeatureConstructionMethodTypeChoicePair() {}

ThreadedFeatureConstructionMethodTypeChoicePair::ThreadedFeatureConstructionMethodTypeChoicePair(
 whichOne ThreadedFeatureConstructionMethodTypeTypeIn,
 ThreadedFeatureConstructionMethodTypeVal * ThreadedFeatureConstructionMethodTypeValueIn)
{
  ThreadedFeatureConstructionMethodTypeType = ThreadedFeatureConstructionMethodTypeTypeIn;
  ThreadedFeatureConstructionMethodTypeValue = ThreadedFeatureConstructionMethodTypeValueIn;
}

ThreadedFeatureConstructionMethodTypeChoicePair::~ThreadedFeatureConstructionMethodTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (ThreadedFeatureConstructionMethodTypeType == BestFitE)
    delete ThreadedFeatureConstructionMethodTypeValue->BestFit;
  else if (ThreadedFeatureConstructionMethodTypeType == RecompensatedE)
    delete ThreadedFeatureConstructionMethodTypeValue->Recompensated;
  else if (ThreadedFeatureConstructionMethodTypeType == CopyE)
    delete ThreadedFeatureConstructionMethodTypeValue->Copy;
  else if (ThreadedFeatureConstructionMethodTypeType == CastE)
    delete ThreadedFeatureConstructionMethodTypeValue->Cast;
  else if (ThreadedFeatureConstructionMethodTypeType == TransformE)
    delete ThreadedFeatureConstructionMethodTypeValue->Transform;
  else if (ThreadedFeatureConstructionMethodTypeType == FromCylinderE)
    delete ThreadedFeatureConstructionMethodTypeValue->FromCylinder;
  delete ThreadedFeatureConstructionMethodTypeValue;
  #endif
}

void ThreadedFeatureConstructionMethodTypeChoicePair::printSelf(FILE * outFile)
{
  if (ThreadedFeatureConstructionMethodTypeType == BestFitE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BestFit");
      ThreadedFeatureConstructionMethodTypeValue->BestFit->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BestFit>\n");
    }
  else if (ThreadedFeatureConstructionMethodTypeType == RecompensatedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Recompensated");
      ThreadedFeatureConstructionMethodTypeValue->Recompensated->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Recompensated>\n");
    }
  else if (ThreadedFeatureConstructionMethodTypeType == CopyE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Copy");
      ThreadedFeatureConstructionMethodTypeValue->Copy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Copy>\n");
    }
  else if (ThreadedFeatureConstructionMethodTypeType == CastE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Cast");
      ThreadedFeatureConstructionMethodTypeValue->Cast->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Cast>\n");
    }
  else if (ThreadedFeatureConstructionMethodTypeType == TransformE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Transform");
      ThreadedFeatureConstructionMethodTypeValue->Transform->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Transform>\n");
    }
  else if (ThreadedFeatureConstructionMethodTypeType == FromCylinderE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FromCylinder");
      ThreadedFeatureConstructionMethodTypeValue->FromCylinder->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FromCylinder>\n");
    }
}

/* ***************************************************************** */

/* class ThreadedFeatureCopyType

*/

ThreadedFeatureCopyType::ThreadedFeatureCopyType() :
  ConstructionMethodBaseType()
{
  BaseThreadedFeature = 0;
}

ThreadedFeatureCopyType::ThreadedFeatureCopyType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseThreadedFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseThreadedFeature = BaseThreadedFeatureIn;
}

ThreadedFeatureCopyType::~ThreadedFeatureCopyType()
{
  #ifndef NODESTRUCT
  delete BaseThreadedFeature;
  #endif
}

void ThreadedFeatureCopyType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseThreadedFeature");
  BaseThreadedFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseThreadedFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * ThreadedFeatureCopyType::getBaseThreadedFeature()
{return BaseThreadedFeature;}

void ThreadedFeatureCopyType::setBaseThreadedFeature(BaseFeatureType * BaseThreadedFeatureIn)
{BaseThreadedFeature = BaseThreadedFeatureIn;}

/* ***************************************************************** */

/* class ThreadedFeatureDefinitionType

*/

ThreadedFeatureDefinitionType::ThreadedFeatureDefinitionType() :
  SpecifiedFeatureDefinitionBaseType()
{
  InternalExternal = 0;
  ThreadSpecificationId = 0;
  Length = 0;
  Bottom = 0;
}

ThreadedFeatureDefinitionType::ThreadedFeatureDefinitionType(
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 QIFReferenceType * ThreadSpecificationIdIn,
 LinearValueType * LengthIn,
 BottomType * BottomIn) :
  SpecifiedFeatureDefinitionBaseType(
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  ThreadSpecificationId = ThreadSpecificationIdIn;
  Length = LengthIn;
  Bottom = BottomIn;
}

ThreadedFeatureDefinitionType::ThreadedFeatureDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 QIFReferenceType * ThreadSpecificationIdIn,
 LinearValueType * LengthIn,
 BottomType * BottomIn) :
  SpecifiedFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  ThreadSpecificationId = ThreadSpecificationIdIn;
  Length = LengthIn;
  Bottom = BottomIn;
}

ThreadedFeatureDefinitionType::~ThreadedFeatureDefinitionType()
{
  #ifndef NODESTRUCT
  delete InternalExternal;
  delete ThreadSpecificationId;
  delete Length;
  delete Bottom;
  #endif
}

void ThreadedFeatureDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<InternalExternal");
  InternalExternal->printSelf(outFile);
  fprintf(outFile, "</InternalExternal>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<ThreadSpecificationId");
  ThreadSpecificationId->printSelf(outFile);
  fprintf(outFile, "</ThreadSpecificationId>\n");
  if (Length)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Length");
      Length->printSelf(outFile);
      fprintf(outFile, "</Length>\n");
    }
  if (Bottom)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Bottom");
      Bottom->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Bottom>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ThreadedFeatureDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ThreadedFeatureDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ThreadedFeatureDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ThreadedFeatureDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ThreadedFeatureDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

InternalExternalEnumType * ThreadedFeatureDefinitionType::getInternalExternal()
{return InternalExternal;}

void ThreadedFeatureDefinitionType::setInternalExternal(InternalExternalEnumType * InternalExternalIn)
{InternalExternal = InternalExternalIn;}

QIFReferenceType * ThreadedFeatureDefinitionType::getThreadSpecificationId()
{return ThreadSpecificationId;}

void ThreadedFeatureDefinitionType::setThreadSpecificationId(QIFReferenceType * ThreadSpecificationIdIn)
{ThreadSpecificationId = ThreadSpecificationIdIn;}

LinearValueType * ThreadedFeatureDefinitionType::getLength()
{return Length;}

void ThreadedFeatureDefinitionType::setLength(LinearValueType * LengthIn)
{Length = LengthIn;}

BottomType * ThreadedFeatureDefinitionType::getBottom()
{return Bottom;}

void ThreadedFeatureDefinitionType::setBottom(BottomType * BottomIn)
{Bottom = BottomIn;}

/* ***************************************************************** */

/* class ThreadedFeatureFromCylinderType

*/

ThreadedFeatureFromCylinderType::ThreadedFeatureFromCylinderType() :
  ConstructionMethodBaseType()
{
  BaseCylinder = 0;
  Offset = 0;
}

ThreadedFeatureFromCylinderType::ThreadedFeatureFromCylinderType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseCylinderIn,
 LinearValueType * OffsetIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseCylinder = BaseCylinderIn;
  Offset = OffsetIn;
}

ThreadedFeatureFromCylinderType::~ThreadedFeatureFromCylinderType()
{
  #ifndef NODESTRUCT
  delete BaseCylinder;
  delete Offset;
  #endif
}

void ThreadedFeatureFromCylinderType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseCylinder");
  BaseCylinder->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseCylinder>\n");
  if (Offset)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Offset");
      Offset->printSelf(outFile);
      fprintf(outFile, "</Offset>\n");
    }
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * ThreadedFeatureFromCylinderType::getBaseCylinder()
{return BaseCylinder;}

void ThreadedFeatureFromCylinderType::setBaseCylinder(BaseFeatureType * BaseCylinderIn)
{BaseCylinder = BaseCylinderIn;}

LinearValueType * ThreadedFeatureFromCylinderType::getOffset()
{return Offset;}

void ThreadedFeatureFromCylinderType::setOffset(LinearValueType * OffsetIn)
{Offset = OffsetIn;}

/* ***************************************************************** */

/* class ThreadedFeatureItemType

*/

ThreadedFeatureItemType::ThreadedFeatureItemType() :
  SpecifiedFeatureItemBaseType()
{
  DeterminationMode = 0;
}

ThreadedFeatureItemType::ThreadedFeatureItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 ThreadedFeatureMeasurementDeterminationType * DeterminationModeIn) :
  SpecifiedFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

ThreadedFeatureItemType::ThreadedFeatureItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 ThreadedFeatureMeasurementDeterminationType * DeterminationModeIn) :
  SpecifiedFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

ThreadedFeatureItemType::~ThreadedFeatureItemType()
{
  #ifndef NODESTRUCT
  delete DeterminationMode;
  #endif
}

void ThreadedFeatureItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<DeterminationMode");
  DeterminationMode->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeterminationMode>\n");
  doSpaces(-INDENT, outFile);
}

bool ThreadedFeatureItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ThreadedFeatureItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ThreadedFeatureItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ThreadedFeatureItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ThreadedFeatureItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

ThreadedFeatureMeasurementDeterminationType * ThreadedFeatureItemType::getDeterminationMode()
{return DeterminationMode;}

void ThreadedFeatureItemType::setDeterminationMode(ThreadedFeatureMeasurementDeterminationType * DeterminationModeIn)
{DeterminationMode = DeterminationModeIn;}

/* ***************************************************************** */

/* class ThreadedFeatureMeasurementDeterminationType

*/

ThreadedFeatureMeasurementDeterminationType::ThreadedFeatureMeasurementDeterminationType()
{
  ThreadedFeatureMeasurementDeterminationTypePair = 0;
}

ThreadedFeatureMeasurementDeterminationType::ThreadedFeatureMeasurementDeterminationType(
 ThreadedFeatureMeasurementDeterminationTypeChoicePair * ThreadedFeatureMeasurementDeterminationTypePairIn)
{
  ThreadedFeatureMeasurementDeterminationTypePair = ThreadedFeatureMeasurementDeterminationTypePairIn;
}

ThreadedFeatureMeasurementDeterminationType::~ThreadedFeatureMeasurementDeterminationType()
{
  #ifndef NODESTRUCT
  delete ThreadedFeatureMeasurementDeterminationTypePair;
  #endif
}

void ThreadedFeatureMeasurementDeterminationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  ThreadedFeatureMeasurementDeterminationTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

ThreadedFeatureMeasurementDeterminationTypeChoicePair * ThreadedFeatureMeasurementDeterminationType::getThreadedFeatureMeasurementDeterminationTypePair()
{return ThreadedFeatureMeasurementDeterminationTypePair;}

void ThreadedFeatureMeasurementDeterminationType::setThreadedFeatureMeasurementDeterminationTypePair(ThreadedFeatureMeasurementDeterminationTypeChoicePair * ThreadedFeatureMeasurementDeterminationTypePairIn)
{ThreadedFeatureMeasurementDeterminationTypePair = ThreadedFeatureMeasurementDeterminationTypePairIn;}
ThreadedFeatureMeasurementDeterminationTypeChoicePair::ThreadedFeatureMeasurementDeterminationTypeChoicePair() {}

ThreadedFeatureMeasurementDeterminationTypeChoicePair::ThreadedFeatureMeasurementDeterminationTypeChoicePair(
 whichOne ThreadedFeatureMeasurementDeterminationTypeTypeIn,
 ThreadedFeatureMeasurementDeterminationTypeVal * ThreadedFeatureMeasurementDeterminationTypeValueIn)
{
  ThreadedFeatureMeasurementDeterminationTypeType = ThreadedFeatureMeasurementDeterminationTypeTypeIn;
  ThreadedFeatureMeasurementDeterminationTypeValue = ThreadedFeatureMeasurementDeterminationTypeValueIn;
}

ThreadedFeatureMeasurementDeterminationTypeChoicePair::~ThreadedFeatureMeasurementDeterminationTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (ThreadedFeatureMeasurementDeterminationTypeType == CheckedE)
    delete ThreadedFeatureMeasurementDeterminationTypeValue->Checked;
  else if (ThreadedFeatureMeasurementDeterminationTypeType == SetE)
    delete ThreadedFeatureMeasurementDeterminationTypeValue->Set;
  delete ThreadedFeatureMeasurementDeterminationTypeValue;
  #endif
}

void ThreadedFeatureMeasurementDeterminationTypeChoicePair::printSelf(FILE * outFile)
{
  if (ThreadedFeatureMeasurementDeterminationTypeType == CheckedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Checked");
      ThreadedFeatureMeasurementDeterminationTypeValue->Checked->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Checked>\n");
    }
  else if (ThreadedFeatureMeasurementDeterminationTypeType == SetE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Set");
      ThreadedFeatureMeasurementDeterminationTypeValue->Set->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class ThreadedFeatureMeasurementType

*/

ThreadedFeatureMeasurementType::ThreadedFeatureMeasurementType() :
  SpecifiedFeatureMeasurementBaseType()
{
  Axis = 0;
  PitchDiameter = 0;
  FunctionalSize = 0;
  Length = 0;
}

ThreadedFeatureMeasurementType::ThreadedFeatureMeasurementType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredAxisType * AxisIn,
 MeasuredLinearValueType * PitchDiameterIn,
 MeasuredLinearValueType * FunctionalSizeIn,
 MeasuredLinearValueType * LengthIn) :
  SpecifiedFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Axis = AxisIn;
  PitchDiameter = PitchDiameterIn;
  FunctionalSize = FunctionalSizeIn;
  Length = LengthIn;
}

ThreadedFeatureMeasurementType::ThreadedFeatureMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredAxisType * AxisIn,
 MeasuredLinearValueType * PitchDiameterIn,
 MeasuredLinearValueType * FunctionalSizeIn,
 MeasuredLinearValueType * LengthIn) :
  SpecifiedFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Axis = AxisIn;
  PitchDiameter = PitchDiameterIn;
  FunctionalSize = FunctionalSizeIn;
  Length = LengthIn;
}

ThreadedFeatureMeasurementType::~ThreadedFeatureMeasurementType()
{
  #ifndef NODESTRUCT
  delete Axis;
  delete PitchDiameter;
  delete FunctionalSize;
  delete Length;
  #endif
}

void ThreadedFeatureMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  if (Axis)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Axis");
      Axis->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Axis>\n");
    }
  if (PitchDiameter)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PitchDiameter");
      PitchDiameter->printSelf(outFile);
      fprintf(outFile, "</PitchDiameter>\n");
    }
  if (FunctionalSize)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FunctionalSize");
      FunctionalSize->printSelf(outFile);
      fprintf(outFile, "</FunctionalSize>\n");
    }
  if (Length)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Length");
      Length->printSelf(outFile);
      fprintf(outFile, "</Length>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ThreadedFeatureMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ThreadedFeatureMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ThreadedFeatureMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ThreadedFeatureMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ThreadedFeatureMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredAxisType * ThreadedFeatureMeasurementType::getAxis()
{return Axis;}

void ThreadedFeatureMeasurementType::setAxis(MeasuredAxisType * AxisIn)
{Axis = AxisIn;}

MeasuredLinearValueType * ThreadedFeatureMeasurementType::getPitchDiameter()
{return PitchDiameter;}

void ThreadedFeatureMeasurementType::setPitchDiameter(MeasuredLinearValueType * PitchDiameterIn)
{PitchDiameter = PitchDiameterIn;}

MeasuredLinearValueType * ThreadedFeatureMeasurementType::getFunctionalSize()
{return FunctionalSize;}

void ThreadedFeatureMeasurementType::setFunctionalSize(MeasuredLinearValueType * FunctionalSizeIn)
{FunctionalSize = FunctionalSizeIn;}

MeasuredLinearValueType * ThreadedFeatureMeasurementType::getLength()
{return Length;}

void ThreadedFeatureMeasurementType::setLength(MeasuredLinearValueType * LengthIn)
{Length = LengthIn;}

/* ***************************************************************** */

/* class ThreadedFeatureNominalType

*/

ThreadedFeatureNominalType::ThreadedFeatureNominalType() :
  SpecifiedFeatureNominalBaseType()
{
  Axis = 0;
  Constructed = 0;
}

ThreadedFeatureNominalType::ThreadedFeatureNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 AxisType * AxisIn,
 ThreadedFeatureConstructionMethodType * ConstructedIn) :
  SpecifiedFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  Axis = AxisIn;
  Constructed = ConstructedIn;
}

ThreadedFeatureNominalType::ThreadedFeatureNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 AxisType * AxisIn,
 ThreadedFeatureConstructionMethodType * ConstructedIn) :
  SpecifiedFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  Axis = AxisIn;
  Constructed = ConstructedIn;
}

ThreadedFeatureNominalType::~ThreadedFeatureNominalType()
{
  #ifndef NODESTRUCT
  delete Axis;
  delete Constructed;
  #endif
}

void ThreadedFeatureNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Axis");
  Axis->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Axis>\n");
  if (Constructed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ThreadedFeatureNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ThreadedFeatureNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ThreadedFeatureNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ThreadedFeatureNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ThreadedFeatureNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

AxisType * ThreadedFeatureNominalType::getAxis()
{return Axis;}

void ThreadedFeatureNominalType::setAxis(AxisType * AxisIn)
{Axis = AxisIn;}

ThreadedFeatureConstructionMethodType * ThreadedFeatureNominalType::getConstructed()
{return Constructed;}

void ThreadedFeatureNominalType::setConstructed(ThreadedFeatureConstructionMethodType * ConstructedIn)
{Constructed = ConstructedIn;}

/* ***************************************************************** */

/* class ThreadedFeatureRecompType

*/

ThreadedFeatureRecompType::ThreadedFeatureRecompType() :
  ConstructionMethodBaseType()
{
  BaseFeaturePointList = 0;
}

ThreadedFeatureRecompType::ThreadedFeatureRecompType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeaturePointListType * BaseFeaturePointListIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeaturePointList = BaseFeaturePointListIn;
}

ThreadedFeatureRecompType::~ThreadedFeatureRecompType()
{
  #ifndef NODESTRUCT
  delete BaseFeaturePointList;
  #endif
}

void ThreadedFeatureRecompType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeaturePointList");
  BaseFeaturePointList->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeaturePointList>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeaturePointListType * ThreadedFeatureRecompType::getBaseFeaturePointList()
{return BaseFeaturePointList;}

void ThreadedFeatureRecompType::setBaseFeaturePointList(BaseFeaturePointListType * BaseFeaturePointListIn)
{BaseFeaturePointList = BaseFeaturePointListIn;}

/* ***************************************************************** */

/* class ThreadedFeatureTransformType

*/

ThreadedFeatureTransformType::ThreadedFeatureTransformType() :
  ConstructionMethodBaseType()
{
  BaseThreadedFeature = 0;
  Transformation = 0;
}

ThreadedFeatureTransformType::ThreadedFeatureTransformType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseThreadedFeatureIn,
 TransformationReferenceType * TransformationIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseThreadedFeature = BaseThreadedFeatureIn;
  Transformation = TransformationIn;
}

ThreadedFeatureTransformType::~ThreadedFeatureTransformType()
{
  #ifndef NODESTRUCT
  delete BaseThreadedFeature;
  delete Transformation;
  #endif
}

void ThreadedFeatureTransformType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseThreadedFeature");
  BaseThreadedFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseThreadedFeature>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Transformation");
  Transformation->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Transformation>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * ThreadedFeatureTransformType::getBaseThreadedFeature()
{return BaseThreadedFeature;}

void ThreadedFeatureTransformType::setBaseThreadedFeature(BaseFeatureType * BaseThreadedFeatureIn)
{BaseThreadedFeature = BaseThreadedFeatureIn;}

TransformationReferenceType * ThreadedFeatureTransformType::getTransformation()
{return Transformation;}

void ThreadedFeatureTransformType::setTransformation(TransformationReferenceType * TransformationIn)
{Transformation = TransformationIn;}

/* ***************************************************************** */

/* class ToroidalSegmentBestFitType

*/

ToroidalSegmentBestFitType::ToroidalSegmentBestFitType() :
  ConstructionMethodBaseType()
{
  n = 0;
  BaseFeature = 0;
}

ToroidalSegmentBestFitType::ToroidalSegmentBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = 0;
  BaseFeature = BaseFeatureIn;
}

ToroidalSegmentBestFitType::ToroidalSegmentBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 NaturalType * nIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = nIn;
  BaseFeature = BaseFeatureIn;
}

ToroidalSegmentBestFitType::~ToroidalSegmentBestFitType()
{
  #ifndef NODESTRUCT
  delete n;
  delete BaseFeature;
  #endif
}

void ToroidalSegmentBestFitType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  {
    if (!BaseFeature)
      {
        fprintf(stderr, "BaseFeature list is missing\n");
        exit(1);
      }
    if (BaseFeature->size() == 0)
      {
        fprintf(stderr, "BaseFeature list is empty\n");
        exit(1);
      }
    if (BaseFeature->size() < 9)
      {
        fprintf(stderr,
                "size of BaseFeature list (%d) less than minimum required (9)\n",
                (int)BaseFeature->size());
        exit(1);
      }
    std::list<SequencedBaseFeatureType *>::iterator iter;
    for (iter = BaseFeature->begin();
         iter != BaseFeature->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<BaseFeature");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</BaseFeature>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool ToroidalSegmentBestFitType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in ToroidalSegmentBestFitType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in ToroidalSegmentBestFitType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ToroidalSegmentBestFitType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in ToroidalSegmentBestFitType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * ToroidalSegmentBestFitType::getn()
{return n;}

void ToroidalSegmentBestFitType::setn(NaturalType * nIn)
{n = nIn;}

SequencedBaseFeatureTypeLisd * ToroidalSegmentBestFitType::getBaseFeature()
{return BaseFeature;}

void ToroidalSegmentBestFitType::setBaseFeature(SequencedBaseFeatureTypeLisd * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class ToroidalSegmentCastType

*/

ToroidalSegmentCastType::ToroidalSegmentCastType() :
  ConstructionMethodBaseType()
{
  BaseFeature = 0;
}

ToroidalSegmentCastType::ToroidalSegmentCastType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeature = BaseFeatureIn;
}

ToroidalSegmentCastType::~ToroidalSegmentCastType()
{
  #ifndef NODESTRUCT
  delete BaseFeature;
  #endif
}

void ToroidalSegmentCastType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeature");
  BaseFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * ToroidalSegmentCastType::getBaseFeature()
{return BaseFeature;}

void ToroidalSegmentCastType::setBaseFeature(BaseFeatureType * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class ToroidalSegmentCheckedFeatureType

*/

ToroidalSegmentCheckedFeatureType::ToroidalSegmentCheckedFeatureType()
{
  CheckDetails = 0;
}

ToroidalSegmentCheckedFeatureType::ToroidalSegmentCheckedFeatureType(
 ToroidalSegmentCheckedType * CheckDetailsIn)
{
  CheckDetails = CheckDetailsIn;
}

ToroidalSegmentCheckedFeatureType::~ToroidalSegmentCheckedFeatureType()
{
  #ifndef NODESTRUCT
  delete CheckDetails;
  #endif
}

void ToroidalSegmentCheckedFeatureType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (CheckDetails)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CheckDetails");
      CheckDetails->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CheckDetails>\n");
    }
  doSpaces(-INDENT, outFile);
}

ToroidalSegmentCheckedType * ToroidalSegmentCheckedFeatureType::getCheckDetails()
{return CheckDetails;}

void ToroidalSegmentCheckedFeatureType::setCheckDetails(ToroidalSegmentCheckedType * CheckDetailsIn)
{CheckDetails = CheckDetailsIn;}

/* ***************************************************************** */

/* class ToroidalSegmentCheckedType

*/

ToroidalSegmentCheckedType::ToroidalSegmentCheckedType()
{
  ToroidalSegmentCheckedTypePair = 0;
}

ToroidalSegmentCheckedType::ToroidalSegmentCheckedType(
 ToroidalSegmentCheckedTypeChoicePair * ToroidalSegmentCheckedTypePairIn)
{
  ToroidalSegmentCheckedTypePair = ToroidalSegmentCheckedTypePairIn;
}

ToroidalSegmentCheckedType::~ToroidalSegmentCheckedType()
{
  #ifndef NODESTRUCT
  delete ToroidalSegmentCheckedTypePair;
  #endif
}

void ToroidalSegmentCheckedType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  ToroidalSegmentCheckedTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

ToroidalSegmentCheckedTypeChoicePair * ToroidalSegmentCheckedType::getToroidalSegmentCheckedTypePair()
{return ToroidalSegmentCheckedTypePair;}

void ToroidalSegmentCheckedType::setToroidalSegmentCheckedTypePair(ToroidalSegmentCheckedTypeChoicePair * ToroidalSegmentCheckedTypePairIn)
{ToroidalSegmentCheckedTypePair = ToroidalSegmentCheckedTypePairIn;}
ToroidalSegmentCheckedTypeChoicePair::ToroidalSegmentCheckedTypeChoicePair() {}

ToroidalSegmentCheckedTypeChoicePair::ToroidalSegmentCheckedTypeChoicePair(
 whichOne ToroidalSegmentCheckedTypeTypeIn,
 ToroidalSegmentCheckedTypeVal * ToroidalSegmentCheckedTypeValueIn)
{
  ToroidalSegmentCheckedTypeType = ToroidalSegmentCheckedTypeTypeIn;
  ToroidalSegmentCheckedTypeValue = ToroidalSegmentCheckedTypeValueIn;
}

ToroidalSegmentCheckedTypeChoicePair::~ToroidalSegmentCheckedTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (ToroidalSegmentCheckedTypeType == MeasuredE)
    delete ToroidalSegmentCheckedTypeValue->Measured;
  else if (ToroidalSegmentCheckedTypeType == ConstructedE)
    delete ToroidalSegmentCheckedTypeValue->Constructed;
  delete ToroidalSegmentCheckedTypeValue;
  #endif
}

void ToroidalSegmentCheckedTypeChoicePair::printSelf(FILE * outFile)
{
  if (ToroidalSegmentCheckedTypeType == MeasuredE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Measured");
      ToroidalSegmentCheckedTypeValue->Measured->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Measured>\n");
    }
  else if (ToroidalSegmentCheckedTypeType == ConstructedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      ToroidalSegmentCheckedTypeValue->Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
}

/* ***************************************************************** */

/* class ToroidalSegmentConstructionMethodType

*/

ToroidalSegmentConstructionMethodType::ToroidalSegmentConstructionMethodType()
{
  ToroidalSegmentConstructionMethodTypePair = 0;
}

ToroidalSegmentConstructionMethodType::ToroidalSegmentConstructionMethodType(
 ToroidalSegmentConstructionMethodTypeChoicePair * ToroidalSegmentConstructionMethodTypePairIn)
{
  ToroidalSegmentConstructionMethodTypePair = ToroidalSegmentConstructionMethodTypePairIn;
}

ToroidalSegmentConstructionMethodType::~ToroidalSegmentConstructionMethodType()
{
  #ifndef NODESTRUCT
  delete ToroidalSegmentConstructionMethodTypePair;
  #endif
}

void ToroidalSegmentConstructionMethodType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (ToroidalSegmentConstructionMethodTypePair)
    {
      ToroidalSegmentConstructionMethodTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

ToroidalSegmentConstructionMethodTypeChoicePair * ToroidalSegmentConstructionMethodType::getToroidalSegmentConstructionMethodTypePair()
{return ToroidalSegmentConstructionMethodTypePair;}

void ToroidalSegmentConstructionMethodType::setToroidalSegmentConstructionMethodTypePair(ToroidalSegmentConstructionMethodTypeChoicePair * ToroidalSegmentConstructionMethodTypePairIn)
{ToroidalSegmentConstructionMethodTypePair = ToroidalSegmentConstructionMethodTypePairIn;}
ToroidalSegmentConstructionMethodTypeChoicePair::ToroidalSegmentConstructionMethodTypeChoicePair() {}

ToroidalSegmentConstructionMethodTypeChoicePair::ToroidalSegmentConstructionMethodTypeChoicePair(
 whichOne ToroidalSegmentConstructionMethodTypeTypeIn,
 ToroidalSegmentConstructionMethodTypeVal * ToroidalSegmentConstructionMethodTypeValueIn)
{
  ToroidalSegmentConstructionMethodTypeType = ToroidalSegmentConstructionMethodTypeTypeIn;
  ToroidalSegmentConstructionMethodTypeValue = ToroidalSegmentConstructionMethodTypeValueIn;
}

ToroidalSegmentConstructionMethodTypeChoicePair::~ToroidalSegmentConstructionMethodTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (ToroidalSegmentConstructionMethodTypeType == BestFitE)
    delete ToroidalSegmentConstructionMethodTypeValue->BestFit;
  else if (ToroidalSegmentConstructionMethodTypeType == RecompensatedE)
    delete ToroidalSegmentConstructionMethodTypeValue->Recompensated;
  else if (ToroidalSegmentConstructionMethodTypeType == CopyE)
    delete ToroidalSegmentConstructionMethodTypeValue->Copy;
  else if (ToroidalSegmentConstructionMethodTypeType == CastE)
    delete ToroidalSegmentConstructionMethodTypeValue->Cast;
  else if (ToroidalSegmentConstructionMethodTypeType == TransformE)
    delete ToroidalSegmentConstructionMethodTypeValue->Transform;
  delete ToroidalSegmentConstructionMethodTypeValue;
  #endif
}

void ToroidalSegmentConstructionMethodTypeChoicePair::printSelf(FILE * outFile)
{
  if (ToroidalSegmentConstructionMethodTypeType == BestFitE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BestFit");
      ToroidalSegmentConstructionMethodTypeValue->BestFit->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BestFit>\n");
    }
  else if (ToroidalSegmentConstructionMethodTypeType == RecompensatedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Recompensated");
      ToroidalSegmentConstructionMethodTypeValue->Recompensated->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Recompensated>\n");
    }
  else if (ToroidalSegmentConstructionMethodTypeType == CopyE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Copy");
      ToroidalSegmentConstructionMethodTypeValue->Copy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Copy>\n");
    }
  else if (ToroidalSegmentConstructionMethodTypeType == CastE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Cast");
      ToroidalSegmentConstructionMethodTypeValue->Cast->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Cast>\n");
    }
  else if (ToroidalSegmentConstructionMethodTypeType == TransformE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Transform");
      ToroidalSegmentConstructionMethodTypeValue->Transform->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Transform>\n");
    }
}

/* ***************************************************************** */

/* class ToroidalSegmentCopyType

*/

ToroidalSegmentCopyType::ToroidalSegmentCopyType() :
  ConstructionMethodBaseType()
{
  BaseToroidalSegment = 0;
}

ToroidalSegmentCopyType::ToroidalSegmentCopyType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseToroidalSegmentIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseToroidalSegment = BaseToroidalSegmentIn;
}

ToroidalSegmentCopyType::~ToroidalSegmentCopyType()
{
  #ifndef NODESTRUCT
  delete BaseToroidalSegment;
  #endif
}

void ToroidalSegmentCopyType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseToroidalSegment");
  BaseToroidalSegment->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseToroidalSegment>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * ToroidalSegmentCopyType::getBaseToroidalSegment()
{return BaseToroidalSegment;}

void ToroidalSegmentCopyType::setBaseToroidalSegment(BaseFeatureType * BaseToroidalSegmentIn)
{BaseToroidalSegment = BaseToroidalSegmentIn;}

/* ***************************************************************** */

/* class ToroidalSegmentFeatureDefinitionType

*/

ToroidalSegmentFeatureDefinitionType::ToroidalSegmentFeatureDefinitionType() :
  SurfaceFeatureDefinitionBaseType()
{
  InternalExternal = 0;
  MinorDiameter = 0;
  MajorDiameter = 0;
}

ToroidalSegmentFeatureDefinitionType::ToroidalSegmentFeatureDefinitionType(
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * MinorDiameterIn,
 LinearValueType * MajorDiameterIn) :
  SurfaceFeatureDefinitionBaseType(
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  MinorDiameter = MinorDiameterIn;
  MajorDiameter = MajorDiameterIn;
}

ToroidalSegmentFeatureDefinitionType::ToroidalSegmentFeatureDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * MinorDiameterIn,
 LinearValueType * MajorDiameterIn) :
  SurfaceFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  MinorDiameter = MinorDiameterIn;
  MajorDiameter = MajorDiameterIn;
}

ToroidalSegmentFeatureDefinitionType::~ToroidalSegmentFeatureDefinitionType()
{
  #ifndef NODESTRUCT
  delete InternalExternal;
  delete MinorDiameter;
  delete MajorDiameter;
  #endif
}

void ToroidalSegmentFeatureDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<InternalExternal");
  InternalExternal->printSelf(outFile);
  fprintf(outFile, "</InternalExternal>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MinorDiameter");
  MinorDiameter->printSelf(outFile);
  fprintf(outFile, "</MinorDiameter>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MajorDiameter");
  MajorDiameter->printSelf(outFile);
  fprintf(outFile, "</MajorDiameter>\n");
  doSpaces(-INDENT, outFile);
}

bool ToroidalSegmentFeatureDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ToroidalSegmentFeatureDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ToroidalSegmentFeatureDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ToroidalSegmentFeatureDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ToroidalSegmentFeatureDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

InternalExternalEnumType * ToroidalSegmentFeatureDefinitionType::getInternalExternal()
{return InternalExternal;}

void ToroidalSegmentFeatureDefinitionType::setInternalExternal(InternalExternalEnumType * InternalExternalIn)
{InternalExternal = InternalExternalIn;}

LinearValueType * ToroidalSegmentFeatureDefinitionType::getMinorDiameter()
{return MinorDiameter;}

void ToroidalSegmentFeatureDefinitionType::setMinorDiameter(LinearValueType * MinorDiameterIn)
{MinorDiameter = MinorDiameterIn;}

LinearValueType * ToroidalSegmentFeatureDefinitionType::getMajorDiameter()
{return MajorDiameter;}

void ToroidalSegmentFeatureDefinitionType::setMajorDiameter(LinearValueType * MajorDiameterIn)
{MajorDiameter = MajorDiameterIn;}

/* ***************************************************************** */

/* class ToroidalSegmentFeatureItemType

*/

ToroidalSegmentFeatureItemType::ToroidalSegmentFeatureItemType() :
  SurfaceFeatureItemBaseType()
{
  DeterminationMode = 0;
}

ToroidalSegmentFeatureItemType::ToroidalSegmentFeatureItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 ToroidalSegmentMeasurementDeterminationType * DeterminationModeIn) :
  SurfaceFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

ToroidalSegmentFeatureItemType::ToroidalSegmentFeatureItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 ToroidalSegmentMeasurementDeterminationType * DeterminationModeIn) :
  SurfaceFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

ToroidalSegmentFeatureItemType::~ToroidalSegmentFeatureItemType()
{
  #ifndef NODESTRUCT
  delete DeterminationMode;
  #endif
}

void ToroidalSegmentFeatureItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<DeterminationMode");
  DeterminationMode->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeterminationMode>\n");
  doSpaces(-INDENT, outFile);
}

bool ToroidalSegmentFeatureItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ToroidalSegmentFeatureItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ToroidalSegmentFeatureItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ToroidalSegmentFeatureItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ToroidalSegmentFeatureItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

ToroidalSegmentMeasurementDeterminationType * ToroidalSegmentFeatureItemType::getDeterminationMode()
{return DeterminationMode;}

void ToroidalSegmentFeatureItemType::setDeterminationMode(ToroidalSegmentMeasurementDeterminationType * DeterminationModeIn)
{DeterminationMode = DeterminationModeIn;}

/* ***************************************************************** */

/* class ToroidalSegmentFeatureMeasurementType

*/

ToroidalSegmentFeatureMeasurementType::ToroidalSegmentFeatureMeasurementType() :
  SurfaceFeatureMeasurementBaseType()
{
  Location = 0;
  AxisVector = 0;
  MinorDiameter = 0;
  MajorDiameter = 0;
  LatitudeLongitudeSweepMeasurementRange = 0;
  LatitudeLongitudeSweepFull = 0;
  Form = 0;
}

ToroidalSegmentFeatureMeasurementType::ToroidalSegmentFeatureMeasurementType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredPointType * LocationIn,
 MeasuredUnitVectorType * AxisVectorIn,
 MeasuredLinearValueType * MinorDiameterIn,
 MeasuredLinearValueType * MajorDiameterIn,
 OrientedLatitudeLongitudeSweepType * LatitudeLongitudeSweepMeasurementRangeIn,
 OrientedLatitudeLongitudeSweepType * LatitudeLongitudeSweepFullIn,
 MeasuredLinearValueType * FormIn) :
  SurfaceFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Location = LocationIn;
  AxisVector = AxisVectorIn;
  MinorDiameter = MinorDiameterIn;
  MajorDiameter = MajorDiameterIn;
  LatitudeLongitudeSweepMeasurementRange = LatitudeLongitudeSweepMeasurementRangeIn;
  LatitudeLongitudeSweepFull = LatitudeLongitudeSweepFullIn;
  Form = FormIn;
}

ToroidalSegmentFeatureMeasurementType::ToroidalSegmentFeatureMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredPointType * LocationIn,
 MeasuredUnitVectorType * AxisVectorIn,
 MeasuredLinearValueType * MinorDiameterIn,
 MeasuredLinearValueType * MajorDiameterIn,
 OrientedLatitudeLongitudeSweepType * LatitudeLongitudeSweepMeasurementRangeIn,
 OrientedLatitudeLongitudeSweepType * LatitudeLongitudeSweepFullIn,
 MeasuredLinearValueType * FormIn) :
  SurfaceFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Location = LocationIn;
  AxisVector = AxisVectorIn;
  MinorDiameter = MinorDiameterIn;
  MajorDiameter = MajorDiameterIn;
  LatitudeLongitudeSweepMeasurementRange = LatitudeLongitudeSweepMeasurementRangeIn;
  LatitudeLongitudeSweepFull = LatitudeLongitudeSweepFullIn;
  Form = FormIn;
}

ToroidalSegmentFeatureMeasurementType::~ToroidalSegmentFeatureMeasurementType()
{
  #ifndef NODESTRUCT
  delete Location;
  delete AxisVector;
  delete MinorDiameter;
  delete MajorDiameter;
  delete LatitudeLongitudeSweepMeasurementRange;
  delete LatitudeLongitudeSweepFull;
  delete Form;
  #endif
}

void ToroidalSegmentFeatureMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  if (Location)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Location");
      Location->printSelf(outFile);
      fprintf(outFile, "</Location>\n");
    }
  if (AxisVector)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AxisVector");
      AxisVector->printSelf(outFile);
      fprintf(outFile, "</AxisVector>\n");
    }
  if (MinorDiameter)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinorDiameter");
      MinorDiameter->printSelf(outFile);
      fprintf(outFile, "</MinorDiameter>\n");
    }
  if (MajorDiameter)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MajorDiameter");
      MajorDiameter->printSelf(outFile);
      fprintf(outFile, "</MajorDiameter>\n");
    }
  if (LatitudeLongitudeSweepMeasurementRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LatitudeLongitudeSweepMeasurementRange");
      LatitudeLongitudeSweepMeasurementRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LatitudeLongitudeSweepMeasurementRange>\n");
    }
  if (LatitudeLongitudeSweepFull)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LatitudeLongitudeSweepFull");
      LatitudeLongitudeSweepFull->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LatitudeLongitudeSweepFull>\n");
    }
  if (Form)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Form");
      Form->printSelf(outFile);
      fprintf(outFile, "</Form>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ToroidalSegmentFeatureMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ToroidalSegmentFeatureMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ToroidalSegmentFeatureMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ToroidalSegmentFeatureMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ToroidalSegmentFeatureMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredPointType * ToroidalSegmentFeatureMeasurementType::getLocation()
{return Location;}

void ToroidalSegmentFeatureMeasurementType::setLocation(MeasuredPointType * LocationIn)
{Location = LocationIn;}

MeasuredUnitVectorType * ToroidalSegmentFeatureMeasurementType::getAxisVector()
{return AxisVector;}

void ToroidalSegmentFeatureMeasurementType::setAxisVector(MeasuredUnitVectorType * AxisVectorIn)
{AxisVector = AxisVectorIn;}

MeasuredLinearValueType * ToroidalSegmentFeatureMeasurementType::getMinorDiameter()
{return MinorDiameter;}

void ToroidalSegmentFeatureMeasurementType::setMinorDiameter(MeasuredLinearValueType * MinorDiameterIn)
{MinorDiameter = MinorDiameterIn;}

MeasuredLinearValueType * ToroidalSegmentFeatureMeasurementType::getMajorDiameter()
{return MajorDiameter;}

void ToroidalSegmentFeatureMeasurementType::setMajorDiameter(MeasuredLinearValueType * MajorDiameterIn)
{MajorDiameter = MajorDiameterIn;}

OrientedLatitudeLongitudeSweepType * ToroidalSegmentFeatureMeasurementType::getLatitudeLongitudeSweepMeasurementRange()
{return LatitudeLongitudeSweepMeasurementRange;}

void ToroidalSegmentFeatureMeasurementType::setLatitudeLongitudeSweepMeasurementRange(OrientedLatitudeLongitudeSweepType * LatitudeLongitudeSweepMeasurementRangeIn)
{LatitudeLongitudeSweepMeasurementRange = LatitudeLongitudeSweepMeasurementRangeIn;}

OrientedLatitudeLongitudeSweepType * ToroidalSegmentFeatureMeasurementType::getLatitudeLongitudeSweepFull()
{return LatitudeLongitudeSweepFull;}

void ToroidalSegmentFeatureMeasurementType::setLatitudeLongitudeSweepFull(OrientedLatitudeLongitudeSweepType * LatitudeLongitudeSweepFullIn)
{LatitudeLongitudeSweepFull = LatitudeLongitudeSweepFullIn;}

MeasuredLinearValueType * ToroidalSegmentFeatureMeasurementType::getForm()
{return Form;}

void ToroidalSegmentFeatureMeasurementType::setForm(MeasuredLinearValueType * FormIn)
{Form = FormIn;}

/* ***************************************************************** */

/* class ToroidalSegmentFeatureNominalType

*/

ToroidalSegmentFeatureNominalType::ToroidalSegmentFeatureNominalType() :
  SurfaceFeatureNominalBaseType()
{
  Location = 0;
  AxisVector = 0;
  LatitudeLongitudeSweep = 0;
  Constructed = 0;
}

ToroidalSegmentFeatureNominalType::ToroidalSegmentFeatureNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 PointType * LocationIn,
 UnitVectorType * AxisVectorIn,
 LatitudeLongitudeSweepType * LatitudeLongitudeSweepIn,
 ToroidalSegmentConstructionMethodType * ConstructedIn) :
  SurfaceFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  Location = LocationIn;
  AxisVector = AxisVectorIn;
  LatitudeLongitudeSweep = LatitudeLongitudeSweepIn;
  Constructed = ConstructedIn;
}

ToroidalSegmentFeatureNominalType::ToroidalSegmentFeatureNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 PointType * LocationIn,
 UnitVectorType * AxisVectorIn,
 LatitudeLongitudeSweepType * LatitudeLongitudeSweepIn,
 ToroidalSegmentConstructionMethodType * ConstructedIn) :
  SurfaceFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  Location = LocationIn;
  AxisVector = AxisVectorIn;
  LatitudeLongitudeSweep = LatitudeLongitudeSweepIn;
  Constructed = ConstructedIn;
}

ToroidalSegmentFeatureNominalType::~ToroidalSegmentFeatureNominalType()
{
  #ifndef NODESTRUCT
  delete Location;
  delete AxisVector;
  delete LatitudeLongitudeSweep;
  delete Constructed;
  #endif
}

void ToroidalSegmentFeatureNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Location");
  Location->printSelf(outFile);
  fprintf(outFile, "</Location>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<AxisVector");
  AxisVector->printSelf(outFile);
  fprintf(outFile, "</AxisVector>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<LatitudeLongitudeSweep");
  LatitudeLongitudeSweep->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</LatitudeLongitudeSweep>\n");
  if (Constructed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ToroidalSegmentFeatureNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ToroidalSegmentFeatureNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ToroidalSegmentFeatureNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ToroidalSegmentFeatureNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ToroidalSegmentFeatureNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

PointType * ToroidalSegmentFeatureNominalType::getLocation()
{return Location;}

void ToroidalSegmentFeatureNominalType::setLocation(PointType * LocationIn)
{Location = LocationIn;}

UnitVectorType * ToroidalSegmentFeatureNominalType::getAxisVector()
{return AxisVector;}

void ToroidalSegmentFeatureNominalType::setAxisVector(UnitVectorType * AxisVectorIn)
{AxisVector = AxisVectorIn;}

LatitudeLongitudeSweepType * ToroidalSegmentFeatureNominalType::getLatitudeLongitudeSweep()
{return LatitudeLongitudeSweep;}

void ToroidalSegmentFeatureNominalType::setLatitudeLongitudeSweep(LatitudeLongitudeSweepType * LatitudeLongitudeSweepIn)
{LatitudeLongitudeSweep = LatitudeLongitudeSweepIn;}

ToroidalSegmentConstructionMethodType * ToroidalSegmentFeatureNominalType::getConstructed()
{return Constructed;}

void ToroidalSegmentFeatureNominalType::setConstructed(ToroidalSegmentConstructionMethodType * ConstructedIn)
{Constructed = ConstructedIn;}

/* ***************************************************************** */

/* class ToroidalSegmentMeasurementDeterminationType

*/

ToroidalSegmentMeasurementDeterminationType::ToroidalSegmentMeasurementDeterminationType()
{
  ToroidalSegmentMeasurementDeterminationTypePair = 0;
}

ToroidalSegmentMeasurementDeterminationType::ToroidalSegmentMeasurementDeterminationType(
 ToroidalSegmentMeasurementDeterminationTypeChoicePair * ToroidalSegmentMeasurementDeterminationTypePairIn)
{
  ToroidalSegmentMeasurementDeterminationTypePair = ToroidalSegmentMeasurementDeterminationTypePairIn;
}

ToroidalSegmentMeasurementDeterminationType::~ToroidalSegmentMeasurementDeterminationType()
{
  #ifndef NODESTRUCT
  delete ToroidalSegmentMeasurementDeterminationTypePair;
  #endif
}

void ToroidalSegmentMeasurementDeterminationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  ToroidalSegmentMeasurementDeterminationTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

ToroidalSegmentMeasurementDeterminationTypeChoicePair * ToroidalSegmentMeasurementDeterminationType::getToroidalSegmentMeasurementDeterminationTypePair()
{return ToroidalSegmentMeasurementDeterminationTypePair;}

void ToroidalSegmentMeasurementDeterminationType::setToroidalSegmentMeasurementDeterminationTypePair(ToroidalSegmentMeasurementDeterminationTypeChoicePair * ToroidalSegmentMeasurementDeterminationTypePairIn)
{ToroidalSegmentMeasurementDeterminationTypePair = ToroidalSegmentMeasurementDeterminationTypePairIn;}
ToroidalSegmentMeasurementDeterminationTypeChoicePair::ToroidalSegmentMeasurementDeterminationTypeChoicePair() {}

ToroidalSegmentMeasurementDeterminationTypeChoicePair::ToroidalSegmentMeasurementDeterminationTypeChoicePair(
 whichOne ToroidalSegmentMeasurementDeterminationTypeTypeIn,
 ToroidalSegmentMeasurementDeterminationTypeVal * ToroidalSegmentMeasurementDeterminationTypeValueIn)
{
  ToroidalSegmentMeasurementDeterminationTypeType = ToroidalSegmentMeasurementDeterminationTypeTypeIn;
  ToroidalSegmentMeasurementDeterminationTypeValue = ToroidalSegmentMeasurementDeterminationTypeValueIn;
}

ToroidalSegmentMeasurementDeterminationTypeChoicePair::~ToroidalSegmentMeasurementDeterminationTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (ToroidalSegmentMeasurementDeterminationTypeType == CheckedE)
    delete ToroidalSegmentMeasurementDeterminationTypeValue->Checked;
  else if (ToroidalSegmentMeasurementDeterminationTypeType == SetE)
    delete ToroidalSegmentMeasurementDeterminationTypeValue->Set;
  delete ToroidalSegmentMeasurementDeterminationTypeValue;
  #endif
}

void ToroidalSegmentMeasurementDeterminationTypeChoicePair::printSelf(FILE * outFile)
{
  if (ToroidalSegmentMeasurementDeterminationTypeType == CheckedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Checked");
      ToroidalSegmentMeasurementDeterminationTypeValue->Checked->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Checked>\n");
    }
  else if (ToroidalSegmentMeasurementDeterminationTypeType == SetE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Set");
      ToroidalSegmentMeasurementDeterminationTypeValue->Set->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class ToroidalSegmentRecompType

*/

ToroidalSegmentRecompType::ToroidalSegmentRecompType() :
  ConstructionMethodBaseType()
{
  BaseFeaturePointList = 0;
}

ToroidalSegmentRecompType::ToroidalSegmentRecompType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeaturePointListType * BaseFeaturePointListIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeaturePointList = BaseFeaturePointListIn;
}

ToroidalSegmentRecompType::~ToroidalSegmentRecompType()
{
  #ifndef NODESTRUCT
  delete BaseFeaturePointList;
  #endif
}

void ToroidalSegmentRecompType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeaturePointList");
  BaseFeaturePointList->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeaturePointList>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeaturePointListType * ToroidalSegmentRecompType::getBaseFeaturePointList()
{return BaseFeaturePointList;}

void ToroidalSegmentRecompType::setBaseFeaturePointList(BaseFeaturePointListType * BaseFeaturePointListIn)
{BaseFeaturePointList = BaseFeaturePointListIn;}

/* ***************************************************************** */

/* class ToroidalSegmentTransformType

*/

ToroidalSegmentTransformType::ToroidalSegmentTransformType() :
  ConstructionMethodBaseType()
{
  BaseToroidalSegment = 0;
  Transformation = 0;
}

ToroidalSegmentTransformType::ToroidalSegmentTransformType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseToroidalSegmentIn,
 TransformationReferenceType * TransformationIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseToroidalSegment = BaseToroidalSegmentIn;
  Transformation = TransformationIn;
}

ToroidalSegmentTransformType::~ToroidalSegmentTransformType()
{
  #ifndef NODESTRUCT
  delete BaseToroidalSegment;
  delete Transformation;
  #endif
}

void ToroidalSegmentTransformType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseToroidalSegment");
  BaseToroidalSegment->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseToroidalSegment>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Transformation");
  Transformation->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Transformation>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * ToroidalSegmentTransformType::getBaseToroidalSegment()
{return BaseToroidalSegment;}

void ToroidalSegmentTransformType::setBaseToroidalSegment(BaseFeatureType * BaseToroidalSegmentIn)
{BaseToroidalSegment = BaseToroidalSegmentIn;}

TransformationReferenceType * ToroidalSegmentTransformType::getTransformation()
{return Transformation;}

void ToroidalSegmentTransformType::setTransformation(TransformationReferenceType * TransformationIn)
{Transformation = TransformationIn;}

/* ***************************************************************** */

/* class TorusBestFitType

*/

TorusBestFitType::TorusBestFitType() :
  ConstructionMethodBaseType()
{
  n = 0;
  BaseFeature = 0;
}

TorusBestFitType::TorusBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = 0;
  BaseFeature = BaseFeatureIn;
}

TorusBestFitType::TorusBestFitType(
 XmlBoolean * NominalsCalculatedIn,
 NaturalType * nIn,
 SequencedBaseFeatureTypeLisd * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  n = nIn;
  BaseFeature = BaseFeatureIn;
}

TorusBestFitType::~TorusBestFitType()
{
  #ifndef NODESTRUCT
  delete n;
  delete BaseFeature;
  #endif
}

void TorusBestFitType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  {
    if (!BaseFeature)
      {
        fprintf(stderr, "BaseFeature list is missing\n");
        exit(1);
      }
    if (BaseFeature->size() == 0)
      {
        fprintf(stderr, "BaseFeature list is empty\n");
        exit(1);
      }
    if (BaseFeature->size() < 9)
      {
        fprintf(stderr,
                "size of BaseFeature list (%d) less than minimum required (9)\n",
                (int)BaseFeature->size());
        exit(1);
      }
    std::list<SequencedBaseFeatureType *>::iterator iter;
    for (iter = BaseFeature->begin();
         iter != BaseFeature->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<BaseFeature");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</BaseFeature>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool TorusBestFitType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in TorusBestFitType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in TorusBestFitType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in TorusBestFitType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in TorusBestFitType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * TorusBestFitType::getn()
{return n;}

void TorusBestFitType::setn(NaturalType * nIn)
{n = nIn;}

SequencedBaseFeatureTypeLisd * TorusBestFitType::getBaseFeature()
{return BaseFeature;}

void TorusBestFitType::setBaseFeature(SequencedBaseFeatureTypeLisd * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class TorusCastType

*/

TorusCastType::TorusCastType() :
  ConstructionMethodBaseType()
{
  BaseFeature = 0;
}

TorusCastType::TorusCastType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseFeatureIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeature = BaseFeatureIn;
}

TorusCastType::~TorusCastType()
{
  #ifndef NODESTRUCT
  delete BaseFeature;
  #endif
}

void TorusCastType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeature");
  BaseFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeature>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * TorusCastType::getBaseFeature()
{return BaseFeature;}

void TorusCastType::setBaseFeature(BaseFeatureType * BaseFeatureIn)
{BaseFeature = BaseFeatureIn;}

/* ***************************************************************** */

/* class TorusCheckedFeatureType

*/

TorusCheckedFeatureType::TorusCheckedFeatureType()
{
  CheckDetails = 0;
}

TorusCheckedFeatureType::TorusCheckedFeatureType(
 TorusCheckedType * CheckDetailsIn)
{
  CheckDetails = CheckDetailsIn;
}

TorusCheckedFeatureType::~TorusCheckedFeatureType()
{
  #ifndef NODESTRUCT
  delete CheckDetails;
  #endif
}

void TorusCheckedFeatureType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (CheckDetails)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CheckDetails");
      CheckDetails->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CheckDetails>\n");
    }
  doSpaces(-INDENT, outFile);
}

TorusCheckedType * TorusCheckedFeatureType::getCheckDetails()
{return CheckDetails;}

void TorusCheckedFeatureType::setCheckDetails(TorusCheckedType * CheckDetailsIn)
{CheckDetails = CheckDetailsIn;}

/* ***************************************************************** */

/* class TorusCheckedType

*/

TorusCheckedType::TorusCheckedType()
{
  TorusCheckedTypePair = 0;
}

TorusCheckedType::TorusCheckedType(
 TorusCheckedTypeChoicePair * TorusCheckedTypePairIn)
{
  TorusCheckedTypePair = TorusCheckedTypePairIn;
}

TorusCheckedType::~TorusCheckedType()
{
  #ifndef NODESTRUCT
  delete TorusCheckedTypePair;
  #endif
}

void TorusCheckedType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  TorusCheckedTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

TorusCheckedTypeChoicePair * TorusCheckedType::getTorusCheckedTypePair()
{return TorusCheckedTypePair;}

void TorusCheckedType::setTorusCheckedTypePair(TorusCheckedTypeChoicePair * TorusCheckedTypePairIn)
{TorusCheckedTypePair = TorusCheckedTypePairIn;}
TorusCheckedTypeChoicePair::TorusCheckedTypeChoicePair() {}

TorusCheckedTypeChoicePair::TorusCheckedTypeChoicePair(
 whichOne TorusCheckedTypeTypeIn,
 TorusCheckedTypeVal * TorusCheckedTypeValueIn)
{
  TorusCheckedTypeType = TorusCheckedTypeTypeIn;
  TorusCheckedTypeValue = TorusCheckedTypeValueIn;
}

TorusCheckedTypeChoicePair::~TorusCheckedTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (TorusCheckedTypeType == MeasuredE)
    delete TorusCheckedTypeValue->Measured;
  else if (TorusCheckedTypeType == ConstructedE)
    delete TorusCheckedTypeValue->Constructed;
  delete TorusCheckedTypeValue;
  #endif
}

void TorusCheckedTypeChoicePair::printSelf(FILE * outFile)
{
  if (TorusCheckedTypeType == MeasuredE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Measured");
      TorusCheckedTypeValue->Measured->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Measured>\n");
    }
  else if (TorusCheckedTypeType == ConstructedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      TorusCheckedTypeValue->Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
}

/* ***************************************************************** */

/* class TorusConstructionMethodType

*/

TorusConstructionMethodType::TorusConstructionMethodType()
{
  TorusConstructionMethodTypePair = 0;
}

TorusConstructionMethodType::TorusConstructionMethodType(
 TorusConstructionMethodTypeChoicePair * TorusConstructionMethodTypePairIn)
{
  TorusConstructionMethodTypePair = TorusConstructionMethodTypePairIn;
}

TorusConstructionMethodType::~TorusConstructionMethodType()
{
  #ifndef NODESTRUCT
  delete TorusConstructionMethodTypePair;
  #endif
}

void TorusConstructionMethodType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (TorusConstructionMethodTypePair)
    {
      TorusConstructionMethodTypePair->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

TorusConstructionMethodTypeChoicePair * TorusConstructionMethodType::getTorusConstructionMethodTypePair()
{return TorusConstructionMethodTypePair;}

void TorusConstructionMethodType::setTorusConstructionMethodTypePair(TorusConstructionMethodTypeChoicePair * TorusConstructionMethodTypePairIn)
{TorusConstructionMethodTypePair = TorusConstructionMethodTypePairIn;}
TorusConstructionMethodTypeChoicePair::TorusConstructionMethodTypeChoicePair() {}

TorusConstructionMethodTypeChoicePair::TorusConstructionMethodTypeChoicePair(
 whichOne TorusConstructionMethodTypeTypeIn,
 TorusConstructionMethodTypeVal * TorusConstructionMethodTypeValueIn)
{
  TorusConstructionMethodTypeType = TorusConstructionMethodTypeTypeIn;
  TorusConstructionMethodTypeValue = TorusConstructionMethodTypeValueIn;
}

TorusConstructionMethodTypeChoicePair::~TorusConstructionMethodTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (TorusConstructionMethodTypeType == BestFitE)
    delete TorusConstructionMethodTypeValue->BestFit;
  else if (TorusConstructionMethodTypeType == RecompensatedE)
    delete TorusConstructionMethodTypeValue->Recompensated;
  else if (TorusConstructionMethodTypeType == CopyE)
    delete TorusConstructionMethodTypeValue->Copy;
  else if (TorusConstructionMethodTypeType == CastE)
    delete TorusConstructionMethodTypeValue->Cast;
  else if (TorusConstructionMethodTypeType == TransformE)
    delete TorusConstructionMethodTypeValue->Transform;
  else if (TorusConstructionMethodTypeType == FromScanE)
    delete TorusConstructionMethodTypeValue->FromScan;
  delete TorusConstructionMethodTypeValue;
  #endif
}

void TorusConstructionMethodTypeChoicePair::printSelf(FILE * outFile)
{
  if (TorusConstructionMethodTypeType == BestFitE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BestFit");
      TorusConstructionMethodTypeValue->BestFit->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BestFit>\n");
    }
  else if (TorusConstructionMethodTypeType == RecompensatedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Recompensated");
      TorusConstructionMethodTypeValue->Recompensated->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Recompensated>\n");
    }
  else if (TorusConstructionMethodTypeType == CopyE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Copy");
      TorusConstructionMethodTypeValue->Copy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Copy>\n");
    }
  else if (TorusConstructionMethodTypeType == CastE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Cast");
      TorusConstructionMethodTypeValue->Cast->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Cast>\n");
    }
  else if (TorusConstructionMethodTypeType == TransformE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Transform");
      TorusConstructionMethodTypeValue->Transform->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Transform>\n");
    }
  else if (TorusConstructionMethodTypeType == FromScanE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FromScan");
      TorusConstructionMethodTypeValue->FromScan->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FromScan>\n");
    }
}

/* ***************************************************************** */

/* class TorusCopyType

*/

TorusCopyType::TorusCopyType() :
  ConstructionMethodBaseType()
{
  BaseTorus = 0;
}

TorusCopyType::TorusCopyType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseTorusIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseTorus = BaseTorusIn;
}

TorusCopyType::~TorusCopyType()
{
  #ifndef NODESTRUCT
  delete BaseTorus;
  #endif
}

void TorusCopyType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseTorus");
  BaseTorus->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseTorus>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * TorusCopyType::getBaseTorus()
{return BaseTorus;}

void TorusCopyType::setBaseTorus(BaseFeatureType * BaseTorusIn)
{BaseTorus = BaseTorusIn;}

/* ***************************************************************** */

/* class TorusFeatureDefinitionType

*/

TorusFeatureDefinitionType::TorusFeatureDefinitionType() :
  SurfaceFeatureDefinitionBaseType()
{
  InternalExternal = 0;
  MinorDiameter = 0;
  MajorDiameter = 0;
}

TorusFeatureDefinitionType::TorusFeatureDefinitionType(
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * MinorDiameterIn,
 LinearValueType * MajorDiameterIn) :
  SurfaceFeatureDefinitionBaseType(
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  MinorDiameter = MinorDiameterIn;
  MajorDiameter = MajorDiameterIn;
}

TorusFeatureDefinitionType::TorusFeatureDefinitionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 InternalExternalEnumType * InternalExternalIn,
 LinearValueType * MinorDiameterIn,
 LinearValueType * MajorDiameterIn) :
  SurfaceFeatureDefinitionBaseType(
    idIn,
    AttributesIn)
{
  InternalExternal = InternalExternalIn;
  MinorDiameter = MinorDiameterIn;
  MajorDiameter = MajorDiameterIn;
}

TorusFeatureDefinitionType::~TorusFeatureDefinitionType()
{
  #ifndef NODESTRUCT
  delete InternalExternal;
  delete MinorDiameter;
  delete MajorDiameter;
  #endif
}

void TorusFeatureDefinitionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<InternalExternal");
  InternalExternal->printSelf(outFile);
  fprintf(outFile, "</InternalExternal>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MinorDiameter");
  MinorDiameter->printSelf(outFile);
  fprintf(outFile, "</MinorDiameter>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MajorDiameter");
  MajorDiameter->printSelf(outFile);
  fprintf(outFile, "</MajorDiameter>\n");
  doSpaces(-INDENT, outFile);
}

bool TorusFeatureDefinitionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in TorusFeatureDefinitionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in TorusFeatureDefinitionType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in TorusFeatureDefinitionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in TorusFeatureDefinitionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

InternalExternalEnumType * TorusFeatureDefinitionType::getInternalExternal()
{return InternalExternal;}

void TorusFeatureDefinitionType::setInternalExternal(InternalExternalEnumType * InternalExternalIn)
{InternalExternal = InternalExternalIn;}

LinearValueType * TorusFeatureDefinitionType::getMinorDiameter()
{return MinorDiameter;}

void TorusFeatureDefinitionType::setMinorDiameter(LinearValueType * MinorDiameterIn)
{MinorDiameter = MinorDiameterIn;}

LinearValueType * TorusFeatureDefinitionType::getMajorDiameter()
{return MajorDiameter;}

void TorusFeatureDefinitionType::setMajorDiameter(LinearValueType * MajorDiameterIn)
{MajorDiameter = MajorDiameterIn;}

/* ***************************************************************** */

/* class TorusFeatureItemType

*/

TorusFeatureItemType::TorusFeatureItemType() :
  SurfaceFeatureItemBaseType()
{
  DeterminationMode = 0;
}

TorusFeatureItemType::TorusFeatureItemType(
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 TorusMeasurementDeterminationType * DeterminationModeIn) :
  SurfaceFeatureItemBaseType(
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

TorusFeatureItemType::TorusFeatureItemType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceFullType * FeatureNominalIdIn,
 QIFReferenceType * ParentFeatureItemIdIn,
 XmlToken * FeatureNameIn,
 QPIdType * UUIDIn,
 ArrayReferenceType * NotableEventIdsIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 VirtualMeasurementType * VirtualMeasurementIn,
 TorusMeasurementDeterminationType * DeterminationModeIn) :
  SurfaceFeatureItemBaseType(
    idIn,
    AttributesIn,
    FeatureNominalIdIn,
    ParentFeatureItemIdIn,
    FeatureNameIn,
    UUIDIn,
    NotableEventIdsIn,
    CoordinateSystemIdIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    VirtualMeasurementIn)
{
  DeterminationMode = DeterminationModeIn;
}

TorusFeatureItemType::~TorusFeatureItemType()
{
  #ifndef NODESTRUCT
  delete DeterminationMode;
  #endif
}

void TorusFeatureItemType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureNominalId");
  FeatureNominalId->printSelf(outFile);
  fprintf(outFile, "</FeatureNominalId>\n");
  if (ParentFeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureItemId");
      ParentFeatureItemId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureItemId>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureName");
  FeatureName->printSelf(outFile);
  fprintf(outFile, "</FeatureName>\n");
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  if (NotableEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotableEventIds");
      NotableEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotableEventIds>\n");
    }
  if (CoordinateSystemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (VirtualMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VirtualMeasurement");
      VirtualMeasurement->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<DeterminationMode");
  DeterminationMode->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeterminationMode>\n");
  doSpaces(-INDENT, outFile);
}

bool TorusFeatureItemType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in TorusFeatureItemType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in TorusFeatureItemType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in TorusFeatureItemType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in TorusFeatureItemType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

TorusMeasurementDeterminationType * TorusFeatureItemType::getDeterminationMode()
{return DeterminationMode;}

void TorusFeatureItemType::setDeterminationMode(TorusMeasurementDeterminationType * DeterminationModeIn)
{DeterminationMode = DeterminationModeIn;}

/* ***************************************************************** */

/* class TorusFeatureMeasurementType

*/

TorusFeatureMeasurementType::TorusFeatureMeasurementType() :
  SurfaceFeatureMeasurementBaseType()
{
  Location = 0;
  AxisVector = 0;
  MinorDiameter = 0;
  MajorDiameter = 0;
  LatitudeLongitudeSweepMeasurementRange = 0;
  LatitudeLongitudeSweepFull = 0;
  Form = 0;
}

TorusFeatureMeasurementType::TorusFeatureMeasurementType(
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredPointType * LocationIn,
 MeasuredUnitVectorType * AxisVectorIn,
 MeasuredLinearValueType * MinorDiameterIn,
 MeasuredLinearValueType * MajorDiameterIn,
 OrientedLatitudeLongitudeSweepType * LatitudeLongitudeSweepMeasurementRangeIn,
 OrientedLatitudeLongitudeSweepType * LatitudeLongitudeSweepFullIn,
 MeasuredLinearValueType * FormIn) :
  SurfaceFeatureMeasurementBaseType(
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Location = LocationIn;
  AxisVector = AxisVectorIn;
  MinorDiameter = MinorDiameterIn;
  MajorDiameter = MajorDiameterIn;
  LatitudeLongitudeSweepMeasurementRange = LatitudeLongitudeSweepMeasurementRangeIn;
  LatitudeLongitudeSweepFull = LatitudeLongitudeSweepFullIn;
  Form = FormIn;
}

TorusFeatureMeasurementType::TorusFeatureMeasurementType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 QIFReferenceType * FeatureItemIdIn,
 XmlToken * FeatureNameIn,
 XmlDateTime * TimeStampIn,
 QIFReferenceFullType * ActualComponentIdIn,
 QIFReferenceFullType * ManufacturingProcessIdIn,
 ArrayReferenceFullType * MeasurementDeviceIdsIn,
 QIFReferenceType * ActualTransformIdIn,
 ArrayReferenceFullType * NotedEventIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 QIFReferenceType * ProxyMeasurementIdIn,
 MeasuredPointType * LocationIn,
 MeasuredUnitVectorType * AxisVectorIn,
 MeasuredLinearValueType * MinorDiameterIn,
 MeasuredLinearValueType * MajorDiameterIn,
 OrientedLatitudeLongitudeSweepType * LatitudeLongitudeSweepMeasurementRangeIn,
 OrientedLatitudeLongitudeSweepType * LatitudeLongitudeSweepFullIn,
 MeasuredLinearValueType * FormIn) :
  SurfaceFeatureMeasurementBaseType(
    idIn,
    AttributesIn,
    FeatureItemIdIn,
    FeatureNameIn,
    TimeStampIn,
    ActualComponentIdIn,
    ManufacturingProcessIdIn,
    MeasurementDeviceIdsIn,
    ActualTransformIdIn,
    NotedEventIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn,
    ProxyMeasurementIdIn)
{
  Location = LocationIn;
  AxisVector = AxisVectorIn;
  MinorDiameter = MinorDiameterIn;
  MajorDiameter = MajorDiameterIn;
  LatitudeLongitudeSweepMeasurementRange = LatitudeLongitudeSweepMeasurementRangeIn;
  LatitudeLongitudeSweepFull = LatitudeLongitudeSweepFullIn;
  Form = FormIn;
}

TorusFeatureMeasurementType::~TorusFeatureMeasurementType()
{
  #ifndef NODESTRUCT
  delete Location;
  delete AxisVector;
  delete MinorDiameter;
  delete MajorDiameter;
  delete LatitudeLongitudeSweepMeasurementRange;
  delete LatitudeLongitudeSweepFull;
  delete Form;
  #endif
}

void TorusFeatureMeasurementType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (FeatureItemId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureItemId");
      FeatureItemId->printSelf(outFile);
      fprintf(outFile, "</FeatureItemId>\n");
    }
  if (FeatureName)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureName");
      FeatureName->printSelf(outFile);
      fprintf(outFile, "</FeatureName>\n");
    }
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  if (ActualComponentId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualComponentId");
      ActualComponentId->printSelf(outFile);
      fprintf(outFile, "</ActualComponentId>\n");
    }
  if (ManufacturingProcessId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ManufacturingProcessId");
      ManufacturingProcessId->printSelf(outFile);
      fprintf(outFile, "</ManufacturingProcessId>\n");
    }
  if (MeasurementDeviceIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDeviceIds");
      MeasurementDeviceIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDeviceIds>\n");
    }
  if (ActualTransformId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualTransformId");
      ActualTransformId->printSelf(outFile);
      fprintf(outFile, "</ActualTransformId>\n");
    }
  if (NotedEventIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NotedEventIds");
      NotedEventIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NotedEventIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  if (ProxyMeasurementId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProxyMeasurementId");
      ProxyMeasurementId->printSelf(outFile);
      fprintf(outFile, "</ProxyMeasurementId>\n");
    }
  if (Location)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Location");
      Location->printSelf(outFile);
      fprintf(outFile, "</Location>\n");
    }
  if (AxisVector)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AxisVector");
      AxisVector->printSelf(outFile);
      fprintf(outFile, "</AxisVector>\n");
    }
  if (MinorDiameter)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinorDiameter");
      MinorDiameter->printSelf(outFile);
      fprintf(outFile, "</MinorDiameter>\n");
    }
  if (MajorDiameter)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MajorDiameter");
      MajorDiameter->printSelf(outFile);
      fprintf(outFile, "</MajorDiameter>\n");
    }
  if (LatitudeLongitudeSweepMeasurementRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LatitudeLongitudeSweepMeasurementRange");
      LatitudeLongitudeSweepMeasurementRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LatitudeLongitudeSweepMeasurementRange>\n");
    }
  if (LatitudeLongitudeSweepFull)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LatitudeLongitudeSweepFull");
      LatitudeLongitudeSweepFull->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LatitudeLongitudeSweepFull>\n");
    }
  if (Form)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Form");
      Form->printSelf(outFile);
      fprintf(outFile, "</Form>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool TorusFeatureMeasurementType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in TorusFeatureMeasurementType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in TorusFeatureMeasurementType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in TorusFeatureMeasurementType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in TorusFeatureMeasurementType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MeasuredPointType * TorusFeatureMeasurementType::getLocation()
{return Location;}

void TorusFeatureMeasurementType::setLocation(MeasuredPointType * LocationIn)
{Location = LocationIn;}

MeasuredUnitVectorType * TorusFeatureMeasurementType::getAxisVector()
{return AxisVector;}

void TorusFeatureMeasurementType::setAxisVector(MeasuredUnitVectorType * AxisVectorIn)
{AxisVector = AxisVectorIn;}

MeasuredLinearValueType * TorusFeatureMeasurementType::getMinorDiameter()
{return MinorDiameter;}

void TorusFeatureMeasurementType::setMinorDiameter(MeasuredLinearValueType * MinorDiameterIn)
{MinorDiameter = MinorDiameterIn;}

MeasuredLinearValueType * TorusFeatureMeasurementType::getMajorDiameter()
{return MajorDiameter;}

void TorusFeatureMeasurementType::setMajorDiameter(MeasuredLinearValueType * MajorDiameterIn)
{MajorDiameter = MajorDiameterIn;}

OrientedLatitudeLongitudeSweepType * TorusFeatureMeasurementType::getLatitudeLongitudeSweepMeasurementRange()
{return LatitudeLongitudeSweepMeasurementRange;}

void TorusFeatureMeasurementType::setLatitudeLongitudeSweepMeasurementRange(OrientedLatitudeLongitudeSweepType * LatitudeLongitudeSweepMeasurementRangeIn)
{LatitudeLongitudeSweepMeasurementRange = LatitudeLongitudeSweepMeasurementRangeIn;}

OrientedLatitudeLongitudeSweepType * TorusFeatureMeasurementType::getLatitudeLongitudeSweepFull()
{return LatitudeLongitudeSweepFull;}

void TorusFeatureMeasurementType::setLatitudeLongitudeSweepFull(OrientedLatitudeLongitudeSweepType * LatitudeLongitudeSweepFullIn)
{LatitudeLongitudeSweepFull = LatitudeLongitudeSweepFullIn;}

MeasuredLinearValueType * TorusFeatureMeasurementType::getForm()
{return Form;}

void TorusFeatureMeasurementType::setForm(MeasuredLinearValueType * FormIn)
{Form = FormIn;}

/* ***************************************************************** */

/* class TorusFeatureNominalType

*/

TorusFeatureNominalType::TorusFeatureNominalType() :
  SurfaceFeatureNominalBaseType()
{
  Location = 0;
  AxisVector = 0;
  LatitudeLongitudeSweep = 0;
  Constructed = 0;
}

TorusFeatureNominalType::TorusFeatureNominalType(
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 PointType * LocationIn,
 UnitVectorType * AxisVectorIn,
 LatitudeLongitudeSweepType * LatitudeLongitudeSweepIn,
 TorusConstructionMethodType * ConstructedIn) :
  SurfaceFeatureNominalBaseType(
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  Location = LocationIn;
  AxisVector = AxisVectorIn;
  LatitudeLongitudeSweep = LatitudeLongitudeSweepIn;
  Constructed = ConstructedIn;
}

TorusFeatureNominalType::TorusFeatureNominalType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 XmlToken * NameIn,
 QPIdType * UUIDIn,
 QIFReferenceType * FeatureDefinitionIdIn,
 QIFReferenceType * ParentFeatureNominalIdIn,
 ArrayReferenceFullType * EntityInternalIdsIn,
 ArrayReferenceFullType * EntityExternalIdsIn,
 PointListType * PointListIn,
 SubstituteFeatureAlgorithmType * SubstituteFeatureAlgorithmIn,
 PointType * LocationIn,
 UnitVectorType * AxisVectorIn,
 LatitudeLongitudeSweepType * LatitudeLongitudeSweepIn,
 TorusConstructionMethodType * ConstructedIn) :
  SurfaceFeatureNominalBaseType(
    idIn,
    AttributesIn,
    NameIn,
    UUIDIn,
    FeatureDefinitionIdIn,
    ParentFeatureNominalIdIn,
    EntityInternalIdsIn,
    EntityExternalIdsIn,
    PointListIn,
    SubstituteFeatureAlgorithmIn)
{
  Location = LocationIn;
  AxisVector = AxisVectorIn;
  LatitudeLongitudeSweep = LatitudeLongitudeSweepIn;
  Constructed = ConstructedIn;
}

TorusFeatureNominalType::~TorusFeatureNominalType()
{
  #ifndef NODESTRUCT
  delete Location;
  delete AxisVector;
  delete LatitudeLongitudeSweep;
  delete Constructed;
  #endif
}

void TorusFeatureNominalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (UUID)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<UUID");
      UUID->printSelf(outFile);
      fprintf(outFile, "</UUID>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<FeatureDefinitionId");
  FeatureDefinitionId->printSelf(outFile);
  fprintf(outFile, "</FeatureDefinitionId>\n");
  if (ParentFeatureNominalId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ParentFeatureNominalId");
      ParentFeatureNominalId->printSelf(outFile);
      fprintf(outFile, "</ParentFeatureNominalId>\n");
    }
  if (EntityInternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityInternalIds");
      EntityInternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityInternalIds>\n");
    }
  if (EntityExternalIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EntityExternalIds");
      EntityExternalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EntityExternalIds>\n");
    }
  if (PointList)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointList");
      PointList->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointList>\n");
    }
  if (SubstituteFeatureAlgorithm)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubstituteFeatureAlgorithm");
      SubstituteFeatureAlgorithm->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubstituteFeatureAlgorithm>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Location");
  Location->printSelf(outFile);
  fprintf(outFile, "</Location>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<AxisVector");
  AxisVector->printSelf(outFile);
  fprintf(outFile, "</AxisVector>\n");
  if (LatitudeLongitudeSweep)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LatitudeLongitudeSweep");
      LatitudeLongitudeSweep->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LatitudeLongitudeSweep>\n");
    }
  if (Constructed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Constructed");
      Constructed->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Constructed>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool TorusFeatureNominalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in TorusFeatureNominalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in TorusFeatureNominalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in TorusFeatureNominalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in TorusFeatureNominalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

PointType * TorusFeatureNominalType::getLocation()
{return Location;}

void TorusFeatureNominalType::setLocation(PointType * LocationIn)
{Location = LocationIn;}

UnitVectorType * TorusFeatureNominalType::getAxisVector()
{return AxisVector;}

void TorusFeatureNominalType::setAxisVector(UnitVectorType * AxisVectorIn)
{AxisVector = AxisVectorIn;}

LatitudeLongitudeSweepType * TorusFeatureNominalType::getLatitudeLongitudeSweep()
{return LatitudeLongitudeSweep;}

void TorusFeatureNominalType::setLatitudeLongitudeSweep(LatitudeLongitudeSweepType * LatitudeLongitudeSweepIn)
{LatitudeLongitudeSweep = LatitudeLongitudeSweepIn;}

TorusConstructionMethodType * TorusFeatureNominalType::getConstructed()
{return Constructed;}

void TorusFeatureNominalType::setConstructed(TorusConstructionMethodType * ConstructedIn)
{Constructed = ConstructedIn;}

/* ***************************************************************** */

/* class TorusFromScanType

*/

TorusFromScanType::TorusFromScanType() :
  ConstructionMethodBaseType()
{
  SurfaceFeature = 0;
  SearchRadius = 0;
}

TorusFromScanType::TorusFromScanType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * SurfaceFeatureIn,
 LinearValueType * SearchRadiusIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  SurfaceFeature = SurfaceFeatureIn;
  SearchRadius = SearchRadiusIn;
}

TorusFromScanType::~TorusFromScanType()
{
  #ifndef NODESTRUCT
  delete SurfaceFeature;
  delete SearchRadius;
  #endif
}

void TorusFromScanType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<SurfaceFeature");
  SurfaceFeature->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</SurfaceFeature>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<SearchRadius");
  SearchRadius->printSelf(outFile);
  fprintf(outFile, "</SearchRadius>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * TorusFromScanType::getSurfaceFeature()
{return SurfaceFeature;}

void TorusFromScanType::setSurfaceFeature(BaseFeatureType * SurfaceFeatureIn)
{SurfaceFeature = SurfaceFeatureIn;}

LinearValueType * TorusFromScanType::getSearchRadius()
{return SearchRadius;}

void TorusFromScanType::setSearchRadius(LinearValueType * SearchRadiusIn)
{SearchRadius = SearchRadiusIn;}

/* ***************************************************************** */

/* class TorusMeasurementDeterminationType

*/

TorusMeasurementDeterminationType::TorusMeasurementDeterminationType()
{
  TorusMeasurementDeterminationTypePair = 0;
}

TorusMeasurementDeterminationType::TorusMeasurementDeterminationType(
 TorusMeasurementDeterminationTypeChoicePair * TorusMeasurementDeterminationTypePairIn)
{
  TorusMeasurementDeterminationTypePair = TorusMeasurementDeterminationTypePairIn;
}

TorusMeasurementDeterminationType::~TorusMeasurementDeterminationType()
{
  #ifndef NODESTRUCT
  delete TorusMeasurementDeterminationTypePair;
  #endif
}

void TorusMeasurementDeterminationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  TorusMeasurementDeterminationTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

TorusMeasurementDeterminationTypeChoicePair * TorusMeasurementDeterminationType::getTorusMeasurementDeterminationTypePair()
{return TorusMeasurementDeterminationTypePair;}

void TorusMeasurementDeterminationType::setTorusMeasurementDeterminationTypePair(TorusMeasurementDeterminationTypeChoicePair * TorusMeasurementDeterminationTypePairIn)
{TorusMeasurementDeterminationTypePair = TorusMeasurementDeterminationTypePairIn;}
TorusMeasurementDeterminationTypeChoicePair::TorusMeasurementDeterminationTypeChoicePair() {}

TorusMeasurementDeterminationTypeChoicePair::TorusMeasurementDeterminationTypeChoicePair(
 whichOne TorusMeasurementDeterminationTypeTypeIn,
 TorusMeasurementDeterminationTypeVal * TorusMeasurementDeterminationTypeValueIn)
{
  TorusMeasurementDeterminationTypeType = TorusMeasurementDeterminationTypeTypeIn;
  TorusMeasurementDeterminationTypeValue = TorusMeasurementDeterminationTypeValueIn;
}

TorusMeasurementDeterminationTypeChoicePair::~TorusMeasurementDeterminationTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (TorusMeasurementDeterminationTypeType == CheckedE)
    delete TorusMeasurementDeterminationTypeValue->Checked;
  else if (TorusMeasurementDeterminationTypeType == SetE)
    delete TorusMeasurementDeterminationTypeValue->Set;
  delete TorusMeasurementDeterminationTypeValue;
  #endif
}

void TorusMeasurementDeterminationTypeChoicePair::printSelf(FILE * outFile)
{
  if (TorusMeasurementDeterminationTypeType == CheckedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Checked");
      TorusMeasurementDeterminationTypeValue->Checked->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Checked>\n");
    }
  else if (TorusMeasurementDeterminationTypeType == SetE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Set");
      TorusMeasurementDeterminationTypeValue->Set->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class TorusRecompType

*/

TorusRecompType::TorusRecompType() :
  ConstructionMethodBaseType()
{
  BaseFeaturePointList = 0;
}

TorusRecompType::TorusRecompType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeaturePointListType * BaseFeaturePointListIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseFeaturePointList = BaseFeaturePointListIn;
}

TorusRecompType::~TorusRecompType()
{
  #ifndef NODESTRUCT
  delete BaseFeaturePointList;
  #endif
}

void TorusRecompType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseFeaturePointList");
  BaseFeaturePointList->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseFeaturePointList>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeaturePointListType * TorusRecompType::getBaseFeaturePointList()
{return BaseFeaturePointList;}

void TorusRecompType::setBaseFeaturePointList(BaseFeaturePointListType * BaseFeaturePointListIn)
{BaseFeaturePointList = BaseFeaturePointListIn;}

/* ***************************************************************** */

/* class TorusTransformType

*/

TorusTransformType::TorusTransformType() :
  ConstructionMethodBaseType()
{
  BaseTorus = 0;
  Transformation = 0;
}

TorusTransformType::TorusTransformType(
 XmlBoolean * NominalsCalculatedIn,
 BaseFeatureType * BaseTorusIn,
 TransformationReferenceType * TransformationIn) :
  ConstructionMethodBaseType(
    NominalsCalculatedIn)
{
  BaseTorus = BaseTorusIn;
  Transformation = TransformationIn;
}

TorusTransformType::~TorusTransformType()
{
  #ifndef NODESTRUCT
  delete BaseTorus;
  delete Transformation;
  #endif
}

void TorusTransformType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (NominalsCalculated)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalsCalculated");
      NominalsCalculated->printSelf(outFile);
      fprintf(outFile, "</NominalsCalculated>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseTorus");
  BaseTorus->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BaseTorus>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Transformation");
  Transformation->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Transformation>\n");
  doSpaces(-INDENT, outFile);
}

BaseFeatureType * TorusTransformType::getBaseTorus()
{return BaseTorus;}

void TorusTransformType::setBaseTorus(BaseFeatureType * BaseTorusIn)
{BaseTorus = BaseTorusIn;}

TransformationReferenceType * TorusTransformType::getTransformation()
{return Transformation;}

void TorusTransformType::setTransformation(TransformationReferenceType * TransformationIn)
{Transformation = TransformationIn;}

/* ***************************************************************** */

/* class TransformationReferenceType

*/

TransformationReferenceType::TransformationReferenceType()
{
  ReferencedComponent = 0;
  CoordinateSystemId = 0;
  SequenceNumber = 0;
}

TransformationReferenceType::TransformationReferenceType(
 ReferencedComponentEnumType * ReferencedComponentIn,
 QIFReferenceFullType * CoordinateSystemIdIn,
 NaturalType * SequenceNumberIn)
{
  ReferencedComponent = ReferencedComponentIn;
  CoordinateSystemId = CoordinateSystemIdIn;
  SequenceNumber = SequenceNumberIn;
}

TransformationReferenceType::~TransformationReferenceType()
{
  #ifndef NODESTRUCT
  delete ReferencedComponent;
  delete CoordinateSystemId;
  delete SequenceNumber;
  #endif
}

void TransformationReferenceType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<ReferencedComponent");
  ReferencedComponent->printSelf(outFile);
  fprintf(outFile, "</ReferencedComponent>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CoordinateSystemId");
  CoordinateSystemId->printSelf(outFile);
  fprintf(outFile, "</CoordinateSystemId>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<SequenceNumber");
  SequenceNumber->printSelf(outFile);
  fprintf(outFile, "</SequenceNumber>\n");
  doSpaces(-INDENT, outFile);
}

ReferencedComponentEnumType * TransformationReferenceType::getReferencedComponent()
{return ReferencedComponent;}

void TransformationReferenceType::setReferencedComponent(ReferencedComponentEnumType * ReferencedComponentIn)
{ReferencedComponent = ReferencedComponentIn;}

QIFReferenceFullType * TransformationReferenceType::getCoordinateSystemId()
{return CoordinateSystemId;}

void TransformationReferenceType::setCoordinateSystemId(QIFReferenceFullType * CoordinateSystemIdIn)
{CoordinateSystemId = CoordinateSystemIdIn;}

NaturalType * TransformationReferenceType::getSequenceNumber()
{return SequenceNumber;}

void TransformationReferenceType::setSequenceNumber(NaturalType * SequenceNumberIn)
{SequenceNumber = SequenceNumberIn;}

/* ***************************************************************** */

/* class ConeFeatureDefi_1071_Type

*/

ConeFeatureDefi_1071_Type::ConeFeatureDefi_1071_Type()
{
  ConeFeatureDefi_1071_TypePair = 0;
}

ConeFeatureDefi_1071_Type::ConeFeatureDefi_1071_Type(
 ConeFeatureDefi_1071_TypeChoicePair * ConeFeatureDefi_1071_TypePairIn)
{
  ConeFeatureDefi_1071_TypePair = ConeFeatureDefi_1071_TypePairIn;
}

ConeFeatureDefi_1071_Type::~ConeFeatureDefi_1071_Type()
{
  #ifndef NODESTRUCT
  delete ConeFeatureDefi_1071_TypePair;
  #endif
}

void ConeFeatureDefi_1071_Type::printSelf(FILE * outFile)
{
  ConeFeatureDefi_1071_TypePair->printSelf(outFile);
}

ConeFeatureDefi_1071_TypeChoicePair * ConeFeatureDefi_1071_Type::getConeFeatureDefi_1071_TypePair()
{return ConeFeatureDefi_1071_TypePair;}

void ConeFeatureDefi_1071_Type::setConeFeatureDefi_1071_TypePair(ConeFeatureDefi_1071_TypeChoicePair * ConeFeatureDefi_1071_TypePairIn)
{ConeFeatureDefi_1071_TypePair = ConeFeatureDefi_1071_TypePairIn;}
ConeFeatureDefi_1071_TypeChoicePair::ConeFeatureDefi_1071_TypeChoicePair() {}

ConeFeatureDefi_1071_TypeChoicePair::ConeFeatureDefi_1071_TypeChoicePair(
 whichOne ConeFeatureDefi_1071_TypeTypeIn,
 ConeFeatureDefi_1071_TypeVal * ConeFeatureDefi_1071_TypeValueIn)
{
  ConeFeatureDefi_1071_TypeType = ConeFeatureDefi_1071_TypeTypeIn;
  ConeFeatureDefi_1071_TypeValue = ConeFeatureDefi_1071_TypeValueIn;
}

ConeFeatureDefi_1071_TypeChoicePair::~ConeFeatureDefi_1071_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (ConeFeatureDefi_1071_TypeType == HalfAngleE)
    delete ConeFeatureDefi_1071_TypeValue->HalfAngle;
  else if (ConeFeatureDefi_1071_TypeType == FullAngleE)
    delete ConeFeatureDefi_1071_TypeValue->FullAngle;
  delete ConeFeatureDefi_1071_TypeValue;
  #endif
}

void ConeFeatureDefi_1071_TypeChoicePair::printSelf(FILE * outFile)
{
  if (ConeFeatureDefi_1071_TypeType == HalfAngleE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<HalfAngle");
      ConeFeatureDefi_1071_TypeValue->HalfAngle->printSelf(outFile);
      fprintf(outFile, "</HalfAngle>\n");
    }
  else if (ConeFeatureDefi_1071_TypeType == FullAngleE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FullAngle");
      ConeFeatureDefi_1071_TypeValue->FullAngle->printSelf(outFile);
      fprintf(outFile, "</FullAngle>\n");
    }
}

/* ***************************************************************** */

/* class ConeFeatureDefi_1072_Type

*/

ConeFeatureDefi_1072_Type::ConeFeatureDefi_1072_Type()
{
  LargeEndDistance = 0;
  SmallEndDistance = 0;
}

ConeFeatureDefi_1072_Type::ConeFeatureDefi_1072_Type(
 LinearValueType * LargeEndDistanceIn,
 LinearValueType * SmallEndDistanceIn)
{
  LargeEndDistance = LargeEndDistanceIn;
  SmallEndDistance = SmallEndDistanceIn;
}

ConeFeatureDefi_1072_Type::~ConeFeatureDefi_1072_Type()
{
  #ifndef NODESTRUCT
  delete LargeEndDistance;
  delete SmallEndDistance;
  #endif
}

void ConeFeatureDefi_1072_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<LargeEndDistance");
  LargeEndDistance->printSelf(outFile);
  fprintf(outFile, "</LargeEndDistance>\n");
  if (SmallEndDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SmallEndDistance");
      SmallEndDistance->printSelf(outFile);
      fprintf(outFile, "</SmallEndDistance>\n");
    }
}

LinearValueType * ConeFeatureDefi_1072_Type::getLargeEndDistance()
{return LargeEndDistance;}

void ConeFeatureDefi_1072_Type::setLargeEndDistance(LinearValueType * LargeEndDistanceIn)
{LargeEndDistance = LargeEndDistanceIn;}

LinearValueType * ConeFeatureDefi_1072_Type::getSmallEndDistance()
{return SmallEndDistance;}

void ConeFeatureDefi_1072_Type::setSmallEndDistance(LinearValueType * SmallEndDistanceIn)
{SmallEndDistance = SmallEndDistanceIn;}

/* ***************************************************************** */

/* class ConeFeatureMeas_1073_Type

*/

ConeFeatureMeas_1073_Type::ConeFeatureMeas_1073_Type()
{
  ConeFeatureMeas_1073_TypePair = 0;
}

ConeFeatureMeas_1073_Type::ConeFeatureMeas_1073_Type(
 ConeFeatureMeas_1073_TypeChoicePair * ConeFeatureMeas_1073_TypePairIn)
{
  ConeFeatureMeas_1073_TypePair = ConeFeatureMeas_1073_TypePairIn;
}

ConeFeatureMeas_1073_Type::~ConeFeatureMeas_1073_Type()
{
  #ifndef NODESTRUCT
  delete ConeFeatureMeas_1073_TypePair;
  #endif
}

void ConeFeatureMeas_1073_Type::printSelf(FILE * outFile)
{
  if (ConeFeatureMeas_1073_TypePair)
    {
      ConeFeatureMeas_1073_TypePair->printSelf(outFile);
    }
}

ConeFeatureMeas_1073_TypeChoicePair * ConeFeatureMeas_1073_Type::getConeFeatureMeas_1073_TypePair()
{return ConeFeatureMeas_1073_TypePair;}

void ConeFeatureMeas_1073_Type::setConeFeatureMeas_1073_TypePair(ConeFeatureMeas_1073_TypeChoicePair * ConeFeatureMeas_1073_TypePairIn)
{ConeFeatureMeas_1073_TypePair = ConeFeatureMeas_1073_TypePairIn;}
ConeFeatureMeas_1073_TypeChoicePair::ConeFeatureMeas_1073_TypeChoicePair() {}

ConeFeatureMeas_1073_TypeChoicePair::ConeFeatureMeas_1073_TypeChoicePair(
 whichOne ConeFeatureMeas_1073_TypeTypeIn,
 ConeFeatureMeas_1073_TypeVal * ConeFeatureMeas_1073_TypeValueIn)
{
  ConeFeatureMeas_1073_TypeType = ConeFeatureMeas_1073_TypeTypeIn;
  ConeFeatureMeas_1073_TypeValue = ConeFeatureMeas_1073_TypeValueIn;
}

ConeFeatureMeas_1073_TypeChoicePair::~ConeFeatureMeas_1073_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (ConeFeatureMeas_1073_TypeType == HalfAngleE)
    delete ConeFeatureMeas_1073_TypeValue->HalfAngle;
  else if (ConeFeatureMeas_1073_TypeType == FullAngleE)
    delete ConeFeatureMeas_1073_TypeValue->FullAngle;
  delete ConeFeatureMeas_1073_TypeValue;
  #endif
}

void ConeFeatureMeas_1073_TypeChoicePair::printSelf(FILE * outFile)
{
  if (ConeFeatureMeas_1073_TypeType == HalfAngleE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<HalfAngle");
      ConeFeatureMeas_1073_TypeValue->HalfAngle->printSelf(outFile);
      fprintf(outFile, "</HalfAngle>\n");
    }
  else if (ConeFeatureMeas_1073_TypeType == FullAngleE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FullAngle");
      ConeFeatureMeas_1073_TypeValue->FullAngle->printSelf(outFile);
      fprintf(outFile, "</FullAngle>\n");
    }
}

/* ***************************************************************** */

/* class ConicalSegmentF_1074_Type

*/

ConicalSegmentF_1074_Type::ConicalSegmentF_1074_Type()
{
  ConicalSegmentF_1074_TypePair = 0;
}

ConicalSegmentF_1074_Type::ConicalSegmentF_1074_Type(
 ConicalSegmentF_1074_TypeChoicePair * ConicalSegmentF_1074_TypePairIn)
{
  ConicalSegmentF_1074_TypePair = ConicalSegmentF_1074_TypePairIn;
}

ConicalSegmentF_1074_Type::~ConicalSegmentF_1074_Type()
{
  #ifndef NODESTRUCT
  delete ConicalSegmentF_1074_TypePair;
  #endif
}

void ConicalSegmentF_1074_Type::printSelf(FILE * outFile)
{
  ConicalSegmentF_1074_TypePair->printSelf(outFile);
}

ConicalSegmentF_1074_TypeChoicePair * ConicalSegmentF_1074_Type::getConicalSegmentF_1074_TypePair()
{return ConicalSegmentF_1074_TypePair;}

void ConicalSegmentF_1074_Type::setConicalSegmentF_1074_TypePair(ConicalSegmentF_1074_TypeChoicePair * ConicalSegmentF_1074_TypePairIn)
{ConicalSegmentF_1074_TypePair = ConicalSegmentF_1074_TypePairIn;}
ConicalSegmentF_1074_TypeChoicePair::ConicalSegmentF_1074_TypeChoicePair() {}

ConicalSegmentF_1074_TypeChoicePair::ConicalSegmentF_1074_TypeChoicePair(
 whichOne ConicalSegmentF_1074_TypeTypeIn,
 ConicalSegmentF_1074_TypeVal * ConicalSegmentF_1074_TypeValueIn)
{
  ConicalSegmentF_1074_TypeType = ConicalSegmentF_1074_TypeTypeIn;
  ConicalSegmentF_1074_TypeValue = ConicalSegmentF_1074_TypeValueIn;
}

ConicalSegmentF_1074_TypeChoicePair::~ConicalSegmentF_1074_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (ConicalSegmentF_1074_TypeType == HalfAngleE)
    delete ConicalSegmentF_1074_TypeValue->HalfAngle;
  else if (ConicalSegmentF_1074_TypeType == FullAngleE)
    delete ConicalSegmentF_1074_TypeValue->FullAngle;
  delete ConicalSegmentF_1074_TypeValue;
  #endif
}

void ConicalSegmentF_1074_TypeChoicePair::printSelf(FILE * outFile)
{
  if (ConicalSegmentF_1074_TypeType == HalfAngleE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<HalfAngle");
      ConicalSegmentF_1074_TypeValue->HalfAngle->printSelf(outFile);
      fprintf(outFile, "</HalfAngle>\n");
    }
  else if (ConicalSegmentF_1074_TypeType == FullAngleE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FullAngle");
      ConicalSegmentF_1074_TypeValue->FullAngle->printSelf(outFile);
      fprintf(outFile, "</FullAngle>\n");
    }
}

/* ***************************************************************** */

/* class ConicalSegmentF_1075_Type

*/

ConicalSegmentF_1075_Type::ConicalSegmentF_1075_Type()
{
  LargeEndDistance = 0;
  SmallEndDistance = 0;
}

ConicalSegmentF_1075_Type::ConicalSegmentF_1075_Type(
 LinearValueType * LargeEndDistanceIn,
 LinearValueType * SmallEndDistanceIn)
{
  LargeEndDistance = LargeEndDistanceIn;
  SmallEndDistance = SmallEndDistanceIn;
}

ConicalSegmentF_1075_Type::~ConicalSegmentF_1075_Type()
{
  #ifndef NODESTRUCT
  delete LargeEndDistance;
  delete SmallEndDistance;
  #endif
}

void ConicalSegmentF_1075_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<LargeEndDistance");
  LargeEndDistance->printSelf(outFile);
  fprintf(outFile, "</LargeEndDistance>\n");
  if (SmallEndDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SmallEndDistance");
      SmallEndDistance->printSelf(outFile);
      fprintf(outFile, "</SmallEndDistance>\n");
    }
}

LinearValueType * ConicalSegmentF_1075_Type::getLargeEndDistance()
{return LargeEndDistance;}

void ConicalSegmentF_1075_Type::setLargeEndDistance(LinearValueType * LargeEndDistanceIn)
{LargeEndDistance = LargeEndDistanceIn;}

LinearValueType * ConicalSegmentF_1075_Type::getSmallEndDistance()
{return SmallEndDistance;}

void ConicalSegmentF_1075_Type::setSmallEndDistance(LinearValueType * SmallEndDistanceIn)
{SmallEndDistance = SmallEndDistanceIn;}

/* ***************************************************************** */

/* class ConicalSegmentF_1076_Type

*/

ConicalSegmentF_1076_Type::ConicalSegmentF_1076_Type()
{
  ConicalSegmentF_1076_TypePair = 0;
}

ConicalSegmentF_1076_Type::ConicalSegmentF_1076_Type(
 ConicalSegmentF_1076_TypeChoicePair * ConicalSegmentF_1076_TypePairIn)
{
  ConicalSegmentF_1076_TypePair = ConicalSegmentF_1076_TypePairIn;
}

ConicalSegmentF_1076_Type::~ConicalSegmentF_1076_Type()
{
  #ifndef NODESTRUCT
  delete ConicalSegmentF_1076_TypePair;
  #endif
}

void ConicalSegmentF_1076_Type::printSelf(FILE * outFile)
{
  if (ConicalSegmentF_1076_TypePair)
    {
      ConicalSegmentF_1076_TypePair->printSelf(outFile);
    }
}

ConicalSegmentF_1076_TypeChoicePair * ConicalSegmentF_1076_Type::getConicalSegmentF_1076_TypePair()
{return ConicalSegmentF_1076_TypePair;}

void ConicalSegmentF_1076_Type::setConicalSegmentF_1076_TypePair(ConicalSegmentF_1076_TypeChoicePair * ConicalSegmentF_1076_TypePairIn)
{ConicalSegmentF_1076_TypePair = ConicalSegmentF_1076_TypePairIn;}
ConicalSegmentF_1076_TypeChoicePair::ConicalSegmentF_1076_TypeChoicePair() {}

ConicalSegmentF_1076_TypeChoicePair::ConicalSegmentF_1076_TypeChoicePair(
 whichOne ConicalSegmentF_1076_TypeTypeIn,
 ConicalSegmentF_1076_TypeVal * ConicalSegmentF_1076_TypeValueIn)
{
  ConicalSegmentF_1076_TypeType = ConicalSegmentF_1076_TypeTypeIn;
  ConicalSegmentF_1076_TypeValue = ConicalSegmentF_1076_TypeValueIn;
}

ConicalSegmentF_1076_TypeChoicePair::~ConicalSegmentF_1076_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (ConicalSegmentF_1076_TypeType == HalfAngleE)
    delete ConicalSegmentF_1076_TypeValue->HalfAngle;
  else if (ConicalSegmentF_1076_TypeType == FullAngleE)
    delete ConicalSegmentF_1076_TypeValue->FullAngle;
  delete ConicalSegmentF_1076_TypeValue;
  #endif
}

void ConicalSegmentF_1076_TypeChoicePair::printSelf(FILE * outFile)
{
  if (ConicalSegmentF_1076_TypeType == HalfAngleE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<HalfAngle");
      ConicalSegmentF_1076_TypeValue->HalfAngle->printSelf(outFile);
      fprintf(outFile, "</HalfAngle>\n");
    }
  else if (ConicalSegmentF_1076_TypeType == FullAngleE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FullAngle");
      ConicalSegmentF_1076_TypeValue->FullAngle->printSelf(outFile);
      fprintf(outFile, "</FullAngle>\n");
    }
}

/* ***************************************************************** */

/* class FeatureZoneArea_1077_Type

*/

FeatureZoneArea_1077_Type::FeatureZoneArea_1077_Type()
{
  FeatureZoneArea_1077_TypePair = 0;
}

FeatureZoneArea_1077_Type::FeatureZoneArea_1077_Type(
 FeatureZoneArea_1077_TypeChoicePair * FeatureZoneArea_1077_TypePairIn)
{
  FeatureZoneArea_1077_TypePair = FeatureZoneArea_1077_TypePairIn;
}

FeatureZoneArea_1077_Type::~FeatureZoneArea_1077_Type()
{
  #ifndef NODESTRUCT
  delete FeatureZoneArea_1077_TypePair;
  #endif
}

void FeatureZoneArea_1077_Type::printSelf(FILE * outFile)
{
  FeatureZoneArea_1077_TypePair->printSelf(outFile);
}

FeatureZoneArea_1077_TypeChoicePair * FeatureZoneArea_1077_Type::getFeatureZoneArea_1077_TypePair()
{return FeatureZoneArea_1077_TypePair;}

void FeatureZoneArea_1077_Type::setFeatureZoneArea_1077_TypePair(FeatureZoneArea_1077_TypeChoicePair * FeatureZoneArea_1077_TypePairIn)
{FeatureZoneArea_1077_TypePair = FeatureZoneArea_1077_TypePairIn;}
FeatureZoneArea_1077_TypeChoicePair::FeatureZoneArea_1077_TypeChoicePair() {}

FeatureZoneArea_1077_TypeChoicePair::FeatureZoneArea_1077_TypeChoicePair(
 whichOne FeatureZoneArea_1077_TypeTypeIn,
 FeatureZoneArea_1077_TypeVal * FeatureZoneArea_1077_TypeValueIn)
{
  FeatureZoneArea_1077_TypeType = FeatureZoneArea_1077_TypeTypeIn;
  FeatureZoneArea_1077_TypeValue = FeatureZoneArea_1077_TypeValueIn;
}

FeatureZoneArea_1077_TypeChoicePair::~FeatureZoneArea_1077_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (FeatureZoneArea_1077_TypeType == FromPointZoneIdE)
    delete FeatureZoneArea_1077_TypeValue->FromPointZoneId;
  else if (FeatureZoneArea_1077_TypeType == FromCurveZoneIdE)
    delete FeatureZoneArea_1077_TypeValue->FromCurveZoneId;
  delete FeatureZoneArea_1077_TypeValue;
  #endif
}

void FeatureZoneArea_1077_TypeChoicePair::printSelf(FILE * outFile)
{
  if (FeatureZoneArea_1077_TypeType == FromPointZoneIdE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FromPointZoneId");
      FeatureZoneArea_1077_TypeValue->FromPointZoneId->printSelf(outFile);
      fprintf(outFile, "</FromPointZoneId>\n");
    }
  else if (FeatureZoneArea_1077_TypeType == FromCurveZoneIdE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FromCurveZoneId");
      FeatureZoneArea_1077_TypeValue->FromCurveZoneId->printSelf(outFile);
      fprintf(outFile, "</FromCurveZoneId>\n");
    }
}

/* ***************************************************************** */

/* class FeatureZoneArea_1078_Type

*/

FeatureZoneArea_1078_Type::FeatureZoneArea_1078_Type()
{
  FeatureZoneArea_1078_TypePair = 0;
}

FeatureZoneArea_1078_Type::FeatureZoneArea_1078_Type(
 FeatureZoneArea_1078_TypeChoicePair * FeatureZoneArea_1078_TypePairIn)
{
  FeatureZoneArea_1078_TypePair = FeatureZoneArea_1078_TypePairIn;
}

FeatureZoneArea_1078_Type::~FeatureZoneArea_1078_Type()
{
  #ifndef NODESTRUCT
  delete FeatureZoneArea_1078_TypePair;
  #endif
}

void FeatureZoneArea_1078_Type::printSelf(FILE * outFile)
{
  FeatureZoneArea_1078_TypePair->printSelf(outFile);
}

FeatureZoneArea_1078_TypeChoicePair * FeatureZoneArea_1078_Type::getFeatureZoneArea_1078_TypePair()
{return FeatureZoneArea_1078_TypePair;}

void FeatureZoneArea_1078_Type::setFeatureZoneArea_1078_TypePair(FeatureZoneArea_1078_TypeChoicePair * FeatureZoneArea_1078_TypePairIn)
{FeatureZoneArea_1078_TypePair = FeatureZoneArea_1078_TypePairIn;}
FeatureZoneArea_1078_TypeChoicePair::FeatureZoneArea_1078_TypeChoicePair() {}

FeatureZoneArea_1078_TypeChoicePair::FeatureZoneArea_1078_TypeChoicePair(
 whichOne FeatureZoneArea_1078_TypeTypeIn,
 FeatureZoneArea_1078_TypeVal * FeatureZoneArea_1078_TypeValueIn)
{
  FeatureZoneArea_1078_TypeType = FeatureZoneArea_1078_TypeTypeIn;
  FeatureZoneArea_1078_TypeValue = FeatureZoneArea_1078_TypeValueIn;
}

FeatureZoneArea_1078_TypeChoicePair::~FeatureZoneArea_1078_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (FeatureZoneArea_1078_TypeType == ToPointZoneIdE)
    delete FeatureZoneArea_1078_TypeValue->ToPointZoneId;
  else if (FeatureZoneArea_1078_TypeType == ToCurveZoneIdE)
    delete FeatureZoneArea_1078_TypeValue->ToCurveZoneId;
  delete FeatureZoneArea_1078_TypeValue;
  #endif
}

void FeatureZoneArea_1078_TypeChoicePair::printSelf(FILE * outFile)
{
  if (FeatureZoneArea_1078_TypeType == ToPointZoneIdE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToPointZoneId");
      FeatureZoneArea_1078_TypeValue->ToPointZoneId->printSelf(outFile);
      fprintf(outFile, "</ToPointZoneId>\n");
    }
  else if (FeatureZoneArea_1078_TypeType == ToCurveZoneIdE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToCurveZoneId");
      FeatureZoneArea_1078_TypeValue->ToCurveZoneId->printSelf(outFile);
      fprintf(outFile, "</ToCurveZoneId>\n");
    }
}

/* ***************************************************************** */

/* class FeatureZonePoin_1079_Type

*/

FeatureZonePoin_1079_Type::FeatureZonePoin_1079_Type()
{
  FeatureZonePoin_1079_TypePair = 0;
}

FeatureZonePoin_1079_Type::FeatureZonePoin_1079_Type(
 FeatureZonePoin_1079_TypeChoicePair * FeatureZonePoin_1079_TypePairIn)
{
  FeatureZonePoin_1079_TypePair = FeatureZonePoin_1079_TypePairIn;
}

FeatureZonePoin_1079_Type::~FeatureZonePoin_1079_Type()
{
  #ifndef NODESTRUCT
  delete FeatureZonePoin_1079_TypePair;
  #endif
}

void FeatureZonePoin_1079_Type::printSelf(FILE * outFile)
{
  if (FeatureZonePoin_1079_TypePair)
    {
      FeatureZonePoin_1079_TypePair->printSelf(outFile);
    }
}

FeatureZonePoin_1079_TypeChoicePair * FeatureZonePoin_1079_Type::getFeatureZonePoin_1079_TypePair()
{return FeatureZonePoin_1079_TypePair;}

void FeatureZonePoin_1079_Type::setFeatureZonePoin_1079_TypePair(FeatureZonePoin_1079_TypeChoicePair * FeatureZonePoin_1079_TypePairIn)
{FeatureZonePoin_1079_TypePair = FeatureZonePoin_1079_TypePairIn;}
FeatureZonePoin_1079_TypeChoicePair::FeatureZonePoin_1079_TypeChoicePair() {}

FeatureZonePoin_1079_TypeChoicePair::FeatureZonePoin_1079_TypeChoicePair(
 whichOne FeatureZonePoin_1079_TypeTypeIn,
 FeatureZonePoin_1079_TypeVal * FeatureZonePoin_1079_TypeValueIn)
{
  FeatureZonePoin_1079_TypeType = FeatureZonePoin_1079_TypeTypeIn;
  FeatureZonePoin_1079_TypeValue = FeatureZonePoin_1079_TypeValueIn;
}

FeatureZonePoin_1079_TypeChoicePair::~FeatureZonePoin_1079_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (FeatureZonePoin_1079_TypeType == VertexIdE)
    delete FeatureZonePoin_1079_TypeValue->VertexId;
  else if (FeatureZonePoin_1079_TypeType == PointIdE)
    delete FeatureZonePoin_1079_TypeValue->PointId;
  delete FeatureZonePoin_1079_TypeValue;
  #endif
}

void FeatureZonePoin_1079_TypeChoicePair::printSelf(FILE * outFile)
{
  if (FeatureZonePoin_1079_TypeType == VertexIdE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VertexId");
      FeatureZonePoin_1079_TypeValue->VertexId->printSelf(outFile);
      fprintf(outFile, "</VertexId>\n");
    }
  else if (FeatureZonePoin_1079_TypeType == PointIdE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointId");
      FeatureZonePoin_1079_TypeValue->PointId->printSelf(outFile);
      fprintf(outFile, "</PointId>\n");
    }
}

/* ***************************************************************** */

/* class GroupFeatureDef_1080_Type

*/

GroupFeatureDef_1080_Type::GroupFeatureDef_1080_Type()
{
  GroupFeatureDef_1080_TypePair = 0;
}

GroupFeatureDef_1080_Type::GroupFeatureDef_1080_Type(
 GroupFeatureDef_1080_TypeChoicePair * GroupFeatureDef_1080_TypePairIn)
{
  GroupFeatureDef_1080_TypePair = GroupFeatureDef_1080_TypePairIn;
}

GroupFeatureDef_1080_Type::~GroupFeatureDef_1080_Type()
{
  #ifndef NODESTRUCT
  delete GroupFeatureDef_1080_TypePair;
  #endif
}

void GroupFeatureDef_1080_Type::printSelf(FILE * outFile)
{
  if (GroupFeatureDef_1080_TypePair)
    {
      GroupFeatureDef_1080_TypePair->printSelf(outFile);
    }
}

GroupFeatureDef_1080_TypeChoicePair * GroupFeatureDef_1080_Type::getGroupFeatureDef_1080_TypePair()
{return GroupFeatureDef_1080_TypePair;}

void GroupFeatureDef_1080_Type::setGroupFeatureDef_1080_TypePair(GroupFeatureDef_1080_TypeChoicePair * GroupFeatureDef_1080_TypePairIn)
{GroupFeatureDef_1080_TypePair = GroupFeatureDef_1080_TypePairIn;}
GroupFeatureDef_1080_TypeChoicePair::GroupFeatureDef_1080_TypeChoicePair() {}

GroupFeatureDef_1080_TypeChoicePair::GroupFeatureDef_1080_TypeChoicePair(
 whichOne GroupFeatureDef_1080_TypeTypeIn,
 GroupFeatureDef_1080_TypeVal * GroupFeatureDef_1080_TypeValueIn)
{
  GroupFeatureDef_1080_TypeType = GroupFeatureDef_1080_TypeTypeIn;
  GroupFeatureDef_1080_TypeValue = GroupFeatureDef_1080_TypeValueIn;
}

GroupFeatureDef_1080_TypeChoicePair::~GroupFeatureDef_1080_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (GroupFeatureDef_1080_TypeType == IsCountersunkHoleE)
    delete GroupFeatureDef_1080_TypeValue->IsCountersunkHole;
  else if (GroupFeatureDef_1080_TypeType == IsCounterboredHoleE)
    delete GroupFeatureDef_1080_TypeValue->IsCounterboredHole;
  else if (GroupFeatureDef_1080_TypeType == IsSpotfaceE)
    delete GroupFeatureDef_1080_TypeValue->IsSpotface;
  delete GroupFeatureDef_1080_TypeValue;
  #endif
}

void GroupFeatureDef_1080_TypeChoicePair::printSelf(FILE * outFile)
{
  if (GroupFeatureDef_1080_TypeType == IsCountersunkHoleE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IsCountersunkHole");
      GroupFeatureDef_1080_TypeValue->IsCountersunkHole->printSelf(outFile);
      fprintf(outFile, "</IsCountersunkHole>\n");
    }
  else if (GroupFeatureDef_1080_TypeType == IsCounterboredHoleE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IsCounterboredHole");
      GroupFeatureDef_1080_TypeValue->IsCounterboredHole->printSelf(outFile);
      fprintf(outFile, "</IsCounterboredHole>\n");
    }
  else if (GroupFeatureDef_1080_TypeType == IsSpotfaceE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IsSpotface");
      GroupFeatureDef_1080_TypeValue->IsSpotface->printSelf(outFile);
      fprintf(outFile, "</IsSpotface>\n");
    }
}

/* ***************************************************************** */

/* class MeasuredPointSe_1081_Type

*/

MeasuredPointSe_1081_Type::MeasuredPointSe_1081_Type()
{
  MeasuredPointSe_1081_TypePair = 0;
}

MeasuredPointSe_1081_Type::MeasuredPointSe_1081_Type(
 MeasuredPointSe_1081_TypeChoicePair * MeasuredPointSe_1081_TypePairIn)
{
  MeasuredPointSe_1081_TypePair = MeasuredPointSe_1081_TypePairIn;
}

MeasuredPointSe_1081_Type::~MeasuredPointSe_1081_Type()
{
  #ifndef NODESTRUCT
  delete MeasuredPointSe_1081_TypePair;
  #endif
}

void MeasuredPointSe_1081_Type::printSelf(FILE * outFile)
{
  if (MeasuredPointSe_1081_TypePair)
    {
      MeasuredPointSe_1081_TypePair->printSelf(outFile);
    }
}

MeasuredPointSe_1081_TypeChoicePair * MeasuredPointSe_1081_Type::getMeasuredPointSe_1081_TypePair()
{return MeasuredPointSe_1081_TypePair;}

void MeasuredPointSe_1081_Type::setMeasuredPointSe_1081_TypePair(MeasuredPointSe_1081_TypeChoicePair * MeasuredPointSe_1081_TypePairIn)
{MeasuredPointSe_1081_TypePair = MeasuredPointSe_1081_TypePairIn;}
MeasuredPointSe_1081_TypeChoicePair::MeasuredPointSe_1081_TypeChoicePair() {}

MeasuredPointSe_1081_TypeChoicePair::MeasuredPointSe_1081_TypeChoicePair(
 whichOne MeasuredPointSe_1081_TypeTypeIn,
 MeasuredPointSe_1081_TypeVal * MeasuredPointSe_1081_TypeValueIn)
{
  MeasuredPointSe_1081_TypeType = MeasuredPointSe_1081_TypeTypeIn;
  MeasuredPointSe_1081_TypeValue = MeasuredPointSe_1081_TypeValueIn;
}

MeasuredPointSe_1081_TypeChoicePair::~MeasuredPointSe_1081_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (MeasuredPointSe_1081_TypeType == CoordinateSystemIdE)
    delete MeasuredPointSe_1081_TypeValue->CoordinateSystemId;
  else if (MeasuredPointSe_1081_TypeType == TranformIdE)
    delete MeasuredPointSe_1081_TypeValue->TranformId;
  delete MeasuredPointSe_1081_TypeValue;
  #endif
}

void MeasuredPointSe_1081_TypeChoicePair::printSelf(FILE * outFile)
{
  if (MeasuredPointSe_1081_TypeType == CoordinateSystemIdE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CoordinateSystemId");
      MeasuredPointSe_1081_TypeValue->CoordinateSystemId->printSelf(outFile);
      fprintf(outFile, "</CoordinateSystemId>\n");
    }
  else if (MeasuredPointSe_1081_TypeType == TranformIdE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TranformId");
      MeasuredPointSe_1081_TypeValue->TranformId->printSelf(outFile);
      fprintf(outFile, "</TranformId>\n");
    }
}

/* ***************************************************************** */

/* class MeasuredPointSe_1082_Type

*/

MeasuredPointSe_1082_Type::MeasuredPointSe_1082_Type()
{
  MeasuredPointSe_1082_TypePair = 0;
}

MeasuredPointSe_1082_Type::MeasuredPointSe_1082_Type(
 MeasuredPointSe_1082_TypeChoicePair * MeasuredPointSe_1082_TypePairIn)
{
  MeasuredPointSe_1082_TypePair = MeasuredPointSe_1082_TypePairIn;
}

MeasuredPointSe_1082_Type::~MeasuredPointSe_1082_Type()
{
  #ifndef NODESTRUCT
  delete MeasuredPointSe_1082_TypePair;
  #endif
}

void MeasuredPointSe_1082_Type::printSelf(FILE * outFile)
{
  MeasuredPointSe_1082_TypePair->printSelf(outFile);
}

MeasuredPointSe_1082_TypeChoicePair * MeasuredPointSe_1082_Type::getMeasuredPointSe_1082_TypePair()
{return MeasuredPointSe_1082_TypePair;}

void MeasuredPointSe_1082_Type::setMeasuredPointSe_1082_TypePair(MeasuredPointSe_1082_TypeChoicePair * MeasuredPointSe_1082_TypePairIn)
{MeasuredPointSe_1082_TypePair = MeasuredPointSe_1082_TypePairIn;}
MeasuredPointSe_1082_TypeChoicePair::MeasuredPointSe_1082_TypeChoicePair() {}

MeasuredPointSe_1082_TypeChoicePair::MeasuredPointSe_1082_TypeChoicePair(
 whichOne MeasuredPointSe_1082_TypeTypeIn,
 MeasuredPointSe_1082_TypeVal * MeasuredPointSe_1082_TypeValueIn)
{
  MeasuredPointSe_1082_TypeType = MeasuredPointSe_1082_TypeTypeIn;
  MeasuredPointSe_1082_TypeValue = MeasuredPointSe_1082_TypeValueIn;
}

MeasuredPointSe_1082_TypeChoicePair::~MeasuredPointSe_1082_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (MeasuredPointSe_1082_TypeType == PointsE)
    delete MeasuredPointSe_1082_TypeValue->Points;
  else if (MeasuredPointSe_1082_TypeType == BinaryPointsE)
    delete MeasuredPointSe_1082_TypeValue->BinaryPoints;
  delete MeasuredPointSe_1082_TypeValue;
  #endif
}

void MeasuredPointSe_1082_TypeChoicePair::printSelf(FILE * outFile)
{
  if (MeasuredPointSe_1082_TypeType == PointsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Points");
      MeasuredPointSe_1082_TypeValue->Points->printSelf(outFile);
      fprintf(outFile, "</Points>\n");
    }
  else if (MeasuredPointSe_1082_TypeType == BinaryPointsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BinaryPoints");
      MeasuredPointSe_1082_TypeValue->BinaryPoints->printSelf(outFile);
      fprintf(outFile, "</BinaryPoints>\n");
    }
}

/* ***************************************************************** */

/* class MeasuredPointSe_1083_Type

*/

MeasuredPointSe_1083_Type::MeasuredPointSe_1083_Type()
{
  MeasuredPointSe_1083_TypePair = 0;
}

MeasuredPointSe_1083_Type::MeasuredPointSe_1083_Type(
 MeasuredPointSe_1083_TypeChoicePair * MeasuredPointSe_1083_TypePairIn)
{
  MeasuredPointSe_1083_TypePair = MeasuredPointSe_1083_TypePairIn;
}

MeasuredPointSe_1083_Type::~MeasuredPointSe_1083_Type()
{
  #ifndef NODESTRUCT
  delete MeasuredPointSe_1083_TypePair;
  #endif
}

void MeasuredPointSe_1083_Type::printSelf(FILE * outFile)
{
  if (MeasuredPointSe_1083_TypePair)
    {
      MeasuredPointSe_1083_TypePair->printSelf(outFile);
    }
}

MeasuredPointSe_1083_TypeChoicePair * MeasuredPointSe_1083_Type::getMeasuredPointSe_1083_TypePair()
{return MeasuredPointSe_1083_TypePair;}

void MeasuredPointSe_1083_Type::setMeasuredPointSe_1083_TypePair(MeasuredPointSe_1083_TypeChoicePair * MeasuredPointSe_1083_TypePairIn)
{MeasuredPointSe_1083_TypePair = MeasuredPointSe_1083_TypePairIn;}
MeasuredPointSe_1083_TypeChoicePair::MeasuredPointSe_1083_TypeChoicePair() {}

MeasuredPointSe_1083_TypeChoicePair::MeasuredPointSe_1083_TypeChoicePair(
 whichOne MeasuredPointSe_1083_TypeTypeIn,
 MeasuredPointSe_1083_TypeVal * MeasuredPointSe_1083_TypeValueIn)
{
  MeasuredPointSe_1083_TypeType = MeasuredPointSe_1083_TypeTypeIn;
  MeasuredPointSe_1083_TypeValue = MeasuredPointSe_1083_TypeValueIn;
}

MeasuredPointSe_1083_TypeChoicePair::~MeasuredPointSe_1083_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (MeasuredPointSe_1083_TypeType == NormalsE)
    delete MeasuredPointSe_1083_TypeValue->Normals;
  else if (MeasuredPointSe_1083_TypeType == BinaryNormalsE)
    delete MeasuredPointSe_1083_TypeValue->BinaryNormals;
  delete MeasuredPointSe_1083_TypeValue;
  #endif
}

void MeasuredPointSe_1083_TypeChoicePair::printSelf(FILE * outFile)
{
  if (MeasuredPointSe_1083_TypeType == NormalsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Normals");
      MeasuredPointSe_1083_TypeValue->Normals->printSelf(outFile);
      fprintf(outFile, "</Normals>\n");
    }
  else if (MeasuredPointSe_1083_TypeType == BinaryNormalsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BinaryNormals");
      MeasuredPointSe_1083_TypeValue->BinaryNormals->printSelf(outFile);
      fprintf(outFile, "</BinaryNormals>\n");
    }
}

/* ***************************************************************** */

/* class MeasuredPointSe_1084_Type

*/

MeasuredPointSe_1084_Type::MeasuredPointSe_1084_Type()
{
  MeasuredPointSe_1084_TypePair = 0;
}

MeasuredPointSe_1084_Type::MeasuredPointSe_1084_Type(
 MeasuredPointSe_1084_TypeChoicePair * MeasuredPointSe_1084_TypePairIn)
{
  MeasuredPointSe_1084_TypePair = MeasuredPointSe_1084_TypePairIn;
}

MeasuredPointSe_1084_Type::~MeasuredPointSe_1084_Type()
{
  #ifndef NODESTRUCT
  delete MeasuredPointSe_1084_TypePair;
  #endif
}

void MeasuredPointSe_1084_Type::printSelf(FILE * outFile)
{
  MeasuredPointSe_1084_TypePair->printSelf(outFile);
}

MeasuredPointSe_1084_TypeChoicePair * MeasuredPointSe_1084_Type::getMeasuredPointSe_1084_TypePair()
{return MeasuredPointSe_1084_TypePair;}

void MeasuredPointSe_1084_Type::setMeasuredPointSe_1084_TypePair(MeasuredPointSe_1084_TypeChoicePair * MeasuredPointSe_1084_TypePairIn)
{MeasuredPointSe_1084_TypePair = MeasuredPointSe_1084_TypePairIn;}
MeasuredPointSe_1084_TypeChoicePair::MeasuredPointSe_1084_TypeChoicePair() {}

MeasuredPointSe_1084_TypeChoicePair::MeasuredPointSe_1084_TypeChoicePair(
 whichOne MeasuredPointSe_1084_TypeTypeIn,
 MeasuredPointSe_1084_TypeVal * MeasuredPointSe_1084_TypeValueIn)
{
  MeasuredPointSe_1084_TypeType = MeasuredPointSe_1084_TypeTypeIn;
  MeasuredPointSe_1084_TypeValue = MeasuredPointSe_1084_TypeValueIn;
}

MeasuredPointSe_1084_TypeChoicePair::~MeasuredPointSe_1084_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (MeasuredPointSe_1084_TypeType == CompensatedE)
    delete MeasuredPointSe_1084_TypeValue->Compensated;
  else if (MeasuredPointSe_1084_TypeType == CompensationsE)
    delete MeasuredPointSe_1084_TypeValue->Compensations;
  else if (MeasuredPointSe_1084_TypeType == BinaryCompensatedE)
    delete MeasuredPointSe_1084_TypeValue->BinaryCompensated;
  delete MeasuredPointSe_1084_TypeValue;
  #endif
}

void MeasuredPointSe_1084_TypeChoicePair::printSelf(FILE * outFile)
{
  if (MeasuredPointSe_1084_TypeType == CompensatedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Compensated");
      MeasuredPointSe_1084_TypeValue->Compensated->printSelf(outFile);
      fprintf(outFile, "</Compensated>\n");
    }
  else if (MeasuredPointSe_1084_TypeType == CompensationsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Compensations");
      MeasuredPointSe_1084_TypeValue->Compensations->printSelf(outFile);
      fprintf(outFile, "</Compensations>\n");
    }
  else if (MeasuredPointSe_1084_TypeType == BinaryCompensatedE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BinaryCompensated");
      MeasuredPointSe_1084_TypeValue->BinaryCompensated->printSelf(outFile);
      fprintf(outFile, "</BinaryCompensated>\n");
    }
}

/* ***************************************************************** */

/* class MeasuredPointSe_1085_Type

*/

MeasuredPointSe_1085_Type::MeasuredPointSe_1085_Type()
{
  MeasuredPointSe_1085_TypePair = 0;
}

MeasuredPointSe_1085_Type::MeasuredPointSe_1085_Type(
 MeasuredPointSe_1085_TypeChoicePair * MeasuredPointSe_1085_TypePairIn)
{
  MeasuredPointSe_1085_TypePair = MeasuredPointSe_1085_TypePairIn;
}

MeasuredPointSe_1085_Type::~MeasuredPointSe_1085_Type()
{
  #ifndef NODESTRUCT
  delete MeasuredPointSe_1085_TypePair;
  #endif
}

void MeasuredPointSe_1085_Type::printSelf(FILE * outFile)
{
  if (MeasuredPointSe_1085_TypePair)
    {
      MeasuredPointSe_1085_TypePair->printSelf(outFile);
    }
}

MeasuredPointSe_1085_TypeChoicePair * MeasuredPointSe_1085_Type::getMeasuredPointSe_1085_TypePair()
{return MeasuredPointSe_1085_TypePair;}

void MeasuredPointSe_1085_Type::setMeasuredPointSe_1085_TypePair(MeasuredPointSe_1085_TypeChoicePair * MeasuredPointSe_1085_TypePairIn)
{MeasuredPointSe_1085_TypePair = MeasuredPointSe_1085_TypePairIn;}
MeasuredPointSe_1085_TypeChoicePair::MeasuredPointSe_1085_TypeChoicePair() {}

MeasuredPointSe_1085_TypeChoicePair::MeasuredPointSe_1085_TypeChoicePair(
 whichOne MeasuredPointSe_1085_TypeTypeIn,
 MeasuredPointSe_1085_TypeVal * MeasuredPointSe_1085_TypeValueIn)
{
  MeasuredPointSe_1085_TypeType = MeasuredPointSe_1085_TypeTypeIn;
  MeasuredPointSe_1085_TypeValue = MeasuredPointSe_1085_TypeValueIn;
}

MeasuredPointSe_1085_TypeChoicePair::~MeasuredPointSe_1085_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (MeasuredPointSe_1085_TypeType == ProbeRadiusE)
    delete MeasuredPointSe_1085_TypeValue->ProbeRadius;
  else if (MeasuredPointSe_1085_TypeType == ProbeRadiiE)
    delete MeasuredPointSe_1085_TypeValue->ProbeRadii;
  else if (MeasuredPointSe_1085_TypeType == BinaryProbeRadiiE)
    delete MeasuredPointSe_1085_TypeValue->BinaryProbeRadii;
  delete MeasuredPointSe_1085_TypeValue;
  #endif
}

void MeasuredPointSe_1085_TypeChoicePair::printSelf(FILE * outFile)
{
  if (MeasuredPointSe_1085_TypeType == ProbeRadiusE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProbeRadius");
      MeasuredPointSe_1085_TypeValue->ProbeRadius->printSelf(outFile);
      fprintf(outFile, "</ProbeRadius>\n");
    }
  else if (MeasuredPointSe_1085_TypeType == ProbeRadiiE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProbeRadii");
      MeasuredPointSe_1085_TypeValue->ProbeRadii->printSelf(outFile);
      fprintf(outFile, "</ProbeRadii>\n");
    }
  else if (MeasuredPointSe_1085_TypeType == BinaryProbeRadiiE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BinaryProbeRadii");
      MeasuredPointSe_1085_TypeValue->BinaryProbeRadii->printSelf(outFile);
      fprintf(outFile, "</BinaryProbeRadii>\n");
    }
}

/* ***************************************************************** */

/* class MeasuredPointSe_1086_Type

*/

MeasuredPointSe_1086_Type::MeasuredPointSe_1086_Type()
{
  MeasuredPointSe_1086_TypePair = 0;
}

MeasuredPointSe_1086_Type::MeasuredPointSe_1086_Type(
 MeasuredPointSe_1086_TypeChoicePair * MeasuredPointSe_1086_TypePairIn)
{
  MeasuredPointSe_1086_TypePair = MeasuredPointSe_1086_TypePairIn;
}

MeasuredPointSe_1086_Type::~MeasuredPointSe_1086_Type()
{
  #ifndef NODESTRUCT
  delete MeasuredPointSe_1086_TypePair;
  #endif
}

void MeasuredPointSe_1086_Type::printSelf(FILE * outFile)
{
  if (MeasuredPointSe_1086_TypePair)
    {
      MeasuredPointSe_1086_TypePair->printSelf(outFile);
    }
}

MeasuredPointSe_1086_TypeChoicePair * MeasuredPointSe_1086_Type::getMeasuredPointSe_1086_TypePair()
{return MeasuredPointSe_1086_TypePair;}

void MeasuredPointSe_1086_Type::setMeasuredPointSe_1086_TypePair(MeasuredPointSe_1086_TypeChoicePair * MeasuredPointSe_1086_TypePairIn)
{MeasuredPointSe_1086_TypePair = MeasuredPointSe_1086_TypePairIn;}
MeasuredPointSe_1086_TypeChoicePair::MeasuredPointSe_1086_TypeChoicePair() {}

MeasuredPointSe_1086_TypeChoicePair::MeasuredPointSe_1086_TypeChoicePair(
 whichOne MeasuredPointSe_1086_TypeTypeIn,
 MeasuredPointSe_1086_TypeVal * MeasuredPointSe_1086_TypeValueIn)
{
  MeasuredPointSe_1086_TypeType = MeasuredPointSe_1086_TypeTypeIn;
  MeasuredPointSe_1086_TypeValue = MeasuredPointSe_1086_TypeValueIn;
}

MeasuredPointSe_1086_TypeChoicePair::~MeasuredPointSe_1086_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (MeasuredPointSe_1086_TypeType == SensorIdE)
    delete MeasuredPointSe_1086_TypeValue->SensorId;
  else if (MeasuredPointSe_1086_TypeType == SensorIdsE)
    delete MeasuredPointSe_1086_TypeValue->SensorIds;
  else if (MeasuredPointSe_1086_TypeType == BinarySensorIdsE)
    delete MeasuredPointSe_1086_TypeValue->BinarySensorIds;
  delete MeasuredPointSe_1086_TypeValue;
  #endif
}

void MeasuredPointSe_1086_TypeChoicePair::printSelf(FILE * outFile)
{
  if (MeasuredPointSe_1086_TypeType == SensorIdE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SensorId");
      MeasuredPointSe_1086_TypeValue->SensorId->printSelf(outFile);
      fprintf(outFile, "</SensorId>\n");
    }
  else if (MeasuredPointSe_1086_TypeType == SensorIdsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SensorIds");
      MeasuredPointSe_1086_TypeValue->SensorIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SensorIds>\n");
    }
  else if (MeasuredPointSe_1086_TypeType == BinarySensorIdsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BinarySensorIds");
      MeasuredPointSe_1086_TypeValue->BinarySensorIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BinarySensorIds>\n");
    }
}

/* ***************************************************************** */

/* class MeasuredPointSe_1087_Type

*/

MeasuredPointSe_1087_Type::MeasuredPointSe_1087_Type()
{
  MeasuredPointSe_1087_TypePair = 0;
}

MeasuredPointSe_1087_Type::MeasuredPointSe_1087_Type(
 MeasuredPointSe_1087_TypeChoicePair * MeasuredPointSe_1087_TypePairIn)
{
  MeasuredPointSe_1087_TypePair = MeasuredPointSe_1087_TypePairIn;
}

MeasuredPointSe_1087_Type::~MeasuredPointSe_1087_Type()
{
  #ifndef NODESTRUCT
  delete MeasuredPointSe_1087_TypePair;
  #endif
}

void MeasuredPointSe_1087_Type::printSelf(FILE * outFile)
{
  if (MeasuredPointSe_1087_TypePair)
    {
      MeasuredPointSe_1087_TypePair->printSelf(outFile);
    }
}

MeasuredPointSe_1087_TypeChoicePair * MeasuredPointSe_1087_Type::getMeasuredPointSe_1087_TypePair()
{return MeasuredPointSe_1087_TypePair;}

void MeasuredPointSe_1087_Type::setMeasuredPointSe_1087_TypePair(MeasuredPointSe_1087_TypeChoicePair * MeasuredPointSe_1087_TypePairIn)
{MeasuredPointSe_1087_TypePair = MeasuredPointSe_1087_TypePairIn;}
MeasuredPointSe_1087_TypeChoicePair::MeasuredPointSe_1087_TypeChoicePair() {}

MeasuredPointSe_1087_TypeChoicePair::MeasuredPointSe_1087_TypeChoicePair(
 whichOne MeasuredPointSe_1087_TypeTypeIn,
 MeasuredPointSe_1087_TypeVal * MeasuredPointSe_1087_TypeValueIn)
{
  MeasuredPointSe_1087_TypeType = MeasuredPointSe_1087_TypeTypeIn;
  MeasuredPointSe_1087_TypeValue = MeasuredPointSe_1087_TypeValueIn;
}

MeasuredPointSe_1087_TypeChoicePair::~MeasuredPointSe_1087_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (MeasuredPointSe_1087_TypeType == TipIdE)
    delete MeasuredPointSe_1087_TypeValue->TipId;
  else if (MeasuredPointSe_1087_TypeType == TipIdsE)
    delete MeasuredPointSe_1087_TypeValue->TipIds;
  else if (MeasuredPointSe_1087_TypeType == BinaryTipIdsE)
    delete MeasuredPointSe_1087_TypeValue->BinaryTipIds;
  delete MeasuredPointSe_1087_TypeValue;
  #endif
}

void MeasuredPointSe_1087_TypeChoicePair::printSelf(FILE * outFile)
{
  if (MeasuredPointSe_1087_TypeType == TipIdE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TipId");
      MeasuredPointSe_1087_TypeValue->TipId->printSelf(outFile);
      fprintf(outFile, "</TipId>\n");
    }
  else if (MeasuredPointSe_1087_TypeType == TipIdsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TipIds");
      MeasuredPointSe_1087_TypeValue->TipIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</TipIds>\n");
    }
  else if (MeasuredPointSe_1087_TypeType == BinaryTipIdsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BinaryTipIds");
      MeasuredPointSe_1087_TypeValue->BinaryTipIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BinaryTipIds>\n");
    }
}

/* ***************************************************************** */

/* class MeasuredPointSe_1088_Type

*/

MeasuredPointSe_1088_Type::MeasuredPointSe_1088_Type()
{
  MeasuredPointSe_1088_TypePair = 0;
}

MeasuredPointSe_1088_Type::MeasuredPointSe_1088_Type(
 MeasuredPointSe_1088_TypeChoicePair * MeasuredPointSe_1088_TypePairIn)
{
  MeasuredPointSe_1088_TypePair = MeasuredPointSe_1088_TypePairIn;
}

MeasuredPointSe_1088_Type::~MeasuredPointSe_1088_Type()
{
  #ifndef NODESTRUCT
  delete MeasuredPointSe_1088_TypePair;
  #endif
}

void MeasuredPointSe_1088_Type::printSelf(FILE * outFile)
{
  if (MeasuredPointSe_1088_TypePair)
    {
      MeasuredPointSe_1088_TypePair->printSelf(outFile);
    }
}

MeasuredPointSe_1088_TypeChoicePair * MeasuredPointSe_1088_Type::getMeasuredPointSe_1088_TypePair()
{return MeasuredPointSe_1088_TypePair;}

void MeasuredPointSe_1088_Type::setMeasuredPointSe_1088_TypePair(MeasuredPointSe_1088_TypeChoicePair * MeasuredPointSe_1088_TypePairIn)
{MeasuredPointSe_1088_TypePair = MeasuredPointSe_1088_TypePairIn;}
MeasuredPointSe_1088_TypeChoicePair::MeasuredPointSe_1088_TypeChoicePair() {}

MeasuredPointSe_1088_TypeChoicePair::MeasuredPointSe_1088_TypeChoicePair(
 whichOne MeasuredPointSe_1088_TypeTypeIn,
 MeasuredPointSe_1088_TypeVal * MeasuredPointSe_1088_TypeValueIn)
{
  MeasuredPointSe_1088_TypeType = MeasuredPointSe_1088_TypeTypeIn;
  MeasuredPointSe_1088_TypeValue = MeasuredPointSe_1088_TypeValueIn;
}

MeasuredPointSe_1088_TypeChoicePair::~MeasuredPointSe_1088_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (MeasuredPointSe_1088_TypeType == MeasurePointNominalIdsE)
    delete MeasuredPointSe_1088_TypeValue->MeasurePointNominalIds;
  else if (MeasuredPointSe_1088_TypeType == BinaryMeasurePointNominalIdsE)
    delete MeasuredPointSe_1088_TypeValue->BinaryMeasurePointNominalIds;
  delete MeasuredPointSe_1088_TypeValue;
  #endif
}

void MeasuredPointSe_1088_TypeChoicePair::printSelf(FILE * outFile)
{
  if (MeasuredPointSe_1088_TypeType == MeasurePointNominalIdsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurePointNominalIds");
      MeasuredPointSe_1088_TypeValue->MeasurePointNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurePointNominalIds>\n");
    }
  else if (MeasuredPointSe_1088_TypeType == BinaryMeasurePointNominalIdsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BinaryMeasurePointNominalIds");
      MeasuredPointSe_1088_TypeValue->BinaryMeasurePointNominalIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BinaryMeasurePointNominalIds>\n");
    }
}

/* ***************************************************************** */

/* class MeasuredPointSe_1089_Type

*/

MeasuredPointSe_1089_Type::MeasuredPointSe_1089_Type()
{
  MeasuredPointSe_1089_TypePair = 0;
}

MeasuredPointSe_1089_Type::MeasuredPointSe_1089_Type(
 MeasuredPointSe_1089_TypeChoicePair * MeasuredPointSe_1089_TypePairIn)
{
  MeasuredPointSe_1089_TypePair = MeasuredPointSe_1089_TypePairIn;
}

MeasuredPointSe_1089_Type::~MeasuredPointSe_1089_Type()
{
  #ifndef NODESTRUCT
  delete MeasuredPointSe_1089_TypePair;
  #endif
}

void MeasuredPointSe_1089_Type::printSelf(FILE * outFile)
{
  if (MeasuredPointSe_1089_TypePair)
    {
      MeasuredPointSe_1089_TypePair->printSelf(outFile);
    }
}

MeasuredPointSe_1089_TypeChoicePair * MeasuredPointSe_1089_Type::getMeasuredPointSe_1089_TypePair()
{return MeasuredPointSe_1089_TypePair;}

void MeasuredPointSe_1089_Type::setMeasuredPointSe_1089_TypePair(MeasuredPointSe_1089_TypeChoicePair * MeasuredPointSe_1089_TypePairIn)
{MeasuredPointSe_1089_TypePair = MeasuredPointSe_1089_TypePairIn;}
MeasuredPointSe_1089_TypeChoicePair::MeasuredPointSe_1089_TypeChoicePair() {}

MeasuredPointSe_1089_TypeChoicePair::MeasuredPointSe_1089_TypeChoicePair(
 whichOne MeasuredPointSe_1089_TypeTypeIn,
 MeasuredPointSe_1089_TypeVal * MeasuredPointSe_1089_TypeValueIn)
{
  MeasuredPointSe_1089_TypeType = MeasuredPointSe_1089_TypeTypeIn;
  MeasuredPointSe_1089_TypeValue = MeasuredPointSe_1089_TypeValueIn;
}

MeasuredPointSe_1089_TypeChoicePair::~MeasuredPointSe_1089_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (MeasuredPointSe_1089_TypeType == TimeStampE)
    delete MeasuredPointSe_1089_TypeValue->TimeStamp;
  else if (MeasuredPointSe_1089_TypeType == TimeStampsE)
    delete MeasuredPointSe_1089_TypeValue->TimeStamps;
  delete MeasuredPointSe_1089_TypeValue;
  #endif
}

void MeasuredPointSe_1089_TypeChoicePair::printSelf(FILE * outFile)
{
  if (MeasuredPointSe_1089_TypeType == TimeStampE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      MeasuredPointSe_1089_TypeValue->TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  else if (MeasuredPointSe_1089_TypeType == TimeStampsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamps");
      MeasuredPointSe_1089_TypeValue->TimeStamps->printSelf(outFile);
      fprintf(outFile, "</TimeStamps>\n");
    }
}

/* ***************************************************************** */

/* class MeasuredPointSe_1090_Type

*/

MeasuredPointSe_1090_Type::MeasuredPointSe_1090_Type()
{
  MeasuredPointSe_1090_TypePair = 0;
}

MeasuredPointSe_1090_Type::MeasuredPointSe_1090_Type(
 MeasuredPointSe_1090_TypeChoicePair * MeasuredPointSe_1090_TypePairIn)
{
  MeasuredPointSe_1090_TypePair = MeasuredPointSe_1090_TypePairIn;
}

MeasuredPointSe_1090_Type::~MeasuredPointSe_1090_Type()
{
  #ifndef NODESTRUCT
  delete MeasuredPointSe_1090_TypePair;
  #endif
}

void MeasuredPointSe_1090_Type::printSelf(FILE * outFile)
{
  if (MeasuredPointSe_1090_TypePair)
    {
      MeasuredPointSe_1090_TypePair->printSelf(outFile);
    }
}

MeasuredPointSe_1090_TypeChoicePair * MeasuredPointSe_1090_Type::getMeasuredPointSe_1090_TypePair()
{return MeasuredPointSe_1090_TypePair;}

void MeasuredPointSe_1090_Type::setMeasuredPointSe_1090_TypePair(MeasuredPointSe_1090_TypeChoicePair * MeasuredPointSe_1090_TypePairIn)
{MeasuredPointSe_1090_TypePair = MeasuredPointSe_1090_TypePairIn;}
MeasuredPointSe_1090_TypeChoicePair::MeasuredPointSe_1090_TypeChoicePair() {}

MeasuredPointSe_1090_TypeChoicePair::MeasuredPointSe_1090_TypeChoicePair(
 whichOne MeasuredPointSe_1090_TypeTypeIn,
 MeasuredPointSe_1090_TypeVal * MeasuredPointSe_1090_TypeValueIn)
{
  MeasuredPointSe_1090_TypeType = MeasuredPointSe_1090_TypeTypeIn;
  MeasuredPointSe_1090_TypeValue = MeasuredPointSe_1090_TypeValueIn;
}

MeasuredPointSe_1090_TypeChoicePair::~MeasuredPointSe_1090_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (MeasuredPointSe_1090_TypeType == QualityE)
    delete MeasuredPointSe_1090_TypeValue->Quality;
  else if (MeasuredPointSe_1090_TypeType == BinaryQualityE)
    delete MeasuredPointSe_1090_TypeValue->BinaryQuality;
  delete MeasuredPointSe_1090_TypeValue;
  #endif
}

void MeasuredPointSe_1090_TypeChoicePair::printSelf(FILE * outFile)
{
  if (MeasuredPointSe_1090_TypeType == QualityE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Quality");
      MeasuredPointSe_1090_TypeValue->Quality->printSelf(outFile);
      fprintf(outFile, "</Quality>\n");
    }
  else if (MeasuredPointSe_1090_TypeType == BinaryQualityE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BinaryQuality");
      MeasuredPointSe_1090_TypeValue->BinaryQuality->printSelf(outFile);
      fprintf(outFile, "</BinaryQuality>\n");
    }
}

/* ***************************************************************** */

/* class MeasuredPointSe_1091_Type

*/

MeasuredPointSe_1091_Type::MeasuredPointSe_1091_Type()
{
  MeasuredPointSe_1091_TypePair = 0;
}

MeasuredPointSe_1091_Type::MeasuredPointSe_1091_Type(
 MeasuredPointSe_1091_TypeChoicePair * MeasuredPointSe_1091_TypePairIn)
{
  MeasuredPointSe_1091_TypePair = MeasuredPointSe_1091_TypePairIn;
}

MeasuredPointSe_1091_Type::~MeasuredPointSe_1091_Type()
{
  #ifndef NODESTRUCT
  delete MeasuredPointSe_1091_TypePair;
  #endif
}

void MeasuredPointSe_1091_Type::printSelf(FILE * outFile)
{
  if (MeasuredPointSe_1091_TypePair)
    {
      MeasuredPointSe_1091_TypePair->printSelf(outFile);
    }
}

MeasuredPointSe_1091_TypeChoicePair * MeasuredPointSe_1091_Type::getMeasuredPointSe_1091_TypePair()
{return MeasuredPointSe_1091_TypePair;}

void MeasuredPointSe_1091_Type::setMeasuredPointSe_1091_TypePair(MeasuredPointSe_1091_TypeChoicePair * MeasuredPointSe_1091_TypePairIn)
{MeasuredPointSe_1091_TypePair = MeasuredPointSe_1091_TypePairIn;}
MeasuredPointSe_1091_TypeChoicePair::MeasuredPointSe_1091_TypeChoicePair() {}

MeasuredPointSe_1091_TypeChoicePair::MeasuredPointSe_1091_TypeChoicePair(
 whichOne MeasuredPointSe_1091_TypeTypeIn,
 MeasuredPointSe_1091_TypeVal * MeasuredPointSe_1091_TypeValueIn)
{
  MeasuredPointSe_1091_TypeType = MeasuredPointSe_1091_TypeTypeIn;
  MeasuredPointSe_1091_TypeValue = MeasuredPointSe_1091_TypeValueIn;
}

MeasuredPointSe_1091_TypeChoicePair::~MeasuredPointSe_1091_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (MeasuredPointSe_1091_TypeType == DeviationsE)
    delete MeasuredPointSe_1091_TypeValue->Deviations;
  else if (MeasuredPointSe_1091_TypeType == BinaryDeviationsE)
    delete MeasuredPointSe_1091_TypeValue->BinaryDeviations;
  delete MeasuredPointSe_1091_TypeValue;
  #endif
}

void MeasuredPointSe_1091_TypeChoicePair::printSelf(FILE * outFile)
{
  if (MeasuredPointSe_1091_TypeType == DeviationsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Deviations");
      MeasuredPointSe_1091_TypeValue->Deviations->printSelf(outFile);
      fprintf(outFile, "</Deviations>\n");
    }
  else if (MeasuredPointSe_1091_TypeType == BinaryDeviationsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BinaryDeviations");
      MeasuredPointSe_1091_TypeValue->BinaryDeviations->printSelf(outFile);
      fprintf(outFile, "</BinaryDeviations>\n");
    }
}

/* ***************************************************************** */

/* class MeasuredPointSe_1092_Type

*/

MeasuredPointSe_1092_Type::MeasuredPointSe_1092_Type()
{
  MeasuredPointSe_1092_TypePair = 0;
}

MeasuredPointSe_1092_Type::MeasuredPointSe_1092_Type(
 MeasuredPointSe_1092_TypeChoicePair * MeasuredPointSe_1092_TypePairIn)
{
  MeasuredPointSe_1092_TypePair = MeasuredPointSe_1092_TypePairIn;
}

MeasuredPointSe_1092_Type::~MeasuredPointSe_1092_Type()
{
  #ifndef NODESTRUCT
  delete MeasuredPointSe_1092_TypePair;
  #endif
}

void MeasuredPointSe_1092_Type::printSelf(FILE * outFile)
{
  if (MeasuredPointSe_1092_TypePair)
    {
      MeasuredPointSe_1092_TypePair->printSelf(outFile);
    }
}

MeasuredPointSe_1092_TypeChoicePair * MeasuredPointSe_1092_Type::getMeasuredPointSe_1092_TypePair()
{return MeasuredPointSe_1092_TypePair;}

void MeasuredPointSe_1092_Type::setMeasuredPointSe_1092_TypePair(MeasuredPointSe_1092_TypeChoicePair * MeasuredPointSe_1092_TypePairIn)
{MeasuredPointSe_1092_TypePair = MeasuredPointSe_1092_TypePairIn;}
MeasuredPointSe_1092_TypeChoicePair::MeasuredPointSe_1092_TypeChoicePair() {}

MeasuredPointSe_1092_TypeChoicePair::MeasuredPointSe_1092_TypeChoicePair(
 whichOne MeasuredPointSe_1092_TypeTypeIn,
 MeasuredPointSe_1092_TypeVal * MeasuredPointSe_1092_TypeValueIn)
{
  MeasuredPointSe_1092_TypeType = MeasuredPointSe_1092_TypeTypeIn;
  MeasuredPointSe_1092_TypeValue = MeasuredPointSe_1092_TypeValueIn;
}

MeasuredPointSe_1092_TypeChoicePair::~MeasuredPointSe_1092_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (MeasuredPointSe_1092_TypeType == ColorsE)
    delete MeasuredPointSe_1092_TypeValue->Colors;
  else if (MeasuredPointSe_1092_TypeType == BinaryColorsE)
    delete MeasuredPointSe_1092_TypeValue->BinaryColors;
  delete MeasuredPointSe_1092_TypeValue;
  #endif
}

void MeasuredPointSe_1092_TypeChoicePair::printSelf(FILE * outFile)
{
  if (MeasuredPointSe_1092_TypeType == ColorsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Colors");
      MeasuredPointSe_1092_TypeValue->Colors->printSelf(outFile);
      fprintf(outFile, "</Colors>\n");
    }
  else if (MeasuredPointSe_1092_TypeType == BinaryColorsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BinaryColors");
      MeasuredPointSe_1092_TypeValue->BinaryColors->printSelf(outFile);
      fprintf(outFile, "</BinaryColors>\n");
    }
}

/* ***************************************************************** */

/* class MeasuredPointSe_1093_Type

*/

MeasuredPointSe_1093_Type::MeasuredPointSe_1093_Type()
{
  NumberOfFacets = 0;
  MeasuredPointSe_1099 = 0;
}

MeasuredPointSe_1093_Type::MeasuredPointSe_1093_Type(
 NaturalType * NumberOfFacetsIn,
 MeasuredPointSe_1099_Type * MeasuredPointSe_1099In)
{
  NumberOfFacets = NumberOfFacetsIn;
  MeasuredPointSe_1099 = MeasuredPointSe_1099In;
}

MeasuredPointSe_1093_Type::~MeasuredPointSe_1093_Type()
{
  #ifndef NODESTRUCT
  delete NumberOfFacets;
  delete MeasuredPointSe_1099;
  #endif
}

void MeasuredPointSe_1093_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<NumberOfFacets");
  NumberOfFacets->printSelf(outFile);
  fprintf(outFile, "</NumberOfFacets>\n");
  MeasuredPointSe_1099->printSelf(outFile);
}

NaturalType * MeasuredPointSe_1093_Type::getNumberOfFacets()
{return NumberOfFacets;}

void MeasuredPointSe_1093_Type::setNumberOfFacets(NaturalType * NumberOfFacetsIn)
{NumberOfFacets = NumberOfFacetsIn;}

MeasuredPointSe_1099_Type * MeasuredPointSe_1093_Type::getMeasuredPointSe_1099()
{return MeasuredPointSe_1099;}

void MeasuredPointSe_1093_Type::setMeasuredPointSe_1099(MeasuredPointSe_1099_Type * MeasuredPointSe_1099In)
{MeasuredPointSe_1099 = MeasuredPointSe_1099In;}

/* ***************************************************************** */

/* class OppositeAngledP_1094_Type

*/

OppositeAngledP_1094_Type::OppositeAngledP_1094_Type()
{
  OppositeAngledP_1094_TypePair = 0;
}

OppositeAngledP_1094_Type::OppositeAngledP_1094_Type(
 OppositeAngledP_1094_TypeChoicePair * OppositeAngledP_1094_TypePairIn)
{
  OppositeAngledP_1094_TypePair = OppositeAngledP_1094_TypePairIn;
}

OppositeAngledP_1094_Type::~OppositeAngledP_1094_Type()
{
  #ifndef NODESTRUCT
  delete OppositeAngledP_1094_TypePair;
  #endif
}

void OppositeAngledP_1094_Type::printSelf(FILE * outFile)
{
  OppositeAngledP_1094_TypePair->printSelf(outFile);
}

OppositeAngledP_1094_TypeChoicePair * OppositeAngledP_1094_Type::getOppositeAngledP_1094_TypePair()
{return OppositeAngledP_1094_TypePair;}

void OppositeAngledP_1094_Type::setOppositeAngledP_1094_TypePair(OppositeAngledP_1094_TypeChoicePair * OppositeAngledP_1094_TypePairIn)
{OppositeAngledP_1094_TypePair = OppositeAngledP_1094_TypePairIn;}
OppositeAngledP_1094_TypeChoicePair::OppositeAngledP_1094_TypeChoicePair() {}

OppositeAngledP_1094_TypeChoicePair::OppositeAngledP_1094_TypeChoicePair(
 whichOne OppositeAngledP_1094_TypeTypeIn,
 OppositeAngledP_1094_TypeVal * OppositeAngledP_1094_TypeValueIn)
{
  OppositeAngledP_1094_TypeType = OppositeAngledP_1094_TypeTypeIn;
  OppositeAngledP_1094_TypeValue = OppositeAngledP_1094_TypeValueIn;
}

OppositeAngledP_1094_TypeChoicePair::~OppositeAngledP_1094_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (OppositeAngledP_1094_TypeType == TaperAngleE)
    delete OppositeAngledP_1094_TypeValue->TaperAngle;
  else if (OppositeAngledP_1094_TypeType == DraftAngleE)
    delete OppositeAngledP_1094_TypeValue->DraftAngle;
  delete OppositeAngledP_1094_TypeValue;
  #endif
}

void OppositeAngledP_1094_TypeChoicePair::printSelf(FILE * outFile)
{
  if (OppositeAngledP_1094_TypeType == TaperAngleE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TaperAngle");
      OppositeAngledP_1094_TypeValue->TaperAngle->printSelf(outFile);
      fprintf(outFile, "</TaperAngle>\n");
    }
  else if (OppositeAngledP_1094_TypeType == DraftAngleE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DraftAngle");
      OppositeAngledP_1094_TypeValue->DraftAngle->printSelf(outFile);
      fprintf(outFile, "</DraftAngle>\n");
    }
}

/* ***************************************************************** */

/* class OppositeAngledP_1095_Type

*/

OppositeAngledP_1095_Type::OppositeAngledP_1095_Type()
{
  OppositeAngledP_1095_TypePair = 0;
}

OppositeAngledP_1095_Type::OppositeAngledP_1095_Type(
 OppositeAngledP_1095_TypeChoicePair * OppositeAngledP_1095_TypePairIn)
{
  OppositeAngledP_1095_TypePair = OppositeAngledP_1095_TypePairIn;
}

OppositeAngledP_1095_Type::~OppositeAngledP_1095_Type()
{
  #ifndef NODESTRUCT
  delete OppositeAngledP_1095_TypePair;
  #endif
}

void OppositeAngledP_1095_Type::printSelf(FILE * outFile)
{
  if (OppositeAngledP_1095_TypePair)
    {
      OppositeAngledP_1095_TypePair->printSelf(outFile);
    }
}

OppositeAngledP_1095_TypeChoicePair * OppositeAngledP_1095_Type::getOppositeAngledP_1095_TypePair()
{return OppositeAngledP_1095_TypePair;}

void OppositeAngledP_1095_Type::setOppositeAngledP_1095_TypePair(OppositeAngledP_1095_TypeChoicePair * OppositeAngledP_1095_TypePairIn)
{OppositeAngledP_1095_TypePair = OppositeAngledP_1095_TypePairIn;}
OppositeAngledP_1095_TypeChoicePair::OppositeAngledP_1095_TypeChoicePair() {}

OppositeAngledP_1095_TypeChoicePair::OppositeAngledP_1095_TypeChoicePair(
 whichOne OppositeAngledP_1095_TypeTypeIn,
 OppositeAngledP_1095_TypeVal * OppositeAngledP_1095_TypeValueIn)
{
  OppositeAngledP_1095_TypeType = OppositeAngledP_1095_TypeTypeIn;
  OppositeAngledP_1095_TypeValue = OppositeAngledP_1095_TypeValueIn;
}

OppositeAngledP_1095_TypeChoicePair::~OppositeAngledP_1095_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (OppositeAngledP_1095_TypeType == TaperAngleE)
    delete OppositeAngledP_1095_TypeValue->TaperAngle;
  else if (OppositeAngledP_1095_TypeType == DraftAngleE)
    delete OppositeAngledP_1095_TypeValue->DraftAngle;
  delete OppositeAngledP_1095_TypeValue;
  #endif
}

void OppositeAngledP_1095_TypeChoicePair::printSelf(FILE * outFile)
{
  if (OppositeAngledP_1095_TypeType == TaperAngleE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TaperAngle");
      OppositeAngledP_1095_TypeValue->TaperAngle->printSelf(outFile);
      fprintf(outFile, "</TaperAngle>\n");
    }
  else if (OppositeAngledP_1095_TypeType == DraftAngleE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DraftAngle");
      OppositeAngledP_1095_TypeValue->DraftAngle->printSelf(outFile);
      fprintf(outFile, "</DraftAngle>\n");
    }
}

/* ***************************************************************** */

/* class PlaneFeatureNom_1096_Type

*/

PlaneFeatureNom_1096_Type::PlaneFeatureNom_1096_Type()
{
  PlaneFeatureNom_1096_TypePair = 0;
}

PlaneFeatureNom_1096_Type::PlaneFeatureNom_1096_Type(
 PlaneFeatureNom_1096_TypeChoicePair * PlaneFeatureNom_1096_TypePairIn)
{
  PlaneFeatureNom_1096_TypePair = PlaneFeatureNom_1096_TypePairIn;
}

PlaneFeatureNom_1096_Type::~PlaneFeatureNom_1096_Type()
{
  #ifndef NODESTRUCT
  delete PlaneFeatureNom_1096_TypePair;
  #endif
}

void PlaneFeatureNom_1096_Type::printSelf(FILE * outFile)
{
  if (PlaneFeatureNom_1096_TypePair)
    {
      PlaneFeatureNom_1096_TypePair->printSelf(outFile);
    }
}

PlaneFeatureNom_1096_TypeChoicePair * PlaneFeatureNom_1096_Type::getPlaneFeatureNom_1096_TypePair()
{return PlaneFeatureNom_1096_TypePair;}

void PlaneFeatureNom_1096_Type::setPlaneFeatureNom_1096_TypePair(PlaneFeatureNom_1096_TypeChoicePair * PlaneFeatureNom_1096_TypePairIn)
{PlaneFeatureNom_1096_TypePair = PlaneFeatureNom_1096_TypePairIn;}
PlaneFeatureNom_1096_TypeChoicePair::PlaneFeatureNom_1096_TypeChoicePair() {}

PlaneFeatureNom_1096_TypeChoicePair::PlaneFeatureNom_1096_TypeChoicePair(
 whichOne PlaneFeatureNom_1096_TypeTypeIn,
 PlaneFeatureNom_1096_TypeVal * PlaneFeatureNom_1096_TypeValueIn)
{
  PlaneFeatureNom_1096_TypeType = PlaneFeatureNom_1096_TypeTypeIn;
  PlaneFeatureNom_1096_TypeValue = PlaneFeatureNom_1096_TypeValueIn;
}

PlaneFeatureNom_1096_TypeChoicePair::~PlaneFeatureNom_1096_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (PlaneFeatureNom_1096_TypeType == PolyLineE)
    delete PlaneFeatureNom_1096_TypeValue->PolyLine;
  else if (PlaneFeatureNom_1096_TypeType == RectangleE)
    delete PlaneFeatureNom_1096_TypeValue->Rectangle;
  else if (PlaneFeatureNom_1096_TypeType == CircleE)
    delete PlaneFeatureNom_1096_TypeValue->Circle;
  delete PlaneFeatureNom_1096_TypeValue;
  #endif
}

void PlaneFeatureNom_1096_TypeChoicePair::printSelf(FILE * outFile)
{
  if (PlaneFeatureNom_1096_TypeType == PolyLineE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PolyLine");
      PlaneFeatureNom_1096_TypeValue->PolyLine->printSelf(outFile);
      fprintf(outFile, "</PolyLine>\n");
    }
  else if (PlaneFeatureNom_1096_TypeType == RectangleE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Rectangle");
      PlaneFeatureNom_1096_TypeValue->Rectangle->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Rectangle>\n");
    }
  else if (PlaneFeatureNom_1096_TypeType == CircleE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Circle");
      PlaneFeatureNom_1096_TypeValue->Circle->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Circle>\n");
    }
}

/* ***************************************************************** */

/* class PointFeatureExt_1097_Type

*/

PointFeatureExt_1097_Type::PointFeatureExt_1097_Type()
{
  PointFeatureExt_1097_TypePair = 0;
}

PointFeatureExt_1097_Type::PointFeatureExt_1097_Type(
 PointFeatureExt_1097_TypeChoicePair * PointFeatureExt_1097_TypePairIn)
{
  PointFeatureExt_1097_TypePair = PointFeatureExt_1097_TypePairIn;
}

PointFeatureExt_1097_Type::~PointFeatureExt_1097_Type()
{
  #ifndef NODESTRUCT
  delete PointFeatureExt_1097_TypePair;
  #endif
}

void PointFeatureExt_1097_Type::printSelf(FILE * outFile)
{
  PointFeatureExt_1097_TypePair->printSelf(outFile);
}

PointFeatureExt_1097_TypeChoicePair * PointFeatureExt_1097_Type::getPointFeatureExt_1097_TypePair()
{return PointFeatureExt_1097_TypePair;}

void PointFeatureExt_1097_Type::setPointFeatureExt_1097_TypePair(PointFeatureExt_1097_TypeChoicePair * PointFeatureExt_1097_TypePairIn)
{PointFeatureExt_1097_TypePair = PointFeatureExt_1097_TypePairIn;}
PointFeatureExt_1097_TypeChoicePair::PointFeatureExt_1097_TypeChoicePair() {}

PointFeatureExt_1097_TypeChoicePair::PointFeatureExt_1097_TypeChoicePair(
 whichOne PointFeatureExt_1097_TypeTypeIn,
 PointFeatureExt_1097_TypeVal * PointFeatureExt_1097_TypeValueIn)
{
  PointFeatureExt_1097_TypeType = PointFeatureExt_1097_TypeTypeIn;
  PointFeatureExt_1097_TypeValue = PointFeatureExt_1097_TypeValueIn;
}

PointFeatureExt_1097_TypeChoicePair::~PointFeatureExt_1097_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (PointFeatureExt_1097_TypeType == BaseAxisFeatureE)
    delete PointFeatureExt_1097_TypeValue->BaseAxisFeature;
  else if (PointFeatureExt_1097_TypeType == VectorE)
    delete PointFeatureExt_1097_TypeValue->Vector;
  else if (PointFeatureExt_1097_TypeType == RadialE)
    delete PointFeatureExt_1097_TypeValue->Radial;
  else if (PointFeatureExt_1097_TypeType == XaxisE)
    delete PointFeatureExt_1097_TypeValue->Xaxis;
  else if (PointFeatureExt_1097_TypeType == YaxisE)
    delete PointFeatureExt_1097_TypeValue->Yaxis;
  else if (PointFeatureExt_1097_TypeType == ZaxisE)
    delete PointFeatureExt_1097_TypeValue->Zaxis;
  delete PointFeatureExt_1097_TypeValue;
  #endif
}

void PointFeatureExt_1097_TypeChoicePair::printSelf(FILE * outFile)
{
  if (PointFeatureExt_1097_TypeType == BaseAxisFeatureE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BaseAxisFeature");
      PointFeatureExt_1097_TypeValue->BaseAxisFeature->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BaseAxisFeature>\n");
    }
  else if (PointFeatureExt_1097_TypeType == VectorE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Vector");
      PointFeatureExt_1097_TypeValue->Vector->printSelf(outFile);
      fprintf(outFile, "</Vector>\n");
    }
  else if (PointFeatureExt_1097_TypeType == RadialE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Radial");
      PointFeatureExt_1097_TypeValue->Radial->printSelf(outFile);
      fprintf(outFile, "</Radial>\n");
    }
  else if (PointFeatureExt_1097_TypeType == XaxisE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Xaxis");
      PointFeatureExt_1097_TypeValue->Xaxis->printSelf(outFile);
      fprintf(outFile, "</Xaxis>\n");
    }
  else if (PointFeatureExt_1097_TypeType == YaxisE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Yaxis");
      PointFeatureExt_1097_TypeValue->Yaxis->printSelf(outFile);
      fprintf(outFile, "</Yaxis>\n");
    }
  else if (PointFeatureExt_1097_TypeType == ZaxisE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Zaxis");
      PointFeatureExt_1097_TypeValue->Zaxis->printSelf(outFile);
      fprintf(outFile, "</Zaxis>\n");
    }
}

/* ***************************************************************** */

/* class PointFeatureMov_1098_Type

*/

PointFeatureMov_1098_Type::PointFeatureMov_1098_Type()
{
  PointFeatureMov_1098_TypePair = 0;
}

PointFeatureMov_1098_Type::PointFeatureMov_1098_Type(
 PointFeatureMov_1098_TypeChoicePair * PointFeatureMov_1098_TypePairIn)
{
  PointFeatureMov_1098_TypePair = PointFeatureMov_1098_TypePairIn;
}

PointFeatureMov_1098_Type::~PointFeatureMov_1098_Type()
{
  #ifndef NODESTRUCT
  delete PointFeatureMov_1098_TypePair;
  #endif
}

void PointFeatureMov_1098_Type::printSelf(FILE * outFile)
{
  PointFeatureMov_1098_TypePair->printSelf(outFile);
}

PointFeatureMov_1098_TypeChoicePair * PointFeatureMov_1098_Type::getPointFeatureMov_1098_TypePair()
{return PointFeatureMov_1098_TypePair;}

void PointFeatureMov_1098_Type::setPointFeatureMov_1098_TypePair(PointFeatureMov_1098_TypeChoicePair * PointFeatureMov_1098_TypePairIn)
{PointFeatureMov_1098_TypePair = PointFeatureMov_1098_TypePairIn;}
PointFeatureMov_1098_TypeChoicePair::PointFeatureMov_1098_TypeChoicePair() {}

PointFeatureMov_1098_TypeChoicePair::PointFeatureMov_1098_TypeChoicePair(
 whichOne PointFeatureMov_1098_TypeTypeIn,
 PointFeatureMov_1098_TypeVal * PointFeatureMov_1098_TypeValueIn)
{
  PointFeatureMov_1098_TypeType = PointFeatureMov_1098_TypeTypeIn;
  PointFeatureMov_1098_TypeValue = PointFeatureMov_1098_TypeValueIn;
}

PointFeatureMov_1098_TypeChoicePair::~PointFeatureMov_1098_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (PointFeatureMov_1098_TypeType == OffsetE)
    delete PointFeatureMov_1098_TypeValue->Offset;
  else if (PointFeatureMov_1098_TypeType == DirectionalOffsetE)
    delete PointFeatureMov_1098_TypeValue->DirectionalOffset;
  delete PointFeatureMov_1098_TypeValue;
  #endif
}

void PointFeatureMov_1098_TypeChoicePair::printSelf(FILE * outFile)
{
  if (PointFeatureMov_1098_TypeType == OffsetE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Offset");
      PointFeatureMov_1098_TypeValue->Offset->printSelf(outFile);
      fprintf(outFile, "</Offset>\n");
    }
  else if (PointFeatureMov_1098_TypeType == DirectionalOffsetE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DirectionalOffset");
      PointFeatureMov_1098_TypeValue->DirectionalOffset->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DirectionalOffset>\n");
    }
}

/* ***************************************************************** */

/* class MeasuredPointSe_1099_Type

*/

MeasuredPointSe_1099_Type::MeasuredPointSe_1099_Type()
{
  MeasuredPointSe_1099_TypePair = 0;
}

MeasuredPointSe_1099_Type::MeasuredPointSe_1099_Type(
 MeasuredPointSe_1099_TypeChoicePair * MeasuredPointSe_1099_TypePairIn)
{
  MeasuredPointSe_1099_TypePair = MeasuredPointSe_1099_TypePairIn;
}

MeasuredPointSe_1099_Type::~MeasuredPointSe_1099_Type()
{
  #ifndef NODESTRUCT
  delete MeasuredPointSe_1099_TypePair;
  #endif
}

void MeasuredPointSe_1099_Type::printSelf(FILE * outFile)
{
  MeasuredPointSe_1099_TypePair->printSelf(outFile);
}

MeasuredPointSe_1099_TypeChoicePair * MeasuredPointSe_1099_Type::getMeasuredPointSe_1099_TypePair()
{return MeasuredPointSe_1099_TypePair;}

void MeasuredPointSe_1099_Type::setMeasuredPointSe_1099_TypePair(MeasuredPointSe_1099_TypeChoicePair * MeasuredPointSe_1099_TypePairIn)
{MeasuredPointSe_1099_TypePair = MeasuredPointSe_1099_TypePairIn;}
MeasuredPointSe_1099_TypeChoicePair::MeasuredPointSe_1099_TypeChoicePair() {}

MeasuredPointSe_1099_TypeChoicePair::MeasuredPointSe_1099_TypeChoicePair(
 whichOne MeasuredPointSe_1099_TypeTypeIn,
 MeasuredPointSe_1099_TypeVal * MeasuredPointSe_1099_TypeValueIn)
{
  MeasuredPointSe_1099_TypeType = MeasuredPointSe_1099_TypeTypeIn;
  MeasuredPointSe_1099_TypeValue = MeasuredPointSe_1099_TypeValueIn;
}

MeasuredPointSe_1099_TypeChoicePair::~MeasuredPointSe_1099_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (MeasuredPointSe_1099_TypeType == PointIndicesE)
    delete MeasuredPointSe_1099_TypeValue->PointIndices;
  else if (MeasuredPointSe_1099_TypeType == BinaryPointIndicesE)
    delete MeasuredPointSe_1099_TypeValue->BinaryPointIndices;
  delete MeasuredPointSe_1099_TypeValue;
  #endif
}

void MeasuredPointSe_1099_TypeChoicePair::printSelf(FILE * outFile)
{
  if (MeasuredPointSe_1099_TypeType == PointIndicesE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointIndices");
      MeasuredPointSe_1099_TypeValue->PointIndices->printSelf(outFile);
      fprintf(outFile, "</PointIndices>\n");
    }
  else if (MeasuredPointSe_1099_TypeType == BinaryPointIndicesE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BinaryPointIndices");
      MeasuredPointSe_1099_TypeValue->BinaryPointIndices->printSelf(outFile);
      fprintf(outFile, "</BinaryPointIndices>\n");
    }
}

/* ***************************************************************** */

