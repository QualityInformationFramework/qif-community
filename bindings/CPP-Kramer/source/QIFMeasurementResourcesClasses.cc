/* ***************************************************************** */

#include <stdio.h>             // for printf, etc.
#include <string.h>            // for strdup
#include <stdlib.h>            // for exit
#include <list>
#include  <map>
#include <xmlSchemaInstance.hh>
#include "QIFMeasurementResourcesClasses.hh"

#define INDENT 2
extern std::map<unsigned int, XmlSchemaInstanceBase *> idMap;

/* ***************************************************************** */
/* ***************************************************************** */

/* class AACMMAccuraciesType

*/

AACMMAccuraciesType::AACMMAccuraciesType()
{
  n = 0;
  AACMMAccuracy = 0;
}

AACMMAccuraciesType::AACMMAccuraciesType(
 AACMMAccuracyTypeLisd * AACMMAccuracyIn)
{
  n = 0;
  AACMMAccuracy = AACMMAccuracyIn;
}

AACMMAccuraciesType::AACMMAccuraciesType(
 NaturalType * nIn,
 AACMMAccuracyTypeLisd * AACMMAccuracyIn)
{
  n = nIn;
  AACMMAccuracy = AACMMAccuracyIn;
}

AACMMAccuraciesType::~AACMMAccuraciesType()
{
  #ifndef NODESTRUCT
  delete n;
  delete AACMMAccuracy;
  #endif
}

void AACMMAccuraciesType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!AACMMAccuracy)
      {
        fprintf(stderr, "AACMMAccuracy list is missing\n");
        exit(1);
      }
    if (AACMMAccuracy->size() == 0)
      {
        fprintf(stderr, "AACMMAccuracy list is empty\n");
        exit(1);
      }
    if (AACMMAccuracy->size() < 1)
      {
        fprintf(stderr,
                "size of AACMMAccuracy list (%d) less than minimum required (1)\n",
                (int)AACMMAccuracy->size());
        exit(1);
      }
    std::list<AACMMAccuracyType *>::iterator iter;
    for (iter = AACMMAccuracy->begin();
         iter != AACMMAccuracy->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<AACMMAccuracy");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</AACMMAccuracy>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool AACMMAccuraciesType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in AACMMAccuraciesType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in AACMMAccuraciesType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in AACMMAccuraciesType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in AACMMAccuraciesType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * AACMMAccuraciesType::getn()
{return n;}

void AACMMAccuraciesType::setn(NaturalType * nIn)
{n = nIn;}

AACMMAccuracyTypeLisd * AACMMAccuraciesType::getAACMMAccuracy()
{return AACMMAccuracy;}

void AACMMAccuraciesType::setAACMMAccuracy(AACMMAccuracyTypeLisd * AACMMAccuracyIn)
{AACMMAccuracy = AACMMAccuracyIn;}

/* ***************************************************************** */

/* class AACMMAccuracyType

*/

AACMMAccuracyType::AACMMAccuracyType() :
  MeasurementDeviceAccuracyBaseType()
{
  AACMMAccuracyTest = 0;
  AccuracySource = 0;
}

AACMMAccuracyType::AACMMAccuracyType(
 EnvironmentalRangeType * EnvironmentalRangeIn,
 CMMAccuracyTestBaseType * AACMMAccuracyTestIn,
 AccuracySourceType * AccuracySourceIn) :
  MeasurementDeviceAccuracyBaseType(
    EnvironmentalRangeIn)
{
  AACMMAccuracyTest = AACMMAccuracyTestIn;
  AccuracySource = AccuracySourceIn;
}

AACMMAccuracyType::~AACMMAccuracyType()
{
  #ifndef NODESTRUCT
  delete AACMMAccuracyTest;
  delete AccuracySource;
  #endif
}

void AACMMAccuracyType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<EnvironmentalRange");
  EnvironmentalRange->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</EnvironmentalRange>\n");
  {
    doSpaces(0, outFile);
    if (AACMMAccuracyTest->getprintElement() == 0)
      {
        fprintf(stderr, "element name missing\n");
        exit(1);
      }
    else if (strcmp(AACMMAccuracyTest->getprintElement(), "AACMMB89Test") == 0)
      {
        AACMMB89TestType * typ;
        if ((typ = dynamic_cast<AACMMB89TestType *>(AACMMAccuracyTest)))
          {
            fprintf(outFile, "<AACMMB89Test");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</AACMMB89Test>\n");
          }
        else
          {
            fprintf(stderr, "bad AACMMB89Test element\n");
            exit(1);
          }
      }
    else if (strcmp(AACMMAccuracyTest->getprintElement(), "AACMMISO10360Test") == 0)
      {
        ISO10360TestType * typ;
        if ((typ = dynamic_cast<ISO10360TestType *>(AACMMAccuracyTest)))
          {
            fprintf(outFile, "<AACMMISO10360Test");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</AACMMISO10360Test>\n");
          }
        else
          {
            fprintf(stderr, "bad AACMMISO10360Test element\n");
            exit(1);
          }
      }
    else if (strcmp(AACMMAccuracyTest->getprintElement(), "AACMMPointAccuracyTest") == 0)
      {
        PointAccuracyTestType * typ;
        if ((typ = dynamic_cast<PointAccuracyTestType *>(AACMMAccuracyTest)))
          {
            fprintf(outFile, "<AACMMPointAccuracyTest");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</AACMMPointAccuracyTest>\n");
          }
        else
          {
            fprintf(stderr, "bad AACMMPointAccuracyTest element\n");
            exit(1);
          }
      }
    else
      {
        fprintf(stderr, "bad AACMMAccuracyTest type\n");
        fprintf(stderr, " exiting\n");
        exit(1);
      }
  }
  doSpaces(0, outFile);
  fprintf(outFile, "<AccuracySource");
  AccuracySource->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</AccuracySource>\n");
  doSpaces(-INDENT, outFile);
}

CMMAccuracyTestBaseType * AACMMAccuracyType::getAACMMAccuracyTest()
{return AACMMAccuracyTest;}

void AACMMAccuracyType::setAACMMAccuracyTest(CMMAccuracyTestBaseType * AACMMAccuracyTestIn)
{AACMMAccuracyTest = AACMMAccuracyTestIn;}

AccuracySourceType * AACMMAccuracyType::getAccuracySource()
{return AccuracySource;}

void AACMMAccuracyType::setAccuracySource(AccuracySourceType * AccuracySourceIn)
{AccuracySource = AccuracySourceIn;}

/* ***************************************************************** */

/* class AACMMAccuracyTypeLisd

*/

AACMMAccuracyTypeLisd::AACMMAccuracyTypeLisd() {}

AACMMAccuracyTypeLisd::AACMMAccuracyTypeLisd(AACMMAccuracyType * aAACMMAccuracyType)
{
  push_back(aAACMMAccuracyType);
}

AACMMAccuracyTypeLisd::~AACMMAccuracyTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<AACMMAccuracyType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void AACMMAccuracyTypeLisd::printSelf(FILE * outFile)
{
  std::list<AACMMAccuracyType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class AACMMB89TestType

*/

AACMMB89TestType::AACMMB89TestType() :
  CMMAccuracyTestBaseType()
{
  EffectiveDiameterPerformanceTest = 0;
  SinglePointArticulationPerformanceTest = 0;
  VolumetricPerformanceTest = 0;
}

AACMMB89TestType::AACMMB89TestType(
 EffectiveDiameterPerformanceTestType * EffectiveDiameterPerformanceTestIn,
 SinglePointArticulationPerformanceTestType * SinglePointArticulationPerformanceTestIn,
 VolumetricPerformanceTestType * VolumetricPerformanceTestIn) :
  CMMAccuracyTestBaseType()
{
  EffectiveDiameterPerformanceTest = EffectiveDiameterPerformanceTestIn;
  SinglePointArticulationPerformanceTest = SinglePointArticulationPerformanceTestIn;
  VolumetricPerformanceTest = VolumetricPerformanceTestIn;
}

AACMMB89TestType::~AACMMB89TestType()
{
  #ifndef NODESTRUCT
  delete EffectiveDiameterPerformanceTest;
  delete SinglePointArticulationPerformanceTest;
  delete VolumetricPerformanceTest;
  #endif
}

void AACMMB89TestType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (EffectiveDiameterPerformanceTest)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EffectiveDiameterPerformanceTest");
      EffectiveDiameterPerformanceTest->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EffectiveDiameterPerformanceTest>\n");
    }
  if (SinglePointArticulationPerformanceTest)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SinglePointArticulationPerformanceTest");
      SinglePointArticulationPerformanceTest->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SinglePointArticulationPerformanceTest>\n");
    }
  if (VolumetricPerformanceTest)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VolumetricPerformanceTest");
      VolumetricPerformanceTest->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</VolumetricPerformanceTest>\n");
    }
  doSpaces(-INDENT, outFile);
}

EffectiveDiameterPerformanceTestType * AACMMB89TestType::getEffectiveDiameterPerformanceTest()
{return EffectiveDiameterPerformanceTest;}

void AACMMB89TestType::setEffectiveDiameterPerformanceTest(EffectiveDiameterPerformanceTestType * EffectiveDiameterPerformanceTestIn)
{EffectiveDiameterPerformanceTest = EffectiveDiameterPerformanceTestIn;}

SinglePointArticulationPerformanceTestType * AACMMB89TestType::getSinglePointArticulationPerformanceTest()
{return SinglePointArticulationPerformanceTest;}

void AACMMB89TestType::setSinglePointArticulationPerformanceTest(SinglePointArticulationPerformanceTestType * SinglePointArticulationPerformanceTestIn)
{SinglePointArticulationPerformanceTest = SinglePointArticulationPerformanceTestIn;}

VolumetricPerformanceTestType * AACMMB89TestType::getVolumetricPerformanceTest()
{return VolumetricPerformanceTest;}

void AACMMB89TestType::setVolumetricPerformanceTest(VolumetricPerformanceTestType * VolumetricPerformanceTestIn)
{VolumetricPerformanceTest = VolumetricPerformanceTestIn;}

/* ***************************************************************** */

/* class AACMMType

*/

AACMMType::AACMMType() :
  CMMType()
{
  HomeLocation = 0;
  NumberOfJoints = 0;
  MinMeasuringDistance = 0;
  MaxMeasuringDistance = 0;
  ProbeTipDiameter = 0;
  Accuracies = 0;
}

AACMMType::AACMMType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 ResolutionBaseType * ResolutionIn,
 WorkingVolumeBaseType * WorkingVolumeIn,
 EffectiveWorkingVolumeBaseType * EffectiveWorkingVolumeIn,
 TemperatureCompensationType * TemperatureCompensationIn,
 PointType * HomeLocationIn,
 XmlInt * NumberOfJointsIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 LinearValueType * ProbeTipDiameterIn,
 AACMMAccuraciesType * AccuraciesIn) :
  CMMType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    ResolutionIn,
    WorkingVolumeIn,
    EffectiveWorkingVolumeIn,
    TemperatureCompensationIn)
{
  HomeLocation = HomeLocationIn;
  NumberOfJoints = NumberOfJointsIn;
  MinMeasuringDistance = MinMeasuringDistanceIn;
  MaxMeasuringDistance = MaxMeasuringDistanceIn;
  ProbeTipDiameter = ProbeTipDiameterIn;
  Accuracies = AccuraciesIn;
}

AACMMType::AACMMType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 ResolutionBaseType * ResolutionIn,
 WorkingVolumeBaseType * WorkingVolumeIn,
 EffectiveWorkingVolumeBaseType * EffectiveWorkingVolumeIn,
 TemperatureCompensationType * TemperatureCompensationIn,
 PointType * HomeLocationIn,
 XmlInt * NumberOfJointsIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 LinearValueType * ProbeTipDiameterIn,
 AACMMAccuraciesType * AccuraciesIn) :
  CMMType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    ResolutionIn,
    WorkingVolumeIn,
    EffectiveWorkingVolumeIn,
    TemperatureCompensationIn)
{
  HomeLocation = HomeLocationIn;
  NumberOfJoints = NumberOfJointsIn;
  MinMeasuringDistance = MinMeasuringDistanceIn;
  MaxMeasuringDistance = MaxMeasuringDistanceIn;
  ProbeTipDiameter = ProbeTipDiameterIn;
  Accuracies = AccuraciesIn;
}

AACMMType::~AACMMType()
{
  #ifndef NODESTRUCT
  delete HomeLocation;
  delete NumberOfJoints;
  delete MinMeasuringDistance;
  delete MaxMeasuringDistance;
  delete ProbeTipDiameter;
  delete Accuracies;
  #endif
}

void AACMMType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Calibrations)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Calibrations");
      Calibrations->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Calibrations>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (Resolution)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (Resolution->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(Resolution->getprintElement(), "LinearResolution") == 0)
          {
            LinearResolutionType * typ;
            if ((typ = dynamic_cast<LinearResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<LinearResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LinearResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad LinearResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "CartesianResolution") == 0)
          {
            CartesianResolutionType * typ;
            if ((typ = dynamic_cast<CartesianResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<CartesianResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "SphericalResolution") == 0)
          {
            SphericalResolutionType * typ;
            if ((typ = dynamic_cast<SphericalResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<SphericalResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "UserDefinedResolution") == 0)
          {
            UserDefinedResolutionType * typ;
            if ((typ = dynamic_cast<UserDefinedResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<UserDefinedResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedResolution element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad Resolution type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (WorkingVolume)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (WorkingVolume->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(WorkingVolume->getprintElement(), "ClosedShellSetWorkingVolume") == 0)
          {
            ClosedShellSetWorkingVolumeType * typ;
            if ((typ = dynamic_cast<ClosedShellSetWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<ClosedShellSetWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ClosedShellSetWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad ClosedShellSetWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "CartesianWorkingVolume") == 0)
          {
            CartesianWorkingVolumeType * typ;
            if ((typ = dynamic_cast<CartesianWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<CartesianWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "SphericalWorkingVolume") == 0)
          {
            SphericalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<SphericalWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<SphericalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "CylindricalWorkingVolume") == 0)
          {
            CylindricalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<CylindricalWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<CylindricalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CylindricalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad CylindricalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "UserDefinedWorkingVolume") == 0)
          {
            UserDefinedWorkingVolumeType * typ;
            if ((typ = dynamic_cast<UserDefinedWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<UserDefinedWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedWorkingVolume element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad WorkingVolume type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (EffectiveWorkingVolume)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (EffectiveWorkingVolume->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveClosedShellSetWorkingVolume") == 0)
          {
            EffectiveClosedShellSetWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveClosedShellSetWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveClosedShellSetWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveClosedShellSetWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveClosedShellSetWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveCartesianWorkingVolume") == 0)
          {
            EffectiveCartesianWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveCartesianWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveCartesianWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveCartesianWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveCartesianWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveSphericalWorkingVolume") == 0)
          {
            EffectiveSphericalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveSphericalWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveSphericalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveSphericalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveSphericalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveCylindricalWorkingVolume") == 0)
          {
            EffectiveCylindricalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveCylindricalWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveCylindricalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveCylindricalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveCylindricalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveUserDefinedWorkingVolume") == 0)
          {
            EffectiveUserDefinedWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveUserDefinedWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveUserDefinedWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveUserDefinedWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveUserDefinedWorkingVolume element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad EffectiveWorkingVolume type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (TemperatureCompensation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TemperatureCompensation");
      TemperatureCompensation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</TemperatureCompensation>\n");
    }
  if (HomeLocation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<HomeLocation");
      HomeLocation->printSelf(outFile);
      fprintf(outFile, "</HomeLocation>\n");
    }
  if (NumberOfJoints)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NumberOfJoints");
      NumberOfJoints->printSelf(outFile);
      fprintf(outFile, "</NumberOfJoints>\n");
    }
  if (MinMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinMeasuringDistance");
      MinMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MinMeasuringDistance>\n");
    }
  if (MaxMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxMeasuringDistance");
      MaxMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MaxMeasuringDistance>\n");
    }
  if (ProbeTipDiameter)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProbeTipDiameter");
      ProbeTipDiameter->printSelf(outFile);
      fprintf(outFile, "</ProbeTipDiameter>\n");
    }
  if (Accuracies)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Accuracies");
      Accuracies->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Accuracies>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool AACMMType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in AACMMType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in AACMMType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in AACMMType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in AACMMType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

PointType * AACMMType::getHomeLocation()
{return HomeLocation;}

void AACMMType::setHomeLocation(PointType * HomeLocationIn)
{HomeLocation = HomeLocationIn;}

XmlInt * AACMMType::getNumberOfJoints()
{return NumberOfJoints;}

void AACMMType::setNumberOfJoints(XmlInt * NumberOfJointsIn)
{NumberOfJoints = NumberOfJointsIn;}

LinearValueType * AACMMType::getMinMeasuringDistance()
{return MinMeasuringDistance;}

void AACMMType::setMinMeasuringDistance(LinearValueType * MinMeasuringDistanceIn)
{MinMeasuringDistance = MinMeasuringDistanceIn;}

LinearValueType * AACMMType::getMaxMeasuringDistance()
{return MaxMeasuringDistance;}

void AACMMType::setMaxMeasuringDistance(LinearValueType * MaxMeasuringDistanceIn)
{MaxMeasuringDistance = MaxMeasuringDistanceIn;}

LinearValueType * AACMMType::getProbeTipDiameter()
{return ProbeTipDiameter;}

void AACMMType::setProbeTipDiameter(LinearValueType * ProbeTipDiameterIn)
{ProbeTipDiameter = ProbeTipDiameterIn;}

AACMMAccuraciesType * AACMMType::getAccuracies()
{return Accuracies;}

void AACMMType::setAccuracies(AACMMAccuraciesType * AccuraciesIn)
{Accuracies = AccuraciesIn;}

/* ***************************************************************** */

/* class ABCResolutionType

*/

ABCResolutionType::ABCResolutionType()
{
  AAxisResolution = 0;
  BAxisResolution = 0;
  CAxisResolution = 0;
}

ABCResolutionType::ABCResolutionType(
 LinearOrRotaryAxisType * AAxisResolutionIn,
 LinearOrRotaryAxisType * BAxisResolutionIn,
 LinearOrRotaryAxisType * CAxisResolutionIn)
{
  AAxisResolution = AAxisResolutionIn;
  BAxisResolution = BAxisResolutionIn;
  CAxisResolution = CAxisResolutionIn;
}

ABCResolutionType::~ABCResolutionType()
{
  #ifndef NODESTRUCT
  delete AAxisResolution;
  delete BAxisResolution;
  delete CAxisResolution;
  #endif
}

void ABCResolutionType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<AAxisResolution");
  AAxisResolution->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</AAxisResolution>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<BAxisResolution");
  BAxisResolution->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BAxisResolution>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CAxisResolution");
  CAxisResolution->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</CAxisResolution>\n");
  doSpaces(-INDENT, outFile);
}

LinearOrRotaryAxisType * ABCResolutionType::getAAxisResolution()
{return AAxisResolution;}

void ABCResolutionType::setAAxisResolution(LinearOrRotaryAxisType * AAxisResolutionIn)
{AAxisResolution = AAxisResolutionIn;}

LinearOrRotaryAxisType * ABCResolutionType::getBAxisResolution()
{return BAxisResolution;}

void ABCResolutionType::setBAxisResolution(LinearOrRotaryAxisType * BAxisResolutionIn)
{BAxisResolution = BAxisResolutionIn;}

LinearOrRotaryAxisType * ABCResolutionType::getCAxisResolution()
{return CAxisResolution;}

void ABCResolutionType::setCAxisResolution(LinearOrRotaryAxisType * CAxisResolutionIn)
{CAxisResolution = CAxisResolutionIn;}

/* ***************************************************************** */

/* class AccuracySourceEnumType

*/

AccuracySourceEnumType::AccuracySourceEnumType() :
  XmlNMTOKEN()
{
}

AccuracySourceEnumType::AccuracySourceEnumType(
 const char * valIn) :
  XmlNMTOKEN(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "MANUFACTURER_SPECIFICATION") &&
           strcmp(val.c_str(), "CUSTOM_CERTIFICATION"));
}

AccuracySourceEnumType::~AccuracySourceEnumType() {}

bool AccuracySourceEnumType::AccuracySourceEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "MANUFACTURER_SPECIFICATION") &&
          strcmp(val.c_str(), "CUSTOM_CERTIFICATION"));
}

void AccuracySourceEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "AccuracySourceEnumType");
}

void AccuracySourceEnumType::printSelf(FILE * outFile)
{
  if (AccuracySourceEnumTypeIsBad())
    {
      fprintf(stderr, "bad AccuracySourceEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::printSelf(outFile);
}

void AccuracySourceEnumType::oPrintSelf(FILE * outFile)
{
  if (AccuracySourceEnumTypeIsBad())
    {
      fprintf(stderr, "bad AccuracySourceEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class AccuracySourceType

*/

AccuracySourceType::AccuracySourceType()
{
  AccuracySourceTypePair = 0;
}

AccuracySourceType::AccuracySourceType(
 AccuracySourceTypeChoicePair * AccuracySourceTypePairIn)
{
  AccuracySourceTypePair = AccuracySourceTypePairIn;
}

AccuracySourceType::~AccuracySourceType()
{
  #ifndef NODESTRUCT
  delete AccuracySourceTypePair;
  #endif
}

void AccuracySourceType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  AccuracySourceTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

AccuracySourceTypeChoicePair * AccuracySourceType::getAccuracySourceTypePair()
{return AccuracySourceTypePair;}

void AccuracySourceType::setAccuracySourceTypePair(AccuracySourceTypeChoicePair * AccuracySourceTypePairIn)
{AccuracySourceTypePair = AccuracySourceTypePairIn;}
AccuracySourceTypeChoicePair::AccuracySourceTypeChoicePair() {}

AccuracySourceTypeChoicePair::AccuracySourceTypeChoicePair(
 whichOne AccuracySourceTypeTypeIn,
 AccuracySourceTypeVal AccuracySourceTypeValueIn)
{
  AccuracySourceTypeType = AccuracySourceTypeTypeIn;
  AccuracySourceTypeValue = AccuracySourceTypeValueIn;
}

AccuracySourceTypeChoicePair::~AccuracySourceTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (AccuracySourceTypeType == AccuracySourceEnumE)
    delete AccuracySourceTypeValue.AccuracySourceEnum;
  else if (AccuracySourceTypeType == OtherAccuracySourceE)
    delete AccuracySourceTypeValue.OtherAccuracySource;
  #endif
}

void AccuracySourceTypeChoicePair::printSelf(FILE * outFile)
{
  if (AccuracySourceTypeType == AccuracySourceEnumE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AccuracySourceEnum");
      AccuracySourceTypeValue.AccuracySourceEnum->printSelf(outFile);
      fprintf(outFile, "</AccuracySourceEnum>\n");
    }
  else if (AccuracySourceTypeType == OtherAccuracySourceE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OtherAccuracySource");
      AccuracySourceTypeValue.OtherAccuracySource->printSelf(outFile);
      fprintf(outFile, "</OtherAccuracySource>\n");
    }
}

/* ***************************************************************** */

/* class AngleFunctionDiscreteType

*/

AngleFunctionDiscreteType::AngleFunctionDiscreteType() :
  FunctionDiscreteType()
{
  DomainLinearUnit = 0;
  RangeAngularUnit = 0;
}

AngleFunctionDiscreteType::AngleFunctionDiscreteType(
 ListDoubleType * DomainValuesIn,
 ListDoubleType * RangeValuesIn,
 XmlToken * DomainLinearUnitIn,
 XmlToken * RangeAngularUnitIn) :
  FunctionDiscreteType(
    DomainValuesIn,
    RangeValuesIn)
{
  DomainLinearUnit = DomainLinearUnitIn;
  RangeAngularUnit = RangeAngularUnitIn;
}

AngleFunctionDiscreteType::AngleFunctionDiscreteType(
 NaturalType * nIn,
 ListDoubleType * DomainValuesIn,
 ListDoubleType * RangeValuesIn,
 XmlToken * DomainLinearUnitIn,
 XmlToken * RangeAngularUnitIn) :
  FunctionDiscreteType(
    nIn,
    DomainValuesIn,
    RangeValuesIn)
{
  DomainLinearUnit = DomainLinearUnitIn;
  RangeAngularUnit = RangeAngularUnitIn;
}

AngleFunctionDiscreteType::~AngleFunctionDiscreteType()
{
  #ifndef NODESTRUCT
  delete DomainLinearUnit;
  delete RangeAngularUnit;
  #endif
}

void AngleFunctionDiscreteType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<DomainValues");
  DomainValues->printSelf(outFile);
  fprintf(outFile, "</DomainValues>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<RangeValues");
  RangeValues->printSelf(outFile);
  fprintf(outFile, "</RangeValues>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<DomainLinearUnit");
  DomainLinearUnit->printSelf(outFile);
  fprintf(outFile, "</DomainLinearUnit>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<RangeAngularUnit");
  RangeAngularUnit->printSelf(outFile);
  fprintf(outFile, "</RangeAngularUnit>\n");
  doSpaces(-INDENT, outFile);
}

bool AngleFunctionDiscreteType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in AngleFunctionDiscreteType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in AngleFunctionDiscreteType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in AngleFunctionDiscreteType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in AngleFunctionDiscreteType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

XmlToken * AngleFunctionDiscreteType::getDomainLinearUnit()
{return DomainLinearUnit;}

void AngleFunctionDiscreteType::setDomainLinearUnit(XmlToken * DomainLinearUnitIn)
{DomainLinearUnit = DomainLinearUnitIn;}

XmlToken * AngleFunctionDiscreteType::getRangeAngularUnit()
{return RangeAngularUnit;}

void AngleFunctionDiscreteType::setRangeAngularUnit(XmlToken * RangeAngularUnitIn)
{RangeAngularUnit = RangeAngularUnitIn;}

/* ***************************************************************** */

/* class AngularErrorType

*/

AngularErrorType::AngularErrorType()
{
  BaseError = 0;
  ErrorRate = 0;
}

AngularErrorType::AngularErrorType(
 AngularValueType * BaseErrorIn,
 XmlDecimal * ErrorRateIn)
{
  BaseError = BaseErrorIn;
  ErrorRate = ErrorRateIn;
}

AngularErrorType::~AngularErrorType()
{
  #ifndef NODESTRUCT
  delete BaseError;
  delete ErrorRate;
  #endif
}

void AngularErrorType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseError");
  BaseError->printSelf(outFile);
  fprintf(outFile, "</BaseError>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<ErrorRate");
  ErrorRate->printSelf(outFile);
  fprintf(outFile, "</ErrorRate>\n");
  doSpaces(-INDENT, outFile);
}

AngularValueType * AngularErrorType::getBaseError()
{return BaseError;}

void AngularErrorType::setBaseError(AngularValueType * BaseErrorIn)
{BaseError = BaseErrorIn;}

XmlDecimal * AngularErrorType::getErrorRate()
{return ErrorRate;}

void AngularErrorType::setErrorRate(XmlDecimal * ErrorRateIn)
{ErrorRate = ErrorRateIn;}

/* ***************************************************************** */

/* class AutocollimatorType

*/

AutocollimatorType::AutocollimatorType() :
  UniversalDeviceType()
{
  LightSource = 0;
  MeasuringAccuracy = 0;
  Magnification = 0;
  ApertureSize = 0;
  MinMeasuringDistance = 0;
  MaxMeasuringDistance = 0;
  ObjectiveFocalLength = 0;
  FieldOfView = 0;
}

AutocollimatorType::AutocollimatorType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 ResolutionBaseType * ResolutionIn,
 WorkingVolumeBaseType * WorkingVolumeIn,
 EffectiveWorkingVolumeBaseType * EffectiveWorkingVolumeIn,
 TemperatureCompensationType * TemperatureCompensationIn,
 XmlString * LightSourceIn,
 AngularErrorType * MeasuringAccuracyIn,
 XmlDecimal * MagnificationIn,
 LinearValueType * ApertureSizeIn,
 AngularValueType * MinMeasuringDistanceIn,
 AngularValueType * MaxMeasuringDistanceIn,
 LinearValueType * ObjectiveFocalLengthIn,
 AngularValueType * FieldOfViewIn) :
  UniversalDeviceType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    ResolutionIn,
    WorkingVolumeIn,
    EffectiveWorkingVolumeIn,
    TemperatureCompensationIn)
{
  LightSource = LightSourceIn;
  MeasuringAccuracy = MeasuringAccuracyIn;
  Magnification = MagnificationIn;
  ApertureSize = ApertureSizeIn;
  MinMeasuringDistance = MinMeasuringDistanceIn;
  MaxMeasuringDistance = MaxMeasuringDistanceIn;
  ObjectiveFocalLength = ObjectiveFocalLengthIn;
  FieldOfView = FieldOfViewIn;
}

AutocollimatorType::AutocollimatorType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 ResolutionBaseType * ResolutionIn,
 WorkingVolumeBaseType * WorkingVolumeIn,
 EffectiveWorkingVolumeBaseType * EffectiveWorkingVolumeIn,
 TemperatureCompensationType * TemperatureCompensationIn,
 XmlString * LightSourceIn,
 AngularErrorType * MeasuringAccuracyIn,
 XmlDecimal * MagnificationIn,
 LinearValueType * ApertureSizeIn,
 AngularValueType * MinMeasuringDistanceIn,
 AngularValueType * MaxMeasuringDistanceIn,
 LinearValueType * ObjectiveFocalLengthIn,
 AngularValueType * FieldOfViewIn) :
  UniversalDeviceType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    ResolutionIn,
    WorkingVolumeIn,
    EffectiveWorkingVolumeIn,
    TemperatureCompensationIn)
{
  LightSource = LightSourceIn;
  MeasuringAccuracy = MeasuringAccuracyIn;
  Magnification = MagnificationIn;
  ApertureSize = ApertureSizeIn;
  MinMeasuringDistance = MinMeasuringDistanceIn;
  MaxMeasuringDistance = MaxMeasuringDistanceIn;
  ObjectiveFocalLength = ObjectiveFocalLengthIn;
  FieldOfView = FieldOfViewIn;
}

AutocollimatorType::~AutocollimatorType()
{
  #ifndef NODESTRUCT
  delete LightSource;
  delete MeasuringAccuracy;
  delete Magnification;
  delete ApertureSize;
  delete MinMeasuringDistance;
  delete MaxMeasuringDistance;
  delete ObjectiveFocalLength;
  delete FieldOfView;
  #endif
}

void AutocollimatorType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Calibrations)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Calibrations");
      Calibrations->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Calibrations>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (Resolution)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (Resolution->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(Resolution->getprintElement(), "LinearResolution") == 0)
          {
            LinearResolutionType * typ;
            if ((typ = dynamic_cast<LinearResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<LinearResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LinearResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad LinearResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "CartesianResolution") == 0)
          {
            CartesianResolutionType * typ;
            if ((typ = dynamic_cast<CartesianResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<CartesianResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "SphericalResolution") == 0)
          {
            SphericalResolutionType * typ;
            if ((typ = dynamic_cast<SphericalResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<SphericalResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "UserDefinedResolution") == 0)
          {
            UserDefinedResolutionType * typ;
            if ((typ = dynamic_cast<UserDefinedResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<UserDefinedResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedResolution element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad Resolution type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (WorkingVolume)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (WorkingVolume->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(WorkingVolume->getprintElement(), "ClosedShellSetWorkingVolume") == 0)
          {
            ClosedShellSetWorkingVolumeType * typ;
            if ((typ = dynamic_cast<ClosedShellSetWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<ClosedShellSetWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ClosedShellSetWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad ClosedShellSetWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "CartesianWorkingVolume") == 0)
          {
            CartesianWorkingVolumeType * typ;
            if ((typ = dynamic_cast<CartesianWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<CartesianWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "SphericalWorkingVolume") == 0)
          {
            SphericalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<SphericalWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<SphericalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "CylindricalWorkingVolume") == 0)
          {
            CylindricalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<CylindricalWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<CylindricalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CylindricalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad CylindricalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "UserDefinedWorkingVolume") == 0)
          {
            UserDefinedWorkingVolumeType * typ;
            if ((typ = dynamic_cast<UserDefinedWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<UserDefinedWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedWorkingVolume element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad WorkingVolume type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (EffectiveWorkingVolume)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (EffectiveWorkingVolume->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveClosedShellSetWorkingVolume") == 0)
          {
            EffectiveClosedShellSetWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveClosedShellSetWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveClosedShellSetWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveClosedShellSetWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveClosedShellSetWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveCartesianWorkingVolume") == 0)
          {
            EffectiveCartesianWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveCartesianWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveCartesianWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveCartesianWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveCartesianWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveSphericalWorkingVolume") == 0)
          {
            EffectiveSphericalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveSphericalWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveSphericalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveSphericalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveSphericalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveCylindricalWorkingVolume") == 0)
          {
            EffectiveCylindricalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveCylindricalWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveCylindricalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveCylindricalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveCylindricalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveUserDefinedWorkingVolume") == 0)
          {
            EffectiveUserDefinedWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveUserDefinedWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveUserDefinedWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveUserDefinedWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveUserDefinedWorkingVolume element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad EffectiveWorkingVolume type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (TemperatureCompensation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TemperatureCompensation");
      TemperatureCompensation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</TemperatureCompensation>\n");
    }
  if (LightSource)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LightSource");
      LightSource->printSelf(outFile);
      fprintf(outFile, "</LightSource>\n");
    }
  if (MeasuringAccuracy)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasuringAccuracy");
      MeasuringAccuracy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasuringAccuracy>\n");
    }
  if (Magnification)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Magnification");
      Magnification->printSelf(outFile);
      fprintf(outFile, "</Magnification>\n");
    }
  if (ApertureSize)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ApertureSize");
      ApertureSize->printSelf(outFile);
      fprintf(outFile, "</ApertureSize>\n");
    }
  if (MinMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinMeasuringDistance");
      MinMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MinMeasuringDistance>\n");
    }
  if (MaxMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxMeasuringDistance");
      MaxMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MaxMeasuringDistance>\n");
    }
  if (ObjectiveFocalLength)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ObjectiveFocalLength");
      ObjectiveFocalLength->printSelf(outFile);
      fprintf(outFile, "</ObjectiveFocalLength>\n");
    }
  if (FieldOfView)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FieldOfView");
      FieldOfView->printSelf(outFile);
      fprintf(outFile, "</FieldOfView>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool AutocollimatorType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in AutocollimatorType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in AutocollimatorType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in AutocollimatorType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in AutocollimatorType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

XmlString * AutocollimatorType::getLightSource()
{return LightSource;}

void AutocollimatorType::setLightSource(XmlString * LightSourceIn)
{LightSource = LightSourceIn;}

AngularErrorType * AutocollimatorType::getMeasuringAccuracy()
{return MeasuringAccuracy;}

void AutocollimatorType::setMeasuringAccuracy(AngularErrorType * MeasuringAccuracyIn)
{MeasuringAccuracy = MeasuringAccuracyIn;}

XmlDecimal * AutocollimatorType::getMagnification()
{return Magnification;}

void AutocollimatorType::setMagnification(XmlDecimal * MagnificationIn)
{Magnification = MagnificationIn;}

LinearValueType * AutocollimatorType::getApertureSize()
{return ApertureSize;}

void AutocollimatorType::setApertureSize(LinearValueType * ApertureSizeIn)
{ApertureSize = ApertureSizeIn;}

AngularValueType * AutocollimatorType::getMinMeasuringDistance()
{return MinMeasuringDistance;}

void AutocollimatorType::setMinMeasuringDistance(AngularValueType * MinMeasuringDistanceIn)
{MinMeasuringDistance = MinMeasuringDistanceIn;}

AngularValueType * AutocollimatorType::getMaxMeasuringDistance()
{return MaxMeasuringDistance;}

void AutocollimatorType::setMaxMeasuringDistance(AngularValueType * MaxMeasuringDistanceIn)
{MaxMeasuringDistance = MaxMeasuringDistanceIn;}

LinearValueType * AutocollimatorType::getObjectiveFocalLength()
{return ObjectiveFocalLength;}

void AutocollimatorType::setObjectiveFocalLength(LinearValueType * ObjectiveFocalLengthIn)
{ObjectiveFocalLength = ObjectiveFocalLengthIn;}

AngularValueType * AutocollimatorType::getFieldOfView()
{return FieldOfView;}

void AutocollimatorType::setFieldOfView(AngularValueType * FieldOfViewIn)
{FieldOfView = FieldOfViewIn;}

/* ***************************************************************** */

/* class CMMAccuracyTestBaseType

*/

CMMAccuracyTestBaseType::CMMAccuracyTestBaseType()
{}

CMMAccuracyTestBaseType::~CMMAccuracyTestBaseType() {}

void CMMAccuracyTestBaseType::printSelf(FILE * outFile)
{
  fprintf(outFile, "/>\n");
}

/* ***************************************************************** */

/* class CMMAxisDirectionsBaseType

*/

CMMAxisDirectionsBaseType::CMMAxisDirectionsBaseType()
{}

CMMAxisDirectionsBaseType::~CMMAxisDirectionsBaseType() {}

void CMMAxisDirectionsBaseType::printSelf(FILE * outFile)
{
  fprintf(outFile, "/>\n");
}

/* ***************************************************************** */

/* class CMMDirectionEnumType

*/

CMMDirectionEnumType::CMMDirectionEnumType() :
  XmlNMTOKEN()
{
}

CMMDirectionEnumType::CMMDirectionEnumType(
 const char * valIn) :
  XmlNMTOKEN(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "RIGHT") &&
           strcmp(val.c_str(), "LEFT") &&
           strcmp(val.c_str(), "FRONT") &&
           strcmp(val.c_str(), "BACK") &&
           strcmp(val.c_str(), "UP") &&
           strcmp(val.c_str(), "DOWN"));
}

CMMDirectionEnumType::~CMMDirectionEnumType() {}

bool CMMDirectionEnumType::CMMDirectionEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "RIGHT") &&
          strcmp(val.c_str(), "LEFT") &&
          strcmp(val.c_str(), "FRONT") &&
          strcmp(val.c_str(), "BACK") &&
          strcmp(val.c_str(), "UP") &&
          strcmp(val.c_str(), "DOWN"));
}

void CMMDirectionEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "CMMDirectionEnumType");
}

void CMMDirectionEnumType::printSelf(FILE * outFile)
{
  if (CMMDirectionEnumTypeIsBad())
    {
      fprintf(stderr, "bad CMMDirectionEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::printSelf(outFile);
}

void CMMDirectionEnumType::oPrintSelf(FILE * outFile)
{
  if (CMMDirectionEnumTypeIsBad())
    {
      fprintf(stderr, "bad CMMDirectionEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class CMMSpeedsBaseType

*/

CMMSpeedsBaseType::CMMSpeedsBaseType()
{}

CMMSpeedsBaseType::~CMMSpeedsBaseType() {}

void CMMSpeedsBaseType::printSelf(FILE * outFile)
{
  fprintf(outFile, "/>\n");
}

/* ***************************************************************** */

/* class CMMType

*/

CMMType::CMMType() :
  UniversalDeviceType()
{
}

CMMType::CMMType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 ResolutionBaseType * ResolutionIn,
 WorkingVolumeBaseType * WorkingVolumeIn,
 EffectiveWorkingVolumeBaseType * EffectiveWorkingVolumeIn,
 TemperatureCompensationType * TemperatureCompensationIn) :
  UniversalDeviceType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    ResolutionIn,
    WorkingVolumeIn,
    EffectiveWorkingVolumeIn,
    TemperatureCompensationIn)
{
}

CMMType::CMMType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 ResolutionBaseType * ResolutionIn,
 WorkingVolumeBaseType * WorkingVolumeIn,
 EffectiveWorkingVolumeBaseType * EffectiveWorkingVolumeIn,
 TemperatureCompensationType * TemperatureCompensationIn) :
  UniversalDeviceType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    ResolutionIn,
    WorkingVolumeIn,
    EffectiveWorkingVolumeIn,
    TemperatureCompensationIn)
{
}

CMMType::~CMMType()
{
  #ifndef NODESTRUCT
  #endif
}

void CMMType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Calibrations)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Calibrations");
      Calibrations->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Calibrations>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (Resolution)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (Resolution->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(Resolution->getprintElement(), "LinearResolution") == 0)
          {
            LinearResolutionType * typ;
            if ((typ = dynamic_cast<LinearResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<LinearResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LinearResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad LinearResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "CartesianResolution") == 0)
          {
            CartesianResolutionType * typ;
            if ((typ = dynamic_cast<CartesianResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<CartesianResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "SphericalResolution") == 0)
          {
            SphericalResolutionType * typ;
            if ((typ = dynamic_cast<SphericalResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<SphericalResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "UserDefinedResolution") == 0)
          {
            UserDefinedResolutionType * typ;
            if ((typ = dynamic_cast<UserDefinedResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<UserDefinedResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedResolution element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad Resolution type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (WorkingVolume)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (WorkingVolume->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(WorkingVolume->getprintElement(), "ClosedShellSetWorkingVolume") == 0)
          {
            ClosedShellSetWorkingVolumeType * typ;
            if ((typ = dynamic_cast<ClosedShellSetWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<ClosedShellSetWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ClosedShellSetWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad ClosedShellSetWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "CartesianWorkingVolume") == 0)
          {
            CartesianWorkingVolumeType * typ;
            if ((typ = dynamic_cast<CartesianWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<CartesianWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "SphericalWorkingVolume") == 0)
          {
            SphericalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<SphericalWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<SphericalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "CylindricalWorkingVolume") == 0)
          {
            CylindricalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<CylindricalWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<CylindricalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CylindricalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad CylindricalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "UserDefinedWorkingVolume") == 0)
          {
            UserDefinedWorkingVolumeType * typ;
            if ((typ = dynamic_cast<UserDefinedWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<UserDefinedWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedWorkingVolume element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad WorkingVolume type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (EffectiveWorkingVolume)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (EffectiveWorkingVolume->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveClosedShellSetWorkingVolume") == 0)
          {
            EffectiveClosedShellSetWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveClosedShellSetWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveClosedShellSetWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveClosedShellSetWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveClosedShellSetWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveCartesianWorkingVolume") == 0)
          {
            EffectiveCartesianWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveCartesianWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveCartesianWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveCartesianWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveCartesianWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveSphericalWorkingVolume") == 0)
          {
            EffectiveSphericalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveSphericalWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveSphericalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveSphericalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveSphericalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveCylindricalWorkingVolume") == 0)
          {
            EffectiveCylindricalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveCylindricalWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveCylindricalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveCylindricalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveCylindricalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveUserDefinedWorkingVolume") == 0)
          {
            EffectiveUserDefinedWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveUserDefinedWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveUserDefinedWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveUserDefinedWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveUserDefinedWorkingVolume element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad EffectiveWorkingVolume type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (TemperatureCompensation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TemperatureCompensation");
      TemperatureCompensation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</TemperatureCompensation>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CMMType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CMMType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CMMType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CMMType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CMMType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class CalibrationMasterType

*/

CalibrationMasterType::CalibrationMasterType()
{
  SerialNumber = 0;
  Description = 0;
}

CalibrationMasterType::CalibrationMasterType(
 XmlString * SerialNumberIn,
 XmlString * DescriptionIn)
{
  SerialNumber = SerialNumberIn;
  Description = DescriptionIn;
}

CalibrationMasterType::~CalibrationMasterType()
{
  #ifndef NODESTRUCT
  delete SerialNumber;
  delete Description;
  #endif
}

void CalibrationMasterType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<SerialNumber");
  SerialNumber->printSelf(outFile);
  fprintf(outFile, "</SerialNumber>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  doSpaces(-INDENT, outFile);
}

XmlString * CalibrationMasterType::getSerialNumber()
{return SerialNumber;}

void CalibrationMasterType::setSerialNumber(XmlString * SerialNumberIn)
{SerialNumber = SerialNumberIn;}

XmlString * CalibrationMasterType::getDescription()
{return Description;}

void CalibrationMasterType::setDescription(XmlString * DescriptionIn)
{Description = DescriptionIn;}

/* ***************************************************************** */

/* class CalibrationType

*/

CalibrationType::CalibrationType()
{
  CalibrationMaster = 0;
  Temperatures = 0;
  CalibrationDate = 0;
  ExpirationDate = 0;
}

CalibrationType::CalibrationType(
 CalibrationMasterType * CalibrationMasterIn,
 TemperaturesType * TemperaturesIn,
 XmlDateTime * CalibrationDateIn,
 XmlDateTime * ExpirationDateIn)
{
  CalibrationMaster = CalibrationMasterIn;
  Temperatures = TemperaturesIn;
  CalibrationDate = CalibrationDateIn;
  ExpirationDate = ExpirationDateIn;
}

CalibrationType::~CalibrationType()
{
  #ifndef NODESTRUCT
  delete CalibrationMaster;
  delete Temperatures;
  delete CalibrationDate;
  delete ExpirationDate;
  #endif
}

void CalibrationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (CalibrationMaster)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CalibrationMaster");
      CalibrationMaster->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CalibrationMaster>\n");
    }
  if (Temperatures)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Temperatures");
      Temperatures->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Temperatures>\n");
    }
  if (CalibrationDate)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CalibrationDate");
      CalibrationDate->printSelf(outFile);
      fprintf(outFile, "</CalibrationDate>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ExpirationDate");
  ExpirationDate->printSelf(outFile);
  fprintf(outFile, "</ExpirationDate>\n");
  doSpaces(-INDENT, outFile);
}

CalibrationMasterType * CalibrationType::getCalibrationMaster()
{return CalibrationMaster;}

void CalibrationType::setCalibrationMaster(CalibrationMasterType * CalibrationMasterIn)
{CalibrationMaster = CalibrationMasterIn;}

TemperaturesType * CalibrationType::getTemperatures()
{return Temperatures;}

void CalibrationType::setTemperatures(TemperaturesType * TemperaturesIn)
{Temperatures = TemperaturesIn;}

XmlDateTime * CalibrationType::getCalibrationDate()
{return CalibrationDate;}

void CalibrationType::setCalibrationDate(XmlDateTime * CalibrationDateIn)
{CalibrationDate = CalibrationDateIn;}

XmlDateTime * CalibrationType::getExpirationDate()
{return ExpirationDate;}

void CalibrationType::setExpirationDate(XmlDateTime * ExpirationDateIn)
{ExpirationDate = ExpirationDateIn;}

/* ***************************************************************** */

/* class CalibrationTypeLisd

*/

CalibrationTypeLisd::CalibrationTypeLisd() {}

CalibrationTypeLisd::CalibrationTypeLisd(CalibrationType * aCalibrationType)
{
  push_back(aCalibrationType);
}

CalibrationTypeLisd::~CalibrationTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<CalibrationType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void CalibrationTypeLisd::printSelf(FILE * outFile)
{
  std::list<CalibrationType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class CalibrationsType

*/

CalibrationsType::CalibrationsType()
{
  n = 0;
  Calibration = 0;
}

CalibrationsType::CalibrationsType(
 CalibrationTypeLisd * CalibrationIn)
{
  n = 0;
  Calibration = CalibrationIn;
}

CalibrationsType::CalibrationsType(
 NaturalType * nIn,
 CalibrationTypeLisd * CalibrationIn)
{
  n = nIn;
  Calibration = CalibrationIn;
}

CalibrationsType::~CalibrationsType()
{
  #ifndef NODESTRUCT
  delete n;
  delete Calibration;
  #endif
}

void CalibrationsType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!Calibration)
      {
        fprintf(stderr, "Calibration list is missing\n");
        exit(1);
      }
    if (Calibration->size() == 0)
      {
        fprintf(stderr, "Calibration list is empty\n");
        exit(1);
      }
    if (Calibration->size() < 1)
      {
        fprintf(stderr,
                "size of Calibration list (%d) less than minimum required (1)\n",
                (int)Calibration->size());
        exit(1);
      }
    std::list<CalibrationType *>::iterator iter;
    for (iter = Calibration->begin();
         iter != Calibration->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<Calibration");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</Calibration>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool CalibrationsType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in CalibrationsType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in CalibrationsType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CalibrationsType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in CalibrationsType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * CalibrationsType::getn()
{return n;}

void CalibrationsType::setn(NaturalType * nIn)
{n = nIn;}

CalibrationTypeLisd * CalibrationsType::getCalibration()
{return Calibration;}

void CalibrationsType::setCalibration(CalibrationTypeLisd * CalibrationIn)
{Calibration = CalibrationIn;}

/* ***************************************************************** */

/* class CaliperDialType

*/

CaliperDialType::CaliperDialType() :
  CaliperType()
{
}

CaliperDialType::CaliperDialType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 LinearResolutionType * LinearResolutionIn,
 NumericalLengthAccuracyType * AccuracyIn,
 XmlBoolean * CanMeasureInnerDIn,
 XmlBoolean * CanMeasureOuterDIn,
 XmlBoolean * CanMeasureDepthIn) :
  CaliperType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    MinMeasuringDistanceIn,
    MaxMeasuringDistanceIn,
    LinearResolutionIn,
    AccuracyIn,
    CanMeasureInnerDIn,
    CanMeasureOuterDIn,
    CanMeasureDepthIn)
{
}

CaliperDialType::CaliperDialType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 LinearResolutionType * LinearResolutionIn,
 NumericalLengthAccuracyType * AccuracyIn,
 XmlBoolean * CanMeasureInnerDIn,
 XmlBoolean * CanMeasureOuterDIn,
 XmlBoolean * CanMeasureDepthIn) :
  CaliperType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    MinMeasuringDistanceIn,
    MaxMeasuringDistanceIn,
    LinearResolutionIn,
    AccuracyIn,
    CanMeasureInnerDIn,
    CanMeasureOuterDIn,
    CanMeasureDepthIn)
{
}

CaliperDialType::~CaliperDialType()
{
  #ifndef NODESTRUCT
  #endif
}

void CaliperDialType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Calibrations)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Calibrations");
      Calibrations->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Calibrations>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (MinMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinMeasuringDistance");
      MinMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MinMeasuringDistance>\n");
    }
  if (MaxMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxMeasuringDistance");
      MaxMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MaxMeasuringDistance>\n");
    }
  if (LinearResolution)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LinearResolution");
      LinearResolution->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LinearResolution>\n");
    }
  if (Accuracy)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Accuracy");
      Accuracy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Accuracy>\n");
    }
  if (CanMeasureInnerD)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CanMeasureInnerD");
      CanMeasureInnerD->printSelf(outFile);
      fprintf(outFile, "</CanMeasureInnerD>\n");
    }
  if (CanMeasureOuterD)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CanMeasureOuterD");
      CanMeasureOuterD->printSelf(outFile);
      fprintf(outFile, "</CanMeasureOuterD>\n");
    }
  if (CanMeasureDepth)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CanMeasureDepth");
      CanMeasureDepth->printSelf(outFile);
      fprintf(outFile, "</CanMeasureDepth>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CaliperDialType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CaliperDialType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CaliperDialType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CaliperDialType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CaliperDialType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class CaliperDigitalType

*/

CaliperDigitalType::CaliperDigitalType() :
  CaliperType()
{
}

CaliperDigitalType::CaliperDigitalType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 LinearResolutionType * LinearResolutionIn,
 NumericalLengthAccuracyType * AccuracyIn,
 XmlBoolean * CanMeasureInnerDIn,
 XmlBoolean * CanMeasureOuterDIn,
 XmlBoolean * CanMeasureDepthIn) :
  CaliperType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    MinMeasuringDistanceIn,
    MaxMeasuringDistanceIn,
    LinearResolutionIn,
    AccuracyIn,
    CanMeasureInnerDIn,
    CanMeasureOuterDIn,
    CanMeasureDepthIn)
{
}

CaliperDigitalType::CaliperDigitalType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 LinearResolutionType * LinearResolutionIn,
 NumericalLengthAccuracyType * AccuracyIn,
 XmlBoolean * CanMeasureInnerDIn,
 XmlBoolean * CanMeasureOuterDIn,
 XmlBoolean * CanMeasureDepthIn) :
  CaliperType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    MinMeasuringDistanceIn,
    MaxMeasuringDistanceIn,
    LinearResolutionIn,
    AccuracyIn,
    CanMeasureInnerDIn,
    CanMeasureOuterDIn,
    CanMeasureDepthIn)
{
}

CaliperDigitalType::~CaliperDigitalType()
{
  #ifndef NODESTRUCT
  #endif
}

void CaliperDigitalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Calibrations)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Calibrations");
      Calibrations->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Calibrations>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (MinMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinMeasuringDistance");
      MinMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MinMeasuringDistance>\n");
    }
  if (MaxMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxMeasuringDistance");
      MaxMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MaxMeasuringDistance>\n");
    }
  if (LinearResolution)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LinearResolution");
      LinearResolution->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LinearResolution>\n");
    }
  if (Accuracy)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Accuracy");
      Accuracy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Accuracy>\n");
    }
  if (CanMeasureInnerD)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CanMeasureInnerD");
      CanMeasureInnerD->printSelf(outFile);
      fprintf(outFile, "</CanMeasureInnerD>\n");
    }
  if (CanMeasureOuterD)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CanMeasureOuterD");
      CanMeasureOuterD->printSelf(outFile);
      fprintf(outFile, "</CanMeasureOuterD>\n");
    }
  if (CanMeasureDepth)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CanMeasureDepth");
      CanMeasureDepth->printSelf(outFile);
      fprintf(outFile, "</CanMeasureDepth>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CaliperDigitalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CaliperDigitalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CaliperDigitalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CaliperDigitalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CaliperDigitalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class CaliperType

*/

CaliperType::CaliperType() :
  ManualMeasurementDeviceType()
{
  LinearResolution = 0;
  Accuracy = 0;
  CanMeasureInnerD = 0;
  CanMeasureOuterD = 0;
  CanMeasureDepth = 0;
}

CaliperType::CaliperType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 LinearResolutionType * LinearResolutionIn,
 NumericalLengthAccuracyType * AccuracyIn,
 XmlBoolean * CanMeasureInnerDIn,
 XmlBoolean * CanMeasureOuterDIn,
 XmlBoolean * CanMeasureDepthIn) :
  ManualMeasurementDeviceType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    MinMeasuringDistanceIn,
    MaxMeasuringDistanceIn)
{
  LinearResolution = LinearResolutionIn;
  Accuracy = AccuracyIn;
  CanMeasureInnerD = CanMeasureInnerDIn;
  CanMeasureOuterD = CanMeasureOuterDIn;
  CanMeasureDepth = CanMeasureDepthIn;
}

CaliperType::CaliperType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 LinearResolutionType * LinearResolutionIn,
 NumericalLengthAccuracyType * AccuracyIn,
 XmlBoolean * CanMeasureInnerDIn,
 XmlBoolean * CanMeasureOuterDIn,
 XmlBoolean * CanMeasureDepthIn) :
  ManualMeasurementDeviceType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    MinMeasuringDistanceIn,
    MaxMeasuringDistanceIn)
{
  LinearResolution = LinearResolutionIn;
  Accuracy = AccuracyIn;
  CanMeasureInnerD = CanMeasureInnerDIn;
  CanMeasureOuterD = CanMeasureOuterDIn;
  CanMeasureDepth = CanMeasureDepthIn;
}

CaliperType::~CaliperType()
{
  #ifndef NODESTRUCT
  delete LinearResolution;
  delete Accuracy;
  delete CanMeasureInnerD;
  delete CanMeasureOuterD;
  delete CanMeasureDepth;
  #endif
}

void CaliperType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Calibrations)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Calibrations");
      Calibrations->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Calibrations>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (MinMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinMeasuringDistance");
      MinMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MinMeasuringDistance>\n");
    }
  if (MaxMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxMeasuringDistance");
      MaxMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MaxMeasuringDistance>\n");
    }
  if (LinearResolution)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LinearResolution");
      LinearResolution->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LinearResolution>\n");
    }
  if (Accuracy)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Accuracy");
      Accuracy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Accuracy>\n");
    }
  if (CanMeasureInnerD)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CanMeasureInnerD");
      CanMeasureInnerD->printSelf(outFile);
      fprintf(outFile, "</CanMeasureInnerD>\n");
    }
  if (CanMeasureOuterD)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CanMeasureOuterD");
      CanMeasureOuterD->printSelf(outFile);
      fprintf(outFile, "</CanMeasureOuterD>\n");
    }
  if (CanMeasureDepth)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CanMeasureDepth");
      CanMeasureDepth->printSelf(outFile);
      fprintf(outFile, "</CanMeasureDepth>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CaliperType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CaliperType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CaliperType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CaliperType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CaliperType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LinearResolutionType * CaliperType::getLinearResolution()
{return LinearResolution;}

void CaliperType::setLinearResolution(LinearResolutionType * LinearResolutionIn)
{LinearResolution = LinearResolutionIn;}

NumericalLengthAccuracyType * CaliperType::getAccuracy()
{return Accuracy;}

void CaliperType::setAccuracy(NumericalLengthAccuracyType * AccuracyIn)
{Accuracy = AccuracyIn;}

XmlBoolean * CaliperType::getCanMeasureInnerD()
{return CanMeasureInnerD;}

void CaliperType::setCanMeasureInnerD(XmlBoolean * CanMeasureInnerDIn)
{CanMeasureInnerD = CanMeasureInnerDIn;}

XmlBoolean * CaliperType::getCanMeasureOuterD()
{return CanMeasureOuterD;}

void CaliperType::setCanMeasureOuterD(XmlBoolean * CanMeasureOuterDIn)
{CanMeasureOuterD = CanMeasureOuterDIn;}

XmlBoolean * CaliperType::getCanMeasureDepth()
{return CanMeasureDepth;}

void CaliperType::setCanMeasureDepth(XmlBoolean * CanMeasureDepthIn)
{CanMeasureDepth = CanMeasureDepthIn;}

/* ***************************************************************** */

/* class CapacitiveSensorType

*/

CapacitiveSensorType::CapacitiveSensorType() :
  DetachableSensorBaseType()
{
  MinOperatingVoltage = 0;
  MaxOperatingVoltage = 0;
  MinMeasuringDistance = 0;
  MaxMeasuringDistance = 0;
  TemperatureStability = 0;
  MinimumTargetDiameter = 0;
  HousingMaterial = 0;
  Mounting = 0;
}

CapacitiveSensorType::CapacitiveSensorType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 XmlString * ProtectionClassIn,
 XmlString * LinearityErrorIn,
 LinearValueType * RepeatabilityIn,
 XmlDecimal * SensitivityIn,
 LinearValueType * ResolutionIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 UserDefinedUnitValueType * MinOperatingVoltageIn,
 UserDefinedUnitValueType * MaxOperatingVoltageIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 UserDefinedUnitValueType * TemperatureStabilityIn,
 LinearValueType * MinimumTargetDiameterIn,
 XmlString * HousingMaterialIn,
 XmlString * MountingIn) :
  DetachableSensorBaseType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    ProtectionClassIn,
    LinearityErrorIn,
    RepeatabilityIn,
    SensitivityIn,
    ResolutionIn,
    EnvironmentalRangeIn)
{
  MinOperatingVoltage = MinOperatingVoltageIn;
  MaxOperatingVoltage = MaxOperatingVoltageIn;
  MinMeasuringDistance = MinMeasuringDistanceIn;
  MaxMeasuringDistance = MaxMeasuringDistanceIn;
  TemperatureStability = TemperatureStabilityIn;
  MinimumTargetDiameter = MinimumTargetDiameterIn;
  HousingMaterial = HousingMaterialIn;
  Mounting = MountingIn;
}

CapacitiveSensorType::CapacitiveSensorType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 XmlString * ProtectionClassIn,
 XmlString * LinearityErrorIn,
 LinearValueType * RepeatabilityIn,
 XmlDecimal * SensitivityIn,
 LinearValueType * ResolutionIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 UserDefinedUnitValueType * MinOperatingVoltageIn,
 UserDefinedUnitValueType * MaxOperatingVoltageIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 UserDefinedUnitValueType * TemperatureStabilityIn,
 LinearValueType * MinimumTargetDiameterIn,
 XmlString * HousingMaterialIn,
 XmlString * MountingIn) :
  DetachableSensorBaseType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    ProtectionClassIn,
    LinearityErrorIn,
    RepeatabilityIn,
    SensitivityIn,
    ResolutionIn,
    EnvironmentalRangeIn)
{
  MinOperatingVoltage = MinOperatingVoltageIn;
  MaxOperatingVoltage = MaxOperatingVoltageIn;
  MinMeasuringDistance = MinMeasuringDistanceIn;
  MaxMeasuringDistance = MaxMeasuringDistanceIn;
  TemperatureStability = TemperatureStabilityIn;
  MinimumTargetDiameter = MinimumTargetDiameterIn;
  HousingMaterial = HousingMaterialIn;
  Mounting = MountingIn;
}

CapacitiveSensorType::~CapacitiveSensorType()
{
  #ifndef NODESTRUCT
  delete MinOperatingVoltage;
  delete MaxOperatingVoltage;
  delete MinMeasuringDistance;
  delete MaxMeasuringDistance;
  delete TemperatureStability;
  delete MinimumTargetDiameter;
  delete HousingMaterial;
  delete Mounting;
  #endif
}

void CapacitiveSensorType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (ProtectionClass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProtectionClass");
      ProtectionClass->printSelf(outFile);
      fprintf(outFile, "</ProtectionClass>\n");
    }
  if (LinearityError)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LinearityError");
      LinearityError->printSelf(outFile);
      fprintf(outFile, "</LinearityError>\n");
    }
  if (Repeatability)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Repeatability");
      Repeatability->printSelf(outFile);
      fprintf(outFile, "</Repeatability>\n");
    }
  if (Sensitivity)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Sensitivity");
      Sensitivity->printSelf(outFile);
      fprintf(outFile, "</Sensitivity>\n");
    }
  if (Resolution)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Resolution");
      Resolution->printSelf(outFile);
      fprintf(outFile, "</Resolution>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (MinOperatingVoltage)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinOperatingVoltage");
      MinOperatingVoltage->printSelf(outFile);
      fprintf(outFile, "</MinOperatingVoltage>\n");
    }
  if (MaxOperatingVoltage)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxOperatingVoltage");
      MaxOperatingVoltage->printSelf(outFile);
      fprintf(outFile, "</MaxOperatingVoltage>\n");
    }
  if (MinMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinMeasuringDistance");
      MinMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MinMeasuringDistance>\n");
    }
  if (MaxMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxMeasuringDistance");
      MaxMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MaxMeasuringDistance>\n");
    }
  if (TemperatureStability)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TemperatureStability");
      TemperatureStability->printSelf(outFile);
      fprintf(outFile, "</TemperatureStability>\n");
    }
  if (MinimumTargetDiameter)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinimumTargetDiameter");
      MinimumTargetDiameter->printSelf(outFile);
      fprintf(outFile, "</MinimumTargetDiameter>\n");
    }
  if (HousingMaterial)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<HousingMaterial");
      HousingMaterial->printSelf(outFile);
      fprintf(outFile, "</HousingMaterial>\n");
    }
  if (Mounting)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mounting");
      Mounting->printSelf(outFile);
      fprintf(outFile, "</Mounting>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CapacitiveSensorType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CapacitiveSensorType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CapacitiveSensorType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CapacitiveSensorType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CapacitiveSensorType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

UserDefinedUnitValueType * CapacitiveSensorType::getMinOperatingVoltage()
{return MinOperatingVoltage;}

void CapacitiveSensorType::setMinOperatingVoltage(UserDefinedUnitValueType * MinOperatingVoltageIn)
{MinOperatingVoltage = MinOperatingVoltageIn;}

UserDefinedUnitValueType * CapacitiveSensorType::getMaxOperatingVoltage()
{return MaxOperatingVoltage;}

void CapacitiveSensorType::setMaxOperatingVoltage(UserDefinedUnitValueType * MaxOperatingVoltageIn)
{MaxOperatingVoltage = MaxOperatingVoltageIn;}

LinearValueType * CapacitiveSensorType::getMinMeasuringDistance()
{return MinMeasuringDistance;}

void CapacitiveSensorType::setMinMeasuringDistance(LinearValueType * MinMeasuringDistanceIn)
{MinMeasuringDistance = MinMeasuringDistanceIn;}

LinearValueType * CapacitiveSensorType::getMaxMeasuringDistance()
{return MaxMeasuringDistance;}

void CapacitiveSensorType::setMaxMeasuringDistance(LinearValueType * MaxMeasuringDistanceIn)
{MaxMeasuringDistance = MaxMeasuringDistanceIn;}

UserDefinedUnitValueType * CapacitiveSensorType::getTemperatureStability()
{return TemperatureStability;}

void CapacitiveSensorType::setTemperatureStability(UserDefinedUnitValueType * TemperatureStabilityIn)
{TemperatureStability = TemperatureStabilityIn;}

LinearValueType * CapacitiveSensorType::getMinimumTargetDiameter()
{return MinimumTargetDiameter;}

void CapacitiveSensorType::setMinimumTargetDiameter(LinearValueType * MinimumTargetDiameterIn)
{MinimumTargetDiameter = MinimumTargetDiameterIn;}

XmlString * CapacitiveSensorType::getHousingMaterial()
{return HousingMaterial;}

void CapacitiveSensorType::setHousingMaterial(XmlString * HousingMaterialIn)
{HousingMaterial = HousingMaterialIn;}

XmlString * CapacitiveSensorType::getMounting()
{return Mounting;}

void CapacitiveSensorType::setMounting(XmlString * MountingIn)
{Mounting = MountingIn;}

/* ***************************************************************** */

/* class CarriageType

*/

CarriageType::CarriageType() :
  MeasurementResourceBaseType()
{
  ToolIds = 0;
}

CarriageType::CarriageType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 ArrayReferenceType * ToolIdsIn) :
  MeasurementResourceBaseType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  ToolIds = ToolIdsIn;
}

CarriageType::CarriageType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 ArrayReferenceType * ToolIdsIn) :
  MeasurementResourceBaseType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  ToolIds = ToolIdsIn;
}

CarriageType::~CarriageType()
{
  #ifndef NODESTRUCT
  delete ToolIds;
  #endif
}

void CarriageType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (ToolIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToolIds");
      ToolIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ToolIds>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CarriageType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CarriageType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CarriageType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CarriageType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CarriageType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

ArrayReferenceType * CarriageType::getToolIds()
{return ToolIds;}

void CarriageType::setToolIds(ArrayReferenceType * ToolIdsIn)
{ToolIds = ToolIdsIn;}

/* ***************************************************************** */

/* class CarriageTypeLisd

*/

CarriageTypeLisd::CarriageTypeLisd() {}

CarriageTypeLisd::CarriageTypeLisd(CarriageType * aCarriageType)
{
  push_back(aCarriageType);
}

CarriageTypeLisd::~CarriageTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<CarriageType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void CarriageTypeLisd::printSelf(FILE * outFile)
{
  std::list<CarriageType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class CarriagesType

*/

CarriagesType::CarriagesType()
{
  n = 0;
  Carriage = 0;
}

CarriagesType::CarriagesType(
 CarriageTypeLisd * CarriageIn)
{
  n = 0;
  Carriage = CarriageIn;
}

CarriagesType::CarriagesType(
 NaturalType * nIn,
 CarriageTypeLisd * CarriageIn)
{
  n = nIn;
  Carriage = CarriageIn;
}

CarriagesType::~CarriagesType()
{
  #ifndef NODESTRUCT
  delete n;
  delete Carriage;
  #endif
}

void CarriagesType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!Carriage)
      {
        fprintf(stderr, "Carriage list is missing\n");
        exit(1);
      }
    if (Carriage->size() == 0)
      {
        fprintf(stderr, "Carriage list is empty\n");
        exit(1);
      }
    if (Carriage->size() < 2)
      {
        fprintf(stderr,
                "size of Carriage list (%d) less than minimum required (2)\n",
                (int)Carriage->size());
        exit(1);
      }
    std::list<CarriageType *>::iterator iter;
    for (iter = Carriage->begin();
         iter != Carriage->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<Carriage");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</Carriage>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool CarriagesType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in CarriagesType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in CarriagesType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CarriagesType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in CarriagesType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * CarriagesType::getn()
{return n;}

void CarriagesType::setn(NaturalType * nIn)
{n = nIn;}

CarriageTypeLisd * CarriagesType::getCarriage()
{return Carriage;}

void CarriagesType::setCarriage(CarriageTypeLisd * CarriageIn)
{Carriage = CarriageIn;}

/* ***************************************************************** */

/* class CartesianCMMAccuraciesType

*/

CartesianCMMAccuraciesType::CartesianCMMAccuraciesType()
{
  n = 0;
  CartesianCMMAccuracy = 0;
}

CartesianCMMAccuraciesType::CartesianCMMAccuraciesType(
 CartesianCMMAccuracyTypeLisd * CartesianCMMAccuracyIn)
{
  n = 0;
  CartesianCMMAccuracy = CartesianCMMAccuracyIn;
}

CartesianCMMAccuraciesType::CartesianCMMAccuraciesType(
 NaturalType * nIn,
 CartesianCMMAccuracyTypeLisd * CartesianCMMAccuracyIn)
{
  n = nIn;
  CartesianCMMAccuracy = CartesianCMMAccuracyIn;
}

CartesianCMMAccuraciesType::~CartesianCMMAccuraciesType()
{
  #ifndef NODESTRUCT
  delete n;
  delete CartesianCMMAccuracy;
  #endif
}

void CartesianCMMAccuraciesType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!CartesianCMMAccuracy)
      {
        fprintf(stderr, "CartesianCMMAccuracy list is missing\n");
        exit(1);
      }
    if (CartesianCMMAccuracy->size() == 0)
      {
        fprintf(stderr, "CartesianCMMAccuracy list is empty\n");
        exit(1);
      }
    if (CartesianCMMAccuracy->size() < 1)
      {
        fprintf(stderr,
                "size of CartesianCMMAccuracy list (%d) less than minimum required (1)\n",
                (int)CartesianCMMAccuracy->size());
        exit(1);
      }
    std::list<CartesianCMMAccuracyType *>::iterator iter;
    for (iter = CartesianCMMAccuracy->begin();
         iter != CartesianCMMAccuracy->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<CartesianCMMAccuracy");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</CartesianCMMAccuracy>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool CartesianCMMAccuraciesType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in CartesianCMMAccuraciesType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in CartesianCMMAccuraciesType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CartesianCMMAccuraciesType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in CartesianCMMAccuraciesType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * CartesianCMMAccuraciesType::getn()
{return n;}

void CartesianCMMAccuraciesType::setn(NaturalType * nIn)
{n = nIn;}

CartesianCMMAccuracyTypeLisd * CartesianCMMAccuraciesType::getCartesianCMMAccuracy()
{return CartesianCMMAccuracy;}

void CartesianCMMAccuraciesType::setCartesianCMMAccuracy(CartesianCMMAccuracyTypeLisd * CartesianCMMAccuracyIn)
{CartesianCMMAccuracy = CartesianCMMAccuracyIn;}

/* ***************************************************************** */

/* class CartesianCMMAccuracyType

*/

CartesianCMMAccuracyType::CartesianCMMAccuracyType() :
  MeasurementDeviceAccuracyBaseType()
{
  CartesianCMMAccuracyTest = 0;
  AccuracySource = 0;
}

CartesianCMMAccuracyType::CartesianCMMAccuracyType(
 EnvironmentalRangeType * EnvironmentalRangeIn,
 CMMAccuracyTestBaseType * CartesianCMMAccuracyTestIn,
 AccuracySourceType * AccuracySourceIn) :
  MeasurementDeviceAccuracyBaseType(
    EnvironmentalRangeIn)
{
  CartesianCMMAccuracyTest = CartesianCMMAccuracyTestIn;
  AccuracySource = AccuracySourceIn;
}

CartesianCMMAccuracyType::~CartesianCMMAccuracyType()
{
  #ifndef NODESTRUCT
  delete CartesianCMMAccuracyTest;
  delete AccuracySource;
  #endif
}

void CartesianCMMAccuracyType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<EnvironmentalRange");
  EnvironmentalRange->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</EnvironmentalRange>\n");
  {
    doSpaces(0, outFile);
    if (CartesianCMMAccuracyTest->getprintElement() == 0)
      {
        fprintf(stderr, "element name missing\n");
        exit(1);
      }
    else if (strcmp(CartesianCMMAccuracyTest->getprintElement(), "CartesianCMMFPSTest") == 0)
      {
        FPSTestType * typ;
        if ((typ = dynamic_cast<FPSTestType *>(CartesianCMMAccuracyTest)))
          {
            fprintf(outFile, "<CartesianCMMFPSTest");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</CartesianCMMFPSTest>\n");
          }
        else
          {
            fprintf(stderr, "bad CartesianCMMFPSTest element\n");
            exit(1);
          }
      }
    else if (strcmp(CartesianCMMAccuracyTest->getprintElement(), "CartesianCMMB89Test") == 0)
      {
        CartesianCMMB89TestType * typ;
        if ((typ = dynamic_cast<CartesianCMMB89TestType *>(CartesianCMMAccuracyTest)))
          {
            fprintf(outFile, "<CartesianCMMB89Test");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</CartesianCMMB89Test>\n");
          }
        else
          {
            fprintf(stderr, "bad CartesianCMMB89Test element\n");
            exit(1);
          }
      }
    else if (strcmp(CartesianCMMAccuracyTest->getprintElement(), "CartesianCMMISO10360Test") == 0)
      {
        ISO10360TestType * typ;
        if ((typ = dynamic_cast<ISO10360TestType *>(CartesianCMMAccuracyTest)))
          {
            fprintf(outFile, "<CartesianCMMISO10360Test");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</CartesianCMMISO10360Test>\n");
          }
        else
          {
            fprintf(stderr, "bad CartesianCMMISO10360Test element\n");
            exit(1);
          }
      }
    else if (strcmp(CartesianCMMAccuracyTest->getprintElement(), "CartesianCMMPointAccuracyTest") == 0)
      {
        PointAccuracyTestType * typ;
        if ((typ = dynamic_cast<PointAccuracyTestType *>(CartesianCMMAccuracyTest)))
          {
            fprintf(outFile, "<CartesianCMMPointAccuracyTest");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</CartesianCMMPointAccuracyTest>\n");
          }
        else
          {
            fprintf(stderr, "bad CartesianCMMPointAccuracyTest element\n");
            exit(1);
          }
      }
    else
      {
        fprintf(stderr, "bad CartesianCMMAccuracyTest type\n");
        fprintf(stderr, " exiting\n");
        exit(1);
      }
  }
  doSpaces(0, outFile);
  fprintf(outFile, "<AccuracySource");
  AccuracySource->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</AccuracySource>\n");
  doSpaces(-INDENT, outFile);
}

CMMAccuracyTestBaseType * CartesianCMMAccuracyType::getCartesianCMMAccuracyTest()
{return CartesianCMMAccuracyTest;}

void CartesianCMMAccuracyType::setCartesianCMMAccuracyTest(CMMAccuracyTestBaseType * CartesianCMMAccuracyTestIn)
{CartesianCMMAccuracyTest = CartesianCMMAccuracyTestIn;}

AccuracySourceType * CartesianCMMAccuracyType::getAccuracySource()
{return AccuracySource;}

void CartesianCMMAccuracyType::setAccuracySource(AccuracySourceType * AccuracySourceIn)
{AccuracySource = AccuracySourceIn;}

/* ***************************************************************** */

/* class CartesianCMMAccuracyTypeLisd

*/

CartesianCMMAccuracyTypeLisd::CartesianCMMAccuracyTypeLisd() {}

CartesianCMMAccuracyTypeLisd::CartesianCMMAccuracyTypeLisd(CartesianCMMAccuracyType * aCartesianCMMAccuracyType)
{
  push_back(aCartesianCMMAccuracyType);
}

CartesianCMMAccuracyTypeLisd::~CartesianCMMAccuracyTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<CartesianCMMAccuracyType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void CartesianCMMAccuracyTypeLisd::printSelf(FILE * outFile)
{
  std::list<CartesianCMMAccuracyType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class CartesianCMMAxisDirectionsType

*/

CartesianCMMAxisDirectionsType::CartesianCMMAxisDirectionsType() :
  CMMAxisDirectionsBaseType()
{
  XAxisDirection = 0;
  YAxisDirection = 0;
  ZAxisDirection = 0;
}

CartesianCMMAxisDirectionsType::CartesianCMMAxisDirectionsType(
 CMMDirectionEnumType * XAxisDirectionIn,
 CMMDirectionEnumType * YAxisDirectionIn,
 CMMDirectionEnumType * ZAxisDirectionIn) :
  CMMAxisDirectionsBaseType()
{
  XAxisDirection = XAxisDirectionIn;
  YAxisDirection = YAxisDirectionIn;
  ZAxisDirection = ZAxisDirectionIn;
}

CartesianCMMAxisDirectionsType::~CartesianCMMAxisDirectionsType()
{
  #ifndef NODESTRUCT
  delete XAxisDirection;
  delete YAxisDirection;
  delete ZAxisDirection;
  #endif
}

void CartesianCMMAxisDirectionsType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<XAxisDirection");
  XAxisDirection->printSelf(outFile);
  fprintf(outFile, "</XAxisDirection>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<YAxisDirection");
  YAxisDirection->printSelf(outFile);
  fprintf(outFile, "</YAxisDirection>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<ZAxisDirection");
  ZAxisDirection->printSelf(outFile);
  fprintf(outFile, "</ZAxisDirection>\n");
  doSpaces(-INDENT, outFile);
}

CMMDirectionEnumType * CartesianCMMAxisDirectionsType::getXAxisDirection()
{return XAxisDirection;}

void CartesianCMMAxisDirectionsType::setXAxisDirection(CMMDirectionEnumType * XAxisDirectionIn)
{XAxisDirection = XAxisDirectionIn;}

CMMDirectionEnumType * CartesianCMMAxisDirectionsType::getYAxisDirection()
{return YAxisDirection;}

void CartesianCMMAxisDirectionsType::setYAxisDirection(CMMDirectionEnumType * YAxisDirectionIn)
{YAxisDirection = YAxisDirectionIn;}

CMMDirectionEnumType * CartesianCMMAxisDirectionsType::getZAxisDirection()
{return ZAxisDirection;}

void CartesianCMMAxisDirectionsType::setZAxisDirection(CMMDirectionEnumType * ZAxisDirectionIn)
{ZAxisDirection = ZAxisDirectionIn;}

/* ***************************************************************** */

/* class CartesianCMMB89TestType

*/

CartesianCMMB89TestType::CartesianCMMB89TestType() :
  CMMAccuracyTestBaseType()
{
  XLinearAccuracy = 0;
  YLinearAccuracy = 0;
  ZLinearAccuracy = 0;
  OffsetVolumetricPerformance = 0;
  VolumetricPerformance = 0;
  Repeatability = 0;
}

CartesianCMMB89TestType::CartesianCMMB89TestType(
 LinearValueType * XLinearAccuracyIn,
 LinearValueType * YLinearAccuracyIn,
 LinearValueType * ZLinearAccuracyIn,
 LinearValueType * OffsetVolumetricPerformanceIn,
 LinearValueType * VolumetricPerformanceIn,
 LinearValueType * RepeatabilityIn) :
  CMMAccuracyTestBaseType()
{
  XLinearAccuracy = XLinearAccuracyIn;
  YLinearAccuracy = YLinearAccuracyIn;
  ZLinearAccuracy = ZLinearAccuracyIn;
  OffsetVolumetricPerformance = OffsetVolumetricPerformanceIn;
  VolumetricPerformance = VolumetricPerformanceIn;
  Repeatability = RepeatabilityIn;
}

CartesianCMMB89TestType::~CartesianCMMB89TestType()
{
  #ifndef NODESTRUCT
  delete XLinearAccuracy;
  delete YLinearAccuracy;
  delete ZLinearAccuracy;
  delete OffsetVolumetricPerformance;
  delete VolumetricPerformance;
  delete Repeatability;
  #endif
}

void CartesianCMMB89TestType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<XLinearAccuracy");
  XLinearAccuracy->printSelf(outFile);
  fprintf(outFile, "</XLinearAccuracy>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<YLinearAccuracy");
  YLinearAccuracy->printSelf(outFile);
  fprintf(outFile, "</YLinearAccuracy>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<ZLinearAccuracy");
  ZLinearAccuracy->printSelf(outFile);
  fprintf(outFile, "</ZLinearAccuracy>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<OffsetVolumetricPerformance");
  OffsetVolumetricPerformance->printSelf(outFile);
  fprintf(outFile, "</OffsetVolumetricPerformance>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<VolumetricPerformance");
  VolumetricPerformance->printSelf(outFile);
  fprintf(outFile, "</VolumetricPerformance>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Repeatability");
  Repeatability->printSelf(outFile);
  fprintf(outFile, "</Repeatability>\n");
  doSpaces(-INDENT, outFile);
}

LinearValueType * CartesianCMMB89TestType::getXLinearAccuracy()
{return XLinearAccuracy;}

void CartesianCMMB89TestType::setXLinearAccuracy(LinearValueType * XLinearAccuracyIn)
{XLinearAccuracy = XLinearAccuracyIn;}

LinearValueType * CartesianCMMB89TestType::getYLinearAccuracy()
{return YLinearAccuracy;}

void CartesianCMMB89TestType::setYLinearAccuracy(LinearValueType * YLinearAccuracyIn)
{YLinearAccuracy = YLinearAccuracyIn;}

LinearValueType * CartesianCMMB89TestType::getZLinearAccuracy()
{return ZLinearAccuracy;}

void CartesianCMMB89TestType::setZLinearAccuracy(LinearValueType * ZLinearAccuracyIn)
{ZLinearAccuracy = ZLinearAccuracyIn;}

LinearValueType * CartesianCMMB89TestType::getOffsetVolumetricPerformance()
{return OffsetVolumetricPerformance;}

void CartesianCMMB89TestType::setOffsetVolumetricPerformance(LinearValueType * OffsetVolumetricPerformanceIn)
{OffsetVolumetricPerformance = OffsetVolumetricPerformanceIn;}

LinearValueType * CartesianCMMB89TestType::getVolumetricPerformance()
{return VolumetricPerformance;}

void CartesianCMMB89TestType::setVolumetricPerformance(LinearValueType * VolumetricPerformanceIn)
{VolumetricPerformance = VolumetricPerformanceIn;}

LinearValueType * CartesianCMMB89TestType::getRepeatability()
{return Repeatability;}

void CartesianCMMB89TestType::setRepeatability(LinearValueType * RepeatabilityIn)
{Repeatability = RepeatabilityIn;}

/* ***************************************************************** */

/* class CartesianCMMGeometryEnumType

*/

CartesianCMMGeometryEnumType::CartesianCMMGeometryEnumType() :
  XmlNMTOKEN()
{
}

CartesianCMMGeometryEnumType::CartesianCMMGeometryEnumType(
 const char * valIn) :
  XmlNMTOKEN(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "FIXED_BRIDGE") &&
           strcmp(val.c_str(), "MOVING_BRIDGE") &&
           strcmp(val.c_str(), "L_SHAPED_BRIDGE") &&
           strcmp(val.c_str(), "COLUMN") &&
           strcmp(val.c_str(), "FIXED_TABLE_CANTILEVER_ARM") &&
           strcmp(val.c_str(), "MOVING_TABLE_CANTILEVER_ARM") &&
           strcmp(val.c_str(), "FIXED_TABLE_HORIZONTAL_ARM") &&
           strcmp(val.c_str(), "MOVING_TABLE_HORIZONTAL_ARM") &&
           strcmp(val.c_str(), "MOVING_RAM_HORIZONTAL_ARM") &&
           strcmp(val.c_str(), "GANTRY"));
}

CartesianCMMGeometryEnumType::~CartesianCMMGeometryEnumType() {}

bool CartesianCMMGeometryEnumType::CartesianCMMGeometryEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "FIXED_BRIDGE") &&
          strcmp(val.c_str(), "MOVING_BRIDGE") &&
          strcmp(val.c_str(), "L_SHAPED_BRIDGE") &&
          strcmp(val.c_str(), "COLUMN") &&
          strcmp(val.c_str(), "FIXED_TABLE_CANTILEVER_ARM") &&
          strcmp(val.c_str(), "MOVING_TABLE_CANTILEVER_ARM") &&
          strcmp(val.c_str(), "FIXED_TABLE_HORIZONTAL_ARM") &&
          strcmp(val.c_str(), "MOVING_TABLE_HORIZONTAL_ARM") &&
          strcmp(val.c_str(), "MOVING_RAM_HORIZONTAL_ARM") &&
          strcmp(val.c_str(), "GANTRY"));
}

void CartesianCMMGeometryEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "CartesianCMMGeometryEnumType");
}

void CartesianCMMGeometryEnumType::printSelf(FILE * outFile)
{
  if (CartesianCMMGeometryEnumTypeIsBad())
    {
      fprintf(stderr, "bad CartesianCMMGeometryEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::printSelf(outFile);
}

void CartesianCMMGeometryEnumType::oPrintSelf(FILE * outFile)
{
  if (CartesianCMMGeometryEnumTypeIsBad())
    {
      fprintf(stderr, "bad CartesianCMMGeometryEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class CartesianCMMGeometryType

*/

CartesianCMMGeometryType::CartesianCMMGeometryType()
{
  CartesianCMMGeometryTypePair = 0;
}

CartesianCMMGeometryType::CartesianCMMGeometryType(
 CartesianCMMGeometryTypeChoicePair * CartesianCMMGeometryTypePairIn)
{
  CartesianCMMGeometryTypePair = CartesianCMMGeometryTypePairIn;
}

CartesianCMMGeometryType::~CartesianCMMGeometryType()
{
  #ifndef NODESTRUCT
  delete CartesianCMMGeometryTypePair;
  #endif
}

void CartesianCMMGeometryType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  CartesianCMMGeometryTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

CartesianCMMGeometryTypeChoicePair * CartesianCMMGeometryType::getCartesianCMMGeometryTypePair()
{return CartesianCMMGeometryTypePair;}

void CartesianCMMGeometryType::setCartesianCMMGeometryTypePair(CartesianCMMGeometryTypeChoicePair * CartesianCMMGeometryTypePairIn)
{CartesianCMMGeometryTypePair = CartesianCMMGeometryTypePairIn;}
CartesianCMMGeometryTypeChoicePair::CartesianCMMGeometryTypeChoicePair() {}

CartesianCMMGeometryTypeChoicePair::CartesianCMMGeometryTypeChoicePair(
 whichOne CartesianCMMGeometryTypeTypeIn,
 CartesianCMMGeometryTypeVal CartesianCMMGeometryTypeValueIn)
{
  CartesianCMMGeometryTypeType = CartesianCMMGeometryTypeTypeIn;
  CartesianCMMGeometryTypeValue = CartesianCMMGeometryTypeValueIn;
}

CartesianCMMGeometryTypeChoicePair::~CartesianCMMGeometryTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (CartesianCMMGeometryTypeType == CartesianCMMGeometryEnumE)
    delete CartesianCMMGeometryTypeValue.CartesianCMMGeometryEnum;
  else if (CartesianCMMGeometryTypeType == OtherCartesianCMMGeometryE)
    delete CartesianCMMGeometryTypeValue.OtherCartesianCMMGeometry;
  #endif
}

void CartesianCMMGeometryTypeChoicePair::printSelf(FILE * outFile)
{
  if (CartesianCMMGeometryTypeType == CartesianCMMGeometryEnumE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CartesianCMMGeometryEnum");
      CartesianCMMGeometryTypeValue.CartesianCMMGeometryEnum->printSelf(outFile);
      fprintf(outFile, "</CartesianCMMGeometryEnum>\n");
    }
  else if (CartesianCMMGeometryTypeType == OtherCartesianCMMGeometryE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OtherCartesianCMMGeometry");
      CartesianCMMGeometryTypeValue.OtherCartesianCMMGeometry->printSelf(outFile);
      fprintf(outFile, "</OtherCartesianCMMGeometry>\n");
    }
}

/* ***************************************************************** */

/* class CartesianCMMSpeedsType

*/

CartesianCMMSpeedsType::CartesianCMMSpeedsType() :
  CMMSpeedsBaseType()
{
  MaxXTraverseSpeed = 0;
  MaxYTraverseSpeed = 0;
  MaxZTraverseSpeed = 0;
  MaxXProbingSpeed = 0;
  MaxYProbingSpeed = 0;
  MaxZProbingSpeed = 0;
}

CartesianCMMSpeedsType::CartesianCMMSpeedsType(
 SpeedValueType * MaxXTraverseSpeedIn,
 SpeedValueType * MaxYTraverseSpeedIn,
 SpeedValueType * MaxZTraverseSpeedIn,
 SpeedValueType * MaxXProbingSpeedIn,
 SpeedValueType * MaxYProbingSpeedIn,
 SpeedValueType * MaxZProbingSpeedIn) :
  CMMSpeedsBaseType()
{
  MaxXTraverseSpeed = MaxXTraverseSpeedIn;
  MaxYTraverseSpeed = MaxYTraverseSpeedIn;
  MaxZTraverseSpeed = MaxZTraverseSpeedIn;
  MaxXProbingSpeed = MaxXProbingSpeedIn;
  MaxYProbingSpeed = MaxYProbingSpeedIn;
  MaxZProbingSpeed = MaxZProbingSpeedIn;
}

CartesianCMMSpeedsType::~CartesianCMMSpeedsType()
{
  #ifndef NODESTRUCT
  delete MaxXTraverseSpeed;
  delete MaxYTraverseSpeed;
  delete MaxZTraverseSpeed;
  delete MaxXProbingSpeed;
  delete MaxYProbingSpeed;
  delete MaxZProbingSpeed;
  #endif
}

void CartesianCMMSpeedsType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (MaxXTraverseSpeed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxXTraverseSpeed");
      MaxXTraverseSpeed->printSelf(outFile);
      fprintf(outFile, "</MaxXTraverseSpeed>\n");
    }
  if (MaxYTraverseSpeed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxYTraverseSpeed");
      MaxYTraverseSpeed->printSelf(outFile);
      fprintf(outFile, "</MaxYTraverseSpeed>\n");
    }
  if (MaxZTraverseSpeed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxZTraverseSpeed");
      MaxZTraverseSpeed->printSelf(outFile);
      fprintf(outFile, "</MaxZTraverseSpeed>\n");
    }
  if (MaxXProbingSpeed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxXProbingSpeed");
      MaxXProbingSpeed->printSelf(outFile);
      fprintf(outFile, "</MaxXProbingSpeed>\n");
    }
  if (MaxYProbingSpeed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxYProbingSpeed");
      MaxYProbingSpeed->printSelf(outFile);
      fprintf(outFile, "</MaxYProbingSpeed>\n");
    }
  if (MaxZProbingSpeed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxZProbingSpeed");
      MaxZProbingSpeed->printSelf(outFile);
      fprintf(outFile, "</MaxZProbingSpeed>\n");
    }
  doSpaces(-INDENT, outFile);
}

SpeedValueType * CartesianCMMSpeedsType::getMaxXTraverseSpeed()
{return MaxXTraverseSpeed;}

void CartesianCMMSpeedsType::setMaxXTraverseSpeed(SpeedValueType * MaxXTraverseSpeedIn)
{MaxXTraverseSpeed = MaxXTraverseSpeedIn;}

SpeedValueType * CartesianCMMSpeedsType::getMaxYTraverseSpeed()
{return MaxYTraverseSpeed;}

void CartesianCMMSpeedsType::setMaxYTraverseSpeed(SpeedValueType * MaxYTraverseSpeedIn)
{MaxYTraverseSpeed = MaxYTraverseSpeedIn;}

SpeedValueType * CartesianCMMSpeedsType::getMaxZTraverseSpeed()
{return MaxZTraverseSpeed;}

void CartesianCMMSpeedsType::setMaxZTraverseSpeed(SpeedValueType * MaxZTraverseSpeedIn)
{MaxZTraverseSpeed = MaxZTraverseSpeedIn;}

SpeedValueType * CartesianCMMSpeedsType::getMaxXProbingSpeed()
{return MaxXProbingSpeed;}

void CartesianCMMSpeedsType::setMaxXProbingSpeed(SpeedValueType * MaxXProbingSpeedIn)
{MaxXProbingSpeed = MaxXProbingSpeedIn;}

SpeedValueType * CartesianCMMSpeedsType::getMaxYProbingSpeed()
{return MaxYProbingSpeed;}

void CartesianCMMSpeedsType::setMaxYProbingSpeed(SpeedValueType * MaxYProbingSpeedIn)
{MaxYProbingSpeed = MaxYProbingSpeedIn;}

SpeedValueType * CartesianCMMSpeedsType::getMaxZProbingSpeed()
{return MaxZProbingSpeed;}

void CartesianCMMSpeedsType::setMaxZProbingSpeed(SpeedValueType * MaxZProbingSpeedIn)
{MaxZProbingSpeed = MaxZProbingSpeedIn;}

/* ***************************************************************** */

/* class CartesianCMMType

*/

CartesianCMMType::CartesianCMMType() :
  CMMType()
{
  HomeLocation = 0;
  CMMGeometry = 0;
  CMMAxisDirections = 0;
  Scales = 0;
  MaxWorkpieceHeight = 0;
  MaxWorkpieceMass = 0;
  JoystickSpeeds = 0;
  CMMSpeeds = 0;
  RotaryTable = 0;
  Accuracies = 0;
  ToolIds = 0;
  SensorIds = 0;
}

CartesianCMMType::CartesianCMMType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 ResolutionBaseType * ResolutionIn,
 WorkingVolumeBaseType * WorkingVolumeIn,
 EffectiveWorkingVolumeBaseType * EffectiveWorkingVolumeIn,
 TemperatureCompensationType * TemperatureCompensationIn,
 PointType * HomeLocationIn,
 CartesianCMMGeometryType * CMMGeometryIn,
 CMMAxisDirectionsBaseType * CMMAxisDirectionsIn,
 MeasurementDeviceScalesBaseType * ScalesIn,
 LinearValueType * MaxWorkpieceHeightIn,
 MassValueType * MaxWorkpieceMassIn,
 CartesianCMMSpeedsType * JoystickSpeedsIn,
 CMMSpeedsBaseType * CMMSpeedsIn,
 RotaryTableType * RotaryTableIn,
 CartesianCMMAccuraciesType * AccuraciesIn,
 ArrayReferenceType * ToolIdsIn,
 ArrayReferenceType * SensorIdsIn) :
  CMMType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    ResolutionIn,
    WorkingVolumeIn,
    EffectiveWorkingVolumeIn,
    TemperatureCompensationIn)
{
  HomeLocation = HomeLocationIn;
  CMMGeometry = CMMGeometryIn;
  CMMAxisDirections = CMMAxisDirectionsIn;
  Scales = ScalesIn;
  MaxWorkpieceHeight = MaxWorkpieceHeightIn;
  MaxWorkpieceMass = MaxWorkpieceMassIn;
  JoystickSpeeds = JoystickSpeedsIn;
  CMMSpeeds = CMMSpeedsIn;
  RotaryTable = RotaryTableIn;
  Accuracies = AccuraciesIn;
  ToolIds = ToolIdsIn;
  SensorIds = SensorIdsIn;
}

CartesianCMMType::CartesianCMMType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 ResolutionBaseType * ResolutionIn,
 WorkingVolumeBaseType * WorkingVolumeIn,
 EffectiveWorkingVolumeBaseType * EffectiveWorkingVolumeIn,
 TemperatureCompensationType * TemperatureCompensationIn,
 PointType * HomeLocationIn,
 CartesianCMMGeometryType * CMMGeometryIn,
 CMMAxisDirectionsBaseType * CMMAxisDirectionsIn,
 MeasurementDeviceScalesBaseType * ScalesIn,
 LinearValueType * MaxWorkpieceHeightIn,
 MassValueType * MaxWorkpieceMassIn,
 CartesianCMMSpeedsType * JoystickSpeedsIn,
 CMMSpeedsBaseType * CMMSpeedsIn,
 RotaryTableType * RotaryTableIn,
 CartesianCMMAccuraciesType * AccuraciesIn,
 ArrayReferenceType * ToolIdsIn,
 ArrayReferenceType * SensorIdsIn) :
  CMMType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    ResolutionIn,
    WorkingVolumeIn,
    EffectiveWorkingVolumeIn,
    TemperatureCompensationIn)
{
  HomeLocation = HomeLocationIn;
  CMMGeometry = CMMGeometryIn;
  CMMAxisDirections = CMMAxisDirectionsIn;
  Scales = ScalesIn;
  MaxWorkpieceHeight = MaxWorkpieceHeightIn;
  MaxWorkpieceMass = MaxWorkpieceMassIn;
  JoystickSpeeds = JoystickSpeedsIn;
  CMMSpeeds = CMMSpeedsIn;
  RotaryTable = RotaryTableIn;
  Accuracies = AccuraciesIn;
  ToolIds = ToolIdsIn;
  SensorIds = SensorIdsIn;
}

CartesianCMMType::~CartesianCMMType()
{
  #ifndef NODESTRUCT
  delete HomeLocation;
  delete CMMGeometry;
  delete CMMAxisDirections;
  delete Scales;
  delete MaxWorkpieceHeight;
  delete MaxWorkpieceMass;
  delete JoystickSpeeds;
  delete CMMSpeeds;
  delete RotaryTable;
  delete Accuracies;
  delete ToolIds;
  delete SensorIds;
  #endif
}

void CartesianCMMType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Calibrations)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Calibrations");
      Calibrations->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Calibrations>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (Resolution)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (Resolution->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(Resolution->getprintElement(), "LinearResolution") == 0)
          {
            LinearResolutionType * typ;
            if ((typ = dynamic_cast<LinearResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<LinearResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LinearResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad LinearResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "CartesianResolution") == 0)
          {
            CartesianResolutionType * typ;
            if ((typ = dynamic_cast<CartesianResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<CartesianResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "SphericalResolution") == 0)
          {
            SphericalResolutionType * typ;
            if ((typ = dynamic_cast<SphericalResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<SphericalResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "UserDefinedResolution") == 0)
          {
            UserDefinedResolutionType * typ;
            if ((typ = dynamic_cast<UserDefinedResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<UserDefinedResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedResolution element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad Resolution type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (WorkingVolume)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (WorkingVolume->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(WorkingVolume->getprintElement(), "ClosedShellSetWorkingVolume") == 0)
          {
            ClosedShellSetWorkingVolumeType * typ;
            if ((typ = dynamic_cast<ClosedShellSetWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<ClosedShellSetWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ClosedShellSetWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad ClosedShellSetWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "CartesianWorkingVolume") == 0)
          {
            CartesianWorkingVolumeType * typ;
            if ((typ = dynamic_cast<CartesianWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<CartesianWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "SphericalWorkingVolume") == 0)
          {
            SphericalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<SphericalWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<SphericalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "CylindricalWorkingVolume") == 0)
          {
            CylindricalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<CylindricalWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<CylindricalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CylindricalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad CylindricalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "UserDefinedWorkingVolume") == 0)
          {
            UserDefinedWorkingVolumeType * typ;
            if ((typ = dynamic_cast<UserDefinedWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<UserDefinedWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedWorkingVolume element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad WorkingVolume type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (EffectiveWorkingVolume)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (EffectiveWorkingVolume->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveClosedShellSetWorkingVolume") == 0)
          {
            EffectiveClosedShellSetWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveClosedShellSetWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveClosedShellSetWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveClosedShellSetWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveClosedShellSetWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveCartesianWorkingVolume") == 0)
          {
            EffectiveCartesianWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveCartesianWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveCartesianWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveCartesianWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveCartesianWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveSphericalWorkingVolume") == 0)
          {
            EffectiveSphericalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveSphericalWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveSphericalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveSphericalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveSphericalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveCylindricalWorkingVolume") == 0)
          {
            EffectiveCylindricalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveCylindricalWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveCylindricalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveCylindricalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveCylindricalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveUserDefinedWorkingVolume") == 0)
          {
            EffectiveUserDefinedWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveUserDefinedWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveUserDefinedWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveUserDefinedWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveUserDefinedWorkingVolume element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad EffectiveWorkingVolume type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (TemperatureCompensation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TemperatureCompensation");
      TemperatureCompensation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</TemperatureCompensation>\n");
    }
  if (HomeLocation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<HomeLocation");
      HomeLocation->printSelf(outFile);
      fprintf(outFile, "</HomeLocation>\n");
    }
  if (CMMGeometry)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CMMGeometry");
      CMMGeometry->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CMMGeometry>\n");
    }
  if (CMMAxisDirections)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (CMMAxisDirections->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(CMMAxisDirections->getprintElement(), "CartesianCMMAxisDirections") == 0)
          {
            CartesianCMMAxisDirectionsType * typ;
            if ((typ = dynamic_cast<CartesianCMMAxisDirectionsType *>(CMMAxisDirections)))
              {
                fprintf(outFile, "<CartesianCMMAxisDirections");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianCMMAxisDirections>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianCMMAxisDirections element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad CMMAxisDirections type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (Scales)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (Scales->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(Scales->getprintElement(), "CartesianMeasurementDeviceScales") == 0)
          {
            CartesianMeasurementDeviceScalesType * typ;
            if ((typ = dynamic_cast<CartesianMeasurementDeviceScalesType *>(Scales)))
              {
                fprintf(outFile, "<CartesianMeasurementDeviceScales");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianMeasurementDeviceScales>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianMeasurementDeviceScales element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad Scales type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (MaxWorkpieceHeight)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxWorkpieceHeight");
      MaxWorkpieceHeight->printSelf(outFile);
      fprintf(outFile, "</MaxWorkpieceHeight>\n");
    }
  if (MaxWorkpieceMass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxWorkpieceMass");
      MaxWorkpieceMass->printSelf(outFile);
      fprintf(outFile, "</MaxWorkpieceMass>\n");
    }
  if (JoystickSpeeds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<JoystickSpeeds");
      JoystickSpeeds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</JoystickSpeeds>\n");
    }
  if (CMMSpeeds)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (CMMSpeeds->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(CMMSpeeds->getprintElement(), "CartesianCMMSpeeds") == 0)
          {
            CartesianCMMSpeedsType * typ;
            if ((typ = dynamic_cast<CartesianCMMSpeedsType *>(CMMSpeeds)))
              {
                fprintf(outFile, "<CartesianCMMSpeeds");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianCMMSpeeds>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianCMMSpeeds element\n");
                exit(1);
              }
          }
        else if (strcmp(CMMSpeeds->getprintElement(), "ParallelLinkCMMSpeeds") == 0)
          {
            ParallelLinkCMMSpeedsType * typ;
            if ((typ = dynamic_cast<ParallelLinkCMMSpeedsType *>(CMMSpeeds)))
              {
                fprintf(outFile, "<ParallelLinkCMMSpeeds");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ParallelLinkCMMSpeeds>\n");
              }
            else
              {
                fprintf(stderr, "bad ParallelLinkCMMSpeeds element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad CMMSpeeds type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (RotaryTable)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<RotaryTable");
      RotaryTable->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</RotaryTable>\n");
    }
  if (Accuracies)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Accuracies");
      Accuracies->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Accuracies>\n");
    }
  if (ToolIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToolIds");
      ToolIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ToolIds>\n");
    }
  if (SensorIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SensorIds");
      SensorIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SensorIds>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool CartesianCMMType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CartesianCMMType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CartesianCMMType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CartesianCMMType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in CartesianCMMType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

PointType * CartesianCMMType::getHomeLocation()
{return HomeLocation;}

void CartesianCMMType::setHomeLocation(PointType * HomeLocationIn)
{HomeLocation = HomeLocationIn;}

CartesianCMMGeometryType * CartesianCMMType::getCMMGeometry()
{return CMMGeometry;}

void CartesianCMMType::setCMMGeometry(CartesianCMMGeometryType * CMMGeometryIn)
{CMMGeometry = CMMGeometryIn;}

CMMAxisDirectionsBaseType * CartesianCMMType::getCMMAxisDirections()
{return CMMAxisDirections;}

void CartesianCMMType::setCMMAxisDirections(CMMAxisDirectionsBaseType * CMMAxisDirectionsIn)
{CMMAxisDirections = CMMAxisDirectionsIn;}

MeasurementDeviceScalesBaseType * CartesianCMMType::getScales()
{return Scales;}

void CartesianCMMType::setScales(MeasurementDeviceScalesBaseType * ScalesIn)
{Scales = ScalesIn;}

LinearValueType * CartesianCMMType::getMaxWorkpieceHeight()
{return MaxWorkpieceHeight;}

void CartesianCMMType::setMaxWorkpieceHeight(LinearValueType * MaxWorkpieceHeightIn)
{MaxWorkpieceHeight = MaxWorkpieceHeightIn;}

MassValueType * CartesianCMMType::getMaxWorkpieceMass()
{return MaxWorkpieceMass;}

void CartesianCMMType::setMaxWorkpieceMass(MassValueType * MaxWorkpieceMassIn)
{MaxWorkpieceMass = MaxWorkpieceMassIn;}

CartesianCMMSpeedsType * CartesianCMMType::getJoystickSpeeds()
{return JoystickSpeeds;}

void CartesianCMMType::setJoystickSpeeds(CartesianCMMSpeedsType * JoystickSpeedsIn)
{JoystickSpeeds = JoystickSpeedsIn;}

CMMSpeedsBaseType * CartesianCMMType::getCMMSpeeds()
{return CMMSpeeds;}

void CartesianCMMType::setCMMSpeeds(CMMSpeedsBaseType * CMMSpeedsIn)
{CMMSpeeds = CMMSpeedsIn;}

RotaryTableType * CartesianCMMType::getRotaryTable()
{return RotaryTable;}

void CartesianCMMType::setRotaryTable(RotaryTableType * RotaryTableIn)
{RotaryTable = RotaryTableIn;}

CartesianCMMAccuraciesType * CartesianCMMType::getAccuracies()
{return Accuracies;}

void CartesianCMMType::setAccuracies(CartesianCMMAccuraciesType * AccuraciesIn)
{Accuracies = AccuraciesIn;}

ArrayReferenceType * CartesianCMMType::getToolIds()
{return ToolIds;}

void CartesianCMMType::setToolIds(ArrayReferenceType * ToolIdsIn)
{ToolIds = ToolIdsIn;}

ArrayReferenceType * CartesianCMMType::getSensorIds()
{return SensorIds;}

void CartesianCMMType::setSensorIds(ArrayReferenceType * SensorIdsIn)
{SensorIds = SensorIdsIn;}

/* ***************************************************************** */

/* class CartesianMeasurementDeviceScalesType

*/

CartesianMeasurementDeviceScalesType::CartesianMeasurementDeviceScalesType() :
  MeasurementDeviceScalesBaseType()
{
  XScale = 0;
  YScale = 0;
  ZScale = 0;
}

CartesianMeasurementDeviceScalesType::CartesianMeasurementDeviceScalesType(
 MeasurementDeviceScaleType * XScaleIn,
 MeasurementDeviceScaleType * YScaleIn,
 MeasurementDeviceScaleType * ZScaleIn) :
  MeasurementDeviceScalesBaseType()
{
  XScale = XScaleIn;
  YScale = YScaleIn;
  ZScale = ZScaleIn;
}

CartesianMeasurementDeviceScalesType::~CartesianMeasurementDeviceScalesType()
{
  #ifndef NODESTRUCT
  delete XScale;
  delete YScale;
  delete ZScale;
  #endif
}

void CartesianMeasurementDeviceScalesType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<XScale");
  XScale->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</XScale>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<YScale");
  YScale->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</YScale>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<ZScale");
  ZScale->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ZScale>\n");
  doSpaces(-INDENT, outFile);
}

MeasurementDeviceScaleType * CartesianMeasurementDeviceScalesType::getXScale()
{return XScale;}

void CartesianMeasurementDeviceScalesType::setXScale(MeasurementDeviceScaleType * XScaleIn)
{XScale = XScaleIn;}

MeasurementDeviceScaleType * CartesianMeasurementDeviceScalesType::getYScale()
{return YScale;}

void CartesianMeasurementDeviceScalesType::setYScale(MeasurementDeviceScaleType * YScaleIn)
{YScale = YScaleIn;}

MeasurementDeviceScaleType * CartesianMeasurementDeviceScalesType::getZScale()
{return ZScale;}

void CartesianMeasurementDeviceScalesType::setZScale(MeasurementDeviceScaleType * ZScaleIn)
{ZScale = ZScaleIn;}

/* ***************************************************************** */

/* class CartesianResolutionType

*/

CartesianResolutionType::CartesianResolutionType() :
  ResolutionBaseType()
{
  CartesianResolutionTypePair = 0;
}

CartesianResolutionType::CartesianResolutionType(
 CartesianResolutionTypeChoicePair * CartesianResolutionTypePairIn) :
  ResolutionBaseType()
{
  CartesianResolutionTypePair = CartesianResolutionTypePairIn;
}

CartesianResolutionType::~CartesianResolutionType()
{
  #ifndef NODESTRUCT
  delete CartesianResolutionTypePair;
  #endif
}

void CartesianResolutionType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  CartesianResolutionTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}
CartesianResolutionTypeChoicePair * CartesianResolutionType::getCartesianResolutionTypeChoicePair()
{return CartesianResolutionTypePair;}

void CartesianResolutionType::setCartesianResolutionTypeChoicePair(CartesianResolutionTypeChoicePair * CartesianResolutionTypePairIn)
{CartesianResolutionTypePair = CartesianResolutionTypePairIn;}

/* ***************************************************************** */

CartesianResolutionTypeChoicePair::CartesianResolutionTypeChoicePair() {}

CartesianResolutionTypeChoicePair::CartesianResolutionTypeChoicePair(
 whichOne CartesianResolutionTypeTypeIn,
 CartesianResolutionTypeVal CartesianResolutionTypeValueIn)
{
  CartesianResolutionTypeType = CartesianResolutionTypeTypeIn;
  CartesianResolutionTypeValue = CartesianResolutionTypeValueIn;
}

CartesianResolutionTypeChoicePair::~CartesianResolutionTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (CartesianResolutionTypeType == CartesianResolu_1195E)
    delete CartesianResolutionTypeValue.CartesianResolu_1195;
  else if (CartesianResolutionTypeType == XYZResolutionE)
    delete CartesianResolutionTypeValue.XYZResolution;
  #endif
}

void CartesianResolutionTypeChoicePair::printSelf(FILE * outFile)
{
  if (CartesianResolutionTypeType == CartesianResolu_1195E)
    {
      CartesianResolutionTypeValue.CartesianResolu_1195->printSelf(outFile);
    }
  else if (CartesianResolutionTypeType == XYZResolutionE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<XYZResolution");
      CartesianResolutionTypeValue.XYZResolution->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</XYZResolution>\n");
    }
}

/* ***************************************************************** */

/* class CartesianWorkingVolumeType

*/

CartesianWorkingVolumeType::CartesianWorkingVolumeType() :
  WorkingVolumeBaseType()
{
  XAxisLength = 0;
  YAxisLength = 0;
  ZAxisLength = 0;
}

CartesianWorkingVolumeType::CartesianWorkingVolumeType(
 LinearValueType * XAxisLengthIn,
 LinearValueType * YAxisLengthIn,
 LinearValueType * ZAxisLengthIn) :
  WorkingVolumeBaseType()
{
  XAxisLength = XAxisLengthIn;
  YAxisLength = YAxisLengthIn;
  ZAxisLength = ZAxisLengthIn;
}

CartesianWorkingVolumeType::~CartesianWorkingVolumeType()
{
  #ifndef NODESTRUCT
  delete XAxisLength;
  delete YAxisLength;
  delete ZAxisLength;
  #endif
}

void CartesianWorkingVolumeType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (XAxisLength)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<XAxisLength");
      XAxisLength->printSelf(outFile);
      fprintf(outFile, "</XAxisLength>\n");
    }
  if (YAxisLength)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<YAxisLength");
      YAxisLength->printSelf(outFile);
      fprintf(outFile, "</YAxisLength>\n");
    }
  if (ZAxisLength)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ZAxisLength");
      ZAxisLength->printSelf(outFile);
      fprintf(outFile, "</ZAxisLength>\n");
    }
  doSpaces(-INDENT, outFile);
}

LinearValueType * CartesianWorkingVolumeType::getXAxisLength()
{return XAxisLength;}

void CartesianWorkingVolumeType::setXAxisLength(LinearValueType * XAxisLengthIn)
{XAxisLength = XAxisLengthIn;}

LinearValueType * CartesianWorkingVolumeType::getYAxisLength()
{return YAxisLength;}

void CartesianWorkingVolumeType::setYAxisLength(LinearValueType * YAxisLengthIn)
{YAxisLength = YAxisLengthIn;}

LinearValueType * CartesianWorkingVolumeType::getZAxisLength()
{return ZAxisLength;}

void CartesianWorkingVolumeType::setZAxisLength(LinearValueType * ZAxisLengthIn)
{ZAxisLength = ZAxisLengthIn;}

/* ***************************************************************** */

/* class ChargeCoupledDeviceCameraSensorType

*/

ChargeCoupledDeviceCameraSensorType::ChargeCoupledDeviceCameraSensorType() :
  SensorType()
{
  NumberOfPixels = 0;
  MaxReadoutFrequency = 0;
  HorizontalFieldOfView = 0;
  VerticalFieldOfView = 0;
  MaxReadNoise = 0;
  MaxFrameRate = 0;
  PixelSize = 0;
  SustainedDataRate = 0;
  DarkCurrent = 0;
  MaxPixelClockSpeed = 0;
  Linearity = 0;
  MaxOutputVoltage = 0;
}

ChargeCoupledDeviceCameraSensorType::ChargeCoupledDeviceCameraSensorType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 XmlString * ProtectionClassIn,
 XmlString * LinearityErrorIn,
 LinearValueType * RepeatabilityIn,
 XmlDecimal * SensitivityIn,
 LinearValueType * ResolutionIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 XmlInt * NumberOfPixelsIn,
 UserDefinedUnitValueType * MaxReadoutFrequencyIn,
 LinearValueType * HorizontalFieldOfViewIn,
 LinearValueType * VerticalFieldOfViewIn,
 UserDefinedUnitValueType * MaxReadNoiseIn,
 PositiveDecimalType * MaxFrameRateIn,
 LinearValueType * PixelSizeIn,
 UserDefinedUnitValueType * SustainedDataRateIn,
 UserDefinedUnitValueType * DarkCurrentIn,
 UserDefinedUnitValueType * MaxPixelClockSpeedIn,
 UserDefinedUnitValueType * LinearityIn,
 UserDefinedUnitValueType * MaxOutputVoltageIn) :
  SensorType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    ProtectionClassIn,
    LinearityErrorIn,
    RepeatabilityIn,
    SensitivityIn,
    ResolutionIn,
    EnvironmentalRangeIn)
{
  NumberOfPixels = NumberOfPixelsIn;
  MaxReadoutFrequency = MaxReadoutFrequencyIn;
  HorizontalFieldOfView = HorizontalFieldOfViewIn;
  VerticalFieldOfView = VerticalFieldOfViewIn;
  MaxReadNoise = MaxReadNoiseIn;
  MaxFrameRate = MaxFrameRateIn;
  PixelSize = PixelSizeIn;
  SustainedDataRate = SustainedDataRateIn;
  DarkCurrent = DarkCurrentIn;
  MaxPixelClockSpeed = MaxPixelClockSpeedIn;
  Linearity = LinearityIn;
  MaxOutputVoltage = MaxOutputVoltageIn;
}

ChargeCoupledDeviceCameraSensorType::ChargeCoupledDeviceCameraSensorType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 XmlString * ProtectionClassIn,
 XmlString * LinearityErrorIn,
 LinearValueType * RepeatabilityIn,
 XmlDecimal * SensitivityIn,
 LinearValueType * ResolutionIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 XmlInt * NumberOfPixelsIn,
 UserDefinedUnitValueType * MaxReadoutFrequencyIn,
 LinearValueType * HorizontalFieldOfViewIn,
 LinearValueType * VerticalFieldOfViewIn,
 UserDefinedUnitValueType * MaxReadNoiseIn,
 PositiveDecimalType * MaxFrameRateIn,
 LinearValueType * PixelSizeIn,
 UserDefinedUnitValueType * SustainedDataRateIn,
 UserDefinedUnitValueType * DarkCurrentIn,
 UserDefinedUnitValueType * MaxPixelClockSpeedIn,
 UserDefinedUnitValueType * LinearityIn,
 UserDefinedUnitValueType * MaxOutputVoltageIn) :
  SensorType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    ProtectionClassIn,
    LinearityErrorIn,
    RepeatabilityIn,
    SensitivityIn,
    ResolutionIn,
    EnvironmentalRangeIn)
{
  NumberOfPixels = NumberOfPixelsIn;
  MaxReadoutFrequency = MaxReadoutFrequencyIn;
  HorizontalFieldOfView = HorizontalFieldOfViewIn;
  VerticalFieldOfView = VerticalFieldOfViewIn;
  MaxReadNoise = MaxReadNoiseIn;
  MaxFrameRate = MaxFrameRateIn;
  PixelSize = PixelSizeIn;
  SustainedDataRate = SustainedDataRateIn;
  DarkCurrent = DarkCurrentIn;
  MaxPixelClockSpeed = MaxPixelClockSpeedIn;
  Linearity = LinearityIn;
  MaxOutputVoltage = MaxOutputVoltageIn;
}

ChargeCoupledDeviceCameraSensorType::~ChargeCoupledDeviceCameraSensorType()
{
  #ifndef NODESTRUCT
  delete NumberOfPixels;
  delete MaxReadoutFrequency;
  delete HorizontalFieldOfView;
  delete VerticalFieldOfView;
  delete MaxReadNoise;
  delete MaxFrameRate;
  delete PixelSize;
  delete SustainedDataRate;
  delete DarkCurrent;
  delete MaxPixelClockSpeed;
  delete Linearity;
  delete MaxOutputVoltage;
  #endif
}

void ChargeCoupledDeviceCameraSensorType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (ProtectionClass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProtectionClass");
      ProtectionClass->printSelf(outFile);
      fprintf(outFile, "</ProtectionClass>\n");
    }
  if (LinearityError)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LinearityError");
      LinearityError->printSelf(outFile);
      fprintf(outFile, "</LinearityError>\n");
    }
  if (Repeatability)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Repeatability");
      Repeatability->printSelf(outFile);
      fprintf(outFile, "</Repeatability>\n");
    }
  if (Sensitivity)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Sensitivity");
      Sensitivity->printSelf(outFile);
      fprintf(outFile, "</Sensitivity>\n");
    }
  if (Resolution)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Resolution");
      Resolution->printSelf(outFile);
      fprintf(outFile, "</Resolution>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (NumberOfPixels)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NumberOfPixels");
      NumberOfPixels->printSelf(outFile);
      fprintf(outFile, "</NumberOfPixels>\n");
    }
  if (MaxReadoutFrequency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxReadoutFrequency");
      MaxReadoutFrequency->printSelf(outFile);
      fprintf(outFile, "</MaxReadoutFrequency>\n");
    }
  if (HorizontalFieldOfView)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<HorizontalFieldOfView");
      HorizontalFieldOfView->printSelf(outFile);
      fprintf(outFile, "</HorizontalFieldOfView>\n");
    }
  if (VerticalFieldOfView)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VerticalFieldOfView");
      VerticalFieldOfView->printSelf(outFile);
      fprintf(outFile, "</VerticalFieldOfView>\n");
    }
  if (MaxReadNoise)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxReadNoise");
      MaxReadNoise->printSelf(outFile);
      fprintf(outFile, "</MaxReadNoise>\n");
    }
  if (MaxFrameRate)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxFrameRate");
      MaxFrameRate->printSelf(outFile);
      fprintf(outFile, "</MaxFrameRate>\n");
    }
  if (PixelSize)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PixelSize");
      PixelSize->printSelf(outFile);
      fprintf(outFile, "</PixelSize>\n");
    }
  if (SustainedDataRate)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SustainedDataRate");
      SustainedDataRate->printSelf(outFile);
      fprintf(outFile, "</SustainedDataRate>\n");
    }
  if (DarkCurrent)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DarkCurrent");
      DarkCurrent->printSelf(outFile);
      fprintf(outFile, "</DarkCurrent>\n");
    }
  if (MaxPixelClockSpeed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxPixelClockSpeed");
      MaxPixelClockSpeed->printSelf(outFile);
      fprintf(outFile, "</MaxPixelClockSpeed>\n");
    }
  if (Linearity)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Linearity");
      Linearity->printSelf(outFile);
      fprintf(outFile, "</Linearity>\n");
    }
  if (MaxOutputVoltage)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxOutputVoltage");
      MaxOutputVoltage->printSelf(outFile);
      fprintf(outFile, "</MaxOutputVoltage>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ChargeCoupledDeviceCameraSensorType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ChargeCoupledDeviceCameraSensorType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ChargeCoupledDeviceCameraSensorType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ChargeCoupledDeviceCameraSensorType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ChargeCoupledDeviceCameraSensorType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

XmlInt * ChargeCoupledDeviceCameraSensorType::getNumberOfPixels()
{return NumberOfPixels;}

void ChargeCoupledDeviceCameraSensorType::setNumberOfPixels(XmlInt * NumberOfPixelsIn)
{NumberOfPixels = NumberOfPixelsIn;}

UserDefinedUnitValueType * ChargeCoupledDeviceCameraSensorType::getMaxReadoutFrequency()
{return MaxReadoutFrequency;}

void ChargeCoupledDeviceCameraSensorType::setMaxReadoutFrequency(UserDefinedUnitValueType * MaxReadoutFrequencyIn)
{MaxReadoutFrequency = MaxReadoutFrequencyIn;}

LinearValueType * ChargeCoupledDeviceCameraSensorType::getHorizontalFieldOfView()
{return HorizontalFieldOfView;}

void ChargeCoupledDeviceCameraSensorType::setHorizontalFieldOfView(LinearValueType * HorizontalFieldOfViewIn)
{HorizontalFieldOfView = HorizontalFieldOfViewIn;}

LinearValueType * ChargeCoupledDeviceCameraSensorType::getVerticalFieldOfView()
{return VerticalFieldOfView;}

void ChargeCoupledDeviceCameraSensorType::setVerticalFieldOfView(LinearValueType * VerticalFieldOfViewIn)
{VerticalFieldOfView = VerticalFieldOfViewIn;}

UserDefinedUnitValueType * ChargeCoupledDeviceCameraSensorType::getMaxReadNoise()
{return MaxReadNoise;}

void ChargeCoupledDeviceCameraSensorType::setMaxReadNoise(UserDefinedUnitValueType * MaxReadNoiseIn)
{MaxReadNoise = MaxReadNoiseIn;}

PositiveDecimalType * ChargeCoupledDeviceCameraSensorType::getMaxFrameRate()
{return MaxFrameRate;}

void ChargeCoupledDeviceCameraSensorType::setMaxFrameRate(PositiveDecimalType * MaxFrameRateIn)
{MaxFrameRate = MaxFrameRateIn;}

LinearValueType * ChargeCoupledDeviceCameraSensorType::getPixelSize()
{return PixelSize;}

void ChargeCoupledDeviceCameraSensorType::setPixelSize(LinearValueType * PixelSizeIn)
{PixelSize = PixelSizeIn;}

UserDefinedUnitValueType * ChargeCoupledDeviceCameraSensorType::getSustainedDataRate()
{return SustainedDataRate;}

void ChargeCoupledDeviceCameraSensorType::setSustainedDataRate(UserDefinedUnitValueType * SustainedDataRateIn)
{SustainedDataRate = SustainedDataRateIn;}

UserDefinedUnitValueType * ChargeCoupledDeviceCameraSensorType::getDarkCurrent()
{return DarkCurrent;}

void ChargeCoupledDeviceCameraSensorType::setDarkCurrent(UserDefinedUnitValueType * DarkCurrentIn)
{DarkCurrent = DarkCurrentIn;}

UserDefinedUnitValueType * ChargeCoupledDeviceCameraSensorType::getMaxPixelClockSpeed()
{return MaxPixelClockSpeed;}

void ChargeCoupledDeviceCameraSensorType::setMaxPixelClockSpeed(UserDefinedUnitValueType * MaxPixelClockSpeedIn)
{MaxPixelClockSpeed = MaxPixelClockSpeedIn;}

UserDefinedUnitValueType * ChargeCoupledDeviceCameraSensorType::getLinearity()
{return Linearity;}

void ChargeCoupledDeviceCameraSensorType::setLinearity(UserDefinedUnitValueType * LinearityIn)
{Linearity = LinearityIn;}

UserDefinedUnitValueType * ChargeCoupledDeviceCameraSensorType::getMaxOutputVoltage()
{return MaxOutputVoltage;}

void ChargeCoupledDeviceCameraSensorType::setMaxOutputVoltage(UserDefinedUnitValueType * MaxOutputVoltageIn)
{MaxOutputVoltage = MaxOutputVoltageIn;}

/* ***************************************************************** */

/* class ClosedShellSetType

*/

ClosedShellSetType::ClosedShellSetType()
{
  PointSet = 0;
  Curve12Set = 0;
  Curve13Set = 0;
  SurfaceSet = 0;
  CurveMeshSet = 0;
  SurfaceMeshSet = 0;
  VertexSet = 0;
  EdgeSet = 0;
  LoopSet = 0;
  FaceSet = 0;
  ShellSet = 0;
}

ClosedShellSetType::ClosedShellSetType(
 PointSetType * PointSetIn,
 Curve12SetType * Curve12SetIn,
 Curve13SetType * Curve13SetIn,
 SurfaceSetType * SurfaceSetIn,
 CurveMeshSetType * CurveMeshSetIn,
 SurfaceMeshSetType * SurfaceMeshSetIn,
 VertexSetType * VertexSetIn,
 EdgeSetType * EdgeSetIn,
 LoopSetType * LoopSetIn,
 FaceSetType * FaceSetIn,
 ShellSetType * ShellSetIn)
{
  PointSet = PointSetIn;
  Curve12Set = Curve12SetIn;
  Curve13Set = Curve13SetIn;
  SurfaceSet = SurfaceSetIn;
  CurveMeshSet = CurveMeshSetIn;
  SurfaceMeshSet = SurfaceMeshSetIn;
  VertexSet = VertexSetIn;
  EdgeSet = EdgeSetIn;
  LoopSet = LoopSetIn;
  FaceSet = FaceSetIn;
  ShellSet = ShellSetIn;
}

ClosedShellSetType::~ClosedShellSetType()
{
  #ifndef NODESTRUCT
  delete PointSet;
  delete Curve12Set;
  delete Curve13Set;
  delete SurfaceSet;
  delete CurveMeshSet;
  delete SurfaceMeshSet;
  delete VertexSet;
  delete EdgeSet;
  delete LoopSet;
  delete FaceSet;
  delete ShellSet;
  #endif
}

void ClosedShellSetType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (PointSet)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointSet");
      PointSet->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointSet>\n");
    }
  if (Curve12Set)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Curve12Set");
      Curve12Set->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Curve12Set>\n");
    }
  if (Curve13Set)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Curve13Set");
      Curve13Set->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Curve13Set>\n");
    }
  if (SurfaceSet)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SurfaceSet");
      SurfaceSet->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SurfaceSet>\n");
    }
  if (CurveMeshSet)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CurveMeshSet");
      CurveMeshSet->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CurveMeshSet>\n");
    }
  if (SurfaceMeshSet)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SurfaceMeshSet");
      SurfaceMeshSet->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SurfaceMeshSet>\n");
    }
  if (VertexSet)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VertexSet");
      VertexSet->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</VertexSet>\n");
    }
  if (EdgeSet)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EdgeSet");
      EdgeSet->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EdgeSet>\n");
    }
  if (LoopSet)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LoopSet");
      LoopSet->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LoopSet>\n");
    }
  if (FaceSet)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FaceSet");
      FaceSet->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FaceSet>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ShellSet");
  ShellSet->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ShellSet>\n");
  doSpaces(-INDENT, outFile);
}

PointSetType * ClosedShellSetType::getPointSet()
{return PointSet;}

void ClosedShellSetType::setPointSet(PointSetType * PointSetIn)
{PointSet = PointSetIn;}

Curve12SetType * ClosedShellSetType::getCurve12Set()
{return Curve12Set;}

void ClosedShellSetType::setCurve12Set(Curve12SetType * Curve12SetIn)
{Curve12Set = Curve12SetIn;}

Curve13SetType * ClosedShellSetType::getCurve13Set()
{return Curve13Set;}

void ClosedShellSetType::setCurve13Set(Curve13SetType * Curve13SetIn)
{Curve13Set = Curve13SetIn;}

SurfaceSetType * ClosedShellSetType::getSurfaceSet()
{return SurfaceSet;}

void ClosedShellSetType::setSurfaceSet(SurfaceSetType * SurfaceSetIn)
{SurfaceSet = SurfaceSetIn;}

CurveMeshSetType * ClosedShellSetType::getCurveMeshSet()
{return CurveMeshSet;}

void ClosedShellSetType::setCurveMeshSet(CurveMeshSetType * CurveMeshSetIn)
{CurveMeshSet = CurveMeshSetIn;}

SurfaceMeshSetType * ClosedShellSetType::getSurfaceMeshSet()
{return SurfaceMeshSet;}

void ClosedShellSetType::setSurfaceMeshSet(SurfaceMeshSetType * SurfaceMeshSetIn)
{SurfaceMeshSet = SurfaceMeshSetIn;}

VertexSetType * ClosedShellSetType::getVertexSet()
{return VertexSet;}

void ClosedShellSetType::setVertexSet(VertexSetType * VertexSetIn)
{VertexSet = VertexSetIn;}

EdgeSetType * ClosedShellSetType::getEdgeSet()
{return EdgeSet;}

void ClosedShellSetType::setEdgeSet(EdgeSetType * EdgeSetIn)
{EdgeSet = EdgeSetIn;}

LoopSetType * ClosedShellSetType::getLoopSet()
{return LoopSet;}

void ClosedShellSetType::setLoopSet(LoopSetType * LoopSetIn)
{LoopSet = LoopSetIn;}

FaceSetType * ClosedShellSetType::getFaceSet()
{return FaceSet;}

void ClosedShellSetType::setFaceSet(FaceSetType * FaceSetIn)
{FaceSet = FaceSetIn;}

ShellSetType * ClosedShellSetType::getShellSet()
{return ShellSet;}

void ClosedShellSetType::setShellSet(ShellSetType * ShellSetIn)
{ShellSet = ShellSetIn;}

/* ***************************************************************** */

/* class ClosedShellSetWorkingVolumeType

*/

ClosedShellSetWorkingVolumeType::ClosedShellSetWorkingVolumeType() :
  WorkingVolumeBaseType()
{
  WorkingClosedShellSet = 0;
}

ClosedShellSetWorkingVolumeType::ClosedShellSetWorkingVolumeType(
 ClosedShellSetType * WorkingClosedShellSetIn) :
  WorkingVolumeBaseType()
{
  WorkingClosedShellSet = WorkingClosedShellSetIn;
}

ClosedShellSetWorkingVolumeType::~ClosedShellSetWorkingVolumeType()
{
  #ifndef NODESTRUCT
  delete WorkingClosedShellSet;
  #endif
}

void ClosedShellSetWorkingVolumeType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<WorkingClosedShellSet");
  WorkingClosedShellSet->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</WorkingClosedShellSet>\n");
  doSpaces(-INDENT, outFile);
}

ClosedShellSetType * ClosedShellSetWorkingVolumeType::getWorkingClosedShellSet()
{return WorkingClosedShellSet;}

void ClosedShellSetWorkingVolumeType::setWorkingClosedShellSet(ClosedShellSetType * WorkingClosedShellSetIn)
{WorkingClosedShellSet = WorkingClosedShellSetIn;}

/* ***************************************************************** */

/* class CombinedSphericalResolutionType

*/

CombinedSphericalResolutionType::CombinedSphericalResolutionType()
{
  CombinedRadialResolution = 0;
  CombinedAzimuthalResolution = 0;
  CombinedPolarResolution = 0;
}

CombinedSphericalResolutionType::CombinedSphericalResolutionType(
 LinearValueType * CombinedRadialResolutionIn,
 AngularValueType * CombinedAzimuthalResolutionIn,
 AngularValueType * CombinedPolarResolutionIn)
{
  CombinedRadialResolution = CombinedRadialResolutionIn;
  CombinedAzimuthalResolution = CombinedAzimuthalResolutionIn;
  CombinedPolarResolution = CombinedPolarResolutionIn;
}

CombinedSphericalResolutionType::~CombinedSphericalResolutionType()
{
  #ifndef NODESTRUCT
  delete CombinedRadialResolution;
  delete CombinedAzimuthalResolution;
  delete CombinedPolarResolution;
  #endif
}

void CombinedSphericalResolutionType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<CombinedRadialResolution");
  CombinedRadialResolution->printSelf(outFile);
  fprintf(outFile, "</CombinedRadialResolution>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CombinedAzimuthalResolution");
  CombinedAzimuthalResolution->printSelf(outFile);
  fprintf(outFile, "</CombinedAzimuthalResolution>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CombinedPolarResolution");
  CombinedPolarResolution->printSelf(outFile);
  fprintf(outFile, "</CombinedPolarResolution>\n");
  doSpaces(-INDENT, outFile);
}

LinearValueType * CombinedSphericalResolutionType::getCombinedRadialResolution()
{return CombinedRadialResolution;}

void CombinedSphericalResolutionType::setCombinedRadialResolution(LinearValueType * CombinedRadialResolutionIn)
{CombinedRadialResolution = CombinedRadialResolutionIn;}

AngularValueType * CombinedSphericalResolutionType::getCombinedAzimuthalResolution()
{return CombinedAzimuthalResolution;}

void CombinedSphericalResolutionType::setCombinedAzimuthalResolution(AngularValueType * CombinedAzimuthalResolutionIn)
{CombinedAzimuthalResolution = CombinedAzimuthalResolutionIn;}

AngularValueType * CombinedSphericalResolutionType::getCombinedPolarResolution()
{return CombinedPolarResolution;}

void CombinedSphericalResolutionType::setCombinedPolarResolution(AngularValueType * CombinedPolarResolutionIn)
{CombinedPolarResolution = CombinedPolarResolutionIn;}

/* ***************************************************************** */

/* class CombinedUserDefinedResolutionType

*/

CombinedUserDefinedResolutionType::CombinedUserDefinedResolutionType()
{
  ACombinedResolution = 0;
  BCombinedResolution = 0;
  CCombinedResolution = 0;
}

CombinedUserDefinedResolutionType::CombinedUserDefinedResolutionType(
 LinearOrRotaryAxisType * ACombinedResolutionIn,
 LinearOrRotaryAxisType * BCombinedResolutionIn,
 LinearOrRotaryAxisType * CCombinedResolutionIn)
{
  ACombinedResolution = ACombinedResolutionIn;
  BCombinedResolution = BCombinedResolutionIn;
  CCombinedResolution = CCombinedResolutionIn;
}

CombinedUserDefinedResolutionType::~CombinedUserDefinedResolutionType()
{
  #ifndef NODESTRUCT
  delete ACombinedResolution;
  delete BCombinedResolution;
  delete CCombinedResolution;
  #endif
}

void CombinedUserDefinedResolutionType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<ACombinedResolution");
  ACombinedResolution->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ACombinedResolution>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<BCombinedResolution");
  BCombinedResolution->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</BCombinedResolution>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<CCombinedResolution");
  CCombinedResolution->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</CCombinedResolution>\n");
  doSpaces(-INDENT, outFile);
}

LinearOrRotaryAxisType * CombinedUserDefinedResolutionType::getACombinedResolution()
{return ACombinedResolution;}

void CombinedUserDefinedResolutionType::setACombinedResolution(LinearOrRotaryAxisType * ACombinedResolutionIn)
{ACombinedResolution = ACombinedResolutionIn;}

LinearOrRotaryAxisType * CombinedUserDefinedResolutionType::getBCombinedResolution()
{return BCombinedResolution;}

void CombinedUserDefinedResolutionType::setBCombinedResolution(LinearOrRotaryAxisType * BCombinedResolutionIn)
{BCombinedResolution = BCombinedResolutionIn;}

LinearOrRotaryAxisType * CombinedUserDefinedResolutionType::getCCombinedResolution()
{return CCombinedResolution;}

void CombinedUserDefinedResolutionType::setCCombinedResolution(LinearOrRotaryAxisType * CCombinedResolutionIn)
{CCombinedResolution = CCombinedResolutionIn;}

/* ***************************************************************** */

/* class ComplexTactileProbeSensorType

*/

ComplexTactileProbeSensorType::ComplexTactileProbeSensorType() :
  TactileProbeSensorBaseType()
{
  LocatedTips = 0;
}

ComplexTactileProbeSensorType::ComplexTactileProbeSensorType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 XmlString * ProtectionClassIn,
 XmlString * LinearityErrorIn,
 LinearValueType * RepeatabilityIn,
 XmlDecimal * SensitivityIn,
 LinearValueType * ResolutionIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 LocatedTipsType * LocatedTipsIn) :
  TactileProbeSensorBaseType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    ProtectionClassIn,
    LinearityErrorIn,
    RepeatabilityIn,
    SensitivityIn,
    ResolutionIn,
    EnvironmentalRangeIn)
{
  LocatedTips = LocatedTipsIn;
}

ComplexTactileProbeSensorType::ComplexTactileProbeSensorType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 XmlString * ProtectionClassIn,
 XmlString * LinearityErrorIn,
 LinearValueType * RepeatabilityIn,
 XmlDecimal * SensitivityIn,
 LinearValueType * ResolutionIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 LocatedTipsType * LocatedTipsIn) :
  TactileProbeSensorBaseType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    ProtectionClassIn,
    LinearityErrorIn,
    RepeatabilityIn,
    SensitivityIn,
    ResolutionIn,
    EnvironmentalRangeIn)
{
  LocatedTips = LocatedTipsIn;
}

ComplexTactileProbeSensorType::~ComplexTactileProbeSensorType()
{
  #ifndef NODESTRUCT
  delete LocatedTips;
  #endif
}

void ComplexTactileProbeSensorType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (ProtectionClass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProtectionClass");
      ProtectionClass->printSelf(outFile);
      fprintf(outFile, "</ProtectionClass>\n");
    }
  if (LinearityError)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LinearityError");
      LinearityError->printSelf(outFile);
      fprintf(outFile, "</LinearityError>\n");
    }
  if (Repeatability)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Repeatability");
      Repeatability->printSelf(outFile);
      fprintf(outFile, "</Repeatability>\n");
    }
  if (Sensitivity)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Sensitivity");
      Sensitivity->printSelf(outFile);
      fprintf(outFile, "</Sensitivity>\n");
    }
  if (Resolution)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Resolution");
      Resolution->printSelf(outFile);
      fprintf(outFile, "</Resolution>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<LocatedTips");
  LocatedTips->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</LocatedTips>\n");
  doSpaces(-INDENT, outFile);
}

bool ComplexTactileProbeSensorType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ComplexTactileProbeSensorType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ComplexTactileProbeSensorType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ComplexTactileProbeSensorType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ComplexTactileProbeSensorType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LocatedTipsType * ComplexTactileProbeSensorType::getLocatedTips()
{return LocatedTips;}

void ComplexTactileProbeSensorType::setLocatedTips(LocatedTipsType * LocatedTipsIn)
{LocatedTips = LocatedTipsIn;}

/* ***************************************************************** */

/* class ComputedTomographyType

*/

ComputedTomographyType::ComputedTomographyType() :
  UniversalDeviceType()
{
  SourceDescription = 0;
  SamplePenetratingMaterial = 0;
  SamplePenetratingMaterialLength = 0;
  FocalSpotSize = 0;
  MaxWorkpieceMass = 0;
  SafetyLevel = 0;
  CabinetDimensions = 0;
  MaxPower = 0;
  DetectorBitNumber = 0;
  DetectorPixelSize = 0;
  ActivePixelsNumber = 0;
  MaxKV = 0;
  MinOperatingCurrent = 0;
  MaxOperatingCurrent = 0;
  MaxFramePerSecond = 0;
  RotaryTable = 0;
  ToolIds = 0;
}

ComputedTomographyType::ComputedTomographyType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 ResolutionBaseType * ResolutionIn,
 WorkingVolumeBaseType * WorkingVolumeIn,
 EffectiveWorkingVolumeBaseType * EffectiveWorkingVolumeIn,
 TemperatureCompensationType * TemperatureCompensationIn,
 XmlString * SourceDescriptionIn,
 XmlString * SamplePenetratingMaterialIn,
 LinearValueType * SamplePenetratingMaterialLengthIn,
 LinearValueType * FocalSpotSizeIn,
 MassValueType * MaxWorkpieceMassIn,
 XmlString * SafetyLevelIn,
 CartesianWorkingVolumeType * CabinetDimensionsIn,
 UserDefinedUnitValueType * MaxPowerIn,
 XmlDecimal * DetectorBitNumberIn,
 LinearValueType * DetectorPixelSizeIn,
 FunctionDiscreteType * ActivePixelsNumberIn,
 UserDefinedUnitValueType * MaxKVIn,
 UserDefinedUnitValueType * MinOperatingCurrentIn,
 UserDefinedUnitValueType * MaxOperatingCurrentIn,
 UserDefinedUnitValueType * MaxFramePerSecondIn,
 RotaryTableType * RotaryTableIn,
 ArrayReferenceType * ToolIdsIn) :
  UniversalDeviceType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    ResolutionIn,
    WorkingVolumeIn,
    EffectiveWorkingVolumeIn,
    TemperatureCompensationIn)
{
  SourceDescription = SourceDescriptionIn;
  SamplePenetratingMaterial = SamplePenetratingMaterialIn;
  SamplePenetratingMaterialLength = SamplePenetratingMaterialLengthIn;
  FocalSpotSize = FocalSpotSizeIn;
  MaxWorkpieceMass = MaxWorkpieceMassIn;
  SafetyLevel = SafetyLevelIn;
  CabinetDimensions = CabinetDimensionsIn;
  MaxPower = MaxPowerIn;
  DetectorBitNumber = DetectorBitNumberIn;
  DetectorPixelSize = DetectorPixelSizeIn;
  ActivePixelsNumber = ActivePixelsNumberIn;
  MaxKV = MaxKVIn;
  MinOperatingCurrent = MinOperatingCurrentIn;
  MaxOperatingCurrent = MaxOperatingCurrentIn;
  MaxFramePerSecond = MaxFramePerSecondIn;
  RotaryTable = RotaryTableIn;
  ToolIds = ToolIdsIn;
}

ComputedTomographyType::ComputedTomographyType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 ResolutionBaseType * ResolutionIn,
 WorkingVolumeBaseType * WorkingVolumeIn,
 EffectiveWorkingVolumeBaseType * EffectiveWorkingVolumeIn,
 TemperatureCompensationType * TemperatureCompensationIn,
 XmlString * SourceDescriptionIn,
 XmlString * SamplePenetratingMaterialIn,
 LinearValueType * SamplePenetratingMaterialLengthIn,
 LinearValueType * FocalSpotSizeIn,
 MassValueType * MaxWorkpieceMassIn,
 XmlString * SafetyLevelIn,
 CartesianWorkingVolumeType * CabinetDimensionsIn,
 UserDefinedUnitValueType * MaxPowerIn,
 XmlDecimal * DetectorBitNumberIn,
 LinearValueType * DetectorPixelSizeIn,
 FunctionDiscreteType * ActivePixelsNumberIn,
 UserDefinedUnitValueType * MaxKVIn,
 UserDefinedUnitValueType * MinOperatingCurrentIn,
 UserDefinedUnitValueType * MaxOperatingCurrentIn,
 UserDefinedUnitValueType * MaxFramePerSecondIn,
 RotaryTableType * RotaryTableIn,
 ArrayReferenceType * ToolIdsIn) :
  UniversalDeviceType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    ResolutionIn,
    WorkingVolumeIn,
    EffectiveWorkingVolumeIn,
    TemperatureCompensationIn)
{
  SourceDescription = SourceDescriptionIn;
  SamplePenetratingMaterial = SamplePenetratingMaterialIn;
  SamplePenetratingMaterialLength = SamplePenetratingMaterialLengthIn;
  FocalSpotSize = FocalSpotSizeIn;
  MaxWorkpieceMass = MaxWorkpieceMassIn;
  SafetyLevel = SafetyLevelIn;
  CabinetDimensions = CabinetDimensionsIn;
  MaxPower = MaxPowerIn;
  DetectorBitNumber = DetectorBitNumberIn;
  DetectorPixelSize = DetectorPixelSizeIn;
  ActivePixelsNumber = ActivePixelsNumberIn;
  MaxKV = MaxKVIn;
  MinOperatingCurrent = MinOperatingCurrentIn;
  MaxOperatingCurrent = MaxOperatingCurrentIn;
  MaxFramePerSecond = MaxFramePerSecondIn;
  RotaryTable = RotaryTableIn;
  ToolIds = ToolIdsIn;
}

ComputedTomographyType::~ComputedTomographyType()
{
  #ifndef NODESTRUCT
  delete SourceDescription;
  delete SamplePenetratingMaterial;
  delete SamplePenetratingMaterialLength;
  delete FocalSpotSize;
  delete MaxWorkpieceMass;
  delete SafetyLevel;
  delete CabinetDimensions;
  delete MaxPower;
  delete DetectorBitNumber;
  delete DetectorPixelSize;
  delete ActivePixelsNumber;
  delete MaxKV;
  delete MinOperatingCurrent;
  delete MaxOperatingCurrent;
  delete MaxFramePerSecond;
  delete RotaryTable;
  delete ToolIds;
  #endif
}

void ComputedTomographyType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Calibrations)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Calibrations");
      Calibrations->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Calibrations>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (Resolution)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (Resolution->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(Resolution->getprintElement(), "LinearResolution") == 0)
          {
            LinearResolutionType * typ;
            if ((typ = dynamic_cast<LinearResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<LinearResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LinearResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad LinearResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "CartesianResolution") == 0)
          {
            CartesianResolutionType * typ;
            if ((typ = dynamic_cast<CartesianResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<CartesianResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "SphericalResolution") == 0)
          {
            SphericalResolutionType * typ;
            if ((typ = dynamic_cast<SphericalResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<SphericalResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "UserDefinedResolution") == 0)
          {
            UserDefinedResolutionType * typ;
            if ((typ = dynamic_cast<UserDefinedResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<UserDefinedResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedResolution element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad Resolution type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (WorkingVolume)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (WorkingVolume->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(WorkingVolume->getprintElement(), "ClosedShellSetWorkingVolume") == 0)
          {
            ClosedShellSetWorkingVolumeType * typ;
            if ((typ = dynamic_cast<ClosedShellSetWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<ClosedShellSetWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ClosedShellSetWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad ClosedShellSetWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "CartesianWorkingVolume") == 0)
          {
            CartesianWorkingVolumeType * typ;
            if ((typ = dynamic_cast<CartesianWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<CartesianWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "SphericalWorkingVolume") == 0)
          {
            SphericalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<SphericalWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<SphericalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "CylindricalWorkingVolume") == 0)
          {
            CylindricalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<CylindricalWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<CylindricalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CylindricalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad CylindricalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "UserDefinedWorkingVolume") == 0)
          {
            UserDefinedWorkingVolumeType * typ;
            if ((typ = dynamic_cast<UserDefinedWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<UserDefinedWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedWorkingVolume element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad WorkingVolume type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (EffectiveWorkingVolume)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (EffectiveWorkingVolume->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveClosedShellSetWorkingVolume") == 0)
          {
            EffectiveClosedShellSetWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveClosedShellSetWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveClosedShellSetWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveClosedShellSetWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveClosedShellSetWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveCartesianWorkingVolume") == 0)
          {
            EffectiveCartesianWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveCartesianWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveCartesianWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveCartesianWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveCartesianWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveSphericalWorkingVolume") == 0)
          {
            EffectiveSphericalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveSphericalWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveSphericalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveSphericalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveSphericalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveCylindricalWorkingVolume") == 0)
          {
            EffectiveCylindricalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveCylindricalWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveCylindricalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveCylindricalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveCylindricalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveUserDefinedWorkingVolume") == 0)
          {
            EffectiveUserDefinedWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveUserDefinedWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveUserDefinedWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveUserDefinedWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveUserDefinedWorkingVolume element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad EffectiveWorkingVolume type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (TemperatureCompensation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TemperatureCompensation");
      TemperatureCompensation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</TemperatureCompensation>\n");
    }
  if (SourceDescription)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SourceDescription");
      SourceDescription->printSelf(outFile);
      fprintf(outFile, "</SourceDescription>\n");
    }
  if (SamplePenetratingMaterial)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SamplePenetratingMaterial");
      SamplePenetratingMaterial->printSelf(outFile);
      fprintf(outFile, "</SamplePenetratingMaterial>\n");
    }
  if (SamplePenetratingMaterialLength)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SamplePenetratingMaterialLength");
      SamplePenetratingMaterialLength->printSelf(outFile);
      fprintf(outFile, "</SamplePenetratingMaterialLength>\n");
    }
  if (FocalSpotSize)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FocalSpotSize");
      FocalSpotSize->printSelf(outFile);
      fprintf(outFile, "</FocalSpotSize>\n");
    }
  if (MaxWorkpieceMass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxWorkpieceMass");
      MaxWorkpieceMass->printSelf(outFile);
      fprintf(outFile, "</MaxWorkpieceMass>\n");
    }
  if (SafetyLevel)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SafetyLevel");
      SafetyLevel->printSelf(outFile);
      fprintf(outFile, "</SafetyLevel>\n");
    }
  if (CabinetDimensions)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CabinetDimensions");
      CabinetDimensions->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CabinetDimensions>\n");
    }
  if (MaxPower)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxPower");
      MaxPower->printSelf(outFile);
      fprintf(outFile, "</MaxPower>\n");
    }
  if (DetectorBitNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DetectorBitNumber");
      DetectorBitNumber->printSelf(outFile);
      fprintf(outFile, "</DetectorBitNumber>\n");
    }
  if (DetectorPixelSize)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DetectorPixelSize");
      DetectorPixelSize->printSelf(outFile);
      fprintf(outFile, "</DetectorPixelSize>\n");
    }
  if (ActivePixelsNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActivePixelsNumber");
      ActivePixelsNumber->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ActivePixelsNumber>\n");
    }
  if (MaxKV)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxKV");
      MaxKV->printSelf(outFile);
      fprintf(outFile, "</MaxKV>\n");
    }
  if (MinOperatingCurrent)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinOperatingCurrent");
      MinOperatingCurrent->printSelf(outFile);
      fprintf(outFile, "</MinOperatingCurrent>\n");
    }
  if (MaxOperatingCurrent)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxOperatingCurrent");
      MaxOperatingCurrent->printSelf(outFile);
      fprintf(outFile, "</MaxOperatingCurrent>\n");
    }
  if (MaxFramePerSecond)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxFramePerSecond");
      MaxFramePerSecond->printSelf(outFile);
      fprintf(outFile, "</MaxFramePerSecond>\n");
    }
  if (RotaryTable)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<RotaryTable");
      RotaryTable->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</RotaryTable>\n");
    }
  if (ToolIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToolIds");
      ToolIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ToolIds>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ComputedTomographyType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ComputedTomographyType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ComputedTomographyType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ComputedTomographyType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ComputedTomographyType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

XmlString * ComputedTomographyType::getSourceDescription()
{return SourceDescription;}

void ComputedTomographyType::setSourceDescription(XmlString * SourceDescriptionIn)
{SourceDescription = SourceDescriptionIn;}

XmlString * ComputedTomographyType::getSamplePenetratingMaterial()
{return SamplePenetratingMaterial;}

void ComputedTomographyType::setSamplePenetratingMaterial(XmlString * SamplePenetratingMaterialIn)
{SamplePenetratingMaterial = SamplePenetratingMaterialIn;}

LinearValueType * ComputedTomographyType::getSamplePenetratingMaterialLength()
{return SamplePenetratingMaterialLength;}

void ComputedTomographyType::setSamplePenetratingMaterialLength(LinearValueType * SamplePenetratingMaterialLengthIn)
{SamplePenetratingMaterialLength = SamplePenetratingMaterialLengthIn;}

LinearValueType * ComputedTomographyType::getFocalSpotSize()
{return FocalSpotSize;}

void ComputedTomographyType::setFocalSpotSize(LinearValueType * FocalSpotSizeIn)
{FocalSpotSize = FocalSpotSizeIn;}

MassValueType * ComputedTomographyType::getMaxWorkpieceMass()
{return MaxWorkpieceMass;}

void ComputedTomographyType::setMaxWorkpieceMass(MassValueType * MaxWorkpieceMassIn)
{MaxWorkpieceMass = MaxWorkpieceMassIn;}

XmlString * ComputedTomographyType::getSafetyLevel()
{return SafetyLevel;}

void ComputedTomographyType::setSafetyLevel(XmlString * SafetyLevelIn)
{SafetyLevel = SafetyLevelIn;}

CartesianWorkingVolumeType * ComputedTomographyType::getCabinetDimensions()
{return CabinetDimensions;}

void ComputedTomographyType::setCabinetDimensions(CartesianWorkingVolumeType * CabinetDimensionsIn)
{CabinetDimensions = CabinetDimensionsIn;}

UserDefinedUnitValueType * ComputedTomographyType::getMaxPower()
{return MaxPower;}

void ComputedTomographyType::setMaxPower(UserDefinedUnitValueType * MaxPowerIn)
{MaxPower = MaxPowerIn;}

XmlDecimal * ComputedTomographyType::getDetectorBitNumber()
{return DetectorBitNumber;}

void ComputedTomographyType::setDetectorBitNumber(XmlDecimal * DetectorBitNumberIn)
{DetectorBitNumber = DetectorBitNumberIn;}

LinearValueType * ComputedTomographyType::getDetectorPixelSize()
{return DetectorPixelSize;}

void ComputedTomographyType::setDetectorPixelSize(LinearValueType * DetectorPixelSizeIn)
{DetectorPixelSize = DetectorPixelSizeIn;}

FunctionDiscreteType * ComputedTomographyType::getActivePixelsNumber()
{return ActivePixelsNumber;}

void ComputedTomographyType::setActivePixelsNumber(FunctionDiscreteType * ActivePixelsNumberIn)
{ActivePixelsNumber = ActivePixelsNumberIn;}

UserDefinedUnitValueType * ComputedTomographyType::getMaxKV()
{return MaxKV;}

void ComputedTomographyType::setMaxKV(UserDefinedUnitValueType * MaxKVIn)
{MaxKV = MaxKVIn;}

UserDefinedUnitValueType * ComputedTomographyType::getMinOperatingCurrent()
{return MinOperatingCurrent;}

void ComputedTomographyType::setMinOperatingCurrent(UserDefinedUnitValueType * MinOperatingCurrentIn)
{MinOperatingCurrent = MinOperatingCurrentIn;}

UserDefinedUnitValueType * ComputedTomographyType::getMaxOperatingCurrent()
{return MaxOperatingCurrent;}

void ComputedTomographyType::setMaxOperatingCurrent(UserDefinedUnitValueType * MaxOperatingCurrentIn)
{MaxOperatingCurrent = MaxOperatingCurrentIn;}

UserDefinedUnitValueType * ComputedTomographyType::getMaxFramePerSecond()
{return MaxFramePerSecond;}

void ComputedTomographyType::setMaxFramePerSecond(UserDefinedUnitValueType * MaxFramePerSecondIn)
{MaxFramePerSecond = MaxFramePerSecondIn;}

RotaryTableType * ComputedTomographyType::getRotaryTable()
{return RotaryTable;}

void ComputedTomographyType::setRotaryTable(RotaryTableType * RotaryTableIn)
{RotaryTable = RotaryTableIn;}

ArrayReferenceType * ComputedTomographyType::getToolIds()
{return ToolIds;}

void ComputedTomographyType::setToolIds(ArrayReferenceType * ToolIdsIn)
{ToolIds = ToolIdsIn;}

/* ***************************************************************** */

/* class ConfocalChromaticSensorType

*/

ConfocalChromaticSensorType::ConfocalChromaticSensorType() :
  SensorType()
{
  SpotDiameter = 0;
  MinMeasuringDistance = 0;
  MaxMeasuringDistance = 0;
  MultiPeakMeasurement = 0;
  LightSource = 0;
  MaxTilt = 0;
  HousingMaterial = 0;
  OpticalFiberCableLength = 0;
  ShockTolerance = 0;
  VibrationTolerance = 0;
}

ConfocalChromaticSensorType::ConfocalChromaticSensorType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 XmlString * ProtectionClassIn,
 XmlString * LinearityErrorIn,
 LinearValueType * RepeatabilityIn,
 XmlDecimal * SensitivityIn,
 LinearValueType * ResolutionIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 LinearValueType * SpotDiameterIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 XmlInt * MultiPeakMeasurementIn,
 XmlString * LightSourceIn,
 AngularValueType * MaxTiltIn,
 XmlString * HousingMaterialIn,
 LinearValueType * OpticalFiberCableLengthIn,
 UserDefinedUnitValueType * ShockToleranceIn,
 UserDefinedUnitValueType * VibrationToleranceIn) :
  SensorType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    ProtectionClassIn,
    LinearityErrorIn,
    RepeatabilityIn,
    SensitivityIn,
    ResolutionIn,
    EnvironmentalRangeIn)
{
  SpotDiameter = SpotDiameterIn;
  MinMeasuringDistance = MinMeasuringDistanceIn;
  MaxMeasuringDistance = MaxMeasuringDistanceIn;
  MultiPeakMeasurement = MultiPeakMeasurementIn;
  LightSource = LightSourceIn;
  MaxTilt = MaxTiltIn;
  HousingMaterial = HousingMaterialIn;
  OpticalFiberCableLength = OpticalFiberCableLengthIn;
  ShockTolerance = ShockToleranceIn;
  VibrationTolerance = VibrationToleranceIn;
}

ConfocalChromaticSensorType::ConfocalChromaticSensorType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 XmlString * ProtectionClassIn,
 XmlString * LinearityErrorIn,
 LinearValueType * RepeatabilityIn,
 XmlDecimal * SensitivityIn,
 LinearValueType * ResolutionIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 LinearValueType * SpotDiameterIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 XmlInt * MultiPeakMeasurementIn,
 XmlString * LightSourceIn,
 AngularValueType * MaxTiltIn,
 XmlString * HousingMaterialIn,
 LinearValueType * OpticalFiberCableLengthIn,
 UserDefinedUnitValueType * ShockToleranceIn,
 UserDefinedUnitValueType * VibrationToleranceIn) :
  SensorType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    ProtectionClassIn,
    LinearityErrorIn,
    RepeatabilityIn,
    SensitivityIn,
    ResolutionIn,
    EnvironmentalRangeIn)
{
  SpotDiameter = SpotDiameterIn;
  MinMeasuringDistance = MinMeasuringDistanceIn;
  MaxMeasuringDistance = MaxMeasuringDistanceIn;
  MultiPeakMeasurement = MultiPeakMeasurementIn;
  LightSource = LightSourceIn;
  MaxTilt = MaxTiltIn;
  HousingMaterial = HousingMaterialIn;
  OpticalFiberCableLength = OpticalFiberCableLengthIn;
  ShockTolerance = ShockToleranceIn;
  VibrationTolerance = VibrationToleranceIn;
}

ConfocalChromaticSensorType::~ConfocalChromaticSensorType()
{
  #ifndef NODESTRUCT
  delete SpotDiameter;
  delete MinMeasuringDistance;
  delete MaxMeasuringDistance;
  delete MultiPeakMeasurement;
  delete LightSource;
  delete MaxTilt;
  delete HousingMaterial;
  delete OpticalFiberCableLength;
  delete ShockTolerance;
  delete VibrationTolerance;
  #endif
}

void ConfocalChromaticSensorType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (ProtectionClass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProtectionClass");
      ProtectionClass->printSelf(outFile);
      fprintf(outFile, "</ProtectionClass>\n");
    }
  if (LinearityError)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LinearityError");
      LinearityError->printSelf(outFile);
      fprintf(outFile, "</LinearityError>\n");
    }
  if (Repeatability)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Repeatability");
      Repeatability->printSelf(outFile);
      fprintf(outFile, "</Repeatability>\n");
    }
  if (Sensitivity)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Sensitivity");
      Sensitivity->printSelf(outFile);
      fprintf(outFile, "</Sensitivity>\n");
    }
  if (Resolution)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Resolution");
      Resolution->printSelf(outFile);
      fprintf(outFile, "</Resolution>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (SpotDiameter)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SpotDiameter");
      SpotDiameter->printSelf(outFile);
      fprintf(outFile, "</SpotDiameter>\n");
    }
  if (MinMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinMeasuringDistance");
      MinMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MinMeasuringDistance>\n");
    }
  if (MaxMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxMeasuringDistance");
      MaxMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MaxMeasuringDistance>\n");
    }
  if (MultiPeakMeasurement)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MultiPeakMeasurement");
      MultiPeakMeasurement->printSelf(outFile);
      fprintf(outFile, "</MultiPeakMeasurement>\n");
    }
  if (LightSource)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LightSource");
      LightSource->printSelf(outFile);
      fprintf(outFile, "</LightSource>\n");
    }
  if (MaxTilt)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxTilt");
      MaxTilt->printSelf(outFile);
      fprintf(outFile, "</MaxTilt>\n");
    }
  if (HousingMaterial)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<HousingMaterial");
      HousingMaterial->printSelf(outFile);
      fprintf(outFile, "</HousingMaterial>\n");
    }
  if (OpticalFiberCableLength)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OpticalFiberCableLength");
      OpticalFiberCableLength->printSelf(outFile);
      fprintf(outFile, "</OpticalFiberCableLength>\n");
    }
  if (ShockTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ShockTolerance");
      ShockTolerance->printSelf(outFile);
      fprintf(outFile, "</ShockTolerance>\n");
    }
  if (VibrationTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VibrationTolerance");
      VibrationTolerance->printSelf(outFile);
      fprintf(outFile, "</VibrationTolerance>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ConfocalChromaticSensorType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ConfocalChromaticSensorType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ConfocalChromaticSensorType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ConfocalChromaticSensorType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ConfocalChromaticSensorType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LinearValueType * ConfocalChromaticSensorType::getSpotDiameter()
{return SpotDiameter;}

void ConfocalChromaticSensorType::setSpotDiameter(LinearValueType * SpotDiameterIn)
{SpotDiameter = SpotDiameterIn;}

LinearValueType * ConfocalChromaticSensorType::getMinMeasuringDistance()
{return MinMeasuringDistance;}

void ConfocalChromaticSensorType::setMinMeasuringDistance(LinearValueType * MinMeasuringDistanceIn)
{MinMeasuringDistance = MinMeasuringDistanceIn;}

LinearValueType * ConfocalChromaticSensorType::getMaxMeasuringDistance()
{return MaxMeasuringDistance;}

void ConfocalChromaticSensorType::setMaxMeasuringDistance(LinearValueType * MaxMeasuringDistanceIn)
{MaxMeasuringDistance = MaxMeasuringDistanceIn;}

XmlInt * ConfocalChromaticSensorType::getMultiPeakMeasurement()
{return MultiPeakMeasurement;}

void ConfocalChromaticSensorType::setMultiPeakMeasurement(XmlInt * MultiPeakMeasurementIn)
{MultiPeakMeasurement = MultiPeakMeasurementIn;}

XmlString * ConfocalChromaticSensorType::getLightSource()
{return LightSource;}

void ConfocalChromaticSensorType::setLightSource(XmlString * LightSourceIn)
{LightSource = LightSourceIn;}

AngularValueType * ConfocalChromaticSensorType::getMaxTilt()
{return MaxTilt;}

void ConfocalChromaticSensorType::setMaxTilt(AngularValueType * MaxTiltIn)
{MaxTilt = MaxTiltIn;}

XmlString * ConfocalChromaticSensorType::getHousingMaterial()
{return HousingMaterial;}

void ConfocalChromaticSensorType::setHousingMaterial(XmlString * HousingMaterialIn)
{HousingMaterial = HousingMaterialIn;}

LinearValueType * ConfocalChromaticSensorType::getOpticalFiberCableLength()
{return OpticalFiberCableLength;}

void ConfocalChromaticSensorType::setOpticalFiberCableLength(LinearValueType * OpticalFiberCableLengthIn)
{OpticalFiberCableLength = OpticalFiberCableLengthIn;}

UserDefinedUnitValueType * ConfocalChromaticSensorType::getShockTolerance()
{return ShockTolerance;}

void ConfocalChromaticSensorType::setShockTolerance(UserDefinedUnitValueType * ShockToleranceIn)
{ShockTolerance = ShockToleranceIn;}

UserDefinedUnitValueType * ConfocalChromaticSensorType::getVibrationTolerance()
{return VibrationTolerance;}

void ConfocalChromaticSensorType::setVibrationTolerance(UserDefinedUnitValueType * VibrationToleranceIn)
{VibrationTolerance = VibrationToleranceIn;}

/* ***************************************************************** */

/* class CylindricalWorkingVolumeType

*/

CylindricalWorkingVolumeType::CylindricalWorkingVolumeType() :
  WorkingVolumeBaseType()
{
  RadialAxisLength = 0;
  MinAzimuthalAxisAngle = 0;
  MaxAzimuthalAxisAngle = 0;
  ZAxisLength = 0;
}

CylindricalWorkingVolumeType::CylindricalWorkingVolumeType(
 LinearValueType * RadialAxisLengthIn,
 AngularValueType * MinAzimuthalAxisAngleIn,
 AngularValueType * MaxAzimuthalAxisAngleIn,
 LinearValueType * ZAxisLengthIn) :
  WorkingVolumeBaseType()
{
  RadialAxisLength = RadialAxisLengthIn;
  MinAzimuthalAxisAngle = MinAzimuthalAxisAngleIn;
  MaxAzimuthalAxisAngle = MaxAzimuthalAxisAngleIn;
  ZAxisLength = ZAxisLengthIn;
}

CylindricalWorkingVolumeType::~CylindricalWorkingVolumeType()
{
  #ifndef NODESTRUCT
  delete RadialAxisLength;
  delete MinAzimuthalAxisAngle;
  delete MaxAzimuthalAxisAngle;
  delete ZAxisLength;
  #endif
}

void CylindricalWorkingVolumeType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<RadialAxisLength");
  RadialAxisLength->printSelf(outFile);
  fprintf(outFile, "</RadialAxisLength>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MinAzimuthalAxisAngle");
  MinAzimuthalAxisAngle->printSelf(outFile);
  fprintf(outFile, "</MinAzimuthalAxisAngle>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxAzimuthalAxisAngle");
  MaxAzimuthalAxisAngle->printSelf(outFile);
  fprintf(outFile, "</MaxAzimuthalAxisAngle>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<ZAxisLength");
  ZAxisLength->printSelf(outFile);
  fprintf(outFile, "</ZAxisLength>\n");
  doSpaces(-INDENT, outFile);
}

LinearValueType * CylindricalWorkingVolumeType::getRadialAxisLength()
{return RadialAxisLength;}

void CylindricalWorkingVolumeType::setRadialAxisLength(LinearValueType * RadialAxisLengthIn)
{RadialAxisLength = RadialAxisLengthIn;}

AngularValueType * CylindricalWorkingVolumeType::getMinAzimuthalAxisAngle()
{return MinAzimuthalAxisAngle;}

void CylindricalWorkingVolumeType::setMinAzimuthalAxisAngle(AngularValueType * MinAzimuthalAxisAngleIn)
{MinAzimuthalAxisAngle = MinAzimuthalAxisAngleIn;}

AngularValueType * CylindricalWorkingVolumeType::getMaxAzimuthalAxisAngle()
{return MaxAzimuthalAxisAngle;}

void CylindricalWorkingVolumeType::setMaxAzimuthalAxisAngle(AngularValueType * MaxAzimuthalAxisAngleIn)
{MaxAzimuthalAxisAngle = MaxAzimuthalAxisAngleIn;}

LinearValueType * CylindricalWorkingVolumeType::getZAxisLength()
{return ZAxisLength;}

void CylindricalWorkingVolumeType::setZAxisLength(LinearValueType * ZAxisLengthIn)
{ZAxisLength = ZAxisLengthIn;}

/* ***************************************************************** */

/* class DetachableSensorBaseType

*/

DetachableSensorBaseType::DetachableSensorBaseType() :
  SensorType()
{
}

DetachableSensorBaseType::DetachableSensorBaseType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 XmlString * ProtectionClassIn,
 XmlString * LinearityErrorIn,
 LinearValueType * RepeatabilityIn,
 XmlDecimal * SensitivityIn,
 LinearValueType * ResolutionIn,
 EnvironmentalRangeType * EnvironmentalRangeIn) :
  SensorType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    ProtectionClassIn,
    LinearityErrorIn,
    RepeatabilityIn,
    SensitivityIn,
    ResolutionIn,
    EnvironmentalRangeIn)
{
}

DetachableSensorBaseType::DetachableSensorBaseType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 XmlString * ProtectionClassIn,
 XmlString * LinearityErrorIn,
 LinearValueType * RepeatabilityIn,
 XmlDecimal * SensitivityIn,
 LinearValueType * ResolutionIn,
 EnvironmentalRangeType * EnvironmentalRangeIn) :
  SensorType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    ProtectionClassIn,
    LinearityErrorIn,
    RepeatabilityIn,
    SensitivityIn,
    ResolutionIn,
    EnvironmentalRangeIn)
{
}

DetachableSensorBaseType::~DetachableSensorBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void DetachableSensorBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (ProtectionClass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProtectionClass");
      ProtectionClass->printSelf(outFile);
      fprintf(outFile, "</ProtectionClass>\n");
    }
  if (LinearityError)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LinearityError");
      LinearityError->printSelf(outFile);
      fprintf(outFile, "</LinearityError>\n");
    }
  if (Repeatability)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Repeatability");
      Repeatability->printSelf(outFile);
      fprintf(outFile, "</Repeatability>\n");
    }
  if (Sensitivity)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Sensitivity");
      Sensitivity->printSelf(outFile);
      fprintf(outFile, "</Sensitivity>\n");
    }
  if (Resolution)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Resolution");
      Resolution->printSelf(outFile);
      fprintf(outFile, "</Resolution>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool DetachableSensorBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in DetachableSensorBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in DetachableSensorBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in DetachableSensorBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in DetachableSensorBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class DetachableSensorBaseTypeLisd

*/

DetachableSensorBaseTypeLisd::DetachableSensorBaseTypeLisd() {}

DetachableSensorBaseTypeLisd::DetachableSensorBaseTypeLisd(DetachableSensorBaseType * aDetachableSensorBaseType)
{
  push_back(aDetachableSensorBaseType);
}

DetachableSensorBaseTypeLisd::~DetachableSensorBaseTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<DetachableSensorBaseType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void DetachableSensorBaseTypeLisd::printSelf(FILE * outFile)
{
  std::list<DetachableSensorBaseType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class DetachableSensorsType

*/

DetachableSensorsType::DetachableSensorsType()
{
  n = 0;
  DetachableSensor = 0;
}

DetachableSensorsType::DetachableSensorsType(
 DetachableSensorBaseTypeLisd * DetachableSensorIn)
{
  n = 0;
  DetachableSensor = DetachableSensorIn;
}

DetachableSensorsType::DetachableSensorsType(
 NaturalType * nIn,
 DetachableSensorBaseTypeLisd * DetachableSensorIn)
{
  n = nIn;
  DetachableSensor = DetachableSensorIn;
}

DetachableSensorsType::~DetachableSensorsType()
{
  #ifndef NODESTRUCT
  delete n;
  delete DetachableSensor;
  #endif
}

void DetachableSensorsType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!DetachableSensor)
      {
        fprintf(stderr, "DetachableSensor list is missing\n");
        exit(1);
      }
    if (DetachableSensor->size() == 0)
      {
        fprintf(stderr, "DetachableSensor list is empty\n");
        exit(1);
      }
    if (DetachableSensor->size() < 1)
      {
        fprintf(stderr,
                "size of DetachableSensor list (%d) less than minimum required (1)\n",
                (int)DetachableSensor->size());
        exit(1);
      }
    std::list<DetachableSensorBaseType *>::iterator iter;
    for (iter = DetachableSensor->begin();
         iter != DetachableSensor->end(); iter++)
      {
        DetachableSensorBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->getprintElement(), "DetachableTactileProbeSensor") == 0)
          {
            TactileProbeSensorBaseType * typ;
            if ((typ = dynamic_cast<TactileProbeSensorBaseType *>(basie)))
              {
                fprintf(outFile, "<DetachableTactileProbeSensor");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</DetachableTactileProbeSensor>\n");
              }
            else
              {
                fprintf(stderr, "bad DetachableTactileProbeSensor element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "DetachableCapacitiveSensor") == 0)
          {
            CapacitiveSensorType * typ;
            if ((typ = dynamic_cast<CapacitiveSensorType *>(basie)))
              {
                fprintf(outFile, "<DetachableCapacitiveSensor");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</DetachableCapacitiveSensor>\n");
              }
            else
              {
                fprintf(stderr, "bad DetachableCapacitiveSensor element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "DetachableLVDTSensor") == 0)
          {
            LinearVariableDifferentialTransformerSensorType * typ;
            if ((typ = dynamic_cast<LinearVariableDifferentialTransformerSensorType *>(basie)))
              {
                fprintf(outFile, "<DetachableLVDTSensor");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</DetachableLVDTSensor>\n");
              }
            else
              {
                fprintf(stderr, "bad DetachableLVDTSensor element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SimpleTactileProbeSensor") == 0)
          {
            SimpleTactileProbeSensorType * typ;
            if ((typ = dynamic_cast<SimpleTactileProbeSensorType *>(basie)))
              {
                fprintf(outFile, "<SimpleTactileProbeSensor");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SimpleTactileProbeSensor>\n");
              }
            else
              {
                fprintf(stderr, "bad SimpleTactileProbeSensor element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ComplexTactileProbeSensor") == 0)
          {
            ComplexTactileProbeSensorType * typ;
            if ((typ = dynamic_cast<ComplexTactileProbeSensorType *>(basie)))
              {
                fprintf(outFile, "<ComplexTactileProbeSensor");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ComplexTactileProbeSensor>\n");
              }
            else
              {
                fprintf(stderr, "bad ComplexTactileProbeSensor element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad DetachableSensor type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool DetachableSensorsType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in DetachableSensorsType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in DetachableSensorsType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in DetachableSensorsType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in DetachableSensorsType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * DetachableSensorsType::getn()
{return n;}

void DetachableSensorsType::setn(NaturalType * nIn)
{n = nIn;}

DetachableSensorBaseTypeLisd * DetachableSensorsType::getDetachableSensor()
{return DetachableSensor;}

void DetachableSensorsType::setDetachableSensor(DetachableSensorBaseTypeLisd * DetachableSensorIn)
{DetachableSensor = DetachableSensorIn;}

/* ***************************************************************** */

/* class DifferentialVariableReluctanceTransducerSensorType

*/

DifferentialVariableReluctanceTransducerSensorType::DifferentialVariableReluctanceTransducerSensorType() :
  SensorType()
{
  MinMeasuringDistance = 0;
  MaxMeasuringDistance = 0;
  Hysteresis = 0;
  FrequencyResponse = 0;
  TemperatureStability = 0;
  HousingMaterial = 0;
}

DifferentialVariableReluctanceTransducerSensorType::DifferentialVariableReluctanceTransducerSensorType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 XmlString * ProtectionClassIn,
 XmlString * LinearityErrorIn,
 LinearValueType * RepeatabilityIn,
 XmlDecimal * SensitivityIn,
 LinearValueType * ResolutionIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 LinearValueType * HysteresisIn,
 UserDefinedUnitValueType * FrequencyResponseIn,
 UserDefinedUnitValueType * TemperatureStabilityIn,
 XmlString * HousingMaterialIn) :
  SensorType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    ProtectionClassIn,
    LinearityErrorIn,
    RepeatabilityIn,
    SensitivityIn,
    ResolutionIn,
    EnvironmentalRangeIn)
{
  MinMeasuringDistance = MinMeasuringDistanceIn;
  MaxMeasuringDistance = MaxMeasuringDistanceIn;
  Hysteresis = HysteresisIn;
  FrequencyResponse = FrequencyResponseIn;
  TemperatureStability = TemperatureStabilityIn;
  HousingMaterial = HousingMaterialIn;
}

DifferentialVariableReluctanceTransducerSensorType::DifferentialVariableReluctanceTransducerSensorType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 XmlString * ProtectionClassIn,
 XmlString * LinearityErrorIn,
 LinearValueType * RepeatabilityIn,
 XmlDecimal * SensitivityIn,
 LinearValueType * ResolutionIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 LinearValueType * HysteresisIn,
 UserDefinedUnitValueType * FrequencyResponseIn,
 UserDefinedUnitValueType * TemperatureStabilityIn,
 XmlString * HousingMaterialIn) :
  SensorType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    ProtectionClassIn,
    LinearityErrorIn,
    RepeatabilityIn,
    SensitivityIn,
    ResolutionIn,
    EnvironmentalRangeIn)
{
  MinMeasuringDistance = MinMeasuringDistanceIn;
  MaxMeasuringDistance = MaxMeasuringDistanceIn;
  Hysteresis = HysteresisIn;
  FrequencyResponse = FrequencyResponseIn;
  TemperatureStability = TemperatureStabilityIn;
  HousingMaterial = HousingMaterialIn;
}

DifferentialVariableReluctanceTransducerSensorType::~DifferentialVariableReluctanceTransducerSensorType()
{
  #ifndef NODESTRUCT
  delete MinMeasuringDistance;
  delete MaxMeasuringDistance;
  delete Hysteresis;
  delete FrequencyResponse;
  delete TemperatureStability;
  delete HousingMaterial;
  #endif
}

void DifferentialVariableReluctanceTransducerSensorType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (ProtectionClass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProtectionClass");
      ProtectionClass->printSelf(outFile);
      fprintf(outFile, "</ProtectionClass>\n");
    }
  if (LinearityError)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LinearityError");
      LinearityError->printSelf(outFile);
      fprintf(outFile, "</LinearityError>\n");
    }
  if (Repeatability)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Repeatability");
      Repeatability->printSelf(outFile);
      fprintf(outFile, "</Repeatability>\n");
    }
  if (Sensitivity)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Sensitivity");
      Sensitivity->printSelf(outFile);
      fprintf(outFile, "</Sensitivity>\n");
    }
  if (Resolution)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Resolution");
      Resolution->printSelf(outFile);
      fprintf(outFile, "</Resolution>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (MinMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinMeasuringDistance");
      MinMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MinMeasuringDistance>\n");
    }
  if (MaxMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxMeasuringDistance");
      MaxMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MaxMeasuringDistance>\n");
    }
  if (Hysteresis)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Hysteresis");
      Hysteresis->printSelf(outFile);
      fprintf(outFile, "</Hysteresis>\n");
    }
  if (FrequencyResponse)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FrequencyResponse");
      FrequencyResponse->printSelf(outFile);
      fprintf(outFile, "</FrequencyResponse>\n");
    }
  if (TemperatureStability)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TemperatureStability");
      TemperatureStability->printSelf(outFile);
      fprintf(outFile, "</TemperatureStability>\n");
    }
  if (HousingMaterial)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<HousingMaterial");
      HousingMaterial->printSelf(outFile);
      fprintf(outFile, "</HousingMaterial>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool DifferentialVariableReluctanceTransducerSensorType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in DifferentialVariableReluctanceTransducerSensorType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in DifferentialVariableReluctanceTransducerSensorType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in DifferentialVariableReluctanceTransducerSensorType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in DifferentialVariableReluctanceTransducerSensorType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LinearValueType * DifferentialVariableReluctanceTransducerSensorType::getMinMeasuringDistance()
{return MinMeasuringDistance;}

void DifferentialVariableReluctanceTransducerSensorType::setMinMeasuringDistance(LinearValueType * MinMeasuringDistanceIn)
{MinMeasuringDistance = MinMeasuringDistanceIn;}

LinearValueType * DifferentialVariableReluctanceTransducerSensorType::getMaxMeasuringDistance()
{return MaxMeasuringDistance;}

void DifferentialVariableReluctanceTransducerSensorType::setMaxMeasuringDistance(LinearValueType * MaxMeasuringDistanceIn)
{MaxMeasuringDistance = MaxMeasuringDistanceIn;}

LinearValueType * DifferentialVariableReluctanceTransducerSensorType::getHysteresis()
{return Hysteresis;}

void DifferentialVariableReluctanceTransducerSensorType::setHysteresis(LinearValueType * HysteresisIn)
{Hysteresis = HysteresisIn;}

UserDefinedUnitValueType * DifferentialVariableReluctanceTransducerSensorType::getFrequencyResponse()
{return FrequencyResponse;}

void DifferentialVariableReluctanceTransducerSensorType::setFrequencyResponse(UserDefinedUnitValueType * FrequencyResponseIn)
{FrequencyResponse = FrequencyResponseIn;}

UserDefinedUnitValueType * DifferentialVariableReluctanceTransducerSensorType::getTemperatureStability()
{return TemperatureStability;}

void DifferentialVariableReluctanceTransducerSensorType::setTemperatureStability(UserDefinedUnitValueType * TemperatureStabilityIn)
{TemperatureStability = TemperatureStabilityIn;}

XmlString * DifferentialVariableReluctanceTransducerSensorType::getHousingMaterial()
{return HousingMaterial;}

void DifferentialVariableReluctanceTransducerSensorType::setHousingMaterial(XmlString * HousingMaterialIn)
{HousingMaterial = HousingMaterialIn;}

/* ***************************************************************** */

/* class DrawWireSensorType

*/

DrawWireSensorType::DrawWireSensorType() :
  SensorType()
{
  MinMeasuringDistance = 0;
  MaxMeasuringDistance = 0;
  MaxWireExtensionForce = 0;
  MinWireRetractionForce = 0;
  MaxWireAcceleration = 0;
}

DrawWireSensorType::DrawWireSensorType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 XmlString * ProtectionClassIn,
 XmlString * LinearityErrorIn,
 LinearValueType * RepeatabilityIn,
 XmlDecimal * SensitivityIn,
 LinearValueType * ResolutionIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 ForceValueType * MaxWireExtensionForceIn,
 ForceValueType * MinWireRetractionForceIn,
 XmlString * MaxWireAccelerationIn) :
  SensorType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    ProtectionClassIn,
    LinearityErrorIn,
    RepeatabilityIn,
    SensitivityIn,
    ResolutionIn,
    EnvironmentalRangeIn)
{
  MinMeasuringDistance = MinMeasuringDistanceIn;
  MaxMeasuringDistance = MaxMeasuringDistanceIn;
  MaxWireExtensionForce = MaxWireExtensionForceIn;
  MinWireRetractionForce = MinWireRetractionForceIn;
  MaxWireAcceleration = MaxWireAccelerationIn;
}

DrawWireSensorType::DrawWireSensorType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 XmlString * ProtectionClassIn,
 XmlString * LinearityErrorIn,
 LinearValueType * RepeatabilityIn,
 XmlDecimal * SensitivityIn,
 LinearValueType * ResolutionIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 ForceValueType * MaxWireExtensionForceIn,
 ForceValueType * MinWireRetractionForceIn,
 XmlString * MaxWireAccelerationIn) :
  SensorType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    ProtectionClassIn,
    LinearityErrorIn,
    RepeatabilityIn,
    SensitivityIn,
    ResolutionIn,
    EnvironmentalRangeIn)
{
  MinMeasuringDistance = MinMeasuringDistanceIn;
  MaxMeasuringDistance = MaxMeasuringDistanceIn;
  MaxWireExtensionForce = MaxWireExtensionForceIn;
  MinWireRetractionForce = MinWireRetractionForceIn;
  MaxWireAcceleration = MaxWireAccelerationIn;
}

DrawWireSensorType::~DrawWireSensorType()
{
  #ifndef NODESTRUCT
  delete MinMeasuringDistance;
  delete MaxMeasuringDistance;
  delete MaxWireExtensionForce;
  delete MinWireRetractionForce;
  delete MaxWireAcceleration;
  #endif
}

void DrawWireSensorType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (ProtectionClass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProtectionClass");
      ProtectionClass->printSelf(outFile);
      fprintf(outFile, "</ProtectionClass>\n");
    }
  if (LinearityError)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LinearityError");
      LinearityError->printSelf(outFile);
      fprintf(outFile, "</LinearityError>\n");
    }
  if (Repeatability)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Repeatability");
      Repeatability->printSelf(outFile);
      fprintf(outFile, "</Repeatability>\n");
    }
  if (Sensitivity)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Sensitivity");
      Sensitivity->printSelf(outFile);
      fprintf(outFile, "</Sensitivity>\n");
    }
  if (Resolution)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Resolution");
      Resolution->printSelf(outFile);
      fprintf(outFile, "</Resolution>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (MinMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinMeasuringDistance");
      MinMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MinMeasuringDistance>\n");
    }
  if (MaxMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxMeasuringDistance");
      MaxMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MaxMeasuringDistance>\n");
    }
  if (MaxWireExtensionForce)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxWireExtensionForce");
      MaxWireExtensionForce->printSelf(outFile);
      fprintf(outFile, "</MaxWireExtensionForce>\n");
    }
  if (MinWireRetractionForce)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinWireRetractionForce");
      MinWireRetractionForce->printSelf(outFile);
      fprintf(outFile, "</MinWireRetractionForce>\n");
    }
  if (MaxWireAcceleration)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxWireAcceleration");
      MaxWireAcceleration->printSelf(outFile);
      fprintf(outFile, "</MaxWireAcceleration>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool DrawWireSensorType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in DrawWireSensorType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in DrawWireSensorType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in DrawWireSensorType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in DrawWireSensorType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LinearValueType * DrawWireSensorType::getMinMeasuringDistance()
{return MinMeasuringDistance;}

void DrawWireSensorType::setMinMeasuringDistance(LinearValueType * MinMeasuringDistanceIn)
{MinMeasuringDistance = MinMeasuringDistanceIn;}

LinearValueType * DrawWireSensorType::getMaxMeasuringDistance()
{return MaxMeasuringDistance;}

void DrawWireSensorType::setMaxMeasuringDistance(LinearValueType * MaxMeasuringDistanceIn)
{MaxMeasuringDistance = MaxMeasuringDistanceIn;}

ForceValueType * DrawWireSensorType::getMaxWireExtensionForce()
{return MaxWireExtensionForce;}

void DrawWireSensorType::setMaxWireExtensionForce(ForceValueType * MaxWireExtensionForceIn)
{MaxWireExtensionForce = MaxWireExtensionForceIn;}

ForceValueType * DrawWireSensorType::getMinWireRetractionForce()
{return MinWireRetractionForce;}

void DrawWireSensorType::setMinWireRetractionForce(ForceValueType * MinWireRetractionForceIn)
{MinWireRetractionForce = MinWireRetractionForceIn;}

XmlString * DrawWireSensorType::getMaxWireAcceleration()
{return MaxWireAcceleration;}

void DrawWireSensorType::setMaxWireAcceleration(XmlString * MaxWireAccelerationIn)
{MaxWireAcceleration = MaxWireAccelerationIn;}

/* ***************************************************************** */

/* class EddyCurrentSensorType

*/

EddyCurrentSensorType::EddyCurrentSensorType() :
  SensorType()
{
  MaxPressureFront = 0;
  MaxPressureSide = 0;
  MinMeasuringDistance = 0;
  MaxMeasuringDistance = 0;
  TemperatureStability = 0;
  OffsetDistance = 0;
  FrequencyResponse = 0;
  MinPowerSupplyVoltage = 0;
  MaxPowerSupplyVoltage = 0;
  HousingMaterial = 0;
  MeasurementObjectMaterial = 0;
}

EddyCurrentSensorType::EddyCurrentSensorType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 XmlString * ProtectionClassIn,
 XmlString * LinearityErrorIn,
 LinearValueType * RepeatabilityIn,
 XmlDecimal * SensitivityIn,
 LinearValueType * ResolutionIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 PressureValueType * MaxPressureFrontIn,
 PressureValueType * MaxPressureSideIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 UserDefinedUnitValueType * TemperatureStabilityIn,
 LinearValueType * OffsetDistanceIn,
 UserDefinedUnitValueType * FrequencyResponseIn,
 UserDefinedUnitValueType * MinPowerSupplyVoltageIn,
 UserDefinedUnitValueType * MaxPowerSupplyVoltageIn,
 XmlString * HousingMaterialIn,
 XmlString * MeasurementObjectMaterialIn) :
  SensorType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    ProtectionClassIn,
    LinearityErrorIn,
    RepeatabilityIn,
    SensitivityIn,
    ResolutionIn,
    EnvironmentalRangeIn)
{
  MaxPressureFront = MaxPressureFrontIn;
  MaxPressureSide = MaxPressureSideIn;
  MinMeasuringDistance = MinMeasuringDistanceIn;
  MaxMeasuringDistance = MaxMeasuringDistanceIn;
  TemperatureStability = TemperatureStabilityIn;
  OffsetDistance = OffsetDistanceIn;
  FrequencyResponse = FrequencyResponseIn;
  MinPowerSupplyVoltage = MinPowerSupplyVoltageIn;
  MaxPowerSupplyVoltage = MaxPowerSupplyVoltageIn;
  HousingMaterial = HousingMaterialIn;
  MeasurementObjectMaterial = MeasurementObjectMaterialIn;
}

EddyCurrentSensorType::EddyCurrentSensorType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 XmlString * ProtectionClassIn,
 XmlString * LinearityErrorIn,
 LinearValueType * RepeatabilityIn,
 XmlDecimal * SensitivityIn,
 LinearValueType * ResolutionIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 PressureValueType * MaxPressureFrontIn,
 PressureValueType * MaxPressureSideIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 UserDefinedUnitValueType * TemperatureStabilityIn,
 LinearValueType * OffsetDistanceIn,
 UserDefinedUnitValueType * FrequencyResponseIn,
 UserDefinedUnitValueType * MinPowerSupplyVoltageIn,
 UserDefinedUnitValueType * MaxPowerSupplyVoltageIn,
 XmlString * HousingMaterialIn,
 XmlString * MeasurementObjectMaterialIn) :
  SensorType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    ProtectionClassIn,
    LinearityErrorIn,
    RepeatabilityIn,
    SensitivityIn,
    ResolutionIn,
    EnvironmentalRangeIn)
{
  MaxPressureFront = MaxPressureFrontIn;
  MaxPressureSide = MaxPressureSideIn;
  MinMeasuringDistance = MinMeasuringDistanceIn;
  MaxMeasuringDistance = MaxMeasuringDistanceIn;
  TemperatureStability = TemperatureStabilityIn;
  OffsetDistance = OffsetDistanceIn;
  FrequencyResponse = FrequencyResponseIn;
  MinPowerSupplyVoltage = MinPowerSupplyVoltageIn;
  MaxPowerSupplyVoltage = MaxPowerSupplyVoltageIn;
  HousingMaterial = HousingMaterialIn;
  MeasurementObjectMaterial = MeasurementObjectMaterialIn;
}

EddyCurrentSensorType::~EddyCurrentSensorType()
{
  #ifndef NODESTRUCT
  delete MaxPressureFront;
  delete MaxPressureSide;
  delete MinMeasuringDistance;
  delete MaxMeasuringDistance;
  delete TemperatureStability;
  delete OffsetDistance;
  delete FrequencyResponse;
  delete MinPowerSupplyVoltage;
  delete MaxPowerSupplyVoltage;
  delete HousingMaterial;
  delete MeasurementObjectMaterial;
  #endif
}

void EddyCurrentSensorType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (ProtectionClass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProtectionClass");
      ProtectionClass->printSelf(outFile);
      fprintf(outFile, "</ProtectionClass>\n");
    }
  if (LinearityError)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LinearityError");
      LinearityError->printSelf(outFile);
      fprintf(outFile, "</LinearityError>\n");
    }
  if (Repeatability)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Repeatability");
      Repeatability->printSelf(outFile);
      fprintf(outFile, "</Repeatability>\n");
    }
  if (Sensitivity)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Sensitivity");
      Sensitivity->printSelf(outFile);
      fprintf(outFile, "</Sensitivity>\n");
    }
  if (Resolution)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Resolution");
      Resolution->printSelf(outFile);
      fprintf(outFile, "</Resolution>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (MaxPressureFront)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxPressureFront");
      MaxPressureFront->printSelf(outFile);
      fprintf(outFile, "</MaxPressureFront>\n");
    }
  if (MaxPressureSide)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxPressureSide");
      MaxPressureSide->printSelf(outFile);
      fprintf(outFile, "</MaxPressureSide>\n");
    }
  if (MinMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinMeasuringDistance");
      MinMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MinMeasuringDistance>\n");
    }
  if (MaxMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxMeasuringDistance");
      MaxMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MaxMeasuringDistance>\n");
    }
  if (TemperatureStability)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TemperatureStability");
      TemperatureStability->printSelf(outFile);
      fprintf(outFile, "</TemperatureStability>\n");
    }
  if (OffsetDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OffsetDistance");
      OffsetDistance->printSelf(outFile);
      fprintf(outFile, "</OffsetDistance>\n");
    }
  if (FrequencyResponse)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FrequencyResponse");
      FrequencyResponse->printSelf(outFile);
      fprintf(outFile, "</FrequencyResponse>\n");
    }
  if (MinPowerSupplyVoltage)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinPowerSupplyVoltage");
      MinPowerSupplyVoltage->printSelf(outFile);
      fprintf(outFile, "</MinPowerSupplyVoltage>\n");
    }
  if (MaxPowerSupplyVoltage)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxPowerSupplyVoltage");
      MaxPowerSupplyVoltage->printSelf(outFile);
      fprintf(outFile, "</MaxPowerSupplyVoltage>\n");
    }
  if (HousingMaterial)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<HousingMaterial");
      HousingMaterial->printSelf(outFile);
      fprintf(outFile, "</HousingMaterial>\n");
    }
  if (MeasurementObjectMaterial)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementObjectMaterial");
      MeasurementObjectMaterial->printSelf(outFile);
      fprintf(outFile, "</MeasurementObjectMaterial>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool EddyCurrentSensorType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in EddyCurrentSensorType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in EddyCurrentSensorType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in EddyCurrentSensorType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in EddyCurrentSensorType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

PressureValueType * EddyCurrentSensorType::getMaxPressureFront()
{return MaxPressureFront;}

void EddyCurrentSensorType::setMaxPressureFront(PressureValueType * MaxPressureFrontIn)
{MaxPressureFront = MaxPressureFrontIn;}

PressureValueType * EddyCurrentSensorType::getMaxPressureSide()
{return MaxPressureSide;}

void EddyCurrentSensorType::setMaxPressureSide(PressureValueType * MaxPressureSideIn)
{MaxPressureSide = MaxPressureSideIn;}

LinearValueType * EddyCurrentSensorType::getMinMeasuringDistance()
{return MinMeasuringDistance;}

void EddyCurrentSensorType::setMinMeasuringDistance(LinearValueType * MinMeasuringDistanceIn)
{MinMeasuringDistance = MinMeasuringDistanceIn;}

LinearValueType * EddyCurrentSensorType::getMaxMeasuringDistance()
{return MaxMeasuringDistance;}

void EddyCurrentSensorType::setMaxMeasuringDistance(LinearValueType * MaxMeasuringDistanceIn)
{MaxMeasuringDistance = MaxMeasuringDistanceIn;}

UserDefinedUnitValueType * EddyCurrentSensorType::getTemperatureStability()
{return TemperatureStability;}

void EddyCurrentSensorType::setTemperatureStability(UserDefinedUnitValueType * TemperatureStabilityIn)
{TemperatureStability = TemperatureStabilityIn;}

LinearValueType * EddyCurrentSensorType::getOffsetDistance()
{return OffsetDistance;}

void EddyCurrentSensorType::setOffsetDistance(LinearValueType * OffsetDistanceIn)
{OffsetDistance = OffsetDistanceIn;}

UserDefinedUnitValueType * EddyCurrentSensorType::getFrequencyResponse()
{return FrequencyResponse;}

void EddyCurrentSensorType::setFrequencyResponse(UserDefinedUnitValueType * FrequencyResponseIn)
{FrequencyResponse = FrequencyResponseIn;}

UserDefinedUnitValueType * EddyCurrentSensorType::getMinPowerSupplyVoltage()
{return MinPowerSupplyVoltage;}

void EddyCurrentSensorType::setMinPowerSupplyVoltage(UserDefinedUnitValueType * MinPowerSupplyVoltageIn)
{MinPowerSupplyVoltage = MinPowerSupplyVoltageIn;}

UserDefinedUnitValueType * EddyCurrentSensorType::getMaxPowerSupplyVoltage()
{return MaxPowerSupplyVoltage;}

void EddyCurrentSensorType::setMaxPowerSupplyVoltage(UserDefinedUnitValueType * MaxPowerSupplyVoltageIn)
{MaxPowerSupplyVoltage = MaxPowerSupplyVoltageIn;}

XmlString * EddyCurrentSensorType::getHousingMaterial()
{return HousingMaterial;}

void EddyCurrentSensorType::setHousingMaterial(XmlString * HousingMaterialIn)
{HousingMaterial = HousingMaterialIn;}

XmlString * EddyCurrentSensorType::getMeasurementObjectMaterial()
{return MeasurementObjectMaterial;}

void EddyCurrentSensorType::setMeasurementObjectMaterial(XmlString * MeasurementObjectMaterialIn)
{MeasurementObjectMaterial = MeasurementObjectMaterialIn;}

/* ***************************************************************** */

/* class EffectiveCartesianWorkingVolumeType

*/

EffectiveCartesianWorkingVolumeType::EffectiveCartesianWorkingVolumeType() :
  EffectiveWorkingVolumeBaseType()
{
  MinPoint = 0;
  MaxPoint = 0;
}

EffectiveCartesianWorkingVolumeType::EffectiveCartesianWorkingVolumeType(
 PointType * MinPointIn,
 PointType * MaxPointIn) :
  EffectiveWorkingVolumeBaseType()
{
  MinPoint = MinPointIn;
  MaxPoint = MaxPointIn;
}

EffectiveCartesianWorkingVolumeType::~EffectiveCartesianWorkingVolumeType()
{
  #ifndef NODESTRUCT
  delete MinPoint;
  delete MaxPoint;
  #endif
}

void EffectiveCartesianWorkingVolumeType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<MinPoint");
  MinPoint->printSelf(outFile);
  fprintf(outFile, "</MinPoint>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxPoint");
  MaxPoint->printSelf(outFile);
  fprintf(outFile, "</MaxPoint>\n");
  doSpaces(-INDENT, outFile);
}

PointType * EffectiveCartesianWorkingVolumeType::getMinPoint()
{return MinPoint;}

void EffectiveCartesianWorkingVolumeType::setMinPoint(PointType * MinPointIn)
{MinPoint = MinPointIn;}

PointType * EffectiveCartesianWorkingVolumeType::getMaxPoint()
{return MaxPoint;}

void EffectiveCartesianWorkingVolumeType::setMaxPoint(PointType * MaxPointIn)
{MaxPoint = MaxPointIn;}

/* ***************************************************************** */

/* class EffectiveClosedShellSetWorkingVolumeType

*/

EffectiveClosedShellSetWorkingVolumeType::EffectiveClosedShellSetWorkingVolumeType() :
  EffectiveWorkingVolumeBaseType()
{
  WorkingClosedShellSet = 0;
}

EffectiveClosedShellSetWorkingVolumeType::EffectiveClosedShellSetWorkingVolumeType(
 ClosedShellSetType * WorkingClosedShellSetIn) :
  EffectiveWorkingVolumeBaseType()
{
  WorkingClosedShellSet = WorkingClosedShellSetIn;
}

EffectiveClosedShellSetWorkingVolumeType::~EffectiveClosedShellSetWorkingVolumeType()
{
  #ifndef NODESTRUCT
  delete WorkingClosedShellSet;
  #endif
}

void EffectiveClosedShellSetWorkingVolumeType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<WorkingClosedShellSet");
  WorkingClosedShellSet->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</WorkingClosedShellSet>\n");
  doSpaces(-INDENT, outFile);
}

ClosedShellSetType * EffectiveClosedShellSetWorkingVolumeType::getWorkingClosedShellSet()
{return WorkingClosedShellSet;}

void EffectiveClosedShellSetWorkingVolumeType::setWorkingClosedShellSet(ClosedShellSetType * WorkingClosedShellSetIn)
{WorkingClosedShellSet = WorkingClosedShellSetIn;}

/* ***************************************************************** */

/* class EffectiveCylindricalWorkingVolumeType

*/

EffectiveCylindricalWorkingVolumeType::EffectiveCylindricalWorkingVolumeType() :
  EffectiveWorkingVolumeBaseType()
{
  MinRadius = 0;
  MaxRadius = 0;
  MinAzimuthalAxisAngle = 0;
  MaxAzimuthalAxisAngle = 0;
  MinZAxis = 0;
  MaxZAxis = 0;
}

EffectiveCylindricalWorkingVolumeType::EffectiveCylindricalWorkingVolumeType(
 LinearValueType * MinRadiusIn,
 LinearValueType * MaxRadiusIn,
 AngularValueType * MinAzimuthalAxisAngleIn,
 AngularValueType * MaxAzimuthalAxisAngleIn,
 LinearValueType * MinZAxisIn,
 LinearValueType * MaxZAxisIn) :
  EffectiveWorkingVolumeBaseType()
{
  MinRadius = MinRadiusIn;
  MaxRadius = MaxRadiusIn;
  MinAzimuthalAxisAngle = MinAzimuthalAxisAngleIn;
  MaxAzimuthalAxisAngle = MaxAzimuthalAxisAngleIn;
  MinZAxis = MinZAxisIn;
  MaxZAxis = MaxZAxisIn;
}

EffectiveCylindricalWorkingVolumeType::~EffectiveCylindricalWorkingVolumeType()
{
  #ifndef NODESTRUCT
  delete MinRadius;
  delete MaxRadius;
  delete MinAzimuthalAxisAngle;
  delete MaxAzimuthalAxisAngle;
  delete MinZAxis;
  delete MaxZAxis;
  #endif
}

void EffectiveCylindricalWorkingVolumeType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<MinRadius");
  MinRadius->printSelf(outFile);
  fprintf(outFile, "</MinRadius>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxRadius");
  MaxRadius->printSelf(outFile);
  fprintf(outFile, "</MaxRadius>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MinAzimuthalAxisAngle");
  MinAzimuthalAxisAngle->printSelf(outFile);
  fprintf(outFile, "</MinAzimuthalAxisAngle>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxAzimuthalAxisAngle");
  MaxAzimuthalAxisAngle->printSelf(outFile);
  fprintf(outFile, "</MaxAzimuthalAxisAngle>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MinZAxis");
  MinZAxis->printSelf(outFile);
  fprintf(outFile, "</MinZAxis>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxZAxis");
  MaxZAxis->printSelf(outFile);
  fprintf(outFile, "</MaxZAxis>\n");
  doSpaces(-INDENT, outFile);
}

LinearValueType * EffectiveCylindricalWorkingVolumeType::getMinRadius()
{return MinRadius;}

void EffectiveCylindricalWorkingVolumeType::setMinRadius(LinearValueType * MinRadiusIn)
{MinRadius = MinRadiusIn;}

LinearValueType * EffectiveCylindricalWorkingVolumeType::getMaxRadius()
{return MaxRadius;}

void EffectiveCylindricalWorkingVolumeType::setMaxRadius(LinearValueType * MaxRadiusIn)
{MaxRadius = MaxRadiusIn;}

AngularValueType * EffectiveCylindricalWorkingVolumeType::getMinAzimuthalAxisAngle()
{return MinAzimuthalAxisAngle;}

void EffectiveCylindricalWorkingVolumeType::setMinAzimuthalAxisAngle(AngularValueType * MinAzimuthalAxisAngleIn)
{MinAzimuthalAxisAngle = MinAzimuthalAxisAngleIn;}

AngularValueType * EffectiveCylindricalWorkingVolumeType::getMaxAzimuthalAxisAngle()
{return MaxAzimuthalAxisAngle;}

void EffectiveCylindricalWorkingVolumeType::setMaxAzimuthalAxisAngle(AngularValueType * MaxAzimuthalAxisAngleIn)
{MaxAzimuthalAxisAngle = MaxAzimuthalAxisAngleIn;}

LinearValueType * EffectiveCylindricalWorkingVolumeType::getMinZAxis()
{return MinZAxis;}

void EffectiveCylindricalWorkingVolumeType::setMinZAxis(LinearValueType * MinZAxisIn)
{MinZAxis = MinZAxisIn;}

LinearValueType * EffectiveCylindricalWorkingVolumeType::getMaxZAxis()
{return MaxZAxis;}

void EffectiveCylindricalWorkingVolumeType::setMaxZAxis(LinearValueType * MaxZAxisIn)
{MaxZAxis = MaxZAxisIn;}

/* ***************************************************************** */

/* class EffectiveDiameterPerformanceTestType

*/

EffectiveDiameterPerformanceTestType::EffectiveDiameterPerformanceTestType()
{
  AverageDiameter = 0;
  StandardDeviation = 0;
}

EffectiveDiameterPerformanceTestType::EffectiveDiameterPerformanceTestType(
 XmlDecimal * AverageDiameterIn,
 XmlDecimal * StandardDeviationIn)
{
  AverageDiameter = AverageDiameterIn;
  StandardDeviation = StandardDeviationIn;
}

EffectiveDiameterPerformanceTestType::~EffectiveDiameterPerformanceTestType()
{
  #ifndef NODESTRUCT
  delete AverageDiameter;
  delete StandardDeviation;
  #endif
}

void EffectiveDiameterPerformanceTestType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<AverageDiameter");
  AverageDiameter->printSelf(outFile);
  fprintf(outFile, "</AverageDiameter>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<StandardDeviation");
  StandardDeviation->printSelf(outFile);
  fprintf(outFile, "</StandardDeviation>\n");
  doSpaces(-INDENT, outFile);
}

XmlDecimal * EffectiveDiameterPerformanceTestType::getAverageDiameter()
{return AverageDiameter;}

void EffectiveDiameterPerformanceTestType::setAverageDiameter(XmlDecimal * AverageDiameterIn)
{AverageDiameter = AverageDiameterIn;}

XmlDecimal * EffectiveDiameterPerformanceTestType::getStandardDeviation()
{return StandardDeviation;}

void EffectiveDiameterPerformanceTestType::setStandardDeviation(XmlDecimal * StandardDeviationIn)
{StandardDeviation = StandardDeviationIn;}

/* ***************************************************************** */

/* class EffectiveSphericalWorkingVolumeType

*/

EffectiveSphericalWorkingVolumeType::EffectiveSphericalWorkingVolumeType() :
  EffectiveWorkingVolumeBaseType()
{
  MinRadialAxis = 0;
  MaxRadialAxis = 0;
  MinAzimuthalAxisAngle = 0;
  MaxAzimuthalAxisAngle = 0;
  MinPolarAxis = 0;
  MaxPolarAxis = 0;
}

EffectiveSphericalWorkingVolumeType::EffectiveSphericalWorkingVolumeType(
 LinearValueType * MinRadialAxisIn,
 LinearValueType * MaxRadialAxisIn,
 AngularValueType * MinAzimuthalAxisAngleIn,
 AngularValueType * MaxAzimuthalAxisAngleIn,
 AngularValueType * MinPolarAxisIn,
 AngularValueType * MaxPolarAxisIn) :
  EffectiveWorkingVolumeBaseType()
{
  MinRadialAxis = MinRadialAxisIn;
  MaxRadialAxis = MaxRadialAxisIn;
  MinAzimuthalAxisAngle = MinAzimuthalAxisAngleIn;
  MaxAzimuthalAxisAngle = MaxAzimuthalAxisAngleIn;
  MinPolarAxis = MinPolarAxisIn;
  MaxPolarAxis = MaxPolarAxisIn;
}

EffectiveSphericalWorkingVolumeType::~EffectiveSphericalWorkingVolumeType()
{
  #ifndef NODESTRUCT
  delete MinRadialAxis;
  delete MaxRadialAxis;
  delete MinAzimuthalAxisAngle;
  delete MaxAzimuthalAxisAngle;
  delete MinPolarAxis;
  delete MaxPolarAxis;
  #endif
}

void EffectiveSphericalWorkingVolumeType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<MinRadialAxis");
  MinRadialAxis->printSelf(outFile);
  fprintf(outFile, "</MinRadialAxis>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxRadialAxis");
  MaxRadialAxis->printSelf(outFile);
  fprintf(outFile, "</MaxRadialAxis>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MinAzimuthalAxisAngle");
  MinAzimuthalAxisAngle->printSelf(outFile);
  fprintf(outFile, "</MinAzimuthalAxisAngle>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxAzimuthalAxisAngle");
  MaxAzimuthalAxisAngle->printSelf(outFile);
  fprintf(outFile, "</MaxAzimuthalAxisAngle>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MinPolarAxis");
  MinPolarAxis->printSelf(outFile);
  fprintf(outFile, "</MinPolarAxis>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxPolarAxis");
  MaxPolarAxis->printSelf(outFile);
  fprintf(outFile, "</MaxPolarAxis>\n");
  doSpaces(-INDENT, outFile);
}

LinearValueType * EffectiveSphericalWorkingVolumeType::getMinRadialAxis()
{return MinRadialAxis;}

void EffectiveSphericalWorkingVolumeType::setMinRadialAxis(LinearValueType * MinRadialAxisIn)
{MinRadialAxis = MinRadialAxisIn;}

LinearValueType * EffectiveSphericalWorkingVolumeType::getMaxRadialAxis()
{return MaxRadialAxis;}

void EffectiveSphericalWorkingVolumeType::setMaxRadialAxis(LinearValueType * MaxRadialAxisIn)
{MaxRadialAxis = MaxRadialAxisIn;}

AngularValueType * EffectiveSphericalWorkingVolumeType::getMinAzimuthalAxisAngle()
{return MinAzimuthalAxisAngle;}

void EffectiveSphericalWorkingVolumeType::setMinAzimuthalAxisAngle(AngularValueType * MinAzimuthalAxisAngleIn)
{MinAzimuthalAxisAngle = MinAzimuthalAxisAngleIn;}

AngularValueType * EffectiveSphericalWorkingVolumeType::getMaxAzimuthalAxisAngle()
{return MaxAzimuthalAxisAngle;}

void EffectiveSphericalWorkingVolumeType::setMaxAzimuthalAxisAngle(AngularValueType * MaxAzimuthalAxisAngleIn)
{MaxAzimuthalAxisAngle = MaxAzimuthalAxisAngleIn;}

AngularValueType * EffectiveSphericalWorkingVolumeType::getMinPolarAxis()
{return MinPolarAxis;}

void EffectiveSphericalWorkingVolumeType::setMinPolarAxis(AngularValueType * MinPolarAxisIn)
{MinPolarAxis = MinPolarAxisIn;}

AngularValueType * EffectiveSphericalWorkingVolumeType::getMaxPolarAxis()
{return MaxPolarAxis;}

void EffectiveSphericalWorkingVolumeType::setMaxPolarAxis(AngularValueType * MaxPolarAxisIn)
{MaxPolarAxis = MaxPolarAxisIn;}

/* ***************************************************************** */

/* class EffectiveUserDefinedWorkingVolumeType

*/

EffectiveUserDefinedWorkingVolumeType::EffectiveUserDefinedWorkingVolumeType() :
  EffectiveWorkingVolumeBaseType()
{
  UserDefinedWorkingVolumeId = 0;
  MinFirstAxis = 0;
  MaxFirstAxis = 0;
  MinSecondAxis = 0;
  MaxSecondAxis = 0;
  MinThirdAxis = 0;
  MaxThirdAxis = 0;
}

EffectiveUserDefinedWorkingVolumeType::EffectiveUserDefinedWorkingVolumeType(
 QIFReferenceType * UserDefinedWorkingVolumeIdIn,
 MeasuredDecimalType * MinFirstAxisIn,
 MeasuredDecimalType * MaxFirstAxisIn,
 MeasuredDecimalType * MinSecondAxisIn,
 MeasuredDecimalType * MaxSecondAxisIn,
 MeasuredDecimalType * MinThirdAxisIn,
 MeasuredDecimalType * MaxThirdAxisIn) :
  EffectiveWorkingVolumeBaseType()
{
  UserDefinedWorkingVolumeId = UserDefinedWorkingVolumeIdIn;
  MinFirstAxis = MinFirstAxisIn;
  MaxFirstAxis = MaxFirstAxisIn;
  MinSecondAxis = MinSecondAxisIn;
  MaxSecondAxis = MaxSecondAxisIn;
  MinThirdAxis = MinThirdAxisIn;
  MaxThirdAxis = MaxThirdAxisIn;
}

EffectiveUserDefinedWorkingVolumeType::~EffectiveUserDefinedWorkingVolumeType()
{
  #ifndef NODESTRUCT
  delete UserDefinedWorkingVolumeId;
  delete MinFirstAxis;
  delete MaxFirstAxis;
  delete MinSecondAxis;
  delete MaxSecondAxis;
  delete MinThirdAxis;
  delete MaxThirdAxis;
  #endif
}

void EffectiveUserDefinedWorkingVolumeType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<UserDefinedWorkingVolumeId");
  UserDefinedWorkingVolumeId->printSelf(outFile);
  fprintf(outFile, "</UserDefinedWorkingVolumeId>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MinFirstAxis");
  MinFirstAxis->printSelf(outFile);
  fprintf(outFile, "</MinFirstAxis>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxFirstAxis");
  MaxFirstAxis->printSelf(outFile);
  fprintf(outFile, "</MaxFirstAxis>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MinSecondAxis");
  MinSecondAxis->printSelf(outFile);
  fprintf(outFile, "</MinSecondAxis>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxSecondAxis");
  MaxSecondAxis->printSelf(outFile);
  fprintf(outFile, "</MaxSecondAxis>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MinThirdAxis");
  MinThirdAxis->printSelf(outFile);
  fprintf(outFile, "</MinThirdAxis>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxThirdAxis");
  MaxThirdAxis->printSelf(outFile);
  fprintf(outFile, "</MaxThirdAxis>\n");
  doSpaces(-INDENT, outFile);
}

QIFReferenceType * EffectiveUserDefinedWorkingVolumeType::getUserDefinedWorkingVolumeId()
{return UserDefinedWorkingVolumeId;}

void EffectiveUserDefinedWorkingVolumeType::setUserDefinedWorkingVolumeId(QIFReferenceType * UserDefinedWorkingVolumeIdIn)
{UserDefinedWorkingVolumeId = UserDefinedWorkingVolumeIdIn;}

MeasuredDecimalType * EffectiveUserDefinedWorkingVolumeType::getMinFirstAxis()
{return MinFirstAxis;}

void EffectiveUserDefinedWorkingVolumeType::setMinFirstAxis(MeasuredDecimalType * MinFirstAxisIn)
{MinFirstAxis = MinFirstAxisIn;}

MeasuredDecimalType * EffectiveUserDefinedWorkingVolumeType::getMaxFirstAxis()
{return MaxFirstAxis;}

void EffectiveUserDefinedWorkingVolumeType::setMaxFirstAxis(MeasuredDecimalType * MaxFirstAxisIn)
{MaxFirstAxis = MaxFirstAxisIn;}

MeasuredDecimalType * EffectiveUserDefinedWorkingVolumeType::getMinSecondAxis()
{return MinSecondAxis;}

void EffectiveUserDefinedWorkingVolumeType::setMinSecondAxis(MeasuredDecimalType * MinSecondAxisIn)
{MinSecondAxis = MinSecondAxisIn;}

MeasuredDecimalType * EffectiveUserDefinedWorkingVolumeType::getMaxSecondAxis()
{return MaxSecondAxis;}

void EffectiveUserDefinedWorkingVolumeType::setMaxSecondAxis(MeasuredDecimalType * MaxSecondAxisIn)
{MaxSecondAxis = MaxSecondAxisIn;}

MeasuredDecimalType * EffectiveUserDefinedWorkingVolumeType::getMinThirdAxis()
{return MinThirdAxis;}

void EffectiveUserDefinedWorkingVolumeType::setMinThirdAxis(MeasuredDecimalType * MinThirdAxisIn)
{MinThirdAxis = MinThirdAxisIn;}

MeasuredDecimalType * EffectiveUserDefinedWorkingVolumeType::getMaxThirdAxis()
{return MaxThirdAxis;}

void EffectiveUserDefinedWorkingVolumeType::setMaxThirdAxis(MeasuredDecimalType * MaxThirdAxisIn)
{MaxThirdAxis = MaxThirdAxisIn;}

/* ***************************************************************** */

/* class EffectiveWorkingVolumeBaseType

*/

EffectiveWorkingVolumeBaseType::EffectiveWorkingVolumeBaseType()
{}

EffectiveWorkingVolumeBaseType::~EffectiveWorkingVolumeBaseType() {}

void EffectiveWorkingVolumeBaseType::printSelf(FILE * outFile)
{
  fprintf(outFile, "/>\n");
}

/* ***************************************************************** */

/* class EnvironmentalRangeType

*/

EnvironmentalRangeType::EnvironmentalRangeType()
{
  Name = 0;
  Description = 0;
  MaxAmbientTemperature = 0;
  MinAmbientTemperature = 0;
  MaxAmbientAirPressure = 0;
  MinAmbientAirPressure = 0;
  MaxAmbientRelativeHumidity = 0;
  MinAmbientRelativeHumidity = 0;
  MaxVibration = 0;
  Attributes = 0;
}

EnvironmentalRangeType::EnvironmentalRangeType(
 XmlNMTOKEN * NameIn,
 XmlString * DescriptionIn,
 TemperatureValueType * MaxAmbientTemperatureIn,
 TemperatureValueType * MinAmbientTemperatureIn,
 PressureValueType * MaxAmbientAirPressureIn,
 PressureValueType * MinAmbientAirPressureIn,
 SpecifiedDecimalType * MaxAmbientRelativeHumidityIn,
 SpecifiedDecimalType * MinAmbientRelativeHumidityIn,
 UserDefinedUnitValueType * MaxVibrationIn,
 AttributesType * AttributesIn)
{
  Name = NameIn;
  Description = DescriptionIn;
  MaxAmbientTemperature = MaxAmbientTemperatureIn;
  MinAmbientTemperature = MinAmbientTemperatureIn;
  MaxAmbientAirPressure = MaxAmbientAirPressureIn;
  MinAmbientAirPressure = MinAmbientAirPressureIn;
  MaxAmbientRelativeHumidity = MaxAmbientRelativeHumidityIn;
  MinAmbientRelativeHumidity = MinAmbientRelativeHumidityIn;
  MaxVibration = MaxVibrationIn;
  Attributes = AttributesIn;
}

EnvironmentalRangeType::~EnvironmentalRangeType()
{
  #ifndef NODESTRUCT
  delete Name;
  delete Description;
  delete MaxAmbientTemperature;
  delete MinAmbientTemperature;
  delete MaxAmbientAirPressure;
  delete MinAmbientAirPressure;
  delete MaxAmbientRelativeHumidity;
  delete MinAmbientRelativeHumidity;
  delete MaxVibration;
  delete Attributes;
  #endif
}

void EnvironmentalRangeType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Name)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Name");
      Name->printSelf(outFile);
      fprintf(outFile, "</Name>\n");
    }
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (MaxAmbientTemperature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxAmbientTemperature");
      MaxAmbientTemperature->printSelf(outFile);
      fprintf(outFile, "</MaxAmbientTemperature>\n");
    }
  if (MinAmbientTemperature)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinAmbientTemperature");
      MinAmbientTemperature->printSelf(outFile);
      fprintf(outFile, "</MinAmbientTemperature>\n");
    }
  if (MaxAmbientAirPressure)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxAmbientAirPressure");
      MaxAmbientAirPressure->printSelf(outFile);
      fprintf(outFile, "</MaxAmbientAirPressure>\n");
    }
  if (MinAmbientAirPressure)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinAmbientAirPressure");
      MinAmbientAirPressure->printSelf(outFile);
      fprintf(outFile, "</MinAmbientAirPressure>\n");
    }
  if (MaxAmbientRelativeHumidity)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxAmbientRelativeHumidity");
      MaxAmbientRelativeHumidity->printSelf(outFile);
      fprintf(outFile, "</MaxAmbientRelativeHumidity>\n");
    }
  if (MinAmbientRelativeHumidity)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinAmbientRelativeHumidity");
      MinAmbientRelativeHumidity->printSelf(outFile);
      fprintf(outFile, "</MinAmbientRelativeHumidity>\n");
    }
  if (MaxVibration)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxVibration");
      MaxVibration->printSelf(outFile);
      fprintf(outFile, "</MaxVibration>\n");
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(-INDENT, outFile);
}

XmlNMTOKEN * EnvironmentalRangeType::getName()
{return Name;}

void EnvironmentalRangeType::setName(XmlNMTOKEN * NameIn)
{Name = NameIn;}

XmlString * EnvironmentalRangeType::getDescription()
{return Description;}

void EnvironmentalRangeType::setDescription(XmlString * DescriptionIn)
{Description = DescriptionIn;}

TemperatureValueType * EnvironmentalRangeType::getMaxAmbientTemperature()
{return MaxAmbientTemperature;}

void EnvironmentalRangeType::setMaxAmbientTemperature(TemperatureValueType * MaxAmbientTemperatureIn)
{MaxAmbientTemperature = MaxAmbientTemperatureIn;}

TemperatureValueType * EnvironmentalRangeType::getMinAmbientTemperature()
{return MinAmbientTemperature;}

void EnvironmentalRangeType::setMinAmbientTemperature(TemperatureValueType * MinAmbientTemperatureIn)
{MinAmbientTemperature = MinAmbientTemperatureIn;}

PressureValueType * EnvironmentalRangeType::getMaxAmbientAirPressure()
{return MaxAmbientAirPressure;}

void EnvironmentalRangeType::setMaxAmbientAirPressure(PressureValueType * MaxAmbientAirPressureIn)
{MaxAmbientAirPressure = MaxAmbientAirPressureIn;}

PressureValueType * EnvironmentalRangeType::getMinAmbientAirPressure()
{return MinAmbientAirPressure;}

void EnvironmentalRangeType::setMinAmbientAirPressure(PressureValueType * MinAmbientAirPressureIn)
{MinAmbientAirPressure = MinAmbientAirPressureIn;}

SpecifiedDecimalType * EnvironmentalRangeType::getMaxAmbientRelativeHumidity()
{return MaxAmbientRelativeHumidity;}

void EnvironmentalRangeType::setMaxAmbientRelativeHumidity(SpecifiedDecimalType * MaxAmbientRelativeHumidityIn)
{MaxAmbientRelativeHumidity = MaxAmbientRelativeHumidityIn;}

SpecifiedDecimalType * EnvironmentalRangeType::getMinAmbientRelativeHumidity()
{return MinAmbientRelativeHumidity;}

void EnvironmentalRangeType::setMinAmbientRelativeHumidity(SpecifiedDecimalType * MinAmbientRelativeHumidityIn)
{MinAmbientRelativeHumidity = MinAmbientRelativeHumidityIn;}

UserDefinedUnitValueType * EnvironmentalRangeType::getMaxVibration()
{return MaxVibration;}

void EnvironmentalRangeType::setMaxVibration(UserDefinedUnitValueType * MaxVibrationIn)
{MaxVibration = MaxVibrationIn;}

AttributesType * EnvironmentalRangeType::getAttributes()
{return Attributes;}

void EnvironmentalRangeType::setAttributes(AttributesType * AttributesIn)
{Attributes = AttributesIn;}

/* ***************************************************************** */

/* class FPSTestType

*/

FPSTestType::FPSTestType() :
  CMMAccuracyTestBaseType()
{
  XLinearity = 0;
  YLinearity = 0;
  ZLinearity = 0;
  XAxisRoll = 0;
  XAxisPitch = 0;
  XAxisYaw = 0;
  YAxisRoll = 0;
  YAxisPitch = 0;
  YAxisYaw = 0;
  ZAxisRoll = 0;
  ZAxisPitch = 0;
  ZAxisYaw = 0;
  XAxisStraightnessY = 0;
  XAxisStraightnessZ = 0;
  YAxisStraightnessX = 0;
  YAxisStraightnessZ = 0;
  ZAxisStraightnessX = 0;
  ZAxisStraightnessY = 0;
  XYSquareness = 0;
  XZSquareness = 0;
  YZSquareness = 0;
}

FPSTestType::FPSTestType(
 LengthFunctionDiscreteType * XLinearityIn,
 LengthFunctionDiscreteType * YLinearityIn,
 LengthFunctionDiscreteType * ZLinearityIn,
 AngleFunctionDiscreteType * XAxisRollIn,
 AngleFunctionDiscreteType * XAxisPitchIn,
 AngleFunctionDiscreteType * XAxisYawIn,
 AngleFunctionDiscreteType * YAxisRollIn,
 AngleFunctionDiscreteType * YAxisPitchIn,
 AngleFunctionDiscreteType * YAxisYawIn,
 AngleFunctionDiscreteType * ZAxisRollIn,
 AngleFunctionDiscreteType * ZAxisPitchIn,
 AngleFunctionDiscreteType * ZAxisYawIn,
 LengthFunctionDiscreteType * XAxisStraightnessYIn,
 LengthFunctionDiscreteType * XAxisStraightnessZIn,
 LengthFunctionDiscreteType * YAxisStraightnessXIn,
 LengthFunctionDiscreteType * YAxisStraightnessZIn,
 LengthFunctionDiscreteType * ZAxisStraightnessXIn,
 LengthFunctionDiscreteType * ZAxisStraightnessYIn,
 XmlDouble * XYSquarenessIn,
 XmlDouble * XZSquarenessIn,
 XmlDouble * YZSquarenessIn) :
  CMMAccuracyTestBaseType()
{
  XLinearity = XLinearityIn;
  YLinearity = YLinearityIn;
  ZLinearity = ZLinearityIn;
  XAxisRoll = XAxisRollIn;
  XAxisPitch = XAxisPitchIn;
  XAxisYaw = XAxisYawIn;
  YAxisRoll = YAxisRollIn;
  YAxisPitch = YAxisPitchIn;
  YAxisYaw = YAxisYawIn;
  ZAxisRoll = ZAxisRollIn;
  ZAxisPitch = ZAxisPitchIn;
  ZAxisYaw = ZAxisYawIn;
  XAxisStraightnessY = XAxisStraightnessYIn;
  XAxisStraightnessZ = XAxisStraightnessZIn;
  YAxisStraightnessX = YAxisStraightnessXIn;
  YAxisStraightnessZ = YAxisStraightnessZIn;
  ZAxisStraightnessX = ZAxisStraightnessXIn;
  ZAxisStraightnessY = ZAxisStraightnessYIn;
  XYSquareness = XYSquarenessIn;
  XZSquareness = XZSquarenessIn;
  YZSquareness = YZSquarenessIn;
}

FPSTestType::~FPSTestType()
{
  #ifndef NODESTRUCT
  delete XLinearity;
  delete YLinearity;
  delete ZLinearity;
  delete XAxisRoll;
  delete XAxisPitch;
  delete XAxisYaw;
  delete YAxisRoll;
  delete YAxisPitch;
  delete YAxisYaw;
  delete ZAxisRoll;
  delete ZAxisPitch;
  delete ZAxisYaw;
  delete XAxisStraightnessY;
  delete XAxisStraightnessZ;
  delete YAxisStraightnessX;
  delete YAxisStraightnessZ;
  delete ZAxisStraightnessX;
  delete ZAxisStraightnessY;
  delete XYSquareness;
  delete XZSquareness;
  delete YZSquareness;
  #endif
}

void FPSTestType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<XLinearity");
  XLinearity->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</XLinearity>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<YLinearity");
  YLinearity->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</YLinearity>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<ZLinearity");
  ZLinearity->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ZLinearity>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<XAxisRoll");
  XAxisRoll->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</XAxisRoll>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<XAxisPitch");
  XAxisPitch->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</XAxisPitch>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<XAxisYaw");
  XAxisYaw->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</XAxisYaw>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<YAxisRoll");
  YAxisRoll->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</YAxisRoll>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<YAxisPitch");
  YAxisPitch->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</YAxisPitch>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<YAxisYaw");
  YAxisYaw->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</YAxisYaw>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<ZAxisRoll");
  ZAxisRoll->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ZAxisRoll>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<ZAxisPitch");
  ZAxisPitch->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ZAxisPitch>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<ZAxisYaw");
  ZAxisYaw->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ZAxisYaw>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<XAxisStraightnessY");
  XAxisStraightnessY->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</XAxisStraightnessY>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<XAxisStraightnessZ");
  XAxisStraightnessZ->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</XAxisStraightnessZ>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<YAxisStraightnessX");
  YAxisStraightnessX->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</YAxisStraightnessX>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<YAxisStraightnessZ");
  YAxisStraightnessZ->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</YAxisStraightnessZ>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<ZAxisStraightnessX");
  ZAxisStraightnessX->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ZAxisStraightnessX>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<ZAxisStraightnessY");
  ZAxisStraightnessY->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ZAxisStraightnessY>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<XYSquareness");
  XYSquareness->printSelf(outFile);
  fprintf(outFile, "</XYSquareness>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<XZSquareness");
  XZSquareness->printSelf(outFile);
  fprintf(outFile, "</XZSquareness>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<YZSquareness");
  YZSquareness->printSelf(outFile);
  fprintf(outFile, "</YZSquareness>\n");
  doSpaces(-INDENT, outFile);
}

LengthFunctionDiscreteType * FPSTestType::getXLinearity()
{return XLinearity;}

void FPSTestType::setXLinearity(LengthFunctionDiscreteType * XLinearityIn)
{XLinearity = XLinearityIn;}

LengthFunctionDiscreteType * FPSTestType::getYLinearity()
{return YLinearity;}

void FPSTestType::setYLinearity(LengthFunctionDiscreteType * YLinearityIn)
{YLinearity = YLinearityIn;}

LengthFunctionDiscreteType * FPSTestType::getZLinearity()
{return ZLinearity;}

void FPSTestType::setZLinearity(LengthFunctionDiscreteType * ZLinearityIn)
{ZLinearity = ZLinearityIn;}

AngleFunctionDiscreteType * FPSTestType::getXAxisRoll()
{return XAxisRoll;}

void FPSTestType::setXAxisRoll(AngleFunctionDiscreteType * XAxisRollIn)
{XAxisRoll = XAxisRollIn;}

AngleFunctionDiscreteType * FPSTestType::getXAxisPitch()
{return XAxisPitch;}

void FPSTestType::setXAxisPitch(AngleFunctionDiscreteType * XAxisPitchIn)
{XAxisPitch = XAxisPitchIn;}

AngleFunctionDiscreteType * FPSTestType::getXAxisYaw()
{return XAxisYaw;}

void FPSTestType::setXAxisYaw(AngleFunctionDiscreteType * XAxisYawIn)
{XAxisYaw = XAxisYawIn;}

AngleFunctionDiscreteType * FPSTestType::getYAxisRoll()
{return YAxisRoll;}

void FPSTestType::setYAxisRoll(AngleFunctionDiscreteType * YAxisRollIn)
{YAxisRoll = YAxisRollIn;}

AngleFunctionDiscreteType * FPSTestType::getYAxisPitch()
{return YAxisPitch;}

void FPSTestType::setYAxisPitch(AngleFunctionDiscreteType * YAxisPitchIn)
{YAxisPitch = YAxisPitchIn;}

AngleFunctionDiscreteType * FPSTestType::getYAxisYaw()
{return YAxisYaw;}

void FPSTestType::setYAxisYaw(AngleFunctionDiscreteType * YAxisYawIn)
{YAxisYaw = YAxisYawIn;}

AngleFunctionDiscreteType * FPSTestType::getZAxisRoll()
{return ZAxisRoll;}

void FPSTestType::setZAxisRoll(AngleFunctionDiscreteType * ZAxisRollIn)
{ZAxisRoll = ZAxisRollIn;}

AngleFunctionDiscreteType * FPSTestType::getZAxisPitch()
{return ZAxisPitch;}

void FPSTestType::setZAxisPitch(AngleFunctionDiscreteType * ZAxisPitchIn)
{ZAxisPitch = ZAxisPitchIn;}

AngleFunctionDiscreteType * FPSTestType::getZAxisYaw()
{return ZAxisYaw;}

void FPSTestType::setZAxisYaw(AngleFunctionDiscreteType * ZAxisYawIn)
{ZAxisYaw = ZAxisYawIn;}

LengthFunctionDiscreteType * FPSTestType::getXAxisStraightnessY()
{return XAxisStraightnessY;}

void FPSTestType::setXAxisStraightnessY(LengthFunctionDiscreteType * XAxisStraightnessYIn)
{XAxisStraightnessY = XAxisStraightnessYIn;}

LengthFunctionDiscreteType * FPSTestType::getXAxisStraightnessZ()
{return XAxisStraightnessZ;}

void FPSTestType::setXAxisStraightnessZ(LengthFunctionDiscreteType * XAxisStraightnessZIn)
{XAxisStraightnessZ = XAxisStraightnessZIn;}

LengthFunctionDiscreteType * FPSTestType::getYAxisStraightnessX()
{return YAxisStraightnessX;}

void FPSTestType::setYAxisStraightnessX(LengthFunctionDiscreteType * YAxisStraightnessXIn)
{YAxisStraightnessX = YAxisStraightnessXIn;}

LengthFunctionDiscreteType * FPSTestType::getYAxisStraightnessZ()
{return YAxisStraightnessZ;}

void FPSTestType::setYAxisStraightnessZ(LengthFunctionDiscreteType * YAxisStraightnessZIn)
{YAxisStraightnessZ = YAxisStraightnessZIn;}

LengthFunctionDiscreteType * FPSTestType::getZAxisStraightnessX()
{return ZAxisStraightnessX;}

void FPSTestType::setZAxisStraightnessX(LengthFunctionDiscreteType * ZAxisStraightnessXIn)
{ZAxisStraightnessX = ZAxisStraightnessXIn;}

LengthFunctionDiscreteType * FPSTestType::getZAxisStraightnessY()
{return ZAxisStraightnessY;}

void FPSTestType::setZAxisStraightnessY(LengthFunctionDiscreteType * ZAxisStraightnessYIn)
{ZAxisStraightnessY = ZAxisStraightnessYIn;}

XmlDouble * FPSTestType::getXYSquareness()
{return XYSquareness;}

void FPSTestType::setXYSquareness(XmlDouble * XYSquarenessIn)
{XYSquareness = XYSquarenessIn;}

XmlDouble * FPSTestType::getXZSquareness()
{return XZSquareness;}

void FPSTestType::setXZSquareness(XmlDouble * XZSquarenessIn)
{XZSquareness = XZSquarenessIn;}

XmlDouble * FPSTestType::getYZSquareness()
{return YZSquareness;}

void FPSTestType::setYZSquareness(XmlDouble * YZSquarenessIn)
{YZSquareness = YZSquarenessIn;}

/* ***************************************************************** */

/* class FixtureType

*/

FixtureType::FixtureType() :
  MeasurementResourceBaseType()
{
}

FixtureType::FixtureType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn) :
  MeasurementResourceBaseType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
}

FixtureType::FixtureType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn) :
  MeasurementResourceBaseType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
}

FixtureType::~FixtureType()
{
  #ifndef NODESTRUCT
  #endif
}

void FixtureType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool FixtureType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in FixtureType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in FixtureType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FixtureType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in FixtureType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class FixtureTypeLisd

*/

FixtureTypeLisd::FixtureTypeLisd() {}

FixtureTypeLisd::FixtureTypeLisd(FixtureType * aFixtureType)
{
  push_back(aFixtureType);
}

FixtureTypeLisd::~FixtureTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<FixtureType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void FixtureTypeLisd::printSelf(FILE * outFile)
{
  std::list<FixtureType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class FixturesType

*/

FixturesType::FixturesType()
{
  n = 0;
  Fixture = 0;
}

FixturesType::FixturesType(
 FixtureTypeLisd * FixtureIn)
{
  n = 0;
  Fixture = FixtureIn;
}

FixturesType::FixturesType(
 NaturalType * nIn,
 FixtureTypeLisd * FixtureIn)
{
  n = nIn;
  Fixture = FixtureIn;
}

FixturesType::~FixturesType()
{
  #ifndef NODESTRUCT
  delete n;
  delete Fixture;
  #endif
}

void FixturesType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!Fixture)
      {
        fprintf(stderr, "Fixture list is missing\n");
        exit(1);
      }
    if (Fixture->size() == 0)
      {
        fprintf(stderr, "Fixture list is empty\n");
        exit(1);
      }
    if (Fixture->size() < 1)
      {
        fprintf(stderr,
                "size of Fixture list (%d) less than minimum required (1)\n",
                (int)Fixture->size());
        exit(1);
      }
    std::list<FixtureType *>::iterator iter;
    for (iter = Fixture->begin();
         iter != Fixture->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<Fixture");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</Fixture>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool FixturesType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in FixturesType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in FixturesType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FixturesType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in FixturesType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * FixturesType::getn()
{return n;}

void FixturesType::setn(NaturalType * nIn)
{n = nIn;}

FixtureTypeLisd * FixturesType::getFixture()
{return Fixture;}

void FixturesType::setFixture(FixtureTypeLisd * FixtureIn)
{Fixture = FixtureIn;}

/* ***************************************************************** */

/* class FunctionDiscreteType

*/

FunctionDiscreteType::FunctionDiscreteType()
{
  n = 0;
  DomainValues = 0;
  RangeValues = 0;
}

FunctionDiscreteType::FunctionDiscreteType(
 ListDoubleType * DomainValuesIn,
 ListDoubleType * RangeValuesIn)
{
  n = 0;
  DomainValues = DomainValuesIn;
  RangeValues = RangeValuesIn;
}

FunctionDiscreteType::FunctionDiscreteType(
 NaturalType * nIn,
 ListDoubleType * DomainValuesIn,
 ListDoubleType * RangeValuesIn)
{
  n = nIn;
  DomainValues = DomainValuesIn;
  RangeValues = RangeValuesIn;
}

FunctionDiscreteType::~FunctionDiscreteType()
{
  #ifndef NODESTRUCT
  delete n;
  delete DomainValues;
  delete RangeValues;
  #endif
}

void FunctionDiscreteType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<DomainValues");
  DomainValues->printSelf(outFile);
  fprintf(outFile, "</DomainValues>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<RangeValues");
  RangeValues->printSelf(outFile);
  fprintf(outFile, "</RangeValues>\n");
  doSpaces(-INDENT, outFile);
}

bool FunctionDiscreteType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in FunctionDiscreteType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in FunctionDiscreteType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in FunctionDiscreteType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in FunctionDiscreteType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * FunctionDiscreteType::getn()
{return n;}

void FunctionDiscreteType::setn(NaturalType * nIn)
{n = nIn;}

ListDoubleType * FunctionDiscreteType::getDomainValues()
{return DomainValues;}

void FunctionDiscreteType::setDomainValues(ListDoubleType * DomainValuesIn)
{DomainValues = DomainValuesIn;}

ListDoubleType * FunctionDiscreteType::getRangeValues()
{return RangeValues;}

void FunctionDiscreteType::setRangeValues(ListDoubleType * RangeValuesIn)
{RangeValues = RangeValuesIn;}

/* ***************************************************************** */

/* class GageDeviceType

*/

GageDeviceType::GageDeviceType() :
  ManualMeasurementDeviceType()
{
}

GageDeviceType::GageDeviceType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn) :
  ManualMeasurementDeviceType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    MinMeasuringDistanceIn,
    MaxMeasuringDistanceIn)
{
}

GageDeviceType::GageDeviceType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn) :
  ManualMeasurementDeviceType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    MinMeasuringDistanceIn,
    MaxMeasuringDistanceIn)
{
}

GageDeviceType::~GageDeviceType()
{
  #ifndef NODESTRUCT
  #endif
}

void GageDeviceType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Calibrations)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Calibrations");
      Calibrations->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Calibrations>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (MinMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinMeasuringDistance");
      MinMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MinMeasuringDistance>\n");
    }
  if (MaxMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxMeasuringDistance");
      MaxMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MaxMeasuringDistance>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool GageDeviceType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in GageDeviceType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in GageDeviceType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in GageDeviceType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in GageDeviceType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class ISO10360TestType

*/

ISO10360TestType::ISO10360TestType() :
  CMMAccuracyTestBaseType()
{
  ISO10360TestTypePair = 0;
}

ISO10360TestType::ISO10360TestType(
 ISO10360TestTypeChoicePair * ISO10360TestTypePairIn) :
  CMMAccuracyTestBaseType()
{
  ISO10360TestTypePair = ISO10360TestTypePairIn;
}

ISO10360TestType::~ISO10360TestType()
{
  #ifndef NODESTRUCT
  delete ISO10360TestTypePair;
  #endif
}

void ISO10360TestType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  ISO10360TestTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}
ISO10360TestTypeChoicePair * ISO10360TestType::getISO10360TestTypeChoicePair()
{return ISO10360TestTypePair;}

void ISO10360TestType::setISO10360TestTypeChoicePair(ISO10360TestTypeChoicePair * ISO10360TestTypePairIn)
{ISO10360TestTypePair = ISO10360TestTypePairIn;}

/* ***************************************************************** */

ISO10360TestTypeChoicePair::ISO10360TestTypeChoicePair() {}

ISO10360TestTypeChoicePair::ISO10360TestTypeChoicePair(
 whichOne ISO10360TestTypeTypeIn,
 ISO10360TestTypeVal ISO10360TestTypeValueIn)
{
  ISO10360TestTypeType = ISO10360TestTypeTypeIn;
  ISO10360TestTypeValue = ISO10360TestTypeValueIn;
}

ISO10360TestTypeChoicePair::~ISO10360TestTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (ISO10360TestTypeType == MaxErrorConstantE)
    delete ISO10360TestTypeValue.MaxErrorConstant;
  else if (ISO10360TestTypeType == LinearErrorE)
    delete ISO10360TestTypeValue.LinearError;
  else if (ISO10360TestTypeType == LesserErrorE)
    delete ISO10360TestTypeValue.LesserError;
  #endif
}

void ISO10360TestTypeChoicePair::printSelf(FILE * outFile)
{
  if (ISO10360TestTypeType == MaxErrorConstantE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxErrorConstant");
      ISO10360TestTypeValue.MaxErrorConstant->printSelf(outFile);
      fprintf(outFile, "</MaxErrorConstant>\n");
    }
  else if (ISO10360TestTypeType == LinearErrorE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LinearError");
      ISO10360TestTypeValue.LinearError->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LinearError>\n");
    }
  else if (ISO10360TestTypeType == LesserErrorE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LesserError");
      ISO10360TestTypeValue.LesserError->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LesserError>\n");
    }
}

/* ***************************************************************** */

/* class LaserRadarType

*/

LaserRadarType::LaserRadarType() :
  UniversalDeviceType()
{
  MeasurementLaser = 0;
  PointingLaser = 0;
  MaxPointsRate = 0;
  MaxMeasurementRange = 0;
  MinMeasurementRange = 0;
  ScanningSpeed = 0;
  DistanceAccuracy = 0;
  AzimuthAngularAccuracy = 0;
  ElevationAngularAccuracy = 0;
  RangeForVolumetricUncertainty = 0;
  VolumetricUncertainty = 0;
  MaxEnvironmentalAltitude = 0;
  MinEnvironmentalAltitude = 0;
  SurfacePointsSpeed = 0;
  ToolingBallSpeed = 0;
  FeatureSpeed = 0;
}

LaserRadarType::LaserRadarType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 ResolutionBaseType * ResolutionIn,
 WorkingVolumeBaseType * WorkingVolumeIn,
 EffectiveWorkingVolumeBaseType * EffectiveWorkingVolumeIn,
 TemperatureCompensationType * TemperatureCompensationIn,
 LaserType * MeasurementLaserIn,
 LaserType * PointingLaserIn,
 UserDefinedUnitValueType * MaxPointsRateIn,
 LinearValueType * MaxMeasurementRangeIn,
 LinearValueType * MinMeasurementRangeIn,
 UserDefinedUnitValueType * ScanningSpeedIn,
 LinearErrorType * DistanceAccuracyIn,
 AngularErrorType * AzimuthAngularAccuracyIn,
 AngularErrorType * ElevationAngularAccuracyIn,
 LinearValueType * RangeForVolumetricUncertaintyIn,
 LinearValueType * VolumetricUncertaintyIn,
 LinearValueType * MaxEnvironmentalAltitudeIn,
 LinearValueType * MinEnvironmentalAltitudeIn,
 TimeValueType * SurfacePointsSpeedIn,
 TimeValueType * ToolingBallSpeedIn,
 TimeValueType * FeatureSpeedIn) :
  UniversalDeviceType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    ResolutionIn,
    WorkingVolumeIn,
    EffectiveWorkingVolumeIn,
    TemperatureCompensationIn)
{
  MeasurementLaser = MeasurementLaserIn;
  PointingLaser = PointingLaserIn;
  MaxPointsRate = MaxPointsRateIn;
  MaxMeasurementRange = MaxMeasurementRangeIn;
  MinMeasurementRange = MinMeasurementRangeIn;
  ScanningSpeed = ScanningSpeedIn;
  DistanceAccuracy = DistanceAccuracyIn;
  AzimuthAngularAccuracy = AzimuthAngularAccuracyIn;
  ElevationAngularAccuracy = ElevationAngularAccuracyIn;
  RangeForVolumetricUncertainty = RangeForVolumetricUncertaintyIn;
  VolumetricUncertainty = VolumetricUncertaintyIn;
  MaxEnvironmentalAltitude = MaxEnvironmentalAltitudeIn;
  MinEnvironmentalAltitude = MinEnvironmentalAltitudeIn;
  SurfacePointsSpeed = SurfacePointsSpeedIn;
  ToolingBallSpeed = ToolingBallSpeedIn;
  FeatureSpeed = FeatureSpeedIn;
}

LaserRadarType::LaserRadarType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 ResolutionBaseType * ResolutionIn,
 WorkingVolumeBaseType * WorkingVolumeIn,
 EffectiveWorkingVolumeBaseType * EffectiveWorkingVolumeIn,
 TemperatureCompensationType * TemperatureCompensationIn,
 LaserType * MeasurementLaserIn,
 LaserType * PointingLaserIn,
 UserDefinedUnitValueType * MaxPointsRateIn,
 LinearValueType * MaxMeasurementRangeIn,
 LinearValueType * MinMeasurementRangeIn,
 UserDefinedUnitValueType * ScanningSpeedIn,
 LinearErrorType * DistanceAccuracyIn,
 AngularErrorType * AzimuthAngularAccuracyIn,
 AngularErrorType * ElevationAngularAccuracyIn,
 LinearValueType * RangeForVolumetricUncertaintyIn,
 LinearValueType * VolumetricUncertaintyIn,
 LinearValueType * MaxEnvironmentalAltitudeIn,
 LinearValueType * MinEnvironmentalAltitudeIn,
 TimeValueType * SurfacePointsSpeedIn,
 TimeValueType * ToolingBallSpeedIn,
 TimeValueType * FeatureSpeedIn) :
  UniversalDeviceType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    ResolutionIn,
    WorkingVolumeIn,
    EffectiveWorkingVolumeIn,
    TemperatureCompensationIn)
{
  MeasurementLaser = MeasurementLaserIn;
  PointingLaser = PointingLaserIn;
  MaxPointsRate = MaxPointsRateIn;
  MaxMeasurementRange = MaxMeasurementRangeIn;
  MinMeasurementRange = MinMeasurementRangeIn;
  ScanningSpeed = ScanningSpeedIn;
  DistanceAccuracy = DistanceAccuracyIn;
  AzimuthAngularAccuracy = AzimuthAngularAccuracyIn;
  ElevationAngularAccuracy = ElevationAngularAccuracyIn;
  RangeForVolumetricUncertainty = RangeForVolumetricUncertaintyIn;
  VolumetricUncertainty = VolumetricUncertaintyIn;
  MaxEnvironmentalAltitude = MaxEnvironmentalAltitudeIn;
  MinEnvironmentalAltitude = MinEnvironmentalAltitudeIn;
  SurfacePointsSpeed = SurfacePointsSpeedIn;
  ToolingBallSpeed = ToolingBallSpeedIn;
  FeatureSpeed = FeatureSpeedIn;
}

LaserRadarType::~LaserRadarType()
{
  #ifndef NODESTRUCT
  delete MeasurementLaser;
  delete PointingLaser;
  delete MaxPointsRate;
  delete MaxMeasurementRange;
  delete MinMeasurementRange;
  delete ScanningSpeed;
  delete DistanceAccuracy;
  delete AzimuthAngularAccuracy;
  delete ElevationAngularAccuracy;
  delete RangeForVolumetricUncertainty;
  delete VolumetricUncertainty;
  delete MaxEnvironmentalAltitude;
  delete MinEnvironmentalAltitude;
  delete SurfacePointsSpeed;
  delete ToolingBallSpeed;
  delete FeatureSpeed;
  #endif
}

void LaserRadarType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Calibrations)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Calibrations");
      Calibrations->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Calibrations>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (Resolution)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (Resolution->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(Resolution->getprintElement(), "LinearResolution") == 0)
          {
            LinearResolutionType * typ;
            if ((typ = dynamic_cast<LinearResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<LinearResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LinearResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad LinearResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "CartesianResolution") == 0)
          {
            CartesianResolutionType * typ;
            if ((typ = dynamic_cast<CartesianResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<CartesianResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "SphericalResolution") == 0)
          {
            SphericalResolutionType * typ;
            if ((typ = dynamic_cast<SphericalResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<SphericalResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "UserDefinedResolution") == 0)
          {
            UserDefinedResolutionType * typ;
            if ((typ = dynamic_cast<UserDefinedResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<UserDefinedResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedResolution element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad Resolution type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (WorkingVolume)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (WorkingVolume->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(WorkingVolume->getprintElement(), "ClosedShellSetWorkingVolume") == 0)
          {
            ClosedShellSetWorkingVolumeType * typ;
            if ((typ = dynamic_cast<ClosedShellSetWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<ClosedShellSetWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ClosedShellSetWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad ClosedShellSetWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "CartesianWorkingVolume") == 0)
          {
            CartesianWorkingVolumeType * typ;
            if ((typ = dynamic_cast<CartesianWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<CartesianWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "SphericalWorkingVolume") == 0)
          {
            SphericalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<SphericalWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<SphericalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "CylindricalWorkingVolume") == 0)
          {
            CylindricalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<CylindricalWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<CylindricalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CylindricalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad CylindricalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "UserDefinedWorkingVolume") == 0)
          {
            UserDefinedWorkingVolumeType * typ;
            if ((typ = dynamic_cast<UserDefinedWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<UserDefinedWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedWorkingVolume element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad WorkingVolume type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (EffectiveWorkingVolume)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (EffectiveWorkingVolume->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveClosedShellSetWorkingVolume") == 0)
          {
            EffectiveClosedShellSetWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveClosedShellSetWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveClosedShellSetWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveClosedShellSetWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveClosedShellSetWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveCartesianWorkingVolume") == 0)
          {
            EffectiveCartesianWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveCartesianWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveCartesianWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveCartesianWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveCartesianWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveSphericalWorkingVolume") == 0)
          {
            EffectiveSphericalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveSphericalWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveSphericalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveSphericalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveSphericalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveCylindricalWorkingVolume") == 0)
          {
            EffectiveCylindricalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveCylindricalWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveCylindricalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveCylindricalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveCylindricalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveUserDefinedWorkingVolume") == 0)
          {
            EffectiveUserDefinedWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveUserDefinedWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveUserDefinedWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveUserDefinedWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveUserDefinedWorkingVolume element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad EffectiveWorkingVolume type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (TemperatureCompensation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TemperatureCompensation");
      TemperatureCompensation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</TemperatureCompensation>\n");
    }
  if (MeasurementLaser)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementLaser");
      MeasurementLaser->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementLaser>\n");
    }
  if (PointingLaser)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointingLaser");
      PointingLaser->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointingLaser>\n");
    }
  if (MaxPointsRate)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxPointsRate");
      MaxPointsRate->printSelf(outFile);
      fprintf(outFile, "</MaxPointsRate>\n");
    }
  if (MaxMeasurementRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxMeasurementRange");
      MaxMeasurementRange->printSelf(outFile);
      fprintf(outFile, "</MaxMeasurementRange>\n");
    }
  if (MinMeasurementRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinMeasurementRange");
      MinMeasurementRange->printSelf(outFile);
      fprintf(outFile, "</MinMeasurementRange>\n");
    }
  if (ScanningSpeed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ScanningSpeed");
      ScanningSpeed->printSelf(outFile);
      fprintf(outFile, "</ScanningSpeed>\n");
    }
  if (DistanceAccuracy)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistanceAccuracy");
      DistanceAccuracy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistanceAccuracy>\n");
    }
  if (AzimuthAngularAccuracy)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AzimuthAngularAccuracy");
      AzimuthAngularAccuracy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</AzimuthAngularAccuracy>\n");
    }
  if (ElevationAngularAccuracy)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ElevationAngularAccuracy");
      ElevationAngularAccuracy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ElevationAngularAccuracy>\n");
    }
  if (RangeForVolumetricUncertainty)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<RangeForVolumetricUncertainty");
      RangeForVolumetricUncertainty->printSelf(outFile);
      fprintf(outFile, "</RangeForVolumetricUncertainty>\n");
    }
  if (VolumetricUncertainty)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VolumetricUncertainty");
      VolumetricUncertainty->printSelf(outFile);
      fprintf(outFile, "</VolumetricUncertainty>\n");
    }
  if (MaxEnvironmentalAltitude)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxEnvironmentalAltitude");
      MaxEnvironmentalAltitude->printSelf(outFile);
      fprintf(outFile, "</MaxEnvironmentalAltitude>\n");
    }
  if (MinEnvironmentalAltitude)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinEnvironmentalAltitude");
      MinEnvironmentalAltitude->printSelf(outFile);
      fprintf(outFile, "</MinEnvironmentalAltitude>\n");
    }
  if (SurfacePointsSpeed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SurfacePointsSpeed");
      SurfacePointsSpeed->printSelf(outFile);
      fprintf(outFile, "</SurfacePointsSpeed>\n");
    }
  if (ToolingBallSpeed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToolingBallSpeed");
      ToolingBallSpeed->printSelf(outFile);
      fprintf(outFile, "</ToolingBallSpeed>\n");
    }
  if (FeatureSpeed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FeatureSpeed");
      FeatureSpeed->printSelf(outFile);
      fprintf(outFile, "</FeatureSpeed>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool LaserRadarType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in LaserRadarType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in LaserRadarType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in LaserRadarType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in LaserRadarType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LaserType * LaserRadarType::getMeasurementLaser()
{return MeasurementLaser;}

void LaserRadarType::setMeasurementLaser(LaserType * MeasurementLaserIn)
{MeasurementLaser = MeasurementLaserIn;}

LaserType * LaserRadarType::getPointingLaser()
{return PointingLaser;}

void LaserRadarType::setPointingLaser(LaserType * PointingLaserIn)
{PointingLaser = PointingLaserIn;}

UserDefinedUnitValueType * LaserRadarType::getMaxPointsRate()
{return MaxPointsRate;}

void LaserRadarType::setMaxPointsRate(UserDefinedUnitValueType * MaxPointsRateIn)
{MaxPointsRate = MaxPointsRateIn;}

LinearValueType * LaserRadarType::getMaxMeasurementRange()
{return MaxMeasurementRange;}

void LaserRadarType::setMaxMeasurementRange(LinearValueType * MaxMeasurementRangeIn)
{MaxMeasurementRange = MaxMeasurementRangeIn;}

LinearValueType * LaserRadarType::getMinMeasurementRange()
{return MinMeasurementRange;}

void LaserRadarType::setMinMeasurementRange(LinearValueType * MinMeasurementRangeIn)
{MinMeasurementRange = MinMeasurementRangeIn;}

UserDefinedUnitValueType * LaserRadarType::getScanningSpeed()
{return ScanningSpeed;}

void LaserRadarType::setScanningSpeed(UserDefinedUnitValueType * ScanningSpeedIn)
{ScanningSpeed = ScanningSpeedIn;}

LinearErrorType * LaserRadarType::getDistanceAccuracy()
{return DistanceAccuracy;}

void LaserRadarType::setDistanceAccuracy(LinearErrorType * DistanceAccuracyIn)
{DistanceAccuracy = DistanceAccuracyIn;}

AngularErrorType * LaserRadarType::getAzimuthAngularAccuracy()
{return AzimuthAngularAccuracy;}

void LaserRadarType::setAzimuthAngularAccuracy(AngularErrorType * AzimuthAngularAccuracyIn)
{AzimuthAngularAccuracy = AzimuthAngularAccuracyIn;}

AngularErrorType * LaserRadarType::getElevationAngularAccuracy()
{return ElevationAngularAccuracy;}

void LaserRadarType::setElevationAngularAccuracy(AngularErrorType * ElevationAngularAccuracyIn)
{ElevationAngularAccuracy = ElevationAngularAccuracyIn;}

LinearValueType * LaserRadarType::getRangeForVolumetricUncertainty()
{return RangeForVolumetricUncertainty;}

void LaserRadarType::setRangeForVolumetricUncertainty(LinearValueType * RangeForVolumetricUncertaintyIn)
{RangeForVolumetricUncertainty = RangeForVolumetricUncertaintyIn;}

LinearValueType * LaserRadarType::getVolumetricUncertainty()
{return VolumetricUncertainty;}

void LaserRadarType::setVolumetricUncertainty(LinearValueType * VolumetricUncertaintyIn)
{VolumetricUncertainty = VolumetricUncertaintyIn;}

LinearValueType * LaserRadarType::getMaxEnvironmentalAltitude()
{return MaxEnvironmentalAltitude;}

void LaserRadarType::setMaxEnvironmentalAltitude(LinearValueType * MaxEnvironmentalAltitudeIn)
{MaxEnvironmentalAltitude = MaxEnvironmentalAltitudeIn;}

LinearValueType * LaserRadarType::getMinEnvironmentalAltitude()
{return MinEnvironmentalAltitude;}

void LaserRadarType::setMinEnvironmentalAltitude(LinearValueType * MinEnvironmentalAltitudeIn)
{MinEnvironmentalAltitude = MinEnvironmentalAltitudeIn;}

TimeValueType * LaserRadarType::getSurfacePointsSpeed()
{return SurfacePointsSpeed;}

void LaserRadarType::setSurfacePointsSpeed(TimeValueType * SurfacePointsSpeedIn)
{SurfacePointsSpeed = SurfacePointsSpeedIn;}

TimeValueType * LaserRadarType::getToolingBallSpeed()
{return ToolingBallSpeed;}

void LaserRadarType::setToolingBallSpeed(TimeValueType * ToolingBallSpeedIn)
{ToolingBallSpeed = ToolingBallSpeedIn;}

TimeValueType * LaserRadarType::getFeatureSpeed()
{return FeatureSpeed;}

void LaserRadarType::setFeatureSpeed(TimeValueType * FeatureSpeedIn)
{FeatureSpeed = FeatureSpeedIn;}

/* ***************************************************************** */

/* class LaserTrackerType

*/

LaserTrackerType::LaserTrackerType() :
  UniversalDeviceType()
{
  MaximumAngularVelocity = 0;
  DistanceAccuracy = 0;
  AngularAccuracy = 0;
  SamplingRate = 0;
  TargetMirror = 0;
  HeadMass = 0;
  HeadSize = 0;
  MaximumWorkingAmplitude = 0;
  Laser = 0;
  Repeatability = 0;
}

LaserTrackerType::LaserTrackerType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 ResolutionBaseType * ResolutionIn,
 WorkingVolumeBaseType * WorkingVolumeIn,
 EffectiveWorkingVolumeBaseType * EffectiveWorkingVolumeIn,
 TemperatureCompensationType * TemperatureCompensationIn,
 UserDefinedUnitValueType * MaximumAngularVelocityIn,
 LinearErrorType * DistanceAccuracyIn,
 AngularErrorType * AngularAccuracyIn,
 UserDefinedUnitValueType * SamplingRateIn,
 TargetMirrorEnumType * TargetMirrorIn,
 MassValueType * HeadMassIn,
 CartesianWorkingVolumeType * HeadSizeIn,
 LinearValueType * MaximumWorkingAmplitudeIn,
 LaserType * LaserIn,
 LinearValueType * RepeatabilityIn) :
  UniversalDeviceType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    ResolutionIn,
    WorkingVolumeIn,
    EffectiveWorkingVolumeIn,
    TemperatureCompensationIn)
{
  MaximumAngularVelocity = MaximumAngularVelocityIn;
  DistanceAccuracy = DistanceAccuracyIn;
  AngularAccuracy = AngularAccuracyIn;
  SamplingRate = SamplingRateIn;
  TargetMirror = TargetMirrorIn;
  HeadMass = HeadMassIn;
  HeadSize = HeadSizeIn;
  MaximumWorkingAmplitude = MaximumWorkingAmplitudeIn;
  Laser = LaserIn;
  Repeatability = RepeatabilityIn;
}

LaserTrackerType::LaserTrackerType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 ResolutionBaseType * ResolutionIn,
 WorkingVolumeBaseType * WorkingVolumeIn,
 EffectiveWorkingVolumeBaseType * EffectiveWorkingVolumeIn,
 TemperatureCompensationType * TemperatureCompensationIn,
 UserDefinedUnitValueType * MaximumAngularVelocityIn,
 LinearErrorType * DistanceAccuracyIn,
 AngularErrorType * AngularAccuracyIn,
 UserDefinedUnitValueType * SamplingRateIn,
 TargetMirrorEnumType * TargetMirrorIn,
 MassValueType * HeadMassIn,
 CartesianWorkingVolumeType * HeadSizeIn,
 LinearValueType * MaximumWorkingAmplitudeIn,
 LaserType * LaserIn,
 LinearValueType * RepeatabilityIn) :
  UniversalDeviceType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    ResolutionIn,
    WorkingVolumeIn,
    EffectiveWorkingVolumeIn,
    TemperatureCompensationIn)
{
  MaximumAngularVelocity = MaximumAngularVelocityIn;
  DistanceAccuracy = DistanceAccuracyIn;
  AngularAccuracy = AngularAccuracyIn;
  SamplingRate = SamplingRateIn;
  TargetMirror = TargetMirrorIn;
  HeadMass = HeadMassIn;
  HeadSize = HeadSizeIn;
  MaximumWorkingAmplitude = MaximumWorkingAmplitudeIn;
  Laser = LaserIn;
  Repeatability = RepeatabilityIn;
}

LaserTrackerType::~LaserTrackerType()
{
  #ifndef NODESTRUCT
  delete MaximumAngularVelocity;
  delete DistanceAccuracy;
  delete AngularAccuracy;
  delete SamplingRate;
  delete TargetMirror;
  delete HeadMass;
  delete HeadSize;
  delete MaximumWorkingAmplitude;
  delete Laser;
  delete Repeatability;
  #endif
}

void LaserTrackerType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Calibrations)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Calibrations");
      Calibrations->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Calibrations>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (Resolution)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (Resolution->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(Resolution->getprintElement(), "LinearResolution") == 0)
          {
            LinearResolutionType * typ;
            if ((typ = dynamic_cast<LinearResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<LinearResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LinearResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad LinearResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "CartesianResolution") == 0)
          {
            CartesianResolutionType * typ;
            if ((typ = dynamic_cast<CartesianResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<CartesianResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "SphericalResolution") == 0)
          {
            SphericalResolutionType * typ;
            if ((typ = dynamic_cast<SphericalResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<SphericalResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "UserDefinedResolution") == 0)
          {
            UserDefinedResolutionType * typ;
            if ((typ = dynamic_cast<UserDefinedResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<UserDefinedResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedResolution element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad Resolution type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (WorkingVolume)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (WorkingVolume->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(WorkingVolume->getprintElement(), "ClosedShellSetWorkingVolume") == 0)
          {
            ClosedShellSetWorkingVolumeType * typ;
            if ((typ = dynamic_cast<ClosedShellSetWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<ClosedShellSetWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ClosedShellSetWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad ClosedShellSetWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "CartesianWorkingVolume") == 0)
          {
            CartesianWorkingVolumeType * typ;
            if ((typ = dynamic_cast<CartesianWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<CartesianWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "SphericalWorkingVolume") == 0)
          {
            SphericalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<SphericalWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<SphericalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "CylindricalWorkingVolume") == 0)
          {
            CylindricalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<CylindricalWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<CylindricalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CylindricalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad CylindricalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "UserDefinedWorkingVolume") == 0)
          {
            UserDefinedWorkingVolumeType * typ;
            if ((typ = dynamic_cast<UserDefinedWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<UserDefinedWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedWorkingVolume element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad WorkingVolume type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (EffectiveWorkingVolume)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (EffectiveWorkingVolume->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveClosedShellSetWorkingVolume") == 0)
          {
            EffectiveClosedShellSetWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveClosedShellSetWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveClosedShellSetWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveClosedShellSetWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveClosedShellSetWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveCartesianWorkingVolume") == 0)
          {
            EffectiveCartesianWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveCartesianWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveCartesianWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveCartesianWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveCartesianWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveSphericalWorkingVolume") == 0)
          {
            EffectiveSphericalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveSphericalWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveSphericalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveSphericalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveSphericalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveCylindricalWorkingVolume") == 0)
          {
            EffectiveCylindricalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveCylindricalWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveCylindricalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveCylindricalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveCylindricalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveUserDefinedWorkingVolume") == 0)
          {
            EffectiveUserDefinedWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveUserDefinedWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveUserDefinedWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveUserDefinedWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveUserDefinedWorkingVolume element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad EffectiveWorkingVolume type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (TemperatureCompensation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TemperatureCompensation");
      TemperatureCompensation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</TemperatureCompensation>\n");
    }
  if (MaximumAngularVelocity)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaximumAngularVelocity");
      MaximumAngularVelocity->printSelf(outFile);
      fprintf(outFile, "</MaximumAngularVelocity>\n");
    }
  if (DistanceAccuracy)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistanceAccuracy");
      DistanceAccuracy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistanceAccuracy>\n");
    }
  if (AngularAccuracy)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AngularAccuracy");
      AngularAccuracy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</AngularAccuracy>\n");
    }
  if (SamplingRate)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SamplingRate");
      SamplingRate->printSelf(outFile);
      fprintf(outFile, "</SamplingRate>\n");
    }
  if (TargetMirror)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TargetMirror");
      TargetMirror->printSelf(outFile);
      fprintf(outFile, "</TargetMirror>\n");
    }
  if (HeadMass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<HeadMass");
      HeadMass->printSelf(outFile);
      fprintf(outFile, "</HeadMass>\n");
    }
  if (HeadSize)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<HeadSize");
      HeadSize->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</HeadSize>\n");
    }
  if (MaximumWorkingAmplitude)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaximumWorkingAmplitude");
      MaximumWorkingAmplitude->printSelf(outFile);
      fprintf(outFile, "</MaximumWorkingAmplitude>\n");
    }
  if (Laser)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Laser");
      Laser->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Laser>\n");
    }
  if (Repeatability)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Repeatability");
      Repeatability->printSelf(outFile);
      fprintf(outFile, "</Repeatability>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool LaserTrackerType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in LaserTrackerType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in LaserTrackerType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in LaserTrackerType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in LaserTrackerType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

UserDefinedUnitValueType * LaserTrackerType::getMaximumAngularVelocity()
{return MaximumAngularVelocity;}

void LaserTrackerType::setMaximumAngularVelocity(UserDefinedUnitValueType * MaximumAngularVelocityIn)
{MaximumAngularVelocity = MaximumAngularVelocityIn;}

LinearErrorType * LaserTrackerType::getDistanceAccuracy()
{return DistanceAccuracy;}

void LaserTrackerType::setDistanceAccuracy(LinearErrorType * DistanceAccuracyIn)
{DistanceAccuracy = DistanceAccuracyIn;}

AngularErrorType * LaserTrackerType::getAngularAccuracy()
{return AngularAccuracy;}

void LaserTrackerType::setAngularAccuracy(AngularErrorType * AngularAccuracyIn)
{AngularAccuracy = AngularAccuracyIn;}

UserDefinedUnitValueType * LaserTrackerType::getSamplingRate()
{return SamplingRate;}

void LaserTrackerType::setSamplingRate(UserDefinedUnitValueType * SamplingRateIn)
{SamplingRate = SamplingRateIn;}

TargetMirrorEnumType * LaserTrackerType::getTargetMirror()
{return TargetMirror;}

void LaserTrackerType::setTargetMirror(TargetMirrorEnumType * TargetMirrorIn)
{TargetMirror = TargetMirrorIn;}

MassValueType * LaserTrackerType::getHeadMass()
{return HeadMass;}

void LaserTrackerType::setHeadMass(MassValueType * HeadMassIn)
{HeadMass = HeadMassIn;}

CartesianWorkingVolumeType * LaserTrackerType::getHeadSize()
{return HeadSize;}

void LaserTrackerType::setHeadSize(CartesianWorkingVolumeType * HeadSizeIn)
{HeadSize = HeadSizeIn;}

LinearValueType * LaserTrackerType::getMaximumWorkingAmplitude()
{return MaximumWorkingAmplitude;}

void LaserTrackerType::setMaximumWorkingAmplitude(LinearValueType * MaximumWorkingAmplitudeIn)
{MaximumWorkingAmplitude = MaximumWorkingAmplitudeIn;}

LaserType * LaserTrackerType::getLaser()
{return Laser;}

void LaserTrackerType::setLaser(LaserType * LaserIn)
{Laser = LaserIn;}

LinearValueType * LaserTrackerType::getRepeatability()
{return Repeatability;}

void LaserTrackerType::setRepeatability(LinearValueType * RepeatabilityIn)
{Repeatability = RepeatabilityIn;}

/* ***************************************************************** */

/* class LaserTriangulationSensorType

*/

LaserTriangulationSensorType::LaserTriangulationSensorType() :
  SensorType()
{
  AverageSpotDiameter = 0;
  LaserSafetyClass = 0;
  MaxMeasurementFrequency = 0;
  MinMeasuringDistance = 0;
  MaxMeasuringDistance = 0;
  HousingMaterial = 0;
  PermissibleAmbientLight = 0;
  ShockTolerance = 0;
  VibrationTolerance = 0;
  OutputPower = 0;
  Laser = 0;
}

LaserTriangulationSensorType::LaserTriangulationSensorType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 XmlString * ProtectionClassIn,
 XmlString * LinearityErrorIn,
 LinearValueType * RepeatabilityIn,
 XmlDecimal * SensitivityIn,
 LinearValueType * ResolutionIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 LinearValueType * AverageSpotDiameterIn,
 XmlString * LaserSafetyClassIn,
 UserDefinedUnitValueType * MaxMeasurementFrequencyIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 XmlString * HousingMaterialIn,
 UserDefinedUnitValueType * PermissibleAmbientLightIn,
 UserDefinedUnitValueType * ShockToleranceIn,
 UserDefinedUnitValueType * VibrationToleranceIn,
 UserDefinedUnitValueType * OutputPowerIn,
 LaserType * LaserIn) :
  SensorType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    ProtectionClassIn,
    LinearityErrorIn,
    RepeatabilityIn,
    SensitivityIn,
    ResolutionIn,
    EnvironmentalRangeIn)
{
  AverageSpotDiameter = AverageSpotDiameterIn;
  LaserSafetyClass = LaserSafetyClassIn;
  MaxMeasurementFrequency = MaxMeasurementFrequencyIn;
  MinMeasuringDistance = MinMeasuringDistanceIn;
  MaxMeasuringDistance = MaxMeasuringDistanceIn;
  HousingMaterial = HousingMaterialIn;
  PermissibleAmbientLight = PermissibleAmbientLightIn;
  ShockTolerance = ShockToleranceIn;
  VibrationTolerance = VibrationToleranceIn;
  OutputPower = OutputPowerIn;
  Laser = LaserIn;
}

LaserTriangulationSensorType::LaserTriangulationSensorType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 XmlString * ProtectionClassIn,
 XmlString * LinearityErrorIn,
 LinearValueType * RepeatabilityIn,
 XmlDecimal * SensitivityIn,
 LinearValueType * ResolutionIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 LinearValueType * AverageSpotDiameterIn,
 XmlString * LaserSafetyClassIn,
 UserDefinedUnitValueType * MaxMeasurementFrequencyIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 XmlString * HousingMaterialIn,
 UserDefinedUnitValueType * PermissibleAmbientLightIn,
 UserDefinedUnitValueType * ShockToleranceIn,
 UserDefinedUnitValueType * VibrationToleranceIn,
 UserDefinedUnitValueType * OutputPowerIn,
 LaserType * LaserIn) :
  SensorType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    ProtectionClassIn,
    LinearityErrorIn,
    RepeatabilityIn,
    SensitivityIn,
    ResolutionIn,
    EnvironmentalRangeIn)
{
  AverageSpotDiameter = AverageSpotDiameterIn;
  LaserSafetyClass = LaserSafetyClassIn;
  MaxMeasurementFrequency = MaxMeasurementFrequencyIn;
  MinMeasuringDistance = MinMeasuringDistanceIn;
  MaxMeasuringDistance = MaxMeasuringDistanceIn;
  HousingMaterial = HousingMaterialIn;
  PermissibleAmbientLight = PermissibleAmbientLightIn;
  ShockTolerance = ShockToleranceIn;
  VibrationTolerance = VibrationToleranceIn;
  OutputPower = OutputPowerIn;
  Laser = LaserIn;
}

LaserTriangulationSensorType::~LaserTriangulationSensorType()
{
  #ifndef NODESTRUCT
  delete AverageSpotDiameter;
  delete LaserSafetyClass;
  delete MaxMeasurementFrequency;
  delete MinMeasuringDistance;
  delete MaxMeasuringDistance;
  delete HousingMaterial;
  delete PermissibleAmbientLight;
  delete ShockTolerance;
  delete VibrationTolerance;
  delete OutputPower;
  delete Laser;
  #endif
}

void LaserTriangulationSensorType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (ProtectionClass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProtectionClass");
      ProtectionClass->printSelf(outFile);
      fprintf(outFile, "</ProtectionClass>\n");
    }
  if (LinearityError)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LinearityError");
      LinearityError->printSelf(outFile);
      fprintf(outFile, "</LinearityError>\n");
    }
  if (Repeatability)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Repeatability");
      Repeatability->printSelf(outFile);
      fprintf(outFile, "</Repeatability>\n");
    }
  if (Sensitivity)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Sensitivity");
      Sensitivity->printSelf(outFile);
      fprintf(outFile, "</Sensitivity>\n");
    }
  if (Resolution)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Resolution");
      Resolution->printSelf(outFile);
      fprintf(outFile, "</Resolution>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (AverageSpotDiameter)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AverageSpotDiameter");
      AverageSpotDiameter->printSelf(outFile);
      fprintf(outFile, "</AverageSpotDiameter>\n");
    }
  if (LaserSafetyClass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LaserSafetyClass");
      LaserSafetyClass->printSelf(outFile);
      fprintf(outFile, "</LaserSafetyClass>\n");
    }
  if (MaxMeasurementFrequency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxMeasurementFrequency");
      MaxMeasurementFrequency->printSelf(outFile);
      fprintf(outFile, "</MaxMeasurementFrequency>\n");
    }
  if (MinMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinMeasuringDistance");
      MinMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MinMeasuringDistance>\n");
    }
  if (MaxMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxMeasuringDistance");
      MaxMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MaxMeasuringDistance>\n");
    }
  if (HousingMaterial)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<HousingMaterial");
      HousingMaterial->printSelf(outFile);
      fprintf(outFile, "</HousingMaterial>\n");
    }
  if (PermissibleAmbientLight)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PermissibleAmbientLight");
      PermissibleAmbientLight->printSelf(outFile);
      fprintf(outFile, "</PermissibleAmbientLight>\n");
    }
  if (ShockTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ShockTolerance");
      ShockTolerance->printSelf(outFile);
      fprintf(outFile, "</ShockTolerance>\n");
    }
  if (VibrationTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VibrationTolerance");
      VibrationTolerance->printSelf(outFile);
      fprintf(outFile, "</VibrationTolerance>\n");
    }
  if (OutputPower)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OutputPower");
      OutputPower->printSelf(outFile);
      fprintf(outFile, "</OutputPower>\n");
    }
  if (Laser)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Laser");
      Laser->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Laser>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool LaserTriangulationSensorType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in LaserTriangulationSensorType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in LaserTriangulationSensorType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in LaserTriangulationSensorType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in LaserTriangulationSensorType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LinearValueType * LaserTriangulationSensorType::getAverageSpotDiameter()
{return AverageSpotDiameter;}

void LaserTriangulationSensorType::setAverageSpotDiameter(LinearValueType * AverageSpotDiameterIn)
{AverageSpotDiameter = AverageSpotDiameterIn;}

XmlString * LaserTriangulationSensorType::getLaserSafetyClass()
{return LaserSafetyClass;}

void LaserTriangulationSensorType::setLaserSafetyClass(XmlString * LaserSafetyClassIn)
{LaserSafetyClass = LaserSafetyClassIn;}

UserDefinedUnitValueType * LaserTriangulationSensorType::getMaxMeasurementFrequency()
{return MaxMeasurementFrequency;}

void LaserTriangulationSensorType::setMaxMeasurementFrequency(UserDefinedUnitValueType * MaxMeasurementFrequencyIn)
{MaxMeasurementFrequency = MaxMeasurementFrequencyIn;}

LinearValueType * LaserTriangulationSensorType::getMinMeasuringDistance()
{return MinMeasuringDistance;}

void LaserTriangulationSensorType::setMinMeasuringDistance(LinearValueType * MinMeasuringDistanceIn)
{MinMeasuringDistance = MinMeasuringDistanceIn;}

LinearValueType * LaserTriangulationSensorType::getMaxMeasuringDistance()
{return MaxMeasuringDistance;}

void LaserTriangulationSensorType::setMaxMeasuringDistance(LinearValueType * MaxMeasuringDistanceIn)
{MaxMeasuringDistance = MaxMeasuringDistanceIn;}

XmlString * LaserTriangulationSensorType::getHousingMaterial()
{return HousingMaterial;}

void LaserTriangulationSensorType::setHousingMaterial(XmlString * HousingMaterialIn)
{HousingMaterial = HousingMaterialIn;}

UserDefinedUnitValueType * LaserTriangulationSensorType::getPermissibleAmbientLight()
{return PermissibleAmbientLight;}

void LaserTriangulationSensorType::setPermissibleAmbientLight(UserDefinedUnitValueType * PermissibleAmbientLightIn)
{PermissibleAmbientLight = PermissibleAmbientLightIn;}

UserDefinedUnitValueType * LaserTriangulationSensorType::getShockTolerance()
{return ShockTolerance;}

void LaserTriangulationSensorType::setShockTolerance(UserDefinedUnitValueType * ShockToleranceIn)
{ShockTolerance = ShockToleranceIn;}

UserDefinedUnitValueType * LaserTriangulationSensorType::getVibrationTolerance()
{return VibrationTolerance;}

void LaserTriangulationSensorType::setVibrationTolerance(UserDefinedUnitValueType * VibrationToleranceIn)
{VibrationTolerance = VibrationToleranceIn;}

UserDefinedUnitValueType * LaserTriangulationSensorType::getOutputPower()
{return OutputPower;}

void LaserTriangulationSensorType::setOutputPower(UserDefinedUnitValueType * OutputPowerIn)
{OutputPower = OutputPowerIn;}

LaserType * LaserTriangulationSensorType::getLaser()
{return Laser;}

void LaserTriangulationSensorType::setLaser(LaserType * LaserIn)
{Laser = LaserIn;}

/* ***************************************************************** */

/* class LaserType

*/

LaserType::LaserType() :
  MeasurementResourceBaseType()
{
  LaserSource = 0;
  LaserWaveLength = 0;
  LaserPower = 0;
  LaserSafetyClass = 0;
  LaserEffectiveLength = 0;
  LaserSpotSize = 0;
  LaserPowerSupply = 0;
}

LaserType::LaserType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 XmlString * LaserSourceIn,
 LinearValueType * LaserWaveLengthIn,
 UserDefinedUnitValueType * LaserPowerIn,
 XmlString * LaserSafetyClassIn,
 LinearValueType * LaserEffectiveLengthIn,
 LinearValueType * LaserSpotSizeIn,
 UserDefinedUnitValueType * LaserPowerSupplyIn) :
  MeasurementResourceBaseType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  LaserSource = LaserSourceIn;
  LaserWaveLength = LaserWaveLengthIn;
  LaserPower = LaserPowerIn;
  LaserSafetyClass = LaserSafetyClassIn;
  LaserEffectiveLength = LaserEffectiveLengthIn;
  LaserSpotSize = LaserSpotSizeIn;
  LaserPowerSupply = LaserPowerSupplyIn;
}

LaserType::LaserType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 XmlString * LaserSourceIn,
 LinearValueType * LaserWaveLengthIn,
 UserDefinedUnitValueType * LaserPowerIn,
 XmlString * LaserSafetyClassIn,
 LinearValueType * LaserEffectiveLengthIn,
 LinearValueType * LaserSpotSizeIn,
 UserDefinedUnitValueType * LaserPowerSupplyIn) :
  MeasurementResourceBaseType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  LaserSource = LaserSourceIn;
  LaserWaveLength = LaserWaveLengthIn;
  LaserPower = LaserPowerIn;
  LaserSafetyClass = LaserSafetyClassIn;
  LaserEffectiveLength = LaserEffectiveLengthIn;
  LaserSpotSize = LaserSpotSizeIn;
  LaserPowerSupply = LaserPowerSupplyIn;
}

LaserType::~LaserType()
{
  #ifndef NODESTRUCT
  delete LaserSource;
  delete LaserWaveLength;
  delete LaserPower;
  delete LaserSafetyClass;
  delete LaserEffectiveLength;
  delete LaserSpotSize;
  delete LaserPowerSupply;
  #endif
}

void LaserType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (LaserSource)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LaserSource");
      LaserSource->printSelf(outFile);
      fprintf(outFile, "</LaserSource>\n");
    }
  if (LaserWaveLength)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LaserWaveLength");
      LaserWaveLength->printSelf(outFile);
      fprintf(outFile, "</LaserWaveLength>\n");
    }
  if (LaserPower)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LaserPower");
      LaserPower->printSelf(outFile);
      fprintf(outFile, "</LaserPower>\n");
    }
  if (LaserSafetyClass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LaserSafetyClass");
      LaserSafetyClass->printSelf(outFile);
      fprintf(outFile, "</LaserSafetyClass>\n");
    }
  if (LaserEffectiveLength)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LaserEffectiveLength");
      LaserEffectiveLength->printSelf(outFile);
      fprintf(outFile, "</LaserEffectiveLength>\n");
    }
  if (LaserSpotSize)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LaserSpotSize");
      LaserSpotSize->printSelf(outFile);
      fprintf(outFile, "</LaserSpotSize>\n");
    }
  if (LaserPowerSupply)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LaserPowerSupply");
      LaserPowerSupply->printSelf(outFile);
      fprintf(outFile, "</LaserPowerSupply>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool LaserType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in LaserType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in LaserType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in LaserType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in LaserType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

XmlString * LaserType::getLaserSource()
{return LaserSource;}

void LaserType::setLaserSource(XmlString * LaserSourceIn)
{LaserSource = LaserSourceIn;}

LinearValueType * LaserType::getLaserWaveLength()
{return LaserWaveLength;}

void LaserType::setLaserWaveLength(LinearValueType * LaserWaveLengthIn)
{LaserWaveLength = LaserWaveLengthIn;}

UserDefinedUnitValueType * LaserType::getLaserPower()
{return LaserPower;}

void LaserType::setLaserPower(UserDefinedUnitValueType * LaserPowerIn)
{LaserPower = LaserPowerIn;}

XmlString * LaserType::getLaserSafetyClass()
{return LaserSafetyClass;}

void LaserType::setLaserSafetyClass(XmlString * LaserSafetyClassIn)
{LaserSafetyClass = LaserSafetyClassIn;}

LinearValueType * LaserType::getLaserEffectiveLength()
{return LaserEffectiveLength;}

void LaserType::setLaserEffectiveLength(LinearValueType * LaserEffectiveLengthIn)
{LaserEffectiveLength = LaserEffectiveLengthIn;}

LinearValueType * LaserType::getLaserSpotSize()
{return LaserSpotSize;}

void LaserType::setLaserSpotSize(LinearValueType * LaserSpotSizeIn)
{LaserSpotSize = LaserSpotSizeIn;}

UserDefinedUnitValueType * LaserType::getLaserPowerSupply()
{return LaserPowerSupply;}

void LaserType::setLaserPowerSupply(UserDefinedUnitValueType * LaserPowerSupplyIn)
{LaserPowerSupply = LaserPowerSupplyIn;}

/* ***************************************************************** */

/* class LengthFunctionDiscreteType

*/

LengthFunctionDiscreteType::LengthFunctionDiscreteType() :
  FunctionDiscreteType()
{
  DomainLinearUnit = 0;
  RangeLinearUnit = 0;
}

LengthFunctionDiscreteType::LengthFunctionDiscreteType(
 ListDoubleType * DomainValuesIn,
 ListDoubleType * RangeValuesIn,
 XmlToken * DomainLinearUnitIn,
 XmlToken * RangeLinearUnitIn) :
  FunctionDiscreteType(
    DomainValuesIn,
    RangeValuesIn)
{
  DomainLinearUnit = DomainLinearUnitIn;
  RangeLinearUnit = RangeLinearUnitIn;
}

LengthFunctionDiscreteType::LengthFunctionDiscreteType(
 NaturalType * nIn,
 ListDoubleType * DomainValuesIn,
 ListDoubleType * RangeValuesIn,
 XmlToken * DomainLinearUnitIn,
 XmlToken * RangeLinearUnitIn) :
  FunctionDiscreteType(
    nIn,
    DomainValuesIn,
    RangeValuesIn)
{
  DomainLinearUnit = DomainLinearUnitIn;
  RangeLinearUnit = RangeLinearUnitIn;
}

LengthFunctionDiscreteType::~LengthFunctionDiscreteType()
{
  #ifndef NODESTRUCT
  delete DomainLinearUnit;
  delete RangeLinearUnit;
  #endif
}

void LengthFunctionDiscreteType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<DomainValues");
  DomainValues->printSelf(outFile);
  fprintf(outFile, "</DomainValues>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<RangeValues");
  RangeValues->printSelf(outFile);
  fprintf(outFile, "</RangeValues>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<DomainLinearUnit");
  DomainLinearUnit->printSelf(outFile);
  fprintf(outFile, "</DomainLinearUnit>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<RangeLinearUnit");
  RangeLinearUnit->printSelf(outFile);
  fprintf(outFile, "</RangeLinearUnit>\n");
  doSpaces(-INDENT, outFile);
}

bool LengthFunctionDiscreteType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in LengthFunctionDiscreteType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in LengthFunctionDiscreteType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in LengthFunctionDiscreteType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in LengthFunctionDiscreteType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

XmlToken * LengthFunctionDiscreteType::getDomainLinearUnit()
{return DomainLinearUnit;}

void LengthFunctionDiscreteType::setDomainLinearUnit(XmlToken * DomainLinearUnitIn)
{DomainLinearUnit = DomainLinearUnitIn;}

XmlToken * LengthFunctionDiscreteType::getRangeLinearUnit()
{return RangeLinearUnit;}

void LengthFunctionDiscreteType::setRangeLinearUnit(XmlToken * RangeLinearUnitIn)
{RangeLinearUnit = RangeLinearUnitIn;}

/* ***************************************************************** */

/* class LesserErrorType

*/

LesserErrorType::LesserErrorType()
{
  MaxErrorConstant = 0;
  LinearError = 0;
}

LesserErrorType::LesserErrorType(
 LinearValueType * MaxErrorConstantIn,
 LinearErrorType * LinearErrorIn)
{
  MaxErrorConstant = MaxErrorConstantIn;
  LinearError = LinearErrorIn;
}

LesserErrorType::~LesserErrorType()
{
  #ifndef NODESTRUCT
  delete MaxErrorConstant;
  delete LinearError;
  #endif
}

void LesserErrorType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxErrorConstant");
  MaxErrorConstant->printSelf(outFile);
  fprintf(outFile, "</MaxErrorConstant>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<LinearError");
  LinearError->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</LinearError>\n");
  doSpaces(-INDENT, outFile);
}

LinearValueType * LesserErrorType::getMaxErrorConstant()
{return MaxErrorConstant;}

void LesserErrorType::setMaxErrorConstant(LinearValueType * MaxErrorConstantIn)
{MaxErrorConstant = MaxErrorConstantIn;}

LinearErrorType * LesserErrorType::getLinearError()
{return LinearError;}

void LesserErrorType::setLinearError(LinearErrorType * LinearErrorIn)
{LinearError = LinearErrorIn;}

/* ***************************************************************** */

/* class LightPenCMMType

*/

LightPenCMMType::LightPenCMMType() :
  CMMType()
{
  LightPenCMMChargeCoupledDeviceCameraSensor = 0;
  LightSource = 0;
  NominalVolumetricAccuracy = 0;
  ActualVolumetricAccuracy = 0;
  NominalSinglePointAccuracy = 0;
  ActualSinglePointAccuracy = 0;
  ScanningSpeed = 0;
  LaserClass = 0;
}

LightPenCMMType::LightPenCMMType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 ResolutionBaseType * ResolutionIn,
 WorkingVolumeBaseType * WorkingVolumeIn,
 EffectiveWorkingVolumeBaseType * EffectiveWorkingVolumeIn,
 TemperatureCompensationType * TemperatureCompensationIn,
 ChargeCoupledDeviceCameraSensorType * LightPenCMMChargeCoupledDeviceCameraSensorIn,
 XmlString * LightSourceIn,
 LinearValueType * NominalVolumetricAccuracyIn,
 LinearValueType * ActualVolumetricAccuracyIn,
 LinearValueType * NominalSinglePointAccuracyIn,
 LinearValueType * ActualSinglePointAccuracyIn,
 UserDefinedUnitValueType * ScanningSpeedIn,
 XmlString * LaserClassIn) :
  CMMType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    ResolutionIn,
    WorkingVolumeIn,
    EffectiveWorkingVolumeIn,
    TemperatureCompensationIn)
{
  LightPenCMMChargeCoupledDeviceCameraSensor = LightPenCMMChargeCoupledDeviceCameraSensorIn;
  LightSource = LightSourceIn;
  NominalVolumetricAccuracy = NominalVolumetricAccuracyIn;
  ActualVolumetricAccuracy = ActualVolumetricAccuracyIn;
  NominalSinglePointAccuracy = NominalSinglePointAccuracyIn;
  ActualSinglePointAccuracy = ActualSinglePointAccuracyIn;
  ScanningSpeed = ScanningSpeedIn;
  LaserClass = LaserClassIn;
}

LightPenCMMType::LightPenCMMType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 ResolutionBaseType * ResolutionIn,
 WorkingVolumeBaseType * WorkingVolumeIn,
 EffectiveWorkingVolumeBaseType * EffectiveWorkingVolumeIn,
 TemperatureCompensationType * TemperatureCompensationIn,
 ChargeCoupledDeviceCameraSensorType * LightPenCMMChargeCoupledDeviceCameraSensorIn,
 XmlString * LightSourceIn,
 LinearValueType * NominalVolumetricAccuracyIn,
 LinearValueType * ActualVolumetricAccuracyIn,
 LinearValueType * NominalSinglePointAccuracyIn,
 LinearValueType * ActualSinglePointAccuracyIn,
 UserDefinedUnitValueType * ScanningSpeedIn,
 XmlString * LaserClassIn) :
  CMMType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    ResolutionIn,
    WorkingVolumeIn,
    EffectiveWorkingVolumeIn,
    TemperatureCompensationIn)
{
  LightPenCMMChargeCoupledDeviceCameraSensor = LightPenCMMChargeCoupledDeviceCameraSensorIn;
  LightSource = LightSourceIn;
  NominalVolumetricAccuracy = NominalVolumetricAccuracyIn;
  ActualVolumetricAccuracy = ActualVolumetricAccuracyIn;
  NominalSinglePointAccuracy = NominalSinglePointAccuracyIn;
  ActualSinglePointAccuracy = ActualSinglePointAccuracyIn;
  ScanningSpeed = ScanningSpeedIn;
  LaserClass = LaserClassIn;
}

LightPenCMMType::~LightPenCMMType()
{
  #ifndef NODESTRUCT
  delete LightPenCMMChargeCoupledDeviceCameraSensor;
  delete LightSource;
  delete NominalVolumetricAccuracy;
  delete ActualVolumetricAccuracy;
  delete NominalSinglePointAccuracy;
  delete ActualSinglePointAccuracy;
  delete ScanningSpeed;
  delete LaserClass;
  #endif
}

void LightPenCMMType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Calibrations)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Calibrations");
      Calibrations->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Calibrations>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (Resolution)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (Resolution->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(Resolution->getprintElement(), "LinearResolution") == 0)
          {
            LinearResolutionType * typ;
            if ((typ = dynamic_cast<LinearResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<LinearResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LinearResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad LinearResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "CartesianResolution") == 0)
          {
            CartesianResolutionType * typ;
            if ((typ = dynamic_cast<CartesianResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<CartesianResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "SphericalResolution") == 0)
          {
            SphericalResolutionType * typ;
            if ((typ = dynamic_cast<SphericalResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<SphericalResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "UserDefinedResolution") == 0)
          {
            UserDefinedResolutionType * typ;
            if ((typ = dynamic_cast<UserDefinedResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<UserDefinedResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedResolution element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad Resolution type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (WorkingVolume)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (WorkingVolume->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(WorkingVolume->getprintElement(), "ClosedShellSetWorkingVolume") == 0)
          {
            ClosedShellSetWorkingVolumeType * typ;
            if ((typ = dynamic_cast<ClosedShellSetWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<ClosedShellSetWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ClosedShellSetWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad ClosedShellSetWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "CartesianWorkingVolume") == 0)
          {
            CartesianWorkingVolumeType * typ;
            if ((typ = dynamic_cast<CartesianWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<CartesianWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "SphericalWorkingVolume") == 0)
          {
            SphericalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<SphericalWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<SphericalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "CylindricalWorkingVolume") == 0)
          {
            CylindricalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<CylindricalWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<CylindricalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CylindricalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad CylindricalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "UserDefinedWorkingVolume") == 0)
          {
            UserDefinedWorkingVolumeType * typ;
            if ((typ = dynamic_cast<UserDefinedWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<UserDefinedWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedWorkingVolume element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad WorkingVolume type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (EffectiveWorkingVolume)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (EffectiveWorkingVolume->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveClosedShellSetWorkingVolume") == 0)
          {
            EffectiveClosedShellSetWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveClosedShellSetWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveClosedShellSetWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveClosedShellSetWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveClosedShellSetWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveCartesianWorkingVolume") == 0)
          {
            EffectiveCartesianWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveCartesianWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveCartesianWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveCartesianWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveCartesianWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveSphericalWorkingVolume") == 0)
          {
            EffectiveSphericalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveSphericalWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveSphericalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveSphericalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveSphericalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveCylindricalWorkingVolume") == 0)
          {
            EffectiveCylindricalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveCylindricalWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveCylindricalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveCylindricalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveCylindricalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveUserDefinedWorkingVolume") == 0)
          {
            EffectiveUserDefinedWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveUserDefinedWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveUserDefinedWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveUserDefinedWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveUserDefinedWorkingVolume element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad EffectiveWorkingVolume type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (TemperatureCompensation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TemperatureCompensation");
      TemperatureCompensation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</TemperatureCompensation>\n");
    }
  if (LightPenCMMChargeCoupledDeviceCameraSensor)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LightPenCMMChargeCoupledDeviceCameraSensor");
      LightPenCMMChargeCoupledDeviceCameraSensor->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LightPenCMMChargeCoupledDeviceCameraSensor>\n");
    }
  if (LightSource)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LightSource");
      LightSource->printSelf(outFile);
      fprintf(outFile, "</LightSource>\n");
    }
  if (NominalVolumetricAccuracy)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalVolumetricAccuracy");
      NominalVolumetricAccuracy->printSelf(outFile);
      fprintf(outFile, "</NominalVolumetricAccuracy>\n");
    }
  if (ActualVolumetricAccuracy)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualVolumetricAccuracy");
      ActualVolumetricAccuracy->printSelf(outFile);
      fprintf(outFile, "</ActualVolumetricAccuracy>\n");
    }
  if (NominalSinglePointAccuracy)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalSinglePointAccuracy");
      NominalSinglePointAccuracy->printSelf(outFile);
      fprintf(outFile, "</NominalSinglePointAccuracy>\n");
    }
  if (ActualSinglePointAccuracy)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActualSinglePointAccuracy");
      ActualSinglePointAccuracy->printSelf(outFile);
      fprintf(outFile, "</ActualSinglePointAccuracy>\n");
    }
  if (ScanningSpeed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ScanningSpeed");
      ScanningSpeed->printSelf(outFile);
      fprintf(outFile, "</ScanningSpeed>\n");
    }
  if (LaserClass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LaserClass");
      LaserClass->printSelf(outFile);
      fprintf(outFile, "</LaserClass>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool LightPenCMMType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in LightPenCMMType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in LightPenCMMType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in LightPenCMMType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in LightPenCMMType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

ChargeCoupledDeviceCameraSensorType * LightPenCMMType::getLightPenCMMChargeCoupledDeviceCameraSensor()
{return LightPenCMMChargeCoupledDeviceCameraSensor;}

void LightPenCMMType::setLightPenCMMChargeCoupledDeviceCameraSensor(ChargeCoupledDeviceCameraSensorType * LightPenCMMChargeCoupledDeviceCameraSensorIn)
{LightPenCMMChargeCoupledDeviceCameraSensor = LightPenCMMChargeCoupledDeviceCameraSensorIn;}

XmlString * LightPenCMMType::getLightSource()
{return LightSource;}

void LightPenCMMType::setLightSource(XmlString * LightSourceIn)
{LightSource = LightSourceIn;}

LinearValueType * LightPenCMMType::getNominalVolumetricAccuracy()
{return NominalVolumetricAccuracy;}

void LightPenCMMType::setNominalVolumetricAccuracy(LinearValueType * NominalVolumetricAccuracyIn)
{NominalVolumetricAccuracy = NominalVolumetricAccuracyIn;}

LinearValueType * LightPenCMMType::getActualVolumetricAccuracy()
{return ActualVolumetricAccuracy;}

void LightPenCMMType::setActualVolumetricAccuracy(LinearValueType * ActualVolumetricAccuracyIn)
{ActualVolumetricAccuracy = ActualVolumetricAccuracyIn;}

LinearValueType * LightPenCMMType::getNominalSinglePointAccuracy()
{return NominalSinglePointAccuracy;}

void LightPenCMMType::setNominalSinglePointAccuracy(LinearValueType * NominalSinglePointAccuracyIn)
{NominalSinglePointAccuracy = NominalSinglePointAccuracyIn;}

LinearValueType * LightPenCMMType::getActualSinglePointAccuracy()
{return ActualSinglePointAccuracy;}

void LightPenCMMType::setActualSinglePointAccuracy(LinearValueType * ActualSinglePointAccuracyIn)
{ActualSinglePointAccuracy = ActualSinglePointAccuracyIn;}

UserDefinedUnitValueType * LightPenCMMType::getScanningSpeed()
{return ScanningSpeed;}

void LightPenCMMType::setScanningSpeed(UserDefinedUnitValueType * ScanningSpeedIn)
{ScanningSpeed = ScanningSpeedIn;}

XmlString * LightPenCMMType::getLaserClass()
{return LaserClass;}

void LightPenCMMType::setLaserClass(XmlString * LaserClassIn)
{LaserClass = LaserClassIn;}

/* ***************************************************************** */

/* class LinearAxisType

*/

LinearAxisType::LinearAxisType() :
  UserAxisBaseType()
{
  MinLinearAxis = 0;
  MaxLinearAxis = 0;
}

LinearAxisType::LinearAxisType(
 LinearValueType * MinLinearAxisIn,
 LinearValueType * MaxLinearAxisIn) :
  UserAxisBaseType()
{
  MinLinearAxis = MinLinearAxisIn;
  MaxLinearAxis = MaxLinearAxisIn;
}

LinearAxisType::~LinearAxisType()
{
  #ifndef NODESTRUCT
  delete MinLinearAxis;
  delete MaxLinearAxis;
  #endif
}

void LinearAxisType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<MinLinearAxis");
  MinLinearAxis->printSelf(outFile);
  fprintf(outFile, "</MinLinearAxis>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxLinearAxis");
  MaxLinearAxis->printSelf(outFile);
  fprintf(outFile, "</MaxLinearAxis>\n");
  doSpaces(-INDENT, outFile);
}

LinearValueType * LinearAxisType::getMinLinearAxis()
{return MinLinearAxis;}

void LinearAxisType::setMinLinearAxis(LinearValueType * MinLinearAxisIn)
{MinLinearAxis = MinLinearAxisIn;}

LinearValueType * LinearAxisType::getMaxLinearAxis()
{return MaxLinearAxis;}

void LinearAxisType::setMaxLinearAxis(LinearValueType * MaxLinearAxisIn)
{MaxLinearAxis = MaxLinearAxisIn;}

/* ***************************************************************** */

/* class LinearErrorType

*/

LinearErrorType::LinearErrorType()
{
  BaseError = 0;
  ErrorRate = 0;
}

LinearErrorType::LinearErrorType(
 LinearValueType * BaseErrorIn,
 XmlDecimal * ErrorRateIn)
{
  BaseError = BaseErrorIn;
  ErrorRate = ErrorRateIn;
}

LinearErrorType::~LinearErrorType()
{
  #ifndef NODESTRUCT
  delete BaseError;
  delete ErrorRate;
  #endif
}

void LinearErrorType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<BaseError");
  BaseError->printSelf(outFile);
  fprintf(outFile, "</BaseError>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<ErrorRate");
  ErrorRate->printSelf(outFile);
  fprintf(outFile, "</ErrorRate>\n");
  doSpaces(-INDENT, outFile);
}

LinearValueType * LinearErrorType::getBaseError()
{return BaseError;}

void LinearErrorType::setBaseError(LinearValueType * BaseErrorIn)
{BaseError = BaseErrorIn;}

XmlDecimal * LinearErrorType::getErrorRate()
{return ErrorRate;}

void LinearErrorType::setErrorRate(XmlDecimal * ErrorRateIn)
{ErrorRate = ErrorRateIn;}

/* ***************************************************************** */

/* class LinearOrRotaryAxisType

*/

LinearOrRotaryAxisType::LinearOrRotaryAxisType()
{
  Axis = 0;
}

LinearOrRotaryAxisType::LinearOrRotaryAxisType(
 UserAxisBaseType * AxisIn)
{
  Axis = AxisIn;
}

LinearOrRotaryAxisType::~LinearOrRotaryAxisType()
{
  #ifndef NODESTRUCT
  delete Axis;
  #endif
}

void LinearOrRotaryAxisType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    doSpaces(0, outFile);
    if (Axis->getprintElement() == 0)
      {
        fprintf(stderr, "element name missing\n");
        exit(1);
      }
    else if (strcmp(Axis->getprintElement(), "RotaryAxis") == 0)
      {
        RotaryAxisType * typ;
        if ((typ = dynamic_cast<RotaryAxisType *>(Axis)))
          {
            fprintf(outFile, "<RotaryAxis");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</RotaryAxis>\n");
          }
        else
          {
            fprintf(stderr, "bad RotaryAxis element\n");
            exit(1);
          }
      }
    else if (strcmp(Axis->getprintElement(), "LinearAxis") == 0)
      {
        LinearAxisType * typ;
        if ((typ = dynamic_cast<LinearAxisType *>(Axis)))
          {
            fprintf(outFile, "<LinearAxis");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</LinearAxis>\n");
          }
        else
          {
            fprintf(stderr, "bad LinearAxis element\n");
            exit(1);
          }
      }
    else
      {
        fprintf(stderr, "bad Axis type\n");
        fprintf(stderr, " exiting\n");
        exit(1);
      }
  }
  doSpaces(-INDENT, outFile);
}

UserAxisBaseType * LinearOrRotaryAxisType::getAxis()
{return Axis;}

void LinearOrRotaryAxisType::setAxis(UserAxisBaseType * AxisIn)
{Axis = AxisIn;}

/* ***************************************************************** */

/* class LinearResolutionType

*/

LinearResolutionType::LinearResolutionType() :
  ResolutionBaseType()
{
  LinearValue = 0;
}

LinearResolutionType::LinearResolutionType(
 LinearValueType * LinearValueIn) :
  ResolutionBaseType()
{
  LinearValue = LinearValueIn;
}

LinearResolutionType::~LinearResolutionType()
{
  #ifndef NODESTRUCT
  delete LinearValue;
  #endif
}

void LinearResolutionType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<LinearValue");
  LinearValue->printSelf(outFile);
  fprintf(outFile, "</LinearValue>\n");
  doSpaces(-INDENT, outFile);
}

LinearValueType * LinearResolutionType::getLinearValue()
{return LinearValue;}

void LinearResolutionType::setLinearValue(LinearValueType * LinearValueIn)
{LinearValue = LinearValueIn;}

/* ***************************************************************** */

/* class LinearVariableDifferentialTransformerEnumType

*/

LinearVariableDifferentialTransformerEnumType::LinearVariableDifferentialTransformerEnumType() :
  XmlNMTOKEN()
{
}

LinearVariableDifferentialTransformerEnumType::LinearVariableDifferentialTransformerEnumType(
 const char * valIn) :
  XmlNMTOKEN(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "AC_LINEAR_VARIABLE_DIFFERENTIAL_TRANSFORMER") &&
           strcmp(val.c_str(), "DC_LINEAR_VARIABLE_DIFFERENTIAL_TRANSFORMER"));
}

LinearVariableDifferentialTransformerEnumType::~LinearVariableDifferentialTransformerEnumType() {}

bool LinearVariableDifferentialTransformerEnumType::LinearVariableDifferentialTransformerEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "AC_LINEAR_VARIABLE_DIFFERENTIAL_TRANSFORMER") &&
          strcmp(val.c_str(), "DC_LINEAR_VARIABLE_DIFFERENTIAL_TRANSFORMER"));
}

void LinearVariableDifferentialTransformerEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "LinearVariableDifferentialTransformerEnumType");
}

void LinearVariableDifferentialTransformerEnumType::printSelf(FILE * outFile)
{
  if (LinearVariableDifferentialTransformerEnumTypeIsBad())
    {
      fprintf(stderr, "bad LinearVariableDifferentialTransformerEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::printSelf(outFile);
}

void LinearVariableDifferentialTransformerEnumType::oPrintSelf(FILE * outFile)
{
  if (LinearVariableDifferentialTransformerEnumTypeIsBad())
    {
      fprintf(stderr, "bad LinearVariableDifferentialTransformerEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class LinearVariableDifferentialTransformerSensorType

*/

LinearVariableDifferentialTransformerSensorType::LinearVariableDifferentialTransformerSensorType() :
  DetachableSensorBaseType()
{
  TypeOfLinearVariableDifferentialTransformer = 0;
  MinMeasuringDistance = 0;
  MaxMeasuringDistance = 0;
  TemperatureStability = 0;
  ExcitationFrequency = 0;
  ExcitationAmplitude = 0;
  Diameter = 0;
  ShockTolerance = 0;
  VibrationTolerance = 0;
  HousingMaterial = 0;
  ElectronicDescription = 0;
}

LinearVariableDifferentialTransformerSensorType::LinearVariableDifferentialTransformerSensorType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 XmlString * ProtectionClassIn,
 XmlString * LinearityErrorIn,
 LinearValueType * RepeatabilityIn,
 XmlDecimal * SensitivityIn,
 LinearValueType * ResolutionIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 LinearVariableDifferentialTransformerEnumType * TypeOfLinearVariableDifferentialTransformerIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 UserDefinedUnitValueType * TemperatureStabilityIn,
 UserDefinedUnitValueType * ExcitationFrequencyIn,
 UserDefinedUnitValueType * ExcitationAmplitudeIn,
 LinearValueType * DiameterIn,
 UserDefinedUnitValueType * ShockToleranceIn,
 UserDefinedUnitValueType * VibrationToleranceIn,
 XmlString * HousingMaterialIn,
 XmlString * ElectronicDescriptionIn) :
  DetachableSensorBaseType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    ProtectionClassIn,
    LinearityErrorIn,
    RepeatabilityIn,
    SensitivityIn,
    ResolutionIn,
    EnvironmentalRangeIn)
{
  TypeOfLinearVariableDifferentialTransformer = TypeOfLinearVariableDifferentialTransformerIn;
  MinMeasuringDistance = MinMeasuringDistanceIn;
  MaxMeasuringDistance = MaxMeasuringDistanceIn;
  TemperatureStability = TemperatureStabilityIn;
  ExcitationFrequency = ExcitationFrequencyIn;
  ExcitationAmplitude = ExcitationAmplitudeIn;
  Diameter = DiameterIn;
  ShockTolerance = ShockToleranceIn;
  VibrationTolerance = VibrationToleranceIn;
  HousingMaterial = HousingMaterialIn;
  ElectronicDescription = ElectronicDescriptionIn;
}

LinearVariableDifferentialTransformerSensorType::LinearVariableDifferentialTransformerSensorType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 XmlString * ProtectionClassIn,
 XmlString * LinearityErrorIn,
 LinearValueType * RepeatabilityIn,
 XmlDecimal * SensitivityIn,
 LinearValueType * ResolutionIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 LinearVariableDifferentialTransformerEnumType * TypeOfLinearVariableDifferentialTransformerIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 UserDefinedUnitValueType * TemperatureStabilityIn,
 UserDefinedUnitValueType * ExcitationFrequencyIn,
 UserDefinedUnitValueType * ExcitationAmplitudeIn,
 LinearValueType * DiameterIn,
 UserDefinedUnitValueType * ShockToleranceIn,
 UserDefinedUnitValueType * VibrationToleranceIn,
 XmlString * HousingMaterialIn,
 XmlString * ElectronicDescriptionIn) :
  DetachableSensorBaseType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    ProtectionClassIn,
    LinearityErrorIn,
    RepeatabilityIn,
    SensitivityIn,
    ResolutionIn,
    EnvironmentalRangeIn)
{
  TypeOfLinearVariableDifferentialTransformer = TypeOfLinearVariableDifferentialTransformerIn;
  MinMeasuringDistance = MinMeasuringDistanceIn;
  MaxMeasuringDistance = MaxMeasuringDistanceIn;
  TemperatureStability = TemperatureStabilityIn;
  ExcitationFrequency = ExcitationFrequencyIn;
  ExcitationAmplitude = ExcitationAmplitudeIn;
  Diameter = DiameterIn;
  ShockTolerance = ShockToleranceIn;
  VibrationTolerance = VibrationToleranceIn;
  HousingMaterial = HousingMaterialIn;
  ElectronicDescription = ElectronicDescriptionIn;
}

LinearVariableDifferentialTransformerSensorType::~LinearVariableDifferentialTransformerSensorType()
{
  #ifndef NODESTRUCT
  delete TypeOfLinearVariableDifferentialTransformer;
  delete MinMeasuringDistance;
  delete MaxMeasuringDistance;
  delete TemperatureStability;
  delete ExcitationFrequency;
  delete ExcitationAmplitude;
  delete Diameter;
  delete ShockTolerance;
  delete VibrationTolerance;
  delete HousingMaterial;
  delete ElectronicDescription;
  #endif
}

void LinearVariableDifferentialTransformerSensorType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (ProtectionClass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProtectionClass");
      ProtectionClass->printSelf(outFile);
      fprintf(outFile, "</ProtectionClass>\n");
    }
  if (LinearityError)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LinearityError");
      LinearityError->printSelf(outFile);
      fprintf(outFile, "</LinearityError>\n");
    }
  if (Repeatability)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Repeatability");
      Repeatability->printSelf(outFile);
      fprintf(outFile, "</Repeatability>\n");
    }
  if (Sensitivity)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Sensitivity");
      Sensitivity->printSelf(outFile);
      fprintf(outFile, "</Sensitivity>\n");
    }
  if (Resolution)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Resolution");
      Resolution->printSelf(outFile);
      fprintf(outFile, "</Resolution>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (TypeOfLinearVariableDifferentialTransformer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TypeOfLinearVariableDifferentialTransformer");
      TypeOfLinearVariableDifferentialTransformer->printSelf(outFile);
      fprintf(outFile, "</TypeOfLinearVariableDifferentialTransformer>\n");
    }
  if (MinMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinMeasuringDistance");
      MinMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MinMeasuringDistance>\n");
    }
  if (MaxMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxMeasuringDistance");
      MaxMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MaxMeasuringDistance>\n");
    }
  if (TemperatureStability)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TemperatureStability");
      TemperatureStability->printSelf(outFile);
      fprintf(outFile, "</TemperatureStability>\n");
    }
  if (ExcitationFrequency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ExcitationFrequency");
      ExcitationFrequency->printSelf(outFile);
      fprintf(outFile, "</ExcitationFrequency>\n");
    }
  if (ExcitationAmplitude)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ExcitationAmplitude");
      ExcitationAmplitude->printSelf(outFile);
      fprintf(outFile, "</ExcitationAmplitude>\n");
    }
  if (Diameter)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Diameter");
      Diameter->printSelf(outFile);
      fprintf(outFile, "</Diameter>\n");
    }
  if (ShockTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ShockTolerance");
      ShockTolerance->printSelf(outFile);
      fprintf(outFile, "</ShockTolerance>\n");
    }
  if (VibrationTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VibrationTolerance");
      VibrationTolerance->printSelf(outFile);
      fprintf(outFile, "</VibrationTolerance>\n");
    }
  if (HousingMaterial)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<HousingMaterial");
      HousingMaterial->printSelf(outFile);
      fprintf(outFile, "</HousingMaterial>\n");
    }
  if (ElectronicDescription)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ElectronicDescription");
      ElectronicDescription->printSelf(outFile);
      fprintf(outFile, "</ElectronicDescription>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool LinearVariableDifferentialTransformerSensorType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in LinearVariableDifferentialTransformerSensorType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in LinearVariableDifferentialTransformerSensorType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in LinearVariableDifferentialTransformerSensorType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in LinearVariableDifferentialTransformerSensorType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LinearVariableDifferentialTransformerEnumType * LinearVariableDifferentialTransformerSensorType::getTypeOfLinearVariableDifferentialTransformer()
{return TypeOfLinearVariableDifferentialTransformer;}

void LinearVariableDifferentialTransformerSensorType::setTypeOfLinearVariableDifferentialTransformer(LinearVariableDifferentialTransformerEnumType * TypeOfLinearVariableDifferentialTransformerIn)
{TypeOfLinearVariableDifferentialTransformer = TypeOfLinearVariableDifferentialTransformerIn;}

LinearValueType * LinearVariableDifferentialTransformerSensorType::getMinMeasuringDistance()
{return MinMeasuringDistance;}

void LinearVariableDifferentialTransformerSensorType::setMinMeasuringDistance(LinearValueType * MinMeasuringDistanceIn)
{MinMeasuringDistance = MinMeasuringDistanceIn;}

LinearValueType * LinearVariableDifferentialTransformerSensorType::getMaxMeasuringDistance()
{return MaxMeasuringDistance;}

void LinearVariableDifferentialTransformerSensorType::setMaxMeasuringDistance(LinearValueType * MaxMeasuringDistanceIn)
{MaxMeasuringDistance = MaxMeasuringDistanceIn;}

UserDefinedUnitValueType * LinearVariableDifferentialTransformerSensorType::getTemperatureStability()
{return TemperatureStability;}

void LinearVariableDifferentialTransformerSensorType::setTemperatureStability(UserDefinedUnitValueType * TemperatureStabilityIn)
{TemperatureStability = TemperatureStabilityIn;}

UserDefinedUnitValueType * LinearVariableDifferentialTransformerSensorType::getExcitationFrequency()
{return ExcitationFrequency;}

void LinearVariableDifferentialTransformerSensorType::setExcitationFrequency(UserDefinedUnitValueType * ExcitationFrequencyIn)
{ExcitationFrequency = ExcitationFrequencyIn;}

UserDefinedUnitValueType * LinearVariableDifferentialTransformerSensorType::getExcitationAmplitude()
{return ExcitationAmplitude;}

void LinearVariableDifferentialTransformerSensorType::setExcitationAmplitude(UserDefinedUnitValueType * ExcitationAmplitudeIn)
{ExcitationAmplitude = ExcitationAmplitudeIn;}

LinearValueType * LinearVariableDifferentialTransformerSensorType::getDiameter()
{return Diameter;}

void LinearVariableDifferentialTransformerSensorType::setDiameter(LinearValueType * DiameterIn)
{Diameter = DiameterIn;}

UserDefinedUnitValueType * LinearVariableDifferentialTransformerSensorType::getShockTolerance()
{return ShockTolerance;}

void LinearVariableDifferentialTransformerSensorType::setShockTolerance(UserDefinedUnitValueType * ShockToleranceIn)
{ShockTolerance = ShockToleranceIn;}

UserDefinedUnitValueType * LinearVariableDifferentialTransformerSensorType::getVibrationTolerance()
{return VibrationTolerance;}

void LinearVariableDifferentialTransformerSensorType::setVibrationTolerance(UserDefinedUnitValueType * VibrationToleranceIn)
{VibrationTolerance = VibrationToleranceIn;}

XmlString * LinearVariableDifferentialTransformerSensorType::getHousingMaterial()
{return HousingMaterial;}

void LinearVariableDifferentialTransformerSensorType::setHousingMaterial(XmlString * HousingMaterialIn)
{HousingMaterial = HousingMaterialIn;}

XmlString * LinearVariableDifferentialTransformerSensorType::getElectronicDescription()
{return ElectronicDescription;}

void LinearVariableDifferentialTransformerSensorType::setElectronicDescription(XmlString * ElectronicDescriptionIn)
{ElectronicDescription = ElectronicDescriptionIn;}

/* ***************************************************************** */

/* class LocatedTipType

*/

LocatedTipType::LocatedTipType()
{
  ProbeTip = 0;
  TipEndLocation = 0;
}

LocatedTipType::LocatedTipType(
 ProbeTipType * ProbeTipIn,
 PointType * TipEndLocationIn)
{
  ProbeTip = ProbeTipIn;
  TipEndLocation = TipEndLocationIn;
}

LocatedTipType::~LocatedTipType()
{
  #ifndef NODESTRUCT
  delete ProbeTip;
  delete TipEndLocation;
  #endif
}

void LocatedTipType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<ProbeTip");
  ProbeTip->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ProbeTip>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<TipEndLocation");
  TipEndLocation->printSelf(outFile);
  fprintf(outFile, "</TipEndLocation>\n");
  doSpaces(-INDENT, outFile);
}

ProbeTipType * LocatedTipType::getProbeTip()
{return ProbeTip;}

void LocatedTipType::setProbeTip(ProbeTipType * ProbeTipIn)
{ProbeTip = ProbeTipIn;}

PointType * LocatedTipType::getTipEndLocation()
{return TipEndLocation;}

void LocatedTipType::setTipEndLocation(PointType * TipEndLocationIn)
{TipEndLocation = TipEndLocationIn;}

/* ***************************************************************** */

/* class LocatedTipTypeLisd

*/

LocatedTipTypeLisd::LocatedTipTypeLisd() {}

LocatedTipTypeLisd::LocatedTipTypeLisd(LocatedTipType * aLocatedTipType)
{
  push_back(aLocatedTipType);
}

LocatedTipTypeLisd::~LocatedTipTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<LocatedTipType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void LocatedTipTypeLisd::printSelf(FILE * outFile)
{
  std::list<LocatedTipType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class LocatedTipsType

*/

LocatedTipsType::LocatedTipsType()
{
  n = 0;
  LocatedTip = 0;
}

LocatedTipsType::LocatedTipsType(
 LocatedTipTypeLisd * LocatedTipIn)
{
  n = 0;
  LocatedTip = LocatedTipIn;
}

LocatedTipsType::LocatedTipsType(
 NaturalType * nIn,
 LocatedTipTypeLisd * LocatedTipIn)
{
  n = nIn;
  LocatedTip = LocatedTipIn;
}

LocatedTipsType::~LocatedTipsType()
{
  #ifndef NODESTRUCT
  delete n;
  delete LocatedTip;
  #endif
}

void LocatedTipsType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!LocatedTip)
      {
        fprintf(stderr, "LocatedTip list is missing\n");
        exit(1);
      }
    if (LocatedTip->size() == 0)
      {
        fprintf(stderr, "LocatedTip list is empty\n");
        exit(1);
      }
    if (LocatedTip->size() < 1)
      {
        fprintf(stderr,
                "size of LocatedTip list (%d) less than minimum required (1)\n",
                (int)LocatedTip->size());
        exit(1);
      }
    std::list<LocatedTipType *>::iterator iter;
    for (iter = LocatedTip->begin();
         iter != LocatedTip->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<LocatedTip");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</LocatedTip>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool LocatedTipsType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in LocatedTipsType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in LocatedTipsType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in LocatedTipsType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in LocatedTipsType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * LocatedTipsType::getn()
{return n;}

void LocatedTipsType::setn(NaturalType * nIn)
{n = nIn;}

LocatedTipTypeLisd * LocatedTipsType::getLocatedTip()
{return LocatedTip;}

void LocatedTipsType::setLocatedTip(LocatedTipTypeLisd * LocatedTipIn)
{LocatedTip = LocatedTipIn;}

/* ***************************************************************** */

/* class MagnetoInductiveSensorType

*/

MagnetoInductiveSensorType::MagnetoInductiveSensorType() :
  SensorType()
{
  MinMeasuringDistance = 0;
  MaxMeasuringDistance = 0;
  FrequencyResponse = 0;
  OffsetDistance = 0;
  MaxPressure = 0;
  ShockTolerance = 0;
  VibrationTolerance = 0;
  HousingMaterial = 0;
  MaxCurrentConsumption = 0;
  MinPowerSupplyVoltage = 0;
  MaxPowerSupplyVoltage = 0;
}

MagnetoInductiveSensorType::MagnetoInductiveSensorType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 XmlString * ProtectionClassIn,
 XmlString * LinearityErrorIn,
 LinearValueType * RepeatabilityIn,
 XmlDecimal * SensitivityIn,
 LinearValueType * ResolutionIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 UserDefinedUnitValueType * FrequencyResponseIn,
 LinearValueType * OffsetDistanceIn,
 PressureValueType * MaxPressureIn,
 UserDefinedUnitValueType * ShockToleranceIn,
 UserDefinedUnitValueType * VibrationToleranceIn,
 XmlString * HousingMaterialIn,
 UserDefinedUnitValueType * MaxCurrentConsumptionIn,
 UserDefinedUnitValueType * MinPowerSupplyVoltageIn,
 UserDefinedUnitValueType * MaxPowerSupplyVoltageIn) :
  SensorType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    ProtectionClassIn,
    LinearityErrorIn,
    RepeatabilityIn,
    SensitivityIn,
    ResolutionIn,
    EnvironmentalRangeIn)
{
  MinMeasuringDistance = MinMeasuringDistanceIn;
  MaxMeasuringDistance = MaxMeasuringDistanceIn;
  FrequencyResponse = FrequencyResponseIn;
  OffsetDistance = OffsetDistanceIn;
  MaxPressure = MaxPressureIn;
  ShockTolerance = ShockToleranceIn;
  VibrationTolerance = VibrationToleranceIn;
  HousingMaterial = HousingMaterialIn;
  MaxCurrentConsumption = MaxCurrentConsumptionIn;
  MinPowerSupplyVoltage = MinPowerSupplyVoltageIn;
  MaxPowerSupplyVoltage = MaxPowerSupplyVoltageIn;
}

MagnetoInductiveSensorType::MagnetoInductiveSensorType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 XmlString * ProtectionClassIn,
 XmlString * LinearityErrorIn,
 LinearValueType * RepeatabilityIn,
 XmlDecimal * SensitivityIn,
 LinearValueType * ResolutionIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 UserDefinedUnitValueType * FrequencyResponseIn,
 LinearValueType * OffsetDistanceIn,
 PressureValueType * MaxPressureIn,
 UserDefinedUnitValueType * ShockToleranceIn,
 UserDefinedUnitValueType * VibrationToleranceIn,
 XmlString * HousingMaterialIn,
 UserDefinedUnitValueType * MaxCurrentConsumptionIn,
 UserDefinedUnitValueType * MinPowerSupplyVoltageIn,
 UserDefinedUnitValueType * MaxPowerSupplyVoltageIn) :
  SensorType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    ProtectionClassIn,
    LinearityErrorIn,
    RepeatabilityIn,
    SensitivityIn,
    ResolutionIn,
    EnvironmentalRangeIn)
{
  MinMeasuringDistance = MinMeasuringDistanceIn;
  MaxMeasuringDistance = MaxMeasuringDistanceIn;
  FrequencyResponse = FrequencyResponseIn;
  OffsetDistance = OffsetDistanceIn;
  MaxPressure = MaxPressureIn;
  ShockTolerance = ShockToleranceIn;
  VibrationTolerance = VibrationToleranceIn;
  HousingMaterial = HousingMaterialIn;
  MaxCurrentConsumption = MaxCurrentConsumptionIn;
  MinPowerSupplyVoltage = MinPowerSupplyVoltageIn;
  MaxPowerSupplyVoltage = MaxPowerSupplyVoltageIn;
}

MagnetoInductiveSensorType::~MagnetoInductiveSensorType()
{
  #ifndef NODESTRUCT
  delete MinMeasuringDistance;
  delete MaxMeasuringDistance;
  delete FrequencyResponse;
  delete OffsetDistance;
  delete MaxPressure;
  delete ShockTolerance;
  delete VibrationTolerance;
  delete HousingMaterial;
  delete MaxCurrentConsumption;
  delete MinPowerSupplyVoltage;
  delete MaxPowerSupplyVoltage;
  #endif
}

void MagnetoInductiveSensorType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (ProtectionClass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProtectionClass");
      ProtectionClass->printSelf(outFile);
      fprintf(outFile, "</ProtectionClass>\n");
    }
  if (LinearityError)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LinearityError");
      LinearityError->printSelf(outFile);
      fprintf(outFile, "</LinearityError>\n");
    }
  if (Repeatability)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Repeatability");
      Repeatability->printSelf(outFile);
      fprintf(outFile, "</Repeatability>\n");
    }
  if (Sensitivity)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Sensitivity");
      Sensitivity->printSelf(outFile);
      fprintf(outFile, "</Sensitivity>\n");
    }
  if (Resolution)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Resolution");
      Resolution->printSelf(outFile);
      fprintf(outFile, "</Resolution>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (MinMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinMeasuringDistance");
      MinMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MinMeasuringDistance>\n");
    }
  if (MaxMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxMeasuringDistance");
      MaxMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MaxMeasuringDistance>\n");
    }
  if (FrequencyResponse)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FrequencyResponse");
      FrequencyResponse->printSelf(outFile);
      fprintf(outFile, "</FrequencyResponse>\n");
    }
  if (OffsetDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OffsetDistance");
      OffsetDistance->printSelf(outFile);
      fprintf(outFile, "</OffsetDistance>\n");
    }
  if (MaxPressure)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxPressure");
      MaxPressure->printSelf(outFile);
      fprintf(outFile, "</MaxPressure>\n");
    }
  if (ShockTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ShockTolerance");
      ShockTolerance->printSelf(outFile);
      fprintf(outFile, "</ShockTolerance>\n");
    }
  if (VibrationTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VibrationTolerance");
      VibrationTolerance->printSelf(outFile);
      fprintf(outFile, "</VibrationTolerance>\n");
    }
  if (HousingMaterial)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<HousingMaterial");
      HousingMaterial->printSelf(outFile);
      fprintf(outFile, "</HousingMaterial>\n");
    }
  if (MaxCurrentConsumption)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxCurrentConsumption");
      MaxCurrentConsumption->printSelf(outFile);
      fprintf(outFile, "</MaxCurrentConsumption>\n");
    }
  if (MinPowerSupplyVoltage)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinPowerSupplyVoltage");
      MinPowerSupplyVoltage->printSelf(outFile);
      fprintf(outFile, "</MinPowerSupplyVoltage>\n");
    }
  if (MaxPowerSupplyVoltage)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxPowerSupplyVoltage");
      MaxPowerSupplyVoltage->printSelf(outFile);
      fprintf(outFile, "</MaxPowerSupplyVoltage>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool MagnetoInductiveSensorType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in MagnetoInductiveSensorType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in MagnetoInductiveSensorType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in MagnetoInductiveSensorType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in MagnetoInductiveSensorType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LinearValueType * MagnetoInductiveSensorType::getMinMeasuringDistance()
{return MinMeasuringDistance;}

void MagnetoInductiveSensorType::setMinMeasuringDistance(LinearValueType * MinMeasuringDistanceIn)
{MinMeasuringDistance = MinMeasuringDistanceIn;}

LinearValueType * MagnetoInductiveSensorType::getMaxMeasuringDistance()
{return MaxMeasuringDistance;}

void MagnetoInductiveSensorType::setMaxMeasuringDistance(LinearValueType * MaxMeasuringDistanceIn)
{MaxMeasuringDistance = MaxMeasuringDistanceIn;}

UserDefinedUnitValueType * MagnetoInductiveSensorType::getFrequencyResponse()
{return FrequencyResponse;}

void MagnetoInductiveSensorType::setFrequencyResponse(UserDefinedUnitValueType * FrequencyResponseIn)
{FrequencyResponse = FrequencyResponseIn;}

LinearValueType * MagnetoInductiveSensorType::getOffsetDistance()
{return OffsetDistance;}

void MagnetoInductiveSensorType::setOffsetDistance(LinearValueType * OffsetDistanceIn)
{OffsetDistance = OffsetDistanceIn;}

PressureValueType * MagnetoInductiveSensorType::getMaxPressure()
{return MaxPressure;}

void MagnetoInductiveSensorType::setMaxPressure(PressureValueType * MaxPressureIn)
{MaxPressure = MaxPressureIn;}

UserDefinedUnitValueType * MagnetoInductiveSensorType::getShockTolerance()
{return ShockTolerance;}

void MagnetoInductiveSensorType::setShockTolerance(UserDefinedUnitValueType * ShockToleranceIn)
{ShockTolerance = ShockToleranceIn;}

UserDefinedUnitValueType * MagnetoInductiveSensorType::getVibrationTolerance()
{return VibrationTolerance;}

void MagnetoInductiveSensorType::setVibrationTolerance(UserDefinedUnitValueType * VibrationToleranceIn)
{VibrationTolerance = VibrationToleranceIn;}

XmlString * MagnetoInductiveSensorType::getHousingMaterial()
{return HousingMaterial;}

void MagnetoInductiveSensorType::setHousingMaterial(XmlString * HousingMaterialIn)
{HousingMaterial = HousingMaterialIn;}

UserDefinedUnitValueType * MagnetoInductiveSensorType::getMaxCurrentConsumption()
{return MaxCurrentConsumption;}

void MagnetoInductiveSensorType::setMaxCurrentConsumption(UserDefinedUnitValueType * MaxCurrentConsumptionIn)
{MaxCurrentConsumption = MaxCurrentConsumptionIn;}

UserDefinedUnitValueType * MagnetoInductiveSensorType::getMinPowerSupplyVoltage()
{return MinPowerSupplyVoltage;}

void MagnetoInductiveSensorType::setMinPowerSupplyVoltage(UserDefinedUnitValueType * MinPowerSupplyVoltageIn)
{MinPowerSupplyVoltage = MinPowerSupplyVoltageIn;}

UserDefinedUnitValueType * MagnetoInductiveSensorType::getMaxPowerSupplyVoltage()
{return MaxPowerSupplyVoltage;}

void MagnetoInductiveSensorType::setMaxPowerSupplyVoltage(UserDefinedUnitValueType * MaxPowerSupplyVoltageIn)
{MaxPowerSupplyVoltage = MaxPowerSupplyVoltageIn;}

/* ***************************************************************** */

/* class ManualMeasurementDeviceType

*/

ManualMeasurementDeviceType::ManualMeasurementDeviceType() :
  MeasurementDeviceType()
{
  MinMeasuringDistance = 0;
  MaxMeasuringDistance = 0;
}

ManualMeasurementDeviceType::ManualMeasurementDeviceType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn) :
  MeasurementDeviceType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn)
{
  MinMeasuringDistance = MinMeasuringDistanceIn;
  MaxMeasuringDistance = MaxMeasuringDistanceIn;
}

ManualMeasurementDeviceType::ManualMeasurementDeviceType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn) :
  MeasurementDeviceType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn)
{
  MinMeasuringDistance = MinMeasuringDistanceIn;
  MaxMeasuringDistance = MaxMeasuringDistanceIn;
}

ManualMeasurementDeviceType::~ManualMeasurementDeviceType()
{
  #ifndef NODESTRUCT
  delete MinMeasuringDistance;
  delete MaxMeasuringDistance;
  #endif
}

void ManualMeasurementDeviceType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Calibrations)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Calibrations");
      Calibrations->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Calibrations>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (MinMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinMeasuringDistance");
      MinMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MinMeasuringDistance>\n");
    }
  if (MaxMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxMeasuringDistance");
      MaxMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MaxMeasuringDistance>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ManualMeasurementDeviceType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ManualMeasurementDeviceType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ManualMeasurementDeviceType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ManualMeasurementDeviceType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ManualMeasurementDeviceType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LinearValueType * ManualMeasurementDeviceType::getMinMeasuringDistance()
{return MinMeasuringDistance;}

void ManualMeasurementDeviceType::setMinMeasuringDistance(LinearValueType * MinMeasuringDistanceIn)
{MinMeasuringDistance = MinMeasuringDistanceIn;}

LinearValueType * ManualMeasurementDeviceType::getMaxMeasuringDistance()
{return MaxMeasuringDistance;}

void ManualMeasurementDeviceType::setMaxMeasuringDistance(LinearValueType * MaxMeasuringDistanceIn)
{MaxMeasuringDistance = MaxMeasuringDistanceIn;}

/* ***************************************************************** */

/* class MeasurementDeviceAccuracyBaseType

*/

MeasurementDeviceAccuracyBaseType::MeasurementDeviceAccuracyBaseType()
{
  EnvironmentalRange = 0;
}

MeasurementDeviceAccuracyBaseType::MeasurementDeviceAccuracyBaseType(
 EnvironmentalRangeType * EnvironmentalRangeIn)
{
  EnvironmentalRange = EnvironmentalRangeIn;
}

MeasurementDeviceAccuracyBaseType::~MeasurementDeviceAccuracyBaseType()
{
  #ifndef NODESTRUCT
  delete EnvironmentalRange;
  #endif
}

void MeasurementDeviceAccuracyBaseType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<EnvironmentalRange");
  EnvironmentalRange->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</EnvironmentalRange>\n");
  doSpaces(-INDENT, outFile);
}

EnvironmentalRangeType * MeasurementDeviceAccuracyBaseType::getEnvironmentalRange()
{return EnvironmentalRange;}

void MeasurementDeviceAccuracyBaseType::setEnvironmentalRange(EnvironmentalRangeType * EnvironmentalRangeIn)
{EnvironmentalRange = EnvironmentalRangeIn;}

/* ***************************************************************** */

/* class MeasurementDeviceScaleType

*/

MeasurementDeviceScaleType::MeasurementDeviceScaleType()
{
  ScaleMaterial = 0;
  ScaleCoefficientOfExpansion = 0;
  ScaleCoefficientOfExpansionUncertainty = 0;
  TypeOfScale = 0;
  ScaleResolution = 0;
  ScaleReference = 0;
}

MeasurementDeviceScaleType::MeasurementDeviceScaleType(
 XmlString * ScaleMaterialIn,
 XmlDecimal * ScaleCoefficientOfExpansionIn,
 XmlDecimal * ScaleCoefficientOfExpansionUncertaintyIn,
 TypeOfScaleType * TypeOfScaleIn,
 LinearValueType * ScaleResolutionIn,
 ScaleReferenceEnumType * ScaleReferenceIn)
{
  ScaleMaterial = ScaleMaterialIn;
  ScaleCoefficientOfExpansion = ScaleCoefficientOfExpansionIn;
  ScaleCoefficientOfExpansionUncertainty = ScaleCoefficientOfExpansionUncertaintyIn;
  TypeOfScale = TypeOfScaleIn;
  ScaleResolution = ScaleResolutionIn;
  ScaleReference = ScaleReferenceIn;
}

MeasurementDeviceScaleType::~MeasurementDeviceScaleType()
{
  #ifndef NODESTRUCT
  delete ScaleMaterial;
  delete ScaleCoefficientOfExpansion;
  delete ScaleCoefficientOfExpansionUncertainty;
  delete TypeOfScale;
  delete ScaleResolution;
  delete ScaleReference;
  #endif
}

void MeasurementDeviceScaleType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (ScaleMaterial)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ScaleMaterial");
      ScaleMaterial->printSelf(outFile);
      fprintf(outFile, "</ScaleMaterial>\n");
    }
  if (ScaleCoefficientOfExpansion)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ScaleCoefficientOfExpansion");
      ScaleCoefficientOfExpansion->printSelf(outFile);
      fprintf(outFile, "</ScaleCoefficientOfExpansion>\n");
    }
  if (ScaleCoefficientOfExpansionUncertainty)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ScaleCoefficientOfExpansionUncertainty");
      ScaleCoefficientOfExpansionUncertainty->printSelf(outFile);
      fprintf(outFile, "</ScaleCoefficientOfExpansionUncertainty>\n");
    }
  if (TypeOfScale)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TypeOfScale");
      TypeOfScale->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</TypeOfScale>\n");
    }
  if (ScaleResolution)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ScaleResolution");
      ScaleResolution->printSelf(outFile);
      fprintf(outFile, "</ScaleResolution>\n");
    }
  if (ScaleReference)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ScaleReference");
      ScaleReference->printSelf(outFile);
      fprintf(outFile, "</ScaleReference>\n");
    }
  doSpaces(-INDENT, outFile);
}

XmlString * MeasurementDeviceScaleType::getScaleMaterial()
{return ScaleMaterial;}

void MeasurementDeviceScaleType::setScaleMaterial(XmlString * ScaleMaterialIn)
{ScaleMaterial = ScaleMaterialIn;}

XmlDecimal * MeasurementDeviceScaleType::getScaleCoefficientOfExpansion()
{return ScaleCoefficientOfExpansion;}

void MeasurementDeviceScaleType::setScaleCoefficientOfExpansion(XmlDecimal * ScaleCoefficientOfExpansionIn)
{ScaleCoefficientOfExpansion = ScaleCoefficientOfExpansionIn;}

XmlDecimal * MeasurementDeviceScaleType::getScaleCoefficientOfExpansionUncertainty()
{return ScaleCoefficientOfExpansionUncertainty;}

void MeasurementDeviceScaleType::setScaleCoefficientOfExpansionUncertainty(XmlDecimal * ScaleCoefficientOfExpansionUncertaintyIn)
{ScaleCoefficientOfExpansionUncertainty = ScaleCoefficientOfExpansionUncertaintyIn;}

TypeOfScaleType * MeasurementDeviceScaleType::getTypeOfScale()
{return TypeOfScale;}

void MeasurementDeviceScaleType::setTypeOfScale(TypeOfScaleType * TypeOfScaleIn)
{TypeOfScale = TypeOfScaleIn;}

LinearValueType * MeasurementDeviceScaleType::getScaleResolution()
{return ScaleResolution;}

void MeasurementDeviceScaleType::setScaleResolution(LinearValueType * ScaleResolutionIn)
{ScaleResolution = ScaleResolutionIn;}

ScaleReferenceEnumType * MeasurementDeviceScaleType::getScaleReference()
{return ScaleReference;}

void MeasurementDeviceScaleType::setScaleReference(ScaleReferenceEnumType * ScaleReferenceIn)
{ScaleReference = ScaleReferenceIn;}

/* ***************************************************************** */

/* class MeasurementDeviceScalesBaseType

*/

MeasurementDeviceScalesBaseType::MeasurementDeviceScalesBaseType()
{}

MeasurementDeviceScalesBaseType::~MeasurementDeviceScalesBaseType() {}

void MeasurementDeviceScalesBaseType::printSelf(FILE * outFile)
{
  fprintf(outFile, "/>\n");
}

/* ***************************************************************** */

/* class MeasurementDeviceType

*/

MeasurementDeviceType::MeasurementDeviceType() :
  MeasurementResourceBaseType()
{
  Calibrations = 0;
  EnvironmentalRange = 0;
}

MeasurementDeviceType::MeasurementDeviceType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn) :
  MeasurementResourceBaseType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  Calibrations = CalibrationsIn;
  EnvironmentalRange = EnvironmentalRangeIn;
}

MeasurementDeviceType::MeasurementDeviceType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn) :
  MeasurementResourceBaseType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  Calibrations = CalibrationsIn;
  EnvironmentalRange = EnvironmentalRangeIn;
}

MeasurementDeviceType::~MeasurementDeviceType()
{
  #ifndef NODESTRUCT
  delete Calibrations;
  delete EnvironmentalRange;
  #endif
}

void MeasurementDeviceType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Calibrations)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Calibrations");
      Calibrations->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Calibrations>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool MeasurementDeviceType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in MeasurementDeviceType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in MeasurementDeviceType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in MeasurementDeviceType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in MeasurementDeviceType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

CalibrationsType * MeasurementDeviceType::getCalibrations()
{return Calibrations;}

void MeasurementDeviceType::setCalibrations(CalibrationsType * CalibrationsIn)
{Calibrations = CalibrationsIn;}

EnvironmentalRangeType * MeasurementDeviceType::getEnvironmentalRange()
{return EnvironmentalRange;}

void MeasurementDeviceType::setEnvironmentalRange(EnvironmentalRangeType * EnvironmentalRangeIn)
{EnvironmentalRange = EnvironmentalRangeIn;}

/* ***************************************************************** */

/* class MeasurementDeviceTypeLisd

*/

MeasurementDeviceTypeLisd::MeasurementDeviceTypeLisd() {}

MeasurementDeviceTypeLisd::MeasurementDeviceTypeLisd(MeasurementDeviceType * aMeasurementDeviceType)
{
  push_back(aMeasurementDeviceType);
}

MeasurementDeviceTypeLisd::~MeasurementDeviceTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<MeasurementDeviceType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void MeasurementDeviceTypeLisd::printSelf(FILE * outFile)
{
  std::list<MeasurementDeviceType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class MeasurementDevicesType

*/

MeasurementDevicesType::MeasurementDevicesType()
{
  n = 0;
  MeasurementDevice = 0;
}

MeasurementDevicesType::MeasurementDevicesType(
 MeasurementDeviceTypeLisd * MeasurementDeviceIn)
{
  n = 0;
  MeasurementDevice = MeasurementDeviceIn;
}

MeasurementDevicesType::MeasurementDevicesType(
 NaturalType * nIn,
 MeasurementDeviceTypeLisd * MeasurementDeviceIn)
{
  n = nIn;
  MeasurementDevice = MeasurementDeviceIn;
}

MeasurementDevicesType::~MeasurementDevicesType()
{
  #ifndef NODESTRUCT
  delete n;
  delete MeasurementDevice;
  #endif
}

void MeasurementDevicesType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!MeasurementDevice)
      {
        fprintf(stderr, "MeasurementDevice list is missing\n");
        exit(1);
      }
    if (MeasurementDevice->size() == 0)
      {
        fprintf(stderr, "MeasurementDevice list is empty\n");
        exit(1);
      }
    if (MeasurementDevice->size() < 1)
      {
        fprintf(stderr,
                "size of MeasurementDevice list (%d) less than minimum required (1)\n",
                (int)MeasurementDevice->size());
        exit(1);
      }
    std::list<MeasurementDeviceType *>::iterator iter;
    for (iter = MeasurementDevice->begin();
         iter != MeasurementDevice->end(); iter++)
      {
        MeasurementDeviceType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->getprintElement(), "CMM") == 0)
          {
            CMMType * typ;
            if ((typ = dynamic_cast<CMMType *>(basie)))
              {
                fprintf(outFile, "<CMM");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CMM>\n");
              }
            else
              {
                fprintf(stderr, "bad CMM element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ManualMeasurementDevice") == 0)
          {
            ManualMeasurementDeviceType * typ;
            if ((typ = dynamic_cast<ManualMeasurementDeviceType *>(basie)))
              {
                fprintf(outFile, "<ManualMeasurementDevice");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ManualMeasurementDevice>\n");
              }
            else
              {
                fprintf(stderr, "bad ManualMeasurementDevice element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "Microscope") == 0)
          {
            MicroscopeType * typ;
            if ((typ = dynamic_cast<MicroscopeType *>(basie)))
              {
                fprintf(outFile, "<Microscope");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Microscope>\n");
              }
            else
              {
                fprintf(stderr, "bad Microscope element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "Autocollimator") == 0)
          {
            AutocollimatorType * typ;
            if ((typ = dynamic_cast<AutocollimatorType *>(basie)))
              {
                fprintf(outFile, "<Autocollimator");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Autocollimator>\n");
              }
            else
              {
                fprintf(stderr, "bad Autocollimator element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "OpticalComparator") == 0)
          {
            OpticalComparatorType * typ;
            if ((typ = dynamic_cast<OpticalComparatorType *>(basie)))
              {
                fprintf(outFile, "<OpticalComparator");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OpticalComparator>\n");
              }
            else
              {
                fprintf(stderr, "bad OpticalComparator element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "UniversalLengthMeasuring") == 0)
          {
            UniversalLengthMeasuringType * typ;
            if ((typ = dynamic_cast<UniversalLengthMeasuringType *>(basie)))
              {
                fprintf(outFile, "<UniversalLengthMeasuring");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UniversalLengthMeasuring>\n");
              }
            else
              {
                fprintf(stderr, "bad UniversalLengthMeasuring element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "LaserRadar") == 0)
          {
            LaserRadarType * typ;
            if ((typ = dynamic_cast<LaserRadarType *>(basie)))
              {
                fprintf(outFile, "<LaserRadar");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LaserRadar>\n");
              }
            else
              {
                fprintf(stderr, "bad LaserRadar element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "LaserTracker") == 0)
          {
            LaserTrackerType * typ;
            if ((typ = dynamic_cast<LaserTrackerType *>(basie)))
              {
                fprintf(outFile, "<LaserTracker");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LaserTracker>\n");
              }
            else
              {
                fprintf(stderr, "bad LaserTracker element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ComputedTomography") == 0)
          {
            ComputedTomographyType * typ;
            if ((typ = dynamic_cast<ComputedTomographyType *>(basie)))
              {
                fprintf(outFile, "<ComputedTomography");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ComputedTomography>\n");
              }
            else
              {
                fprintf(stderr, "bad ComputedTomography element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "Theodolite") == 0)
          {
            TheodoliteType * typ;
            if ((typ = dynamic_cast<TheodoliteType *>(basie)))
              {
                fprintf(outFile, "<Theodolite");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Theodolite>\n");
              }
            else
              {
                fprintf(stderr, "bad Theodolite element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "AACMM") == 0)
          {
            AACMMType * typ;
            if ((typ = dynamic_cast<AACMMType *>(basie)))
              {
                fprintf(outFile, "<AACMM");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AACMM>\n");
              }
            else
              {
                fprintf(stderr, "bad AACMM element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CartesianCMM") == 0)
          {
            CartesianCMMType * typ;
            if ((typ = dynamic_cast<CartesianCMMType *>(basie)))
              {
                fprintf(outFile, "<CartesianCMM");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianCMM>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianCMM element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "MultipleCarriageCartesianCMM") == 0)
          {
            MultipleCarriageCartesianCMMType * typ;
            if ((typ = dynamic_cast<MultipleCarriageCartesianCMMType *>(basie)))
              {
                fprintf(outFile, "<MultipleCarriageCartesianCMM");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</MultipleCarriageCartesianCMM>\n");
              }
            else
              {
                fprintf(stderr, "bad MultipleCarriageCartesianCMM element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ParallelLinkCMM") == 0)
          {
            ParallelLinkCMMType * typ;
            if ((typ = dynamic_cast<ParallelLinkCMMType *>(basie)))
              {
                fprintf(outFile, "<ParallelLinkCMM");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ParallelLinkCMM>\n");
              }
            else
              {
                fprintf(stderr, "bad ParallelLinkCMM element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "LightPenCMM") == 0)
          {
            LightPenCMMType * typ;
            if ((typ = dynamic_cast<LightPenCMMType *>(basie)))
              {
                fprintf(outFile, "<LightPenCMM");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LightPenCMM>\n");
              }
            else
              {
                fprintf(stderr, "bad LightPenCMM element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "Caliper") == 0)
          {
            CaliperType * typ;
            if ((typ = dynamic_cast<CaliperType *>(basie)))
              {
                fprintf(outFile, "<Caliper");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Caliper>\n");
              }
            else
              {
                fprintf(stderr, "bad Caliper element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CaliperDial") == 0)
          {
            CaliperDialType * typ;
            if ((typ = dynamic_cast<CaliperDialType *>(basie)))
              {
                fprintf(outFile, "<CaliperDial");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CaliperDial>\n");
              }
            else
              {
                fprintf(stderr, "bad CaliperDial element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "CaliperDigital") == 0)
          {
            CaliperDigitalType * typ;
            if ((typ = dynamic_cast<CaliperDigitalType *>(basie)))
              {
                fprintf(outFile, "<CaliperDigital");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CaliperDigital>\n");
              }
            else
              {
                fprintf(stderr, "bad CaliperDigital element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "GageDevice") == 0)
          {
            GageDeviceType * typ;
            if ((typ = dynamic_cast<GageDeviceType *>(basie)))
              {
                fprintf(outFile, "<GageDevice");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GageDevice>\n");
              }
            else
              {
                fprintf(stderr, "bad GageDevice element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "Micrometer") == 0)
          {
            MicrometerType * typ;
            if ((typ = dynamic_cast<MicrometerType *>(basie)))
              {
                fprintf(outFile, "<Micrometer");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Micrometer>\n");
              }
            else
              {
                fprintf(stderr, "bad Micrometer element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "MicrometerAnalog") == 0)
          {
            MicrometerAnalogType * typ;
            if ((typ = dynamic_cast<MicrometerAnalogType *>(basie)))
              {
                fprintf(outFile, "<MicrometerAnalog");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</MicrometerAnalog>\n");
              }
            else
              {
                fprintf(stderr, "bad MicrometerAnalog element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "MicrometerDigital") == 0)
          {
            MicrometerDigitalType * typ;
            if ((typ = dynamic_cast<MicrometerDigitalType *>(basie)))
              {
                fprintf(outFile, "<MicrometerDigital");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</MicrometerDigital>\n");
              }
            else
              {
                fprintf(stderr, "bad MicrometerDigital element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "SineBar") == 0)
          {
            SineBarType * typ;
            if ((typ = dynamic_cast<SineBarType *>(basie)))
              {
                fprintf(outFile, "<SineBar");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SineBar>\n");
              }
            else
              {
                fprintf(stderr, "bad SineBar element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "MeasurementDevice") == 0)
          {
            MeasurementDeviceType * typ;
            if ((typ = dynamic_cast<MeasurementDeviceType *>(basie)))
              {
                fprintf(outFile, "<MeasurementDevice");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</MeasurementDevice>\n");
              }
            else
              {
                fprintf(stderr, "bad MeasurementDevice element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad MeasurementDevice type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool MeasurementDevicesType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in MeasurementDevicesType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in MeasurementDevicesType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in MeasurementDevicesType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in MeasurementDevicesType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * MeasurementDevicesType::getn()
{return n;}

void MeasurementDevicesType::setn(NaturalType * nIn)
{n = nIn;}

MeasurementDeviceTypeLisd * MeasurementDevicesType::getMeasurementDevice()
{return MeasurementDevice;}

void MeasurementDevicesType::setMeasurementDevice(MeasurementDeviceTypeLisd * MeasurementDeviceIn)
{MeasurementDevice = MeasurementDeviceIn;}

/* ***************************************************************** */

/* class MeasurementResourceBaseType

*/

MeasurementResourceBaseType::MeasurementResourceBaseType()
{
  id = 0;
  Name = 0;
  Description = 0;
  Manufacturer = 0;
  ModelNumber = 0;
  SerialNumber = 0;
  Mass = 0;
  Size = 0;
  MeasurementReso_1196 = 0;
  Attributes = 0;
}

MeasurementResourceBaseType::MeasurementResourceBaseType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn)
{
  id = 0;
  Name = NameIn;
  Description = DescriptionIn;
  Manufacturer = ManufacturerIn;
  ModelNumber = ModelNumberIn;
  SerialNumber = SerialNumberIn;
  Mass = MassIn;
  Size = SizeIn;
  MeasurementReso_1196 = MeasurementReso_1196In;
  Attributes = AttributesIn;
}

MeasurementResourceBaseType::MeasurementResourceBaseType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn)
{
  id = idIn;
  Name = NameIn;
  Description = DescriptionIn;
  Manufacturer = ManufacturerIn;
  ModelNumber = ModelNumberIn;
  SerialNumber = SerialNumberIn;
  Mass = MassIn;
  Size = SizeIn;
  MeasurementReso_1196 = MeasurementReso_1196In;
  Attributes = AttributesIn;
}

MeasurementResourceBaseType::~MeasurementResourceBaseType()
{
  #ifndef NODESTRUCT
  delete id;
  delete Name;
  delete Description;
  delete Manufacturer;
  delete ModelNumber;
  delete SerialNumber;
  delete Mass;
  delete Size;
  delete MeasurementReso_1196;
  delete Attributes;
  #endif
}

void MeasurementResourceBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool MeasurementResourceBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in MeasurementResourceBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in MeasurementResourceBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in MeasurementResourceBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in MeasurementResourceBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

QIFIdType * MeasurementResourceBaseType::getid()
{return id;}

void MeasurementResourceBaseType::setid(QIFIdType * idIn)
{id = idIn;}

XmlToken * MeasurementResourceBaseType::getName()
{return Name;}

void MeasurementResourceBaseType::setName(XmlToken * NameIn)
{Name = NameIn;}

XmlString * MeasurementResourceBaseType::getDescription()
{return Description;}

void MeasurementResourceBaseType::setDescription(XmlString * DescriptionIn)
{Description = DescriptionIn;}

XmlString * MeasurementResourceBaseType::getManufacturer()
{return Manufacturer;}

void MeasurementResourceBaseType::setManufacturer(XmlString * ManufacturerIn)
{Manufacturer = ManufacturerIn;}

XmlString * MeasurementResourceBaseType::getModelNumber()
{return ModelNumber;}

void MeasurementResourceBaseType::setModelNumber(XmlString * ModelNumberIn)
{ModelNumber = ModelNumberIn;}

XmlString * MeasurementResourceBaseType::getSerialNumber()
{return SerialNumber;}

void MeasurementResourceBaseType::setSerialNumber(XmlString * SerialNumberIn)
{SerialNumber = SerialNumberIn;}

MassValueType * MeasurementResourceBaseType::getMass()
{return Mass;}

void MeasurementResourceBaseType::setMass(MassValueType * MassIn)
{Mass = MassIn;}

CartesianWorkingVolumeType * MeasurementResourceBaseType::getSize()
{return Size;}

void MeasurementResourceBaseType::setSize(CartesianWorkingVolumeType * SizeIn)
{Size = SizeIn;}

MeasurementReso_1196_Type * MeasurementResourceBaseType::getMeasurementReso_1196()
{return MeasurementReso_1196;}

void MeasurementResourceBaseType::setMeasurementReso_1196(MeasurementReso_1196_Type * MeasurementReso_1196In)
{MeasurementReso_1196 = MeasurementReso_1196In;}

AttributesType * MeasurementResourceBaseType::getAttributes()
{return Attributes;}

void MeasurementResourceBaseType::setAttributes(AttributesType * AttributesIn)
{Attributes = AttributesIn;}

/* ***************************************************************** */

/* class MeasurementResourcesType

*/

MeasurementResourcesType::MeasurementResourcesType()
{
  Version = 0;
  Fixtures = 0;
  MeasurementRooms = 0;
  MeasurementDevices = 0;
  DetachableSensors = 0;
  Tools = 0;
}

MeasurementResourcesType::MeasurementResourcesType(
 VersionType * VersionIn,
 FixturesType * FixturesIn,
 MeasurementRoomsType * MeasurementRoomsIn,
 MeasurementDevicesType * MeasurementDevicesIn,
 DetachableSensorsType * DetachableSensorsIn,
 ToolsType * ToolsIn)
{
  Version = VersionIn;
  Fixtures = FixturesIn;
  MeasurementRooms = MeasurementRoomsIn;
  MeasurementDevices = MeasurementDevicesIn;
  DetachableSensors = DetachableSensorsIn;
  Tools = ToolsIn;
}

MeasurementResourcesType::~MeasurementResourcesType()
{
  #ifndef NODESTRUCT
  delete Version;
  delete Fixtures;
  delete MeasurementRooms;
  delete MeasurementDevices;
  delete DetachableSensors;
  delete Tools;
  #endif
}

void MeasurementResourcesType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Version)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Version");
      Version->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Version>\n");
    }
  if (Fixtures)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Fixtures");
      Fixtures->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Fixtures>\n");
    }
  if (MeasurementRooms)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementRooms");
      MeasurementRooms->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementRooms>\n");
    }
  if (MeasurementDevices)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementDevices");
      MeasurementDevices->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasurementDevices>\n");
    }
  if (DetachableSensors)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DetachableSensors");
      DetachableSensors->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DetachableSensors>\n");
    }
  if (Tools)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Tools");
      Tools->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Tools>\n");
    }
  doSpaces(-INDENT, outFile);
}

VersionType * MeasurementResourcesType::getVersion()
{return Version;}

void MeasurementResourcesType::setVersion(VersionType * VersionIn)
{Version = VersionIn;}

FixturesType * MeasurementResourcesType::getFixtures()
{return Fixtures;}

void MeasurementResourcesType::setFixtures(FixturesType * FixturesIn)
{Fixtures = FixturesIn;}

MeasurementRoomsType * MeasurementResourcesType::getMeasurementRooms()
{return MeasurementRooms;}

void MeasurementResourcesType::setMeasurementRooms(MeasurementRoomsType * MeasurementRoomsIn)
{MeasurementRooms = MeasurementRoomsIn;}

MeasurementDevicesType * MeasurementResourcesType::getMeasurementDevices()
{return MeasurementDevices;}

void MeasurementResourcesType::setMeasurementDevices(MeasurementDevicesType * MeasurementDevicesIn)
{MeasurementDevices = MeasurementDevicesIn;}

DetachableSensorsType * MeasurementResourcesType::getDetachableSensors()
{return DetachableSensors;}

void MeasurementResourcesType::setDetachableSensors(DetachableSensorsType * DetachableSensorsIn)
{DetachableSensors = DetachableSensorsIn;}

ToolsType * MeasurementResourcesType::getTools()
{return Tools;}

void MeasurementResourcesType::setTools(ToolsType * ToolsIn)
{Tools = ToolsIn;}

/* ***************************************************************** */

/* class MeasurementRoomType

*/

MeasurementRoomType::MeasurementRoomType() :
  MeasurementResourceBaseType()
{
  TemperatureRangeMin = 0;
  TemperatureRangeMax = 0;
  TemperatureControlMin = 0;
  TemperatureControlMax = 0;
  RelativeHumidityRangeMin = 0;
  RelativeHumidityRangeMax = 0;
  RelativeHumidityControlMin = 0;
  RelativeHumidityControlMax = 0;
}

MeasurementRoomType::MeasurementRoomType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 TemperatureType * TemperatureRangeMinIn,
 TemperatureType * TemperatureRangeMaxIn,
 TemperatureType * TemperatureControlMinIn,
 TemperatureType * TemperatureControlMaxIn,
 FractionType * RelativeHumidityRangeMinIn,
 FractionType * RelativeHumidityRangeMaxIn,
 FractionType * RelativeHumidityControlMinIn,
 FractionType * RelativeHumidityControlMaxIn) :
  MeasurementResourceBaseType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  TemperatureRangeMin = TemperatureRangeMinIn;
  TemperatureRangeMax = TemperatureRangeMaxIn;
  TemperatureControlMin = TemperatureControlMinIn;
  TemperatureControlMax = TemperatureControlMaxIn;
  RelativeHumidityRangeMin = RelativeHumidityRangeMinIn;
  RelativeHumidityRangeMax = RelativeHumidityRangeMaxIn;
  RelativeHumidityControlMin = RelativeHumidityControlMinIn;
  RelativeHumidityControlMax = RelativeHumidityControlMaxIn;
}

MeasurementRoomType::MeasurementRoomType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 TemperatureType * TemperatureRangeMinIn,
 TemperatureType * TemperatureRangeMaxIn,
 TemperatureType * TemperatureControlMinIn,
 TemperatureType * TemperatureControlMaxIn,
 FractionType * RelativeHumidityRangeMinIn,
 FractionType * RelativeHumidityRangeMaxIn,
 FractionType * RelativeHumidityControlMinIn,
 FractionType * RelativeHumidityControlMaxIn) :
  MeasurementResourceBaseType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  TemperatureRangeMin = TemperatureRangeMinIn;
  TemperatureRangeMax = TemperatureRangeMaxIn;
  TemperatureControlMin = TemperatureControlMinIn;
  TemperatureControlMax = TemperatureControlMaxIn;
  RelativeHumidityRangeMin = RelativeHumidityRangeMinIn;
  RelativeHumidityRangeMax = RelativeHumidityRangeMaxIn;
  RelativeHumidityControlMin = RelativeHumidityControlMinIn;
  RelativeHumidityControlMax = RelativeHumidityControlMaxIn;
}

MeasurementRoomType::~MeasurementRoomType()
{
  #ifndef NODESTRUCT
  delete TemperatureRangeMin;
  delete TemperatureRangeMax;
  delete TemperatureControlMin;
  delete TemperatureControlMax;
  delete RelativeHumidityRangeMin;
  delete RelativeHumidityRangeMax;
  delete RelativeHumidityControlMin;
  delete RelativeHumidityControlMax;
  #endif
}

void MeasurementRoomType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<TemperatureRangeMin");
  TemperatureRangeMin->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</TemperatureRangeMin>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<TemperatureRangeMax");
  TemperatureRangeMax->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</TemperatureRangeMax>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<TemperatureControlMin");
  TemperatureControlMin->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</TemperatureControlMin>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<TemperatureControlMax");
  TemperatureControlMax->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</TemperatureControlMax>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<RelativeHumidityRangeMin");
  RelativeHumidityRangeMin->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</RelativeHumidityRangeMin>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<RelativeHumidityRangeMax");
  RelativeHumidityRangeMax->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</RelativeHumidityRangeMax>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<RelativeHumidityControlMin");
  RelativeHumidityControlMin->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</RelativeHumidityControlMin>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<RelativeHumidityControlMax");
  RelativeHumidityControlMax->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</RelativeHumidityControlMax>\n");
  doSpaces(-INDENT, outFile);
}

bool MeasurementRoomType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in MeasurementRoomType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in MeasurementRoomType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in MeasurementRoomType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in MeasurementRoomType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

TemperatureType * MeasurementRoomType::getTemperatureRangeMin()
{return TemperatureRangeMin;}

void MeasurementRoomType::setTemperatureRangeMin(TemperatureType * TemperatureRangeMinIn)
{TemperatureRangeMin = TemperatureRangeMinIn;}

TemperatureType * MeasurementRoomType::getTemperatureRangeMax()
{return TemperatureRangeMax;}

void MeasurementRoomType::setTemperatureRangeMax(TemperatureType * TemperatureRangeMaxIn)
{TemperatureRangeMax = TemperatureRangeMaxIn;}

TemperatureType * MeasurementRoomType::getTemperatureControlMin()
{return TemperatureControlMin;}

void MeasurementRoomType::setTemperatureControlMin(TemperatureType * TemperatureControlMinIn)
{TemperatureControlMin = TemperatureControlMinIn;}

TemperatureType * MeasurementRoomType::getTemperatureControlMax()
{return TemperatureControlMax;}

void MeasurementRoomType::setTemperatureControlMax(TemperatureType * TemperatureControlMaxIn)
{TemperatureControlMax = TemperatureControlMaxIn;}

FractionType * MeasurementRoomType::getRelativeHumidityRangeMin()
{return RelativeHumidityRangeMin;}

void MeasurementRoomType::setRelativeHumidityRangeMin(FractionType * RelativeHumidityRangeMinIn)
{RelativeHumidityRangeMin = RelativeHumidityRangeMinIn;}

FractionType * MeasurementRoomType::getRelativeHumidityRangeMax()
{return RelativeHumidityRangeMax;}

void MeasurementRoomType::setRelativeHumidityRangeMax(FractionType * RelativeHumidityRangeMaxIn)
{RelativeHumidityRangeMax = RelativeHumidityRangeMaxIn;}

FractionType * MeasurementRoomType::getRelativeHumidityControlMin()
{return RelativeHumidityControlMin;}

void MeasurementRoomType::setRelativeHumidityControlMin(FractionType * RelativeHumidityControlMinIn)
{RelativeHumidityControlMin = RelativeHumidityControlMinIn;}

FractionType * MeasurementRoomType::getRelativeHumidityControlMax()
{return RelativeHumidityControlMax;}

void MeasurementRoomType::setRelativeHumidityControlMax(FractionType * RelativeHumidityControlMaxIn)
{RelativeHumidityControlMax = RelativeHumidityControlMaxIn;}

/* ***************************************************************** */

/* class MeasurementRoomTypeLisd

*/

MeasurementRoomTypeLisd::MeasurementRoomTypeLisd() {}

MeasurementRoomTypeLisd::MeasurementRoomTypeLisd(MeasurementRoomType * aMeasurementRoomType)
{
  push_back(aMeasurementRoomType);
}

MeasurementRoomTypeLisd::~MeasurementRoomTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<MeasurementRoomType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void MeasurementRoomTypeLisd::printSelf(FILE * outFile)
{
  std::list<MeasurementRoomType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class MeasurementRoomsType

*/

MeasurementRoomsType::MeasurementRoomsType()
{
  n = 0;
  MeasurementRoom = 0;
}

MeasurementRoomsType::MeasurementRoomsType(
 MeasurementRoomTypeLisd * MeasurementRoomIn)
{
  n = 0;
  MeasurementRoom = MeasurementRoomIn;
}

MeasurementRoomsType::MeasurementRoomsType(
 NaturalType * nIn,
 MeasurementRoomTypeLisd * MeasurementRoomIn)
{
  n = nIn;
  MeasurementRoom = MeasurementRoomIn;
}

MeasurementRoomsType::~MeasurementRoomsType()
{
  #ifndef NODESTRUCT
  delete n;
  delete MeasurementRoom;
  #endif
}

void MeasurementRoomsType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!MeasurementRoom)
      {
        fprintf(stderr, "MeasurementRoom list is missing\n");
        exit(1);
      }
    if (MeasurementRoom->size() == 0)
      {
        fprintf(stderr, "MeasurementRoom list is empty\n");
        exit(1);
      }
    if (MeasurementRoom->size() < 1)
      {
        fprintf(stderr,
                "size of MeasurementRoom list (%d) less than minimum required (1)\n",
                (int)MeasurementRoom->size());
        exit(1);
      }
    std::list<MeasurementRoomType *>::iterator iter;
    for (iter = MeasurementRoom->begin();
         iter != MeasurementRoom->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<MeasurementRoom");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</MeasurementRoom>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool MeasurementRoomsType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in MeasurementRoomsType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in MeasurementRoomsType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in MeasurementRoomsType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in MeasurementRoomsType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * MeasurementRoomsType::getn()
{return n;}

void MeasurementRoomsType::setn(NaturalType * nIn)
{n = nIn;}

MeasurementRoomTypeLisd * MeasurementRoomsType::getMeasurementRoom()
{return MeasurementRoom;}

void MeasurementRoomsType::setMeasurementRoom(MeasurementRoomTypeLisd * MeasurementRoomIn)
{MeasurementRoom = MeasurementRoomIn;}

/* ***************************************************************** */

/* class MicrometerAnalogType

*/

MicrometerAnalogType::MicrometerAnalogType() :
  MicrometerType()
{
}

MicrometerAnalogType::MicrometerAnalogType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 LinearResolutionType * LinearResolutionIn,
 NumericalLengthAccuracyType * AccuracyIn,
 ForceValueType * MeasuringForceIn,
 InternalExternalEnumType * InternalExternalIn) :
  MicrometerType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    MinMeasuringDistanceIn,
    MaxMeasuringDistanceIn,
    LinearResolutionIn,
    AccuracyIn,
    MeasuringForceIn,
    InternalExternalIn)
{
}

MicrometerAnalogType::MicrometerAnalogType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 LinearResolutionType * LinearResolutionIn,
 NumericalLengthAccuracyType * AccuracyIn,
 ForceValueType * MeasuringForceIn,
 InternalExternalEnumType * InternalExternalIn) :
  MicrometerType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    MinMeasuringDistanceIn,
    MaxMeasuringDistanceIn,
    LinearResolutionIn,
    AccuracyIn,
    MeasuringForceIn,
    InternalExternalIn)
{
}

MicrometerAnalogType::~MicrometerAnalogType()
{
  #ifndef NODESTRUCT
  #endif
}

void MicrometerAnalogType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Calibrations)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Calibrations");
      Calibrations->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Calibrations>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (MinMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinMeasuringDistance");
      MinMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MinMeasuringDistance>\n");
    }
  if (MaxMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxMeasuringDistance");
      MaxMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MaxMeasuringDistance>\n");
    }
  if (LinearResolution)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LinearResolution");
      LinearResolution->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LinearResolution>\n");
    }
  if (Accuracy)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Accuracy");
      Accuracy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Accuracy>\n");
    }
  if (MeasuringForce)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasuringForce");
      MeasuringForce->printSelf(outFile);
      fprintf(outFile, "</MeasuringForce>\n");
    }
  if (InternalExternal)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<InternalExternal");
      InternalExternal->printSelf(outFile);
      fprintf(outFile, "</InternalExternal>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool MicrometerAnalogType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in MicrometerAnalogType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in MicrometerAnalogType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in MicrometerAnalogType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in MicrometerAnalogType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class MicrometerDigitalType

*/

MicrometerDigitalType::MicrometerDigitalType() :
  MicrometerType()
{
}

MicrometerDigitalType::MicrometerDigitalType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 LinearResolutionType * LinearResolutionIn,
 NumericalLengthAccuracyType * AccuracyIn,
 ForceValueType * MeasuringForceIn,
 InternalExternalEnumType * InternalExternalIn) :
  MicrometerType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    MinMeasuringDistanceIn,
    MaxMeasuringDistanceIn,
    LinearResolutionIn,
    AccuracyIn,
    MeasuringForceIn,
    InternalExternalIn)
{
}

MicrometerDigitalType::MicrometerDigitalType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 LinearResolutionType * LinearResolutionIn,
 NumericalLengthAccuracyType * AccuracyIn,
 ForceValueType * MeasuringForceIn,
 InternalExternalEnumType * InternalExternalIn) :
  MicrometerType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    MinMeasuringDistanceIn,
    MaxMeasuringDistanceIn,
    LinearResolutionIn,
    AccuracyIn,
    MeasuringForceIn,
    InternalExternalIn)
{
}

MicrometerDigitalType::~MicrometerDigitalType()
{
  #ifndef NODESTRUCT
  #endif
}

void MicrometerDigitalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Calibrations)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Calibrations");
      Calibrations->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Calibrations>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (MinMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinMeasuringDistance");
      MinMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MinMeasuringDistance>\n");
    }
  if (MaxMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxMeasuringDistance");
      MaxMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MaxMeasuringDistance>\n");
    }
  if (LinearResolution)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LinearResolution");
      LinearResolution->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LinearResolution>\n");
    }
  if (Accuracy)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Accuracy");
      Accuracy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Accuracy>\n");
    }
  if (MeasuringForce)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasuringForce");
      MeasuringForce->printSelf(outFile);
      fprintf(outFile, "</MeasuringForce>\n");
    }
  if (InternalExternal)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<InternalExternal");
      InternalExternal->printSelf(outFile);
      fprintf(outFile, "</InternalExternal>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool MicrometerDigitalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in MicrometerDigitalType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in MicrometerDigitalType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in MicrometerDigitalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in MicrometerDigitalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class MicrometerType

*/

MicrometerType::MicrometerType() :
  ManualMeasurementDeviceType()
{
  LinearResolution = 0;
  Accuracy = 0;
  MeasuringForce = 0;
  InternalExternal = 0;
}

MicrometerType::MicrometerType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 LinearResolutionType * LinearResolutionIn,
 NumericalLengthAccuracyType * AccuracyIn,
 ForceValueType * MeasuringForceIn,
 InternalExternalEnumType * InternalExternalIn) :
  ManualMeasurementDeviceType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    MinMeasuringDistanceIn,
    MaxMeasuringDistanceIn)
{
  LinearResolution = LinearResolutionIn;
  Accuracy = AccuracyIn;
  MeasuringForce = MeasuringForceIn;
  InternalExternal = InternalExternalIn;
}

MicrometerType::MicrometerType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 LinearResolutionType * LinearResolutionIn,
 NumericalLengthAccuracyType * AccuracyIn,
 ForceValueType * MeasuringForceIn,
 InternalExternalEnumType * InternalExternalIn) :
  ManualMeasurementDeviceType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    MinMeasuringDistanceIn,
    MaxMeasuringDistanceIn)
{
  LinearResolution = LinearResolutionIn;
  Accuracy = AccuracyIn;
  MeasuringForce = MeasuringForceIn;
  InternalExternal = InternalExternalIn;
}

MicrometerType::~MicrometerType()
{
  #ifndef NODESTRUCT
  delete LinearResolution;
  delete Accuracy;
  delete MeasuringForce;
  delete InternalExternal;
  #endif
}

void MicrometerType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Calibrations)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Calibrations");
      Calibrations->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Calibrations>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (MinMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinMeasuringDistance");
      MinMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MinMeasuringDistance>\n");
    }
  if (MaxMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxMeasuringDistance");
      MaxMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MaxMeasuringDistance>\n");
    }
  if (LinearResolution)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LinearResolution");
      LinearResolution->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LinearResolution>\n");
    }
  if (Accuracy)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Accuracy");
      Accuracy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Accuracy>\n");
    }
  if (MeasuringForce)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasuringForce");
      MeasuringForce->printSelf(outFile);
      fprintf(outFile, "</MeasuringForce>\n");
    }
  if (InternalExternal)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<InternalExternal");
      InternalExternal->printSelf(outFile);
      fprintf(outFile, "</InternalExternal>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool MicrometerType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in MicrometerType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in MicrometerType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in MicrometerType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in MicrometerType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LinearResolutionType * MicrometerType::getLinearResolution()
{return LinearResolution;}

void MicrometerType::setLinearResolution(LinearResolutionType * LinearResolutionIn)
{LinearResolution = LinearResolutionIn;}

NumericalLengthAccuracyType * MicrometerType::getAccuracy()
{return Accuracy;}

void MicrometerType::setAccuracy(NumericalLengthAccuracyType * AccuracyIn)
{Accuracy = AccuracyIn;}

ForceValueType * MicrometerType::getMeasuringForce()
{return MeasuringForce;}

void MicrometerType::setMeasuringForce(ForceValueType * MeasuringForceIn)
{MeasuringForce = MeasuringForceIn;}

InternalExternalEnumType * MicrometerType::getInternalExternal()
{return InternalExternal;}

void MicrometerType::setInternalExternal(InternalExternalEnumType * InternalExternalIn)
{InternalExternal = InternalExternalIn;}

/* ***************************************************************** */

/* class MicroscopeType

*/

MicroscopeType::MicroscopeType() :
  UniversalDeviceType()
{
  IlluminationUnit = 0;
  TotalMagnification = 0;
  EyePieceMagnification = 0;
  ObjectiveMagnification = 0;
  MaxWorkpieceHeight = 0;
  MaxWorkpieceWeight = 0;
  Accuracy = 0;
  StageSwivelingAngle = 0;
  ToolIds = 0;
}

MicroscopeType::MicroscopeType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 ResolutionBaseType * ResolutionIn,
 WorkingVolumeBaseType * WorkingVolumeIn,
 EffectiveWorkingVolumeBaseType * EffectiveWorkingVolumeIn,
 TemperatureCompensationType * TemperatureCompensationIn,
 XmlString * IlluminationUnitIn,
 XmlDecimal * TotalMagnificationIn,
 XmlDecimal * EyePieceMagnificationIn,
 XmlDecimal * ObjectiveMagnificationIn,
 LinearValueType * MaxWorkpieceHeightIn,
 MassValueType * MaxWorkpieceWeightIn,
 LinearErrorType * AccuracyIn,
 AngularValueType * StageSwivelingAngleIn,
 ArrayReferenceType * ToolIdsIn) :
  UniversalDeviceType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    ResolutionIn,
    WorkingVolumeIn,
    EffectiveWorkingVolumeIn,
    TemperatureCompensationIn)
{
  IlluminationUnit = IlluminationUnitIn;
  TotalMagnification = TotalMagnificationIn;
  EyePieceMagnification = EyePieceMagnificationIn;
  ObjectiveMagnification = ObjectiveMagnificationIn;
  MaxWorkpieceHeight = MaxWorkpieceHeightIn;
  MaxWorkpieceWeight = MaxWorkpieceWeightIn;
  Accuracy = AccuracyIn;
  StageSwivelingAngle = StageSwivelingAngleIn;
  ToolIds = ToolIdsIn;
}

MicroscopeType::MicroscopeType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 ResolutionBaseType * ResolutionIn,
 WorkingVolumeBaseType * WorkingVolumeIn,
 EffectiveWorkingVolumeBaseType * EffectiveWorkingVolumeIn,
 TemperatureCompensationType * TemperatureCompensationIn,
 XmlString * IlluminationUnitIn,
 XmlDecimal * TotalMagnificationIn,
 XmlDecimal * EyePieceMagnificationIn,
 XmlDecimal * ObjectiveMagnificationIn,
 LinearValueType * MaxWorkpieceHeightIn,
 MassValueType * MaxWorkpieceWeightIn,
 LinearErrorType * AccuracyIn,
 AngularValueType * StageSwivelingAngleIn,
 ArrayReferenceType * ToolIdsIn) :
  UniversalDeviceType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    ResolutionIn,
    WorkingVolumeIn,
    EffectiveWorkingVolumeIn,
    TemperatureCompensationIn)
{
  IlluminationUnit = IlluminationUnitIn;
  TotalMagnification = TotalMagnificationIn;
  EyePieceMagnification = EyePieceMagnificationIn;
  ObjectiveMagnification = ObjectiveMagnificationIn;
  MaxWorkpieceHeight = MaxWorkpieceHeightIn;
  MaxWorkpieceWeight = MaxWorkpieceWeightIn;
  Accuracy = AccuracyIn;
  StageSwivelingAngle = StageSwivelingAngleIn;
  ToolIds = ToolIdsIn;
}

MicroscopeType::~MicroscopeType()
{
  #ifndef NODESTRUCT
  delete IlluminationUnit;
  delete TotalMagnification;
  delete EyePieceMagnification;
  delete ObjectiveMagnification;
  delete MaxWorkpieceHeight;
  delete MaxWorkpieceWeight;
  delete Accuracy;
  delete StageSwivelingAngle;
  delete ToolIds;
  #endif
}

void MicroscopeType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Calibrations)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Calibrations");
      Calibrations->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Calibrations>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (Resolution)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (Resolution->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(Resolution->getprintElement(), "LinearResolution") == 0)
          {
            LinearResolutionType * typ;
            if ((typ = dynamic_cast<LinearResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<LinearResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LinearResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad LinearResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "CartesianResolution") == 0)
          {
            CartesianResolutionType * typ;
            if ((typ = dynamic_cast<CartesianResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<CartesianResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "SphericalResolution") == 0)
          {
            SphericalResolutionType * typ;
            if ((typ = dynamic_cast<SphericalResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<SphericalResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "UserDefinedResolution") == 0)
          {
            UserDefinedResolutionType * typ;
            if ((typ = dynamic_cast<UserDefinedResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<UserDefinedResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedResolution element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad Resolution type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (WorkingVolume)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (WorkingVolume->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(WorkingVolume->getprintElement(), "ClosedShellSetWorkingVolume") == 0)
          {
            ClosedShellSetWorkingVolumeType * typ;
            if ((typ = dynamic_cast<ClosedShellSetWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<ClosedShellSetWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ClosedShellSetWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad ClosedShellSetWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "CartesianWorkingVolume") == 0)
          {
            CartesianWorkingVolumeType * typ;
            if ((typ = dynamic_cast<CartesianWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<CartesianWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "SphericalWorkingVolume") == 0)
          {
            SphericalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<SphericalWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<SphericalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "CylindricalWorkingVolume") == 0)
          {
            CylindricalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<CylindricalWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<CylindricalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CylindricalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad CylindricalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "UserDefinedWorkingVolume") == 0)
          {
            UserDefinedWorkingVolumeType * typ;
            if ((typ = dynamic_cast<UserDefinedWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<UserDefinedWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedWorkingVolume element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad WorkingVolume type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (EffectiveWorkingVolume)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (EffectiveWorkingVolume->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveClosedShellSetWorkingVolume") == 0)
          {
            EffectiveClosedShellSetWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveClosedShellSetWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveClosedShellSetWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveClosedShellSetWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveClosedShellSetWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveCartesianWorkingVolume") == 0)
          {
            EffectiveCartesianWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveCartesianWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveCartesianWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveCartesianWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveCartesianWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveSphericalWorkingVolume") == 0)
          {
            EffectiveSphericalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveSphericalWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveSphericalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveSphericalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveSphericalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveCylindricalWorkingVolume") == 0)
          {
            EffectiveCylindricalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveCylindricalWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveCylindricalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveCylindricalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveCylindricalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveUserDefinedWorkingVolume") == 0)
          {
            EffectiveUserDefinedWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveUserDefinedWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveUserDefinedWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveUserDefinedWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveUserDefinedWorkingVolume element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad EffectiveWorkingVolume type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (TemperatureCompensation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TemperatureCompensation");
      TemperatureCompensation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</TemperatureCompensation>\n");
    }
  if (IlluminationUnit)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<IlluminationUnit");
      IlluminationUnit->printSelf(outFile);
      fprintf(outFile, "</IlluminationUnit>\n");
    }
  if (TotalMagnification)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TotalMagnification");
      TotalMagnification->printSelf(outFile);
      fprintf(outFile, "</TotalMagnification>\n");
    }
  if (EyePieceMagnification)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EyePieceMagnification");
      EyePieceMagnification->printSelf(outFile);
      fprintf(outFile, "</EyePieceMagnification>\n");
    }
  if (ObjectiveMagnification)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ObjectiveMagnification");
      ObjectiveMagnification->printSelf(outFile);
      fprintf(outFile, "</ObjectiveMagnification>\n");
    }
  if (MaxWorkpieceHeight)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxWorkpieceHeight");
      MaxWorkpieceHeight->printSelf(outFile);
      fprintf(outFile, "</MaxWorkpieceHeight>\n");
    }
  if (MaxWorkpieceWeight)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxWorkpieceWeight");
      MaxWorkpieceWeight->printSelf(outFile);
      fprintf(outFile, "</MaxWorkpieceWeight>\n");
    }
  if (Accuracy)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Accuracy");
      Accuracy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Accuracy>\n");
    }
  if (StageSwivelingAngle)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StageSwivelingAngle");
      StageSwivelingAngle->printSelf(outFile);
      fprintf(outFile, "</StageSwivelingAngle>\n");
    }
  if (ToolIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToolIds");
      ToolIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ToolIds>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool MicroscopeType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in MicroscopeType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in MicroscopeType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in MicroscopeType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in MicroscopeType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

XmlString * MicroscopeType::getIlluminationUnit()
{return IlluminationUnit;}

void MicroscopeType::setIlluminationUnit(XmlString * IlluminationUnitIn)
{IlluminationUnit = IlluminationUnitIn;}

XmlDecimal * MicroscopeType::getTotalMagnification()
{return TotalMagnification;}

void MicroscopeType::setTotalMagnification(XmlDecimal * TotalMagnificationIn)
{TotalMagnification = TotalMagnificationIn;}

XmlDecimal * MicroscopeType::getEyePieceMagnification()
{return EyePieceMagnification;}

void MicroscopeType::setEyePieceMagnification(XmlDecimal * EyePieceMagnificationIn)
{EyePieceMagnification = EyePieceMagnificationIn;}

XmlDecimal * MicroscopeType::getObjectiveMagnification()
{return ObjectiveMagnification;}

void MicroscopeType::setObjectiveMagnification(XmlDecimal * ObjectiveMagnificationIn)
{ObjectiveMagnification = ObjectiveMagnificationIn;}

LinearValueType * MicroscopeType::getMaxWorkpieceHeight()
{return MaxWorkpieceHeight;}

void MicroscopeType::setMaxWorkpieceHeight(LinearValueType * MaxWorkpieceHeightIn)
{MaxWorkpieceHeight = MaxWorkpieceHeightIn;}

MassValueType * MicroscopeType::getMaxWorkpieceWeight()
{return MaxWorkpieceWeight;}

void MicroscopeType::setMaxWorkpieceWeight(MassValueType * MaxWorkpieceWeightIn)
{MaxWorkpieceWeight = MaxWorkpieceWeightIn;}

LinearErrorType * MicroscopeType::getAccuracy()
{return Accuracy;}

void MicroscopeType::setAccuracy(LinearErrorType * AccuracyIn)
{Accuracy = AccuracyIn;}

AngularValueType * MicroscopeType::getStageSwivelingAngle()
{return StageSwivelingAngle;}

void MicroscopeType::setStageSwivelingAngle(AngularValueType * StageSwivelingAngleIn)
{StageSwivelingAngle = StageSwivelingAngleIn;}

ArrayReferenceType * MicroscopeType::getToolIds()
{return ToolIds;}

void MicroscopeType::setToolIds(ArrayReferenceType * ToolIdsIn)
{ToolIds = ToolIdsIn;}

/* ***************************************************************** */

/* class MultipleCarriageCartesianCMMType

*/

MultipleCarriageCartesianCMMType::MultipleCarriageCartesianCMMType() :
  CartesianCMMType()
{
  Carriages = 0;
}

MultipleCarriageCartesianCMMType::MultipleCarriageCartesianCMMType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 ResolutionBaseType * ResolutionIn,
 WorkingVolumeBaseType * WorkingVolumeIn,
 EffectiveWorkingVolumeBaseType * EffectiveWorkingVolumeIn,
 TemperatureCompensationType * TemperatureCompensationIn,
 PointType * HomeLocationIn,
 CartesianCMMGeometryType * CMMGeometryIn,
 CMMAxisDirectionsBaseType * CMMAxisDirectionsIn,
 MeasurementDeviceScalesBaseType * ScalesIn,
 LinearValueType * MaxWorkpieceHeightIn,
 MassValueType * MaxWorkpieceMassIn,
 CartesianCMMSpeedsType * JoystickSpeedsIn,
 CMMSpeedsBaseType * CMMSpeedsIn,
 RotaryTableType * RotaryTableIn,
 CartesianCMMAccuraciesType * AccuraciesIn,
 ArrayReferenceType * ToolIdsIn,
 ArrayReferenceType * SensorIdsIn,
 CarriagesType * CarriagesIn) :
  CartesianCMMType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    ResolutionIn,
    WorkingVolumeIn,
    EffectiveWorkingVolumeIn,
    TemperatureCompensationIn,
    HomeLocationIn,
    CMMGeometryIn,
    CMMAxisDirectionsIn,
    ScalesIn,
    MaxWorkpieceHeightIn,
    MaxWorkpieceMassIn,
    JoystickSpeedsIn,
    CMMSpeedsIn,
    RotaryTableIn,
    AccuraciesIn,
    ToolIdsIn,
    SensorIdsIn)
{
  Carriages = CarriagesIn;
}

MultipleCarriageCartesianCMMType::MultipleCarriageCartesianCMMType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 ResolutionBaseType * ResolutionIn,
 WorkingVolumeBaseType * WorkingVolumeIn,
 EffectiveWorkingVolumeBaseType * EffectiveWorkingVolumeIn,
 TemperatureCompensationType * TemperatureCompensationIn,
 PointType * HomeLocationIn,
 CartesianCMMGeometryType * CMMGeometryIn,
 CMMAxisDirectionsBaseType * CMMAxisDirectionsIn,
 MeasurementDeviceScalesBaseType * ScalesIn,
 LinearValueType * MaxWorkpieceHeightIn,
 MassValueType * MaxWorkpieceMassIn,
 CartesianCMMSpeedsType * JoystickSpeedsIn,
 CMMSpeedsBaseType * CMMSpeedsIn,
 RotaryTableType * RotaryTableIn,
 CartesianCMMAccuraciesType * AccuraciesIn,
 ArrayReferenceType * ToolIdsIn,
 ArrayReferenceType * SensorIdsIn,
 CarriagesType * CarriagesIn) :
  CartesianCMMType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    ResolutionIn,
    WorkingVolumeIn,
    EffectiveWorkingVolumeIn,
    TemperatureCompensationIn,
    HomeLocationIn,
    CMMGeometryIn,
    CMMAxisDirectionsIn,
    ScalesIn,
    MaxWorkpieceHeightIn,
    MaxWorkpieceMassIn,
    JoystickSpeedsIn,
    CMMSpeedsIn,
    RotaryTableIn,
    AccuraciesIn,
    ToolIdsIn,
    SensorIdsIn)
{
  Carriages = CarriagesIn;
}

MultipleCarriageCartesianCMMType::~MultipleCarriageCartesianCMMType()
{
  #ifndef NODESTRUCT
  delete Carriages;
  #endif
}

void MultipleCarriageCartesianCMMType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Calibrations)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Calibrations");
      Calibrations->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Calibrations>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (Resolution)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (Resolution->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(Resolution->getprintElement(), "LinearResolution") == 0)
          {
            LinearResolutionType * typ;
            if ((typ = dynamic_cast<LinearResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<LinearResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LinearResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad LinearResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "CartesianResolution") == 0)
          {
            CartesianResolutionType * typ;
            if ((typ = dynamic_cast<CartesianResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<CartesianResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "SphericalResolution") == 0)
          {
            SphericalResolutionType * typ;
            if ((typ = dynamic_cast<SphericalResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<SphericalResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "UserDefinedResolution") == 0)
          {
            UserDefinedResolutionType * typ;
            if ((typ = dynamic_cast<UserDefinedResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<UserDefinedResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedResolution element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad Resolution type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (WorkingVolume)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (WorkingVolume->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(WorkingVolume->getprintElement(), "ClosedShellSetWorkingVolume") == 0)
          {
            ClosedShellSetWorkingVolumeType * typ;
            if ((typ = dynamic_cast<ClosedShellSetWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<ClosedShellSetWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ClosedShellSetWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad ClosedShellSetWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "CartesianWorkingVolume") == 0)
          {
            CartesianWorkingVolumeType * typ;
            if ((typ = dynamic_cast<CartesianWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<CartesianWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "SphericalWorkingVolume") == 0)
          {
            SphericalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<SphericalWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<SphericalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "CylindricalWorkingVolume") == 0)
          {
            CylindricalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<CylindricalWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<CylindricalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CylindricalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad CylindricalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "UserDefinedWorkingVolume") == 0)
          {
            UserDefinedWorkingVolumeType * typ;
            if ((typ = dynamic_cast<UserDefinedWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<UserDefinedWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedWorkingVolume element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad WorkingVolume type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (EffectiveWorkingVolume)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (EffectiveWorkingVolume->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveClosedShellSetWorkingVolume") == 0)
          {
            EffectiveClosedShellSetWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveClosedShellSetWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveClosedShellSetWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveClosedShellSetWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveClosedShellSetWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveCartesianWorkingVolume") == 0)
          {
            EffectiveCartesianWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveCartesianWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveCartesianWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveCartesianWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveCartesianWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveSphericalWorkingVolume") == 0)
          {
            EffectiveSphericalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveSphericalWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveSphericalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveSphericalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveSphericalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveCylindricalWorkingVolume") == 0)
          {
            EffectiveCylindricalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveCylindricalWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveCylindricalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveCylindricalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveCylindricalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveUserDefinedWorkingVolume") == 0)
          {
            EffectiveUserDefinedWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveUserDefinedWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveUserDefinedWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveUserDefinedWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveUserDefinedWorkingVolume element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad EffectiveWorkingVolume type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (TemperatureCompensation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TemperatureCompensation");
      TemperatureCompensation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</TemperatureCompensation>\n");
    }
  if (HomeLocation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<HomeLocation");
      HomeLocation->printSelf(outFile);
      fprintf(outFile, "</HomeLocation>\n");
    }
  if (CMMGeometry)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CMMGeometry");
      CMMGeometry->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CMMGeometry>\n");
    }
  if (CMMAxisDirections)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (CMMAxisDirections->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(CMMAxisDirections->getprintElement(), "CartesianCMMAxisDirections") == 0)
          {
            CartesianCMMAxisDirectionsType * typ;
            if ((typ = dynamic_cast<CartesianCMMAxisDirectionsType *>(CMMAxisDirections)))
              {
                fprintf(outFile, "<CartesianCMMAxisDirections");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianCMMAxisDirections>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianCMMAxisDirections element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad CMMAxisDirections type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (Scales)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (Scales->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(Scales->getprintElement(), "CartesianMeasurementDeviceScales") == 0)
          {
            CartesianMeasurementDeviceScalesType * typ;
            if ((typ = dynamic_cast<CartesianMeasurementDeviceScalesType *>(Scales)))
              {
                fprintf(outFile, "<CartesianMeasurementDeviceScales");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianMeasurementDeviceScales>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianMeasurementDeviceScales element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad Scales type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (MaxWorkpieceHeight)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxWorkpieceHeight");
      MaxWorkpieceHeight->printSelf(outFile);
      fprintf(outFile, "</MaxWorkpieceHeight>\n");
    }
  if (MaxWorkpieceMass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxWorkpieceMass");
      MaxWorkpieceMass->printSelf(outFile);
      fprintf(outFile, "</MaxWorkpieceMass>\n");
    }
  if (JoystickSpeeds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<JoystickSpeeds");
      JoystickSpeeds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</JoystickSpeeds>\n");
    }
  if (CMMSpeeds)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (CMMSpeeds->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(CMMSpeeds->getprintElement(), "CartesianCMMSpeeds") == 0)
          {
            CartesianCMMSpeedsType * typ;
            if ((typ = dynamic_cast<CartesianCMMSpeedsType *>(CMMSpeeds)))
              {
                fprintf(outFile, "<CartesianCMMSpeeds");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianCMMSpeeds>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianCMMSpeeds element\n");
                exit(1);
              }
          }
        else if (strcmp(CMMSpeeds->getprintElement(), "ParallelLinkCMMSpeeds") == 0)
          {
            ParallelLinkCMMSpeedsType * typ;
            if ((typ = dynamic_cast<ParallelLinkCMMSpeedsType *>(CMMSpeeds)))
              {
                fprintf(outFile, "<ParallelLinkCMMSpeeds");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ParallelLinkCMMSpeeds>\n");
              }
            else
              {
                fprintf(stderr, "bad ParallelLinkCMMSpeeds element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad CMMSpeeds type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (RotaryTable)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<RotaryTable");
      RotaryTable->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</RotaryTable>\n");
    }
  if (Accuracies)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Accuracies");
      Accuracies->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Accuracies>\n");
    }
  if (ToolIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToolIds");
      ToolIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ToolIds>\n");
    }
  if (SensorIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SensorIds");
      SensorIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SensorIds>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Carriages");
  Carriages->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Carriages>\n");
  doSpaces(-INDENT, outFile);
}

bool MultipleCarriageCartesianCMMType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in MultipleCarriageCartesianCMMType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in MultipleCarriageCartesianCMMType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in MultipleCarriageCartesianCMMType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in MultipleCarriageCartesianCMMType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

CarriagesType * MultipleCarriageCartesianCMMType::getCarriages()
{return Carriages;}

void MultipleCarriageCartesianCMMType::setCarriages(CarriagesType * CarriagesIn)
{Carriages = CarriagesIn;}

/* ***************************************************************** */

/* class NumericalLengthAccuracyType

*/

NumericalLengthAccuracyType::NumericalLengthAccuracyType() :
  MeasurementDeviceAccuracyBaseType()
{
  AccuracyValue = 0;
}

NumericalLengthAccuracyType::NumericalLengthAccuracyType(
 EnvironmentalRangeType * EnvironmentalRangeIn,
 LinearValueType * AccuracyValueIn) :
  MeasurementDeviceAccuracyBaseType(
    EnvironmentalRangeIn)
{
  AccuracyValue = AccuracyValueIn;
}

NumericalLengthAccuracyType::~NumericalLengthAccuracyType()
{
  #ifndef NODESTRUCT
  delete AccuracyValue;
  #endif
}

void NumericalLengthAccuracyType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<EnvironmentalRange");
  EnvironmentalRange->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</EnvironmentalRange>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<AccuracyValue");
  AccuracyValue->printSelf(outFile);
  fprintf(outFile, "</AccuracyValue>\n");
  doSpaces(-INDENT, outFile);
}

LinearValueType * NumericalLengthAccuracyType::getAccuracyValue()
{return AccuracyValue;}

void NumericalLengthAccuracyType::setAccuracyValue(LinearValueType * AccuracyValueIn)
{AccuracyValue = AccuracyValueIn;}

/* ***************************************************************** */

/* class OpticalComparatorType

*/

OpticalComparatorType::OpticalComparatorType() :
  UniversalDeviceType()
{
  Magnification = 0;
  EffectiveScreenDiameter = 0;
  ScreenMaterial = 0;
  AngleResolution = 0;
  SurfaceIlluminationLightSource = 0;
  ContourIlluminationLightSource = 0;
  MaxWorkpieceHeight = 0;
  WorkingDistance = 0;
  ToolIds = 0;
}

OpticalComparatorType::OpticalComparatorType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 ResolutionBaseType * ResolutionIn,
 WorkingVolumeBaseType * WorkingVolumeIn,
 EffectiveWorkingVolumeBaseType * EffectiveWorkingVolumeIn,
 TemperatureCompensationType * TemperatureCompensationIn,
 XmlDecimal * MagnificationIn,
 LinearValueType * EffectiveScreenDiameterIn,
 XmlString * ScreenMaterialIn,
 AngularValueType * AngleResolutionIn,
 XmlString * SurfaceIlluminationLightSourceIn,
 XmlString * ContourIlluminationLightSourceIn,
 LinearValueType * MaxWorkpieceHeightIn,
 LinearValueType * WorkingDistanceIn,
 ArrayReferenceType * ToolIdsIn) :
  UniversalDeviceType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    ResolutionIn,
    WorkingVolumeIn,
    EffectiveWorkingVolumeIn,
    TemperatureCompensationIn)
{
  Magnification = MagnificationIn;
  EffectiveScreenDiameter = EffectiveScreenDiameterIn;
  ScreenMaterial = ScreenMaterialIn;
  AngleResolution = AngleResolutionIn;
  SurfaceIlluminationLightSource = SurfaceIlluminationLightSourceIn;
  ContourIlluminationLightSource = ContourIlluminationLightSourceIn;
  MaxWorkpieceHeight = MaxWorkpieceHeightIn;
  WorkingDistance = WorkingDistanceIn;
  ToolIds = ToolIdsIn;
}

OpticalComparatorType::OpticalComparatorType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 ResolutionBaseType * ResolutionIn,
 WorkingVolumeBaseType * WorkingVolumeIn,
 EffectiveWorkingVolumeBaseType * EffectiveWorkingVolumeIn,
 TemperatureCompensationType * TemperatureCompensationIn,
 XmlDecimal * MagnificationIn,
 LinearValueType * EffectiveScreenDiameterIn,
 XmlString * ScreenMaterialIn,
 AngularValueType * AngleResolutionIn,
 XmlString * SurfaceIlluminationLightSourceIn,
 XmlString * ContourIlluminationLightSourceIn,
 LinearValueType * MaxWorkpieceHeightIn,
 LinearValueType * WorkingDistanceIn,
 ArrayReferenceType * ToolIdsIn) :
  UniversalDeviceType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    ResolutionIn,
    WorkingVolumeIn,
    EffectiveWorkingVolumeIn,
    TemperatureCompensationIn)
{
  Magnification = MagnificationIn;
  EffectiveScreenDiameter = EffectiveScreenDiameterIn;
  ScreenMaterial = ScreenMaterialIn;
  AngleResolution = AngleResolutionIn;
  SurfaceIlluminationLightSource = SurfaceIlluminationLightSourceIn;
  ContourIlluminationLightSource = ContourIlluminationLightSourceIn;
  MaxWorkpieceHeight = MaxWorkpieceHeightIn;
  WorkingDistance = WorkingDistanceIn;
  ToolIds = ToolIdsIn;
}

OpticalComparatorType::~OpticalComparatorType()
{
  #ifndef NODESTRUCT
  delete Magnification;
  delete EffectiveScreenDiameter;
  delete ScreenMaterial;
  delete AngleResolution;
  delete SurfaceIlluminationLightSource;
  delete ContourIlluminationLightSource;
  delete MaxWorkpieceHeight;
  delete WorkingDistance;
  delete ToolIds;
  #endif
}

void OpticalComparatorType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Calibrations)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Calibrations");
      Calibrations->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Calibrations>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (Resolution)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (Resolution->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(Resolution->getprintElement(), "LinearResolution") == 0)
          {
            LinearResolutionType * typ;
            if ((typ = dynamic_cast<LinearResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<LinearResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LinearResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad LinearResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "CartesianResolution") == 0)
          {
            CartesianResolutionType * typ;
            if ((typ = dynamic_cast<CartesianResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<CartesianResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "SphericalResolution") == 0)
          {
            SphericalResolutionType * typ;
            if ((typ = dynamic_cast<SphericalResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<SphericalResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "UserDefinedResolution") == 0)
          {
            UserDefinedResolutionType * typ;
            if ((typ = dynamic_cast<UserDefinedResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<UserDefinedResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedResolution element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad Resolution type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (WorkingVolume)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (WorkingVolume->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(WorkingVolume->getprintElement(), "ClosedShellSetWorkingVolume") == 0)
          {
            ClosedShellSetWorkingVolumeType * typ;
            if ((typ = dynamic_cast<ClosedShellSetWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<ClosedShellSetWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ClosedShellSetWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad ClosedShellSetWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "CartesianWorkingVolume") == 0)
          {
            CartesianWorkingVolumeType * typ;
            if ((typ = dynamic_cast<CartesianWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<CartesianWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "SphericalWorkingVolume") == 0)
          {
            SphericalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<SphericalWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<SphericalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "CylindricalWorkingVolume") == 0)
          {
            CylindricalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<CylindricalWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<CylindricalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CylindricalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad CylindricalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "UserDefinedWorkingVolume") == 0)
          {
            UserDefinedWorkingVolumeType * typ;
            if ((typ = dynamic_cast<UserDefinedWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<UserDefinedWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedWorkingVolume element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad WorkingVolume type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (EffectiveWorkingVolume)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (EffectiveWorkingVolume->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveClosedShellSetWorkingVolume") == 0)
          {
            EffectiveClosedShellSetWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveClosedShellSetWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveClosedShellSetWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveClosedShellSetWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveClosedShellSetWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveCartesianWorkingVolume") == 0)
          {
            EffectiveCartesianWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveCartesianWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveCartesianWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveCartesianWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveCartesianWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveSphericalWorkingVolume") == 0)
          {
            EffectiveSphericalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveSphericalWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveSphericalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveSphericalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveSphericalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveCylindricalWorkingVolume") == 0)
          {
            EffectiveCylindricalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveCylindricalWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveCylindricalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveCylindricalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveCylindricalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveUserDefinedWorkingVolume") == 0)
          {
            EffectiveUserDefinedWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveUserDefinedWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveUserDefinedWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveUserDefinedWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveUserDefinedWorkingVolume element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad EffectiveWorkingVolume type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (TemperatureCompensation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TemperatureCompensation");
      TemperatureCompensation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</TemperatureCompensation>\n");
    }
  if (Magnification)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Magnification");
      Magnification->printSelf(outFile);
      fprintf(outFile, "</Magnification>\n");
    }
  if (EffectiveScreenDiameter)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EffectiveScreenDiameter");
      EffectiveScreenDiameter->printSelf(outFile);
      fprintf(outFile, "</EffectiveScreenDiameter>\n");
    }
  if (ScreenMaterial)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ScreenMaterial");
      ScreenMaterial->printSelf(outFile);
      fprintf(outFile, "</ScreenMaterial>\n");
    }
  if (AngleResolution)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AngleResolution");
      AngleResolution->printSelf(outFile);
      fprintf(outFile, "</AngleResolution>\n");
    }
  if (SurfaceIlluminationLightSource)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SurfaceIlluminationLightSource");
      SurfaceIlluminationLightSource->printSelf(outFile);
      fprintf(outFile, "</SurfaceIlluminationLightSource>\n");
    }
  if (ContourIlluminationLightSource)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ContourIlluminationLightSource");
      ContourIlluminationLightSource->printSelf(outFile);
      fprintf(outFile, "</ContourIlluminationLightSource>\n");
    }
  if (MaxWorkpieceHeight)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxWorkpieceHeight");
      MaxWorkpieceHeight->printSelf(outFile);
      fprintf(outFile, "</MaxWorkpieceHeight>\n");
    }
  if (WorkingDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WorkingDistance");
      WorkingDistance->printSelf(outFile);
      fprintf(outFile, "</WorkingDistance>\n");
    }
  if (ToolIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToolIds");
      ToolIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ToolIds>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool OpticalComparatorType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in OpticalComparatorType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in OpticalComparatorType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in OpticalComparatorType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in OpticalComparatorType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

XmlDecimal * OpticalComparatorType::getMagnification()
{return Magnification;}

void OpticalComparatorType::setMagnification(XmlDecimal * MagnificationIn)
{Magnification = MagnificationIn;}

LinearValueType * OpticalComparatorType::getEffectiveScreenDiameter()
{return EffectiveScreenDiameter;}

void OpticalComparatorType::setEffectiveScreenDiameter(LinearValueType * EffectiveScreenDiameterIn)
{EffectiveScreenDiameter = EffectiveScreenDiameterIn;}

XmlString * OpticalComparatorType::getScreenMaterial()
{return ScreenMaterial;}

void OpticalComparatorType::setScreenMaterial(XmlString * ScreenMaterialIn)
{ScreenMaterial = ScreenMaterialIn;}

AngularValueType * OpticalComparatorType::getAngleResolution()
{return AngleResolution;}

void OpticalComparatorType::setAngleResolution(AngularValueType * AngleResolutionIn)
{AngleResolution = AngleResolutionIn;}

XmlString * OpticalComparatorType::getSurfaceIlluminationLightSource()
{return SurfaceIlluminationLightSource;}

void OpticalComparatorType::setSurfaceIlluminationLightSource(XmlString * SurfaceIlluminationLightSourceIn)
{SurfaceIlluminationLightSource = SurfaceIlluminationLightSourceIn;}

XmlString * OpticalComparatorType::getContourIlluminationLightSource()
{return ContourIlluminationLightSource;}

void OpticalComparatorType::setContourIlluminationLightSource(XmlString * ContourIlluminationLightSourceIn)
{ContourIlluminationLightSource = ContourIlluminationLightSourceIn;}

LinearValueType * OpticalComparatorType::getMaxWorkpieceHeight()
{return MaxWorkpieceHeight;}

void OpticalComparatorType::setMaxWorkpieceHeight(LinearValueType * MaxWorkpieceHeightIn)
{MaxWorkpieceHeight = MaxWorkpieceHeightIn;}

LinearValueType * OpticalComparatorType::getWorkingDistance()
{return WorkingDistance;}

void OpticalComparatorType::setWorkingDistance(LinearValueType * WorkingDistanceIn)
{WorkingDistance = WorkingDistanceIn;}

ArrayReferenceType * OpticalComparatorType::getToolIds()
{return ToolIds;}

void OpticalComparatorType::setToolIds(ArrayReferenceType * ToolIdsIn)
{ToolIds = ToolIdsIn;}

/* ***************************************************************** */

/* class ParallelLinkCMMSpeedsType

*/

ParallelLinkCMMSpeedsType::ParallelLinkCMMSpeedsType() :
  CMMSpeedsBaseType()
{
  MaxXTraverseSpeed = 0;
  MaxYTraverseSpeed = 0;
  MaxZTraverseSpeed = 0;
  MaxXProbingSpeed = 0;
  MaxYProbingSpeed = 0;
  MaxZProbingSpeed = 0;
  MaxXRotation = 0;
  MaxYRotation = 0;
  MaxZRotation = 0;
}

ParallelLinkCMMSpeedsType::ParallelLinkCMMSpeedsType(
 SpeedValueType * MaxXTraverseSpeedIn,
 SpeedValueType * MaxYTraverseSpeedIn,
 SpeedValueType * MaxZTraverseSpeedIn,
 SpeedValueType * MaxXProbingSpeedIn,
 SpeedValueType * MaxYProbingSpeedIn,
 SpeedValueType * MaxZProbingSpeedIn,
 UserDefinedUnitValueType * MaxXRotationIn,
 UserDefinedUnitValueType * MaxYRotationIn,
 UserDefinedUnitValueType * MaxZRotationIn) :
  CMMSpeedsBaseType()
{
  MaxXTraverseSpeed = MaxXTraverseSpeedIn;
  MaxYTraverseSpeed = MaxYTraverseSpeedIn;
  MaxZTraverseSpeed = MaxZTraverseSpeedIn;
  MaxXProbingSpeed = MaxXProbingSpeedIn;
  MaxYProbingSpeed = MaxYProbingSpeedIn;
  MaxZProbingSpeed = MaxZProbingSpeedIn;
  MaxXRotation = MaxXRotationIn;
  MaxYRotation = MaxYRotationIn;
  MaxZRotation = MaxZRotationIn;
}

ParallelLinkCMMSpeedsType::~ParallelLinkCMMSpeedsType()
{
  #ifndef NODESTRUCT
  delete MaxXTraverseSpeed;
  delete MaxYTraverseSpeed;
  delete MaxZTraverseSpeed;
  delete MaxXProbingSpeed;
  delete MaxYProbingSpeed;
  delete MaxZProbingSpeed;
  delete MaxXRotation;
  delete MaxYRotation;
  delete MaxZRotation;
  #endif
}

void ParallelLinkCMMSpeedsType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (MaxXTraverseSpeed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxXTraverseSpeed");
      MaxXTraverseSpeed->printSelf(outFile);
      fprintf(outFile, "</MaxXTraverseSpeed>\n");
    }
  if (MaxYTraverseSpeed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxYTraverseSpeed");
      MaxYTraverseSpeed->printSelf(outFile);
      fprintf(outFile, "</MaxYTraverseSpeed>\n");
    }
  if (MaxZTraverseSpeed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxZTraverseSpeed");
      MaxZTraverseSpeed->printSelf(outFile);
      fprintf(outFile, "</MaxZTraverseSpeed>\n");
    }
  if (MaxXProbingSpeed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxXProbingSpeed");
      MaxXProbingSpeed->printSelf(outFile);
      fprintf(outFile, "</MaxXProbingSpeed>\n");
    }
  if (MaxYProbingSpeed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxYProbingSpeed");
      MaxYProbingSpeed->printSelf(outFile);
      fprintf(outFile, "</MaxYProbingSpeed>\n");
    }
  if (MaxZProbingSpeed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxZProbingSpeed");
      MaxZProbingSpeed->printSelf(outFile);
      fprintf(outFile, "</MaxZProbingSpeed>\n");
    }
  if (MaxXRotation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxXRotation");
      MaxXRotation->printSelf(outFile);
      fprintf(outFile, "</MaxXRotation>\n");
    }
  if (MaxYRotation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxYRotation");
      MaxYRotation->printSelf(outFile);
      fprintf(outFile, "</MaxYRotation>\n");
    }
  if (MaxZRotation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxZRotation");
      MaxZRotation->printSelf(outFile);
      fprintf(outFile, "</MaxZRotation>\n");
    }
  doSpaces(-INDENT, outFile);
}

SpeedValueType * ParallelLinkCMMSpeedsType::getMaxXTraverseSpeed()
{return MaxXTraverseSpeed;}

void ParallelLinkCMMSpeedsType::setMaxXTraverseSpeed(SpeedValueType * MaxXTraverseSpeedIn)
{MaxXTraverseSpeed = MaxXTraverseSpeedIn;}

SpeedValueType * ParallelLinkCMMSpeedsType::getMaxYTraverseSpeed()
{return MaxYTraverseSpeed;}

void ParallelLinkCMMSpeedsType::setMaxYTraverseSpeed(SpeedValueType * MaxYTraverseSpeedIn)
{MaxYTraverseSpeed = MaxYTraverseSpeedIn;}

SpeedValueType * ParallelLinkCMMSpeedsType::getMaxZTraverseSpeed()
{return MaxZTraverseSpeed;}

void ParallelLinkCMMSpeedsType::setMaxZTraverseSpeed(SpeedValueType * MaxZTraverseSpeedIn)
{MaxZTraverseSpeed = MaxZTraverseSpeedIn;}

SpeedValueType * ParallelLinkCMMSpeedsType::getMaxXProbingSpeed()
{return MaxXProbingSpeed;}

void ParallelLinkCMMSpeedsType::setMaxXProbingSpeed(SpeedValueType * MaxXProbingSpeedIn)
{MaxXProbingSpeed = MaxXProbingSpeedIn;}

SpeedValueType * ParallelLinkCMMSpeedsType::getMaxYProbingSpeed()
{return MaxYProbingSpeed;}

void ParallelLinkCMMSpeedsType::setMaxYProbingSpeed(SpeedValueType * MaxYProbingSpeedIn)
{MaxYProbingSpeed = MaxYProbingSpeedIn;}

SpeedValueType * ParallelLinkCMMSpeedsType::getMaxZProbingSpeed()
{return MaxZProbingSpeed;}

void ParallelLinkCMMSpeedsType::setMaxZProbingSpeed(SpeedValueType * MaxZProbingSpeedIn)
{MaxZProbingSpeed = MaxZProbingSpeedIn;}

UserDefinedUnitValueType * ParallelLinkCMMSpeedsType::getMaxXRotation()
{return MaxXRotation;}

void ParallelLinkCMMSpeedsType::setMaxXRotation(UserDefinedUnitValueType * MaxXRotationIn)
{MaxXRotation = MaxXRotationIn;}

UserDefinedUnitValueType * ParallelLinkCMMSpeedsType::getMaxYRotation()
{return MaxYRotation;}

void ParallelLinkCMMSpeedsType::setMaxYRotation(UserDefinedUnitValueType * MaxYRotationIn)
{MaxYRotation = MaxYRotationIn;}

UserDefinedUnitValueType * ParallelLinkCMMSpeedsType::getMaxZRotation()
{return MaxZRotation;}

void ParallelLinkCMMSpeedsType::setMaxZRotation(UserDefinedUnitValueType * MaxZRotationIn)
{MaxZRotation = MaxZRotationIn;}

/* ***************************************************************** */

/* class ParallelLinkCMMType

*/

ParallelLinkCMMType::ParallelLinkCMMType() :
  CMMType()
{
  CMMSpeeds = 0;
  AxesTravelDistance = 0;
  AxesRotationAngle = 0;
  AxisBacklash = 0;
  AxisRepeatability = 0;
  MaxLoad = 0;
  StageMaterial = 0;
  MaxHoldingForce = 0;
  MotorType = 0;
  LinksStiffness = 0;
  ToolIds = 0;
}

ParallelLinkCMMType::ParallelLinkCMMType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 ResolutionBaseType * ResolutionIn,
 WorkingVolumeBaseType * WorkingVolumeIn,
 EffectiveWorkingVolumeBaseType * EffectiveWorkingVolumeIn,
 TemperatureCompensationType * TemperatureCompensationIn,
 CMMSpeedsBaseType * CMMSpeedsIn,
 XYZLinearSpecificationType * AxesTravelDistanceIn,
 AngularValueType * AxesRotationAngleIn,
 XYZLinearSpecificationType * AxisBacklashIn,
 XYZLinearSpecificationType * AxisRepeatabilityIn,
 MassValueType * MaxLoadIn,
 XmlString * StageMaterialIn,
 ForceValueType * MaxHoldingForceIn,
 XmlString * MotorTypeIn,
 StiffnessType * LinksStiffnessIn,
 ArrayReferenceType * ToolIdsIn) :
  CMMType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    ResolutionIn,
    WorkingVolumeIn,
    EffectiveWorkingVolumeIn,
    TemperatureCompensationIn)
{
  CMMSpeeds = CMMSpeedsIn;
  AxesTravelDistance = AxesTravelDistanceIn;
  AxesRotationAngle = AxesRotationAngleIn;
  AxisBacklash = AxisBacklashIn;
  AxisRepeatability = AxisRepeatabilityIn;
  MaxLoad = MaxLoadIn;
  StageMaterial = StageMaterialIn;
  MaxHoldingForce = MaxHoldingForceIn;
  MotorType = MotorTypeIn;
  LinksStiffness = LinksStiffnessIn;
  ToolIds = ToolIdsIn;
}

ParallelLinkCMMType::ParallelLinkCMMType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 ResolutionBaseType * ResolutionIn,
 WorkingVolumeBaseType * WorkingVolumeIn,
 EffectiveWorkingVolumeBaseType * EffectiveWorkingVolumeIn,
 TemperatureCompensationType * TemperatureCompensationIn,
 CMMSpeedsBaseType * CMMSpeedsIn,
 XYZLinearSpecificationType * AxesTravelDistanceIn,
 AngularValueType * AxesRotationAngleIn,
 XYZLinearSpecificationType * AxisBacklashIn,
 XYZLinearSpecificationType * AxisRepeatabilityIn,
 MassValueType * MaxLoadIn,
 XmlString * StageMaterialIn,
 ForceValueType * MaxHoldingForceIn,
 XmlString * MotorTypeIn,
 StiffnessType * LinksStiffnessIn,
 ArrayReferenceType * ToolIdsIn) :
  CMMType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    ResolutionIn,
    WorkingVolumeIn,
    EffectiveWorkingVolumeIn,
    TemperatureCompensationIn)
{
  CMMSpeeds = CMMSpeedsIn;
  AxesTravelDistance = AxesTravelDistanceIn;
  AxesRotationAngle = AxesRotationAngleIn;
  AxisBacklash = AxisBacklashIn;
  AxisRepeatability = AxisRepeatabilityIn;
  MaxLoad = MaxLoadIn;
  StageMaterial = StageMaterialIn;
  MaxHoldingForce = MaxHoldingForceIn;
  MotorType = MotorTypeIn;
  LinksStiffness = LinksStiffnessIn;
  ToolIds = ToolIdsIn;
}

ParallelLinkCMMType::~ParallelLinkCMMType()
{
  #ifndef NODESTRUCT
  delete CMMSpeeds;
  delete AxesTravelDistance;
  delete AxesRotationAngle;
  delete AxisBacklash;
  delete AxisRepeatability;
  delete MaxLoad;
  delete StageMaterial;
  delete MaxHoldingForce;
  delete MotorType;
  delete LinksStiffness;
  delete ToolIds;
  #endif
}

void ParallelLinkCMMType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Calibrations)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Calibrations");
      Calibrations->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Calibrations>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (Resolution)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (Resolution->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(Resolution->getprintElement(), "LinearResolution") == 0)
          {
            LinearResolutionType * typ;
            if ((typ = dynamic_cast<LinearResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<LinearResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LinearResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad LinearResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "CartesianResolution") == 0)
          {
            CartesianResolutionType * typ;
            if ((typ = dynamic_cast<CartesianResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<CartesianResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "SphericalResolution") == 0)
          {
            SphericalResolutionType * typ;
            if ((typ = dynamic_cast<SphericalResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<SphericalResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "UserDefinedResolution") == 0)
          {
            UserDefinedResolutionType * typ;
            if ((typ = dynamic_cast<UserDefinedResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<UserDefinedResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedResolution element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad Resolution type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (WorkingVolume)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (WorkingVolume->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(WorkingVolume->getprintElement(), "ClosedShellSetWorkingVolume") == 0)
          {
            ClosedShellSetWorkingVolumeType * typ;
            if ((typ = dynamic_cast<ClosedShellSetWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<ClosedShellSetWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ClosedShellSetWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad ClosedShellSetWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "CartesianWorkingVolume") == 0)
          {
            CartesianWorkingVolumeType * typ;
            if ((typ = dynamic_cast<CartesianWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<CartesianWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "SphericalWorkingVolume") == 0)
          {
            SphericalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<SphericalWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<SphericalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "CylindricalWorkingVolume") == 0)
          {
            CylindricalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<CylindricalWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<CylindricalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CylindricalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad CylindricalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "UserDefinedWorkingVolume") == 0)
          {
            UserDefinedWorkingVolumeType * typ;
            if ((typ = dynamic_cast<UserDefinedWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<UserDefinedWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedWorkingVolume element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad WorkingVolume type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (EffectiveWorkingVolume)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (EffectiveWorkingVolume->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveClosedShellSetWorkingVolume") == 0)
          {
            EffectiveClosedShellSetWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveClosedShellSetWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveClosedShellSetWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveClosedShellSetWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveClosedShellSetWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveCartesianWorkingVolume") == 0)
          {
            EffectiveCartesianWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveCartesianWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveCartesianWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveCartesianWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveCartesianWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveSphericalWorkingVolume") == 0)
          {
            EffectiveSphericalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveSphericalWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveSphericalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveSphericalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveSphericalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveCylindricalWorkingVolume") == 0)
          {
            EffectiveCylindricalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveCylindricalWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveCylindricalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveCylindricalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveCylindricalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveUserDefinedWorkingVolume") == 0)
          {
            EffectiveUserDefinedWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveUserDefinedWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveUserDefinedWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveUserDefinedWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveUserDefinedWorkingVolume element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad EffectiveWorkingVolume type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (TemperatureCompensation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TemperatureCompensation");
      TemperatureCompensation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</TemperatureCompensation>\n");
    }
  if (CMMSpeeds)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (CMMSpeeds->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(CMMSpeeds->getprintElement(), "CartesianCMMSpeeds") == 0)
          {
            CartesianCMMSpeedsType * typ;
            if ((typ = dynamic_cast<CartesianCMMSpeedsType *>(CMMSpeeds)))
              {
                fprintf(outFile, "<CartesianCMMSpeeds");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianCMMSpeeds>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianCMMSpeeds element\n");
                exit(1);
              }
          }
        else if (strcmp(CMMSpeeds->getprintElement(), "ParallelLinkCMMSpeeds") == 0)
          {
            ParallelLinkCMMSpeedsType * typ;
            if ((typ = dynamic_cast<ParallelLinkCMMSpeedsType *>(CMMSpeeds)))
              {
                fprintf(outFile, "<ParallelLinkCMMSpeeds");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ParallelLinkCMMSpeeds>\n");
              }
            else
              {
                fprintf(stderr, "bad ParallelLinkCMMSpeeds element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad CMMSpeeds type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (AxesTravelDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AxesTravelDistance");
      AxesTravelDistance->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</AxesTravelDistance>\n");
    }
  if (AxesRotationAngle)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AxesRotationAngle");
      AxesRotationAngle->printSelf(outFile);
      fprintf(outFile, "</AxesRotationAngle>\n");
    }
  if (AxisBacklash)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AxisBacklash");
      AxisBacklash->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</AxisBacklash>\n");
    }
  if (AxisRepeatability)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AxisRepeatability");
      AxisRepeatability->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</AxisRepeatability>\n");
    }
  if (MaxLoad)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxLoad");
      MaxLoad->printSelf(outFile);
      fprintf(outFile, "</MaxLoad>\n");
    }
  if (StageMaterial)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StageMaterial");
      StageMaterial->printSelf(outFile);
      fprintf(outFile, "</StageMaterial>\n");
    }
  if (MaxHoldingForce)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxHoldingForce");
      MaxHoldingForce->printSelf(outFile);
      fprintf(outFile, "</MaxHoldingForce>\n");
    }
  if (MotorType)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MotorType");
      MotorType->printSelf(outFile);
      fprintf(outFile, "</MotorType>\n");
    }
  if (LinksStiffness)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LinksStiffness");
      LinksStiffness->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</LinksStiffness>\n");
    }
  if (ToolIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToolIds");
      ToolIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ToolIds>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ParallelLinkCMMType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ParallelLinkCMMType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ParallelLinkCMMType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ParallelLinkCMMType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ParallelLinkCMMType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

CMMSpeedsBaseType * ParallelLinkCMMType::getCMMSpeeds()
{return CMMSpeeds;}

void ParallelLinkCMMType::setCMMSpeeds(CMMSpeedsBaseType * CMMSpeedsIn)
{CMMSpeeds = CMMSpeedsIn;}

XYZLinearSpecificationType * ParallelLinkCMMType::getAxesTravelDistance()
{return AxesTravelDistance;}

void ParallelLinkCMMType::setAxesTravelDistance(XYZLinearSpecificationType * AxesTravelDistanceIn)
{AxesTravelDistance = AxesTravelDistanceIn;}

AngularValueType * ParallelLinkCMMType::getAxesRotationAngle()
{return AxesRotationAngle;}

void ParallelLinkCMMType::setAxesRotationAngle(AngularValueType * AxesRotationAngleIn)
{AxesRotationAngle = AxesRotationAngleIn;}

XYZLinearSpecificationType * ParallelLinkCMMType::getAxisBacklash()
{return AxisBacklash;}

void ParallelLinkCMMType::setAxisBacklash(XYZLinearSpecificationType * AxisBacklashIn)
{AxisBacklash = AxisBacklashIn;}

XYZLinearSpecificationType * ParallelLinkCMMType::getAxisRepeatability()
{return AxisRepeatability;}

void ParallelLinkCMMType::setAxisRepeatability(XYZLinearSpecificationType * AxisRepeatabilityIn)
{AxisRepeatability = AxisRepeatabilityIn;}

MassValueType * ParallelLinkCMMType::getMaxLoad()
{return MaxLoad;}

void ParallelLinkCMMType::setMaxLoad(MassValueType * MaxLoadIn)
{MaxLoad = MaxLoadIn;}

XmlString * ParallelLinkCMMType::getStageMaterial()
{return StageMaterial;}

void ParallelLinkCMMType::setStageMaterial(XmlString * StageMaterialIn)
{StageMaterial = StageMaterialIn;}

ForceValueType * ParallelLinkCMMType::getMaxHoldingForce()
{return MaxHoldingForce;}

void ParallelLinkCMMType::setMaxHoldingForce(ForceValueType * MaxHoldingForceIn)
{MaxHoldingForce = MaxHoldingForceIn;}

XmlString * ParallelLinkCMMType::getMotorType()
{return MotorType;}

void ParallelLinkCMMType::setMotorType(XmlString * MotorTypeIn)
{MotorType = MotorTypeIn;}

StiffnessType * ParallelLinkCMMType::getLinksStiffness()
{return LinksStiffness;}

void ParallelLinkCMMType::setLinksStiffness(StiffnessType * LinksStiffnessIn)
{LinksStiffness = LinksStiffnessIn;}

ArrayReferenceType * ParallelLinkCMMType::getToolIds()
{return ToolIds;}

void ParallelLinkCMMType::setToolIds(ArrayReferenceType * ToolIdsIn)
{ToolIds = ToolIdsIn;}

/* ***************************************************************** */

/* class PointAccuracyTestType

*/

PointAccuracyTestType::PointAccuracyTestType() :
  CMMAccuracyTestBaseType()
{
  Accuracy = 0;
}

PointAccuracyTestType::PointAccuracyTestType(
 LinearValueType * AccuracyIn) :
  CMMAccuracyTestBaseType()
{
  Accuracy = AccuracyIn;
}

PointAccuracyTestType::~PointAccuracyTestType()
{
  #ifndef NODESTRUCT
  delete Accuracy;
  #endif
}

void PointAccuracyTestType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Accuracy");
  Accuracy->printSelf(outFile);
  fprintf(outFile, "</Accuracy>\n");
  doSpaces(-INDENT, outFile);
}

LinearValueType * PointAccuracyTestType::getAccuracy()
{return Accuracy;}

void PointAccuracyTestType::setAccuracy(LinearValueType * AccuracyIn)
{Accuracy = AccuracyIn;}

/* ***************************************************************** */

/* class ProbeTipType

*/

ProbeTipType::ProbeTipType() :
  MeasurementResourceBaseType()
{
  TipEndGeometry = 0;
  TipEndDiameter = 0;
  TipEndMaterial = 0;
  StemMaterial = 0;
  StemDiameter = 0;
}

ProbeTipType::ProbeTipType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 TipEndGeometryType * TipEndGeometryIn,
 LinearValueType * TipEndDiameterIn,
 XmlString * TipEndMaterialIn,
 XmlString * StemMaterialIn,
 LinearValueType * StemDiameterIn) :
  MeasurementResourceBaseType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  TipEndGeometry = TipEndGeometryIn;
  TipEndDiameter = TipEndDiameterIn;
  TipEndMaterial = TipEndMaterialIn;
  StemMaterial = StemMaterialIn;
  StemDiameter = StemDiameterIn;
}

ProbeTipType::ProbeTipType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 TipEndGeometryType * TipEndGeometryIn,
 LinearValueType * TipEndDiameterIn,
 XmlString * TipEndMaterialIn,
 XmlString * StemMaterialIn,
 LinearValueType * StemDiameterIn) :
  MeasurementResourceBaseType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  TipEndGeometry = TipEndGeometryIn;
  TipEndDiameter = TipEndDiameterIn;
  TipEndMaterial = TipEndMaterialIn;
  StemMaterial = StemMaterialIn;
  StemDiameter = StemDiameterIn;
}

ProbeTipType::~ProbeTipType()
{
  #ifndef NODESTRUCT
  delete TipEndGeometry;
  delete TipEndDiameter;
  delete TipEndMaterial;
  delete StemMaterial;
  delete StemDiameter;
  #endif
}

void ProbeTipType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (TipEndGeometry)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TipEndGeometry");
      TipEndGeometry->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</TipEndGeometry>\n");
    }
  if (TipEndDiameter)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TipEndDiameter");
      TipEndDiameter->printSelf(outFile);
      fprintf(outFile, "</TipEndDiameter>\n");
    }
  if (TipEndMaterial)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TipEndMaterial");
      TipEndMaterial->printSelf(outFile);
      fprintf(outFile, "</TipEndMaterial>\n");
    }
  if (StemMaterial)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StemMaterial");
      StemMaterial->printSelf(outFile);
      fprintf(outFile, "</StemMaterial>\n");
    }
  if (StemDiameter)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StemDiameter");
      StemDiameter->printSelf(outFile);
      fprintf(outFile, "</StemDiameter>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ProbeTipType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ProbeTipType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ProbeTipType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ProbeTipType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ProbeTipType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

TipEndGeometryType * ProbeTipType::getTipEndGeometry()
{return TipEndGeometry;}

void ProbeTipType::setTipEndGeometry(TipEndGeometryType * TipEndGeometryIn)
{TipEndGeometry = TipEndGeometryIn;}

LinearValueType * ProbeTipType::getTipEndDiameter()
{return TipEndDiameter;}

void ProbeTipType::setTipEndDiameter(LinearValueType * TipEndDiameterIn)
{TipEndDiameter = TipEndDiameterIn;}

XmlString * ProbeTipType::getTipEndMaterial()
{return TipEndMaterial;}

void ProbeTipType::setTipEndMaterial(XmlString * TipEndMaterialIn)
{TipEndMaterial = TipEndMaterialIn;}

XmlString * ProbeTipType::getStemMaterial()
{return StemMaterial;}

void ProbeTipType::setStemMaterial(XmlString * StemMaterialIn)
{StemMaterial = StemMaterialIn;}

LinearValueType * ProbeTipType::getStemDiameter()
{return StemDiameter;}

void ProbeTipType::setStemDiameter(LinearValueType * StemDiameterIn)
{StemDiameter = StemDiameterIn;}

/* ***************************************************************** */

/* class QualificationType

*/

QualificationType::QualificationType()
{
  Attributes = 0;
  Description = 0;
}

QualificationType::QualificationType(
 AttributesType * AttributesIn,
 XmlString * DescriptionIn)
{
  Attributes = AttributesIn;
  Description = DescriptionIn;
}

QualificationType::~QualificationType()
{
  #ifndef NODESTRUCT
  delete Attributes;
  delete Description;
  #endif
}

void QualificationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Description");
  Description->printSelf(outFile);
  fprintf(outFile, "</Description>\n");
  doSpaces(-INDENT, outFile);
}

AttributesType * QualificationType::getAttributes()
{return Attributes;}

void QualificationType::setAttributes(AttributesType * AttributesIn)
{Attributes = AttributesIn;}

XmlString * QualificationType::getDescription()
{return Description;}

void QualificationType::setDescription(XmlString * DescriptionIn)
{Description = DescriptionIn;}

/* ***************************************************************** */

/* class QualificationTypeLisd

*/

QualificationTypeLisd::QualificationTypeLisd() {}

QualificationTypeLisd::QualificationTypeLisd(QualificationType * aQualificationType)
{
  push_back(aQualificationType);
}

QualificationTypeLisd::~QualificationTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<QualificationType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void QualificationTypeLisd::printSelf(FILE * outFile)
{
  std::list<QualificationType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class QualificationsType

*/

QualificationsType::QualificationsType()
{
  n = 0;
  Qualification = 0;
}

QualificationsType::QualificationsType(
 QualificationTypeLisd * QualificationIn)
{
  n = 0;
  Qualification = QualificationIn;
}

QualificationsType::QualificationsType(
 NaturalType * nIn,
 QualificationTypeLisd * QualificationIn)
{
  n = nIn;
  Qualification = QualificationIn;
}

QualificationsType::~QualificationsType()
{
  #ifndef NODESTRUCT
  delete n;
  delete Qualification;
  #endif
}

void QualificationsType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!Qualification)
      {
        fprintf(stderr, "Qualification list is missing\n");
        exit(1);
      }
    if (Qualification->size() == 0)
      {
        fprintf(stderr, "Qualification list is empty\n");
        exit(1);
      }
    if (Qualification->size() < 1)
      {
        fprintf(stderr,
                "size of Qualification list (%d) less than minimum required (1)\n",
                (int)Qualification->size());
        exit(1);
      }
    std::list<QualificationType *>::iterator iter;
    for (iter = Qualification->begin();
         iter != Qualification->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<Qualification");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</Qualification>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool QualificationsType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in QualificationsType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in QualificationsType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in QualificationsType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in QualificationsType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * QualificationsType::getn()
{return n;}

void QualificationsType::setn(NaturalType * nIn)
{n = nIn;}

QualificationTypeLisd * QualificationsType::getQualification()
{return Qualification;}

void QualificationsType::setQualification(QualificationTypeLisd * QualificationIn)
{Qualification = QualificationIn;}

/* ***************************************************************** */

/* class RAPZResolutionType

*/

RAPZResolutionType::RAPZResolutionType()
{
  RadialResolution = 0;
  AzimuthalAngleResolution = 0;
  PolarAngleResolution = 0;
}

RAPZResolutionType::RAPZResolutionType(
 LinearValueType * RadialResolutionIn,
 AngularValueType * AzimuthalAngleResolutionIn,
 AngularValueType * PolarAngleResolutionIn)
{
  RadialResolution = RadialResolutionIn;
  AzimuthalAngleResolution = AzimuthalAngleResolutionIn;
  PolarAngleResolution = PolarAngleResolutionIn;
}

RAPZResolutionType::~RAPZResolutionType()
{
  #ifndef NODESTRUCT
  delete RadialResolution;
  delete AzimuthalAngleResolution;
  delete PolarAngleResolution;
  #endif
}

void RAPZResolutionType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<RadialResolution");
  RadialResolution->printSelf(outFile);
  fprintf(outFile, "</RadialResolution>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<AzimuthalAngleResolution");
  AzimuthalAngleResolution->printSelf(outFile);
  fprintf(outFile, "</AzimuthalAngleResolution>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<PolarAngleResolution");
  PolarAngleResolution->printSelf(outFile);
  fprintf(outFile, "</PolarAngleResolution>\n");
  doSpaces(-INDENT, outFile);
}

LinearValueType * RAPZResolutionType::getRadialResolution()
{return RadialResolution;}

void RAPZResolutionType::setRadialResolution(LinearValueType * RadialResolutionIn)
{RadialResolution = RadialResolutionIn;}

AngularValueType * RAPZResolutionType::getAzimuthalAngleResolution()
{return AzimuthalAngleResolution;}

void RAPZResolutionType::setAzimuthalAngleResolution(AngularValueType * AzimuthalAngleResolutionIn)
{AzimuthalAngleResolution = AzimuthalAngleResolutionIn;}

AngularValueType * RAPZResolutionType::getPolarAngleResolution()
{return PolarAngleResolution;}

void RAPZResolutionType::setPolarAngleResolution(AngularValueType * PolarAngleResolutionIn)
{PolarAngleResolution = PolarAngleResolutionIn;}

/* ***************************************************************** */

/* class ResolutionBaseType

*/

ResolutionBaseType::ResolutionBaseType()
{}

ResolutionBaseType::~ResolutionBaseType() {}

void ResolutionBaseType::printSelf(FILE * outFile)
{
  fprintf(outFile, "/>\n");
}

/* ***************************************************************** */

/* class RotaryAxisType

*/

RotaryAxisType::RotaryAxisType() :
  UserAxisBaseType()
{
  MinRotaryAxis = 0;
  MaxRotaryAxis = 0;
}

RotaryAxisType::RotaryAxisType(
 AngularValueType * MinRotaryAxisIn,
 AngularValueType * MaxRotaryAxisIn) :
  UserAxisBaseType()
{
  MinRotaryAxis = MinRotaryAxisIn;
  MaxRotaryAxis = MaxRotaryAxisIn;
}

RotaryAxisType::~RotaryAxisType()
{
  #ifndef NODESTRUCT
  delete MinRotaryAxis;
  delete MaxRotaryAxis;
  #endif
}

void RotaryAxisType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<MinRotaryAxis");
  MinRotaryAxis->printSelf(outFile);
  fprintf(outFile, "</MinRotaryAxis>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxRotaryAxis");
  MaxRotaryAxis->printSelf(outFile);
  fprintf(outFile, "</MaxRotaryAxis>\n");
  doSpaces(-INDENT, outFile);
}

AngularValueType * RotaryAxisType::getMinRotaryAxis()
{return MinRotaryAxis;}

void RotaryAxisType::setMinRotaryAxis(AngularValueType * MinRotaryAxisIn)
{MinRotaryAxis = MinRotaryAxisIn;}

AngularValueType * RotaryAxisType::getMaxRotaryAxis()
{return MaxRotaryAxis;}

void RotaryAxisType::setMaxRotaryAxis(AngularValueType * MaxRotaryAxisIn)
{MaxRotaryAxis = MaxRotaryAxisIn;}

/* ***************************************************************** */

/* class RotaryTableType

*/

RotaryTableType::RotaryTableType()
{
  LocationOnCMM = 0;
  AxisDirection = 0;
  ZeroIndexDirection = 0;
  TableRadius = 0;
  TableErrors = 0;
}

RotaryTableType::RotaryTableType(
 PointType * LocationOnCMMIn,
 UnitVectorType * AxisDirectionIn,
 UnitVectorType * ZeroIndexDirectionIn,
 LinearValueType * TableRadiusIn,
 TableErrorsType * TableErrorsIn)
{
  LocationOnCMM = LocationOnCMMIn;
  AxisDirection = AxisDirectionIn;
  ZeroIndexDirection = ZeroIndexDirectionIn;
  TableRadius = TableRadiusIn;
  TableErrors = TableErrorsIn;
}

RotaryTableType::~RotaryTableType()
{
  #ifndef NODESTRUCT
  delete LocationOnCMM;
  delete AxisDirection;
  delete ZeroIndexDirection;
  delete TableRadius;
  delete TableErrors;
  #endif
}

void RotaryTableType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<LocationOnCMM");
  LocationOnCMM->printSelf(outFile);
  fprintf(outFile, "</LocationOnCMM>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<AxisDirection");
  AxisDirection->printSelf(outFile);
  fprintf(outFile, "</AxisDirection>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<ZeroIndexDirection");
  ZeroIndexDirection->printSelf(outFile);
  fprintf(outFile, "</ZeroIndexDirection>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<TableRadius");
  TableRadius->printSelf(outFile);
  fprintf(outFile, "</TableRadius>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<TableErrors");
  TableErrors->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</TableErrors>\n");
  doSpaces(-INDENT, outFile);
}

PointType * RotaryTableType::getLocationOnCMM()
{return LocationOnCMM;}

void RotaryTableType::setLocationOnCMM(PointType * LocationOnCMMIn)
{LocationOnCMM = LocationOnCMMIn;}

UnitVectorType * RotaryTableType::getAxisDirection()
{return AxisDirection;}

void RotaryTableType::setAxisDirection(UnitVectorType * AxisDirectionIn)
{AxisDirection = AxisDirectionIn;}

UnitVectorType * RotaryTableType::getZeroIndexDirection()
{return ZeroIndexDirection;}

void RotaryTableType::setZeroIndexDirection(UnitVectorType * ZeroIndexDirectionIn)
{ZeroIndexDirection = ZeroIndexDirectionIn;}

LinearValueType * RotaryTableType::getTableRadius()
{return TableRadius;}

void RotaryTableType::setTableRadius(LinearValueType * TableRadiusIn)
{TableRadius = TableRadiusIn;}

TableErrorsType * RotaryTableType::getTableErrors()
{return TableErrors;}

void RotaryTableType::setTableErrors(TableErrorsType * TableErrorsIn)
{TableErrors = TableErrorsIn;}

/* ***************************************************************** */

/* class ScaleReferenceEnumType

*/

ScaleReferenceEnumType::ScaleReferenceEnumType() :
  XmlNMTOKEN()
{
}

ScaleReferenceEnumType::ScaleReferenceEnumType(
 const char * valIn) :
  XmlNMTOKEN(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "SCALE_ABSOLUTE") &&
           strcmp(val.c_str(), "SCALE_INCREMENTAL"));
}

ScaleReferenceEnumType::~ScaleReferenceEnumType() {}

bool ScaleReferenceEnumType::ScaleReferenceEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "SCALE_ABSOLUTE") &&
          strcmp(val.c_str(), "SCALE_INCREMENTAL"));
}

void ScaleReferenceEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "ScaleReferenceEnumType");
}

void ScaleReferenceEnumType::printSelf(FILE * outFile)
{
  if (ScaleReferenceEnumTypeIsBad())
    {
      fprintf(stderr, "bad ScaleReferenceEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::printSelf(outFile);
}

void ScaleReferenceEnumType::oPrintSelf(FILE * outFile)
{
  if (ScaleReferenceEnumTypeIsBad())
    {
      fprintf(stderr, "bad ScaleReferenceEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class SensorType

*/

SensorType::SensorType() :
  MeasurementResourceBaseType()
{
  ProtectionClass = 0;
  LinearityError = 0;
  Repeatability = 0;
  Sensitivity = 0;
  Resolution = 0;
  EnvironmentalRange = 0;
}

SensorType::SensorType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 XmlString * ProtectionClassIn,
 XmlString * LinearityErrorIn,
 LinearValueType * RepeatabilityIn,
 XmlDecimal * SensitivityIn,
 LinearValueType * ResolutionIn,
 EnvironmentalRangeType * EnvironmentalRangeIn) :
  MeasurementResourceBaseType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  ProtectionClass = ProtectionClassIn;
  LinearityError = LinearityErrorIn;
  Repeatability = RepeatabilityIn;
  Sensitivity = SensitivityIn;
  Resolution = ResolutionIn;
  EnvironmentalRange = EnvironmentalRangeIn;
}

SensorType::SensorType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 XmlString * ProtectionClassIn,
 XmlString * LinearityErrorIn,
 LinearValueType * RepeatabilityIn,
 XmlDecimal * SensitivityIn,
 LinearValueType * ResolutionIn,
 EnvironmentalRangeType * EnvironmentalRangeIn) :
  MeasurementResourceBaseType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  ProtectionClass = ProtectionClassIn;
  LinearityError = LinearityErrorIn;
  Repeatability = RepeatabilityIn;
  Sensitivity = SensitivityIn;
  Resolution = ResolutionIn;
  EnvironmentalRange = EnvironmentalRangeIn;
}

SensorType::~SensorType()
{
  #ifndef NODESTRUCT
  delete ProtectionClass;
  delete LinearityError;
  delete Repeatability;
  delete Sensitivity;
  delete Resolution;
  delete EnvironmentalRange;
  #endif
}

void SensorType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (ProtectionClass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProtectionClass");
      ProtectionClass->printSelf(outFile);
      fprintf(outFile, "</ProtectionClass>\n");
    }
  if (LinearityError)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LinearityError");
      LinearityError->printSelf(outFile);
      fprintf(outFile, "</LinearityError>\n");
    }
  if (Repeatability)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Repeatability");
      Repeatability->printSelf(outFile);
      fprintf(outFile, "</Repeatability>\n");
    }
  if (Sensitivity)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Sensitivity");
      Sensitivity->printSelf(outFile);
      fprintf(outFile, "</Sensitivity>\n");
    }
  if (Resolution)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Resolution");
      Resolution->printSelf(outFile);
      fprintf(outFile, "</Resolution>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SensorType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SensorType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SensorType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SensorType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SensorType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

XmlString * SensorType::getProtectionClass()
{return ProtectionClass;}

void SensorType::setProtectionClass(XmlString * ProtectionClassIn)
{ProtectionClass = ProtectionClassIn;}

XmlString * SensorType::getLinearityError()
{return LinearityError;}

void SensorType::setLinearityError(XmlString * LinearityErrorIn)
{LinearityError = LinearityErrorIn;}

LinearValueType * SensorType::getRepeatability()
{return Repeatability;}

void SensorType::setRepeatability(LinearValueType * RepeatabilityIn)
{Repeatability = RepeatabilityIn;}

XmlDecimal * SensorType::getSensitivity()
{return Sensitivity;}

void SensorType::setSensitivity(XmlDecimal * SensitivityIn)
{Sensitivity = SensitivityIn;}

LinearValueType * SensorType::getResolution()
{return Resolution;}

void SensorType::setResolution(LinearValueType * ResolutionIn)
{Resolution = ResolutionIn;}

EnvironmentalRangeType * SensorType::getEnvironmentalRange()
{return EnvironmentalRange;}

void SensorType::setEnvironmentalRange(EnvironmentalRangeType * EnvironmentalRangeIn)
{EnvironmentalRange = EnvironmentalRangeIn;}

/* ***************************************************************** */

/* class SimpleTactileProbeSensorType

*/

SimpleTactileProbeSensorType::SimpleTactileProbeSensorType() :
  TactileProbeSensorBaseType()
{
  Qualifications = 0;
  Length = 0;
  TipEndGeometry = 0;
  TipEndDiameter = 0;
  TipEndMaterial = 0;
  StemMaterial = 0;
  StemDiameter = 0;
}

SimpleTactileProbeSensorType::SimpleTactileProbeSensorType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 XmlString * ProtectionClassIn,
 XmlString * LinearityErrorIn,
 LinearValueType * RepeatabilityIn,
 XmlDecimal * SensitivityIn,
 LinearValueType * ResolutionIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 QualificationsType * QualificationsIn,
 LinearValueType * LengthIn,
 TipEndGeometryType * TipEndGeometryIn,
 LinearValueType * TipEndDiameterIn,
 XmlString * TipEndMaterialIn,
 XmlString * StemMaterialIn,
 LinearValueType * StemDiameterIn) :
  TactileProbeSensorBaseType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    ProtectionClassIn,
    LinearityErrorIn,
    RepeatabilityIn,
    SensitivityIn,
    ResolutionIn,
    EnvironmentalRangeIn)
{
  Qualifications = QualificationsIn;
  Length = LengthIn;
  TipEndGeometry = TipEndGeometryIn;
  TipEndDiameter = TipEndDiameterIn;
  TipEndMaterial = TipEndMaterialIn;
  StemMaterial = StemMaterialIn;
  StemDiameter = StemDiameterIn;
}

SimpleTactileProbeSensorType::SimpleTactileProbeSensorType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 XmlString * ProtectionClassIn,
 XmlString * LinearityErrorIn,
 LinearValueType * RepeatabilityIn,
 XmlDecimal * SensitivityIn,
 LinearValueType * ResolutionIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 QualificationsType * QualificationsIn,
 LinearValueType * LengthIn,
 TipEndGeometryType * TipEndGeometryIn,
 LinearValueType * TipEndDiameterIn,
 XmlString * TipEndMaterialIn,
 XmlString * StemMaterialIn,
 LinearValueType * StemDiameterIn) :
  TactileProbeSensorBaseType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    ProtectionClassIn,
    LinearityErrorIn,
    RepeatabilityIn,
    SensitivityIn,
    ResolutionIn,
    EnvironmentalRangeIn)
{
  Qualifications = QualificationsIn;
  Length = LengthIn;
  TipEndGeometry = TipEndGeometryIn;
  TipEndDiameter = TipEndDiameterIn;
  TipEndMaterial = TipEndMaterialIn;
  StemMaterial = StemMaterialIn;
  StemDiameter = StemDiameterIn;
}

SimpleTactileProbeSensorType::~SimpleTactileProbeSensorType()
{
  #ifndef NODESTRUCT
  delete Qualifications;
  delete Length;
  delete TipEndGeometry;
  delete TipEndDiameter;
  delete TipEndMaterial;
  delete StemMaterial;
  delete StemDiameter;
  #endif
}

void SimpleTactileProbeSensorType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (ProtectionClass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProtectionClass");
      ProtectionClass->printSelf(outFile);
      fprintf(outFile, "</ProtectionClass>\n");
    }
  if (LinearityError)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LinearityError");
      LinearityError->printSelf(outFile);
      fprintf(outFile, "</LinearityError>\n");
    }
  if (Repeatability)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Repeatability");
      Repeatability->printSelf(outFile);
      fprintf(outFile, "</Repeatability>\n");
    }
  if (Sensitivity)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Sensitivity");
      Sensitivity->printSelf(outFile);
      fprintf(outFile, "</Sensitivity>\n");
    }
  if (Resolution)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Resolution");
      Resolution->printSelf(outFile);
      fprintf(outFile, "</Resolution>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (Qualifications)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Qualifications");
      Qualifications->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Qualifications>\n");
    }
  if (Length)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Length");
      Length->printSelf(outFile);
      fprintf(outFile, "</Length>\n");
    }
  if (TipEndGeometry)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TipEndGeometry");
      TipEndGeometry->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</TipEndGeometry>\n");
    }
  if (TipEndDiameter)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TipEndDiameter");
      TipEndDiameter->printSelf(outFile);
      fprintf(outFile, "</TipEndDiameter>\n");
    }
  if (TipEndMaterial)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TipEndMaterial");
      TipEndMaterial->printSelf(outFile);
      fprintf(outFile, "</TipEndMaterial>\n");
    }
  if (StemMaterial)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StemMaterial");
      StemMaterial->printSelf(outFile);
      fprintf(outFile, "</StemMaterial>\n");
    }
  if (StemDiameter)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StemDiameter");
      StemDiameter->printSelf(outFile);
      fprintf(outFile, "</StemDiameter>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SimpleTactileProbeSensorType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SimpleTactileProbeSensorType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SimpleTactileProbeSensorType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SimpleTactileProbeSensorType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SimpleTactileProbeSensorType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

QualificationsType * SimpleTactileProbeSensorType::getQualifications()
{return Qualifications;}

void SimpleTactileProbeSensorType::setQualifications(QualificationsType * QualificationsIn)
{Qualifications = QualificationsIn;}

LinearValueType * SimpleTactileProbeSensorType::getLength()
{return Length;}

void SimpleTactileProbeSensorType::setLength(LinearValueType * LengthIn)
{Length = LengthIn;}

TipEndGeometryType * SimpleTactileProbeSensorType::getTipEndGeometry()
{return TipEndGeometry;}

void SimpleTactileProbeSensorType::setTipEndGeometry(TipEndGeometryType * TipEndGeometryIn)
{TipEndGeometry = TipEndGeometryIn;}

LinearValueType * SimpleTactileProbeSensorType::getTipEndDiameter()
{return TipEndDiameter;}

void SimpleTactileProbeSensorType::setTipEndDiameter(LinearValueType * TipEndDiameterIn)
{TipEndDiameter = TipEndDiameterIn;}

XmlString * SimpleTactileProbeSensorType::getTipEndMaterial()
{return TipEndMaterial;}

void SimpleTactileProbeSensorType::setTipEndMaterial(XmlString * TipEndMaterialIn)
{TipEndMaterial = TipEndMaterialIn;}

XmlString * SimpleTactileProbeSensorType::getStemMaterial()
{return StemMaterial;}

void SimpleTactileProbeSensorType::setStemMaterial(XmlString * StemMaterialIn)
{StemMaterial = StemMaterialIn;}

LinearValueType * SimpleTactileProbeSensorType::getStemDiameter()
{return StemDiameter;}

void SimpleTactileProbeSensorType::setStemDiameter(LinearValueType * StemDiameterIn)
{StemDiameter = StemDiameterIn;}

/* ***************************************************************** */

/* class SineBarType

*/

SineBarType::SineBarType() :
  ManualMeasurementDeviceType()
{
  NominalBallCenterToBallCenterLength = 0;
  CylinderCenterToCylinderCenterAccuracy = 0;
  Parallelism = 0;
  OverallLength = 0;
  Material = 0;
  Magnetic = 0;
  Width = 0;
}

SineBarType::SineBarType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 LinearValueType * NominalBallCenterToBallCenterLengthIn,
 LinearValueType * CylinderCenterToCylinderCenterAccuracyIn,
 LinearValueType * ParallelismIn,
 LinearValueType * OverallLengthIn,
 XmlString * MaterialIn,
 XmlBoolean * MagneticIn,
 LinearValueType * WidthIn) :
  ManualMeasurementDeviceType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    MinMeasuringDistanceIn,
    MaxMeasuringDistanceIn)
{
  NominalBallCenterToBallCenterLength = NominalBallCenterToBallCenterLengthIn;
  CylinderCenterToCylinderCenterAccuracy = CylinderCenterToCylinderCenterAccuracyIn;
  Parallelism = ParallelismIn;
  OverallLength = OverallLengthIn;
  Material = MaterialIn;
  Magnetic = MagneticIn;
  Width = WidthIn;
}

SineBarType::SineBarType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 LinearValueType * NominalBallCenterToBallCenterLengthIn,
 LinearValueType * CylinderCenterToCylinderCenterAccuracyIn,
 LinearValueType * ParallelismIn,
 LinearValueType * OverallLengthIn,
 XmlString * MaterialIn,
 XmlBoolean * MagneticIn,
 LinearValueType * WidthIn) :
  ManualMeasurementDeviceType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    MinMeasuringDistanceIn,
    MaxMeasuringDistanceIn)
{
  NominalBallCenterToBallCenterLength = NominalBallCenterToBallCenterLengthIn;
  CylinderCenterToCylinderCenterAccuracy = CylinderCenterToCylinderCenterAccuracyIn;
  Parallelism = ParallelismIn;
  OverallLength = OverallLengthIn;
  Material = MaterialIn;
  Magnetic = MagneticIn;
  Width = WidthIn;
}

SineBarType::~SineBarType()
{
  #ifndef NODESTRUCT
  delete NominalBallCenterToBallCenterLength;
  delete CylinderCenterToCylinderCenterAccuracy;
  delete Parallelism;
  delete OverallLength;
  delete Material;
  delete Magnetic;
  delete Width;
  #endif
}

void SineBarType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Calibrations)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Calibrations");
      Calibrations->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Calibrations>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (MinMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinMeasuringDistance");
      MinMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MinMeasuringDistance>\n");
    }
  if (MaxMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxMeasuringDistance");
      MaxMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MaxMeasuringDistance>\n");
    }
  if (NominalBallCenterToBallCenterLength)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NominalBallCenterToBallCenterLength");
      NominalBallCenterToBallCenterLength->printSelf(outFile);
      fprintf(outFile, "</NominalBallCenterToBallCenterLength>\n");
    }
  if (CylinderCenterToCylinderCenterAccuracy)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CylinderCenterToCylinderCenterAccuracy");
      CylinderCenterToCylinderCenterAccuracy->printSelf(outFile);
      fprintf(outFile, "</CylinderCenterToCylinderCenterAccuracy>\n");
    }
  if (Parallelism)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Parallelism");
      Parallelism->printSelf(outFile);
      fprintf(outFile, "</Parallelism>\n");
    }
  if (OverallLength)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OverallLength");
      OverallLength->printSelf(outFile);
      fprintf(outFile, "</OverallLength>\n");
    }
  if (Material)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Material");
      Material->printSelf(outFile);
      fprintf(outFile, "</Material>\n");
    }
  if (Magnetic)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Magnetic");
      Magnetic->printSelf(outFile);
      fprintf(outFile, "</Magnetic>\n");
    }
  if (Width)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Width");
      Width->printSelf(outFile);
      fprintf(outFile, "</Width>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool SineBarType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SineBarType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SineBarType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SineBarType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in SineBarType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LinearValueType * SineBarType::getNominalBallCenterToBallCenterLength()
{return NominalBallCenterToBallCenterLength;}

void SineBarType::setNominalBallCenterToBallCenterLength(LinearValueType * NominalBallCenterToBallCenterLengthIn)
{NominalBallCenterToBallCenterLength = NominalBallCenterToBallCenterLengthIn;}

LinearValueType * SineBarType::getCylinderCenterToCylinderCenterAccuracy()
{return CylinderCenterToCylinderCenterAccuracy;}

void SineBarType::setCylinderCenterToCylinderCenterAccuracy(LinearValueType * CylinderCenterToCylinderCenterAccuracyIn)
{CylinderCenterToCylinderCenterAccuracy = CylinderCenterToCylinderCenterAccuracyIn;}

LinearValueType * SineBarType::getParallelism()
{return Parallelism;}

void SineBarType::setParallelism(LinearValueType * ParallelismIn)
{Parallelism = ParallelismIn;}

LinearValueType * SineBarType::getOverallLength()
{return OverallLength;}

void SineBarType::setOverallLength(LinearValueType * OverallLengthIn)
{OverallLength = OverallLengthIn;}

XmlString * SineBarType::getMaterial()
{return Material;}

void SineBarType::setMaterial(XmlString * MaterialIn)
{Material = MaterialIn;}

XmlBoolean * SineBarType::getMagnetic()
{return Magnetic;}

void SineBarType::setMagnetic(XmlBoolean * MagneticIn)
{Magnetic = MagneticIn;}

LinearValueType * SineBarType::getWidth()
{return Width;}

void SineBarType::setWidth(LinearValueType * WidthIn)
{Width = WidthIn;}

/* ***************************************************************** */

/* class SinglePointArticulationPerformanceTestType

*/

SinglePointArticulationPerformanceTestType::SinglePointArticulationPerformanceTestType()
{
  MaxDeviationFromAverageNear = 0;
  MaxDeviationFromAverageFar = 0;
  MaxDeviationFromAverageMiddle = 0;
  TwiceStandardDeviationNear = 0;
  TwiceStandardDeviationFar = 0;
  TwiceStandardDeviationMiddle = 0;
}

SinglePointArticulationPerformanceTestType::SinglePointArticulationPerformanceTestType(
 LinearValueType * MaxDeviationFromAverageNearIn,
 LinearValueType * MaxDeviationFromAverageFarIn,
 LinearValueType * MaxDeviationFromAverageMiddleIn,
 LinearValueType * TwiceStandardDeviationNearIn,
 LinearValueType * TwiceStandardDeviationFarIn,
 LinearValueType * TwiceStandardDeviationMiddleIn)
{
  MaxDeviationFromAverageNear = MaxDeviationFromAverageNearIn;
  MaxDeviationFromAverageFar = MaxDeviationFromAverageFarIn;
  MaxDeviationFromAverageMiddle = MaxDeviationFromAverageMiddleIn;
  TwiceStandardDeviationNear = TwiceStandardDeviationNearIn;
  TwiceStandardDeviationFar = TwiceStandardDeviationFarIn;
  TwiceStandardDeviationMiddle = TwiceStandardDeviationMiddleIn;
}

SinglePointArticulationPerformanceTestType::~SinglePointArticulationPerformanceTestType()
{
  #ifndef NODESTRUCT
  delete MaxDeviationFromAverageNear;
  delete MaxDeviationFromAverageFar;
  delete MaxDeviationFromAverageMiddle;
  delete TwiceStandardDeviationNear;
  delete TwiceStandardDeviationFar;
  delete TwiceStandardDeviationMiddle;
  #endif
}

void SinglePointArticulationPerformanceTestType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxDeviationFromAverageNear");
  MaxDeviationFromAverageNear->printSelf(outFile);
  fprintf(outFile, "</MaxDeviationFromAverageNear>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxDeviationFromAverageFar");
  MaxDeviationFromAverageFar->printSelf(outFile);
  fprintf(outFile, "</MaxDeviationFromAverageFar>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxDeviationFromAverageMiddle");
  MaxDeviationFromAverageMiddle->printSelf(outFile);
  fprintf(outFile, "</MaxDeviationFromAverageMiddle>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<TwiceStandardDeviationNear");
  TwiceStandardDeviationNear->printSelf(outFile);
  fprintf(outFile, "</TwiceStandardDeviationNear>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<TwiceStandardDeviationFar");
  TwiceStandardDeviationFar->printSelf(outFile);
  fprintf(outFile, "</TwiceStandardDeviationFar>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<TwiceStandardDeviationMiddle");
  TwiceStandardDeviationMiddle->printSelf(outFile);
  fprintf(outFile, "</TwiceStandardDeviationMiddle>\n");
  doSpaces(-INDENT, outFile);
}

LinearValueType * SinglePointArticulationPerformanceTestType::getMaxDeviationFromAverageNear()
{return MaxDeviationFromAverageNear;}

void SinglePointArticulationPerformanceTestType::setMaxDeviationFromAverageNear(LinearValueType * MaxDeviationFromAverageNearIn)
{MaxDeviationFromAverageNear = MaxDeviationFromAverageNearIn;}

LinearValueType * SinglePointArticulationPerformanceTestType::getMaxDeviationFromAverageFar()
{return MaxDeviationFromAverageFar;}

void SinglePointArticulationPerformanceTestType::setMaxDeviationFromAverageFar(LinearValueType * MaxDeviationFromAverageFarIn)
{MaxDeviationFromAverageFar = MaxDeviationFromAverageFarIn;}

LinearValueType * SinglePointArticulationPerformanceTestType::getMaxDeviationFromAverageMiddle()
{return MaxDeviationFromAverageMiddle;}

void SinglePointArticulationPerformanceTestType::setMaxDeviationFromAverageMiddle(LinearValueType * MaxDeviationFromAverageMiddleIn)
{MaxDeviationFromAverageMiddle = MaxDeviationFromAverageMiddleIn;}

LinearValueType * SinglePointArticulationPerformanceTestType::getTwiceStandardDeviationNear()
{return TwiceStandardDeviationNear;}

void SinglePointArticulationPerformanceTestType::setTwiceStandardDeviationNear(LinearValueType * TwiceStandardDeviationNearIn)
{TwiceStandardDeviationNear = TwiceStandardDeviationNearIn;}

LinearValueType * SinglePointArticulationPerformanceTestType::getTwiceStandardDeviationFar()
{return TwiceStandardDeviationFar;}

void SinglePointArticulationPerformanceTestType::setTwiceStandardDeviationFar(LinearValueType * TwiceStandardDeviationFarIn)
{TwiceStandardDeviationFar = TwiceStandardDeviationFarIn;}

LinearValueType * SinglePointArticulationPerformanceTestType::getTwiceStandardDeviationMiddle()
{return TwiceStandardDeviationMiddle;}

void SinglePointArticulationPerformanceTestType::setTwiceStandardDeviationMiddle(LinearValueType * TwiceStandardDeviationMiddleIn)
{TwiceStandardDeviationMiddle = TwiceStandardDeviationMiddleIn;}

/* ***************************************************************** */

/* class SphericalResolutionType

*/

SphericalResolutionType::SphericalResolutionType() :
  ResolutionBaseType()
{
  SphericalResolutionTypePair = 0;
}

SphericalResolutionType::SphericalResolutionType(
 SphericalResolutionTypeChoicePair * SphericalResolutionTypePairIn) :
  ResolutionBaseType()
{
  SphericalResolutionTypePair = SphericalResolutionTypePairIn;
}

SphericalResolutionType::~SphericalResolutionType()
{
  #ifndef NODESTRUCT
  delete SphericalResolutionTypePair;
  #endif
}

void SphericalResolutionType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  SphericalResolutionTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}
SphericalResolutionTypeChoicePair * SphericalResolutionType::getSphericalResolutionTypeChoicePair()
{return SphericalResolutionTypePair;}

void SphericalResolutionType::setSphericalResolutionTypeChoicePair(SphericalResolutionTypeChoicePair * SphericalResolutionTypePairIn)
{SphericalResolutionTypePair = SphericalResolutionTypePairIn;}

/* ***************************************************************** */

SphericalResolutionTypeChoicePair::SphericalResolutionTypeChoicePair() {}

SphericalResolutionTypeChoicePair::SphericalResolutionTypeChoicePair(
 whichOne SphericalResolutionTypeTypeIn,
 SphericalResolutionTypeVal SphericalResolutionTypeValueIn)
{
  SphericalResolutionTypeType = SphericalResolutionTypeTypeIn;
  SphericalResolutionTypeValue = SphericalResolutionTypeValueIn;
}

SphericalResolutionTypeChoicePair::~SphericalResolutionTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (SphericalResolutionTypeType == SphericalResolu_1197E)
    delete SphericalResolutionTypeValue.SphericalResolu_1197;
  else if (SphericalResolutionTypeType == RAPResolutionE)
    delete SphericalResolutionTypeValue.RAPResolution;
  #endif
}

void SphericalResolutionTypeChoicePair::printSelf(FILE * outFile)
{
  if (SphericalResolutionTypeType == SphericalResolu_1197E)
    {
      SphericalResolutionTypeValue.SphericalResolu_1197->printSelf(outFile);
    }
  else if (SphericalResolutionTypeType == RAPResolutionE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<RAPResolution");
      SphericalResolutionTypeValue.RAPResolution->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</RAPResolution>\n");
    }
}

/* ***************************************************************** */

/* class SphericalWorkingVolumeType

*/

SphericalWorkingVolumeType::SphericalWorkingVolumeType() :
  WorkingVolumeBaseType()
{
  RadialAxisLength = 0;
  MinAzimuthalAxisAngle = 0;
  MaxAzimuthalAxisAngle = 0;
  MinPolarAxisAngle = 0;
  MaxPolarAxisAngle = 0;
}

SphericalWorkingVolumeType::SphericalWorkingVolumeType(
 LinearValueType * RadialAxisLengthIn,
 AngularValueType * MinAzimuthalAxisAngleIn,
 AngularValueType * MaxAzimuthalAxisAngleIn,
 AngularValueType * MinPolarAxisAngleIn,
 AngularValueType * MaxPolarAxisAngleIn) :
  WorkingVolumeBaseType()
{
  RadialAxisLength = RadialAxisLengthIn;
  MinAzimuthalAxisAngle = MinAzimuthalAxisAngleIn;
  MaxAzimuthalAxisAngle = MaxAzimuthalAxisAngleIn;
  MinPolarAxisAngle = MinPolarAxisAngleIn;
  MaxPolarAxisAngle = MaxPolarAxisAngleIn;
}

SphericalWorkingVolumeType::~SphericalWorkingVolumeType()
{
  #ifndef NODESTRUCT
  delete RadialAxisLength;
  delete MinAzimuthalAxisAngle;
  delete MaxAzimuthalAxisAngle;
  delete MinPolarAxisAngle;
  delete MaxPolarAxisAngle;
  #endif
}

void SphericalWorkingVolumeType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<RadialAxisLength");
  RadialAxisLength->printSelf(outFile);
  fprintf(outFile, "</RadialAxisLength>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MinAzimuthalAxisAngle");
  MinAzimuthalAxisAngle->printSelf(outFile);
  fprintf(outFile, "</MinAzimuthalAxisAngle>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxAzimuthalAxisAngle");
  MaxAzimuthalAxisAngle->printSelf(outFile);
  fprintf(outFile, "</MaxAzimuthalAxisAngle>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MinPolarAxisAngle");
  MinPolarAxisAngle->printSelf(outFile);
  fprintf(outFile, "</MinPolarAxisAngle>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxPolarAxisAngle");
  MaxPolarAxisAngle->printSelf(outFile);
  fprintf(outFile, "</MaxPolarAxisAngle>\n");
  doSpaces(-INDENT, outFile);
}

LinearValueType * SphericalWorkingVolumeType::getRadialAxisLength()
{return RadialAxisLength;}

void SphericalWorkingVolumeType::setRadialAxisLength(LinearValueType * RadialAxisLengthIn)
{RadialAxisLength = RadialAxisLengthIn;}

AngularValueType * SphericalWorkingVolumeType::getMinAzimuthalAxisAngle()
{return MinAzimuthalAxisAngle;}

void SphericalWorkingVolumeType::setMinAzimuthalAxisAngle(AngularValueType * MinAzimuthalAxisAngleIn)
{MinAzimuthalAxisAngle = MinAzimuthalAxisAngleIn;}

AngularValueType * SphericalWorkingVolumeType::getMaxAzimuthalAxisAngle()
{return MaxAzimuthalAxisAngle;}

void SphericalWorkingVolumeType::setMaxAzimuthalAxisAngle(AngularValueType * MaxAzimuthalAxisAngleIn)
{MaxAzimuthalAxisAngle = MaxAzimuthalAxisAngleIn;}

AngularValueType * SphericalWorkingVolumeType::getMinPolarAxisAngle()
{return MinPolarAxisAngle;}

void SphericalWorkingVolumeType::setMinPolarAxisAngle(AngularValueType * MinPolarAxisAngleIn)
{MinPolarAxisAngle = MinPolarAxisAngleIn;}

AngularValueType * SphericalWorkingVolumeType::getMaxPolarAxisAngle()
{return MaxPolarAxisAngle;}

void SphericalWorkingVolumeType::setMaxPolarAxisAngle(AngularValueType * MaxPolarAxisAngleIn)
{MaxPolarAxisAngle = MaxPolarAxisAngleIn;}

/* ***************************************************************** */

/* class StiffnessType

*/

StiffnessType::StiffnessType()
{
  XStiffness = 0;
  YStiffness = 0;
  ZStiffness = 0;
}

StiffnessType::StiffnessType(
 UserDefinedUnitValueType * XStiffnessIn,
 UserDefinedUnitValueType * YStiffnessIn,
 UserDefinedUnitValueType * ZStiffnessIn)
{
  XStiffness = XStiffnessIn;
  YStiffness = YStiffnessIn;
  ZStiffness = ZStiffnessIn;
}

StiffnessType::~StiffnessType()
{
  #ifndef NODESTRUCT
  delete XStiffness;
  delete YStiffness;
  delete ZStiffness;
  #endif
}

void StiffnessType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (XStiffness)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<XStiffness");
      XStiffness->printSelf(outFile);
      fprintf(outFile, "</XStiffness>\n");
    }
  if (YStiffness)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<YStiffness");
      YStiffness->printSelf(outFile);
      fprintf(outFile, "</YStiffness>\n");
    }
  if (ZStiffness)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ZStiffness");
      ZStiffness->printSelf(outFile);
      fprintf(outFile, "</ZStiffness>\n");
    }
  doSpaces(-INDENT, outFile);
}

UserDefinedUnitValueType * StiffnessType::getXStiffness()
{return XStiffness;}

void StiffnessType::setXStiffness(UserDefinedUnitValueType * XStiffnessIn)
{XStiffness = XStiffnessIn;}

UserDefinedUnitValueType * StiffnessType::getYStiffness()
{return YStiffness;}

void StiffnessType::setYStiffness(UserDefinedUnitValueType * YStiffnessIn)
{YStiffness = YStiffnessIn;}

UserDefinedUnitValueType * StiffnessType::getZStiffness()
{return ZStiffness;}

void StiffnessType::setZStiffness(UserDefinedUnitValueType * ZStiffnessIn)
{ZStiffness = ZStiffnessIn;}

/* ***************************************************************** */

/* class StructuredLightSensorType

*/

StructuredLightSensorType::StructuredLightSensorType() :
  SensorType()
{
  OutputFileFormat = 0;
  MeasurementFieldSize = 0;
  NumberOfCameraPixels = 0;
  LightSource = 0;
  MeasurementRate = 0;
  WorkingVolume = 0;
  StandOffDistance = 0;
  MaxPermissibleProbingError = 0;
  Laser = 0;
}

StructuredLightSensorType::StructuredLightSensorType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 XmlString * ProtectionClassIn,
 XmlString * LinearityErrorIn,
 LinearValueType * RepeatabilityIn,
 XmlDecimal * SensitivityIn,
 LinearValueType * ResolutionIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 XmlString * OutputFileFormatIn,
 LinearValueType * MeasurementFieldSizeIn,
 XmlInt * NumberOfCameraPixelsIn,
 XmlString * LightSourceIn,
 UserDefinedUnitValueType * MeasurementRateIn,
 WorkingVolumeBaseType * WorkingVolumeIn,
 LinearValueType * StandOffDistanceIn,
 LinearValueType * MaxPermissibleProbingErrorIn,
 LaserType * LaserIn) :
  SensorType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    ProtectionClassIn,
    LinearityErrorIn,
    RepeatabilityIn,
    SensitivityIn,
    ResolutionIn,
    EnvironmentalRangeIn)
{
  OutputFileFormat = OutputFileFormatIn;
  MeasurementFieldSize = MeasurementFieldSizeIn;
  NumberOfCameraPixels = NumberOfCameraPixelsIn;
  LightSource = LightSourceIn;
  MeasurementRate = MeasurementRateIn;
  WorkingVolume = WorkingVolumeIn;
  StandOffDistance = StandOffDistanceIn;
  MaxPermissibleProbingError = MaxPermissibleProbingErrorIn;
  Laser = LaserIn;
}

StructuredLightSensorType::StructuredLightSensorType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 XmlString * ProtectionClassIn,
 XmlString * LinearityErrorIn,
 LinearValueType * RepeatabilityIn,
 XmlDecimal * SensitivityIn,
 LinearValueType * ResolutionIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 XmlString * OutputFileFormatIn,
 LinearValueType * MeasurementFieldSizeIn,
 XmlInt * NumberOfCameraPixelsIn,
 XmlString * LightSourceIn,
 UserDefinedUnitValueType * MeasurementRateIn,
 WorkingVolumeBaseType * WorkingVolumeIn,
 LinearValueType * StandOffDistanceIn,
 LinearValueType * MaxPermissibleProbingErrorIn,
 LaserType * LaserIn) :
  SensorType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    ProtectionClassIn,
    LinearityErrorIn,
    RepeatabilityIn,
    SensitivityIn,
    ResolutionIn,
    EnvironmentalRangeIn)
{
  OutputFileFormat = OutputFileFormatIn;
  MeasurementFieldSize = MeasurementFieldSizeIn;
  NumberOfCameraPixels = NumberOfCameraPixelsIn;
  LightSource = LightSourceIn;
  MeasurementRate = MeasurementRateIn;
  WorkingVolume = WorkingVolumeIn;
  StandOffDistance = StandOffDistanceIn;
  MaxPermissibleProbingError = MaxPermissibleProbingErrorIn;
  Laser = LaserIn;
}

StructuredLightSensorType::~StructuredLightSensorType()
{
  #ifndef NODESTRUCT
  delete OutputFileFormat;
  delete MeasurementFieldSize;
  delete NumberOfCameraPixels;
  delete LightSource;
  delete MeasurementRate;
  delete WorkingVolume;
  delete StandOffDistance;
  delete MaxPermissibleProbingError;
  delete Laser;
  #endif
}

void StructuredLightSensorType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (ProtectionClass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProtectionClass");
      ProtectionClass->printSelf(outFile);
      fprintf(outFile, "</ProtectionClass>\n");
    }
  if (LinearityError)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LinearityError");
      LinearityError->printSelf(outFile);
      fprintf(outFile, "</LinearityError>\n");
    }
  if (Repeatability)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Repeatability");
      Repeatability->printSelf(outFile);
      fprintf(outFile, "</Repeatability>\n");
    }
  if (Sensitivity)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Sensitivity");
      Sensitivity->printSelf(outFile);
      fprintf(outFile, "</Sensitivity>\n");
    }
  if (Resolution)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Resolution");
      Resolution->printSelf(outFile);
      fprintf(outFile, "</Resolution>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (OutputFileFormat)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OutputFileFormat");
      OutputFileFormat->printSelf(outFile);
      fprintf(outFile, "</OutputFileFormat>\n");
    }
  if (MeasurementFieldSize)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementFieldSize");
      MeasurementFieldSize->printSelf(outFile);
      fprintf(outFile, "</MeasurementFieldSize>\n");
    }
  if (NumberOfCameraPixels)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NumberOfCameraPixels");
      NumberOfCameraPixels->printSelf(outFile);
      fprintf(outFile, "</NumberOfCameraPixels>\n");
    }
  if (LightSource)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LightSource");
      LightSource->printSelf(outFile);
      fprintf(outFile, "</LightSource>\n");
    }
  if (MeasurementRate)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasurementRate");
      MeasurementRate->printSelf(outFile);
      fprintf(outFile, "</MeasurementRate>\n");
    }
  if (WorkingVolume)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (WorkingVolume->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(WorkingVolume->getprintElement(), "ClosedShellSetWorkingVolume") == 0)
          {
            ClosedShellSetWorkingVolumeType * typ;
            if ((typ = dynamic_cast<ClosedShellSetWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<ClosedShellSetWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ClosedShellSetWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad ClosedShellSetWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "CartesianWorkingVolume") == 0)
          {
            CartesianWorkingVolumeType * typ;
            if ((typ = dynamic_cast<CartesianWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<CartesianWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "SphericalWorkingVolume") == 0)
          {
            SphericalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<SphericalWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<SphericalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "CylindricalWorkingVolume") == 0)
          {
            CylindricalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<CylindricalWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<CylindricalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CylindricalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad CylindricalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "UserDefinedWorkingVolume") == 0)
          {
            UserDefinedWorkingVolumeType * typ;
            if ((typ = dynamic_cast<UserDefinedWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<UserDefinedWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedWorkingVolume element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad WorkingVolume type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (StandOffDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StandOffDistance");
      StandOffDistance->printSelf(outFile);
      fprintf(outFile, "</StandOffDistance>\n");
    }
  if (MaxPermissibleProbingError)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxPermissibleProbingError");
      MaxPermissibleProbingError->printSelf(outFile);
      fprintf(outFile, "</MaxPermissibleProbingError>\n");
    }
  if (Laser)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Laser");
      Laser->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Laser>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool StructuredLightSensorType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in StructuredLightSensorType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in StructuredLightSensorType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in StructuredLightSensorType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in StructuredLightSensorType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

XmlString * StructuredLightSensorType::getOutputFileFormat()
{return OutputFileFormat;}

void StructuredLightSensorType::setOutputFileFormat(XmlString * OutputFileFormatIn)
{OutputFileFormat = OutputFileFormatIn;}

LinearValueType * StructuredLightSensorType::getMeasurementFieldSize()
{return MeasurementFieldSize;}

void StructuredLightSensorType::setMeasurementFieldSize(LinearValueType * MeasurementFieldSizeIn)
{MeasurementFieldSize = MeasurementFieldSizeIn;}

XmlInt * StructuredLightSensorType::getNumberOfCameraPixels()
{return NumberOfCameraPixels;}

void StructuredLightSensorType::setNumberOfCameraPixels(XmlInt * NumberOfCameraPixelsIn)
{NumberOfCameraPixels = NumberOfCameraPixelsIn;}

XmlString * StructuredLightSensorType::getLightSource()
{return LightSource;}

void StructuredLightSensorType::setLightSource(XmlString * LightSourceIn)
{LightSource = LightSourceIn;}

UserDefinedUnitValueType * StructuredLightSensorType::getMeasurementRate()
{return MeasurementRate;}

void StructuredLightSensorType::setMeasurementRate(UserDefinedUnitValueType * MeasurementRateIn)
{MeasurementRate = MeasurementRateIn;}

WorkingVolumeBaseType * StructuredLightSensorType::getWorkingVolume()
{return WorkingVolume;}

void StructuredLightSensorType::setWorkingVolume(WorkingVolumeBaseType * WorkingVolumeIn)
{WorkingVolume = WorkingVolumeIn;}

LinearValueType * StructuredLightSensorType::getStandOffDistance()
{return StandOffDistance;}

void StructuredLightSensorType::setStandOffDistance(LinearValueType * StandOffDistanceIn)
{StandOffDistance = StandOffDistanceIn;}

LinearValueType * StructuredLightSensorType::getMaxPermissibleProbingError()
{return MaxPermissibleProbingError;}

void StructuredLightSensorType::setMaxPermissibleProbingError(LinearValueType * MaxPermissibleProbingErrorIn)
{MaxPermissibleProbingError = MaxPermissibleProbingErrorIn;}

LaserType * StructuredLightSensorType::getLaser()
{return Laser;}

void StructuredLightSensorType::setLaser(LaserType * LaserIn)
{Laser = LaserIn;}

/* ***************************************************************** */

/* class TableErrorsType

*/

TableErrorsType::TableErrorsType()
{
  AxialError = 0;
  RadialError = 0;
  TangentialError = 0;
}

TableErrorsType::TableErrorsType(
 LinearValueType * AxialErrorIn,
 LinearValueType * RadialErrorIn,
 LinearValueType * TangentialErrorIn)
{
  AxialError = AxialErrorIn;
  RadialError = RadialErrorIn;
  TangentialError = TangentialErrorIn;
}

TableErrorsType::~TableErrorsType()
{
  #ifndef NODESTRUCT
  delete AxialError;
  delete RadialError;
  delete TangentialError;
  #endif
}

void TableErrorsType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<AxialError");
  AxialError->printSelf(outFile);
  fprintf(outFile, "</AxialError>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<RadialError");
  RadialError->printSelf(outFile);
  fprintf(outFile, "</RadialError>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<TangentialError");
  TangentialError->printSelf(outFile);
  fprintf(outFile, "</TangentialError>\n");
  doSpaces(-INDENT, outFile);
}

LinearValueType * TableErrorsType::getAxialError()
{return AxialError;}

void TableErrorsType::setAxialError(LinearValueType * AxialErrorIn)
{AxialError = AxialErrorIn;}

LinearValueType * TableErrorsType::getRadialError()
{return RadialError;}

void TableErrorsType::setRadialError(LinearValueType * RadialErrorIn)
{RadialError = RadialErrorIn;}

LinearValueType * TableErrorsType::getTangentialError()
{return TangentialError;}

void TableErrorsType::setTangentialError(LinearValueType * TangentialErrorIn)
{TangentialError = TangentialErrorIn;}

/* ***************************************************************** */

/* class TactileProbeSensorBaseType

*/

TactileProbeSensorBaseType::TactileProbeSensorBaseType() :
  DetachableSensorBaseType()
{
}

TactileProbeSensorBaseType::TactileProbeSensorBaseType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 XmlString * ProtectionClassIn,
 XmlString * LinearityErrorIn,
 LinearValueType * RepeatabilityIn,
 XmlDecimal * SensitivityIn,
 LinearValueType * ResolutionIn,
 EnvironmentalRangeType * EnvironmentalRangeIn) :
  DetachableSensorBaseType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    ProtectionClassIn,
    LinearityErrorIn,
    RepeatabilityIn,
    SensitivityIn,
    ResolutionIn,
    EnvironmentalRangeIn)
{
}

TactileProbeSensorBaseType::TactileProbeSensorBaseType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 XmlString * ProtectionClassIn,
 XmlString * LinearityErrorIn,
 LinearValueType * RepeatabilityIn,
 XmlDecimal * SensitivityIn,
 LinearValueType * ResolutionIn,
 EnvironmentalRangeType * EnvironmentalRangeIn) :
  DetachableSensorBaseType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    ProtectionClassIn,
    LinearityErrorIn,
    RepeatabilityIn,
    SensitivityIn,
    ResolutionIn,
    EnvironmentalRangeIn)
{
}

TactileProbeSensorBaseType::~TactileProbeSensorBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void TactileProbeSensorBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (ProtectionClass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProtectionClass");
      ProtectionClass->printSelf(outFile);
      fprintf(outFile, "</ProtectionClass>\n");
    }
  if (LinearityError)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LinearityError");
      LinearityError->printSelf(outFile);
      fprintf(outFile, "</LinearityError>\n");
    }
  if (Repeatability)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Repeatability");
      Repeatability->printSelf(outFile);
      fprintf(outFile, "</Repeatability>\n");
    }
  if (Sensitivity)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Sensitivity");
      Sensitivity->printSelf(outFile);
      fprintf(outFile, "</Sensitivity>\n");
    }
  if (Resolution)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Resolution");
      Resolution->printSelf(outFile);
      fprintf(outFile, "</Resolution>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool TactileProbeSensorBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in TactileProbeSensorBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in TactileProbeSensorBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in TactileProbeSensorBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in TactileProbeSensorBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class TargetMirrorEnumType

*/

TargetMirrorEnumType::TargetMirrorEnumType() :
  XmlNMTOKEN()
{
}

TargetMirrorEnumType::TargetMirrorEnumType(
 const char * valIn) :
  XmlNMTOKEN(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "CUBE_CORNER") &&
           strcmp(val.c_str(), "CATS_EYE") &&
           strcmp(val.c_str(), "PLANE_MIRROR"));
}

TargetMirrorEnumType::~TargetMirrorEnumType() {}

bool TargetMirrorEnumType::TargetMirrorEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "CUBE_CORNER") &&
          strcmp(val.c_str(), "CATS_EYE") &&
          strcmp(val.c_str(), "PLANE_MIRROR"));
}

void TargetMirrorEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "TargetMirrorEnumType");
}

void TargetMirrorEnumType::printSelf(FILE * outFile)
{
  if (TargetMirrorEnumTypeIsBad())
    {
      fprintf(stderr, "bad TargetMirrorEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::printSelf(outFile);
}

void TargetMirrorEnumType::oPrintSelf(FILE * outFile)
{
  if (TargetMirrorEnumTypeIsBad())
    {
      fprintf(stderr, "bad TargetMirrorEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class TemperatureCompensationEnumType

*/

TemperatureCompensationEnumType::TemperatureCompensationEnumType() :
  XmlNMTOKEN()
{
}

TemperatureCompensationEnumType::TemperatureCompensationEnumType(
 const char * valIn) :
  XmlNMTOKEN(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "NONE") &&
           strcmp(val.c_str(), "DEVICE_ONLY") &&
           strcmp(val.c_str(), "DEVICE_AND_PART_SAME") &&
           strcmp(val.c_str(), "DEVICE_AND_PART_SEPARATE"));
}

TemperatureCompensationEnumType::~TemperatureCompensationEnumType() {}

bool TemperatureCompensationEnumType::TemperatureCompensationEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "NONE") &&
          strcmp(val.c_str(), "DEVICE_ONLY") &&
          strcmp(val.c_str(), "DEVICE_AND_PART_SAME") &&
          strcmp(val.c_str(), "DEVICE_AND_PART_SEPARATE"));
}

void TemperatureCompensationEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "TemperatureCompensationEnumType");
}

void TemperatureCompensationEnumType::printSelf(FILE * outFile)
{
  if (TemperatureCompensationEnumTypeIsBad())
    {
      fprintf(stderr, "bad TemperatureCompensationEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::printSelf(outFile);
}

void TemperatureCompensationEnumType::oPrintSelf(FILE * outFile)
{
  if (TemperatureCompensationEnumTypeIsBad())
    {
      fprintf(stderr, "bad TemperatureCompensationEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class TemperatureCompensationType

*/

TemperatureCompensationType::TemperatureCompensationType()
{
  TemperatureCompensationTypePair = 0;
}

TemperatureCompensationType::TemperatureCompensationType(
 TemperatureCompensationTypeChoicePair * TemperatureCompensationTypePairIn)
{
  TemperatureCompensationTypePair = TemperatureCompensationTypePairIn;
}

TemperatureCompensationType::~TemperatureCompensationType()
{
  #ifndef NODESTRUCT
  delete TemperatureCompensationTypePair;
  #endif
}

void TemperatureCompensationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  TemperatureCompensationTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

TemperatureCompensationTypeChoicePair * TemperatureCompensationType::getTemperatureCompensationTypePair()
{return TemperatureCompensationTypePair;}

void TemperatureCompensationType::setTemperatureCompensationTypePair(TemperatureCompensationTypeChoicePair * TemperatureCompensationTypePairIn)
{TemperatureCompensationTypePair = TemperatureCompensationTypePairIn;}
TemperatureCompensationTypeChoicePair::TemperatureCompensationTypeChoicePair() {}

TemperatureCompensationTypeChoicePair::TemperatureCompensationTypeChoicePair(
 whichOne TemperatureCompensationTypeTypeIn,
 TemperatureCompensationTypeVal TemperatureCompensationTypeValueIn)
{
  TemperatureCompensationTypeType = TemperatureCompensationTypeTypeIn;
  TemperatureCompensationTypeValue = TemperatureCompensationTypeValueIn;
}

TemperatureCompensationTypeChoicePair::~TemperatureCompensationTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (TemperatureCompensationTypeType == TemperatureCompensationEnumE)
    delete TemperatureCompensationTypeValue.TemperatureCompensationEnum;
  else if (TemperatureCompensationTypeType == OtherTemperatureCompensationE)
    delete TemperatureCompensationTypeValue.OtherTemperatureCompensation;
  #endif
}

void TemperatureCompensationTypeChoicePair::printSelf(FILE * outFile)
{
  if (TemperatureCompensationTypeType == TemperatureCompensationEnumE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TemperatureCompensationEnum");
      TemperatureCompensationTypeValue.TemperatureCompensationEnum->printSelf(outFile);
      fprintf(outFile, "</TemperatureCompensationEnum>\n");
    }
  else if (TemperatureCompensationTypeType == OtherTemperatureCompensationE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OtherTemperatureCompensation");
      TemperatureCompensationTypeValue.OtherTemperatureCompensation->printSelf(outFile);
      fprintf(outFile, "</OtherTemperatureCompensation>\n");
    }
}

/* ***************************************************************** */

/* class TemperatureType

*/

TemperatureType::TemperatureType()
{
  Attributes = 0;
  Temperature = 0;
  TimeStamp = 0;
}

TemperatureType::TemperatureType(
 AttributesType * AttributesIn,
 TemperatureValueType * TemperatureIn,
 XmlDateTime * TimeStampIn)
{
  Attributes = AttributesIn;
  Temperature = TemperatureIn;
  TimeStamp = TimeStampIn;
}

TemperatureType::~TemperatureType()
{
  #ifndef NODESTRUCT
  delete Attributes;
  delete Temperature;
  delete TimeStamp;
  #endif
}

void TemperatureType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Temperature");
  Temperature->printSelf(outFile);
  fprintf(outFile, "</Temperature>\n");
  if (TimeStamp)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TimeStamp");
      TimeStamp->printSelf(outFile);
      fprintf(outFile, "</TimeStamp>\n");
    }
  doSpaces(-INDENT, outFile);
}

AttributesType * TemperatureType::getAttributes()
{return Attributes;}

void TemperatureType::setAttributes(AttributesType * AttributesIn)
{Attributes = AttributesIn;}

TemperatureValueType * TemperatureType::getTemperature()
{return Temperature;}

void TemperatureType::setTemperature(TemperatureValueType * TemperatureIn)
{Temperature = TemperatureIn;}

XmlDateTime * TemperatureType::getTimeStamp()
{return TimeStamp;}

void TemperatureType::setTimeStamp(XmlDateTime * TimeStampIn)
{TimeStamp = TimeStampIn;}

/* ***************************************************************** */

/* class TemperatureTypeLisd

*/

TemperatureTypeLisd::TemperatureTypeLisd() {}

TemperatureTypeLisd::TemperatureTypeLisd(TemperatureType * aTemperatureType)
{
  push_back(aTemperatureType);
}

TemperatureTypeLisd::~TemperatureTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<TemperatureType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void TemperatureTypeLisd::printSelf(FILE * outFile)
{
  std::list<TemperatureType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class TemperaturesType

*/

TemperaturesType::TemperaturesType()
{
  n = 0;
  Temperature = 0;
}

TemperaturesType::TemperaturesType(
 TemperatureTypeLisd * TemperatureIn)
{
  n = 0;
  Temperature = TemperatureIn;
}

TemperaturesType::TemperaturesType(
 NaturalType * nIn,
 TemperatureTypeLisd * TemperatureIn)
{
  n = nIn;
  Temperature = TemperatureIn;
}

TemperaturesType::~TemperaturesType()
{
  #ifndef NODESTRUCT
  delete n;
  delete Temperature;
  #endif
}

void TemperaturesType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!Temperature)
      {
        fprintf(stderr, "Temperature list is missing\n");
        exit(1);
      }
    if (Temperature->size() == 0)
      {
        fprintf(stderr, "Temperature list is empty\n");
        exit(1);
      }
    if (Temperature->size() < 1)
      {
        fprintf(stderr,
                "size of Temperature list (%d) less than minimum required (1)\n",
                (int)Temperature->size());
        exit(1);
      }
    std::list<TemperatureType *>::iterator iter;
    for (iter = Temperature->begin();
         iter != Temperature->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<Temperature");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</Temperature>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool TemperaturesType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in TemperaturesType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in TemperaturesType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in TemperaturesType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in TemperaturesType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * TemperaturesType::getn()
{return n;}

void TemperaturesType::setn(NaturalType * nIn)
{n = nIn;}

TemperatureTypeLisd * TemperaturesType::getTemperature()
{return Temperature;}

void TemperaturesType::setTemperature(TemperatureTypeLisd * TemperatureIn)
{Temperature = TemperatureIn;}

/* ***************************************************************** */

/* class TheodoliteType

*/

TheodoliteType::TheodoliteType() :
  UniversalDeviceType()
{
  LongitudinalTrackingSpeed = 0;
  LateralTrackingSpeed = 0;
  Magnification = 0;
  FieldOfViewDiameter = 0;
  ApertureSize = 0;
  MaxFocusDistance = 0;
  AngularAccuracy = 0;
  MaxTiltCompensation = 0;
  ChargeCoupledDeviceCameraSensor = 0;
  MinFocusDistance = 0;
  EffectiveDiameterOfObjective = 0;
  StadiaBaseConstant = 0;
  StadiaRateConstant = 0;
  MinPowerSupplyVoltage = 0;
  MaxPowerSupplyVoltage = 0;
  Laser = 0;
}

TheodoliteType::TheodoliteType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 ResolutionBaseType * ResolutionIn,
 WorkingVolumeBaseType * WorkingVolumeIn,
 EffectiveWorkingVolumeBaseType * EffectiveWorkingVolumeIn,
 TemperatureCompensationType * TemperatureCompensationIn,
 SpeedValueType * LongitudinalTrackingSpeedIn,
 SpeedValueType * LateralTrackingSpeedIn,
 XmlDecimal * MagnificationIn,
 LinearValueType * FieldOfViewDiameterIn,
 LinearValueType * ApertureSizeIn,
 LinearValueType * MaxFocusDistanceIn,
 AngularValueType * AngularAccuracyIn,
 AngularValueType * MaxTiltCompensationIn,
 ChargeCoupledDeviceCameraSensorType * ChargeCoupledDeviceCameraSensorIn,
 LinearValueType * MinFocusDistanceIn,
 LinearValueType * EffectiveDiameterOfObjectiveIn,
 UserDefinedUnitValueType * StadiaBaseConstantIn,
 UserDefinedUnitValueType * StadiaRateConstantIn,
 UserDefinedUnitValueType * MinPowerSupplyVoltageIn,
 UserDefinedUnitValueType * MaxPowerSupplyVoltageIn,
 LaserType * LaserIn) :
  UniversalDeviceType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    ResolutionIn,
    WorkingVolumeIn,
    EffectiveWorkingVolumeIn,
    TemperatureCompensationIn)
{
  LongitudinalTrackingSpeed = LongitudinalTrackingSpeedIn;
  LateralTrackingSpeed = LateralTrackingSpeedIn;
  Magnification = MagnificationIn;
  FieldOfViewDiameter = FieldOfViewDiameterIn;
  ApertureSize = ApertureSizeIn;
  MaxFocusDistance = MaxFocusDistanceIn;
  AngularAccuracy = AngularAccuracyIn;
  MaxTiltCompensation = MaxTiltCompensationIn;
  ChargeCoupledDeviceCameraSensor = ChargeCoupledDeviceCameraSensorIn;
  MinFocusDistance = MinFocusDistanceIn;
  EffectiveDiameterOfObjective = EffectiveDiameterOfObjectiveIn;
  StadiaBaseConstant = StadiaBaseConstantIn;
  StadiaRateConstant = StadiaRateConstantIn;
  MinPowerSupplyVoltage = MinPowerSupplyVoltageIn;
  MaxPowerSupplyVoltage = MaxPowerSupplyVoltageIn;
  Laser = LaserIn;
}

TheodoliteType::TheodoliteType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 ResolutionBaseType * ResolutionIn,
 WorkingVolumeBaseType * WorkingVolumeIn,
 EffectiveWorkingVolumeBaseType * EffectiveWorkingVolumeIn,
 TemperatureCompensationType * TemperatureCompensationIn,
 SpeedValueType * LongitudinalTrackingSpeedIn,
 SpeedValueType * LateralTrackingSpeedIn,
 XmlDecimal * MagnificationIn,
 LinearValueType * FieldOfViewDiameterIn,
 LinearValueType * ApertureSizeIn,
 LinearValueType * MaxFocusDistanceIn,
 AngularValueType * AngularAccuracyIn,
 AngularValueType * MaxTiltCompensationIn,
 ChargeCoupledDeviceCameraSensorType * ChargeCoupledDeviceCameraSensorIn,
 LinearValueType * MinFocusDistanceIn,
 LinearValueType * EffectiveDiameterOfObjectiveIn,
 UserDefinedUnitValueType * StadiaBaseConstantIn,
 UserDefinedUnitValueType * StadiaRateConstantIn,
 UserDefinedUnitValueType * MinPowerSupplyVoltageIn,
 UserDefinedUnitValueType * MaxPowerSupplyVoltageIn,
 LaserType * LaserIn) :
  UniversalDeviceType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    ResolutionIn,
    WorkingVolumeIn,
    EffectiveWorkingVolumeIn,
    TemperatureCompensationIn)
{
  LongitudinalTrackingSpeed = LongitudinalTrackingSpeedIn;
  LateralTrackingSpeed = LateralTrackingSpeedIn;
  Magnification = MagnificationIn;
  FieldOfViewDiameter = FieldOfViewDiameterIn;
  ApertureSize = ApertureSizeIn;
  MaxFocusDistance = MaxFocusDistanceIn;
  AngularAccuracy = AngularAccuracyIn;
  MaxTiltCompensation = MaxTiltCompensationIn;
  ChargeCoupledDeviceCameraSensor = ChargeCoupledDeviceCameraSensorIn;
  MinFocusDistance = MinFocusDistanceIn;
  EffectiveDiameterOfObjective = EffectiveDiameterOfObjectiveIn;
  StadiaBaseConstant = StadiaBaseConstantIn;
  StadiaRateConstant = StadiaRateConstantIn;
  MinPowerSupplyVoltage = MinPowerSupplyVoltageIn;
  MaxPowerSupplyVoltage = MaxPowerSupplyVoltageIn;
  Laser = LaserIn;
}

TheodoliteType::~TheodoliteType()
{
  #ifndef NODESTRUCT
  delete LongitudinalTrackingSpeed;
  delete LateralTrackingSpeed;
  delete Magnification;
  delete FieldOfViewDiameter;
  delete ApertureSize;
  delete MaxFocusDistance;
  delete AngularAccuracy;
  delete MaxTiltCompensation;
  delete ChargeCoupledDeviceCameraSensor;
  delete MinFocusDistance;
  delete EffectiveDiameterOfObjective;
  delete StadiaBaseConstant;
  delete StadiaRateConstant;
  delete MinPowerSupplyVoltage;
  delete MaxPowerSupplyVoltage;
  delete Laser;
  #endif
}

void TheodoliteType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Calibrations)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Calibrations");
      Calibrations->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Calibrations>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (Resolution)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (Resolution->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(Resolution->getprintElement(), "LinearResolution") == 0)
          {
            LinearResolutionType * typ;
            if ((typ = dynamic_cast<LinearResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<LinearResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LinearResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad LinearResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "CartesianResolution") == 0)
          {
            CartesianResolutionType * typ;
            if ((typ = dynamic_cast<CartesianResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<CartesianResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "SphericalResolution") == 0)
          {
            SphericalResolutionType * typ;
            if ((typ = dynamic_cast<SphericalResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<SphericalResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "UserDefinedResolution") == 0)
          {
            UserDefinedResolutionType * typ;
            if ((typ = dynamic_cast<UserDefinedResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<UserDefinedResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedResolution element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad Resolution type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (WorkingVolume)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (WorkingVolume->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(WorkingVolume->getprintElement(), "ClosedShellSetWorkingVolume") == 0)
          {
            ClosedShellSetWorkingVolumeType * typ;
            if ((typ = dynamic_cast<ClosedShellSetWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<ClosedShellSetWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ClosedShellSetWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad ClosedShellSetWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "CartesianWorkingVolume") == 0)
          {
            CartesianWorkingVolumeType * typ;
            if ((typ = dynamic_cast<CartesianWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<CartesianWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "SphericalWorkingVolume") == 0)
          {
            SphericalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<SphericalWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<SphericalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "CylindricalWorkingVolume") == 0)
          {
            CylindricalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<CylindricalWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<CylindricalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CylindricalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad CylindricalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "UserDefinedWorkingVolume") == 0)
          {
            UserDefinedWorkingVolumeType * typ;
            if ((typ = dynamic_cast<UserDefinedWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<UserDefinedWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedWorkingVolume element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad WorkingVolume type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (EffectiveWorkingVolume)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (EffectiveWorkingVolume->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveClosedShellSetWorkingVolume") == 0)
          {
            EffectiveClosedShellSetWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveClosedShellSetWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveClosedShellSetWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveClosedShellSetWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveClosedShellSetWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveCartesianWorkingVolume") == 0)
          {
            EffectiveCartesianWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveCartesianWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveCartesianWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveCartesianWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveCartesianWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveSphericalWorkingVolume") == 0)
          {
            EffectiveSphericalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveSphericalWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveSphericalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveSphericalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveSphericalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveCylindricalWorkingVolume") == 0)
          {
            EffectiveCylindricalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveCylindricalWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveCylindricalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveCylindricalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveCylindricalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveUserDefinedWorkingVolume") == 0)
          {
            EffectiveUserDefinedWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveUserDefinedWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveUserDefinedWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveUserDefinedWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveUserDefinedWorkingVolume element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad EffectiveWorkingVolume type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (TemperatureCompensation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TemperatureCompensation");
      TemperatureCompensation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</TemperatureCompensation>\n");
    }
  if (LongitudinalTrackingSpeed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LongitudinalTrackingSpeed");
      LongitudinalTrackingSpeed->printSelf(outFile);
      fprintf(outFile, "</LongitudinalTrackingSpeed>\n");
    }
  if (LateralTrackingSpeed)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LateralTrackingSpeed");
      LateralTrackingSpeed->printSelf(outFile);
      fprintf(outFile, "</LateralTrackingSpeed>\n");
    }
  if (Magnification)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Magnification");
      Magnification->printSelf(outFile);
      fprintf(outFile, "</Magnification>\n");
    }
  if (FieldOfViewDiameter)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FieldOfViewDiameter");
      FieldOfViewDiameter->printSelf(outFile);
      fprintf(outFile, "</FieldOfViewDiameter>\n");
    }
  if (ApertureSize)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ApertureSize");
      ApertureSize->printSelf(outFile);
      fprintf(outFile, "</ApertureSize>\n");
    }
  if (MaxFocusDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxFocusDistance");
      MaxFocusDistance->printSelf(outFile);
      fprintf(outFile, "</MaxFocusDistance>\n");
    }
  if (AngularAccuracy)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AngularAccuracy");
      AngularAccuracy->printSelf(outFile);
      fprintf(outFile, "</AngularAccuracy>\n");
    }
  if (MaxTiltCompensation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxTiltCompensation");
      MaxTiltCompensation->printSelf(outFile);
      fprintf(outFile, "</MaxTiltCompensation>\n");
    }
  if (ChargeCoupledDeviceCameraSensor)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ChargeCoupledDeviceCameraSensor");
      ChargeCoupledDeviceCameraSensor->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ChargeCoupledDeviceCameraSensor>\n");
    }
  if (MinFocusDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinFocusDistance");
      MinFocusDistance->printSelf(outFile);
      fprintf(outFile, "</MinFocusDistance>\n");
    }
  if (EffectiveDiameterOfObjective)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EffectiveDiameterOfObjective");
      EffectiveDiameterOfObjective->printSelf(outFile);
      fprintf(outFile, "</EffectiveDiameterOfObjective>\n");
    }
  if (StadiaBaseConstant)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StadiaBaseConstant");
      StadiaBaseConstant->printSelf(outFile);
      fprintf(outFile, "</StadiaBaseConstant>\n");
    }
  if (StadiaRateConstant)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StadiaRateConstant");
      StadiaRateConstant->printSelf(outFile);
      fprintf(outFile, "</StadiaRateConstant>\n");
    }
  if (MinPowerSupplyVoltage)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinPowerSupplyVoltage");
      MinPowerSupplyVoltage->printSelf(outFile);
      fprintf(outFile, "</MinPowerSupplyVoltage>\n");
    }
  if (MaxPowerSupplyVoltage)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxPowerSupplyVoltage");
      MaxPowerSupplyVoltage->printSelf(outFile);
      fprintf(outFile, "</MaxPowerSupplyVoltage>\n");
    }
  if (Laser)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Laser");
      Laser->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Laser>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool TheodoliteType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in TheodoliteType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in TheodoliteType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in TheodoliteType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in TheodoliteType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

SpeedValueType * TheodoliteType::getLongitudinalTrackingSpeed()
{return LongitudinalTrackingSpeed;}

void TheodoliteType::setLongitudinalTrackingSpeed(SpeedValueType * LongitudinalTrackingSpeedIn)
{LongitudinalTrackingSpeed = LongitudinalTrackingSpeedIn;}

SpeedValueType * TheodoliteType::getLateralTrackingSpeed()
{return LateralTrackingSpeed;}

void TheodoliteType::setLateralTrackingSpeed(SpeedValueType * LateralTrackingSpeedIn)
{LateralTrackingSpeed = LateralTrackingSpeedIn;}

XmlDecimal * TheodoliteType::getMagnification()
{return Magnification;}

void TheodoliteType::setMagnification(XmlDecimal * MagnificationIn)
{Magnification = MagnificationIn;}

LinearValueType * TheodoliteType::getFieldOfViewDiameter()
{return FieldOfViewDiameter;}

void TheodoliteType::setFieldOfViewDiameter(LinearValueType * FieldOfViewDiameterIn)
{FieldOfViewDiameter = FieldOfViewDiameterIn;}

LinearValueType * TheodoliteType::getApertureSize()
{return ApertureSize;}

void TheodoliteType::setApertureSize(LinearValueType * ApertureSizeIn)
{ApertureSize = ApertureSizeIn;}

LinearValueType * TheodoliteType::getMaxFocusDistance()
{return MaxFocusDistance;}

void TheodoliteType::setMaxFocusDistance(LinearValueType * MaxFocusDistanceIn)
{MaxFocusDistance = MaxFocusDistanceIn;}

AngularValueType * TheodoliteType::getAngularAccuracy()
{return AngularAccuracy;}

void TheodoliteType::setAngularAccuracy(AngularValueType * AngularAccuracyIn)
{AngularAccuracy = AngularAccuracyIn;}

AngularValueType * TheodoliteType::getMaxTiltCompensation()
{return MaxTiltCompensation;}

void TheodoliteType::setMaxTiltCompensation(AngularValueType * MaxTiltCompensationIn)
{MaxTiltCompensation = MaxTiltCompensationIn;}

ChargeCoupledDeviceCameraSensorType * TheodoliteType::getChargeCoupledDeviceCameraSensor()
{return ChargeCoupledDeviceCameraSensor;}

void TheodoliteType::setChargeCoupledDeviceCameraSensor(ChargeCoupledDeviceCameraSensorType * ChargeCoupledDeviceCameraSensorIn)
{ChargeCoupledDeviceCameraSensor = ChargeCoupledDeviceCameraSensorIn;}

LinearValueType * TheodoliteType::getMinFocusDistance()
{return MinFocusDistance;}

void TheodoliteType::setMinFocusDistance(LinearValueType * MinFocusDistanceIn)
{MinFocusDistance = MinFocusDistanceIn;}

LinearValueType * TheodoliteType::getEffectiveDiameterOfObjective()
{return EffectiveDiameterOfObjective;}

void TheodoliteType::setEffectiveDiameterOfObjective(LinearValueType * EffectiveDiameterOfObjectiveIn)
{EffectiveDiameterOfObjective = EffectiveDiameterOfObjectiveIn;}

UserDefinedUnitValueType * TheodoliteType::getStadiaBaseConstant()
{return StadiaBaseConstant;}

void TheodoliteType::setStadiaBaseConstant(UserDefinedUnitValueType * StadiaBaseConstantIn)
{StadiaBaseConstant = StadiaBaseConstantIn;}

UserDefinedUnitValueType * TheodoliteType::getStadiaRateConstant()
{return StadiaRateConstant;}

void TheodoliteType::setStadiaRateConstant(UserDefinedUnitValueType * StadiaRateConstantIn)
{StadiaRateConstant = StadiaRateConstantIn;}

UserDefinedUnitValueType * TheodoliteType::getMinPowerSupplyVoltage()
{return MinPowerSupplyVoltage;}

void TheodoliteType::setMinPowerSupplyVoltage(UserDefinedUnitValueType * MinPowerSupplyVoltageIn)
{MinPowerSupplyVoltage = MinPowerSupplyVoltageIn;}

UserDefinedUnitValueType * TheodoliteType::getMaxPowerSupplyVoltage()
{return MaxPowerSupplyVoltage;}

void TheodoliteType::setMaxPowerSupplyVoltage(UserDefinedUnitValueType * MaxPowerSupplyVoltageIn)
{MaxPowerSupplyVoltage = MaxPowerSupplyVoltageIn;}

LaserType * TheodoliteType::getLaser()
{return Laser;}

void TheodoliteType::setLaser(LaserType * LaserIn)
{Laser = LaserIn;}

/* ***************************************************************** */

/* class TipEndGeometryEnumType

*/

TipEndGeometryEnumType::TipEndGeometryEnumType() :
  XmlNMTOKEN()
{
}

TipEndGeometryEnumType::TipEndGeometryEnumType(
 const char * valIn) :
  XmlNMTOKEN(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "SPHERE") &&
           strcmp(val.c_str(), "CYLINDER") &&
           strcmp(val.c_str(), "CYLINDER_WITH_SPHERE") &&
           strcmp(val.c_str(), "HEMISPHERE") &&
           strcmp(val.c_str(), "SPHERICAL_DISC") &&
           strcmp(val.c_str(), "POINT"));
}

TipEndGeometryEnumType::~TipEndGeometryEnumType() {}

bool TipEndGeometryEnumType::TipEndGeometryEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "SPHERE") &&
          strcmp(val.c_str(), "CYLINDER") &&
          strcmp(val.c_str(), "CYLINDER_WITH_SPHERE") &&
          strcmp(val.c_str(), "HEMISPHERE") &&
          strcmp(val.c_str(), "SPHERICAL_DISC") &&
          strcmp(val.c_str(), "POINT"));
}

void TipEndGeometryEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "TipEndGeometryEnumType");
}

void TipEndGeometryEnumType::printSelf(FILE * outFile)
{
  if (TipEndGeometryEnumTypeIsBad())
    {
      fprintf(stderr, "bad TipEndGeometryEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::printSelf(outFile);
}

void TipEndGeometryEnumType::oPrintSelf(FILE * outFile)
{
  if (TipEndGeometryEnumTypeIsBad())
    {
      fprintf(stderr, "bad TipEndGeometryEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class TipEndGeometryType

*/

TipEndGeometryType::TipEndGeometryType()
{
  TipEndGeometryTypePair = 0;
}

TipEndGeometryType::TipEndGeometryType(
 TipEndGeometryTypeChoicePair * TipEndGeometryTypePairIn)
{
  TipEndGeometryTypePair = TipEndGeometryTypePairIn;
}

TipEndGeometryType::~TipEndGeometryType()
{
  #ifndef NODESTRUCT
  delete TipEndGeometryTypePair;
  #endif
}

void TipEndGeometryType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  TipEndGeometryTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

TipEndGeometryTypeChoicePair * TipEndGeometryType::getTipEndGeometryTypePair()
{return TipEndGeometryTypePair;}

void TipEndGeometryType::setTipEndGeometryTypePair(TipEndGeometryTypeChoicePair * TipEndGeometryTypePairIn)
{TipEndGeometryTypePair = TipEndGeometryTypePairIn;}
TipEndGeometryTypeChoicePair::TipEndGeometryTypeChoicePair() {}

TipEndGeometryTypeChoicePair::TipEndGeometryTypeChoicePair(
 whichOne TipEndGeometryTypeTypeIn,
 TipEndGeometryTypeVal TipEndGeometryTypeValueIn)
{
  TipEndGeometryTypeType = TipEndGeometryTypeTypeIn;
  TipEndGeometryTypeValue = TipEndGeometryTypeValueIn;
}

TipEndGeometryTypeChoicePair::~TipEndGeometryTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (TipEndGeometryTypeType == TipEndGeometryEnumE)
    delete TipEndGeometryTypeValue.TipEndGeometryEnum;
  else if (TipEndGeometryTypeType == OtherTipEndGeometryE)
    delete TipEndGeometryTypeValue.OtherTipEndGeometry;
  #endif
}

void TipEndGeometryTypeChoicePair::printSelf(FILE * outFile)
{
  if (TipEndGeometryTypeType == TipEndGeometryEnumE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TipEndGeometryEnum");
      TipEndGeometryTypeValue.TipEndGeometryEnum->printSelf(outFile);
      fprintf(outFile, "</TipEndGeometryEnum>\n");
    }
  else if (TipEndGeometryTypeType == OtherTipEndGeometryE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OtherTipEndGeometry");
      TipEndGeometryTypeValue.OtherTipEndGeometry->printSelf(outFile);
      fprintf(outFile, "</OtherTipEndGeometry>\n");
    }
}

/* ***************************************************************** */

/* class ToolBaseType

*/

ToolBaseType::ToolBaseType() :
  MeasurementResourceBaseType()
{
}

ToolBaseType::ToolBaseType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn) :
  MeasurementResourceBaseType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
}

ToolBaseType::ToolBaseType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn) :
  MeasurementResourceBaseType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
}

ToolBaseType::~ToolBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void ToolBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ToolBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ToolBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ToolBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ToolBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ToolBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class ToolBaseTypeLisd

*/

ToolBaseTypeLisd::ToolBaseTypeLisd() {}

ToolBaseTypeLisd::ToolBaseTypeLisd(ToolBaseType * aToolBaseType)
{
  push_back(aToolBaseType);
}

ToolBaseTypeLisd::~ToolBaseTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<ToolBaseType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void ToolBaseTypeLisd::printSelf(FILE * outFile)
{
  std::list<ToolBaseType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class ToolWithCCDCameraSensorType

*/

ToolWithCCDCameraSensorType::ToolWithCCDCameraSensorType() :
  ToolWithIntegratedSensorBaseType()
{
  ChargeCoupledDeviceCameraSensor = 0;
}

ToolWithCCDCameraSensorType::ToolWithCCDCameraSensorType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 ChargeCoupledDeviceCameraSensorType * ChargeCoupledDeviceCameraSensorIn) :
  ToolWithIntegratedSensorBaseType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  ChargeCoupledDeviceCameraSensor = ChargeCoupledDeviceCameraSensorIn;
}

ToolWithCCDCameraSensorType::ToolWithCCDCameraSensorType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 ChargeCoupledDeviceCameraSensorType * ChargeCoupledDeviceCameraSensorIn) :
  ToolWithIntegratedSensorBaseType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  ChargeCoupledDeviceCameraSensor = ChargeCoupledDeviceCameraSensorIn;
}

ToolWithCCDCameraSensorType::~ToolWithCCDCameraSensorType()
{
  #ifndef NODESTRUCT
  delete ChargeCoupledDeviceCameraSensor;
  #endif
}

void ToolWithCCDCameraSensorType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ChargeCoupledDeviceCameraSensor");
  ChargeCoupledDeviceCameraSensor->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ChargeCoupledDeviceCameraSensor>\n");
  doSpaces(-INDENT, outFile);
}

bool ToolWithCCDCameraSensorType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ToolWithCCDCameraSensorType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ToolWithCCDCameraSensorType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ToolWithCCDCameraSensorType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ToolWithCCDCameraSensorType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

ChargeCoupledDeviceCameraSensorType * ToolWithCCDCameraSensorType::getChargeCoupledDeviceCameraSensor()
{return ChargeCoupledDeviceCameraSensor;}

void ToolWithCCDCameraSensorType::setChargeCoupledDeviceCameraSensor(ChargeCoupledDeviceCameraSensorType * ChargeCoupledDeviceCameraSensorIn)
{ChargeCoupledDeviceCameraSensor = ChargeCoupledDeviceCameraSensorIn;}

/* ***************************************************************** */

/* class ToolWithCapacitiveSensorType

*/

ToolWithCapacitiveSensorType::ToolWithCapacitiveSensorType() :
  ToolWithIntegratedSensorBaseType()
{
  CapacitiveSensor = 0;
}

ToolWithCapacitiveSensorType::ToolWithCapacitiveSensorType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CapacitiveSensorType * CapacitiveSensorIn) :
  ToolWithIntegratedSensorBaseType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  CapacitiveSensor = CapacitiveSensorIn;
}

ToolWithCapacitiveSensorType::ToolWithCapacitiveSensorType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CapacitiveSensorType * CapacitiveSensorIn) :
  ToolWithIntegratedSensorBaseType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  CapacitiveSensor = CapacitiveSensorIn;
}

ToolWithCapacitiveSensorType::~ToolWithCapacitiveSensorType()
{
  #ifndef NODESTRUCT
  delete CapacitiveSensor;
  #endif
}

void ToolWithCapacitiveSensorType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<CapacitiveSensor");
  CapacitiveSensor->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</CapacitiveSensor>\n");
  doSpaces(-INDENT, outFile);
}

bool ToolWithCapacitiveSensorType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ToolWithCapacitiveSensorType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ToolWithCapacitiveSensorType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ToolWithCapacitiveSensorType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ToolWithCapacitiveSensorType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

CapacitiveSensorType * ToolWithCapacitiveSensorType::getCapacitiveSensor()
{return CapacitiveSensor;}

void ToolWithCapacitiveSensorType::setCapacitiveSensor(CapacitiveSensorType * CapacitiveSensorIn)
{CapacitiveSensor = CapacitiveSensorIn;}

/* ***************************************************************** */

/* class ToolWithComplexTactileProbeSensorType

*/

ToolWithComplexTactileProbeSensorType::ToolWithComplexTactileProbeSensorType() :
  ToolWithIntegratedSensorBaseType()
{
  ComplexTactileProbeSensor = 0;
}

ToolWithComplexTactileProbeSensorType::ToolWithComplexTactileProbeSensorType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 ComplexTactileProbeSensorType * ComplexTactileProbeSensorIn) :
  ToolWithIntegratedSensorBaseType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  ComplexTactileProbeSensor = ComplexTactileProbeSensorIn;
}

ToolWithComplexTactileProbeSensorType::ToolWithComplexTactileProbeSensorType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 ComplexTactileProbeSensorType * ComplexTactileProbeSensorIn) :
  ToolWithIntegratedSensorBaseType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  ComplexTactileProbeSensor = ComplexTactileProbeSensorIn;
}

ToolWithComplexTactileProbeSensorType::~ToolWithComplexTactileProbeSensorType()
{
  #ifndef NODESTRUCT
  delete ComplexTactileProbeSensor;
  #endif
}

void ToolWithComplexTactileProbeSensorType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ComplexTactileProbeSensor");
  ComplexTactileProbeSensor->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ComplexTactileProbeSensor>\n");
  doSpaces(-INDENT, outFile);
}

bool ToolWithComplexTactileProbeSensorType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ToolWithComplexTactileProbeSensorType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ToolWithComplexTactileProbeSensorType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ToolWithComplexTactileProbeSensorType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ToolWithComplexTactileProbeSensorType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

ComplexTactileProbeSensorType * ToolWithComplexTactileProbeSensorType::getComplexTactileProbeSensor()
{return ComplexTactileProbeSensor;}

void ToolWithComplexTactileProbeSensorType::setComplexTactileProbeSensor(ComplexTactileProbeSensorType * ComplexTactileProbeSensorIn)
{ComplexTactileProbeSensor = ComplexTactileProbeSensorIn;}

/* ***************************************************************** */

/* class ToolWithConfocalChromaticSensorType

*/

ToolWithConfocalChromaticSensorType::ToolWithConfocalChromaticSensorType() :
  ToolWithIntegratedSensorBaseType()
{
  ConfocalChromaticSensor = 0;
}

ToolWithConfocalChromaticSensorType::ToolWithConfocalChromaticSensorType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 ConfocalChromaticSensorType * ConfocalChromaticSensorIn) :
  ToolWithIntegratedSensorBaseType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  ConfocalChromaticSensor = ConfocalChromaticSensorIn;
}

ToolWithConfocalChromaticSensorType::ToolWithConfocalChromaticSensorType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 ConfocalChromaticSensorType * ConfocalChromaticSensorIn) :
  ToolWithIntegratedSensorBaseType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  ConfocalChromaticSensor = ConfocalChromaticSensorIn;
}

ToolWithConfocalChromaticSensorType::~ToolWithConfocalChromaticSensorType()
{
  #ifndef NODESTRUCT
  delete ConfocalChromaticSensor;
  #endif
}

void ToolWithConfocalChromaticSensorType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<ConfocalChromaticSensor");
  ConfocalChromaticSensor->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ConfocalChromaticSensor>\n");
  doSpaces(-INDENT, outFile);
}

bool ToolWithConfocalChromaticSensorType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ToolWithConfocalChromaticSensorType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ToolWithConfocalChromaticSensorType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ToolWithConfocalChromaticSensorType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ToolWithConfocalChromaticSensorType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

ConfocalChromaticSensorType * ToolWithConfocalChromaticSensorType::getConfocalChromaticSensor()
{return ConfocalChromaticSensor;}

void ToolWithConfocalChromaticSensorType::setConfocalChromaticSensor(ConfocalChromaticSensorType * ConfocalChromaticSensorIn)
{ConfocalChromaticSensor = ConfocalChromaticSensorIn;}

/* ***************************************************************** */

/* class ToolWithDVRTSensorType

*/

ToolWithDVRTSensorType::ToolWithDVRTSensorType() :
  ToolWithIntegratedSensorBaseType()
{
  DVRTSensor = 0;
}

ToolWithDVRTSensorType::ToolWithDVRTSensorType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 DifferentialVariableReluctanceTransducerSensorType * DVRTSensorIn) :
  ToolWithIntegratedSensorBaseType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  DVRTSensor = DVRTSensorIn;
}

ToolWithDVRTSensorType::ToolWithDVRTSensorType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 DifferentialVariableReluctanceTransducerSensorType * DVRTSensorIn) :
  ToolWithIntegratedSensorBaseType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  DVRTSensor = DVRTSensorIn;
}

ToolWithDVRTSensorType::~ToolWithDVRTSensorType()
{
  #ifndef NODESTRUCT
  delete DVRTSensor;
  #endif
}

void ToolWithDVRTSensorType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<DVRTSensor");
  DVRTSensor->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DVRTSensor>\n");
  doSpaces(-INDENT, outFile);
}

bool ToolWithDVRTSensorType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ToolWithDVRTSensorType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ToolWithDVRTSensorType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ToolWithDVRTSensorType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ToolWithDVRTSensorType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

DifferentialVariableReluctanceTransducerSensorType * ToolWithDVRTSensorType::getDVRTSensor()
{return DVRTSensor;}

void ToolWithDVRTSensorType::setDVRTSensor(DifferentialVariableReluctanceTransducerSensorType * DVRTSensorIn)
{DVRTSensor = DVRTSensorIn;}

/* ***************************************************************** */

/* class ToolWithDetachableSensorsType

*/

ToolWithDetachableSensorsType::ToolWithDetachableSensorsType() :
  ToolBaseType()
{
  SensorIds = 0;
}

ToolWithDetachableSensorsType::ToolWithDetachableSensorsType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 ArrayReferenceType * SensorIdsIn) :
  ToolBaseType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  SensorIds = SensorIdsIn;
}

ToolWithDetachableSensorsType::ToolWithDetachableSensorsType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 ArrayReferenceType * SensorIdsIn) :
  ToolBaseType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  SensorIds = SensorIdsIn;
}

ToolWithDetachableSensorsType::~ToolWithDetachableSensorsType()
{
  #ifndef NODESTRUCT
  delete SensorIds;
  #endif
}

void ToolWithDetachableSensorsType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (SensorIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SensorIds");
      SensorIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SensorIds>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ToolWithDetachableSensorsType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ToolWithDetachableSensorsType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ToolWithDetachableSensorsType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ToolWithDetachableSensorsType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ToolWithDetachableSensorsType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

ArrayReferenceType * ToolWithDetachableSensorsType::getSensorIds()
{return SensorIds;}

void ToolWithDetachableSensorsType::setSensorIds(ArrayReferenceType * SensorIdsIn)
{SensorIds = SensorIdsIn;}

/* ***************************************************************** */

/* class ToolWithDrawWireSensorType

*/

ToolWithDrawWireSensorType::ToolWithDrawWireSensorType() :
  ToolWithIntegratedSensorBaseType()
{
  DrawWireSensor = 0;
}

ToolWithDrawWireSensorType::ToolWithDrawWireSensorType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 DrawWireSensorType * DrawWireSensorIn) :
  ToolWithIntegratedSensorBaseType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  DrawWireSensor = DrawWireSensorIn;
}

ToolWithDrawWireSensorType::ToolWithDrawWireSensorType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 DrawWireSensorType * DrawWireSensorIn) :
  ToolWithIntegratedSensorBaseType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  DrawWireSensor = DrawWireSensorIn;
}

ToolWithDrawWireSensorType::~ToolWithDrawWireSensorType()
{
  #ifndef NODESTRUCT
  delete DrawWireSensor;
  #endif
}

void ToolWithDrawWireSensorType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<DrawWireSensor");
  DrawWireSensor->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DrawWireSensor>\n");
  doSpaces(-INDENT, outFile);
}

bool ToolWithDrawWireSensorType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ToolWithDrawWireSensorType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ToolWithDrawWireSensorType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ToolWithDrawWireSensorType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ToolWithDrawWireSensorType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

DrawWireSensorType * ToolWithDrawWireSensorType::getDrawWireSensor()
{return DrawWireSensor;}

void ToolWithDrawWireSensorType::setDrawWireSensor(DrawWireSensorType * DrawWireSensorIn)
{DrawWireSensor = DrawWireSensorIn;}

/* ***************************************************************** */

/* class ToolWithEddyCurrentSensorType

*/

ToolWithEddyCurrentSensorType::ToolWithEddyCurrentSensorType() :
  ToolWithIntegratedSensorBaseType()
{
  EddyCurrentSensor = 0;
}

ToolWithEddyCurrentSensorType::ToolWithEddyCurrentSensorType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 EddyCurrentSensorType * EddyCurrentSensorIn) :
  ToolWithIntegratedSensorBaseType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  EddyCurrentSensor = EddyCurrentSensorIn;
}

ToolWithEddyCurrentSensorType::ToolWithEddyCurrentSensorType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 EddyCurrentSensorType * EddyCurrentSensorIn) :
  ToolWithIntegratedSensorBaseType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  EddyCurrentSensor = EddyCurrentSensorIn;
}

ToolWithEddyCurrentSensorType::~ToolWithEddyCurrentSensorType()
{
  #ifndef NODESTRUCT
  delete EddyCurrentSensor;
  #endif
}

void ToolWithEddyCurrentSensorType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<EddyCurrentSensor");
  EddyCurrentSensor->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</EddyCurrentSensor>\n");
  doSpaces(-INDENT, outFile);
}

bool ToolWithEddyCurrentSensorType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ToolWithEddyCurrentSensorType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ToolWithEddyCurrentSensorType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ToolWithEddyCurrentSensorType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ToolWithEddyCurrentSensorType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

EddyCurrentSensorType * ToolWithEddyCurrentSensorType::getEddyCurrentSensor()
{return EddyCurrentSensor;}

void ToolWithEddyCurrentSensorType::setEddyCurrentSensor(EddyCurrentSensorType * EddyCurrentSensorIn)
{EddyCurrentSensor = EddyCurrentSensorIn;}

/* ***************************************************************** */

/* class ToolWithIntegratedSensorBaseType

*/

ToolWithIntegratedSensorBaseType::ToolWithIntegratedSensorBaseType() :
  ToolBaseType()
{
}

ToolWithIntegratedSensorBaseType::ToolWithIntegratedSensorBaseType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn) :
  ToolBaseType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
}

ToolWithIntegratedSensorBaseType::ToolWithIntegratedSensorBaseType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn) :
  ToolBaseType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
}

ToolWithIntegratedSensorBaseType::~ToolWithIntegratedSensorBaseType()
{
  #ifndef NODESTRUCT
  #endif
}

void ToolWithIntegratedSensorBaseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool ToolWithIntegratedSensorBaseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ToolWithIntegratedSensorBaseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ToolWithIntegratedSensorBaseType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ToolWithIntegratedSensorBaseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ToolWithIntegratedSensorBaseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

/* ***************************************************************** */

/* class ToolWithLVDTSensorType

*/

ToolWithLVDTSensorType::ToolWithLVDTSensorType() :
  ToolWithIntegratedSensorBaseType()
{
  LVDTSensor = 0;
}

ToolWithLVDTSensorType::ToolWithLVDTSensorType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 LinearVariableDifferentialTransformerSensorType * LVDTSensorIn) :
  ToolWithIntegratedSensorBaseType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  LVDTSensor = LVDTSensorIn;
}

ToolWithLVDTSensorType::ToolWithLVDTSensorType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 LinearVariableDifferentialTransformerSensorType * LVDTSensorIn) :
  ToolWithIntegratedSensorBaseType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  LVDTSensor = LVDTSensorIn;
}

ToolWithLVDTSensorType::~ToolWithLVDTSensorType()
{
  #ifndef NODESTRUCT
  delete LVDTSensor;
  #endif
}

void ToolWithLVDTSensorType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<LVDTSensor");
  LVDTSensor->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</LVDTSensor>\n");
  doSpaces(-INDENT, outFile);
}

bool ToolWithLVDTSensorType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ToolWithLVDTSensorType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ToolWithLVDTSensorType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ToolWithLVDTSensorType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ToolWithLVDTSensorType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LinearVariableDifferentialTransformerSensorType * ToolWithLVDTSensorType::getLVDTSensor()
{return LVDTSensor;}

void ToolWithLVDTSensorType::setLVDTSensor(LinearVariableDifferentialTransformerSensorType * LVDTSensorIn)
{LVDTSensor = LVDTSensorIn;}

/* ***************************************************************** */

/* class ToolWithLaserTriangulationSensorType

*/

ToolWithLaserTriangulationSensorType::ToolWithLaserTriangulationSensorType() :
  ToolWithIntegratedSensorBaseType()
{
  LaserTriangulationSensor = 0;
}

ToolWithLaserTriangulationSensorType::ToolWithLaserTriangulationSensorType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 LaserTriangulationSensorType * LaserTriangulationSensorIn) :
  ToolWithIntegratedSensorBaseType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  LaserTriangulationSensor = LaserTriangulationSensorIn;
}

ToolWithLaserTriangulationSensorType::ToolWithLaserTriangulationSensorType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 LaserTriangulationSensorType * LaserTriangulationSensorIn) :
  ToolWithIntegratedSensorBaseType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  LaserTriangulationSensor = LaserTriangulationSensorIn;
}

ToolWithLaserTriangulationSensorType::~ToolWithLaserTriangulationSensorType()
{
  #ifndef NODESTRUCT
  delete LaserTriangulationSensor;
  #endif
}

void ToolWithLaserTriangulationSensorType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<LaserTriangulationSensor");
  LaserTriangulationSensor->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</LaserTriangulationSensor>\n");
  doSpaces(-INDENT, outFile);
}

bool ToolWithLaserTriangulationSensorType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ToolWithLaserTriangulationSensorType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ToolWithLaserTriangulationSensorType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ToolWithLaserTriangulationSensorType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ToolWithLaserTriangulationSensorType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LaserTriangulationSensorType * ToolWithLaserTriangulationSensorType::getLaserTriangulationSensor()
{return LaserTriangulationSensor;}

void ToolWithLaserTriangulationSensorType::setLaserTriangulationSensor(LaserTriangulationSensorType * LaserTriangulationSensorIn)
{LaserTriangulationSensor = LaserTriangulationSensorIn;}

/* ***************************************************************** */

/* class ToolWithMagnetoInductiveSensorType

*/

ToolWithMagnetoInductiveSensorType::ToolWithMagnetoInductiveSensorType() :
  ToolWithIntegratedSensorBaseType()
{
  MagnetoInductiveSensor = 0;
}

ToolWithMagnetoInductiveSensorType::ToolWithMagnetoInductiveSensorType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 MagnetoInductiveSensorType * MagnetoInductiveSensorIn) :
  ToolWithIntegratedSensorBaseType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  MagnetoInductiveSensor = MagnetoInductiveSensorIn;
}

ToolWithMagnetoInductiveSensorType::ToolWithMagnetoInductiveSensorType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 MagnetoInductiveSensorType * MagnetoInductiveSensorIn) :
  ToolWithIntegratedSensorBaseType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  MagnetoInductiveSensor = MagnetoInductiveSensorIn;
}

ToolWithMagnetoInductiveSensorType::~ToolWithMagnetoInductiveSensorType()
{
  #ifndef NODESTRUCT
  delete MagnetoInductiveSensor;
  #endif
}

void ToolWithMagnetoInductiveSensorType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<MagnetoInductiveSensor");
  MagnetoInductiveSensor->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</MagnetoInductiveSensor>\n");
  doSpaces(-INDENT, outFile);
}

bool ToolWithMagnetoInductiveSensorType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ToolWithMagnetoInductiveSensorType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ToolWithMagnetoInductiveSensorType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ToolWithMagnetoInductiveSensorType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ToolWithMagnetoInductiveSensorType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

MagnetoInductiveSensorType * ToolWithMagnetoInductiveSensorType::getMagnetoInductiveSensor()
{return MagnetoInductiveSensor;}

void ToolWithMagnetoInductiveSensorType::setMagnetoInductiveSensor(MagnetoInductiveSensorType * MagnetoInductiveSensorIn)
{MagnetoInductiveSensor = MagnetoInductiveSensorIn;}

/* ***************************************************************** */

/* class ToolWithSimpleTactileProbeSensorType

*/

ToolWithSimpleTactileProbeSensorType::ToolWithSimpleTactileProbeSensorType() :
  ToolWithIntegratedSensorBaseType()
{
  SimpleTactileProbeSensor = 0;
}

ToolWithSimpleTactileProbeSensorType::ToolWithSimpleTactileProbeSensorType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 SimpleTactileProbeSensorType * SimpleTactileProbeSensorIn) :
  ToolWithIntegratedSensorBaseType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  SimpleTactileProbeSensor = SimpleTactileProbeSensorIn;
}

ToolWithSimpleTactileProbeSensorType::ToolWithSimpleTactileProbeSensorType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 SimpleTactileProbeSensorType * SimpleTactileProbeSensorIn) :
  ToolWithIntegratedSensorBaseType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  SimpleTactileProbeSensor = SimpleTactileProbeSensorIn;
}

ToolWithSimpleTactileProbeSensorType::~ToolWithSimpleTactileProbeSensorType()
{
  #ifndef NODESTRUCT
  delete SimpleTactileProbeSensor;
  #endif
}

void ToolWithSimpleTactileProbeSensorType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<SimpleTactileProbeSensor");
  SimpleTactileProbeSensor->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</SimpleTactileProbeSensor>\n");
  doSpaces(-INDENT, outFile);
}

bool ToolWithSimpleTactileProbeSensorType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ToolWithSimpleTactileProbeSensorType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ToolWithSimpleTactileProbeSensorType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ToolWithSimpleTactileProbeSensorType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ToolWithSimpleTactileProbeSensorType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

SimpleTactileProbeSensorType * ToolWithSimpleTactileProbeSensorType::getSimpleTactileProbeSensor()
{return SimpleTactileProbeSensor;}

void ToolWithSimpleTactileProbeSensorType::setSimpleTactileProbeSensor(SimpleTactileProbeSensorType * SimpleTactileProbeSensorIn)
{SimpleTactileProbeSensor = SimpleTactileProbeSensorIn;}

/* ***************************************************************** */

/* class ToolWithStructuredLightSensorType

*/

ToolWithStructuredLightSensorType::ToolWithStructuredLightSensorType() :
  ToolWithIntegratedSensorBaseType()
{
  StructuredLightSensor = 0;
}

ToolWithStructuredLightSensorType::ToolWithStructuredLightSensorType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 StructuredLightSensorType * StructuredLightSensorIn) :
  ToolWithIntegratedSensorBaseType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  StructuredLightSensor = StructuredLightSensorIn;
}

ToolWithStructuredLightSensorType::ToolWithStructuredLightSensorType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 StructuredLightSensorType * StructuredLightSensorIn) :
  ToolWithIntegratedSensorBaseType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  StructuredLightSensor = StructuredLightSensorIn;
}

ToolWithStructuredLightSensorType::~ToolWithStructuredLightSensorType()
{
  #ifndef NODESTRUCT
  delete StructuredLightSensor;
  #endif
}

void ToolWithStructuredLightSensorType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<StructuredLightSensor");
  StructuredLightSensor->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</StructuredLightSensor>\n");
  doSpaces(-INDENT, outFile);
}

bool ToolWithStructuredLightSensorType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ToolWithStructuredLightSensorType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ToolWithStructuredLightSensorType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ToolWithStructuredLightSensorType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ToolWithStructuredLightSensorType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

StructuredLightSensorType * ToolWithStructuredLightSensorType::getStructuredLightSensor()
{return StructuredLightSensor;}

void ToolWithStructuredLightSensorType::setStructuredLightSensor(StructuredLightSensorType * StructuredLightSensorIn)
{StructuredLightSensor = StructuredLightSensorIn;}

/* ***************************************************************** */

/* class ToolWithUltrasonicSensorType

*/

ToolWithUltrasonicSensorType::ToolWithUltrasonicSensorType() :
  ToolWithIntegratedSensorBaseType()
{
  UltrasonicSensor = 0;
}

ToolWithUltrasonicSensorType::ToolWithUltrasonicSensorType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 UltrasonicSensorType * UltrasonicSensorIn) :
  ToolWithIntegratedSensorBaseType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  UltrasonicSensor = UltrasonicSensorIn;
}

ToolWithUltrasonicSensorType::ToolWithUltrasonicSensorType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 UltrasonicSensorType * UltrasonicSensorIn) :
  ToolWithIntegratedSensorBaseType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn)
{
  UltrasonicSensor = UltrasonicSensorIn;
}

ToolWithUltrasonicSensorType::~ToolWithUltrasonicSensorType()
{
  #ifndef NODESTRUCT
  delete UltrasonicSensor;
  #endif
}

void ToolWithUltrasonicSensorType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<UltrasonicSensor");
  UltrasonicSensor->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</UltrasonicSensor>\n");
  doSpaces(-INDENT, outFile);
}

bool ToolWithUltrasonicSensorType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in ToolWithUltrasonicSensorType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in ToolWithUltrasonicSensorType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ToolWithUltrasonicSensorType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in ToolWithUltrasonicSensorType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

UltrasonicSensorType * ToolWithUltrasonicSensorType::getUltrasonicSensor()
{return UltrasonicSensor;}

void ToolWithUltrasonicSensorType::setUltrasonicSensor(UltrasonicSensorType * UltrasonicSensorIn)
{UltrasonicSensor = UltrasonicSensorIn;}

/* ***************************************************************** */

/* class ToolsType

*/

ToolsType::ToolsType()
{
  n = 0;
  Tool = 0;
}

ToolsType::ToolsType(
 ToolBaseTypeLisd * ToolIn)
{
  n = 0;
  Tool = ToolIn;
}

ToolsType::ToolsType(
 NaturalType * nIn,
 ToolBaseTypeLisd * ToolIn)
{
  n = nIn;
  Tool = ToolIn;
}

ToolsType::~ToolsType()
{
  #ifndef NODESTRUCT
  delete n;
  delete Tool;
  #endif
}

void ToolsType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!Tool)
      {
        fprintf(stderr, "Tool list is missing\n");
        exit(1);
      }
    if (Tool->size() == 0)
      {
        fprintf(stderr, "Tool list is empty\n");
        exit(1);
      }
    if (Tool->size() < 1)
      {
        fprintf(stderr,
                "size of Tool list (%d) less than minimum required (1)\n",
                (int)Tool->size());
        exit(1);
      }
    std::list<ToolBaseType *>::iterator iter;
    for (iter = Tool->begin();
         iter != Tool->end(); iter++)
      {
        ToolBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->getprintElement(), "ToolWithIntegratedSensor") == 0)
          {
            ToolWithIntegratedSensorBaseType * typ;
            if ((typ = dynamic_cast<ToolWithIntegratedSensorBaseType *>(basie)))
              {
                fprintf(outFile, "<ToolWithIntegratedSensor");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ToolWithIntegratedSensor>\n");
              }
            else
              {
                fprintf(stderr, "bad ToolWithIntegratedSensor element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ToolWithDetachableSensors") == 0)
          {
            ToolWithDetachableSensorsType * typ;
            if ((typ = dynamic_cast<ToolWithDetachableSensorsType *>(basie)))
              {
                fprintf(outFile, "<ToolWithDetachableSensors");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ToolWithDetachableSensors>\n");
              }
            else
              {
                fprintf(stderr, "bad ToolWithDetachableSensors element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ToolWithLVDTSensor") == 0)
          {
            ToolWithLVDTSensorType * typ;
            if ((typ = dynamic_cast<ToolWithLVDTSensorType *>(basie)))
              {
                fprintf(outFile, "<ToolWithLVDTSensor");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ToolWithLVDTSensor>\n");
              }
            else
              {
                fprintf(stderr, "bad ToolWithLVDTSensor element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ToolWithCapacitiveSensor") == 0)
          {
            ToolWithCapacitiveSensorType * typ;
            if ((typ = dynamic_cast<ToolWithCapacitiveSensorType *>(basie)))
              {
                fprintf(outFile, "<ToolWithCapacitiveSensor");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ToolWithCapacitiveSensor>\n");
              }
            else
              {
                fprintf(stderr, "bad ToolWithCapacitiveSensor element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ToolWithEddyCurrentSensor") == 0)
          {
            ToolWithEddyCurrentSensorType * typ;
            if ((typ = dynamic_cast<ToolWithEddyCurrentSensorType *>(basie)))
              {
                fprintf(outFile, "<ToolWithEddyCurrentSensor");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ToolWithEddyCurrentSensor>\n");
              }
            else
              {
                fprintf(stderr, "bad ToolWithEddyCurrentSensor element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ToolWithConfocalChromaticSensor") == 0)
          {
            ToolWithConfocalChromaticSensorType * typ;
            if ((typ = dynamic_cast<ToolWithConfocalChromaticSensorType *>(basie)))
              {
                fprintf(outFile, "<ToolWithConfocalChromaticSensor");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ToolWithConfocalChromaticSensor>\n");
              }
            else
              {
                fprintf(stderr, "bad ToolWithConfocalChromaticSensor element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ToolWithDrawWireSensor") == 0)
          {
            ToolWithDrawWireSensorType * typ;
            if ((typ = dynamic_cast<ToolWithDrawWireSensorType *>(basie)))
              {
                fprintf(outFile, "<ToolWithDrawWireSensor");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ToolWithDrawWireSensor>\n");
              }
            else
              {
                fprintf(stderr, "bad ToolWithDrawWireSensor element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ToolWithMagnetoInductiveSensor") == 0)
          {
            ToolWithMagnetoInductiveSensorType * typ;
            if ((typ = dynamic_cast<ToolWithMagnetoInductiveSensorType *>(basie)))
              {
                fprintf(outFile, "<ToolWithMagnetoInductiveSensor");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ToolWithMagnetoInductiveSensor>\n");
              }
            else
              {
                fprintf(stderr, "bad ToolWithMagnetoInductiveSensor element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ToolWithDVRTSensor") == 0)
          {
            ToolWithDVRTSensorType * typ;
            if ((typ = dynamic_cast<ToolWithDVRTSensorType *>(basie)))
              {
                fprintf(outFile, "<ToolWithDVRTSensor");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ToolWithDVRTSensor>\n");
              }
            else
              {
                fprintf(stderr, "bad ToolWithDVRTSensor element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ToolWithLaserTriangulationSensor") == 0)
          {
            ToolWithLaserTriangulationSensorType * typ;
            if ((typ = dynamic_cast<ToolWithLaserTriangulationSensorType *>(basie)))
              {
                fprintf(outFile, "<ToolWithLaserTriangulationSensor");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ToolWithLaserTriangulationSensor>\n");
              }
            else
              {
                fprintf(stderr, "bad ToolWithLaserTriangulationSensor element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ToolWithStructuredLightSensor") == 0)
          {
            ToolWithStructuredLightSensorType * typ;
            if ((typ = dynamic_cast<ToolWithStructuredLightSensorType *>(basie)))
              {
                fprintf(outFile, "<ToolWithStructuredLightSensor");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ToolWithStructuredLightSensor>\n");
              }
            else
              {
                fprintf(stderr, "bad ToolWithStructuredLightSensor element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ToolWithUltrasonicSensor") == 0)
          {
            ToolWithUltrasonicSensorType * typ;
            if ((typ = dynamic_cast<ToolWithUltrasonicSensorType *>(basie)))
              {
                fprintf(outFile, "<ToolWithUltrasonicSensor");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ToolWithUltrasonicSensor>\n");
              }
            else
              {
                fprintf(stderr, "bad ToolWithUltrasonicSensor element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ToolWithSimpleTactileProbeSensor") == 0)
          {
            ToolWithSimpleTactileProbeSensorType * typ;
            if ((typ = dynamic_cast<ToolWithSimpleTactileProbeSensorType *>(basie)))
              {
                fprintf(outFile, "<ToolWithSimpleTactileProbeSensor");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ToolWithSimpleTactileProbeSensor>\n");
              }
            else
              {
                fprintf(stderr, "bad ToolWithSimpleTactileProbeSensor element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ToolWithComplexTactileProbeSensor") == 0)
          {
            ToolWithComplexTactileProbeSensorType * typ;
            if ((typ = dynamic_cast<ToolWithComplexTactileProbeSensorType *>(basie)))
              {
                fprintf(outFile, "<ToolWithComplexTactileProbeSensor");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ToolWithComplexTactileProbeSensor>\n");
              }
            else
              {
                fprintf(stderr, "bad ToolWithComplexTactileProbeSensor element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->getprintElement(), "ToolWithCCDCameraSensor") == 0)
          {
            ToolWithCCDCameraSensorType * typ;
            if ((typ = dynamic_cast<ToolWithCCDCameraSensorType *>(basie)))
              {
                fprintf(outFile, "<ToolWithCCDCameraSensor");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ToolWithCCDCameraSensor>\n");
              }
            else
              {
                fprintf(stderr, "bad ToolWithCCDCameraSensor element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad Tool type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool ToolsType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in ToolsType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in ToolsType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ToolsType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in ToolsType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * ToolsType::getn()
{return n;}

void ToolsType::setn(NaturalType * nIn)
{n = nIn;}

ToolBaseTypeLisd * ToolsType::getTool()
{return Tool;}

void ToolsType::setTool(ToolBaseTypeLisd * ToolIn)
{Tool = ToolIn;}

/* ***************************************************************** */

/* class TwentyLinearValuesType

*/

TwentyLinearValuesType::TwentyLinearValuesType()
{
  n = 0;
  LinearValue = 0;
}

TwentyLinearValuesType::TwentyLinearValuesType(
 LinearValueTypeLisd * LinearValueIn)
{
  n = 0;
  LinearValue = LinearValueIn;
}

TwentyLinearValuesType::TwentyLinearValuesType(
 NaturalType * nIn,
 LinearValueTypeLisd * LinearValueIn)
{
  n = nIn;
  LinearValue = LinearValueIn;
}

TwentyLinearValuesType::~TwentyLinearValuesType()
{
  #ifndef NODESTRUCT
  delete n;
  delete LinearValue;
  #endif
}

void TwentyLinearValuesType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!LinearValue)
      {
        fprintf(stderr, "LinearValue list is missing\n");
        exit(1);
      }
    if (LinearValue->size() == 0)
      {
        fprintf(stderr, "LinearValue list is empty\n");
        exit(1);
      }
    if (LinearValue->size() > 20)
      {
        fprintf(stderr,
                "size of LinearValue list (%d) greater than maximum allowed (20)\n",
                (int)LinearValue->size());
        exit(1);
      }
    if (LinearValue->size() < 20)
      {
        fprintf(stderr,
                "size of LinearValue list (%d) less than minimum required (20)\n",
                (int)LinearValue->size());
        exit(1);
      }
    std::list<LinearValueType *>::iterator iter;
    for (iter = LinearValue->begin();
         iter != LinearValue->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<LinearValue");
        (*iter)->printSelf(outFile);
        fprintf(outFile, "</LinearValue>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool TwentyLinearValuesType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in TwentyLinearValuesType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->getval().c_str());
          if (nVal->getbad())
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in TwentyLinearValuesType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in TwentyLinearValuesType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in TwentyLinearValuesType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * TwentyLinearValuesType::getn()
{return n;}

void TwentyLinearValuesType::setn(NaturalType * nIn)
{n = nIn;}

LinearValueTypeLisd * TwentyLinearValuesType::getLinearValue()
{return LinearValue;}

void TwentyLinearValuesType::setLinearValue(LinearValueTypeLisd * LinearValueIn)
{LinearValue = LinearValueIn;}

/* ***************************************************************** */

/* class TypeOfScaleEnumType

*/

TypeOfScaleEnumType::TypeOfScaleEnumType() :
  XmlNMTOKEN()
{
}

TypeOfScaleEnumType::TypeOfScaleEnumType(
 const char * valIn) :
  XmlNMTOKEN(
    valIn)
{
  if (!getbad())
    setbad(strcmp(val.c_str(), "ELECTROOPTICAL_LINEAR") &&
           strcmp(val.c_str(), "ELECTROOPTICAL_ROTARY") &&
           strcmp(val.c_str(), "LASER_INTERFEROMETER_LINEAR") &&
           strcmp(val.c_str(), "TIME_OF_FLIGHT_LINEAR"));
}

TypeOfScaleEnumType::~TypeOfScaleEnumType() {}

bool TypeOfScaleEnumType::TypeOfScaleEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "ELECTROOPTICAL_LINEAR") &&
          strcmp(val.c_str(), "ELECTROOPTICAL_ROTARY") &&
          strcmp(val.c_str(), "LASER_INTERFEROMETER_LINEAR") &&
          strcmp(val.c_str(), "TIME_OF_FLIGHT_LINEAR"));
}

void TypeOfScaleEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "TypeOfScaleEnumType");
}

void TypeOfScaleEnumType::printSelf(FILE * outFile)
{
  if (TypeOfScaleEnumTypeIsBad())
    {
      fprintf(stderr, "bad TypeOfScaleEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::printSelf(outFile);
}

void TypeOfScaleEnumType::oPrintSelf(FILE * outFile)
{
  if (TypeOfScaleEnumTypeIsBad())
    {
      fprintf(stderr, "bad TypeOfScaleEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class TypeOfScaleType

*/

TypeOfScaleType::TypeOfScaleType()
{
  TypeOfScaleTypePair = 0;
}

TypeOfScaleType::TypeOfScaleType(
 TypeOfScaleTypeChoicePair * TypeOfScaleTypePairIn)
{
  TypeOfScaleTypePair = TypeOfScaleTypePairIn;
}

TypeOfScaleType::~TypeOfScaleType()
{
  #ifndef NODESTRUCT
  delete TypeOfScaleTypePair;
  #endif
}

void TypeOfScaleType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  TypeOfScaleTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

TypeOfScaleTypeChoicePair * TypeOfScaleType::getTypeOfScaleTypePair()
{return TypeOfScaleTypePair;}

void TypeOfScaleType::setTypeOfScaleTypePair(TypeOfScaleTypeChoicePair * TypeOfScaleTypePairIn)
{TypeOfScaleTypePair = TypeOfScaleTypePairIn;}
TypeOfScaleTypeChoicePair::TypeOfScaleTypeChoicePair() {}

TypeOfScaleTypeChoicePair::TypeOfScaleTypeChoicePair(
 whichOne TypeOfScaleTypeTypeIn,
 TypeOfScaleTypeVal TypeOfScaleTypeValueIn)
{
  TypeOfScaleTypeType = TypeOfScaleTypeTypeIn;
  TypeOfScaleTypeValue = TypeOfScaleTypeValueIn;
}

TypeOfScaleTypeChoicePair::~TypeOfScaleTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (TypeOfScaleTypeType == TypeOfScaleEnumE)
    delete TypeOfScaleTypeValue.TypeOfScaleEnum;
  else if (TypeOfScaleTypeType == OtherTypeOfScaleE)
    delete TypeOfScaleTypeValue.OtherTypeOfScale;
  #endif
}

void TypeOfScaleTypeChoicePair::printSelf(FILE * outFile)
{
  if (TypeOfScaleTypeType == TypeOfScaleEnumE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TypeOfScaleEnum");
      TypeOfScaleTypeValue.TypeOfScaleEnum->printSelf(outFile);
      fprintf(outFile, "</TypeOfScaleEnum>\n");
    }
  else if (TypeOfScaleTypeType == OtherTypeOfScaleE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OtherTypeOfScale");
      TypeOfScaleTypeValue.OtherTypeOfScale->printSelf(outFile);
      fprintf(outFile, "</OtherTypeOfScale>\n");
    }
}

/* ***************************************************************** */

/* class UltrasonicSensorType

*/

UltrasonicSensorType::UltrasonicSensorType() :
  SensorType()
{
  MinMeasuringDistance = 0;
  MaxMeasuringDistance = 0;
  SamplingFrequency = 0;
  AppliedFrequency = 0;
  MaxResponseTime = 0;
  ShockTolerance = 0;
  VibrationTolerance = 0;
  MinPowerSupplyVoltage = 0;
  MaxPowerSupplyVoltage = 0;
}

UltrasonicSensorType::UltrasonicSensorType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 XmlString * ProtectionClassIn,
 XmlString * LinearityErrorIn,
 LinearValueType * RepeatabilityIn,
 XmlDecimal * SensitivityIn,
 LinearValueType * ResolutionIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 UserDefinedUnitValueType * SamplingFrequencyIn,
 UserDefinedUnitValueType * AppliedFrequencyIn,
 TimeValueType * MaxResponseTimeIn,
 UserDefinedUnitValueType * ShockToleranceIn,
 UserDefinedUnitValueType * VibrationToleranceIn,
 UserDefinedUnitValueType * MinPowerSupplyVoltageIn,
 UserDefinedUnitValueType * MaxPowerSupplyVoltageIn) :
  SensorType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    ProtectionClassIn,
    LinearityErrorIn,
    RepeatabilityIn,
    SensitivityIn,
    ResolutionIn,
    EnvironmentalRangeIn)
{
  MinMeasuringDistance = MinMeasuringDistanceIn;
  MaxMeasuringDistance = MaxMeasuringDistanceIn;
  SamplingFrequency = SamplingFrequencyIn;
  AppliedFrequency = AppliedFrequencyIn;
  MaxResponseTime = MaxResponseTimeIn;
  ShockTolerance = ShockToleranceIn;
  VibrationTolerance = VibrationToleranceIn;
  MinPowerSupplyVoltage = MinPowerSupplyVoltageIn;
  MaxPowerSupplyVoltage = MaxPowerSupplyVoltageIn;
}

UltrasonicSensorType::UltrasonicSensorType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 XmlString * ProtectionClassIn,
 XmlString * LinearityErrorIn,
 LinearValueType * RepeatabilityIn,
 XmlDecimal * SensitivityIn,
 LinearValueType * ResolutionIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 UserDefinedUnitValueType * SamplingFrequencyIn,
 UserDefinedUnitValueType * AppliedFrequencyIn,
 TimeValueType * MaxResponseTimeIn,
 UserDefinedUnitValueType * ShockToleranceIn,
 UserDefinedUnitValueType * VibrationToleranceIn,
 UserDefinedUnitValueType * MinPowerSupplyVoltageIn,
 UserDefinedUnitValueType * MaxPowerSupplyVoltageIn) :
  SensorType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    ProtectionClassIn,
    LinearityErrorIn,
    RepeatabilityIn,
    SensitivityIn,
    ResolutionIn,
    EnvironmentalRangeIn)
{
  MinMeasuringDistance = MinMeasuringDistanceIn;
  MaxMeasuringDistance = MaxMeasuringDistanceIn;
  SamplingFrequency = SamplingFrequencyIn;
  AppliedFrequency = AppliedFrequencyIn;
  MaxResponseTime = MaxResponseTimeIn;
  ShockTolerance = ShockToleranceIn;
  VibrationTolerance = VibrationToleranceIn;
  MinPowerSupplyVoltage = MinPowerSupplyVoltageIn;
  MaxPowerSupplyVoltage = MaxPowerSupplyVoltageIn;
}

UltrasonicSensorType::~UltrasonicSensorType()
{
  #ifndef NODESTRUCT
  delete MinMeasuringDistance;
  delete MaxMeasuringDistance;
  delete SamplingFrequency;
  delete AppliedFrequency;
  delete MaxResponseTime;
  delete ShockTolerance;
  delete VibrationTolerance;
  delete MinPowerSupplyVoltage;
  delete MaxPowerSupplyVoltage;
  #endif
}

void UltrasonicSensorType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (ProtectionClass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ProtectionClass");
      ProtectionClass->printSelf(outFile);
      fprintf(outFile, "</ProtectionClass>\n");
    }
  if (LinearityError)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LinearityError");
      LinearityError->printSelf(outFile);
      fprintf(outFile, "</LinearityError>\n");
    }
  if (Repeatability)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Repeatability");
      Repeatability->printSelf(outFile);
      fprintf(outFile, "</Repeatability>\n");
    }
  if (Sensitivity)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Sensitivity");
      Sensitivity->printSelf(outFile);
      fprintf(outFile, "</Sensitivity>\n");
    }
  if (Resolution)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Resolution");
      Resolution->printSelf(outFile);
      fprintf(outFile, "</Resolution>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (MinMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinMeasuringDistance");
      MinMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MinMeasuringDistance>\n");
    }
  if (MaxMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxMeasuringDistance");
      MaxMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MaxMeasuringDistance>\n");
    }
  if (SamplingFrequency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SamplingFrequency");
      SamplingFrequency->printSelf(outFile);
      fprintf(outFile, "</SamplingFrequency>\n");
    }
  if (AppliedFrequency)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AppliedFrequency");
      AppliedFrequency->printSelf(outFile);
      fprintf(outFile, "</AppliedFrequency>\n");
    }
  if (MaxResponseTime)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxResponseTime");
      MaxResponseTime->printSelf(outFile);
      fprintf(outFile, "</MaxResponseTime>\n");
    }
  if (ShockTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ShockTolerance");
      ShockTolerance->printSelf(outFile);
      fprintf(outFile, "</ShockTolerance>\n");
    }
  if (VibrationTolerance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<VibrationTolerance");
      VibrationTolerance->printSelf(outFile);
      fprintf(outFile, "</VibrationTolerance>\n");
    }
  if (MinPowerSupplyVoltage)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinPowerSupplyVoltage");
      MinPowerSupplyVoltage->printSelf(outFile);
      fprintf(outFile, "</MinPowerSupplyVoltage>\n");
    }
  if (MaxPowerSupplyVoltage)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxPowerSupplyVoltage");
      MaxPowerSupplyVoltage->printSelf(outFile);
      fprintf(outFile, "</MaxPowerSupplyVoltage>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool UltrasonicSensorType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UltrasonicSensorType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UltrasonicSensorType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UltrasonicSensorType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UltrasonicSensorType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LinearValueType * UltrasonicSensorType::getMinMeasuringDistance()
{return MinMeasuringDistance;}

void UltrasonicSensorType::setMinMeasuringDistance(LinearValueType * MinMeasuringDistanceIn)
{MinMeasuringDistance = MinMeasuringDistanceIn;}

LinearValueType * UltrasonicSensorType::getMaxMeasuringDistance()
{return MaxMeasuringDistance;}

void UltrasonicSensorType::setMaxMeasuringDistance(LinearValueType * MaxMeasuringDistanceIn)
{MaxMeasuringDistance = MaxMeasuringDistanceIn;}

UserDefinedUnitValueType * UltrasonicSensorType::getSamplingFrequency()
{return SamplingFrequency;}

void UltrasonicSensorType::setSamplingFrequency(UserDefinedUnitValueType * SamplingFrequencyIn)
{SamplingFrequency = SamplingFrequencyIn;}

UserDefinedUnitValueType * UltrasonicSensorType::getAppliedFrequency()
{return AppliedFrequency;}

void UltrasonicSensorType::setAppliedFrequency(UserDefinedUnitValueType * AppliedFrequencyIn)
{AppliedFrequency = AppliedFrequencyIn;}

TimeValueType * UltrasonicSensorType::getMaxResponseTime()
{return MaxResponseTime;}

void UltrasonicSensorType::setMaxResponseTime(TimeValueType * MaxResponseTimeIn)
{MaxResponseTime = MaxResponseTimeIn;}

UserDefinedUnitValueType * UltrasonicSensorType::getShockTolerance()
{return ShockTolerance;}

void UltrasonicSensorType::setShockTolerance(UserDefinedUnitValueType * ShockToleranceIn)
{ShockTolerance = ShockToleranceIn;}

UserDefinedUnitValueType * UltrasonicSensorType::getVibrationTolerance()
{return VibrationTolerance;}

void UltrasonicSensorType::setVibrationTolerance(UserDefinedUnitValueType * VibrationToleranceIn)
{VibrationTolerance = VibrationToleranceIn;}

UserDefinedUnitValueType * UltrasonicSensorType::getMinPowerSupplyVoltage()
{return MinPowerSupplyVoltage;}

void UltrasonicSensorType::setMinPowerSupplyVoltage(UserDefinedUnitValueType * MinPowerSupplyVoltageIn)
{MinPowerSupplyVoltage = MinPowerSupplyVoltageIn;}

UserDefinedUnitValueType * UltrasonicSensorType::getMaxPowerSupplyVoltage()
{return MaxPowerSupplyVoltage;}

void UltrasonicSensorType::setMaxPowerSupplyVoltage(UserDefinedUnitValueType * MaxPowerSupplyVoltageIn)
{MaxPowerSupplyVoltage = MaxPowerSupplyVoltageIn;}

/* ***************************************************************** */

/* class UniversalDeviceType

*/

UniversalDeviceType::UniversalDeviceType() :
  MeasurementDeviceType()
{
  Resolution = 0;
  WorkingVolume = 0;
  EffectiveWorkingVolume = 0;
  TemperatureCompensation = 0;
}

UniversalDeviceType::UniversalDeviceType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 ResolutionBaseType * ResolutionIn,
 WorkingVolumeBaseType * WorkingVolumeIn,
 EffectiveWorkingVolumeBaseType * EffectiveWorkingVolumeIn,
 TemperatureCompensationType * TemperatureCompensationIn) :
  MeasurementDeviceType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn)
{
  Resolution = ResolutionIn;
  WorkingVolume = WorkingVolumeIn;
  EffectiveWorkingVolume = EffectiveWorkingVolumeIn;
  TemperatureCompensation = TemperatureCompensationIn;
}

UniversalDeviceType::UniversalDeviceType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 ResolutionBaseType * ResolutionIn,
 WorkingVolumeBaseType * WorkingVolumeIn,
 EffectiveWorkingVolumeBaseType * EffectiveWorkingVolumeIn,
 TemperatureCompensationType * TemperatureCompensationIn) :
  MeasurementDeviceType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn)
{
  Resolution = ResolutionIn;
  WorkingVolume = WorkingVolumeIn;
  EffectiveWorkingVolume = EffectiveWorkingVolumeIn;
  TemperatureCompensation = TemperatureCompensationIn;
}

UniversalDeviceType::~UniversalDeviceType()
{
  #ifndef NODESTRUCT
  delete Resolution;
  delete WorkingVolume;
  delete EffectiveWorkingVolume;
  delete TemperatureCompensation;
  #endif
}

void UniversalDeviceType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Calibrations)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Calibrations");
      Calibrations->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Calibrations>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (Resolution)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (Resolution->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(Resolution->getprintElement(), "LinearResolution") == 0)
          {
            LinearResolutionType * typ;
            if ((typ = dynamic_cast<LinearResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<LinearResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LinearResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad LinearResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "CartesianResolution") == 0)
          {
            CartesianResolutionType * typ;
            if ((typ = dynamic_cast<CartesianResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<CartesianResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "SphericalResolution") == 0)
          {
            SphericalResolutionType * typ;
            if ((typ = dynamic_cast<SphericalResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<SphericalResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "UserDefinedResolution") == 0)
          {
            UserDefinedResolutionType * typ;
            if ((typ = dynamic_cast<UserDefinedResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<UserDefinedResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedResolution element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad Resolution type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (WorkingVolume)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (WorkingVolume->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(WorkingVolume->getprintElement(), "ClosedShellSetWorkingVolume") == 0)
          {
            ClosedShellSetWorkingVolumeType * typ;
            if ((typ = dynamic_cast<ClosedShellSetWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<ClosedShellSetWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ClosedShellSetWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad ClosedShellSetWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "CartesianWorkingVolume") == 0)
          {
            CartesianWorkingVolumeType * typ;
            if ((typ = dynamic_cast<CartesianWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<CartesianWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "SphericalWorkingVolume") == 0)
          {
            SphericalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<SphericalWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<SphericalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "CylindricalWorkingVolume") == 0)
          {
            CylindricalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<CylindricalWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<CylindricalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CylindricalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad CylindricalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "UserDefinedWorkingVolume") == 0)
          {
            UserDefinedWorkingVolumeType * typ;
            if ((typ = dynamic_cast<UserDefinedWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<UserDefinedWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedWorkingVolume element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad WorkingVolume type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (EffectiveWorkingVolume)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (EffectiveWorkingVolume->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveClosedShellSetWorkingVolume") == 0)
          {
            EffectiveClosedShellSetWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveClosedShellSetWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveClosedShellSetWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveClosedShellSetWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveClosedShellSetWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveCartesianWorkingVolume") == 0)
          {
            EffectiveCartesianWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveCartesianWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveCartesianWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveCartesianWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveCartesianWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveSphericalWorkingVolume") == 0)
          {
            EffectiveSphericalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveSphericalWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveSphericalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveSphericalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveSphericalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveCylindricalWorkingVolume") == 0)
          {
            EffectiveCylindricalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveCylindricalWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveCylindricalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveCylindricalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveCylindricalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveUserDefinedWorkingVolume") == 0)
          {
            EffectiveUserDefinedWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveUserDefinedWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveUserDefinedWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveUserDefinedWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveUserDefinedWorkingVolume element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad EffectiveWorkingVolume type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (TemperatureCompensation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TemperatureCompensation");
      TemperatureCompensation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</TemperatureCompensation>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool UniversalDeviceType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UniversalDeviceType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UniversalDeviceType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UniversalDeviceType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UniversalDeviceType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

ResolutionBaseType * UniversalDeviceType::getResolution()
{return Resolution;}

void UniversalDeviceType::setResolution(ResolutionBaseType * ResolutionIn)
{Resolution = ResolutionIn;}

WorkingVolumeBaseType * UniversalDeviceType::getWorkingVolume()
{return WorkingVolume;}

void UniversalDeviceType::setWorkingVolume(WorkingVolumeBaseType * WorkingVolumeIn)
{WorkingVolume = WorkingVolumeIn;}

EffectiveWorkingVolumeBaseType * UniversalDeviceType::getEffectiveWorkingVolume()
{return EffectiveWorkingVolume;}

void UniversalDeviceType::setEffectiveWorkingVolume(EffectiveWorkingVolumeBaseType * EffectiveWorkingVolumeIn)
{EffectiveWorkingVolume = EffectiveWorkingVolumeIn;}

TemperatureCompensationType * UniversalDeviceType::getTemperatureCompensation()
{return TemperatureCompensation;}

void UniversalDeviceType::setTemperatureCompensation(TemperatureCompensationType * TemperatureCompensationIn)
{TemperatureCompensation = TemperatureCompensationIn;}

/* ***************************************************************** */

/* class UniversalLengthMeasuringType

*/

UniversalLengthMeasuringType::UniversalLengthMeasuringType() :
  UniversalDeviceType()
{
  MinMeasuringDistance = 0;
  MaxMeasuringDistance = 0;
  MeasuringForce = 0;
  Accuracy = 0;
  Repeatability = 0;
  ToolIds = 0;
  MaxWorkpieceWeight = 0;
}

UniversalLengthMeasuringType::UniversalLengthMeasuringType(
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 ResolutionBaseType * ResolutionIn,
 WorkingVolumeBaseType * WorkingVolumeIn,
 EffectiveWorkingVolumeBaseType * EffectiveWorkingVolumeIn,
 TemperatureCompensationType * TemperatureCompensationIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 ForceValueType * MeasuringForceIn,
 LinearErrorType * AccuracyIn,
 LinearValueType * RepeatabilityIn,
 ArrayReferenceType * ToolIdsIn,
 MassValueType * MaxWorkpieceWeightIn) :
  UniversalDeviceType(
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    ResolutionIn,
    WorkingVolumeIn,
    EffectiveWorkingVolumeIn,
    TemperatureCompensationIn)
{
  MinMeasuringDistance = MinMeasuringDistanceIn;
  MaxMeasuringDistance = MaxMeasuringDistanceIn;
  MeasuringForce = MeasuringForceIn;
  Accuracy = AccuracyIn;
  Repeatability = RepeatabilityIn;
  ToolIds = ToolIdsIn;
  MaxWorkpieceWeight = MaxWorkpieceWeightIn;
}

UniversalLengthMeasuringType::UniversalLengthMeasuringType(
 QIFIdType * idIn,
 XmlToken * NameIn,
 XmlString * DescriptionIn,
 XmlString * ManufacturerIn,
 XmlString * ModelNumberIn,
 XmlString * SerialNumberIn,
 MassValueType * MassIn,
 CartesianWorkingVolumeType * SizeIn,
 MeasurementReso_1196_Type * MeasurementReso_1196In,
 AttributesType * AttributesIn,
 CalibrationsType * CalibrationsIn,
 EnvironmentalRangeType * EnvironmentalRangeIn,
 ResolutionBaseType * ResolutionIn,
 WorkingVolumeBaseType * WorkingVolumeIn,
 EffectiveWorkingVolumeBaseType * EffectiveWorkingVolumeIn,
 TemperatureCompensationType * TemperatureCompensationIn,
 LinearValueType * MinMeasuringDistanceIn,
 LinearValueType * MaxMeasuringDistanceIn,
 ForceValueType * MeasuringForceIn,
 LinearErrorType * AccuracyIn,
 LinearValueType * RepeatabilityIn,
 ArrayReferenceType * ToolIdsIn,
 MassValueType * MaxWorkpieceWeightIn) :
  UniversalDeviceType(
    idIn,
    NameIn,
    DescriptionIn,
    ManufacturerIn,
    ModelNumberIn,
    SerialNumberIn,
    MassIn,
    SizeIn,
    MeasurementReso_1196In,
    AttributesIn,
    CalibrationsIn,
    EnvironmentalRangeIn,
    ResolutionIn,
    WorkingVolumeIn,
    EffectiveWorkingVolumeIn,
    TemperatureCompensationIn)
{
  MinMeasuringDistance = MinMeasuringDistanceIn;
  MaxMeasuringDistance = MaxMeasuringDistanceIn;
  MeasuringForce = MeasuringForceIn;
  Accuracy = AccuracyIn;
  Repeatability = RepeatabilityIn;
  ToolIds = ToolIdsIn;
  MaxWorkpieceWeight = MaxWorkpieceWeightIn;
}

UniversalLengthMeasuringType::~UniversalLengthMeasuringType()
{
  #ifndef NODESTRUCT
  delete MinMeasuringDistance;
  delete MaxMeasuringDistance;
  delete MeasuringForce;
  delete Accuracy;
  delete Repeatability;
  delete ToolIds;
  delete MaxWorkpieceWeight;
  #endif
}

void UniversalLengthMeasuringType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Name");
  Name->printSelf(outFile);
  fprintf(outFile, "</Name>\n");
  if (Description)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  if (Manufacturer)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Manufacturer");
      Manufacturer->printSelf(outFile);
      fprintf(outFile, "</Manufacturer>\n");
    }
  if (ModelNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ModelNumber");
      ModelNumber->printSelf(outFile);
      fprintf(outFile, "</ModelNumber>\n");
    }
  if (SerialNumber)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SerialNumber");
      SerialNumber->printSelf(outFile);
      fprintf(outFile, "</SerialNumber>\n");
    }
  if (Mass)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Mass");
      Mass->printSelf(outFile);
      fprintf(outFile, "</Mass>\n");
    }
  if (Size)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Size");
      Size->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Size>\n");
    }
  if (MeasurementReso_1196)
    {
  MeasurementReso_1196->printSelf(outFile);
    }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (Calibrations)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Calibrations");
      Calibrations->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Calibrations>\n");
    }
  if (EnvironmentalRange)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<EnvironmentalRange");
      EnvironmentalRange->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</EnvironmentalRange>\n");
    }
  if (Resolution)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (Resolution->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(Resolution->getprintElement(), "LinearResolution") == 0)
          {
            LinearResolutionType * typ;
            if ((typ = dynamic_cast<LinearResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<LinearResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LinearResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad LinearResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "CartesianResolution") == 0)
          {
            CartesianResolutionType * typ;
            if ((typ = dynamic_cast<CartesianResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<CartesianResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "SphericalResolution") == 0)
          {
            SphericalResolutionType * typ;
            if ((typ = dynamic_cast<SphericalResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<SphericalResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalResolution element\n");
                exit(1);
              }
          }
        else if (strcmp(Resolution->getprintElement(), "UserDefinedResolution") == 0)
          {
            UserDefinedResolutionType * typ;
            if ((typ = dynamic_cast<UserDefinedResolutionType *>(Resolution)))
              {
                fprintf(outFile, "<UserDefinedResolution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedResolution>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedResolution element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad Resolution type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (WorkingVolume)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (WorkingVolume->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(WorkingVolume->getprintElement(), "ClosedShellSetWorkingVolume") == 0)
          {
            ClosedShellSetWorkingVolumeType * typ;
            if ((typ = dynamic_cast<ClosedShellSetWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<ClosedShellSetWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ClosedShellSetWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad ClosedShellSetWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "CartesianWorkingVolume") == 0)
          {
            CartesianWorkingVolumeType * typ;
            if ((typ = dynamic_cast<CartesianWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<CartesianWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CartesianWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad CartesianWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "SphericalWorkingVolume") == 0)
          {
            SphericalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<SphericalWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<SphericalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "CylindricalWorkingVolume") == 0)
          {
            CylindricalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<CylindricalWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<CylindricalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CylindricalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad CylindricalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(WorkingVolume->getprintElement(), "UserDefinedWorkingVolume") == 0)
          {
            UserDefinedWorkingVolumeType * typ;
            if ((typ = dynamic_cast<UserDefinedWorkingVolumeType *>(WorkingVolume)))
              {
                fprintf(outFile, "<UserDefinedWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedWorkingVolume element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad WorkingVolume type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (EffectiveWorkingVolume)
    {
      {// list may be empty
        doSpaces(0, outFile);
        if (EffectiveWorkingVolume->getprintElement() == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveClosedShellSetWorkingVolume") == 0)
          {
            EffectiveClosedShellSetWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveClosedShellSetWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveClosedShellSetWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveClosedShellSetWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveClosedShellSetWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveCartesianWorkingVolume") == 0)
          {
            EffectiveCartesianWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveCartesianWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveCartesianWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveCartesianWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveCartesianWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveSphericalWorkingVolume") == 0)
          {
            EffectiveSphericalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveSphericalWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveSphericalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveSphericalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveSphericalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveCylindricalWorkingVolume") == 0)
          {
            EffectiveCylindricalWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveCylindricalWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveCylindricalWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveCylindricalWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveCylindricalWorkingVolume element\n");
                exit(1);
              }
          }
        else if (strcmp(EffectiveWorkingVolume->getprintElement(), "EffectiveUserDefinedWorkingVolume") == 0)
          {
            EffectiveUserDefinedWorkingVolumeType * typ;
            if ((typ = dynamic_cast<EffectiveUserDefinedWorkingVolumeType *>(EffectiveWorkingVolume)))
              {
                fprintf(outFile, "<EffectiveUserDefinedWorkingVolume");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveUserDefinedWorkingVolume>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveUserDefinedWorkingVolume element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad EffectiveWorkingVolume type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
    }
  if (TemperatureCompensation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<TemperatureCompensation");
      TemperatureCompensation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</TemperatureCompensation>\n");
    }
  if (MinMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinMeasuringDistance");
      MinMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MinMeasuringDistance>\n");
    }
  if (MaxMeasuringDistance)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxMeasuringDistance");
      MaxMeasuringDistance->printSelf(outFile);
      fprintf(outFile, "</MaxMeasuringDistance>\n");
    }
  if (MeasuringForce)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasuringForce");
      MeasuringForce->printSelf(outFile);
      fprintf(outFile, "</MeasuringForce>\n");
    }
  if (Accuracy)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Accuracy");
      Accuracy->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Accuracy>\n");
    }
  if (Repeatability)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Repeatability");
      Repeatability->printSelf(outFile);
      fprintf(outFile, "</Repeatability>\n");
    }
  if (ToolIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ToolIds");
      ToolIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ToolIds>\n");
    }
  if (MaxWorkpieceWeight)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxWorkpieceWeight");
      MaxWorkpieceWeight->printSelf(outFile);
      fprintf(outFile, "</MaxWorkpieceWeight>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool UniversalLengthMeasuringType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->getname() == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in UniversalLengthMeasuringType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->getval().c_str());
          if (idVal->getbad())
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in UniversalLengthMeasuringType\n",
                      decl->getval().c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in UniversalLengthMeasuringType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id)
    {
      idMap[this->id->getval()] = this;
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing in UniversalLengthMeasuringType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

LinearValueType * UniversalLengthMeasuringType::getMinMeasuringDistance()
{return MinMeasuringDistance;}

void UniversalLengthMeasuringType::setMinMeasuringDistance(LinearValueType * MinMeasuringDistanceIn)
{MinMeasuringDistance = MinMeasuringDistanceIn;}

LinearValueType * UniversalLengthMeasuringType::getMaxMeasuringDistance()
{return MaxMeasuringDistance;}

void UniversalLengthMeasuringType::setMaxMeasuringDistance(LinearValueType * MaxMeasuringDistanceIn)
{MaxMeasuringDistance = MaxMeasuringDistanceIn;}

ForceValueType * UniversalLengthMeasuringType::getMeasuringForce()
{return MeasuringForce;}

void UniversalLengthMeasuringType::setMeasuringForce(ForceValueType * MeasuringForceIn)
{MeasuringForce = MeasuringForceIn;}

LinearErrorType * UniversalLengthMeasuringType::getAccuracy()
{return Accuracy;}

void UniversalLengthMeasuringType::setAccuracy(LinearErrorType * AccuracyIn)
{Accuracy = AccuracyIn;}

LinearValueType * UniversalLengthMeasuringType::getRepeatability()
{return Repeatability;}

void UniversalLengthMeasuringType::setRepeatability(LinearValueType * RepeatabilityIn)
{Repeatability = RepeatabilityIn;}

ArrayReferenceType * UniversalLengthMeasuringType::getToolIds()
{return ToolIds;}

void UniversalLengthMeasuringType::setToolIds(ArrayReferenceType * ToolIdsIn)
{ToolIds = ToolIdsIn;}

MassValueType * UniversalLengthMeasuringType::getMaxWorkpieceWeight()
{return MaxWorkpieceWeight;}

void UniversalLengthMeasuringType::setMaxWorkpieceWeight(MassValueType * MaxWorkpieceWeightIn)
{MaxWorkpieceWeight = MaxWorkpieceWeightIn;}

/* ***************************************************************** */

/* class UserAxisBaseType

*/

UserAxisBaseType::UserAxisBaseType()
{}

UserAxisBaseType::~UserAxisBaseType() {}

void UserAxisBaseType::printSelf(FILE * outFile)
{
  fprintf(outFile, "/>\n");
}

/* ***************************************************************** */

/* class UserDefinedAxisType

*/

UserDefinedAxisType::UserDefinedAxisType() :
  LinearOrRotaryAxisType()
{
  Attributes = 0;
  AxisName = 0;
}

UserDefinedAxisType::UserDefinedAxisType(
 UserAxisBaseType * AxisIn,
 AttributesType * AttributesIn,
 XmlToken * AxisNameIn) :
  LinearOrRotaryAxisType(
    AxisIn)
{
  Attributes = AttributesIn;
  AxisName = AxisNameIn;
}

UserDefinedAxisType::~UserDefinedAxisType()
{
  #ifndef NODESTRUCT
  delete Attributes;
  delete AxisName;
  #endif
}

void UserDefinedAxisType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    doSpaces(0, outFile);
    if (Axis->getprintElement() == 0)
      {
        fprintf(stderr, "element name missing\n");
        exit(1);
      }
    else if (strcmp(Axis->getprintElement(), "RotaryAxis") == 0)
      {
        RotaryAxisType * typ;
        if ((typ = dynamic_cast<RotaryAxisType *>(Axis)))
          {
            fprintf(outFile, "<RotaryAxis");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</RotaryAxis>\n");
          }
        else
          {
            fprintf(stderr, "bad RotaryAxis element\n");
            exit(1);
          }
      }
    else if (strcmp(Axis->getprintElement(), "LinearAxis") == 0)
      {
        LinearAxisType * typ;
        if ((typ = dynamic_cast<LinearAxisType *>(Axis)))
          {
            fprintf(outFile, "<LinearAxis");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</LinearAxis>\n");
          }
        else
          {
            fprintf(stderr, "bad LinearAxis element\n");
            exit(1);
          }
      }
    else
      {
        fprintf(stderr, "bad Axis type\n");
        fprintf(stderr, " exiting\n");
        exit(1);
      }
  }
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<AxisName");
  AxisName->printSelf(outFile);
  fprintf(outFile, "</AxisName>\n");
  doSpaces(-INDENT, outFile);
}

AttributesType * UserDefinedAxisType::getAttributes()
{return Attributes;}

void UserDefinedAxisType::setAttributes(AttributesType * AttributesIn)
{Attributes = AttributesIn;}

XmlToken * UserDefinedAxisType::getAxisName()
{return AxisName;}

void UserDefinedAxisType::setAxisName(XmlToken * AxisNameIn)
{AxisName = AxisNameIn;}

/* ***************************************************************** */

/* class UserDefinedResolutionType

*/

UserDefinedResolutionType::UserDefinedResolutionType() :
  ResolutionBaseType()
{
  UserDefinedResolutionTypePair = 0;
}

UserDefinedResolutionType::UserDefinedResolutionType(
 UserDefinedResolutionTypeChoicePair * UserDefinedResolutionTypePairIn) :
  ResolutionBaseType()
{
  UserDefinedResolutionTypePair = UserDefinedResolutionTypePairIn;
}

UserDefinedResolutionType::~UserDefinedResolutionType()
{
  #ifndef NODESTRUCT
  delete UserDefinedResolutionTypePair;
  #endif
}

void UserDefinedResolutionType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  UserDefinedResolutionTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}
UserDefinedResolutionTypeChoicePair * UserDefinedResolutionType::getUserDefinedResolutionTypeChoicePair()
{return UserDefinedResolutionTypePair;}

void UserDefinedResolutionType::setUserDefinedResolutionTypeChoicePair(UserDefinedResolutionTypeChoicePair * UserDefinedResolutionTypePairIn)
{UserDefinedResolutionTypePair = UserDefinedResolutionTypePairIn;}

/* ***************************************************************** */

UserDefinedResolutionTypeChoicePair::UserDefinedResolutionTypeChoicePair() {}

UserDefinedResolutionTypeChoicePair::UserDefinedResolutionTypeChoicePair(
 whichOne UserDefinedResolutionTypeTypeIn,
 UserDefinedResolutionTypeVal UserDefinedResolutionTypeValueIn)
{
  UserDefinedResolutionTypeType = UserDefinedResolutionTypeTypeIn;
  UserDefinedResolutionTypeValue = UserDefinedResolutionTypeValueIn;
}

UserDefinedResolutionTypeChoicePair::~UserDefinedResolutionTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (UserDefinedResolutionTypeType == UserDefinedReso_1198E)
    delete UserDefinedResolutionTypeValue.UserDefinedReso_1198;
  else if (UserDefinedResolutionTypeType == ABCResolutionE)
    delete UserDefinedResolutionTypeValue.ABCResolution;
  #endif
}

void UserDefinedResolutionTypeChoicePair::printSelf(FILE * outFile)
{
  if (UserDefinedResolutionTypeType == UserDefinedReso_1198E)
    {
      UserDefinedResolutionTypeValue.UserDefinedReso_1198->printSelf(outFile);
    }
  else if (UserDefinedResolutionTypeType == ABCResolutionE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ABCResolution");
      UserDefinedResolutionTypeValue.ABCResolution->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ABCResolution>\n");
    }
}

/* ***************************************************************** */

/* class UserDefinedWorkingVolumeType

*/

UserDefinedWorkingVolumeType::UserDefinedWorkingVolumeType() :
  WorkingVolumeBaseType()
{
  FirstAxis = 0;
  SecondAxis = 0;
  ThirdAxis = 0;
}

UserDefinedWorkingVolumeType::UserDefinedWorkingVolumeType(
 UserDefinedAxisType * FirstAxisIn,
 UserDefinedAxisType * SecondAxisIn,
 UserDefinedAxisType * ThirdAxisIn) :
  WorkingVolumeBaseType()
{
  FirstAxis = FirstAxisIn;
  SecondAxis = SecondAxisIn;
  ThirdAxis = ThirdAxisIn;
}

UserDefinedWorkingVolumeType::~UserDefinedWorkingVolumeType()
{
  #ifndef NODESTRUCT
  delete FirstAxis;
  delete SecondAxis;
  delete ThirdAxis;
  #endif
}

void UserDefinedWorkingVolumeType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<FirstAxis");
  FirstAxis->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</FirstAxis>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<SecondAxis");
  SecondAxis->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</SecondAxis>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<ThirdAxis");
  ThirdAxis->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ThirdAxis>\n");
  doSpaces(-INDENT, outFile);
}

UserDefinedAxisType * UserDefinedWorkingVolumeType::getFirstAxis()
{return FirstAxis;}

void UserDefinedWorkingVolumeType::setFirstAxis(UserDefinedAxisType * FirstAxisIn)
{FirstAxis = FirstAxisIn;}

UserDefinedAxisType * UserDefinedWorkingVolumeType::getSecondAxis()
{return SecondAxis;}

void UserDefinedWorkingVolumeType::setSecondAxis(UserDefinedAxisType * SecondAxisIn)
{SecondAxis = SecondAxisIn;}

UserDefinedAxisType * UserDefinedWorkingVolumeType::getThirdAxis()
{return ThirdAxis;}

void UserDefinedWorkingVolumeType::setThirdAxis(UserDefinedAxisType * ThirdAxisIn)
{ThirdAxis = ThirdAxisIn;}

/* ***************************************************************** */

/* class VolumetricPerformanceTestType

*/

VolumetricPerformanceTestType::VolumetricPerformanceTestType()
{
  DeviationsFromCalibration = 0;
  TwiceStandardDeviation = 0;
}

VolumetricPerformanceTestType::VolumetricPerformanceTestType(
 TwentyLinearValuesType * DeviationsFromCalibrationIn,
 LinearValueType * TwiceStandardDeviationIn)
{
  DeviationsFromCalibration = DeviationsFromCalibrationIn;
  TwiceStandardDeviation = TwiceStandardDeviationIn;
}

VolumetricPerformanceTestType::~VolumetricPerformanceTestType()
{
  #ifndef NODESTRUCT
  delete DeviationsFromCalibration;
  delete TwiceStandardDeviation;
  #endif
}

void VolumetricPerformanceTestType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<DeviationsFromCalibration");
  DeviationsFromCalibration->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeviationsFromCalibration>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<TwiceStandardDeviation");
  TwiceStandardDeviation->printSelf(outFile);
  fprintf(outFile, "</TwiceStandardDeviation>\n");
  doSpaces(-INDENT, outFile);
}

TwentyLinearValuesType * VolumetricPerformanceTestType::getDeviationsFromCalibration()
{return DeviationsFromCalibration;}

void VolumetricPerformanceTestType::setDeviationsFromCalibration(TwentyLinearValuesType * DeviationsFromCalibrationIn)
{DeviationsFromCalibration = DeviationsFromCalibrationIn;}

LinearValueType * VolumetricPerformanceTestType::getTwiceStandardDeviation()
{return TwiceStandardDeviation;}

void VolumetricPerformanceTestType::setTwiceStandardDeviation(LinearValueType * TwiceStandardDeviationIn)
{TwiceStandardDeviation = TwiceStandardDeviationIn;}

/* ***************************************************************** */

/* class WorkingVolumeBaseType

*/

WorkingVolumeBaseType::WorkingVolumeBaseType()
{}

WorkingVolumeBaseType::~WorkingVolumeBaseType() {}

void WorkingVolumeBaseType::printSelf(FILE * outFile)
{
  fprintf(outFile, "/>\n");
}

/* ***************************************************************** */

/* class XYZLinearSpecificationType

*/

XYZLinearSpecificationType::XYZLinearSpecificationType()
{
  X = 0;
  Y = 0;
  Z = 0;
}

XYZLinearSpecificationType::XYZLinearSpecificationType(
 LinearValueType * XIn,
 LinearValueType * YIn,
 LinearValueType * ZIn)
{
  X = XIn;
  Y = YIn;
  Z = ZIn;
}

XYZLinearSpecificationType::~XYZLinearSpecificationType()
{
  #ifndef NODESTRUCT
  delete X;
  delete Y;
  delete Z;
  #endif
}

void XYZLinearSpecificationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (X)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<X");
      X->printSelf(outFile);
      fprintf(outFile, "</X>\n");
    }
  if (Y)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Y");
      Y->printSelf(outFile);
      fprintf(outFile, "</Y>\n");
    }
  if (Z)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Z");
      Z->printSelf(outFile);
      fprintf(outFile, "</Z>\n");
    }
  doSpaces(-INDENT, outFile);
}

LinearValueType * XYZLinearSpecificationType::getX()
{return X;}

void XYZLinearSpecificationType::setX(LinearValueType * XIn)
{X = XIn;}

LinearValueType * XYZLinearSpecificationType::getY()
{return Y;}

void XYZLinearSpecificationType::setY(LinearValueType * YIn)
{Y = YIn;}

LinearValueType * XYZLinearSpecificationType::getZ()
{return Z;}

void XYZLinearSpecificationType::setZ(LinearValueType * ZIn)
{Z = ZIn;}

/* ***************************************************************** */

/* class XYZResolutionType

*/

XYZResolutionType::XYZResolutionType()
{
  XResolution = 0;
  YResolution = 0;
  ZResolution = 0;
}

XYZResolutionType::XYZResolutionType(
 LinearValueType * XResolutionIn,
 LinearValueType * YResolutionIn,
 LinearValueType * ZResolutionIn)
{
  XResolution = XResolutionIn;
  YResolution = YResolutionIn;
  ZResolution = ZResolutionIn;
}

XYZResolutionType::~XYZResolutionType()
{
  #ifndef NODESTRUCT
  delete XResolution;
  delete YResolution;
  delete ZResolution;
  #endif
}

void XYZResolutionType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<XResolution");
  XResolution->printSelf(outFile);
  fprintf(outFile, "</XResolution>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<YResolution");
  YResolution->printSelf(outFile);
  fprintf(outFile, "</YResolution>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<ZResolution");
  ZResolution->printSelf(outFile);
  fprintf(outFile, "</ZResolution>\n");
  doSpaces(-INDENT, outFile);
}

LinearValueType * XYZResolutionType::getXResolution()
{return XResolution;}

void XYZResolutionType::setXResolution(LinearValueType * XResolutionIn)
{XResolution = XResolutionIn;}

LinearValueType * XYZResolutionType::getYResolution()
{return YResolution;}

void XYZResolutionType::setYResolution(LinearValueType * YResolutionIn)
{YResolution = YResolutionIn;}

LinearValueType * XYZResolutionType::getZResolution()
{return ZResolution;}

void XYZResolutionType::setZResolution(LinearValueType * ZResolutionIn)
{ZResolution = ZResolutionIn;}

/* ***************************************************************** */

/* class CartesianResolu_1195_Type

*/

CartesianResolu_1195_Type::CartesianResolu_1195_Type()
{
  CombinedCartesianResolution = 0;
  XYZResolution = 0;
}

CartesianResolu_1195_Type::CartesianResolu_1195_Type(
 LinearValueType * CombinedCartesianResolutionIn,
 XYZResolutionType * XYZResolutionIn)
{
  CombinedCartesianResolution = CombinedCartesianResolutionIn;
  XYZResolution = XYZResolutionIn;
}

CartesianResolu_1195_Type::~CartesianResolu_1195_Type()
{
  #ifndef NODESTRUCT
  delete CombinedCartesianResolution;
  delete XYZResolution;
  #endif
}

void CartesianResolu_1195_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<CombinedCartesianResolution");
  CombinedCartesianResolution->printSelf(outFile);
  fprintf(outFile, "</CombinedCartesianResolution>\n");
  if (XYZResolution)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<XYZResolution");
      XYZResolution->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</XYZResolution>\n");
    }
}

LinearValueType * CartesianResolu_1195_Type::getCombinedCartesianResolution()
{return CombinedCartesianResolution;}

void CartesianResolu_1195_Type::setCombinedCartesianResolution(LinearValueType * CombinedCartesianResolutionIn)
{CombinedCartesianResolution = CombinedCartesianResolutionIn;}

XYZResolutionType * CartesianResolu_1195_Type::getXYZResolution()
{return XYZResolution;}

void CartesianResolu_1195_Type::setXYZResolution(XYZResolutionType * XYZResolutionIn)
{XYZResolution = XYZResolutionIn;}

/* ***************************************************************** */

/* class MeasurementReso_1196_Type

*/

MeasurementReso_1196_Type::MeasurementReso_1196_Type()
{
  MeasurementReso_1196_TypePair = 0;
}

MeasurementReso_1196_Type::MeasurementReso_1196_Type(
 MeasurementReso_1196_TypeChoicePair * MeasurementReso_1196_TypePairIn)
{
  MeasurementReso_1196_TypePair = MeasurementReso_1196_TypePairIn;
}

MeasurementReso_1196_Type::~MeasurementReso_1196_Type()
{
  #ifndef NODESTRUCT
  delete MeasurementReso_1196_TypePair;
  #endif
}

void MeasurementReso_1196_Type::printSelf(FILE * outFile)
{
  if (MeasurementReso_1196_TypePair)
    {
      MeasurementReso_1196_TypePair->printSelf(outFile);
    }
}

MeasurementReso_1196_TypeChoicePair * MeasurementReso_1196_Type::getMeasurementReso_1196_TypePair()
{return MeasurementReso_1196_TypePair;}

void MeasurementReso_1196_Type::setMeasurementReso_1196_TypePair(MeasurementReso_1196_TypeChoicePair * MeasurementReso_1196_TypePairIn)
{MeasurementReso_1196_TypePair = MeasurementReso_1196_TypePairIn;}
MeasurementReso_1196_TypeChoicePair::MeasurementReso_1196_TypeChoicePair() {}

MeasurementReso_1196_TypeChoicePair::MeasurementReso_1196_TypeChoicePair(
 whichOne MeasurementReso_1196_TypeTypeIn,
 MeasurementReso_1196_TypeVal MeasurementReso_1196_TypeValueIn)
{
  MeasurementReso_1196_TypeType = MeasurementReso_1196_TypeTypeIn;
  MeasurementReso_1196_TypeValue = MeasurementReso_1196_TypeValueIn;
}

MeasurementReso_1196_TypeChoicePair::~MeasurementReso_1196_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (MeasurementReso_1196_TypeType == LocationIdE)
    delete MeasurementReso_1196_TypeValue.LocationId;
  else if (MeasurementReso_1196_TypeType == LocationE)
    delete MeasurementReso_1196_TypeValue.Location;
  #endif
}

void MeasurementReso_1196_TypeChoicePair::printSelf(FILE * outFile)
{
  if (MeasurementReso_1196_TypeType == LocationIdE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<LocationId");
      MeasurementReso_1196_TypeValue.LocationId->printSelf(outFile);
      fprintf(outFile, "</LocationId>\n");
    }
  else if (MeasurementReso_1196_TypeType == LocationE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Location");
      MeasurementReso_1196_TypeValue.Location->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Location>\n");
    }
}

/* ***************************************************************** */

/* class SphericalResolu_1197_Type

*/

SphericalResolu_1197_Type::SphericalResolu_1197_Type()
{
  CombinedSphericalResolution = 0;
  RAPZResolution = 0;
}

SphericalResolu_1197_Type::SphericalResolu_1197_Type(
 CombinedSphericalResolutionType * CombinedSphericalResolutionIn,
 RAPZResolutionType * RAPZResolutionIn)
{
  CombinedSphericalResolution = CombinedSphericalResolutionIn;
  RAPZResolution = RAPZResolutionIn;
}

SphericalResolu_1197_Type::~SphericalResolu_1197_Type()
{
  #ifndef NODESTRUCT
  delete CombinedSphericalResolution;
  delete RAPZResolution;
  #endif
}

void SphericalResolu_1197_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<CombinedSphericalResolution");
  CombinedSphericalResolution->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</CombinedSphericalResolution>\n");
  if (RAPZResolution)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<RAPZResolution");
      RAPZResolution->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</RAPZResolution>\n");
    }
}

CombinedSphericalResolutionType * SphericalResolu_1197_Type::getCombinedSphericalResolution()
{return CombinedSphericalResolution;}

void SphericalResolu_1197_Type::setCombinedSphericalResolution(CombinedSphericalResolutionType * CombinedSphericalResolutionIn)
{CombinedSphericalResolution = CombinedSphericalResolutionIn;}

RAPZResolutionType * SphericalResolu_1197_Type::getRAPZResolution()
{return RAPZResolution;}

void SphericalResolu_1197_Type::setRAPZResolution(RAPZResolutionType * RAPZResolutionIn)
{RAPZResolution = RAPZResolutionIn;}

/* ***************************************************************** */

/* class UserDefinedReso_1198_Type

*/

UserDefinedReso_1198_Type::UserDefinedReso_1198_Type()
{
  CombinedUserDefinedResolution = 0;
  ABCResolution = 0;
}

UserDefinedReso_1198_Type::UserDefinedReso_1198_Type(
 CombinedUserDefinedResolutionType * CombinedUserDefinedResolutionIn,
 ABCResolutionType * ABCResolutionIn)
{
  CombinedUserDefinedResolution = CombinedUserDefinedResolutionIn;
  ABCResolution = ABCResolutionIn;
}

UserDefinedReso_1198_Type::~UserDefinedReso_1198_Type()
{
  #ifndef NODESTRUCT
  delete CombinedUserDefinedResolution;
  delete ABCResolution;
  #endif
}

void UserDefinedReso_1198_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<CombinedUserDefinedResolution");
  CombinedUserDefinedResolution->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</CombinedUserDefinedResolution>\n");
  if (ABCResolution)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ABCResolution");
      ABCResolution->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ABCResolution>\n");
    }
}

CombinedUserDefinedResolutionType * UserDefinedReso_1198_Type::getCombinedUserDefinedResolution()
{return CombinedUserDefinedResolution;}

void UserDefinedReso_1198_Type::setCombinedUserDefinedResolution(CombinedUserDefinedResolutionType * CombinedUserDefinedResolutionIn)
{CombinedUserDefinedResolution = CombinedUserDefinedResolutionIn;}

ABCResolutionType * UserDefinedReso_1198_Type::getABCResolution()
{return ABCResolution;}

void UserDefinedReso_1198_Type::setABCResolution(ABCResolutionType * ABCResolutionIn)
{ABCResolution = ABCResolutionIn;}

/* ***************************************************************** */

