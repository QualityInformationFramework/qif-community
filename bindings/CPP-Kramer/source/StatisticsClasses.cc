/* ***************************************************************** */

#include <stdio.h>             // for printf, etc.
#include <string.h>            // for strdup
#include <stdlib.h>            // for exit
#include <list>
#include <xmlSchemaInstance.hh>
#include "StatisticsClasses.hh"

#define INDENT 2

/* ***************************************************************** */
/* ***************************************************************** */

/* class ActionToTakeEnumType

*/

ActionToTakeEnumType::ActionToTakeEnumType() :
  XmlNMTOKEN()
{
}

ActionToTakeEnumType::ActionToTakeEnumType(
 const char * valIn) :
  XmlNMTOKEN(
    valIn)
{
  if (!bad)
    bad = (strcmp(val.c_str(), "HALT_PRODUCTION") &&
           strcmp(val.c_str(), "CONTAINMENT") &&
           strcmp(val.c_str(), "NEW_MATERIAL_BATCH") &&
           strcmp(val.c_str(), "NEW_TOOLING") &&
           strcmp(val.c_str(), "INSPECT_100PC") &&
           strcmp(val.c_str(), "REBOOT") &&
           strcmp(val.c_str(), "RECALIBRATE") &&
           strcmp(val.c_str(), "OTHER"));
}

ActionToTakeEnumType::~ActionToTakeEnumType() {}

bool ActionToTakeEnumType::ActionToTakeEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "HALT_PRODUCTION") &&
          strcmp(val.c_str(), "CONTAINMENT") &&
          strcmp(val.c_str(), "NEW_MATERIAL_BATCH") &&
          strcmp(val.c_str(), "NEW_TOOLING") &&
          strcmp(val.c_str(), "INSPECT_100PC") &&
          strcmp(val.c_str(), "REBOOT") &&
          strcmp(val.c_str(), "RECALIBRATE") &&
          strcmp(val.c_str(), "OTHER"));
}

void ActionToTakeEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "ActionToTakeEnumType");
}

void ActionToTakeEnumType::printSelf(FILE * outFile)
{
  if (ActionToTakeEnumTypeIsBad())
    {
      fprintf(stderr, "bad ActionToTakeEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::printSelf(outFile);
}

void ActionToTakeEnumType::oPrintSelf(FILE * outFile)
{
  if (ActionToTakeEnumTypeIsBad())
    {
      fprintf(stderr, "bad ActionToTakeEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class AngleBetweenCharacteristicStatsEvalType

*/

AngleBetweenCharacteristicStatsEvalType::AngleBetweenCharacteristicStatsEvalType() :
  AngularCharacteristicStatsEvalType() {}

AngleBetweenCharacteristicStatsEvalType::AngleBetweenCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 AngularCharacteristicStatsEvalTypeChoicePair * AngularCharacteristicStatsEvalTypePairIn) :
  AngularCharacteristicStatsEvalType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    AngularCharacteristicStatsEvalTypePairIn)
{}

AngleBetweenCharacteristicStatsEvalType::~AngleBetweenCharacteristicStatsEvalType() {}

void AngleBetweenCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  AngularCharacteristicStatsEvalTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class AngleCharacteristicStatsEvalType

*/

AngleCharacteristicStatsEvalType::AngleCharacteristicStatsEvalType() :
  AngularCharacteristicStatsEvalType() {}

AngleCharacteristicStatsEvalType::AngleCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 AngularCharacteristicStatsEvalTypeChoicePair * AngularCharacteristicStatsEvalTypePairIn) :
  AngularCharacteristicStatsEvalType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    AngularCharacteristicStatsEvalTypePairIn)
{}

AngleCharacteristicStatsEvalType::~AngleCharacteristicStatsEvalType() {}

void AngleCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  AngularCharacteristicStatsEvalTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class AngleFromCharacteristicStatsEvalType

*/

AngleFromCharacteristicStatsEvalType::AngleFromCharacteristicStatsEvalType() :
  AngularCharacteristicStatsEvalType() {}

AngleFromCharacteristicStatsEvalType::AngleFromCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 AngularCharacteristicStatsEvalTypeChoicePair * AngularCharacteristicStatsEvalTypePairIn) :
  AngularCharacteristicStatsEvalType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    AngularCharacteristicStatsEvalTypePairIn)
{}

AngleFromCharacteristicStatsEvalType::~AngleFromCharacteristicStatsEvalType() {}

void AngleFromCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  AngularCharacteristicStatsEvalTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class AngularCharacteristicStatsEvalType

*/

AngularCharacteristicStatsEvalType::AngularCharacteristicStatsEvalType() :
  CharacteristicStatsEvalBaseType()
{
  AngularCharacteristicStatsEvalTypePair = 0;
}

AngularCharacteristicStatsEvalType::AngularCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 AngularCharacteristicStatsEvalTypeChoicePair * AngularCharacteristicStatsEvalTypePairIn) :
  CharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn)
{
  AngularCharacteristicStatsEvalTypePair = AngularCharacteristicStatsEvalTypePairIn;
}

AngularCharacteristicStatsEvalType::~AngularCharacteristicStatsEvalType()
{
  #ifndef NODESTRUCT
  delete AngularCharacteristicStatsEvalTypePair;
  #endif
}

void AngularCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  AngularCharacteristicStatsEvalTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}
AngularCharacteristicStatsEvalTypeChoicePair * AngularCharacteristicStatsEvalType::getAngularCharacteristicStatsEvalTypeChoicePair()
{return AngularCharacteristicStatsEvalTypePair;}

void AngularCharacteristicStatsEvalType::setAngularCharacteristicStatsEvalTypeChoicePair(AngularCharacteristicStatsEvalTypeChoicePair * AngularCharacteristicStatsEvalTypePairIn)
{AngularCharacteristicStatsEvalTypePair = AngularCharacteristicStatsEvalTypePairIn;}

/* ***************************************************************** */

AngularCharacteristicStatsEvalTypeChoicePair::AngularCharacteristicStatsEvalTypeChoicePair() {}

AngularCharacteristicStatsEvalTypeChoicePair::AngularCharacteristicStatsEvalTypeChoicePair(
 whichOne AngularCharacteristicStatsEvalTypeTypeIn,
 AngularCharacteristicStatsEvalTypeVal AngularCharacteristicStatsEvalTypeValueIn)
{
  AngularCharacteristicStatsEvalTypeType = AngularCharacteristicStatsEvalTypeTypeIn;
  AngularCharacteristicStatsEvalTypeValue = AngularCharacteristicStatsEvalTypeValueIn;
}

AngularCharacteristicStatsEvalTypeChoicePair::~AngularCharacteristicStatsEvalTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (AngularCharacteristicStatsEvalTypeType == AngularCharacte_1100E)
    delete AngularCharacteristicStatsEvalTypeValue.AngularCharacte_1100;
  else if (AngularCharacteristicStatsEvalTypeType == AngularCharacte_1101E)
    delete AngularCharacteristicStatsEvalTypeValue.AngularCharacte_1101;
  else if (AngularCharacteristicStatsEvalTypeType == MinValueStatsE)
    delete AngularCharacteristicStatsEvalTypeValue.MinValueStats;
  else if (AngularCharacteristicStatsEvalTypeType == AngularCharacte_1102E)
    delete AngularCharacteristicStatsEvalTypeValue.AngularCharacte_1102;
  else if (AngularCharacteristicStatsEvalTypeType == AngularCharacte_1103E)
    delete AngularCharacteristicStatsEvalTypeValue.AngularCharacte_1103;
  else if (AngularCharacteristicStatsEvalTypeType == MinDeviationStatsE)
    delete AngularCharacteristicStatsEvalTypeValue.MinDeviationStats;
  #endif
}

void AngularCharacteristicStatsEvalTypeChoicePair::printSelf(FILE * outFile)
{
  if (AngularCharacteristicStatsEvalTypeType == AngularCharacte_1100E)
    {
      AngularCharacteristicStatsEvalTypeValue.AngularCharacte_1100->printSelf(outFile);
    }
  else if (AngularCharacteristicStatsEvalTypeType == AngularCharacte_1101E)
    {
      AngularCharacteristicStatsEvalTypeValue.AngularCharacte_1101->printSelf(outFile);
    }
  else if (AngularCharacteristicStatsEvalTypeType == MinValueStatsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      AngularCharacteristicStatsEvalTypeValue.MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  else if (AngularCharacteristicStatsEvalTypeType == AngularCharacte_1102E)
    {
      AngularCharacteristicStatsEvalTypeValue.AngularCharacte_1102->printSelf(outFile);
    }
  else if (AngularCharacteristicStatsEvalTypeType == AngularCharacte_1103E)
    {
      AngularCharacteristicStatsEvalTypeValue.AngularCharacte_1103->printSelf(outFile);
    }
  else if (AngularCharacteristicStatsEvalTypeType == MinDeviationStatsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      AngularCharacteristicStatsEvalTypeValue.MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

/* ***************************************************************** */

/* class AngularCoordinateCharacteristicStatsEvalType

*/

AngularCoordinateCharacteristicStatsEvalType::AngularCoordinateCharacteristicStatsEvalType() :
  AngularCharacteristicStatsEvalType() {}

AngularCoordinateCharacteristicStatsEvalType::AngularCoordinateCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 AngularCharacteristicStatsEvalTypeChoicePair * AngularCharacteristicStatsEvalTypePairIn) :
  AngularCharacteristicStatsEvalType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    AngularCharacteristicStatsEvalTypePairIn)
{}

AngularCoordinateCharacteristicStatsEvalType::~AngularCoordinateCharacteristicStatsEvalType() {}

void AngularCoordinateCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  AngularCharacteristicStatsEvalTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class AngularityCharacteristicStatsEvalType

*/

AngularityCharacteristicStatsEvalType::AngularityCharacteristicStatsEvalType() :
  OrientationCharacteristicStatsEvalType() {}

AngularityCharacteristicStatsEvalType::AngularityCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsWithTolLinearType * ValueStatsIn,
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn,
 OneSidedCapabilityCalculationEnumType * CapabilityCalculationMethodIn,
 StatsPassFailType * DatumsOkStatsIn,
 StatsLinearType * BonusStatsIn,
 StatsLinearType * ReferenceLengthStatsIn) :
  OrientationCharacteristicStatsEvalType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    ValueStatsIn,
    MaxValueStatsIn,
    MinValueStatsIn,
    CapabilityCalculationMethodIn,
    DatumsOkStatsIn,
    BonusStatsIn,
    ReferenceLengthStatsIn)
{}

AngularityCharacteristicStatsEvalType::~AngularityCharacteristicStatsEvalType() {}

void AngularityCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (ValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ValueStats");
      ValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ValueStats>\n");
    }
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  if (CapabilityCalculationMethod)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CapabilityCalculationMethod");
      CapabilityCalculationMethod->printSelf(outFile);
      fprintf(outFile, "</CapabilityCalculationMethod>\n");
    }
  if (DatumsOkStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumsOkStats");
      DatumsOkStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DatumsOkStats>\n");
    }
  if (BonusStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BonusStats");
      BonusStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BonusStats>\n");
    }
  if (ReferenceLengthStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ReferenceLengthStats");
      ReferenceLengthStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ReferenceLengthStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class AssignableCauseEnumType

*/

AssignableCauseEnumType::AssignableCauseEnumType() :
  XmlNMTOKEN()
{
}

AssignableCauseEnumType::AssignableCauseEnumType(
 const char * valIn) :
  XmlNMTOKEN(
    valIn)
{
  if (!bad)
    bad = (strcmp(val.c_str(), "POWER_FAILURE") &&
           strcmp(val.c_str(), "BROKEN_TOOL") &&
           strcmp(val.c_str(), "COMPUTER_CRASH") &&
           strcmp(val.c_str(), "WEATHER_EVENT") &&
           strcmp(val.c_str(), "OTHER"));
}

AssignableCauseEnumType::~AssignableCauseEnumType() {}

bool AssignableCauseEnumType::AssignableCauseEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "POWER_FAILURE") &&
          strcmp(val.c_str(), "BROKEN_TOOL") &&
          strcmp(val.c_str(), "COMPUTER_CRASH") &&
          strcmp(val.c_str(), "WEATHER_EVENT") &&
          strcmp(val.c_str(), "OTHER"));
}

void AssignableCauseEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "AssignableCauseEnumType");
}

void AssignableCauseEnumType::printSelf(FILE * outFile)
{
  if (AssignableCauseEnumTypeIsBad())
    {
      fprintf(stderr, "bad AssignableCauseEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::printSelf(outFile);
}

void AssignableCauseEnumType::oPrintSelf(FILE * outFile)
{
  if (AssignableCauseEnumTypeIsBad())
    {
      fprintf(stderr, "bad AssignableCauseEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class AssignableCauseType

*/

AssignableCauseType::AssignableCauseType()
{
  id = 0;
  Attributes = 0;
  AssignableCause_1104 = 0;
  CorrectiveActionIds = 0;
}

AssignableCauseType::AssignableCauseType(
 AttributesType * AttributesIn,
 AssignableCause_1104_Type * AssignableCause_1104In,
 ArrayReferenceType * CorrectiveActionIdsIn)
{
  id = 0;
  Attributes = AttributesIn;
  AssignableCause_1104 = AssignableCause_1104In;
  CorrectiveActionIds = CorrectiveActionIdsIn;
}

AssignableCauseType::AssignableCauseType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 AssignableCause_1104_Type * AssignableCause_1104In,
 ArrayReferenceType * CorrectiveActionIdsIn)
{
  id = idIn;
  Attributes = AttributesIn;
  AssignableCause_1104 = AssignableCause_1104In;
  CorrectiveActionIds = CorrectiveActionIdsIn;
}

AssignableCauseType::~AssignableCauseType()
{
  #ifndef NODESTRUCT
  delete id;
  delete Attributes;
  delete AssignableCause_1104;
  delete CorrectiveActionIds;
  #endif
}

void AssignableCauseType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  AssignableCause_1104->printSelf(outFile);
  if (CorrectiveActionIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CorrectiveActionIds");
      CorrectiveActionIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CorrectiveActionIds>\n");
    }
  doSpaces(-INDENT, outFile);
}

bool AssignableCauseType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in AssignableCauseType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->val.c_str());
          if (idVal->bad)
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in AssignableCauseType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in AssignableCauseType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id == 0)
    {
      fprintf(stderr, "required attribute \"id\" missing in AssignableCauseType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

QIFIdType * AssignableCauseType::getid()
{return id;}

void AssignableCauseType::setid(QIFIdType * idIn)
{id = idIn;}

AttributesType * AssignableCauseType::getAttributes()
{return Attributes;}

void AssignableCauseType::setAttributes(AttributesType * AttributesIn)
{Attributes = AttributesIn;}

AssignableCause_1104_Type * AssignableCauseType::getAssignableCause_1104()
{return AssignableCause_1104;}

void AssignableCauseType::setAssignableCause_1104(AssignableCause_1104_Type * AssignableCause_1104In)
{AssignableCause_1104 = AssignableCause_1104In;}

ArrayReferenceType * AssignableCauseType::getCorrectiveActionIds()
{return CorrectiveActionIds;}

void AssignableCauseType::setCorrectiveActionIds(ArrayReferenceType * CorrectiveActionIdsIn)
{CorrectiveActionIds = CorrectiveActionIdsIn;}

/* ***************************************************************** */

/* class AssignableCauseTypeLisd

*/

AssignableCauseTypeLisd::AssignableCauseTypeLisd() {}

AssignableCauseTypeLisd::AssignableCauseTypeLisd(AssignableCauseType * aAssignableCauseType)
{
  push_back(aAssignableCauseType);
}

AssignableCauseTypeLisd::~AssignableCauseTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<AssignableCauseType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void AssignableCauseTypeLisd::printSelf(FILE * outFile)
{
  std::list<AssignableCauseType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class AssignableCausesType

*/

AssignableCausesType::AssignableCausesType()
{
  n = 0;
  AssignableCause = 0;
}

AssignableCausesType::AssignableCausesType(
 AssignableCauseTypeLisd * AssignableCauseIn)
{
  n = 0;
  AssignableCause = AssignableCauseIn;
}

AssignableCausesType::AssignableCausesType(
 NaturalType * nIn,
 AssignableCauseTypeLisd * AssignableCauseIn)
{
  n = nIn;
  AssignableCause = AssignableCauseIn;
}

AssignableCausesType::~AssignableCausesType()
{
  #ifndef NODESTRUCT
  delete n;
  delete AssignableCause;
  #endif
}

void AssignableCausesType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!AssignableCause)
      {
        fprintf(stderr, "AssignableCause list is missing\n");
        exit(1);
      }
    if (AssignableCause->size() == 0)
      {
        fprintf(stderr, "AssignableCause list is empty\n");
        exit(1);
      }
    if (AssignableCause->size() < 1)
      {
        fprintf(stderr,
                "size of AssignableCause list (%d) less than minimum required (1)\n",
                (int)AssignableCause->size());
        exit(1);
      }
    std::list<AssignableCauseType *>::iterator iter;
    for (iter = AssignableCause->begin();
         iter != AssignableCause->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<AssignableCause");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</AssignableCause>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool AssignableCausesType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in AssignableCausesType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->val.c_str());
          if (nVal->bad)
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in AssignableCausesType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in AssignableCausesType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in AssignableCausesType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * AssignableCausesType::getn()
{return n;}

void AssignableCausesType::setn(NaturalType * nIn)
{n = nIn;}

AssignableCauseTypeLisd * AssignableCausesType::getAssignableCause()
{return AssignableCause;}

void AssignableCausesType::setAssignableCause(AssignableCauseTypeLisd * AssignableCauseIn)
{AssignableCause = AssignableCauseIn;}

/* ***************************************************************** */

/* class AverageFeatureType

*/

AverageFeatureType::AverageFeatureType()
{
  FeatureMeasurement = 0;
  MeasuredIds = 0;
}

AverageFeatureType::AverageFeatureType(
 FeatureMeasurementBaseType * FeatureMeasurementIn,
 StatsArrayIdType * MeasuredIdsIn)
{
  FeatureMeasurement = FeatureMeasurementIn;
  MeasuredIds = MeasuredIdsIn;
}

AverageFeatureType::~AverageFeatureType()
{
  #ifndef NODESTRUCT
  delete FeatureMeasurement;
  delete MeasuredIds;
  #endif
}

void AverageFeatureType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    doSpaces(0, outFile);
    if (FeatureMeasurement->printElement == 0)
      {
        fprintf(stderr, "element name missing\n");
        exit(1);
      }
    else if (strcmp(FeatureMeasurement->printElement, "CircleFeatureMeasurement") == 0)
      {
        CircleFeatureMeasurementType * typ;
        if ((typ = dynamic_cast<CircleFeatureMeasurementType *>(FeatureMeasurement)))
          {
            fprintf(outFile, "<CircleFeatureMeasurement");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</CircleFeatureMeasurement>\n");
          }
        else
          {
            fprintf(stderr, "bad CircleFeatureMeasurement element\n");
            exit(1);
          }
      }
    else if (strcmp(FeatureMeasurement->printElement, "CircularArcFeatureMeasurement") == 0)
      {
        CircularArcFeatureMeasurementType * typ;
        if ((typ = dynamic_cast<CircularArcFeatureMeasurementType *>(FeatureMeasurement)))
          {
            fprintf(outFile, "<CircularArcFeatureMeasurement");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</CircularArcFeatureMeasurement>\n");
          }
        else
          {
            fprintf(stderr, "bad CircularArcFeatureMeasurement element\n");
            exit(1);
          }
      }
    else if (strcmp(FeatureMeasurement->printElement, "ConeFeatureMeasurement") == 0)
      {
        ConeFeatureMeasurementType * typ;
        if ((typ = dynamic_cast<ConeFeatureMeasurementType *>(FeatureMeasurement)))
          {
            fprintf(outFile, "<ConeFeatureMeasurement");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</ConeFeatureMeasurement>\n");
          }
        else
          {
            fprintf(stderr, "bad ConeFeatureMeasurement element\n");
            exit(1);
          }
      }
    else if (strcmp(FeatureMeasurement->printElement, "ConicalSegmentFeatureMeasurement") == 0)
      {
        ConicalSegmentFeatureMeasurementType * typ;
        if ((typ = dynamic_cast<ConicalSegmentFeatureMeasurementType *>(FeatureMeasurement)))
          {
            fprintf(outFile, "<ConicalSegmentFeatureMeasurement");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</ConicalSegmentFeatureMeasurement>\n");
          }
        else
          {
            fprintf(stderr, "bad ConicalSegmentFeatureMeasurement element\n");
            exit(1);
          }
      }
    else if (strcmp(FeatureMeasurement->printElement, "CylinderFeatureMeasurement") == 0)
      {
        CylinderFeatureMeasurementType * typ;
        if ((typ = dynamic_cast<CylinderFeatureMeasurementType *>(FeatureMeasurement)))
          {
            fprintf(outFile, "<CylinderFeatureMeasurement");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</CylinderFeatureMeasurement>\n");
          }
        else
          {
            fprintf(stderr, "bad CylinderFeatureMeasurement element\n");
            exit(1);
          }
      }
    else if (strcmp(FeatureMeasurement->printElement, "CylindricalSegmentFeatureMeasurement") == 0)
      {
        CylindricalSegmentFeatureMeasurementType * typ;
        if ((typ = dynamic_cast<CylindricalSegmentFeatureMeasurementType *>(FeatureMeasurement)))
          {
            fprintf(outFile, "<CylindricalSegmentFeatureMeasurement");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</CylindricalSegmentFeatureMeasurement>\n");
          }
        else
          {
            fprintf(stderr, "bad CylindricalSegmentFeatureMeasurement element\n");
            exit(1);
          }
      }
    else if (strcmp(FeatureMeasurement->printElement, "EdgePointFeatureMeasurement") == 0)
      {
        EdgePointFeatureMeasurementType * typ;
        if ((typ = dynamic_cast<EdgePointFeatureMeasurementType *>(FeatureMeasurement)))
          {
            fprintf(outFile, "<EdgePointFeatureMeasurement");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</EdgePointFeatureMeasurement>\n");
          }
        else
          {
            fprintf(stderr, "bad EdgePointFeatureMeasurement element\n");
            exit(1);
          }
      }
    else if (strcmp(FeatureMeasurement->printElement, "EllipseFeatureMeasurement") == 0)
      {
        EllipseFeatureMeasurementType * typ;
        if ((typ = dynamic_cast<EllipseFeatureMeasurementType *>(FeatureMeasurement)))
          {
            fprintf(outFile, "<EllipseFeatureMeasurement");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</EllipseFeatureMeasurement>\n");
          }
        else
          {
            fprintf(stderr, "bad EllipseFeatureMeasurement element\n");
            exit(1);
          }
      }
    else if (strcmp(FeatureMeasurement->printElement, "EllipticalArcFeatureMeasurement") == 0)
      {
        EllipticalArcFeatureMeasurementType * typ;
        if ((typ = dynamic_cast<EllipticalArcFeatureMeasurementType *>(FeatureMeasurement)))
          {
            fprintf(outFile, "<EllipticalArcFeatureMeasurement");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</EllipticalArcFeatureMeasurement>\n");
          }
        else
          {
            fprintf(stderr, "bad EllipticalArcFeatureMeasurement element\n");
            exit(1);
          }
      }
    else if (strcmp(FeatureMeasurement->printElement, "ElongatedCircleFeatureMeasurement") == 0)
      {
        ElongatedCircleFeatureMeasurementType * typ;
        if ((typ = dynamic_cast<ElongatedCircleFeatureMeasurementType *>(FeatureMeasurement)))
          {
            fprintf(outFile, "<ElongatedCircleFeatureMeasurement");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</ElongatedCircleFeatureMeasurement>\n");
          }
        else
          {
            fprintf(stderr, "bad ElongatedCircleFeatureMeasurement element\n");
            exit(1);
          }
      }
    else if (strcmp(FeatureMeasurement->printElement, "ElongatedCylinderFeatureMeasurement") == 0)
      {
        ElongatedCylinderFeatureMeasurementType * typ;
        if ((typ = dynamic_cast<ElongatedCylinderFeatureMeasurementType *>(FeatureMeasurement)))
          {
            fprintf(outFile, "<ElongatedCylinderFeatureMeasurement");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</ElongatedCylinderFeatureMeasurement>\n");
          }
        else
          {
            fprintf(stderr, "bad ElongatedCylinderFeatureMeasurement element\n");
            exit(1);
          }
      }
    else if (strcmp(FeatureMeasurement->printElement, "ExtrudedCrossSectionFeatureMeasurement") == 0)
      {
        ExtrudedCrossSectionFeatureMeasurementType * typ;
        if ((typ = dynamic_cast<ExtrudedCrossSectionFeatureMeasurementType *>(FeatureMeasurement)))
          {
            fprintf(outFile, "<ExtrudedCrossSectionFeatureMeasurement");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</ExtrudedCrossSectionFeatureMeasurement>\n");
          }
        else
          {
            fprintf(stderr, "bad ExtrudedCrossSectionFeatureMeasurement element\n");
            exit(1);
          }
      }
    else if (strcmp(FeatureMeasurement->printElement, "GroupFeatureMeasurement") == 0)
      {
        GroupFeatureMeasurementType * typ;
        if ((typ = dynamic_cast<GroupFeatureMeasurementType *>(FeatureMeasurement)))
          {
            fprintf(outFile, "<GroupFeatureMeasurement");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</GroupFeatureMeasurement>\n");
          }
        else
          {
            fprintf(stderr, "bad GroupFeatureMeasurement element\n");
            exit(1);
          }
      }
    else if (strcmp(FeatureMeasurement->printElement, "LineFeatureMeasurement") == 0)
      {
        LineFeatureMeasurementType * typ;
        if ((typ = dynamic_cast<LineFeatureMeasurementType *>(FeatureMeasurement)))
          {
            fprintf(outFile, "<LineFeatureMeasurement");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</LineFeatureMeasurement>\n");
          }
        else
          {
            fprintf(stderr, "bad LineFeatureMeasurement element\n");
            exit(1);
          }
      }
    else if (strcmp(FeatureMeasurement->printElement, "MarkingFeatureMeasurement") == 0)
      {
        MarkingFeatureMeasurementType * typ;
        if ((typ = dynamic_cast<MarkingFeatureMeasurementType *>(FeatureMeasurement)))
          {
            fprintf(outFile, "<MarkingFeatureMeasurement");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</MarkingFeatureMeasurement>\n");
          }
        else
          {
            fprintf(stderr, "bad MarkingFeatureMeasurement element\n");
            exit(1);
          }
      }
    else if (strcmp(FeatureMeasurement->printElement, "OppositeAngledLinesFeatureMeasurement") == 0)
      {
        OppositeAngledLinesFeatureMeasurementType * typ;
        if ((typ = dynamic_cast<OppositeAngledLinesFeatureMeasurementType *>(FeatureMeasurement)))
          {
            fprintf(outFile, "<OppositeAngledLinesFeatureMeasurement");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</OppositeAngledLinesFeatureMeasurement>\n");
          }
        else
          {
            fprintf(stderr, "bad OppositeAngledLinesFeatureMeasurement element\n");
            exit(1);
          }
      }
    else if (strcmp(FeatureMeasurement->printElement, "OppositeAngledPlanesFeatureMeasurement") == 0)
      {
        OppositeAngledPlanesFeatureMeasurementType * typ;
        if ((typ = dynamic_cast<OppositeAngledPlanesFeatureMeasurementType *>(FeatureMeasurement)))
          {
            fprintf(outFile, "<OppositeAngledPlanesFeatureMeasurement");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</OppositeAngledPlanesFeatureMeasurement>\n");
          }
        else
          {
            fprintf(stderr, "bad OppositeAngledPlanesFeatureMeasurement element\n");
            exit(1);
          }
      }
    else if (strcmp(FeatureMeasurement->printElement, "OppositeParallelLinesFeatureMeasurement") == 0)
      {
        OppositeParallelLinesFeatureMeasurementType * typ;
        if ((typ = dynamic_cast<OppositeParallelLinesFeatureMeasurementType *>(FeatureMeasurement)))
          {
            fprintf(outFile, "<OppositeParallelLinesFeatureMeasurement");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</OppositeParallelLinesFeatureMeasurement>\n");
          }
        else
          {
            fprintf(stderr, "bad OppositeParallelLinesFeatureMeasurement element\n");
            exit(1);
          }
      }
    else if (strcmp(FeatureMeasurement->printElement, "OppositeParallelPlanesFeatureMeasurement") == 0)
      {
        OppositeParallelPlanesFeatureMeasurementType * typ;
        if ((typ = dynamic_cast<OppositeParallelPlanesFeatureMeasurementType *>(FeatureMeasurement)))
          {
            fprintf(outFile, "<OppositeParallelPlanesFeatureMeasurement");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</OppositeParallelPlanesFeatureMeasurement>\n");
          }
        else
          {
            fprintf(stderr, "bad OppositeParallelPlanesFeatureMeasurement element\n");
            exit(1);
          }
      }
    else if (strcmp(FeatureMeasurement->printElement, "OtherCurveFeatureMeasurement") == 0)
      {
        OtherCurveFeatureMeasurementType * typ;
        if ((typ = dynamic_cast<OtherCurveFeatureMeasurementType *>(FeatureMeasurement)))
          {
            fprintf(outFile, "<OtherCurveFeatureMeasurement");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</OtherCurveFeatureMeasurement>\n");
          }
        else
          {
            fprintf(stderr, "bad OtherCurveFeatureMeasurement element\n");
            exit(1);
          }
      }
    else if (strcmp(FeatureMeasurement->printElement, "OtherNonShapeFeatureMeasurement") == 0)
      {
        OtherNonShapeFeatureMeasurementType * typ;
        if ((typ = dynamic_cast<OtherNonShapeFeatureMeasurementType *>(FeatureMeasurement)))
          {
            fprintf(outFile, "<OtherNonShapeFeatureMeasurement");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</OtherNonShapeFeatureMeasurement>\n");
          }
        else
          {
            fprintf(stderr, "bad OtherNonShapeFeatureMeasurement element\n");
            exit(1);
          }
      }
    else if (strcmp(FeatureMeasurement->printElement, "OtherShapeFeatureMeasurement") == 0)
      {
        OtherShapeFeatureMeasurementType * typ;
        if ((typ = dynamic_cast<OtherShapeFeatureMeasurementType *>(FeatureMeasurement)))
          {
            fprintf(outFile, "<OtherShapeFeatureMeasurement");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</OtherShapeFeatureMeasurement>\n");
          }
        else
          {
            fprintf(stderr, "bad OtherShapeFeatureMeasurement element\n");
            exit(1);
          }
      }
    else if (strcmp(FeatureMeasurement->printElement, "OtherSurfaceFeatureMeasurement") == 0)
      {
        OtherSurfaceFeatureMeasurementType * typ;
        if ((typ = dynamic_cast<OtherSurfaceFeatureMeasurementType *>(FeatureMeasurement)))
          {
            fprintf(outFile, "<OtherSurfaceFeatureMeasurement");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</OtherSurfaceFeatureMeasurement>\n");
          }
        else
          {
            fprintf(stderr, "bad OtherSurfaceFeatureMeasurement element\n");
            exit(1);
          }
      }
    else if (strcmp(FeatureMeasurement->printElement, "PlaneFeatureMeasurement") == 0)
      {
        PlaneFeatureMeasurementType * typ;
        if ((typ = dynamic_cast<PlaneFeatureMeasurementType *>(FeatureMeasurement)))
          {
            fprintf(outFile, "<PlaneFeatureMeasurement");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</PlaneFeatureMeasurement>\n");
          }
        else
          {
            fprintf(stderr, "bad PlaneFeatureMeasurement element\n");
            exit(1);
          }
      }
    else if (strcmp(FeatureMeasurement->printElement, "PointDefinedCurveFeatureMeasurement") == 0)
      {
        PointDefinedCurveFeatureMeasurementType * typ;
        if ((typ = dynamic_cast<PointDefinedCurveFeatureMeasurementType *>(FeatureMeasurement)))
          {
            fprintf(outFile, "<PointDefinedCurveFeatureMeasurement");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</PointDefinedCurveFeatureMeasurement>\n");
          }
        else
          {
            fprintf(stderr, "bad PointDefinedCurveFeatureMeasurement element\n");
            exit(1);
          }
      }
    else if (strcmp(FeatureMeasurement->printElement, "PointDefinedSurfaceFeatureMeasurement") == 0)
      {
        PointDefinedSurfaceFeatureMeasurementType * typ;
        if ((typ = dynamic_cast<PointDefinedSurfaceFeatureMeasurementType *>(FeatureMeasurement)))
          {
            fprintf(outFile, "<PointDefinedSurfaceFeatureMeasurement");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</PointDefinedSurfaceFeatureMeasurement>\n");
          }
        else
          {
            fprintf(stderr, "bad PointDefinedSurfaceFeatureMeasurement element\n");
            exit(1);
          }
      }
    else if (strcmp(FeatureMeasurement->printElement, "PointFeatureMeasurement") == 0)
      {
        PointFeatureMeasurementType * typ;
        if ((typ = dynamic_cast<PointFeatureMeasurementType *>(FeatureMeasurement)))
          {
            fprintf(outFile, "<PointFeatureMeasurement");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</PointFeatureMeasurement>\n");
          }
        else
          {
            fprintf(stderr, "bad PointFeatureMeasurement element\n");
            exit(1);
          }
      }
    else if (strcmp(FeatureMeasurement->printElement, "SphereFeatureMeasurement") == 0)
      {
        SphereFeatureMeasurementType * typ;
        if ((typ = dynamic_cast<SphereFeatureMeasurementType *>(FeatureMeasurement)))
          {
            fprintf(outFile, "<SphereFeatureMeasurement");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</SphereFeatureMeasurement>\n");
          }
        else
          {
            fprintf(stderr, "bad SphereFeatureMeasurement element\n");
            exit(1);
          }
      }
    else if (strcmp(FeatureMeasurement->printElement, "SphericalSegmentFeatureMeasurement") == 0)
      {
        SphericalSegmentFeatureMeasurementType * typ;
        if ((typ = dynamic_cast<SphericalSegmentFeatureMeasurementType *>(FeatureMeasurement)))
          {
            fprintf(outFile, "<SphericalSegmentFeatureMeasurement");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</SphericalSegmentFeatureMeasurement>\n");
          }
        else
          {
            fprintf(stderr, "bad SphericalSegmentFeatureMeasurement element\n");
            exit(1);
          }
      }
    else if (strcmp(FeatureMeasurement->printElement, "SurfaceOfRevolutionFeatureMeasurement") == 0)
      {
        SurfaceOfRevolutionFeatureMeasurementType * typ;
        if ((typ = dynamic_cast<SurfaceOfRevolutionFeatureMeasurementType *>(FeatureMeasurement)))
          {
            fprintf(outFile, "<SurfaceOfRevolutionFeatureMeasurement");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</SurfaceOfRevolutionFeatureMeasurement>\n");
          }
        else
          {
            fprintf(stderr, "bad SurfaceOfRevolutionFeatureMeasurement element\n");
            exit(1);
          }
      }
    else if (strcmp(FeatureMeasurement->printElement, "ThreadedFeatureMeasurement") == 0)
      {
        ThreadedFeatureMeasurementType * typ;
        if ((typ = dynamic_cast<ThreadedFeatureMeasurementType *>(FeatureMeasurement)))
          {
            fprintf(outFile, "<ThreadedFeatureMeasurement");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</ThreadedFeatureMeasurement>\n");
          }
        else
          {
            fprintf(stderr, "bad ThreadedFeatureMeasurement element\n");
            exit(1);
          }
      }
    else if (strcmp(FeatureMeasurement->printElement, "ToroidalSegmentFeatureMeasurement") == 0)
      {
        ToroidalSegmentFeatureMeasurementType * typ;
        if ((typ = dynamic_cast<ToroidalSegmentFeatureMeasurementType *>(FeatureMeasurement)))
          {
            fprintf(outFile, "<ToroidalSegmentFeatureMeasurement");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</ToroidalSegmentFeatureMeasurement>\n");
          }
        else
          {
            fprintf(stderr, "bad ToroidalSegmentFeatureMeasurement element\n");
            exit(1);
          }
      }
    else if (strcmp(FeatureMeasurement->printElement, "TorusFeatureMeasurement") == 0)
      {
        TorusFeatureMeasurementType * typ;
        if ((typ = dynamic_cast<TorusFeatureMeasurementType *>(FeatureMeasurement)))
          {
            fprintf(outFile, "<TorusFeatureMeasurement");
            typ->printSelf(outFile);
            doSpaces(0, outFile);
            fprintf(outFile, "</TorusFeatureMeasurement>\n");
          }
        else
          {
            fprintf(stderr, "bad TorusFeatureMeasurement element\n");
            exit(1);
          }
      }
    else
      {
        fprintf(stderr, "bad FeatureMeasurement type\n");
        fprintf(stderr, " exiting\n");
        exit(1);
      }
  }
  doSpaces(0, outFile);
  fprintf(outFile, "<MeasuredIds");
  MeasuredIds->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</MeasuredIds>\n");
  doSpaces(-INDENT, outFile);
}

FeatureMeasurementBaseType * AverageFeatureType::getFeatureMeasurement()
{return FeatureMeasurement;}

void AverageFeatureType::setFeatureMeasurement(FeatureMeasurementBaseType * FeatureMeasurementIn)
{FeatureMeasurement = FeatureMeasurementIn;}

StatsArrayIdType * AverageFeatureType::getMeasuredIds()
{return MeasuredIds;}

void AverageFeatureType::setMeasuredIds(StatsArrayIdType * MeasuredIdsIn)
{MeasuredIds = MeasuredIdsIn;}

/* ***************************************************************** */

/* class AverageFeatureTypeLisd

*/

AverageFeatureTypeLisd::AverageFeatureTypeLisd() {}

AverageFeatureTypeLisd::AverageFeatureTypeLisd(AverageFeatureType * aAverageFeatureType)
{
  push_back(aAverageFeatureType);
}

AverageFeatureTypeLisd::~AverageFeatureTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<AverageFeatureType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void AverageFeatureTypeLisd::printSelf(FILE * outFile)
{
  std::list<AverageFeatureType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class AverageFeaturesType

*/

AverageFeaturesType::AverageFeaturesType()
{
  n = 0;
  AverageFeature = 0;
}

AverageFeaturesType::AverageFeaturesType(
 AverageFeatureTypeLisd * AverageFeatureIn)
{
  n = 0;
  AverageFeature = AverageFeatureIn;
}

AverageFeaturesType::AverageFeaturesType(
 NaturalType * nIn,
 AverageFeatureTypeLisd * AverageFeatureIn)
{
  n = nIn;
  AverageFeature = AverageFeatureIn;
}

AverageFeaturesType::~AverageFeaturesType()
{
  #ifndef NODESTRUCT
  delete n;
  delete AverageFeature;
  #endif
}

void AverageFeaturesType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!AverageFeature)
      {
        fprintf(stderr, "AverageFeature list is missing\n");
        exit(1);
      }
    if (AverageFeature->size() == 0)
      {
        fprintf(stderr, "AverageFeature list is empty\n");
        exit(1);
      }
    if (AverageFeature->size() < 1)
      {
        fprintf(stderr,
                "size of AverageFeature list (%d) less than minimum required (1)\n",
                (int)AverageFeature->size());
        exit(1);
      }
    std::list<AverageFeatureType *>::iterator iter;
    for (iter = AverageFeature->begin();
         iter != AverageFeature->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<AverageFeature");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</AverageFeature>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool AverageFeaturesType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in AverageFeaturesType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->val.c_str());
          if (nVal->bad)
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in AverageFeaturesType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in AverageFeaturesType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in AverageFeaturesType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * AverageFeaturesType::getn()
{return n;}

void AverageFeaturesType::setn(NaturalType * nIn)
{n = nIn;}

AverageFeatureTypeLisd * AverageFeaturesType::getAverageFeature()
{return AverageFeature;}

void AverageFeaturesType::setAverageFeature(AverageFeatureTypeLisd * AverageFeatureIn)
{AverageFeature = AverageFeatureIn;}

/* ***************************************************************** */

/* class CharacteristicStatsEvalBaseType

*/

CharacteristicStatsEvalBaseType::CharacteristicStatsEvalBaseType()
{
  Attributes = 0;
  CharacteristicS_1105 = 0;
  CharacteristicS_1106 = 0;
  Status = 0;
  StudyIssues = 0;
  DistributionTransformation = 0;
}

CharacteristicStatsEvalBaseType::CharacteristicStatsEvalBaseType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn)
{
  Attributes = AttributesIn;
  CharacteristicS_1105 = CharacteristicS_1105In;
  CharacteristicS_1106 = CharacteristicS_1106In;
  Status = StatusIn;
  StudyIssues = StudyIssuesIn;
  DistributionTransformation = DistributionTransformationIn;
}

CharacteristicStatsEvalBaseType::~CharacteristicStatsEvalBaseType()
{
  #ifndef NODESTRUCT
  delete Attributes;
  delete CharacteristicS_1105;
  delete CharacteristicS_1106;
  delete Status;
  delete StudyIssues;
  delete DistributionTransformation;
  #endif
}

void CharacteristicStatsEvalBaseType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  doSpaces(-INDENT, outFile);
}

AttributesType * CharacteristicStatsEvalBaseType::getAttributes()
{return Attributes;}

void CharacteristicStatsEvalBaseType::setAttributes(AttributesType * AttributesIn)
{Attributes = AttributesIn;}

CharacteristicS_1105_Type * CharacteristicStatsEvalBaseType::getCharacteristicS_1105()
{return CharacteristicS_1105;}

void CharacteristicStatsEvalBaseType::setCharacteristicS_1105(CharacteristicS_1105_Type * CharacteristicS_1105In)
{CharacteristicS_1105 = CharacteristicS_1105In;}

CharacteristicS_1106_Type * CharacteristicStatsEvalBaseType::getCharacteristicS_1106()
{return CharacteristicS_1106;}

void CharacteristicStatsEvalBaseType::setCharacteristicS_1106(CharacteristicS_1106_Type * CharacteristicS_1106In)
{CharacteristicS_1106 = CharacteristicS_1106In;}

StatsEvalStatusType * CharacteristicStatsEvalBaseType::getStatus()
{return Status;}

void CharacteristicStatsEvalBaseType::setStatus(StatsEvalStatusType * StatusIn)
{Status = StatusIn;}

StudyIssuesType * CharacteristicStatsEvalBaseType::getStudyIssues()
{return StudyIssues;}

void CharacteristicStatsEvalBaseType::setStudyIssues(StudyIssuesType * StudyIssuesIn)
{StudyIssues = StudyIssuesIn;}

DistributionTransformationType * CharacteristicStatsEvalBaseType::getDistributionTransformation()
{return DistributionTransformation;}

void CharacteristicStatsEvalBaseType::setDistributionTransformation(DistributionTransformationType * DistributionTransformationIn)
{DistributionTransformation = DistributionTransformationIn;}

/* ***************************************************************** */

/* class CharacteristicStatsEvalBaseTypeLisd

*/

CharacteristicStatsEvalBaseTypeLisd::CharacteristicStatsEvalBaseTypeLisd() {}

CharacteristicStatsEvalBaseTypeLisd::CharacteristicStatsEvalBaseTypeLisd(CharacteristicStatsEvalBaseType * aCharacteristicStatsEvalBaseType)
{
  push_back(aCharacteristicStatsEvalBaseType);
}

CharacteristicStatsEvalBaseTypeLisd::~CharacteristicStatsEvalBaseTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<CharacteristicStatsEvalBaseType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void CharacteristicStatsEvalBaseTypeLisd::printSelf(FILE * outFile)
{
  std::list<CharacteristicStatsEvalBaseType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class CharacteristicsStatsType

*/

CharacteristicsStatsType::CharacteristicsStatsType()
{
  n = 0;
  CharacteristicStats = 0;
}

CharacteristicsStatsType::CharacteristicsStatsType(
 CharacteristicStatsEvalBaseTypeLisd * CharacteristicStatsIn)
{
  n = 0;
  CharacteristicStats = CharacteristicStatsIn;
}

CharacteristicsStatsType::CharacteristicsStatsType(
 NaturalType * nIn,
 CharacteristicStatsEvalBaseTypeLisd * CharacteristicStatsIn)
{
  n = nIn;
  CharacteristicStats = CharacteristicStatsIn;
}

CharacteristicsStatsType::~CharacteristicsStatsType()
{
  #ifndef NODESTRUCT
  delete n;
  delete CharacteristicStats;
  #endif
}

void CharacteristicsStatsType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!CharacteristicStats)
      {
        fprintf(stderr, "CharacteristicStats list is missing\n");
        exit(1);
      }
    if (CharacteristicStats->size() == 0)
      {
        fprintf(stderr, "CharacteristicStats list is empty\n");
        exit(1);
      }
    if (CharacteristicStats->size() < 1)
      {
        fprintf(stderr,
                "size of CharacteristicStats list (%d) less than minimum required (1)\n",
                (int)CharacteristicStats->size());
        exit(1);
      }
    std::list<CharacteristicStatsEvalBaseType *>::iterator iter;
    for (iter = CharacteristicStats->begin();
         iter != CharacteristicStats->end(); iter++)
      {
        CharacteristicStatsEvalBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "AngleBetweenCharacteristicStats") == 0)
          {
            AngleBetweenCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<AngleBetweenCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<AngleBetweenCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AngleBetweenCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad AngleBetweenCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AngleCharacteristicStats") == 0)
          {
            AngleCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<AngleCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<AngleCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AngleCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad AngleCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AngularCoordinateCharacteristicStats") == 0)
          {
            AngularCoordinateCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<AngularCoordinateCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<AngularCoordinateCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AngularCoordinateCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad AngularCoordinateCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AngleFromCharacteristicStats") == 0)
          {
            AngleFromCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<AngleFromCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<AngleFromCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AngleFromCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad AngleFromCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AngularCharacteristicStats") == 0)
          {
            AngularCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<AngularCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<AngularCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AngularCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad AngularCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AngularityCharacteristicStats") == 0)
          {
            AngularityCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<AngularityCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<AngularityCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AngularityCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad AngularityCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "ChordCharacteristicStats") == 0)
          {
            ChordCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<ChordCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<ChordCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ChordCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad ChordCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "CircularityCharacteristicStats") == 0)
          {
            CircularityCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<CircularityCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<CircularityCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CircularityCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad CircularityCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "CircularRunoutCharacteristicStats") == 0)
          {
            CircularRunoutCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<CircularRunoutCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<CircularRunoutCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CircularRunoutCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad CircularRunoutCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "CoaxialityCharacteristicStats") == 0)
          {
            CoaxialityCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<CoaxialityCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<CoaxialityCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CoaxialityCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad CoaxialityCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "ConcentricityCharacteristicStats") == 0)
          {
            ConcentricityCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<ConcentricityCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<ConcentricityCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ConcentricityCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad ConcentricityCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "ConicalTaperCharacteristicStats") == 0)
          {
            ConicalTaperCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<ConicalTaperCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<ConicalTaperCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ConicalTaperCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad ConicalTaperCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "ConicityCharacteristicStats") == 0)
          {
            ConicityCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<ConicityCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<ConicityCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ConicityCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad ConicityCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "CurveLengthCharacteristicStats") == 0)
          {
            CurveLengthCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<CurveLengthCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<CurveLengthCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CurveLengthCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad CurveLengthCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "CylindricityCharacteristicStats") == 0)
          {
            CylindricityCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<CylindricityCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<CylindricityCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CylindricityCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad CylindricityCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "DepthCharacteristicStats") == 0)
          {
            DepthCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<DepthCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<DepthCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</DepthCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad DepthCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "DiameterCharacteristicStats") == 0)
          {
            DiameterCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<DiameterCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<DiameterCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</DiameterCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad DiameterCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "DistanceBetweenCharacteristicStats") == 0)
          {
            DistanceBetweenCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<DistanceBetweenCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<DistanceBetweenCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</DistanceBetweenCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad DistanceBetweenCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "DistanceFromCharacteristicStats") == 0)
          {
            DistanceFromCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<DistanceFromCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<DistanceFromCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</DistanceFromCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad DistanceFromCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EllipticityCharacteristicStats") == 0)
          {
            EllipticityCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<EllipticityCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<EllipticityCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EllipticityCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad EllipticityCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "FlatnessCharacteristicStats") == 0)
          {
            FlatnessCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<FlatnessCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<FlatnessCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</FlatnessCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad FlatnessCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "FlatTaperCharacteristicStats") == 0)
          {
            FlatTaperCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<FlatTaperCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<FlatTaperCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</FlatTaperCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad FlatTaperCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GeometricCharacteristicStats") == 0)
          {
            GeometricCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<GeometricCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<GeometricCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GeometricCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad GeometricCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "HeightCharacteristicStats") == 0)
          {
            HeightCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<HeightCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<HeightCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</HeightCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad HeightCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LengthCharacteristicStats") == 0)
          {
            LengthCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<LengthCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<LengthCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LengthCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad LengthCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LinearCharacteristicStats") == 0)
          {
            LinearCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<LinearCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<LinearCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LinearCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad LinearCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LinearCoordinateCharacteristicStats") == 0)
          {
            LinearCoordinateCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<LinearCoordinateCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<LinearCoordinateCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LinearCoordinateCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad LinearCoordinateCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LocationCharacteristicStats") == 0)
          {
            LocationCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<LocationCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<LocationCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LocationCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad LocationCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LineProfileCharacteristicStats") == 0)
          {
            LineProfileCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<LineProfileCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<LineProfileCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LineProfileCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad LineProfileCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "OtherFormCharacteristicStats") == 0)
          {
            OtherFormCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<OtherFormCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<OtherFormCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OtherFormCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad OtherFormCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "OrientationCharacteristicStats") == 0)
          {
            OrientationCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<OrientationCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<OrientationCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</OrientationCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad OrientationCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "ParallelismCharacteristicStats") == 0)
          {
            ParallelismCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<ParallelismCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<ParallelismCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ParallelismCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad ParallelismCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "PerpendicularityCharacteristicStats") == 0)
          {
            PerpendicularityCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<PerpendicularityCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<PerpendicularityCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PerpendicularityCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad PerpendicularityCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "PointProfileCharacteristicStats") == 0)
          {
            PointProfileCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<PointProfileCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<PointProfileCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PointProfileCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad PointProfileCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "PositionCharacteristicStats") == 0)
          {
            PositionCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<PositionCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<PositionCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PositionCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad PositionCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RadiusCharacteristicStats") == 0)
          {
            RadiusCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<RadiusCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<RadiusCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RadiusCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad RadiusCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SphericalDiameterCharacteristicStats") == 0)
          {
            SphericalDiameterCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<SphericalDiameterCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<SphericalDiameterCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalDiameterCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalDiameterCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SphericalRadiusCharacteristicStats") == 0)
          {
            SphericalRadiusCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<SphericalRadiusCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<SphericalRadiusCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericalRadiusCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericalRadiusCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SphericityCharacteristicStats") == 0)
          {
            SphericityCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<SphericityCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<SphericityCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SphericityCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad SphericityCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SquareCharacteristicStats") == 0)
          {
            SquareCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<SquareCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<SquareCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SquareCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad SquareCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "StraightnessCharacteristicStats") == 0)
          {
            StraightnessCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<StraightnessCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<StraightnessCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</StraightnessCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad StraightnessCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SurfaceProfileCharacteristicStats") == 0)
          {
            SurfaceProfileCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<SurfaceProfileCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<SurfaceProfileCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SurfaceProfileCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad SurfaceProfileCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SurfaceProfileNonUniformCharacteristicStats") == 0)
          {
            SurfaceProfileNonUniformCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<SurfaceProfileNonUniformCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<SurfaceProfileNonUniformCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SurfaceProfileNonUniformCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad SurfaceProfileNonUniformCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SurfaceTextureCharacteristicStats") == 0)
          {
            SurfaceTextureCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<SurfaceTextureCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<SurfaceTextureCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SurfaceTextureCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad SurfaceTextureCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SymmetryCharacteristicStats") == 0)
          {
            SymmetryCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<SymmetryCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<SymmetryCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SymmetryCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad SymmetryCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "ThicknessCharacteristicStats") == 0)
          {
            ThicknessCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<ThicknessCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<ThicknessCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ThicknessCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad ThicknessCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "ThreadCharacteristicStats") == 0)
          {
            ThreadCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<ThreadCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<ThreadCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ThreadCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad ThreadCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "ToroidicityCharacteristicStats") == 0)
          {
            ToroidicityCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<ToroidicityCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<ToroidicityCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ToroidicityCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad ToroidicityCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalRunoutCharacteristicStats") == 0)
          {
            TotalRunoutCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<TotalRunoutCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<TotalRunoutCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalRunoutCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalRunoutCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UserDefinedAttributeCharacteristicStats") == 0)
          {
            UserDefinedAttributeCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<UserDefinedAttributeCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedAttributeCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedAttributeCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedAttributeCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UserDefinedLinearCharacteristicStats") == 0)
          {
            UserDefinedLinearCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<UserDefinedLinearCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedLinearCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedLinearCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedLinearCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UserDefinedAngularCharacteristicStats") == 0)
          {
            UserDefinedAngularCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<UserDefinedAngularCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedAngularCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedAngularCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedAngularCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UserDefinedAreaCharacteristicStats") == 0)
          {
            UserDefinedAreaCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<UserDefinedAreaCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedAreaCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedAreaCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedAreaCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UserDefinedForceCharacteristicStats") == 0)
          {
            UserDefinedForceCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<UserDefinedForceCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedForceCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedForceCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedForceCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UserDefinedMassCharacteristicStats") == 0)
          {
            UserDefinedMassCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<UserDefinedMassCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedMassCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedMassCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedMassCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UserDefinedPressureCharacteristicStats") == 0)
          {
            UserDefinedPressureCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<UserDefinedPressureCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedPressureCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedPressureCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedPressureCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UserDefinedSpeedCharacteristicStats") == 0)
          {
            UserDefinedSpeedCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<UserDefinedSpeedCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedSpeedCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedSpeedCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedSpeedCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UserDefinedTemperatureCharacteristicStats") == 0)
          {
            UserDefinedTemperatureCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<UserDefinedTemperatureCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedTemperatureCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedTemperatureCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedTemperatureCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UserDefinedTimeCharacteristicStats") == 0)
          {
            UserDefinedTimeCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<UserDefinedTimeCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedTimeCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedTimeCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedTimeCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UserDefinedUnitCharacteristicStats") == 0)
          {
            UserDefinedUnitCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<UserDefinedUnitCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<UserDefinedUnitCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UserDefinedUnitCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad UserDefinedUnitCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "WidthCharacteristicStats") == 0)
          {
            WidthCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<WidthCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<WidthCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WidthCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad WidthCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "WeldFilletCharacteristicStats") == 0)
          {
            WeldFilletCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<WeldFilletCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<WeldFilletCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldFilletCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldFilletCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "WeldPlugCharacteristicStats") == 0)
          {
            WeldPlugCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<WeldPlugCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<WeldPlugCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldPlugCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldPlugCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "WeldSlotCharacteristicStats") == 0)
          {
            WeldSlotCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<WeldSlotCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<WeldSlotCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldSlotCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldSlotCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "WeldSpotCharacteristicStats") == 0)
          {
            WeldSpotCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<WeldSpotCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<WeldSpotCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldSpotCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldSpotCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "WeldStudCharacteristicStats") == 0)
          {
            WeldStudCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<WeldStudCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<WeldStudCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldStudCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldStudCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "WeldSeamCharacteristicStats") == 0)
          {
            WeldSeamCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<WeldSeamCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<WeldSeamCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldSeamCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldSeamCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "WeldSurfacingCharacteristicStats") == 0)
          {
            WeldSurfacingCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<WeldSurfacingCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<WeldSurfacingCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldSurfacingCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldSurfacingCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "WeldEdgeCharacteristicStats") == 0)
          {
            WeldEdgeCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<WeldEdgeCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<WeldEdgeCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldEdgeCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldEdgeCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "WeldSquareCharacteristicStats") == 0)
          {
            WeldSquareCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<WeldSquareCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<WeldSquareCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldSquareCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldSquareCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "WeldBevelCharacteristicStats") == 0)
          {
            WeldBevelCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<WeldBevelCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<WeldBevelCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldBevelCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldBevelCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "WeldVCharacteristicStats") == 0)
          {
            WeldVCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<WeldVCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<WeldVCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldVCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldVCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "WeldUCharacteristicStats") == 0)
          {
            WeldUCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<WeldUCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<WeldUCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldUCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldUCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "WeldJCharacteristicStats") == 0)
          {
            WeldJCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<WeldJCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<WeldJCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldJCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldJCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "WeldFlareVCharacteristicStats") == 0)
          {
            WeldFlareVCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<WeldFlareVCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<WeldFlareVCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldFlareVCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldFlareVCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "WeldFlareBevelCharacteristicStats") == 0)
          {
            WeldFlareBevelCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<WeldFlareBevelCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<WeldFlareBevelCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldFlareBevelCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldFlareBevelCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "WeldScarfCharacteristicStats") == 0)
          {
            WeldScarfCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<WeldScarfCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<WeldScarfCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldScarfCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldScarfCharacteristicStats element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "WeldCompoundCharacteristicStats") == 0)
          {
            WeldCompoundCharacteristicStatsEvalType * typ;
            if ((typ = dynamic_cast<WeldCompoundCharacteristicStatsEvalType *>(basie)))
              {
                fprintf(outFile, "<WeldCompoundCharacteristicStats");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</WeldCompoundCharacteristicStats>\n");
              }
            else
              {
                fprintf(stderr, "bad WeldCompoundCharacteristicStats element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad CharacteristicStats type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool CharacteristicsStatsType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in CharacteristicsStatsType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->val.c_str());
          if (nVal->bad)
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in CharacteristicsStatsType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CharacteristicsStatsType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in CharacteristicsStatsType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * CharacteristicsStatsType::getn()
{return n;}

void CharacteristicsStatsType::setn(NaturalType * nIn)
{n = nIn;}

CharacteristicStatsEvalBaseTypeLisd * CharacteristicsStatsType::getCharacteristicStats()
{return CharacteristicStats;}

void CharacteristicsStatsType::setCharacteristicStats(CharacteristicStatsEvalBaseTypeLisd * CharacteristicStatsIn)
{CharacteristicStats = CharacteristicStatsIn;}

/* ***************************************************************** */

/* class ChordCharacteristicStatsEvalType

*/

ChordCharacteristicStatsEvalType::ChordCharacteristicStatsEvalType() :
  LinearCharacteristicStatsEvalType() {}

ChordCharacteristicStatsEvalType::ChordCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 LinearCharacteristicStatsEvalTypeChoicePair * LinearCharacteristicStatsEvalTypePairIn) :
  LinearCharacteristicStatsEvalType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    LinearCharacteristicStatsEvalTypePairIn)
{}

ChordCharacteristicStatsEvalType::~ChordCharacteristicStatsEvalType() {}

void ChordCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  LinearCharacteristicStatsEvalTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class CircularRunoutCharacteristicStatsEvalType

*/

CircularRunoutCharacteristicStatsEvalType::CircularRunoutCharacteristicStatsEvalType() :
  RunoutCharacteristicStatsEvalBaseType() {}

CircularRunoutCharacteristicStatsEvalType::CircularRunoutCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsWithTolLinearType * ValueStatsIn,
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn,
 OneSidedCapabilityCalculationEnumType * CapabilityCalculationMethodIn,
 StatsPassFailType * DatumsOkStatsIn) :
  RunoutCharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    ValueStatsIn,
    MaxValueStatsIn,
    MinValueStatsIn,
    CapabilityCalculationMethodIn,
    DatumsOkStatsIn)
{}

CircularRunoutCharacteristicStatsEvalType::~CircularRunoutCharacteristicStatsEvalType() {}

void CircularRunoutCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (ValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ValueStats");
      ValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ValueStats>\n");
    }
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  if (CapabilityCalculationMethod)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CapabilityCalculationMethod");
      CapabilityCalculationMethod->printSelf(outFile);
      fprintf(outFile, "</CapabilityCalculationMethod>\n");
    }
  if (DatumsOkStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumsOkStats");
      DatumsOkStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DatumsOkStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class CircularityCharacteristicStatsEvalType

*/

CircularityCharacteristicStatsEvalType::CircularityCharacteristicStatsEvalType() :
  FormCharacteristicStatsEvalBaseType()
{
  MaxCircularityStats = 0;
}

CircularityCharacteristicStatsEvalType::CircularityCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsWithTolLinearType * ValueStatsIn,
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn,
 OneSidedCapabilityCalculationEnumType * CapabilityCalculationMethodIn,
 StatsLinearType * MaxCircularityStatsIn) :
  FormCharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    ValueStatsIn,
    MaxValueStatsIn,
    MinValueStatsIn,
    CapabilityCalculationMethodIn)
{
  MaxCircularityStats = MaxCircularityStatsIn;
}

CircularityCharacteristicStatsEvalType::~CircularityCharacteristicStatsEvalType()
{
  #ifndef NODESTRUCT
  delete MaxCircularityStats;
  #endif
}

void CircularityCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (ValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ValueStats");
      ValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ValueStats>\n");
    }
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  if (CapabilityCalculationMethod)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CapabilityCalculationMethod");
      CapabilityCalculationMethod->printSelf(outFile);
      fprintf(outFile, "</CapabilityCalculationMethod>\n");
    }
  if (MaxCircularityStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxCircularityStats");
      MaxCircularityStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxCircularityStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

StatsLinearType * CircularityCharacteristicStatsEvalType::getMaxCircularityStats()
{return MaxCircularityStats;}

void CircularityCharacteristicStatsEvalType::setMaxCircularityStats(StatsLinearType * MaxCircularityStatsIn)
{MaxCircularityStats = MaxCircularityStatsIn;}

/* ***************************************************************** */

/* class CoaxialityCharacteristicStatsEvalType

*/

CoaxialityCharacteristicStatsEvalType::CoaxialityCharacteristicStatsEvalType() :
  LocationCharacteristicStatsEvalType()
{
  CapabilityCalculationMethod = 0;
}

CoaxialityCharacteristicStatsEvalType::CoaxialityCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsWithTolLinearType * ValueStatsIn,
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn,
 StatsPassFailType * DatumsOkStatsIn,
 OneSidedCapabilityCalculationEnumType * CapabilityCalculationMethodIn) :
  LocationCharacteristicStatsEvalType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    ValueStatsIn,
    MaxValueStatsIn,
    MinValueStatsIn,
    DatumsOkStatsIn)
{
  CapabilityCalculationMethod = CapabilityCalculationMethodIn;
}

CoaxialityCharacteristicStatsEvalType::~CoaxialityCharacteristicStatsEvalType()
{
  #ifndef NODESTRUCT
  delete CapabilityCalculationMethod;
  #endif
}

void CoaxialityCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (ValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ValueStats");
      ValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ValueStats>\n");
    }
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  if (DatumsOkStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumsOkStats");
      DatumsOkStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DatumsOkStats>\n");
    }
  if (CapabilityCalculationMethod)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CapabilityCalculationMethod");
      CapabilityCalculationMethod->printSelf(outFile);
      fprintf(outFile, "</CapabilityCalculationMethod>\n");
    }
  doSpaces(-INDENT, outFile);
}

OneSidedCapabilityCalculationEnumType * CoaxialityCharacteristicStatsEvalType::getCapabilityCalculationMethod()
{return CapabilityCalculationMethod;}

void CoaxialityCharacteristicStatsEvalType::setCapabilityCalculationMethod(OneSidedCapabilityCalculationEnumType * CapabilityCalculationMethodIn)
{CapabilityCalculationMethod = CapabilityCalculationMethodIn;}

/* ***************************************************************** */

/* class CompositeSegmentPositionStatsEvalType

*/

CompositeSegmentPositionStatsEvalType::CompositeSegmentPositionStatsEvalType() :
  CompositeSegmentStatsEvalBaseType() {}

CompositeSegmentPositionStatsEvalType::CompositeSegmentPositionStatsEvalType(
 StatsWithTolLinearType * ValueStatsIn,
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn) :
  CompositeSegmentStatsEvalBaseType(
    ValueStatsIn,
    MaxValueStatsIn,
    MinValueStatsIn)
{}

CompositeSegmentPositionStatsEvalType::~CompositeSegmentPositionStatsEvalType() {}

void CompositeSegmentPositionStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (ValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ValueStats");
      ValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ValueStats>\n");
    }
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class CompositeSegmentProfileStatsEvalType

*/

CompositeSegmentProfileStatsEvalType::CompositeSegmentProfileStatsEvalType() :
  CompositeSegmentStatsEvalBaseType() {}

CompositeSegmentProfileStatsEvalType::CompositeSegmentProfileStatsEvalType(
 StatsWithTolLinearType * ValueStatsIn,
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn) :
  CompositeSegmentStatsEvalBaseType(
    ValueStatsIn,
    MaxValueStatsIn,
    MinValueStatsIn)
{}

CompositeSegmentProfileStatsEvalType::~CompositeSegmentProfileStatsEvalType() {}

void CompositeSegmentProfileStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (ValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ValueStats");
      ValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ValueStats>\n");
    }
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class CompositeSegmentStatsEvalBaseType

*/

CompositeSegmentStatsEvalBaseType::CompositeSegmentStatsEvalBaseType()
{
  ValueStats = 0;
  MaxValueStats = 0;
  MinValueStats = 0;
}

CompositeSegmentStatsEvalBaseType::CompositeSegmentStatsEvalBaseType(
 StatsWithTolLinearType * ValueStatsIn,
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn)
{
  ValueStats = ValueStatsIn;
  MaxValueStats = MaxValueStatsIn;
  MinValueStats = MinValueStatsIn;
}

CompositeSegmentStatsEvalBaseType::~CompositeSegmentStatsEvalBaseType()
{
  #ifndef NODESTRUCT
  delete ValueStats;
  delete MaxValueStats;
  delete MinValueStats;
  #endif
}

void CompositeSegmentStatsEvalBaseType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (ValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ValueStats");
      ValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ValueStats>\n");
    }
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

StatsWithTolLinearType * CompositeSegmentStatsEvalBaseType::getValueStats()
{return ValueStats;}

void CompositeSegmentStatsEvalBaseType::setValueStats(StatsWithTolLinearType * ValueStatsIn)
{ValueStats = ValueStatsIn;}

StatsLinearType * CompositeSegmentStatsEvalBaseType::getMaxValueStats()
{return MaxValueStats;}

void CompositeSegmentStatsEvalBaseType::setMaxValueStats(StatsLinearType * MaxValueStatsIn)
{MaxValueStats = MaxValueStatsIn;}

StatsLinearType * CompositeSegmentStatsEvalBaseType::getMinValueStats()
{return MinValueStats;}

void CompositeSegmentStatsEvalBaseType::setMinValueStats(StatsLinearType * MinValueStatsIn)
{MinValueStats = MinValueStatsIn;}

/* ***************************************************************** */

/* class CompositeSegmentSymmetryStatsEvalType

*/

CompositeSegmentSymmetryStatsEvalType::CompositeSegmentSymmetryStatsEvalType() :
  CompositeSegmentStatsEvalBaseType() {}

CompositeSegmentSymmetryStatsEvalType::CompositeSegmentSymmetryStatsEvalType(
 StatsWithTolLinearType * ValueStatsIn,
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn) :
  CompositeSegmentStatsEvalBaseType(
    ValueStatsIn,
    MaxValueStatsIn,
    MinValueStatsIn)
{}

CompositeSegmentSymmetryStatsEvalType::~CompositeSegmentSymmetryStatsEvalType() {}

void CompositeSegmentSymmetryStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (ValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ValueStats");
      ValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ValueStats>\n");
    }
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class CompositeSegmentsPositionStatsEvalType

*/

CompositeSegmentsPositionStatsEvalType::CompositeSegmentsPositionStatsEvalType()
{
  SecondCompositeSegmentPositionStats = 0;
  ThirdCompositeSegmentPositionStats = 0;
  FourthCompositeSegmentPositionStats = 0;
}

CompositeSegmentsPositionStatsEvalType::CompositeSegmentsPositionStatsEvalType(
 CompositeSegmentPositionStatsEvalType * SecondCompositeSegmentPositionStatsIn,
 CompositeSegmentPositionStatsEvalType * ThirdCompositeSegmentPositionStatsIn,
 CompositeSegmentPositionStatsEvalType * FourthCompositeSegmentPositionStatsIn)
{
  SecondCompositeSegmentPositionStats = SecondCompositeSegmentPositionStatsIn;
  ThirdCompositeSegmentPositionStats = ThirdCompositeSegmentPositionStatsIn;
  FourthCompositeSegmentPositionStats = FourthCompositeSegmentPositionStatsIn;
}

CompositeSegmentsPositionStatsEvalType::~CompositeSegmentsPositionStatsEvalType()
{
  #ifndef NODESTRUCT
  delete SecondCompositeSegmentPositionStats;
  delete ThirdCompositeSegmentPositionStats;
  delete FourthCompositeSegmentPositionStats;
  #endif
}

void CompositeSegmentsPositionStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<SecondCompositeSegmentPositionStats");
  SecondCompositeSegmentPositionStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</SecondCompositeSegmentPositionStats>\n");
  if (ThirdCompositeSegmentPositionStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ThirdCompositeSegmentPositionStats");
      ThirdCompositeSegmentPositionStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ThirdCompositeSegmentPositionStats>\n");
    }
  if (FourthCompositeSegmentPositionStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FourthCompositeSegmentPositionStats");
      FourthCompositeSegmentPositionStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FourthCompositeSegmentPositionStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

CompositeSegmentPositionStatsEvalType * CompositeSegmentsPositionStatsEvalType::getSecondCompositeSegmentPositionStats()
{return SecondCompositeSegmentPositionStats;}

void CompositeSegmentsPositionStatsEvalType::setSecondCompositeSegmentPositionStats(CompositeSegmentPositionStatsEvalType * SecondCompositeSegmentPositionStatsIn)
{SecondCompositeSegmentPositionStats = SecondCompositeSegmentPositionStatsIn;}

CompositeSegmentPositionStatsEvalType * CompositeSegmentsPositionStatsEvalType::getThirdCompositeSegmentPositionStats()
{return ThirdCompositeSegmentPositionStats;}

void CompositeSegmentsPositionStatsEvalType::setThirdCompositeSegmentPositionStats(CompositeSegmentPositionStatsEvalType * ThirdCompositeSegmentPositionStatsIn)
{ThirdCompositeSegmentPositionStats = ThirdCompositeSegmentPositionStatsIn;}

CompositeSegmentPositionStatsEvalType * CompositeSegmentsPositionStatsEvalType::getFourthCompositeSegmentPositionStats()
{return FourthCompositeSegmentPositionStats;}

void CompositeSegmentsPositionStatsEvalType::setFourthCompositeSegmentPositionStats(CompositeSegmentPositionStatsEvalType * FourthCompositeSegmentPositionStatsIn)
{FourthCompositeSegmentPositionStats = FourthCompositeSegmentPositionStatsIn;}

/* ***************************************************************** */

/* class CompositeSegmentsProfileStatsEvalType

*/

CompositeSegmentsProfileStatsEvalType::CompositeSegmentsProfileStatsEvalType()
{
  SecondCompositeSegmentProfileStats = 0;
  ThirdCompositeSegmentProfileStats = 0;
  FourthCompositeSegmentProfileStats = 0;
}

CompositeSegmentsProfileStatsEvalType::CompositeSegmentsProfileStatsEvalType(
 CompositeSegmentProfileStatsEvalType * SecondCompositeSegmentProfileStatsIn,
 CompositeSegmentProfileStatsEvalType * ThirdCompositeSegmentProfileStatsIn,
 CompositeSegmentProfileStatsEvalType * FourthCompositeSegmentProfileStatsIn)
{
  SecondCompositeSegmentProfileStats = SecondCompositeSegmentProfileStatsIn;
  ThirdCompositeSegmentProfileStats = ThirdCompositeSegmentProfileStatsIn;
  FourthCompositeSegmentProfileStats = FourthCompositeSegmentProfileStatsIn;
}

CompositeSegmentsProfileStatsEvalType::~CompositeSegmentsProfileStatsEvalType()
{
  #ifndef NODESTRUCT
  delete SecondCompositeSegmentProfileStats;
  delete ThirdCompositeSegmentProfileStats;
  delete FourthCompositeSegmentProfileStats;
  #endif
}

void CompositeSegmentsProfileStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<SecondCompositeSegmentProfileStats");
  SecondCompositeSegmentProfileStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</SecondCompositeSegmentProfileStats>\n");
  if (ThirdCompositeSegmentProfileStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ThirdCompositeSegmentProfileStats");
      ThirdCompositeSegmentProfileStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ThirdCompositeSegmentProfileStats>\n");
    }
  if (FourthCompositeSegmentProfileStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FourthCompositeSegmentProfileStats");
      FourthCompositeSegmentProfileStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FourthCompositeSegmentProfileStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

CompositeSegmentProfileStatsEvalType * CompositeSegmentsProfileStatsEvalType::getSecondCompositeSegmentProfileStats()
{return SecondCompositeSegmentProfileStats;}

void CompositeSegmentsProfileStatsEvalType::setSecondCompositeSegmentProfileStats(CompositeSegmentProfileStatsEvalType * SecondCompositeSegmentProfileStatsIn)
{SecondCompositeSegmentProfileStats = SecondCompositeSegmentProfileStatsIn;}

CompositeSegmentProfileStatsEvalType * CompositeSegmentsProfileStatsEvalType::getThirdCompositeSegmentProfileStats()
{return ThirdCompositeSegmentProfileStats;}

void CompositeSegmentsProfileStatsEvalType::setThirdCompositeSegmentProfileStats(CompositeSegmentProfileStatsEvalType * ThirdCompositeSegmentProfileStatsIn)
{ThirdCompositeSegmentProfileStats = ThirdCompositeSegmentProfileStatsIn;}

CompositeSegmentProfileStatsEvalType * CompositeSegmentsProfileStatsEvalType::getFourthCompositeSegmentProfileStats()
{return FourthCompositeSegmentProfileStats;}

void CompositeSegmentsProfileStatsEvalType::setFourthCompositeSegmentProfileStats(CompositeSegmentProfileStatsEvalType * FourthCompositeSegmentProfileStatsIn)
{FourthCompositeSegmentProfileStats = FourthCompositeSegmentProfileStatsIn;}

/* ***************************************************************** */

/* class CompositeSegmentsSymmetryStatsEvalType

*/

CompositeSegmentsSymmetryStatsEvalType::CompositeSegmentsSymmetryStatsEvalType()
{
  SecondCompositeSegmentSymmetryStats = 0;
  ThirdCompositeSegmentSymmetryStats = 0;
}

CompositeSegmentsSymmetryStatsEvalType::CompositeSegmentsSymmetryStatsEvalType(
 CompositeSegmentSymmetryStatsEvalType * SecondCompositeSegmentSymmetryStatsIn,
 CompositeSegmentSymmetryStatsEvalType * ThirdCompositeSegmentSymmetryStatsIn)
{
  SecondCompositeSegmentSymmetryStats = SecondCompositeSegmentSymmetryStatsIn;
  ThirdCompositeSegmentSymmetryStats = ThirdCompositeSegmentSymmetryStatsIn;
}

CompositeSegmentsSymmetryStatsEvalType::~CompositeSegmentsSymmetryStatsEvalType()
{
  #ifndef NODESTRUCT
  delete SecondCompositeSegmentSymmetryStats;
  delete ThirdCompositeSegmentSymmetryStats;
  #endif
}

void CompositeSegmentsSymmetryStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<SecondCompositeSegmentSymmetryStats");
  SecondCompositeSegmentSymmetryStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</SecondCompositeSegmentSymmetryStats>\n");
  if (ThirdCompositeSegmentSymmetryStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ThirdCompositeSegmentSymmetryStats");
      ThirdCompositeSegmentSymmetryStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ThirdCompositeSegmentSymmetryStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

CompositeSegmentSymmetryStatsEvalType * CompositeSegmentsSymmetryStatsEvalType::getSecondCompositeSegmentSymmetryStats()
{return SecondCompositeSegmentSymmetryStats;}

void CompositeSegmentsSymmetryStatsEvalType::setSecondCompositeSegmentSymmetryStats(CompositeSegmentSymmetryStatsEvalType * SecondCompositeSegmentSymmetryStatsIn)
{SecondCompositeSegmentSymmetryStats = SecondCompositeSegmentSymmetryStatsIn;}

CompositeSegmentSymmetryStatsEvalType * CompositeSegmentsSymmetryStatsEvalType::getThirdCompositeSegmentSymmetryStats()
{return ThirdCompositeSegmentSymmetryStats;}

void CompositeSegmentsSymmetryStatsEvalType::setThirdCompositeSegmentSymmetryStats(CompositeSegmentSymmetryStatsEvalType * ThirdCompositeSegmentSymmetryStatsIn)
{ThirdCompositeSegmentSymmetryStats = ThirdCompositeSegmentSymmetryStatsIn;}

/* ***************************************************************** */

/* class ConcentricityCharacteristicStatsEvalType

*/

ConcentricityCharacteristicStatsEvalType::ConcentricityCharacteristicStatsEvalType() :
  LocationCharacteristicStatsEvalType()
{
  CapabilityCalculationMethod = 0;
}

ConcentricityCharacteristicStatsEvalType::ConcentricityCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsWithTolLinearType * ValueStatsIn,
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn,
 StatsPassFailType * DatumsOkStatsIn,
 OneSidedCapabilityCalculationEnumType * CapabilityCalculationMethodIn) :
  LocationCharacteristicStatsEvalType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    ValueStatsIn,
    MaxValueStatsIn,
    MinValueStatsIn,
    DatumsOkStatsIn)
{
  CapabilityCalculationMethod = CapabilityCalculationMethodIn;
}

ConcentricityCharacteristicStatsEvalType::~ConcentricityCharacteristicStatsEvalType()
{
  #ifndef NODESTRUCT
  delete CapabilityCalculationMethod;
  #endif
}

void ConcentricityCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (ValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ValueStats");
      ValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ValueStats>\n");
    }
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  if (DatumsOkStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumsOkStats");
      DatumsOkStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DatumsOkStats>\n");
    }
  if (CapabilityCalculationMethod)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CapabilityCalculationMethod");
      CapabilityCalculationMethod->printSelf(outFile);
      fprintf(outFile, "</CapabilityCalculationMethod>\n");
    }
  doSpaces(-INDENT, outFile);
}

OneSidedCapabilityCalculationEnumType * ConcentricityCharacteristicStatsEvalType::getCapabilityCalculationMethod()
{return CapabilityCalculationMethod;}

void ConcentricityCharacteristicStatsEvalType::setCapabilityCalculationMethod(OneSidedCapabilityCalculationEnumType * CapabilityCalculationMethodIn)
{CapabilityCalculationMethod = CapabilityCalculationMethodIn;}

/* ***************************************************************** */

/* class ConicalTaperCharacteristicStatsEvalType

*/

ConicalTaperCharacteristicStatsEvalType::ConicalTaperCharacteristicStatsEvalType() :
  LinearCharacteristicStatsEvalType() {}

ConicalTaperCharacteristicStatsEvalType::ConicalTaperCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 LinearCharacteristicStatsEvalTypeChoicePair * LinearCharacteristicStatsEvalTypePairIn) :
  LinearCharacteristicStatsEvalType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    LinearCharacteristicStatsEvalTypePairIn)
{}

ConicalTaperCharacteristicStatsEvalType::~ConicalTaperCharacteristicStatsEvalType() {}

void ConicalTaperCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  LinearCharacteristicStatsEvalTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class ConicityCharacteristicStatsEvalType

*/

ConicityCharacteristicStatsEvalType::ConicityCharacteristicStatsEvalType() :
  FormCharacteristicStatsEvalBaseType() {}

ConicityCharacteristicStatsEvalType::ConicityCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsWithTolLinearType * ValueStatsIn,
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn,
 OneSidedCapabilityCalculationEnumType * CapabilityCalculationMethodIn) :
  FormCharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    ValueStatsIn,
    MaxValueStatsIn,
    MinValueStatsIn,
    CapabilityCalculationMethodIn)
{}

ConicityCharacteristicStatsEvalType::~ConicityCharacteristicStatsEvalType() {}

void ConicityCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (ValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ValueStats");
      ValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ValueStats>\n");
    }
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  if (CapabilityCalculationMethod)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CapabilityCalculationMethod");
      CapabilityCalculationMethod->printSelf(outFile);
      fprintf(outFile, "</CapabilityCalculationMethod>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class ControlIssueDetailsListType

*/

ControlIssueDetailsListType::ControlIssueDetailsListType()
{
  n = 0;
  ControlIssueDetails = 0;
}

ControlIssueDetailsListType::ControlIssueDetailsListType(
 ControlIssueDetailsTypeLisd * ControlIssueDetailsIn)
{
  n = 0;
  ControlIssueDetails = ControlIssueDetailsIn;
}

ControlIssueDetailsListType::ControlIssueDetailsListType(
 NaturalType * nIn,
 ControlIssueDetailsTypeLisd * ControlIssueDetailsIn)
{
  n = nIn;
  ControlIssueDetails = ControlIssueDetailsIn;
}

ControlIssueDetailsListType::~ControlIssueDetailsListType()
{
  #ifndef NODESTRUCT
  delete n;
  delete ControlIssueDetails;
  #endif
}

void ControlIssueDetailsListType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!ControlIssueDetails)
      {
        fprintf(stderr, "ControlIssueDetails list is missing\n");
        exit(1);
      }
    if (ControlIssueDetails->size() == 0)
      {
        fprintf(stderr, "ControlIssueDetails list is empty\n");
        exit(1);
      }
    if (ControlIssueDetails->size() < 1)
      {
        fprintf(stderr,
                "size of ControlIssueDetails list (%d) less than minimum required (1)\n",
                (int)ControlIssueDetails->size());
        exit(1);
      }
    std::list<ControlIssueDetailsType *>::iterator iter;
    for (iter = ControlIssueDetails->begin();
         iter != ControlIssueDetails->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<ControlIssueDetails");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</ControlIssueDetails>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool ControlIssueDetailsListType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in ControlIssueDetailsListType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->val.c_str());
          if (nVal->bad)
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in ControlIssueDetailsListType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ControlIssueDetailsListType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in ControlIssueDetailsListType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * ControlIssueDetailsListType::getn()
{return n;}

void ControlIssueDetailsListType::setn(NaturalType * nIn)
{n = nIn;}

ControlIssueDetailsTypeLisd * ControlIssueDetailsListType::getControlIssueDetails()
{return ControlIssueDetails;}

void ControlIssueDetailsListType::setControlIssueDetails(ControlIssueDetailsTypeLisd * ControlIssueDetailsIn)
{ControlIssueDetails = ControlIssueDetailsIn;}

/* ***************************************************************** */

/* class ControlIssueDetailsListTypeLisd

*/

ControlIssueDetailsListTypeLisd::ControlIssueDetailsListTypeLisd() {}

ControlIssueDetailsListTypeLisd::ControlIssueDetailsListTypeLisd(ControlIssueDetailsListType * aControlIssueDetailsListType)
{
  push_back(aControlIssueDetailsListType);
}

ControlIssueDetailsListTypeLisd::~ControlIssueDetailsListTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<ControlIssueDetailsListType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void ControlIssueDetailsListTypeLisd::printSelf(FILE * outFile)
{
  std::list<ControlIssueDetailsListType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class ControlIssueDetailsType

*/

ControlIssueDetailsType::ControlIssueDetailsType()
{
  ControlIssue = 0;
  ControlMethodId = 0;
  StudyIssueId = 0;
}

ControlIssueDetailsType::ControlIssueDetailsType(
 ControlIssueType * ControlIssueIn,
 QIFReferenceType * ControlMethodIdIn,
 QIFReferenceType * StudyIssueIdIn)
{
  ControlIssue = ControlIssueIn;
  ControlMethodId = ControlMethodIdIn;
  StudyIssueId = StudyIssueIdIn;
}

ControlIssueDetailsType::~ControlIssueDetailsType()
{
  #ifndef NODESTRUCT
  delete ControlIssue;
  delete ControlMethodId;
  delete StudyIssueId;
  #endif
}

void ControlIssueDetailsType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<ControlIssue");
  ControlIssue->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ControlIssue>\n");
  if (ControlMethodId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ControlMethodId");
      ControlMethodId->printSelf(outFile);
      fprintf(outFile, "</ControlMethodId>\n");
    }
  if (StudyIssueId)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssueId");
      StudyIssueId->printSelf(outFile);
      fprintf(outFile, "</StudyIssueId>\n");
    }
  doSpaces(-INDENT, outFile);
}

ControlIssueType * ControlIssueDetailsType::getControlIssue()
{return ControlIssue;}

void ControlIssueDetailsType::setControlIssue(ControlIssueType * ControlIssueIn)
{ControlIssue = ControlIssueIn;}

QIFReferenceType * ControlIssueDetailsType::getControlMethodId()
{return ControlMethodId;}

void ControlIssueDetailsType::setControlMethodId(QIFReferenceType * ControlMethodIdIn)
{ControlMethodId = ControlMethodIdIn;}

QIFReferenceType * ControlIssueDetailsType::getStudyIssueId()
{return StudyIssueId;}

void ControlIssueDetailsType::setStudyIssueId(QIFReferenceType * StudyIssueIdIn)
{StudyIssueId = StudyIssueIdIn;}

/* ***************************************************************** */

/* class ControlIssueDetailsTypeLisd

*/

ControlIssueDetailsTypeLisd::ControlIssueDetailsTypeLisd() {}

ControlIssueDetailsTypeLisd::ControlIssueDetailsTypeLisd(ControlIssueDetailsType * aControlIssueDetailsType)
{
  push_back(aControlIssueDetailsType);
}

ControlIssueDetailsTypeLisd::~ControlIssueDetailsTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<ControlIssueDetailsType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void ControlIssueDetailsTypeLisd::printSelf(FILE * outFile)
{
  std::list<ControlIssueDetailsType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class ControlIssueEnumType

*/

ControlIssueEnumType::ControlIssueEnumType() :
  XmlNMTOKEN()
{
}

ControlIssueEnumType::ControlIssueEnumType(
 const char * valIn) :
  XmlNMTOKEN(
    valIn)
{
  if (!bad)
    bad = (strcmp(val.c_str(), "OOT") &&
           strcmp(val.c_str(), "CP") &&
           strcmp(val.c_str(), "CPK") &&
           strcmp(val.c_str(), "PP") &&
           strcmp(val.c_str(), "PPK") &&
           strcmp(val.c_str(), "OOC") &&
           strcmp(val.c_str(), "TRENDING") &&
           strcmp(val.c_str(), "SKEWED") &&
           strcmp(val.c_str(), "ONETHIRDGROUPED") &&
           strcmp(val.c_str(), "TWOTHIRDGROUPED") &&
           strcmp(val.c_str(), "OSCILLATING") &&
           strcmp(val.c_str(), "STRATIFIED") &&
           strcmp(val.c_str(), "OOCRNG") &&
           strcmp(val.c_str(), "UNDEFINED"));
}

ControlIssueEnumType::~ControlIssueEnumType() {}

bool ControlIssueEnumType::ControlIssueEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "OOT") &&
          strcmp(val.c_str(), "CP") &&
          strcmp(val.c_str(), "CPK") &&
          strcmp(val.c_str(), "PP") &&
          strcmp(val.c_str(), "PPK") &&
          strcmp(val.c_str(), "OOC") &&
          strcmp(val.c_str(), "TRENDING") &&
          strcmp(val.c_str(), "SKEWED") &&
          strcmp(val.c_str(), "ONETHIRDGROUPED") &&
          strcmp(val.c_str(), "TWOTHIRDGROUPED") &&
          strcmp(val.c_str(), "OSCILLATING") &&
          strcmp(val.c_str(), "STRATIFIED") &&
          strcmp(val.c_str(), "OOCRNG") &&
          strcmp(val.c_str(), "UNDEFINED"));
}

void ControlIssueEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "ControlIssueEnumType");
}

void ControlIssueEnumType::printSelf(FILE * outFile)
{
  if (ControlIssueEnumTypeIsBad())
    {
      fprintf(stderr, "bad ControlIssueEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::printSelf(outFile);
}

void ControlIssueEnumType::oPrintSelf(FILE * outFile)
{
  if (ControlIssueEnumTypeIsBad())
    {
      fprintf(stderr, "bad ControlIssueEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class ControlIssueType

*/

ControlIssueType::ControlIssueType()
{
  ControlIssueTypePair = 0;
}

ControlIssueType::ControlIssueType(
 ControlIssueTypeChoicePair * ControlIssueTypePairIn)
{
  ControlIssueTypePair = ControlIssueTypePairIn;
}

ControlIssueType::~ControlIssueType()
{
  #ifndef NODESTRUCT
  delete ControlIssueTypePair;
  #endif
}

void ControlIssueType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  ControlIssueTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

ControlIssueTypeChoicePair * ControlIssueType::getControlIssueTypePair()
{return ControlIssueTypePair;}

void ControlIssueType::setControlIssueTypePair(ControlIssueTypeChoicePair * ControlIssueTypePairIn)
{ControlIssueTypePair = ControlIssueTypePairIn;}
ControlIssueTypeChoicePair::ControlIssueTypeChoicePair() {}

ControlIssueTypeChoicePair::ControlIssueTypeChoicePair(
 whichOne ControlIssueTypeTypeIn,
 ControlIssueTypeVal ControlIssueTypeValueIn)
{
  ControlIssueTypeType = ControlIssueTypeTypeIn;
  ControlIssueTypeValue = ControlIssueTypeValueIn;
}

ControlIssueTypeChoicePair::~ControlIssueTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (ControlIssueTypeType == ControlIssueEnumE)
    delete ControlIssueTypeValue.ControlIssueEnum;
  else if (ControlIssueTypeType == OtherControlIssueE)
    delete ControlIssueTypeValue.OtherControlIssue;
  #endif
}

void ControlIssueTypeChoicePair::printSelf(FILE * outFile)
{
  if (ControlIssueTypeType == ControlIssueEnumE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ControlIssueEnum");
      ControlIssueTypeValue.ControlIssueEnum->printSelf(outFile);
      fprintf(outFile, "</ControlIssueEnum>\n");
    }
  else if (ControlIssueTypeType == OtherControlIssueE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OtherControlIssue");
      ControlIssueTypeValue.OtherControlIssue->printSelf(outFile);
      fprintf(outFile, "</OtherControlIssue>\n");
    }
}

/* ***************************************************************** */

/* class CorrectiveActionType

*/

CorrectiveActionType::CorrectiveActionType()
{
  id = 0;
  Attributes = 0;
  CorrectiveActio_1107 = 0;
}

CorrectiveActionType::CorrectiveActionType(
 AttributesType * AttributesIn,
 CorrectiveActio_1107_Type * CorrectiveActio_1107In)
{
  id = 0;
  Attributes = AttributesIn;
  CorrectiveActio_1107 = CorrectiveActio_1107In;
}

CorrectiveActionType::CorrectiveActionType(
 QIFIdType * idIn,
 AttributesType * AttributesIn,
 CorrectiveActio_1107_Type * CorrectiveActio_1107In)
{
  id = idIn;
  Attributes = AttributesIn;
  CorrectiveActio_1107 = CorrectiveActio_1107In;
}

CorrectiveActionType::~CorrectiveActionType()
{
  #ifndef NODESTRUCT
  delete id;
  delete Attributes;
  delete CorrectiveActio_1107;
  #endif
}

void CorrectiveActionType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  CorrectiveActio_1107->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

bool CorrectiveActionType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in CorrectiveActionType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->val.c_str());
          if (idVal->bad)
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in CorrectiveActionType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CorrectiveActionType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id == 0)
    {
      fprintf(stderr, "required attribute \"id\" missing in CorrectiveActionType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

QIFIdType * CorrectiveActionType::getid()
{return id;}

void CorrectiveActionType::setid(QIFIdType * idIn)
{id = idIn;}

AttributesType * CorrectiveActionType::getAttributes()
{return Attributes;}

void CorrectiveActionType::setAttributes(AttributesType * AttributesIn)
{Attributes = AttributesIn;}

CorrectiveActio_1107_Type * CorrectiveActionType::getCorrectiveActio_1107()
{return CorrectiveActio_1107;}

void CorrectiveActionType::setCorrectiveActio_1107(CorrectiveActio_1107_Type * CorrectiveActio_1107In)
{CorrectiveActio_1107 = CorrectiveActio_1107In;}

/* ***************************************************************** */

/* class CorrectiveActionTypeLisd

*/

CorrectiveActionTypeLisd::CorrectiveActionTypeLisd() {}

CorrectiveActionTypeLisd::CorrectiveActionTypeLisd(CorrectiveActionType * aCorrectiveActionType)
{
  push_back(aCorrectiveActionType);
}

CorrectiveActionTypeLisd::~CorrectiveActionTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<CorrectiveActionType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void CorrectiveActionTypeLisd::printSelf(FILE * outFile)
{
  std::list<CorrectiveActionType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class CorrectiveActionsType

*/

CorrectiveActionsType::CorrectiveActionsType()
{
  n = 0;
  CorrectiveAction = 0;
}

CorrectiveActionsType::CorrectiveActionsType(
 CorrectiveActionTypeLisd * CorrectiveActionIn)
{
  n = 0;
  CorrectiveAction = CorrectiveActionIn;
}

CorrectiveActionsType::CorrectiveActionsType(
 NaturalType * nIn,
 CorrectiveActionTypeLisd * CorrectiveActionIn)
{
  n = nIn;
  CorrectiveAction = CorrectiveActionIn;
}

CorrectiveActionsType::~CorrectiveActionsType()
{
  #ifndef NODESTRUCT
  delete n;
  delete CorrectiveAction;
  #endif
}

void CorrectiveActionsType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!CorrectiveAction)
      {
        fprintf(stderr, "CorrectiveAction list is missing\n");
        exit(1);
      }
    if (CorrectiveAction->size() == 0)
      {
        fprintf(stderr, "CorrectiveAction list is empty\n");
        exit(1);
      }
    if (CorrectiveAction->size() < 1)
      {
        fprintf(stderr,
                "size of CorrectiveAction list (%d) less than minimum required (1)\n",
                (int)CorrectiveAction->size());
        exit(1);
      }
    std::list<CorrectiveActionType *>::iterator iter;
    for (iter = CorrectiveAction->begin();
         iter != CorrectiveAction->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<CorrectiveAction");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</CorrectiveAction>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool CorrectiveActionsType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in CorrectiveActionsType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->val.c_str());
          if (nVal->bad)
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in CorrectiveActionsType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CorrectiveActionsType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in CorrectiveActionsType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * CorrectiveActionsType::getn()
{return n;}

void CorrectiveActionsType::setn(NaturalType * nIn)
{n = nIn;}

CorrectiveActionTypeLisd * CorrectiveActionsType::getCorrectiveAction()
{return CorrectiveAction;}

void CorrectiveActionsType::setCorrectiveAction(CorrectiveActionTypeLisd * CorrectiveActionIn)
{CorrectiveAction = CorrectiveActionIn;}

/* ***************************************************************** */

/* class CriterionAngularType

*/

CriterionAngularType::CriterionAngularType() :
  CriterionDecimalType()
{
  angularUnit = 0;
}

CriterionAngularType::CriterionAngularType(
 XmlDecimal * LimitIn,
 CriterionDecima_1108_Type * CriterionDecima_1108In) :
  CriterionDecimalType(
    LimitIn,
    CriterionDecima_1108In)
{
  angularUnit = 0;
}

CriterionAngularType::CriterionAngularType(
 XmlDecimal * LimitIn,
 CriterionDecima_1108_Type * CriterionDecima_1108In,
 XmlToken * angularUnitIn) :
  CriterionDecimalType(
    LimitIn,
    CriterionDecima_1108In)
{
  angularUnit = angularUnitIn;
}

CriterionAngularType::~CriterionAngularType()
{
  #ifndef NODESTRUCT
  delete angularUnit;
  #endif
}

void CriterionAngularType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (angularUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "angularUnit=\"");
      angularUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Limit");
  Limit->printSelf(outFile);
  fprintf(outFile, "</Limit>\n");
  if (CriterionDecima_1108)
    {
      CriterionDecima_1108->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool CriterionAngularType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "angularUnit")
        {
          XmlToken * angularUnitVal;
          if (this->angularUnit)
            {
              fprintf(stderr, "two values for angularUnit in CriterionAngularType\n");
              returnValue = true;
              break;
            }
          angularUnitVal = new XmlToken(decl->val.c_str());
          if (angularUnitVal->bad)
            {
              delete angularUnitVal;
              fprintf(stderr, "bad value %s for angularUnit in CriterionAngularType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->angularUnit = angularUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CriterionAngularType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->angularUnit;
      this->angularUnit = 0;
    }
  return returnValue;
}

XmlToken * CriterionAngularType::getangularUnit()
{return angularUnit;}

void CriterionAngularType::setangularUnit(XmlToken * angularUnitIn)
{angularUnit = angularUnitIn;}

/* ***************************************************************** */

/* class CriterionAreaType

*/

CriterionAreaType::CriterionAreaType() :
  CriterionDecimalType()
{
  areaUnit = 0;
}

CriterionAreaType::CriterionAreaType(
 XmlDecimal * LimitIn,
 CriterionDecima_1108_Type * CriterionDecima_1108In) :
  CriterionDecimalType(
    LimitIn,
    CriterionDecima_1108In)
{
  areaUnit = 0;
}

CriterionAreaType::CriterionAreaType(
 XmlDecimal * LimitIn,
 CriterionDecima_1108_Type * CriterionDecima_1108In,
 XmlToken * areaUnitIn) :
  CriterionDecimalType(
    LimitIn,
    CriterionDecima_1108In)
{
  areaUnit = areaUnitIn;
}

CriterionAreaType::~CriterionAreaType()
{
  #ifndef NODESTRUCT
  delete areaUnit;
  #endif
}

void CriterionAreaType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (areaUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "areaUnit=\"");
      areaUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Limit");
  Limit->printSelf(outFile);
  fprintf(outFile, "</Limit>\n");
  if (CriterionDecima_1108)
    {
      CriterionDecima_1108->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool CriterionAreaType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "areaUnit")
        {
          XmlToken * areaUnitVal;
          if (this->areaUnit)
            {
              fprintf(stderr, "two values for areaUnit in CriterionAreaType\n");
              returnValue = true;
              break;
            }
          areaUnitVal = new XmlToken(decl->val.c_str());
          if (areaUnitVal->bad)
            {
              delete areaUnitVal;
              fprintf(stderr, "bad value %s for areaUnit in CriterionAreaType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->areaUnit = areaUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CriterionAreaType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->areaUnit;
      this->areaUnit = 0;
    }
  return returnValue;
}

XmlToken * CriterionAreaType::getareaUnit()
{return areaUnit;}

void CriterionAreaType::setareaUnit(XmlToken * areaUnitIn)
{areaUnit = areaUnitIn;}

/* ***************************************************************** */

/* class CriterionDecimalType

*/

CriterionDecimalType::CriterionDecimalType()
{
  Limit = 0;
  CriterionDecima_1108 = 0;
}

CriterionDecimalType::CriterionDecimalType(
 XmlDecimal * LimitIn,
 CriterionDecima_1108_Type * CriterionDecima_1108In)
{
  Limit = LimitIn;
  CriterionDecima_1108 = CriterionDecima_1108In;
}

CriterionDecimalType::~CriterionDecimalType()
{
  #ifndef NODESTRUCT
  delete Limit;
  delete CriterionDecima_1108;
  #endif
}

void CriterionDecimalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Limit");
  Limit->printSelf(outFile);
  fprintf(outFile, "</Limit>\n");
  if (CriterionDecima_1108)
    {
      CriterionDecima_1108->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

XmlDecimal * CriterionDecimalType::getLimit()
{return Limit;}

void CriterionDecimalType::setLimit(XmlDecimal * LimitIn)
{Limit = LimitIn;}

CriterionDecima_1108_Type * CriterionDecimalType::getCriterionDecima_1108()
{return CriterionDecima_1108;}

void CriterionDecimalType::setCriterionDecima_1108(CriterionDecima_1108_Type * CriterionDecima_1108In)
{CriterionDecima_1108 = CriterionDecima_1108In;}

/* ***************************************************************** */

/* class CriterionForceType

*/

CriterionForceType::CriterionForceType() :
  CriterionDecimalType()
{
  forceUnit = 0;
}

CriterionForceType::CriterionForceType(
 XmlDecimal * LimitIn,
 CriterionDecima_1108_Type * CriterionDecima_1108In) :
  CriterionDecimalType(
    LimitIn,
    CriterionDecima_1108In)
{
  forceUnit = 0;
}

CriterionForceType::CriterionForceType(
 XmlDecimal * LimitIn,
 CriterionDecima_1108_Type * CriterionDecima_1108In,
 XmlToken * forceUnitIn) :
  CriterionDecimalType(
    LimitIn,
    CriterionDecima_1108In)
{
  forceUnit = forceUnitIn;
}

CriterionForceType::~CriterionForceType()
{
  #ifndef NODESTRUCT
  delete forceUnit;
  #endif
}

void CriterionForceType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (forceUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "forceUnit=\"");
      forceUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Limit");
  Limit->printSelf(outFile);
  fprintf(outFile, "</Limit>\n");
  if (CriterionDecima_1108)
    {
      CriterionDecima_1108->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool CriterionForceType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "forceUnit")
        {
          XmlToken * forceUnitVal;
          if (this->forceUnit)
            {
              fprintf(stderr, "two values for forceUnit in CriterionForceType\n");
              returnValue = true;
              break;
            }
          forceUnitVal = new XmlToken(decl->val.c_str());
          if (forceUnitVal->bad)
            {
              delete forceUnitVal;
              fprintf(stderr, "bad value %s for forceUnit in CriterionForceType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->forceUnit = forceUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CriterionForceType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->forceUnit;
      this->forceUnit = 0;
    }
  return returnValue;
}

XmlToken * CriterionForceType::getforceUnit()
{return forceUnit;}

void CriterionForceType::setforceUnit(XmlToken * forceUnitIn)
{forceUnit = forceUnitIn;}

/* ***************************************************************** */

/* class CriterionIntegerType

*/

CriterionIntegerType::CriterionIntegerType()
{
  Limit = 0;
  CriterionIntege_1109 = 0;
}

CriterionIntegerType::CriterionIntegerType(
 XmlPositiveInteger * LimitIn,
 CriterionIntege_1109_Type * CriterionIntege_1109In)
{
  Limit = LimitIn;
  CriterionIntege_1109 = CriterionIntege_1109In;
}

CriterionIntegerType::~CriterionIntegerType()
{
  #ifndef NODESTRUCT
  delete Limit;
  delete CriterionIntege_1109;
  #endif
}

void CriterionIntegerType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Limit");
  Limit->printSelf(outFile);
  fprintf(outFile, "</Limit>\n");
  if (CriterionIntege_1109)
    {
      CriterionIntege_1109->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

XmlPositiveInteger * CriterionIntegerType::getLimit()
{return Limit;}

void CriterionIntegerType::setLimit(XmlPositiveInteger * LimitIn)
{Limit = LimitIn;}

CriterionIntege_1109_Type * CriterionIntegerType::getCriterionIntege_1109()
{return CriterionIntege_1109;}

void CriterionIntegerType::setCriterionIntege_1109(CriterionIntege_1109_Type * CriterionIntege_1109In)
{CriterionIntege_1109 = CriterionIntege_1109In;}

/* ***************************************************************** */

/* class CriterionLinearType

*/

CriterionLinearType::CriterionLinearType() :
  CriterionDecimalType()
{
  linearUnit = 0;
}

CriterionLinearType::CriterionLinearType(
 XmlDecimal * LimitIn,
 CriterionDecima_1108_Type * CriterionDecima_1108In) :
  CriterionDecimalType(
    LimitIn,
    CriterionDecima_1108In)
{
  linearUnit = 0;
}

CriterionLinearType::CriterionLinearType(
 XmlDecimal * LimitIn,
 CriterionDecima_1108_Type * CriterionDecima_1108In,
 XmlToken * linearUnitIn) :
  CriterionDecimalType(
    LimitIn,
    CriterionDecima_1108In)
{
  linearUnit = linearUnitIn;
}

CriterionLinearType::~CriterionLinearType()
{
  #ifndef NODESTRUCT
  delete linearUnit;
  #endif
}

void CriterionLinearType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (linearUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "linearUnit=\"");
      linearUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Limit");
  Limit->printSelf(outFile);
  fprintf(outFile, "</Limit>\n");
  if (CriterionDecima_1108)
    {
      CriterionDecima_1108->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool CriterionLinearType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "linearUnit")
        {
          XmlToken * linearUnitVal;
          if (this->linearUnit)
            {
              fprintf(stderr, "two values for linearUnit in CriterionLinearType\n");
              returnValue = true;
              break;
            }
          linearUnitVal = new XmlToken(decl->val.c_str());
          if (linearUnitVal->bad)
            {
              delete linearUnitVal;
              fprintf(stderr, "bad value %s for linearUnit in CriterionLinearType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->linearUnit = linearUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CriterionLinearType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->linearUnit;
      this->linearUnit = 0;
    }
  return returnValue;
}

XmlToken * CriterionLinearType::getlinearUnit()
{return linearUnit;}

void CriterionLinearType::setlinearUnit(XmlToken * linearUnitIn)
{linearUnit = linearUnitIn;}

/* ***************************************************************** */

/* class CriterionMassType

*/

CriterionMassType::CriterionMassType() :
  CriterionDecimalType()
{
  massUnit = 0;
}

CriterionMassType::CriterionMassType(
 XmlDecimal * LimitIn,
 CriterionDecima_1108_Type * CriterionDecima_1108In) :
  CriterionDecimalType(
    LimitIn,
    CriterionDecima_1108In)
{
  massUnit = 0;
}

CriterionMassType::CriterionMassType(
 XmlDecimal * LimitIn,
 CriterionDecima_1108_Type * CriterionDecima_1108In,
 XmlToken * massUnitIn) :
  CriterionDecimalType(
    LimitIn,
    CriterionDecima_1108In)
{
  massUnit = massUnitIn;
}

CriterionMassType::~CriterionMassType()
{
  #ifndef NODESTRUCT
  delete massUnit;
  #endif
}

void CriterionMassType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (massUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "massUnit=\"");
      massUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Limit");
  Limit->printSelf(outFile);
  fprintf(outFile, "</Limit>\n");
  if (CriterionDecima_1108)
    {
      CriterionDecima_1108->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool CriterionMassType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "massUnit")
        {
          XmlToken * massUnitVal;
          if (this->massUnit)
            {
              fprintf(stderr, "two values for massUnit in CriterionMassType\n");
              returnValue = true;
              break;
            }
          massUnitVal = new XmlToken(decl->val.c_str());
          if (massUnitVal->bad)
            {
              delete massUnitVal;
              fprintf(stderr, "bad value %s for massUnit in CriterionMassType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->massUnit = massUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CriterionMassType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->massUnit;
      this->massUnit = 0;
    }
  return returnValue;
}

XmlToken * CriterionMassType::getmassUnit()
{return massUnit;}

void CriterionMassType::setmassUnit(XmlToken * massUnitIn)
{massUnit = massUnitIn;}

/* ***************************************************************** */

/* class CriterionOutOfType

*/

CriterionOutOfType::CriterionOutOfType()
{
  Numerator = 0;
  Denominator = 0;
  NumberAllowedExceptions = 0;
}

CriterionOutOfType::CriterionOutOfType(
 XmlPositiveInteger * NumeratorIn,
 XmlPositiveInteger * DenominatorIn,
 LimitingNumberType * NumberAllowedExceptionsIn)
{
  Numerator = NumeratorIn;
  Denominator = DenominatorIn;
  NumberAllowedExceptions = NumberAllowedExceptionsIn;
}

CriterionOutOfType::~CriterionOutOfType()
{
  #ifndef NODESTRUCT
  delete Numerator;
  delete Denominator;
  delete NumberAllowedExceptions;
  #endif
}

void CriterionOutOfType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Numerator");
  Numerator->printSelf(outFile);
  fprintf(outFile, "</Numerator>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Denominator");
  Denominator->printSelf(outFile);
  fprintf(outFile, "</Denominator>\n");
  if (NumberAllowedExceptions)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<NumberAllowedExceptions");
      NumberAllowedExceptions->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</NumberAllowedExceptions>\n");
    }
  doSpaces(-INDENT, outFile);
}

XmlPositiveInteger * CriterionOutOfType::getNumerator()
{return Numerator;}

void CriterionOutOfType::setNumerator(XmlPositiveInteger * NumeratorIn)
{Numerator = NumeratorIn;}

XmlPositiveInteger * CriterionOutOfType::getDenominator()
{return Denominator;}

void CriterionOutOfType::setDenominator(XmlPositiveInteger * DenominatorIn)
{Denominator = DenominatorIn;}

LimitingNumberType * CriterionOutOfType::getNumberAllowedExceptions()
{return NumberAllowedExceptions;}

void CriterionOutOfType::setNumberAllowedExceptions(LimitingNumberType * NumberAllowedExceptionsIn)
{NumberAllowedExceptions = NumberAllowedExceptionsIn;}

/* ***************************************************************** */

/* class CriterionPressureType

*/

CriterionPressureType::CriterionPressureType() :
  CriterionDecimalType()
{
  pressureUnit = 0;
}

CriterionPressureType::CriterionPressureType(
 XmlDecimal * LimitIn,
 CriterionDecima_1108_Type * CriterionDecima_1108In) :
  CriterionDecimalType(
    LimitIn,
    CriterionDecima_1108In)
{
  pressureUnit = 0;
}

CriterionPressureType::CriterionPressureType(
 XmlDecimal * LimitIn,
 CriterionDecima_1108_Type * CriterionDecima_1108In,
 XmlToken * pressureUnitIn) :
  CriterionDecimalType(
    LimitIn,
    CriterionDecima_1108In)
{
  pressureUnit = pressureUnitIn;
}

CriterionPressureType::~CriterionPressureType()
{
  #ifndef NODESTRUCT
  delete pressureUnit;
  #endif
}

void CriterionPressureType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (pressureUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "pressureUnit=\"");
      pressureUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Limit");
  Limit->printSelf(outFile);
  fprintf(outFile, "</Limit>\n");
  if (CriterionDecima_1108)
    {
      CriterionDecima_1108->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool CriterionPressureType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "pressureUnit")
        {
          XmlToken * pressureUnitVal;
          if (this->pressureUnit)
            {
              fprintf(stderr, "two values for pressureUnit in CriterionPressureType\n");
              returnValue = true;
              break;
            }
          pressureUnitVal = new XmlToken(decl->val.c_str());
          if (pressureUnitVal->bad)
            {
              delete pressureUnitVal;
              fprintf(stderr, "bad value %s for pressureUnit in CriterionPressureType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->pressureUnit = pressureUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CriterionPressureType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->pressureUnit;
      this->pressureUnit = 0;
    }
  return returnValue;
}

XmlToken * CriterionPressureType::getpressureUnit()
{return pressureUnit;}

void CriterionPressureType::setpressureUnit(XmlToken * pressureUnitIn)
{pressureUnit = pressureUnitIn;}

/* ***************************************************************** */

/* class CriterionSpeedType

*/

CriterionSpeedType::CriterionSpeedType() :
  CriterionDecimalType()
{
  speedUnit = 0;
}

CriterionSpeedType::CriterionSpeedType(
 XmlDecimal * LimitIn,
 CriterionDecima_1108_Type * CriterionDecima_1108In) :
  CriterionDecimalType(
    LimitIn,
    CriterionDecima_1108In)
{
  speedUnit = 0;
}

CriterionSpeedType::CriterionSpeedType(
 XmlDecimal * LimitIn,
 CriterionDecima_1108_Type * CriterionDecima_1108In,
 XmlToken * speedUnitIn) :
  CriterionDecimalType(
    LimitIn,
    CriterionDecima_1108In)
{
  speedUnit = speedUnitIn;
}

CriterionSpeedType::~CriterionSpeedType()
{
  #ifndef NODESTRUCT
  delete speedUnit;
  #endif
}

void CriterionSpeedType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (speedUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "speedUnit=\"");
      speedUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Limit");
  Limit->printSelf(outFile);
  fprintf(outFile, "</Limit>\n");
  if (CriterionDecima_1108)
    {
      CriterionDecima_1108->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool CriterionSpeedType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "speedUnit")
        {
          XmlToken * speedUnitVal;
          if (this->speedUnit)
            {
              fprintf(stderr, "two values for speedUnit in CriterionSpeedType\n");
              returnValue = true;
              break;
            }
          speedUnitVal = new XmlToken(decl->val.c_str());
          if (speedUnitVal->bad)
            {
              delete speedUnitVal;
              fprintf(stderr, "bad value %s for speedUnit in CriterionSpeedType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->speedUnit = speedUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CriterionSpeedType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->speedUnit;
      this->speedUnit = 0;
    }
  return returnValue;
}

XmlToken * CriterionSpeedType::getspeedUnit()
{return speedUnit;}

void CriterionSpeedType::setspeedUnit(XmlToken * speedUnitIn)
{speedUnit = speedUnitIn;}

/* ***************************************************************** */

/* class CriterionTemperatureType

*/

CriterionTemperatureType::CriterionTemperatureType() :
  CriterionDecimalType()
{
  temperatureUnit = 0;
}

CriterionTemperatureType::CriterionTemperatureType(
 XmlDecimal * LimitIn,
 CriterionDecima_1108_Type * CriterionDecima_1108In) :
  CriterionDecimalType(
    LimitIn,
    CriterionDecima_1108In)
{
  temperatureUnit = 0;
}

CriterionTemperatureType::CriterionTemperatureType(
 XmlDecimal * LimitIn,
 CriterionDecima_1108_Type * CriterionDecima_1108In,
 XmlToken * temperatureUnitIn) :
  CriterionDecimalType(
    LimitIn,
    CriterionDecima_1108In)
{
  temperatureUnit = temperatureUnitIn;
}

CriterionTemperatureType::~CriterionTemperatureType()
{
  #ifndef NODESTRUCT
  delete temperatureUnit;
  #endif
}

void CriterionTemperatureType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (temperatureUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "temperatureUnit=\"");
      temperatureUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Limit");
  Limit->printSelf(outFile);
  fprintf(outFile, "</Limit>\n");
  if (CriterionDecima_1108)
    {
      CriterionDecima_1108->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool CriterionTemperatureType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "temperatureUnit")
        {
          XmlToken * temperatureUnitVal;
          if (this->temperatureUnit)
            {
              fprintf(stderr, "two values for temperatureUnit in CriterionTemperatureType\n");
              returnValue = true;
              break;
            }
          temperatureUnitVal = new XmlToken(decl->val.c_str());
          if (temperatureUnitVal->bad)
            {
              delete temperatureUnitVal;
              fprintf(stderr, "bad value %s for temperatureUnit in CriterionTemperatureType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->temperatureUnit = temperatureUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CriterionTemperatureType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->temperatureUnit;
      this->temperatureUnit = 0;
    }
  return returnValue;
}

XmlToken * CriterionTemperatureType::gettemperatureUnit()
{return temperatureUnit;}

void CriterionTemperatureType::settemperatureUnit(XmlToken * temperatureUnitIn)
{temperatureUnit = temperatureUnitIn;}

/* ***************************************************************** */

/* class CriterionTimeType

*/

CriterionTimeType::CriterionTimeType() :
  CriterionDecimalType()
{
  timeUnit = 0;
}

CriterionTimeType::CriterionTimeType(
 XmlDecimal * LimitIn,
 CriterionDecima_1108_Type * CriterionDecima_1108In) :
  CriterionDecimalType(
    LimitIn,
    CriterionDecima_1108In)
{
  timeUnit = 0;
}

CriterionTimeType::CriterionTimeType(
 XmlDecimal * LimitIn,
 CriterionDecima_1108_Type * CriterionDecima_1108In,
 XmlToken * timeUnitIn) :
  CriterionDecimalType(
    LimitIn,
    CriterionDecima_1108In)
{
  timeUnit = timeUnitIn;
}

CriterionTimeType::~CriterionTimeType()
{
  #ifndef NODESTRUCT
  delete timeUnit;
  #endif
}

void CriterionTimeType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (timeUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "timeUnit=\"");
      timeUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Limit");
  Limit->printSelf(outFile);
  fprintf(outFile, "</Limit>\n");
  if (CriterionDecima_1108)
    {
      CriterionDecima_1108->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool CriterionTimeType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "timeUnit")
        {
          XmlToken * timeUnitVal;
          if (this->timeUnit)
            {
              fprintf(stderr, "two values for timeUnit in CriterionTimeType\n");
              returnValue = true;
              break;
            }
          timeUnitVal = new XmlToken(decl->val.c_str());
          if (timeUnitVal->bad)
            {
              delete timeUnitVal;
              fprintf(stderr, "bad value %s for timeUnit in CriterionTimeType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->timeUnit = timeUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CriterionTimeType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->timeUnit;
      this->timeUnit = 0;
    }
  return returnValue;
}

XmlToken * CriterionTimeType::gettimeUnit()
{return timeUnit;}

void CriterionTimeType::settimeUnit(XmlToken * timeUnitIn)
{timeUnit = timeUnitIn;}

/* ***************************************************************** */

/* class CriterionUserDefinedUnitType

*/

CriterionUserDefinedUnitType::CriterionUserDefinedUnitType() :
  CriterionDecimalType()
{
  unitName = 0;
}

CriterionUserDefinedUnitType::CriterionUserDefinedUnitType(
 XmlDecimal * LimitIn,
 CriterionDecima_1108_Type * CriterionDecima_1108In) :
  CriterionDecimalType(
    LimitIn,
    CriterionDecima_1108In)
{
  unitName = 0;
}

CriterionUserDefinedUnitType::CriterionUserDefinedUnitType(
 XmlDecimal * LimitIn,
 CriterionDecima_1108_Type * CriterionDecima_1108In,
 XmlToken * unitNameIn) :
  CriterionDecimalType(
    LimitIn,
    CriterionDecima_1108In)
{
  unitName = unitNameIn;
}

CriterionUserDefinedUnitType::~CriterionUserDefinedUnitType()
{
  #ifndef NODESTRUCT
  delete unitName;
  #endif
}

void CriterionUserDefinedUnitType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (unitName)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "unitName=\"");
      unitName->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"unitName\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Limit");
  Limit->printSelf(outFile);
  fprintf(outFile, "</Limit>\n");
  if (CriterionDecima_1108)
    {
      CriterionDecima_1108->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool CriterionUserDefinedUnitType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "unitName")
        {
          XmlToken * unitNameVal;
          if (this->unitName)
            {
              fprintf(stderr, "two values for unitName in CriterionUserDefinedUnitType\n");
              returnValue = true;
              break;
            }
          unitNameVal = new XmlToken(decl->val.c_str());
          if (unitNameVal->bad)
            {
              delete unitNameVal;
              fprintf(stderr, "bad value %s for unitName in CriterionUserDefinedUnitType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->unitName = unitNameVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in CriterionUserDefinedUnitType\n");
          returnValue = true;
          break;
        }
    }
  if (this->unitName == 0)
    {
      fprintf(stderr, "required attribute \"unitName\" missing in CriterionUserDefinedUnitType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->unitName;
      this->unitName = 0;
    }
  return returnValue;
}

XmlToken * CriterionUserDefinedUnitType::getunitName()
{return unitName;}

void CriterionUserDefinedUnitType::setunitName(XmlToken * unitNameIn)
{unitName = unitNameIn;}

/* ***************************************************************** */

/* class CriterionUserDefinedUnitTypeLisd

*/

CriterionUserDefinedUnitTypeLisd::CriterionUserDefinedUnitTypeLisd() {}

CriterionUserDefinedUnitTypeLisd::CriterionUserDefinedUnitTypeLisd(CriterionUserDefinedUnitType * aCriterionUserDefinedUnitType)
{
  push_back(aCriterionUserDefinedUnitType);
}

CriterionUserDefinedUnitTypeLisd::~CriterionUserDefinedUnitTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<CriterionUserDefinedUnitType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void CriterionUserDefinedUnitTypeLisd::printSelf(FILE * outFile)
{
  std::list<CriterionUserDefinedUnitType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class CurveLengthCharacteristicStatsEvalType

*/

CurveLengthCharacteristicStatsEvalType::CurveLengthCharacteristicStatsEvalType() :
  LinearCharacteristicStatsEvalType() {}

CurveLengthCharacteristicStatsEvalType::CurveLengthCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 LinearCharacteristicStatsEvalTypeChoicePair * LinearCharacteristicStatsEvalTypePairIn) :
  LinearCharacteristicStatsEvalType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    LinearCharacteristicStatsEvalTypePairIn)
{}

CurveLengthCharacteristicStatsEvalType::~CurveLengthCharacteristicStatsEvalType() {}

void CurveLengthCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  LinearCharacteristicStatsEvalTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class CylindricityCharacteristicStatsEvalType

*/

CylindricityCharacteristicStatsEvalType::CylindricityCharacteristicStatsEvalType() :
  FormCharacteristicStatsEvalBaseType()
{
  MaxCylindricityStats = 0;
}

CylindricityCharacteristicStatsEvalType::CylindricityCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsWithTolLinearType * ValueStatsIn,
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn,
 OneSidedCapabilityCalculationEnumType * CapabilityCalculationMethodIn,
 StatsLinearType * MaxCylindricityStatsIn) :
  FormCharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    ValueStatsIn,
    MaxValueStatsIn,
    MinValueStatsIn,
    CapabilityCalculationMethodIn)
{
  MaxCylindricityStats = MaxCylindricityStatsIn;
}

CylindricityCharacteristicStatsEvalType::~CylindricityCharacteristicStatsEvalType()
{
  #ifndef NODESTRUCT
  delete MaxCylindricityStats;
  #endif
}

void CylindricityCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (ValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ValueStats");
      ValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ValueStats>\n");
    }
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  if (CapabilityCalculationMethod)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CapabilityCalculationMethod");
      CapabilityCalculationMethod->printSelf(outFile);
      fprintf(outFile, "</CapabilityCalculationMethod>\n");
    }
  if (MaxCylindricityStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxCylindricityStats");
      MaxCylindricityStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxCylindricityStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

StatsLinearType * CylindricityCharacteristicStatsEvalType::getMaxCylindricityStats()
{return MaxCylindricityStats;}

void CylindricityCharacteristicStatsEvalType::setMaxCylindricityStats(StatsLinearType * MaxCylindricityStatsIn)
{MaxCylindricityStats = MaxCylindricityStatsIn;}

/* ***************************************************************** */

/* class DepthCharacteristicStatsEvalType

*/

DepthCharacteristicStatsEvalType::DepthCharacteristicStatsEvalType() :
  LinearCharacteristicStatsEvalType() {}

DepthCharacteristicStatsEvalType::DepthCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 LinearCharacteristicStatsEvalTypeChoicePair * LinearCharacteristicStatsEvalTypePairIn) :
  LinearCharacteristicStatsEvalType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    LinearCharacteristicStatsEvalTypePairIn)
{}

DepthCharacteristicStatsEvalType::~DepthCharacteristicStatsEvalType() {}

void DepthCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  LinearCharacteristicStatsEvalTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class DiameterCharacteristicStatsEvalType

*/

DiameterCharacteristicStatsEvalType::DiameterCharacteristicStatsEvalType() :
  LinearCharacteristicStatsEvalType() {}

DiameterCharacteristicStatsEvalType::DiameterCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 LinearCharacteristicStatsEvalTypeChoicePair * LinearCharacteristicStatsEvalTypePairIn) :
  LinearCharacteristicStatsEvalType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    LinearCharacteristicStatsEvalTypePairIn)
{}

DiameterCharacteristicStatsEvalType::~DiameterCharacteristicStatsEvalType() {}

void DiameterCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  LinearCharacteristicStatsEvalTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class DistanceBetweenCharacteristicStatsEvalType

*/

DistanceBetweenCharacteristicStatsEvalType::DistanceBetweenCharacteristicStatsEvalType() :
  LinearCharacteristicStatsEvalType() {}

DistanceBetweenCharacteristicStatsEvalType::DistanceBetweenCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 LinearCharacteristicStatsEvalTypeChoicePair * LinearCharacteristicStatsEvalTypePairIn) :
  LinearCharacteristicStatsEvalType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    LinearCharacteristicStatsEvalTypePairIn)
{}

DistanceBetweenCharacteristicStatsEvalType::~DistanceBetweenCharacteristicStatsEvalType() {}

void DistanceBetweenCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  LinearCharacteristicStatsEvalTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class DistanceFromCharacteristicStatsEvalType

*/

DistanceFromCharacteristicStatsEvalType::DistanceFromCharacteristicStatsEvalType() :
  LinearCharacteristicStatsEvalType() {}

DistanceFromCharacteristicStatsEvalType::DistanceFromCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 LinearCharacteristicStatsEvalTypeChoicePair * LinearCharacteristicStatsEvalTypePairIn) :
  LinearCharacteristicStatsEvalType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    LinearCharacteristicStatsEvalTypePairIn)
{}

DistanceFromCharacteristicStatsEvalType::~DistanceFromCharacteristicStatsEvalType() {}

void DistanceFromCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  LinearCharacteristicStatsEvalTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class DistributionTransformationEnumType

*/

DistributionTransformationEnumType::DistributionTransformationEnumType() :
  XmlNMTOKEN()
{
}

DistributionTransformationEnumType::DistributionTransformationEnumType(
 const char * valIn) :
  XmlNMTOKEN(
    valIn)
{
  if (!bad)
    bad = (strcmp(val.c_str(), "LOGNORMAL") &&
           strcmp(val.c_str(), "BOUNDED") &&
           strcmp(val.c_str(), "UNBOUNDED"));
}

DistributionTransformationEnumType::~DistributionTransformationEnumType() {}

bool DistributionTransformationEnumType::DistributionTransformationEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "LOGNORMAL") &&
          strcmp(val.c_str(), "BOUNDED") &&
          strcmp(val.c_str(), "UNBOUNDED"));
}

void DistributionTransformationEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "DistributionTransformationEnumType");
}

void DistributionTransformationEnumType::printSelf(FILE * outFile)
{
  if (DistributionTransformationEnumTypeIsBad())
    {
      fprintf(stderr, "bad DistributionTransformationEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::printSelf(outFile);
}

void DistributionTransformationEnumType::oPrintSelf(FILE * outFile)
{
  if (DistributionTransformationEnumTypeIsBad())
    {
      fprintf(stderr, "bad DistributionTransformationEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class DistributionTransformationType

*/

DistributionTransformationType::DistributionTransformationType()
{
  DistributionTransformationTypePair = 0;
}

DistributionTransformationType::DistributionTransformationType(
 DistributionTransformationTypeChoicePair * DistributionTransformationTypePairIn)
{
  DistributionTransformationTypePair = DistributionTransformationTypePairIn;
}

DistributionTransformationType::~DistributionTransformationType()
{
  #ifndef NODESTRUCT
  delete DistributionTransformationTypePair;
  #endif
}

void DistributionTransformationType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  DistributionTransformationTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

DistributionTransformationTypeChoicePair * DistributionTransformationType::getDistributionTransformationTypePair()
{return DistributionTransformationTypePair;}

void DistributionTransformationType::setDistributionTransformationTypePair(DistributionTransformationTypeChoicePair * DistributionTransformationTypePairIn)
{DistributionTransformationTypePair = DistributionTransformationTypePairIn;}
DistributionTransformationTypeChoicePair::DistributionTransformationTypeChoicePair() {}

DistributionTransformationTypeChoicePair::DistributionTransformationTypeChoicePair(
 whichOne DistributionTransformationTypeTypeIn,
 DistributionTransformationTypeVal DistributionTransformationTypeValueIn)
{
  DistributionTransformationTypeType = DistributionTransformationTypeTypeIn;
  DistributionTransformationTypeValue = DistributionTransformationTypeValueIn;
}

DistributionTransformationTypeChoicePair::~DistributionTransformationTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (DistributionTransformationTypeType == DistributionTransformationEnumE)
    delete DistributionTransformationTypeValue.DistributionTransformationEnum;
  else if (DistributionTransformationTypeType == BoxCoxTransformationE)
    delete DistributionTransformationTypeValue.BoxCoxTransformation;
  else if (DistributionTransformationTypeType == OtherDistributionTransformationE)
    delete DistributionTransformationTypeValue.OtherDistributionTransformation;
  #endif
}

void DistributionTransformationTypeChoicePair::printSelf(FILE * outFile)
{
  if (DistributionTransformationTypeType == DistributionTransformationEnumE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformationEnum");
      DistributionTransformationTypeValue.DistributionTransformationEnum->printSelf(outFile);
      fprintf(outFile, "</DistributionTransformationEnum>\n");
    }
  else if (DistributionTransformationTypeType == BoxCoxTransformationE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BoxCoxTransformation");
      DistributionTransformationTypeValue.BoxCoxTransformation->printSelf(outFile);
      fprintf(outFile, "</BoxCoxTransformation>\n");
    }
  else if (DistributionTransformationTypeType == OtherDistributionTransformationE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OtherDistributionTransformation");
      DistributionTransformationTypeValue.OtherDistributionTransformation->printSelf(outFile);
      fprintf(outFile, "</OtherDistributionTransformation>\n");
    }
}

/* ***************************************************************** */

/* class EllipticityCharacteristicStatsEvalType

*/

EllipticityCharacteristicStatsEvalType::EllipticityCharacteristicStatsEvalType() :
  FormCharacteristicStatsEvalBaseType() {}

EllipticityCharacteristicStatsEvalType::EllipticityCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsWithTolLinearType * ValueStatsIn,
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn,
 OneSidedCapabilityCalculationEnumType * CapabilityCalculationMethodIn) :
  FormCharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    ValueStatsIn,
    MaxValueStatsIn,
    MinValueStatsIn,
    CapabilityCalculationMethodIn)
{}

EllipticityCharacteristicStatsEvalType::~EllipticityCharacteristicStatsEvalType() {}

void EllipticityCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (ValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ValueStats");
      ValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ValueStats>\n");
    }
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  if (CapabilityCalculationMethod)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CapabilityCalculationMethod");
      CapabilityCalculationMethod->printSelf(outFile);
      fprintf(outFile, "</CapabilityCalculationMethod>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class ExclusionEnumType

*/

ExclusionEnumType::ExclusionEnumType() :
  XmlNMTOKEN()
{
}

ExclusionEnumType::ExclusionEnumType(
 const char * valIn) :
  XmlNMTOKEN(
    valIn)
{
  if (!bad)
    bad = (strcmp(val.c_str(), "FLIER") &&
           strcmp(val.c_str(), "EQUIPERROR") &&
           strcmp(val.c_str(), "REWORK") &&
           strcmp(val.c_str(), "KNOWNCAUSE"));
}

ExclusionEnumType::~ExclusionEnumType() {}

bool ExclusionEnumType::ExclusionEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "FLIER") &&
          strcmp(val.c_str(), "EQUIPERROR") &&
          strcmp(val.c_str(), "REWORK") &&
          strcmp(val.c_str(), "KNOWNCAUSE"));
}

void ExclusionEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "ExclusionEnumType");
}

void ExclusionEnumType::printSelf(FILE * outFile)
{
  if (ExclusionEnumTypeIsBad())
    {
      fprintf(stderr, "bad ExclusionEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::printSelf(outFile);
}

void ExclusionEnumType::oPrintSelf(FILE * outFile)
{
  if (ExclusionEnumTypeIsBad())
    {
      fprintf(stderr, "bad ExclusionEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class ExclusionIdType

*/

ExclusionIdType::ExclusionIdType()
{
  Id = 0;
  Reason = 0;
}

ExclusionIdType::ExclusionIdType(
 QIFReferenceType * IdIn,
 ExclusionReasonType * ReasonIn)
{
  Id = IdIn;
  Reason = ReasonIn;
}

ExclusionIdType::~ExclusionIdType()
{
  #ifndef NODESTRUCT
  delete Id;
  delete Reason;
  #endif
}

void ExclusionIdType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Id");
  Id->printSelf(outFile);
  fprintf(outFile, "</Id>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Reason");
  Reason->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Reason>\n");
  doSpaces(-INDENT, outFile);
}

QIFReferenceType * ExclusionIdType::getId()
{return Id;}

void ExclusionIdType::setId(QIFReferenceType * IdIn)
{Id = IdIn;}

ExclusionReasonType * ExclusionIdType::getReason()
{return Reason;}

void ExclusionIdType::setReason(ExclusionReasonType * ReasonIn)
{Reason = ReasonIn;}

/* ***************************************************************** */

/* class ExclusionIdTypeLisd

*/

ExclusionIdTypeLisd::ExclusionIdTypeLisd() {}

ExclusionIdTypeLisd::ExclusionIdTypeLisd(ExclusionIdType * aExclusionIdType)
{
  push_back(aExclusionIdType);
}

ExclusionIdTypeLisd::~ExclusionIdTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<ExclusionIdType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void ExclusionIdTypeLisd::printSelf(FILE * outFile)
{
  std::list<ExclusionIdType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class ExclusionIndexType

*/

ExclusionIndexType::ExclusionIndexType()
{
  Index = 0;
  Reason = 0;
}

ExclusionIndexType::ExclusionIndexType(
 XmlPositiveInteger * IndexIn,
 ExclusionReasonType * ReasonIn)
{
  Index = IndexIn;
  Reason = ReasonIn;
}

ExclusionIndexType::~ExclusionIndexType()
{
  #ifndef NODESTRUCT
  delete Index;
  delete Reason;
  #endif
}

void ExclusionIndexType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Index");
  Index->printSelf(outFile);
  fprintf(outFile, "</Index>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<Reason");
  Reason->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Reason>\n");
  doSpaces(-INDENT, outFile);
}

XmlPositiveInteger * ExclusionIndexType::getIndex()
{return Index;}

void ExclusionIndexType::setIndex(XmlPositiveInteger * IndexIn)
{Index = IndexIn;}

ExclusionReasonType * ExclusionIndexType::getReason()
{return Reason;}

void ExclusionIndexType::setReason(ExclusionReasonType * ReasonIn)
{Reason = ReasonIn;}

/* ***************************************************************** */

/* class ExclusionIndexTypeLisd

*/

ExclusionIndexTypeLisd::ExclusionIndexTypeLisd() {}

ExclusionIndexTypeLisd::ExclusionIndexTypeLisd(ExclusionIndexType * aExclusionIndexType)
{
  push_back(aExclusionIndexType);
}

ExclusionIndexTypeLisd::~ExclusionIndexTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<ExclusionIndexType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void ExclusionIndexTypeLisd::printSelf(FILE * outFile)
{
  std::list<ExclusionIndexType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class ExclusionReasonType

*/

ExclusionReasonType::ExclusionReasonType()
{
  ExclusionReasonTypePair = 0;
}

ExclusionReasonType::ExclusionReasonType(
 ExclusionReasonTypeChoicePair * ExclusionReasonTypePairIn)
{
  ExclusionReasonTypePair = ExclusionReasonTypePairIn;
}

ExclusionReasonType::~ExclusionReasonType()
{
  #ifndef NODESTRUCT
  delete ExclusionReasonTypePair;
  #endif
}

void ExclusionReasonType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  ExclusionReasonTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

ExclusionReasonTypeChoicePair * ExclusionReasonType::getExclusionReasonTypePair()
{return ExclusionReasonTypePair;}

void ExclusionReasonType::setExclusionReasonTypePair(ExclusionReasonTypeChoicePair * ExclusionReasonTypePairIn)
{ExclusionReasonTypePair = ExclusionReasonTypePairIn;}
ExclusionReasonTypeChoicePair::ExclusionReasonTypeChoicePair() {}

ExclusionReasonTypeChoicePair::ExclusionReasonTypeChoicePair(
 whichOne ExclusionReasonTypeTypeIn,
 ExclusionReasonTypeVal ExclusionReasonTypeValueIn)
{
  ExclusionReasonTypeType = ExclusionReasonTypeTypeIn;
  ExclusionReasonTypeValue = ExclusionReasonTypeValueIn;
}

ExclusionReasonTypeChoicePair::~ExclusionReasonTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (ExclusionReasonTypeType == ExclusionReasonEnumE)
    delete ExclusionReasonTypeValue.ExclusionReasonEnum;
  else if (ExclusionReasonTypeType == OtherExclusionReasonE)
    delete ExclusionReasonTypeValue.OtherExclusionReason;
  #endif
}

void ExclusionReasonTypeChoicePair::printSelf(FILE * outFile)
{
  if (ExclusionReasonTypeType == ExclusionReasonEnumE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ExclusionReasonEnum");
      ExclusionReasonTypeValue.ExclusionReasonEnum->printSelf(outFile);
      fprintf(outFile, "</ExclusionReasonEnum>\n");
    }
  else if (ExclusionReasonTypeType == OtherExclusionReasonE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OtherExclusionReason");
      ExclusionReasonTypeValue.OtherExclusionReason->printSelf(outFile);
      fprintf(outFile, "</OtherExclusionReason>\n");
    }
}

/* ***************************************************************** */

/* class ExclusionsIdType

*/

ExclusionsIdType::ExclusionsIdType()
{
  n = 0;
  Exclusion = 0;
}

ExclusionsIdType::ExclusionsIdType(
 ExclusionIdTypeLisd * ExclusionIn)
{
  n = 0;
  Exclusion = ExclusionIn;
}

ExclusionsIdType::ExclusionsIdType(
 NaturalType * nIn,
 ExclusionIdTypeLisd * ExclusionIn)
{
  n = nIn;
  Exclusion = ExclusionIn;
}

ExclusionsIdType::~ExclusionsIdType()
{
  #ifndef NODESTRUCT
  delete n;
  delete Exclusion;
  #endif
}

void ExclusionsIdType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!Exclusion)
      {
        fprintf(stderr, "Exclusion list is missing\n");
        exit(1);
      }
    if (Exclusion->size() == 0)
      {
        fprintf(stderr, "Exclusion list is empty\n");
        exit(1);
      }
    if (Exclusion->size() < 1)
      {
        fprintf(stderr,
                "size of Exclusion list (%d) less than minimum required (1)\n",
                (int)Exclusion->size());
        exit(1);
      }
    std::list<ExclusionIdType *>::iterator iter;
    for (iter = Exclusion->begin();
         iter != Exclusion->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<Exclusion");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</Exclusion>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool ExclusionsIdType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in ExclusionsIdType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->val.c_str());
          if (nVal->bad)
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in ExclusionsIdType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ExclusionsIdType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in ExclusionsIdType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * ExclusionsIdType::getn()
{return n;}

void ExclusionsIdType::setn(NaturalType * nIn)
{n = nIn;}

ExclusionIdTypeLisd * ExclusionsIdType::getExclusion()
{return Exclusion;}

void ExclusionsIdType::setExclusion(ExclusionIdTypeLisd * ExclusionIn)
{Exclusion = ExclusionIn;}

/* ***************************************************************** */

/* class ExclusionsIndexType

*/

ExclusionsIndexType::ExclusionsIndexType()
{
  n = 0;
  Exclusion = 0;
}

ExclusionsIndexType::ExclusionsIndexType(
 ExclusionIndexTypeLisd * ExclusionIn)
{
  n = 0;
  Exclusion = ExclusionIn;
}

ExclusionsIndexType::ExclusionsIndexType(
 NaturalType * nIn,
 ExclusionIndexTypeLisd * ExclusionIn)
{
  n = nIn;
  Exclusion = ExclusionIn;
}

ExclusionsIndexType::~ExclusionsIndexType()
{
  #ifndef NODESTRUCT
  delete n;
  delete Exclusion;
  #endif
}

void ExclusionsIndexType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!Exclusion)
      {
        fprintf(stderr, "Exclusion list is missing\n");
        exit(1);
      }
    if (Exclusion->size() == 0)
      {
        fprintf(stderr, "Exclusion list is empty\n");
        exit(1);
      }
    if (Exclusion->size() < 1)
      {
        fprintf(stderr,
                "size of Exclusion list (%d) less than minimum required (1)\n",
                (int)Exclusion->size());
        exit(1);
      }
    std::list<ExclusionIndexType *>::iterator iter;
    for (iter = Exclusion->begin();
         iter != Exclusion->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<Exclusion");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</Exclusion>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool ExclusionsIndexType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in ExclusionsIndexType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->val.c_str());
          if (nVal->bad)
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in ExclusionsIndexType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in ExclusionsIndexType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in ExclusionsIndexType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * ExclusionsIndexType::getn()
{return n;}

void ExclusionsIndexType::setn(NaturalType * nIn)
{n = nIn;}

ExclusionIndexTypeLisd * ExclusionsIndexType::getExclusion()
{return Exclusion;}

void ExclusionsIndexType::setExclusion(ExclusionIndexTypeLisd * ExclusionIn)
{Exclusion = ExclusionIn;}

/* ***************************************************************** */

/* class FlatTaperCharacteristicStatsEvalType

*/

FlatTaperCharacteristicStatsEvalType::FlatTaperCharacteristicStatsEvalType() :
  LinearCharacteristicStatsEvalType() {}

FlatTaperCharacteristicStatsEvalType::FlatTaperCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 LinearCharacteristicStatsEvalTypeChoicePair * LinearCharacteristicStatsEvalTypePairIn) :
  LinearCharacteristicStatsEvalType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    LinearCharacteristicStatsEvalTypePairIn)
{}

FlatTaperCharacteristicStatsEvalType::~FlatTaperCharacteristicStatsEvalType() {}

void FlatTaperCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  LinearCharacteristicStatsEvalTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class FlatnessCharacteristicStatsEvalType

*/

FlatnessCharacteristicStatsEvalType::FlatnessCharacteristicStatsEvalType() :
  FormCharacteristicStatsEvalBaseType()
{
  BonusStats = 0;
  MaxFlatnessStats = 0;
}

FlatnessCharacteristicStatsEvalType::FlatnessCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsWithTolLinearType * ValueStatsIn,
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn,
 OneSidedCapabilityCalculationEnumType * CapabilityCalculationMethodIn,
 StatsLinearType * BonusStatsIn,
 StatsLinearType * MaxFlatnessStatsIn) :
  FormCharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    ValueStatsIn,
    MaxValueStatsIn,
    MinValueStatsIn,
    CapabilityCalculationMethodIn)
{
  BonusStats = BonusStatsIn;
  MaxFlatnessStats = MaxFlatnessStatsIn;
}

FlatnessCharacteristicStatsEvalType::~FlatnessCharacteristicStatsEvalType()
{
  #ifndef NODESTRUCT
  delete BonusStats;
  delete MaxFlatnessStats;
  #endif
}

void FlatnessCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (ValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ValueStats");
      ValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ValueStats>\n");
    }
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  if (CapabilityCalculationMethod)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CapabilityCalculationMethod");
      CapabilityCalculationMethod->printSelf(outFile);
      fprintf(outFile, "</CapabilityCalculationMethod>\n");
    }
  if (BonusStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BonusStats");
      BonusStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BonusStats>\n");
    }
  if (MaxFlatnessStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxFlatnessStats");
      MaxFlatnessStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxFlatnessStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

StatsLinearType * FlatnessCharacteristicStatsEvalType::getBonusStats()
{return BonusStats;}

void FlatnessCharacteristicStatsEvalType::setBonusStats(StatsLinearType * BonusStatsIn)
{BonusStats = BonusStatsIn;}

StatsLinearType * FlatnessCharacteristicStatsEvalType::getMaxFlatnessStats()
{return MaxFlatnessStats;}

void FlatnessCharacteristicStatsEvalType::setMaxFlatnessStats(StatsLinearType * MaxFlatnessStatsIn)
{MaxFlatnessStats = MaxFlatnessStatsIn;}

/* ***************************************************************** */

/* class FormCharacteristicStatsEvalBaseType

*/

FormCharacteristicStatsEvalBaseType::FormCharacteristicStatsEvalBaseType() :
  GeometricCharacteristicStatsEvalType()
{
  CapabilityCalculationMethod = 0;
}

FormCharacteristicStatsEvalBaseType::FormCharacteristicStatsEvalBaseType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsWithTolLinearType * ValueStatsIn,
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn,
 OneSidedCapabilityCalculationEnumType * CapabilityCalculationMethodIn) :
  GeometricCharacteristicStatsEvalType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    ValueStatsIn,
    MaxValueStatsIn,
    MinValueStatsIn)
{
  CapabilityCalculationMethod = CapabilityCalculationMethodIn;
}

FormCharacteristicStatsEvalBaseType::~FormCharacteristicStatsEvalBaseType()
{
  #ifndef NODESTRUCT
  delete CapabilityCalculationMethod;
  #endif
}

void FormCharacteristicStatsEvalBaseType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (ValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ValueStats");
      ValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ValueStats>\n");
    }
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  if (CapabilityCalculationMethod)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CapabilityCalculationMethod");
      CapabilityCalculationMethod->printSelf(outFile);
      fprintf(outFile, "</CapabilityCalculationMethod>\n");
    }
  doSpaces(-INDENT, outFile);
}

OneSidedCapabilityCalculationEnumType * FormCharacteristicStatsEvalBaseType::getCapabilityCalculationMethod()
{return CapabilityCalculationMethod;}

void FormCharacteristicStatsEvalBaseType::setCapabilityCalculationMethod(OneSidedCapabilityCalculationEnumType * CapabilityCalculationMethodIn)
{CapabilityCalculationMethod = CapabilityCalculationMethodIn;}

/* ***************************************************************** */

/* class GeometricCharacteristicStatsEvalType

*/

GeometricCharacteristicStatsEvalType::GeometricCharacteristicStatsEvalType() :
  CharacteristicStatsEvalBaseType()
{
  ValueStats = 0;
  MaxValueStats = 0;
  MinValueStats = 0;
}

GeometricCharacteristicStatsEvalType::GeometricCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsWithTolLinearType * ValueStatsIn,
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn) :
  CharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn)
{
  ValueStats = ValueStatsIn;
  MaxValueStats = MaxValueStatsIn;
  MinValueStats = MinValueStatsIn;
}

GeometricCharacteristicStatsEvalType::~GeometricCharacteristicStatsEvalType()
{
  #ifndef NODESTRUCT
  delete ValueStats;
  delete MaxValueStats;
  delete MinValueStats;
  #endif
}

void GeometricCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (ValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ValueStats");
      ValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ValueStats>\n");
    }
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

StatsWithTolLinearType * GeometricCharacteristicStatsEvalType::getValueStats()
{return ValueStats;}

void GeometricCharacteristicStatsEvalType::setValueStats(StatsWithTolLinearType * ValueStatsIn)
{ValueStats = ValueStatsIn;}

StatsLinearType * GeometricCharacteristicStatsEvalType::getMaxValueStats()
{return MaxValueStats;}

void GeometricCharacteristicStatsEvalType::setMaxValueStats(StatsLinearType * MaxValueStatsIn)
{MaxValueStats = MaxValueStatsIn;}

StatsLinearType * GeometricCharacteristicStatsEvalType::getMinValueStats()
{return MinValueStats;}

void GeometricCharacteristicStatsEvalType::setMinValueStats(StatsLinearType * MinValueStatsIn)
{MinValueStats = MinValueStatsIn;}

/* ***************************************************************** */

/* class HeightCharacteristicStatsEvalType

*/

HeightCharacteristicStatsEvalType::HeightCharacteristicStatsEvalType() :
  LinearCharacteristicStatsEvalType() {}

HeightCharacteristicStatsEvalType::HeightCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 LinearCharacteristicStatsEvalTypeChoicePair * LinearCharacteristicStatsEvalTypePairIn) :
  LinearCharacteristicStatsEvalType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    LinearCharacteristicStatsEvalTypePairIn)
{}

HeightCharacteristicStatsEvalType::~HeightCharacteristicStatsEvalType() {}

void HeightCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  LinearCharacteristicStatsEvalTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class LengthCharacteristicStatsEvalType

*/

LengthCharacteristicStatsEvalType::LengthCharacteristicStatsEvalType() :
  LinearCharacteristicStatsEvalType() {}

LengthCharacteristicStatsEvalType::LengthCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 LinearCharacteristicStatsEvalTypeChoicePair * LinearCharacteristicStatsEvalTypePairIn) :
  LinearCharacteristicStatsEvalType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    LinearCharacteristicStatsEvalTypePairIn)
{}

LengthCharacteristicStatsEvalType::~LengthCharacteristicStatsEvalType() {}

void LengthCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  LinearCharacteristicStatsEvalTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class LimitingNumberType

*/

LimitingNumberType::LimitingNumberType()
{
  LimitingNumberTypePair = 0;
}

LimitingNumberType::LimitingNumberType(
 LimitingNumberTypeChoicePair * LimitingNumberTypePairIn)
{
  LimitingNumberTypePair = LimitingNumberTypePairIn;
}

LimitingNumberType::~LimitingNumberType()
{
  #ifndef NODESTRUCT
  delete LimitingNumberTypePair;
  #endif
}

void LimitingNumberType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  LimitingNumberTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

LimitingNumberTypeChoicePair * LimitingNumberType::getLimitingNumberTypePair()
{return LimitingNumberTypePair;}

void LimitingNumberType::setLimitingNumberTypePair(LimitingNumberTypeChoicePair * LimitingNumberTypePairIn)
{LimitingNumberTypePair = LimitingNumberTypePairIn;}
LimitingNumberTypeChoicePair::LimitingNumberTypeChoicePair() {}

LimitingNumberTypeChoicePair::LimitingNumberTypeChoicePair(
 whichOne LimitingNumberTypeTypeIn,
 LimitingNumberTypeVal LimitingNumberTypeValueIn)
{
  LimitingNumberTypeType = LimitingNumberTypeTypeIn;
  LimitingNumberTypeValue = LimitingNumberTypeValueIn;
}

LimitingNumberTypeChoicePair::~LimitingNumberTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (LimitingNumberTypeType == CountE)
    delete LimitingNumberTypeValue.Count;
  else if (LimitingNumberTypeType == FractionE)
    delete LimitingNumberTypeValue.Fraction;
  #endif
}

void LimitingNumberTypeChoicePair::printSelf(FILE * outFile)
{
  if (LimitingNumberTypeType == CountE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Count");
      LimitingNumberTypeValue.Count->printSelf(outFile);
      fprintf(outFile, "</Count>\n");
    }
  else if (LimitingNumberTypeType == FractionE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Fraction");
      LimitingNumberTypeValue.Fraction->printSelf(outFile);
      fprintf(outFile, "</Fraction>\n");
    }
}

/* ***************************************************************** */

/* class LineProfileCharacteristicStatsEvalType

*/

LineProfileCharacteristicStatsEvalType::LineProfileCharacteristicStatsEvalType() :
  ProfileCharacteristicStatsEvalBaseType() {}

LineProfileCharacteristicStatsEvalType::LineProfileCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsWithTolLinearType * ValueStatsIn,
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn,
 OneSidedCapabilityCalculationEnumType * CapabilityCalculationMethodIn,
 StatsLinearType * WorstPositiveDeviationStatsIn,
 StatsLinearType * WorstNegativeDeviationStatsIn,
 PointDeviationsStatsEvalType * PointDeviationsStatsIn,
 StatsPassFailType * DatumsOkStatsIn,
 CompositeSegmentsProfileStatsEvalType * CompositeSegmentsStatsIn) :
  ProfileCharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    ValueStatsIn,
    MaxValueStatsIn,
    MinValueStatsIn,
    CapabilityCalculationMethodIn,
    WorstPositiveDeviationStatsIn,
    WorstNegativeDeviationStatsIn,
    PointDeviationsStatsIn,
    DatumsOkStatsIn,
    CompositeSegmentsStatsIn)
{}

LineProfileCharacteristicStatsEvalType::~LineProfileCharacteristicStatsEvalType() {}

void LineProfileCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (ValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ValueStats");
      ValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ValueStats>\n");
    }
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  if (CapabilityCalculationMethod)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CapabilityCalculationMethod");
      CapabilityCalculationMethod->printSelf(outFile);
      fprintf(outFile, "</CapabilityCalculationMethod>\n");
    }
  if (WorstPositiveDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WorstPositiveDeviationStats");
      WorstPositiveDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WorstPositiveDeviationStats>\n");
    }
  if (WorstNegativeDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WorstNegativeDeviationStats");
      WorstNegativeDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WorstNegativeDeviationStats>\n");
    }
  if (PointDeviationsStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointDeviationsStats");
      PointDeviationsStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointDeviationsStats>\n");
    }
  if (DatumsOkStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumsOkStats");
      DatumsOkStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DatumsOkStats>\n");
    }
  if (CompositeSegmentsStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CompositeSegmentsStats");
      CompositeSegmentsStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CompositeSegmentsStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class LinearCharacteristicStatsEvalType

*/

LinearCharacteristicStatsEvalType::LinearCharacteristicStatsEvalType() :
  CharacteristicStatsEvalBaseType()
{
  LinearCharacteristicStatsEvalTypePair = 0;
}

LinearCharacteristicStatsEvalType::LinearCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 LinearCharacteristicStatsEvalTypeChoicePair * LinearCharacteristicStatsEvalTypePairIn) :
  CharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn)
{
  LinearCharacteristicStatsEvalTypePair = LinearCharacteristicStatsEvalTypePairIn;
}

LinearCharacteristicStatsEvalType::~LinearCharacteristicStatsEvalType()
{
  #ifndef NODESTRUCT
  delete LinearCharacteristicStatsEvalTypePair;
  #endif
}

void LinearCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  LinearCharacteristicStatsEvalTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}
LinearCharacteristicStatsEvalTypeChoicePair * LinearCharacteristicStatsEvalType::getLinearCharacteristicStatsEvalTypeChoicePair()
{return LinearCharacteristicStatsEvalTypePair;}

void LinearCharacteristicStatsEvalType::setLinearCharacteristicStatsEvalTypeChoicePair(LinearCharacteristicStatsEvalTypeChoicePair * LinearCharacteristicStatsEvalTypePairIn)
{LinearCharacteristicStatsEvalTypePair = LinearCharacteristicStatsEvalTypePairIn;}

/* ***************************************************************** */

LinearCharacteristicStatsEvalTypeChoicePair::LinearCharacteristicStatsEvalTypeChoicePair() {}

LinearCharacteristicStatsEvalTypeChoicePair::LinearCharacteristicStatsEvalTypeChoicePair(
 whichOne LinearCharacteristicStatsEvalTypeTypeIn,
 LinearCharacteristicStatsEvalTypeVal LinearCharacteristicStatsEvalTypeValueIn)
{
  LinearCharacteristicStatsEvalTypeType = LinearCharacteristicStatsEvalTypeTypeIn;
  LinearCharacteristicStatsEvalTypeValue = LinearCharacteristicStatsEvalTypeValueIn;
}

LinearCharacteristicStatsEvalTypeChoicePair::~LinearCharacteristicStatsEvalTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (LinearCharacteristicStatsEvalTypeType == LinearCharacter_1110E)
    delete LinearCharacteristicStatsEvalTypeValue.LinearCharacter_1110;
  else if (LinearCharacteristicStatsEvalTypeType == LinearCharacter_1111E)
    delete LinearCharacteristicStatsEvalTypeValue.LinearCharacter_1111;
  else if (LinearCharacteristicStatsEvalTypeType == MinValueStatsE)
    delete LinearCharacteristicStatsEvalTypeValue.MinValueStats;
  else if (LinearCharacteristicStatsEvalTypeType == LinearCharacter_1112E)
    delete LinearCharacteristicStatsEvalTypeValue.LinearCharacter_1112;
  else if (LinearCharacteristicStatsEvalTypeType == LinearCharacter_1113E)
    delete LinearCharacteristicStatsEvalTypeValue.LinearCharacter_1113;
  else if (LinearCharacteristicStatsEvalTypeType == MinDeviationStatsE)
    delete LinearCharacteristicStatsEvalTypeValue.MinDeviationStats;
  #endif
}

void LinearCharacteristicStatsEvalTypeChoicePair::printSelf(FILE * outFile)
{
  if (LinearCharacteristicStatsEvalTypeType == LinearCharacter_1110E)
    {
      LinearCharacteristicStatsEvalTypeValue.LinearCharacter_1110->printSelf(outFile);
    }
  else if (LinearCharacteristicStatsEvalTypeType == LinearCharacter_1111E)
    {
      LinearCharacteristicStatsEvalTypeValue.LinearCharacter_1111->printSelf(outFile);
    }
  else if (LinearCharacteristicStatsEvalTypeType == MinValueStatsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      LinearCharacteristicStatsEvalTypeValue.MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  else if (LinearCharacteristicStatsEvalTypeType == LinearCharacter_1112E)
    {
      LinearCharacteristicStatsEvalTypeValue.LinearCharacter_1112->printSelf(outFile);
    }
  else if (LinearCharacteristicStatsEvalTypeType == LinearCharacter_1113E)
    {
      LinearCharacteristicStatsEvalTypeValue.LinearCharacter_1113->printSelf(outFile);
    }
  else if (LinearCharacteristicStatsEvalTypeType == MinDeviationStatsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      LinearCharacteristicStatsEvalTypeValue.MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

/* ***************************************************************** */

/* class LinearCoordinateCharacteristicStatsEvalType

*/

LinearCoordinateCharacteristicStatsEvalType::LinearCoordinateCharacteristicStatsEvalType() :
  LinearCharacteristicStatsEvalType() {}

LinearCoordinateCharacteristicStatsEvalType::LinearCoordinateCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 LinearCharacteristicStatsEvalTypeChoicePair * LinearCharacteristicStatsEvalTypePairIn) :
  LinearCharacteristicStatsEvalType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    LinearCharacteristicStatsEvalTypePairIn)
{}

LinearCoordinateCharacteristicStatsEvalType::~LinearCoordinateCharacteristicStatsEvalType() {}

void LinearCoordinateCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  LinearCharacteristicStatsEvalTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class LocationCharacteristicStatsEvalType

*/

LocationCharacteristicStatsEvalType::LocationCharacteristicStatsEvalType() :
  GeometricCharacteristicStatsEvalType()
{
  DatumsOkStats = 0;
}

LocationCharacteristicStatsEvalType::LocationCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsWithTolLinearType * ValueStatsIn,
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn,
 StatsPassFailType * DatumsOkStatsIn) :
  GeometricCharacteristicStatsEvalType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    ValueStatsIn,
    MaxValueStatsIn,
    MinValueStatsIn)
{
  DatumsOkStats = DatumsOkStatsIn;
}

LocationCharacteristicStatsEvalType::~LocationCharacteristicStatsEvalType()
{
  #ifndef NODESTRUCT
  delete DatumsOkStats;
  #endif
}

void LocationCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (ValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ValueStats");
      ValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ValueStats>\n");
    }
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  if (DatumsOkStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumsOkStats");
      DatumsOkStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DatumsOkStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

StatsPassFailType * LocationCharacteristicStatsEvalType::getDatumsOkStats()
{return DatumsOkStats;}

void LocationCharacteristicStatsEvalType::setDatumsOkStats(StatsPassFailType * DatumsOkStatsIn)
{DatumsOkStats = DatumsOkStatsIn;}

/* ***************************************************************** */

/* class OneSidedCapabilityCalculationEnumType

*/

OneSidedCapabilityCalculationEnumType::OneSidedCapabilityCalculationEnumType() :
  XmlNMTOKEN()
{
}

OneSidedCapabilityCalculationEnumType::OneSidedCapabilityCalculationEnumType(
 const char * valIn) :
  XmlNMTOKEN(
    valIn)
{
  if (!bad)
    bad = (strcmp(val.c_str(), "THREE_SIGMA") &&
           strcmp(val.c_str(), "SIX_SIGMA"));
}

OneSidedCapabilityCalculationEnumType::~OneSidedCapabilityCalculationEnumType() {}

bool OneSidedCapabilityCalculationEnumType::OneSidedCapabilityCalculationEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "THREE_SIGMA") &&
          strcmp(val.c_str(), "SIX_SIGMA"));
}

void OneSidedCapabilityCalculationEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "OneSidedCapabilityCalculationEnumType");
}

void OneSidedCapabilityCalculationEnumType::printSelf(FILE * outFile)
{
  if (OneSidedCapabilityCalculationEnumTypeIsBad())
    {
      fprintf(stderr, "bad OneSidedCapabilityCalculationEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::printSelf(outFile);
}

void OneSidedCapabilityCalculationEnumType::oPrintSelf(FILE * outFile)
{
  if (OneSidedCapabilityCalculationEnumTypeIsBad())
    {
      fprintf(stderr, "bad OneSidedCapabilityCalculationEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class OrientationCharacteristicStatsEvalType

*/

OrientationCharacteristicStatsEvalType::OrientationCharacteristicStatsEvalType() :
  GeometricCharacteristicStatsEvalType()
{
  CapabilityCalculationMethod = 0;
  DatumsOkStats = 0;
  BonusStats = 0;
  ReferenceLengthStats = 0;
}

OrientationCharacteristicStatsEvalType::OrientationCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsWithTolLinearType * ValueStatsIn,
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn,
 OneSidedCapabilityCalculationEnumType * CapabilityCalculationMethodIn,
 StatsPassFailType * DatumsOkStatsIn,
 StatsLinearType * BonusStatsIn,
 StatsLinearType * ReferenceLengthStatsIn) :
  GeometricCharacteristicStatsEvalType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    ValueStatsIn,
    MaxValueStatsIn,
    MinValueStatsIn)
{
  CapabilityCalculationMethod = CapabilityCalculationMethodIn;
  DatumsOkStats = DatumsOkStatsIn;
  BonusStats = BonusStatsIn;
  ReferenceLengthStats = ReferenceLengthStatsIn;
}

OrientationCharacteristicStatsEvalType::~OrientationCharacteristicStatsEvalType()
{
  #ifndef NODESTRUCT
  delete CapabilityCalculationMethod;
  delete DatumsOkStats;
  delete BonusStats;
  delete ReferenceLengthStats;
  #endif
}

void OrientationCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (ValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ValueStats");
      ValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ValueStats>\n");
    }
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  if (CapabilityCalculationMethod)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CapabilityCalculationMethod");
      CapabilityCalculationMethod->printSelf(outFile);
      fprintf(outFile, "</CapabilityCalculationMethod>\n");
    }
  if (DatumsOkStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumsOkStats");
      DatumsOkStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DatumsOkStats>\n");
    }
  if (BonusStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BonusStats");
      BonusStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BonusStats>\n");
    }
  if (ReferenceLengthStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ReferenceLengthStats");
      ReferenceLengthStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ReferenceLengthStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

OneSidedCapabilityCalculationEnumType * OrientationCharacteristicStatsEvalType::getCapabilityCalculationMethod()
{return CapabilityCalculationMethod;}

void OrientationCharacteristicStatsEvalType::setCapabilityCalculationMethod(OneSidedCapabilityCalculationEnumType * CapabilityCalculationMethodIn)
{CapabilityCalculationMethod = CapabilityCalculationMethodIn;}

StatsPassFailType * OrientationCharacteristicStatsEvalType::getDatumsOkStats()
{return DatumsOkStats;}

void OrientationCharacteristicStatsEvalType::setDatumsOkStats(StatsPassFailType * DatumsOkStatsIn)
{DatumsOkStats = DatumsOkStatsIn;}

StatsLinearType * OrientationCharacteristicStatsEvalType::getBonusStats()
{return BonusStats;}

void OrientationCharacteristicStatsEvalType::setBonusStats(StatsLinearType * BonusStatsIn)
{BonusStats = BonusStatsIn;}

StatsLinearType * OrientationCharacteristicStatsEvalType::getReferenceLengthStats()
{return ReferenceLengthStats;}

void OrientationCharacteristicStatsEvalType::setReferenceLengthStats(StatsLinearType * ReferenceLengthStatsIn)
{ReferenceLengthStats = ReferenceLengthStatsIn;}

/* ***************************************************************** */

/* class OtherFormCharacteristicStatsEvalType

*/

OtherFormCharacteristicStatsEvalType::OtherFormCharacteristicStatsEvalType() :
  FormCharacteristicStatsEvalBaseType() {}

OtherFormCharacteristicStatsEvalType::OtherFormCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsWithTolLinearType * ValueStatsIn,
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn,
 OneSidedCapabilityCalculationEnumType * CapabilityCalculationMethodIn) :
  FormCharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    ValueStatsIn,
    MaxValueStatsIn,
    MinValueStatsIn,
    CapabilityCalculationMethodIn)
{}

OtherFormCharacteristicStatsEvalType::~OtherFormCharacteristicStatsEvalType() {}

void OtherFormCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (ValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ValueStats");
      ValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ValueStats>\n");
    }
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  if (CapabilityCalculationMethod)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CapabilityCalculationMethod");
      CapabilityCalculationMethod->printSelf(outFile);
      fprintf(outFile, "</CapabilityCalculationMethod>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class ParallelismCharacteristicStatsEvalType

*/

ParallelismCharacteristicStatsEvalType::ParallelismCharacteristicStatsEvalType() :
  OrientationCharacteristicStatsEvalType() {}

ParallelismCharacteristicStatsEvalType::ParallelismCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsWithTolLinearType * ValueStatsIn,
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn,
 OneSidedCapabilityCalculationEnumType * CapabilityCalculationMethodIn,
 StatsPassFailType * DatumsOkStatsIn,
 StatsLinearType * BonusStatsIn,
 StatsLinearType * ReferenceLengthStatsIn) :
  OrientationCharacteristicStatsEvalType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    ValueStatsIn,
    MaxValueStatsIn,
    MinValueStatsIn,
    CapabilityCalculationMethodIn,
    DatumsOkStatsIn,
    BonusStatsIn,
    ReferenceLengthStatsIn)
{}

ParallelismCharacteristicStatsEvalType::~ParallelismCharacteristicStatsEvalType() {}

void ParallelismCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (ValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ValueStats");
      ValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ValueStats>\n");
    }
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  if (CapabilityCalculationMethod)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CapabilityCalculationMethod");
      CapabilityCalculationMethod->printSelf(outFile);
      fprintf(outFile, "</CapabilityCalculationMethod>\n");
    }
  if (DatumsOkStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumsOkStats");
      DatumsOkStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DatumsOkStats>\n");
    }
  if (BonusStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BonusStats");
      BonusStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BonusStats>\n");
    }
  if (ReferenceLengthStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ReferenceLengthStats");
      ReferenceLengthStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ReferenceLengthStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class PerpendicularityCharacteristicStatsEvalType

*/

PerpendicularityCharacteristicStatsEvalType::PerpendicularityCharacteristicStatsEvalType() :
  OrientationCharacteristicStatsEvalType() {}

PerpendicularityCharacteristicStatsEvalType::PerpendicularityCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsWithTolLinearType * ValueStatsIn,
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn,
 OneSidedCapabilityCalculationEnumType * CapabilityCalculationMethodIn,
 StatsPassFailType * DatumsOkStatsIn,
 StatsLinearType * BonusStatsIn,
 StatsLinearType * ReferenceLengthStatsIn) :
  OrientationCharacteristicStatsEvalType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    ValueStatsIn,
    MaxValueStatsIn,
    MinValueStatsIn,
    CapabilityCalculationMethodIn,
    DatumsOkStatsIn,
    BonusStatsIn,
    ReferenceLengthStatsIn)
{}

PerpendicularityCharacteristicStatsEvalType::~PerpendicularityCharacteristicStatsEvalType() {}

void PerpendicularityCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (ValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ValueStats");
      ValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ValueStats>\n");
    }
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  if (CapabilityCalculationMethod)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CapabilityCalculationMethod");
      CapabilityCalculationMethod->printSelf(outFile);
      fprintf(outFile, "</CapabilityCalculationMethod>\n");
    }
  if (DatumsOkStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumsOkStats");
      DatumsOkStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DatumsOkStats>\n");
    }
  if (BonusStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BonusStats");
      BonusStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BonusStats>\n");
    }
  if (ReferenceLengthStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ReferenceLengthStats");
      ReferenceLengthStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ReferenceLengthStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class PointDeviationStatsEvalType

*/

PointDeviationStatsEvalType::PointDeviationStatsEvalType()
{
  MeasuredPointIds = 0;
  DeviationStats = 0;
}

PointDeviationStatsEvalType::PointDeviationStatsEvalType(
 StatsArrayIdType * MeasuredPointIdsIn,
 StatsLinearType * DeviationStatsIn)
{
  MeasuredPointIds = MeasuredPointIdsIn;
  DeviationStats = DeviationStatsIn;
}

PointDeviationStatsEvalType::~PointDeviationStatsEvalType()
{
  #ifndef NODESTRUCT
  delete MeasuredPointIds;
  delete DeviationStats;
  #endif
}

void PointDeviationStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<MeasuredPointIds");
  MeasuredPointIds->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</MeasuredPointIds>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<DeviationStats");
  DeviationStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeviationStats>\n");
  doSpaces(-INDENT, outFile);
}

StatsArrayIdType * PointDeviationStatsEvalType::getMeasuredPointIds()
{return MeasuredPointIds;}

void PointDeviationStatsEvalType::setMeasuredPointIds(StatsArrayIdType * MeasuredPointIdsIn)
{MeasuredPointIds = MeasuredPointIdsIn;}

StatsLinearType * PointDeviationStatsEvalType::getDeviationStats()
{return DeviationStats;}

void PointDeviationStatsEvalType::setDeviationStats(StatsLinearType * DeviationStatsIn)
{DeviationStats = DeviationStatsIn;}

/* ***************************************************************** */

/* class PointDeviationStatsEvalTypeLisd

*/

PointDeviationStatsEvalTypeLisd::PointDeviationStatsEvalTypeLisd() {}

PointDeviationStatsEvalTypeLisd::PointDeviationStatsEvalTypeLisd(PointDeviationStatsEvalType * aPointDeviationStatsEvalType)
{
  push_back(aPointDeviationStatsEvalType);
}

PointDeviationStatsEvalTypeLisd::~PointDeviationStatsEvalTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<PointDeviationStatsEvalType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void PointDeviationStatsEvalTypeLisd::printSelf(FILE * outFile)
{
  std::list<PointDeviationStatsEvalType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class PointDeviationsStatsEvalType

*/

PointDeviationsStatsEvalType::PointDeviationsStatsEvalType()
{
  n = 0;
  PointDeviationStats = 0;
}

PointDeviationsStatsEvalType::PointDeviationsStatsEvalType(
 PointDeviationStatsEvalTypeLisd * PointDeviationStatsIn)
{
  n = 0;
  PointDeviationStats = PointDeviationStatsIn;
}

PointDeviationsStatsEvalType::PointDeviationsStatsEvalType(
 NaturalType * nIn,
 PointDeviationStatsEvalTypeLisd * PointDeviationStatsIn)
{
  n = nIn;
  PointDeviationStats = PointDeviationStatsIn;
}

PointDeviationsStatsEvalType::~PointDeviationsStatsEvalType()
{
  #ifndef NODESTRUCT
  delete n;
  delete PointDeviationStats;
  #endif
}

void PointDeviationsStatsEvalType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!PointDeviationStats)
      {
        fprintf(stderr, "PointDeviationStats list is missing\n");
        exit(1);
      }
    if (PointDeviationStats->size() == 0)
      {
        fprintf(stderr, "PointDeviationStats list is empty\n");
        exit(1);
      }
    if (PointDeviationStats->size() < 1)
      {
        fprintf(stderr,
                "size of PointDeviationStats list (%d) less than minimum required (1)\n",
                (int)PointDeviationStats->size());
        exit(1);
      }
    std::list<PointDeviationStatsEvalType *>::iterator iter;
    for (iter = PointDeviationStats->begin();
         iter != PointDeviationStats->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<PointDeviationStats");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</PointDeviationStats>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool PointDeviationsStatsEvalType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in PointDeviationsStatsEvalType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->val.c_str());
          if (nVal->bad)
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in PointDeviationsStatsEvalType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in PointDeviationsStatsEvalType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in PointDeviationsStatsEvalType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * PointDeviationsStatsEvalType::getn()
{return n;}

void PointDeviationsStatsEvalType::setn(NaturalType * nIn)
{n = nIn;}

PointDeviationStatsEvalTypeLisd * PointDeviationsStatsEvalType::getPointDeviationStats()
{return PointDeviationStats;}

void PointDeviationsStatsEvalType::setPointDeviationStats(PointDeviationStatsEvalTypeLisd * PointDeviationStatsIn)
{PointDeviationStats = PointDeviationStatsIn;}

/* ***************************************************************** */

/* class PointProfileCharacteristicStatsEvalType

*/

PointProfileCharacteristicStatsEvalType::PointProfileCharacteristicStatsEvalType() :
  ProfileCharacteristicStatsEvalBaseType() {}

PointProfileCharacteristicStatsEvalType::PointProfileCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsWithTolLinearType * ValueStatsIn,
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn,
 OneSidedCapabilityCalculationEnumType * CapabilityCalculationMethodIn,
 StatsLinearType * WorstPositiveDeviationStatsIn,
 StatsLinearType * WorstNegativeDeviationStatsIn,
 PointDeviationsStatsEvalType * PointDeviationsStatsIn,
 StatsPassFailType * DatumsOkStatsIn,
 CompositeSegmentsProfileStatsEvalType * CompositeSegmentsStatsIn) :
  ProfileCharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    ValueStatsIn,
    MaxValueStatsIn,
    MinValueStatsIn,
    CapabilityCalculationMethodIn,
    WorstPositiveDeviationStatsIn,
    WorstNegativeDeviationStatsIn,
    PointDeviationsStatsIn,
    DatumsOkStatsIn,
    CompositeSegmentsStatsIn)
{}

PointProfileCharacteristicStatsEvalType::~PointProfileCharacteristicStatsEvalType() {}

void PointProfileCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (ValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ValueStats");
      ValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ValueStats>\n");
    }
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  if (CapabilityCalculationMethod)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CapabilityCalculationMethod");
      CapabilityCalculationMethod->printSelf(outFile);
      fprintf(outFile, "</CapabilityCalculationMethod>\n");
    }
  if (WorstPositiveDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WorstPositiveDeviationStats");
      WorstPositiveDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WorstPositiveDeviationStats>\n");
    }
  if (WorstNegativeDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WorstNegativeDeviationStats");
      WorstNegativeDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WorstNegativeDeviationStats>\n");
    }
  if (PointDeviationsStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointDeviationsStats");
      PointDeviationsStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointDeviationsStats>\n");
    }
  if (DatumsOkStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumsOkStats");
      DatumsOkStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DatumsOkStats>\n");
    }
  if (CompositeSegmentsStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CompositeSegmentsStats");
      CompositeSegmentsStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CompositeSegmentsStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class PositionCapabilityCalculationEnumType

*/

PositionCapabilityCalculationEnumType::PositionCapabilityCalculationEnumType() :
  XmlNMTOKEN()
{
}

PositionCapabilityCalculationEnumType::PositionCapabilityCalculationEnumType(
 const char * valIn) :
  XmlNMTOKEN(
    valIn)
{
  if (!bad)
    bad = (strcmp(val.c_str(), "THREE_SIGMA") &&
           strcmp(val.c_str(), "SIX_SIGMA") &&
           strcmp(val.c_str(), "BIVARIATE") &&
           strcmp(val.c_str(), "TRIVARIATE"));
}

PositionCapabilityCalculationEnumType::~PositionCapabilityCalculationEnumType() {}

bool PositionCapabilityCalculationEnumType::PositionCapabilityCalculationEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "THREE_SIGMA") &&
          strcmp(val.c_str(), "SIX_SIGMA") &&
          strcmp(val.c_str(), "BIVARIATE") &&
          strcmp(val.c_str(), "TRIVARIATE"));
}

void PositionCapabilityCalculationEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "PositionCapabilityCalculationEnumType");
}

void PositionCapabilityCalculationEnumType::printSelf(FILE * outFile)
{
  if (PositionCapabilityCalculationEnumTypeIsBad())
    {
      fprintf(stderr, "bad PositionCapabilityCalculationEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::printSelf(outFile);
}

void PositionCapabilityCalculationEnumType::oPrintSelf(FILE * outFile)
{
  if (PositionCapabilityCalculationEnumTypeIsBad())
    {
      fprintf(stderr, "bad PositionCapabilityCalculationEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class PositionCharacteristicStatsEvalType

*/

PositionCharacteristicStatsEvalType::PositionCharacteristicStatsEvalType() :
  LocationCharacteristicStatsEvalType()
{
  BonusStats = 0;
  CapabilityCalculationMethod = 0;
  CompositeSegmentsStats = 0;
}

PositionCharacteristicStatsEvalType::PositionCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsWithTolLinearType * ValueStatsIn,
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn,
 StatsPassFailType * DatumsOkStatsIn,
 StatsLinearType * BonusStatsIn,
 PositionCapabilityCalculationEnumType * CapabilityCalculationMethodIn,
 CompositeSegmentsPositionStatsEvalType * CompositeSegmentsStatsIn) :
  LocationCharacteristicStatsEvalType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    ValueStatsIn,
    MaxValueStatsIn,
    MinValueStatsIn,
    DatumsOkStatsIn)
{
  BonusStats = BonusStatsIn;
  CapabilityCalculationMethod = CapabilityCalculationMethodIn;
  CompositeSegmentsStats = CompositeSegmentsStatsIn;
}

PositionCharacteristicStatsEvalType::~PositionCharacteristicStatsEvalType()
{
  #ifndef NODESTRUCT
  delete BonusStats;
  delete CapabilityCalculationMethod;
  delete CompositeSegmentsStats;
  #endif
}

void PositionCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (ValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ValueStats");
      ValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ValueStats>\n");
    }
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  if (DatumsOkStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumsOkStats");
      DatumsOkStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DatumsOkStats>\n");
    }
  if (BonusStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BonusStats");
      BonusStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BonusStats>\n");
    }
  if (CapabilityCalculationMethod)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CapabilityCalculationMethod");
      CapabilityCalculationMethod->printSelf(outFile);
      fprintf(outFile, "</CapabilityCalculationMethod>\n");
    }
  if (CompositeSegmentsStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CompositeSegmentsStats");
      CompositeSegmentsStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CompositeSegmentsStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

StatsLinearType * PositionCharacteristicStatsEvalType::getBonusStats()
{return BonusStats;}

void PositionCharacteristicStatsEvalType::setBonusStats(StatsLinearType * BonusStatsIn)
{BonusStats = BonusStatsIn;}

PositionCapabilityCalculationEnumType * PositionCharacteristicStatsEvalType::getCapabilityCalculationMethod()
{return CapabilityCalculationMethod;}

void PositionCharacteristicStatsEvalType::setCapabilityCalculationMethod(PositionCapabilityCalculationEnumType * CapabilityCalculationMethodIn)
{CapabilityCalculationMethod = CapabilityCalculationMethodIn;}

CompositeSegmentsPositionStatsEvalType * PositionCharacteristicStatsEvalType::getCompositeSegmentsStats()
{return CompositeSegmentsStats;}

void PositionCharacteristicStatsEvalType::setCompositeSegmentsStats(CompositeSegmentsPositionStatsEvalType * CompositeSegmentsStatsIn)
{CompositeSegmentsStats = CompositeSegmentsStatsIn;}

/* ***************************************************************** */

/* class ProfileCharacteristicStatsEvalBaseType

*/

ProfileCharacteristicStatsEvalBaseType::ProfileCharacteristicStatsEvalBaseType() :
  GeometricCharacteristicStatsEvalType()
{
  CapabilityCalculationMethod = 0;
  WorstPositiveDeviationStats = 0;
  WorstNegativeDeviationStats = 0;
  PointDeviationsStats = 0;
  DatumsOkStats = 0;
  CompositeSegmentsStats = 0;
}

ProfileCharacteristicStatsEvalBaseType::ProfileCharacteristicStatsEvalBaseType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsWithTolLinearType * ValueStatsIn,
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn,
 OneSidedCapabilityCalculationEnumType * CapabilityCalculationMethodIn,
 StatsLinearType * WorstPositiveDeviationStatsIn,
 StatsLinearType * WorstNegativeDeviationStatsIn,
 PointDeviationsStatsEvalType * PointDeviationsStatsIn,
 StatsPassFailType * DatumsOkStatsIn,
 CompositeSegmentsProfileStatsEvalType * CompositeSegmentsStatsIn) :
  GeometricCharacteristicStatsEvalType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    ValueStatsIn,
    MaxValueStatsIn,
    MinValueStatsIn)
{
  CapabilityCalculationMethod = CapabilityCalculationMethodIn;
  WorstPositiveDeviationStats = WorstPositiveDeviationStatsIn;
  WorstNegativeDeviationStats = WorstNegativeDeviationStatsIn;
  PointDeviationsStats = PointDeviationsStatsIn;
  DatumsOkStats = DatumsOkStatsIn;
  CompositeSegmentsStats = CompositeSegmentsStatsIn;
}

ProfileCharacteristicStatsEvalBaseType::~ProfileCharacteristicStatsEvalBaseType()
{
  #ifndef NODESTRUCT
  delete CapabilityCalculationMethod;
  delete WorstPositiveDeviationStats;
  delete WorstNegativeDeviationStats;
  delete PointDeviationsStats;
  delete DatumsOkStats;
  delete CompositeSegmentsStats;
  #endif
}

void ProfileCharacteristicStatsEvalBaseType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (ValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ValueStats");
      ValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ValueStats>\n");
    }
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  if (CapabilityCalculationMethod)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CapabilityCalculationMethod");
      CapabilityCalculationMethod->printSelf(outFile);
      fprintf(outFile, "</CapabilityCalculationMethod>\n");
    }
  if (WorstPositiveDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WorstPositiveDeviationStats");
      WorstPositiveDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WorstPositiveDeviationStats>\n");
    }
  if (WorstNegativeDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WorstNegativeDeviationStats");
      WorstNegativeDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WorstNegativeDeviationStats>\n");
    }
  if (PointDeviationsStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointDeviationsStats");
      PointDeviationsStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointDeviationsStats>\n");
    }
  if (DatumsOkStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumsOkStats");
      DatumsOkStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DatumsOkStats>\n");
    }
  if (CompositeSegmentsStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CompositeSegmentsStats");
      CompositeSegmentsStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CompositeSegmentsStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

OneSidedCapabilityCalculationEnumType * ProfileCharacteristicStatsEvalBaseType::getCapabilityCalculationMethod()
{return CapabilityCalculationMethod;}

void ProfileCharacteristicStatsEvalBaseType::setCapabilityCalculationMethod(OneSidedCapabilityCalculationEnumType * CapabilityCalculationMethodIn)
{CapabilityCalculationMethod = CapabilityCalculationMethodIn;}

StatsLinearType * ProfileCharacteristicStatsEvalBaseType::getWorstPositiveDeviationStats()
{return WorstPositiveDeviationStats;}

void ProfileCharacteristicStatsEvalBaseType::setWorstPositiveDeviationStats(StatsLinearType * WorstPositiveDeviationStatsIn)
{WorstPositiveDeviationStats = WorstPositiveDeviationStatsIn;}

StatsLinearType * ProfileCharacteristicStatsEvalBaseType::getWorstNegativeDeviationStats()
{return WorstNegativeDeviationStats;}

void ProfileCharacteristicStatsEvalBaseType::setWorstNegativeDeviationStats(StatsLinearType * WorstNegativeDeviationStatsIn)
{WorstNegativeDeviationStats = WorstNegativeDeviationStatsIn;}

PointDeviationsStatsEvalType * ProfileCharacteristicStatsEvalBaseType::getPointDeviationsStats()
{return PointDeviationsStats;}

void ProfileCharacteristicStatsEvalBaseType::setPointDeviationsStats(PointDeviationsStatsEvalType * PointDeviationsStatsIn)
{PointDeviationsStats = PointDeviationsStatsIn;}

StatsPassFailType * ProfileCharacteristicStatsEvalBaseType::getDatumsOkStats()
{return DatumsOkStats;}

void ProfileCharacteristicStatsEvalBaseType::setDatumsOkStats(StatsPassFailType * DatumsOkStatsIn)
{DatumsOkStats = DatumsOkStatsIn;}

CompositeSegmentsProfileStatsEvalType * ProfileCharacteristicStatsEvalBaseType::getCompositeSegmentsStats()
{return CompositeSegmentsStats;}

void ProfileCharacteristicStatsEvalBaseType::setCompositeSegmentsStats(CompositeSegmentsProfileStatsEvalType * CompositeSegmentsStatsIn)
{CompositeSegmentsStats = CompositeSegmentsStatsIn;}

/* ***************************************************************** */

/* class RadiusCharacteristicStatsEvalType

*/

RadiusCharacteristicStatsEvalType::RadiusCharacteristicStatsEvalType() :
  LinearCharacteristicStatsEvalType() {}

RadiusCharacteristicStatsEvalType::RadiusCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 LinearCharacteristicStatsEvalTypeChoicePair * LinearCharacteristicStatsEvalTypePairIn) :
  LinearCharacteristicStatsEvalType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    LinearCharacteristicStatsEvalTypePairIn)
{}

RadiusCharacteristicStatsEvalType::~RadiusCharacteristicStatsEvalType() {}

void RadiusCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  LinearCharacteristicStatsEvalTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class RunoutCharacteristicStatsEvalBaseType

*/

RunoutCharacteristicStatsEvalBaseType::RunoutCharacteristicStatsEvalBaseType() :
  GeometricCharacteristicStatsEvalType()
{
  CapabilityCalculationMethod = 0;
  DatumsOkStats = 0;
}

RunoutCharacteristicStatsEvalBaseType::RunoutCharacteristicStatsEvalBaseType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsWithTolLinearType * ValueStatsIn,
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn,
 OneSidedCapabilityCalculationEnumType * CapabilityCalculationMethodIn,
 StatsPassFailType * DatumsOkStatsIn) :
  GeometricCharacteristicStatsEvalType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    ValueStatsIn,
    MaxValueStatsIn,
    MinValueStatsIn)
{
  CapabilityCalculationMethod = CapabilityCalculationMethodIn;
  DatumsOkStats = DatumsOkStatsIn;
}

RunoutCharacteristicStatsEvalBaseType::~RunoutCharacteristicStatsEvalBaseType()
{
  #ifndef NODESTRUCT
  delete CapabilityCalculationMethod;
  delete DatumsOkStats;
  #endif
}

void RunoutCharacteristicStatsEvalBaseType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (ValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ValueStats");
      ValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ValueStats>\n");
    }
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  if (CapabilityCalculationMethod)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CapabilityCalculationMethod");
      CapabilityCalculationMethod->printSelf(outFile);
      fprintf(outFile, "</CapabilityCalculationMethod>\n");
    }
  if (DatumsOkStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumsOkStats");
      DatumsOkStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DatumsOkStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

OneSidedCapabilityCalculationEnumType * RunoutCharacteristicStatsEvalBaseType::getCapabilityCalculationMethod()
{return CapabilityCalculationMethod;}

void RunoutCharacteristicStatsEvalBaseType::setCapabilityCalculationMethod(OneSidedCapabilityCalculationEnumType * CapabilityCalculationMethodIn)
{CapabilityCalculationMethod = CapabilityCalculationMethodIn;}

StatsPassFailType * RunoutCharacteristicStatsEvalBaseType::getDatumsOkStats()
{return DatumsOkStats;}

void RunoutCharacteristicStatsEvalBaseType::setDatumsOkStats(StatsPassFailType * DatumsOkStatsIn)
{DatumsOkStats = DatumsOkStatsIn;}

/* ***************************************************************** */

/* class SamplingIntervalEnumType

*/

SamplingIntervalEnumType::SamplingIntervalEnumType() :
  XmlNMTOKEN()
{
}

SamplingIntervalEnumType::SamplingIntervalEnumType(
 const char * valIn) :
  XmlNMTOKEN(
    valIn)
{
  if (!bad)
    bad = (strcmp(val.c_str(), "SHIFT") &&
           strcmp(val.c_str(), "DAY") &&
           strcmp(val.c_str(), "HOUR") &&
           strcmp(val.c_str(), "WEEK") &&
           strcmp(val.c_str(), "MONTH") &&
           strcmp(val.c_str(), "BATCH") &&
           strcmp(val.c_str(), "LOT"));
}

SamplingIntervalEnumType::~SamplingIntervalEnumType() {}

bool SamplingIntervalEnumType::SamplingIntervalEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "SHIFT") &&
          strcmp(val.c_str(), "DAY") &&
          strcmp(val.c_str(), "HOUR") &&
          strcmp(val.c_str(), "WEEK") &&
          strcmp(val.c_str(), "MONTH") &&
          strcmp(val.c_str(), "BATCH") &&
          strcmp(val.c_str(), "LOT"));
}

void SamplingIntervalEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "SamplingIntervalEnumType");
}

void SamplingIntervalEnumType::printSelf(FILE * outFile)
{
  if (SamplingIntervalEnumTypeIsBad())
    {
      fprintf(stderr, "bad SamplingIntervalEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::printSelf(outFile);
}

void SamplingIntervalEnumType::oPrintSelf(FILE * outFile)
{
  if (SamplingIntervalEnumTypeIsBad())
    {
      fprintf(stderr, "bad SamplingIntervalEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class SamplingIntervalType

*/

SamplingIntervalType::SamplingIntervalType()
{
  SamplingIntervalTypePair = 0;
}

SamplingIntervalType::SamplingIntervalType(
 SamplingIntervalTypeChoicePair * SamplingIntervalTypePairIn)
{
  SamplingIntervalTypePair = SamplingIntervalTypePairIn;
}

SamplingIntervalType::~SamplingIntervalType()
{
  #ifndef NODESTRUCT
  delete SamplingIntervalTypePair;
  #endif
}

void SamplingIntervalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  SamplingIntervalTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

SamplingIntervalTypeChoicePair * SamplingIntervalType::getSamplingIntervalTypePair()
{return SamplingIntervalTypePair;}

void SamplingIntervalType::setSamplingIntervalTypePair(SamplingIntervalTypeChoicePair * SamplingIntervalTypePairIn)
{SamplingIntervalTypePair = SamplingIntervalTypePairIn;}
SamplingIntervalTypeChoicePair::SamplingIntervalTypeChoicePair() {}

SamplingIntervalTypeChoicePair::SamplingIntervalTypeChoicePair(
 whichOne SamplingIntervalTypeTypeIn,
 SamplingIntervalTypeVal SamplingIntervalTypeValueIn)
{
  SamplingIntervalTypeType = SamplingIntervalTypeTypeIn;
  SamplingIntervalTypeValue = SamplingIntervalTypeValueIn;
}

SamplingIntervalTypeChoicePair::~SamplingIntervalTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (SamplingIntervalTypeType == SamplingIntervalEnumE)
    delete SamplingIntervalTypeValue.SamplingIntervalEnum;
  else if (SamplingIntervalTypeType == OtherSamplingIntervalE)
    delete SamplingIntervalTypeValue.OtherSamplingInterval;
  #endif
}

void SamplingIntervalTypeChoicePair::printSelf(FILE * outFile)
{
  if (SamplingIntervalTypeType == SamplingIntervalEnumE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SamplingIntervalEnum");
      SamplingIntervalTypeValue.SamplingIntervalEnum->printSelf(outFile);
      fprintf(outFile, "</SamplingIntervalEnum>\n");
    }
  else if (SamplingIntervalTypeType == OtherSamplingIntervalE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OtherSamplingInterval");
      SamplingIntervalTypeValue.OtherSamplingInterval->printSelf(outFile);
      fprintf(outFile, "</OtherSamplingInterval>\n");
    }
}

/* ***************************************************************** */

/* class SamplingMethodType

*/

SamplingMethodType::SamplingMethodType()
{
  SampleSize = 0;
  SamplingMethodT_1114 = 0;
}

SamplingMethodType::SamplingMethodType(
 XmlPositiveInteger * SampleSizeIn,
 SamplingMethodT_1114_Type * SamplingMethodT_1114In)
{
  SampleSize = SampleSizeIn;
  SamplingMethodT_1114 = SamplingMethodT_1114In;
}

SamplingMethodType::~SamplingMethodType()
{
  #ifndef NODESTRUCT
  delete SampleSize;
  delete SamplingMethodT_1114;
  #endif
}

void SamplingMethodType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<SampleSize");
  SampleSize->printSelf(outFile);
  fprintf(outFile, "</SampleSize>\n");
  SamplingMethodT_1114->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

XmlPositiveInteger * SamplingMethodType::getSampleSize()
{return SampleSize;}

void SamplingMethodType::setSampleSize(XmlPositiveInteger * SampleSizeIn)
{SampleSize = SampleSizeIn;}

SamplingMethodT_1114_Type * SamplingMethodType::getSamplingMethodT_1114()
{return SamplingMethodT_1114;}

void SamplingMethodType::setSamplingMethodT_1114(SamplingMethodT_1114_Type * SamplingMethodT_1114In)
{SamplingMethodT_1114 = SamplingMethodT_1114In;}

/* ***************************************************************** */

/* class SphericalDiameterCharacteristicStatsEvalType

*/

SphericalDiameterCharacteristicStatsEvalType::SphericalDiameterCharacteristicStatsEvalType() :
  LinearCharacteristicStatsEvalType() {}

SphericalDiameterCharacteristicStatsEvalType::SphericalDiameterCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 LinearCharacteristicStatsEvalTypeChoicePair * LinearCharacteristicStatsEvalTypePairIn) :
  LinearCharacteristicStatsEvalType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    LinearCharacteristicStatsEvalTypePairIn)
{}

SphericalDiameterCharacteristicStatsEvalType::~SphericalDiameterCharacteristicStatsEvalType() {}

void SphericalDiameterCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  LinearCharacteristicStatsEvalTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class SphericalRadiusCharacteristicStatsEvalType

*/

SphericalRadiusCharacteristicStatsEvalType::SphericalRadiusCharacteristicStatsEvalType() :
  LinearCharacteristicStatsEvalType() {}

SphericalRadiusCharacteristicStatsEvalType::SphericalRadiusCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 LinearCharacteristicStatsEvalTypeChoicePair * LinearCharacteristicStatsEvalTypePairIn) :
  LinearCharacteristicStatsEvalType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    LinearCharacteristicStatsEvalTypePairIn)
{}

SphericalRadiusCharacteristicStatsEvalType::~SphericalRadiusCharacteristicStatsEvalType() {}

void SphericalRadiusCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  LinearCharacteristicStatsEvalTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class SphericityCharacteristicStatsEvalType

*/

SphericityCharacteristicStatsEvalType::SphericityCharacteristicStatsEvalType() :
  FormCharacteristicStatsEvalBaseType() {}

SphericityCharacteristicStatsEvalType::SphericityCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsWithTolLinearType * ValueStatsIn,
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn,
 OneSidedCapabilityCalculationEnumType * CapabilityCalculationMethodIn) :
  FormCharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    ValueStatsIn,
    MaxValueStatsIn,
    MinValueStatsIn,
    CapabilityCalculationMethodIn)
{}

SphericityCharacteristicStatsEvalType::~SphericityCharacteristicStatsEvalType() {}

void SphericityCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (ValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ValueStats");
      ValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ValueStats>\n");
    }
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  if (CapabilityCalculationMethod)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CapabilityCalculationMethod");
      CapabilityCalculationMethod->printSelf(outFile);
      fprintf(outFile, "</CapabilityCalculationMethod>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class SquareCharacteristicStatsEvalType

*/

SquareCharacteristicStatsEvalType::SquareCharacteristicStatsEvalType() :
  LinearCharacteristicStatsEvalType() {}

SquareCharacteristicStatsEvalType::SquareCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 LinearCharacteristicStatsEvalTypeChoicePair * LinearCharacteristicStatsEvalTypePairIn) :
  LinearCharacteristicStatsEvalType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    LinearCharacteristicStatsEvalTypePairIn)
{}

SquareCharacteristicStatsEvalType::~SquareCharacteristicStatsEvalType() {}

void SquareCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  LinearCharacteristicStatsEvalTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class StatsAngularType

*/

StatsAngularType::StatsAngularType() :
  StatsNumericalBaseType()
{
  angularUnit = 0;
}

StatsAngularType::StatsAngularType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicStatsValueIn) :
  StatsNumericalBaseType(
    AttributesIn,
    NumericCharacteristicStatsValueIn)
{
  angularUnit = 0;
}

StatsAngularType::StatsAngularType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicStatsValueIn,
 XmlToken * angularUnitIn) :
  StatsNumericalBaseType(
    AttributesIn,
    NumericCharacteristicStatsValueIn)
{
  angularUnit = angularUnitIn;
}

StatsAngularType::~StatsAngularType()
{
  #ifndef NODESTRUCT
  delete angularUnit;
  #endif
}

void StatsAngularType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (angularUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "angularUnit=\"");
      angularUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  {
    if (!NumericCharacteristicStatsValue)
      {
        fprintf(stderr, "NumericCharacteristicStatsValue list is missing\n");
        exit(1);
      }
    if (NumericCharacteristicStatsValue->size() == 0)
      {
        fprintf(stderr, "NumericCharacteristicStatsValue list is empty\n");
        exit(1);
      }
    if (NumericCharacteristicStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of NumericCharacteristicStatsValue list (%d) less than minimum required (1)\n",
                (int)NumericCharacteristicStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = NumericCharacteristicStatsValue->begin();
         iter != NumericCharacteristicStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "CommonStatsValue") == 0)
          {
            StatsWithReferenceBaseType * typ;
            if ((typ = dynamic_cast<StatsWithReferenceBaseType *>(basie)))
              {
                fprintf(outFile, "<CommonStatsValue");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CommonStatsValue>\n");
              }
            else
              {
                fprintf(stderr, "bad CommonStatsValue element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Average") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Average");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Average>\n");
              }
            else
              {
                fprintf(stderr, "bad Average element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupAverages") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupAverages");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupAverages>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupAverages element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Difference") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Difference");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Difference>\n");
              }
            else
              {
                fprintf(stderr, "bad Difference element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupDifferences") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupDifferences");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupDifferences>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupDifferences element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RootMeanSquare") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RootMeanSquare");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RootMeanSquare>\n");
              }
            else
              {
                fprintf(stderr, "bad RootMeanSquare element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Maximum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Maximum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Maximum>\n");
              }
            else
              {
                fprintf(stderr, "bad Maximum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMaxima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMaxima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMaxima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMaxima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Minimum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Minimum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Minimum>\n");
              }
            else
              {
                fprintf(stderr, "bad Minimum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMinima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMinima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMinima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMinima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Range") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Range");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Range>\n");
              }
            else
              {
                fprintf(stderr, "bad Range element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupRanges") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupRanges");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupRanges>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupRanges element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AverageRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AverageRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AverageRange>\n");
              }
            else
              {
                fprintf(stderr, "bad AverageRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "StandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<StandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</StandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad StandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Skew") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Skew");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Skew>\n");
              }
            else
              {
                fprintf(stderr, "bad Skew element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Kurtosis") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Kurtosis");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Kurtosis>\n");
              }
            else
              {
                fprintf(stderr, "bad Kurtosis element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Normality") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Normality");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Normality>\n");
              }
            else
              {
                fprintf(stderr, "bad Normality element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "ProcessVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<ProcessVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ProcessVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad ProcessVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EstimatedStandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EstimatedStandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EstimatedStandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad EstimatedStandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOutOfControl") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOutOfControl");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOutOfControl>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOutOfControl element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AppraiserVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AppraiserVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AppraiserVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad AppraiserVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EquipmentVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EquipmentVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EquipmentVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad EquipmentVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Interaction") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Interaction");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Interaction>\n");
              }
            else
              {
                fprintf(stderr, "bad Interaction element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GageRandR") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GageRandR");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GageRandR>\n");
              }
            else
              {
                fprintf(stderr, "bad GageRandR element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "PartVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<PartVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PartVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad PartVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TotalVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Linearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Linearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Linearity>\n");
              }
            else
              {
                fprintf(stderr, "bad Linearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Bias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Bias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Bias>\n");
              }
            else
              {
                fprintf(stderr, "bad Bias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeLinearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeLinearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeLinearity>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeLinearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeBias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeBias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeBias>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeBias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GoodnessOfFit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GoodnessOfFit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GoodnessOfFit>\n");
              }
            else
              {
                fprintf(stderr, "bad GoodnessOfFit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionSlope") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionSlope");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionSlope>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionSlope element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionIntercept") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionIntercept");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionIntercept>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionIntercept element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TDistribution") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TDistribution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TDistribution>\n");
              }
            else
              {
                fprintf(stderr, "bad TDistribution element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<TotalNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupTotalNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupTotalNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupTotalNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupTotalNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EffectiveNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<EffectiveNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupEffectiveNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupEffectiveNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupEffectiveNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupEffectiveNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberSubgroups") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberSubgroups");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberSubgroups>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberSubgroups element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad NumericCharacteristicStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool StatsAngularType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "angularUnit")
        {
          XmlToken * angularUnitVal;
          if (this->angularUnit)
            {
              fprintf(stderr, "two values for angularUnit in StatsAngularType\n");
              returnValue = true;
              break;
            }
          angularUnitVal = new XmlToken(decl->val.c_str());
          if (angularUnitVal->bad)
            {
              delete angularUnitVal;
              fprintf(stderr, "bad value %s for angularUnit in StatsAngularType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->angularUnit = angularUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in StatsAngularType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->angularUnit;
      this->angularUnit = 0;
    }
  return returnValue;
}

XmlToken * StatsAngularType::getangularUnit()
{return angularUnit;}

void StatsAngularType::setangularUnit(XmlToken * angularUnitIn)
{angularUnit = angularUnitIn;}

/* ***************************************************************** */

/* class StatsAreaType

*/

StatsAreaType::StatsAreaType() :
  StatsNumericalBaseType()
{
  areaUnit = 0;
}

StatsAreaType::StatsAreaType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicStatsValueIn) :
  StatsNumericalBaseType(
    AttributesIn,
    NumericCharacteristicStatsValueIn)
{
  areaUnit = 0;
}

StatsAreaType::StatsAreaType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicStatsValueIn,
 XmlToken * areaUnitIn) :
  StatsNumericalBaseType(
    AttributesIn,
    NumericCharacteristicStatsValueIn)
{
  areaUnit = areaUnitIn;
}

StatsAreaType::~StatsAreaType()
{
  #ifndef NODESTRUCT
  delete areaUnit;
  #endif
}

void StatsAreaType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (areaUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "areaUnit=\"");
      areaUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  {
    if (!NumericCharacteristicStatsValue)
      {
        fprintf(stderr, "NumericCharacteristicStatsValue list is missing\n");
        exit(1);
      }
    if (NumericCharacteristicStatsValue->size() == 0)
      {
        fprintf(stderr, "NumericCharacteristicStatsValue list is empty\n");
        exit(1);
      }
    if (NumericCharacteristicStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of NumericCharacteristicStatsValue list (%d) less than minimum required (1)\n",
                (int)NumericCharacteristicStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = NumericCharacteristicStatsValue->begin();
         iter != NumericCharacteristicStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "CommonStatsValue") == 0)
          {
            StatsWithReferenceBaseType * typ;
            if ((typ = dynamic_cast<StatsWithReferenceBaseType *>(basie)))
              {
                fprintf(outFile, "<CommonStatsValue");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CommonStatsValue>\n");
              }
            else
              {
                fprintf(stderr, "bad CommonStatsValue element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Average") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Average");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Average>\n");
              }
            else
              {
                fprintf(stderr, "bad Average element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupAverages") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupAverages");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupAverages>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupAverages element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Difference") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Difference");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Difference>\n");
              }
            else
              {
                fprintf(stderr, "bad Difference element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupDifferences") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupDifferences");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupDifferences>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupDifferences element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RootMeanSquare") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RootMeanSquare");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RootMeanSquare>\n");
              }
            else
              {
                fprintf(stderr, "bad RootMeanSquare element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Maximum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Maximum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Maximum>\n");
              }
            else
              {
                fprintf(stderr, "bad Maximum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMaxima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMaxima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMaxima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMaxima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Minimum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Minimum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Minimum>\n");
              }
            else
              {
                fprintf(stderr, "bad Minimum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMinima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMinima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMinima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMinima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Range") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Range");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Range>\n");
              }
            else
              {
                fprintf(stderr, "bad Range element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupRanges") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupRanges");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupRanges>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupRanges element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AverageRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AverageRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AverageRange>\n");
              }
            else
              {
                fprintf(stderr, "bad AverageRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "StandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<StandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</StandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad StandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Skew") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Skew");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Skew>\n");
              }
            else
              {
                fprintf(stderr, "bad Skew element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Kurtosis") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Kurtosis");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Kurtosis>\n");
              }
            else
              {
                fprintf(stderr, "bad Kurtosis element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Normality") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Normality");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Normality>\n");
              }
            else
              {
                fprintf(stderr, "bad Normality element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "ProcessVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<ProcessVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ProcessVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad ProcessVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EstimatedStandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EstimatedStandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EstimatedStandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad EstimatedStandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOutOfControl") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOutOfControl");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOutOfControl>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOutOfControl element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AppraiserVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AppraiserVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AppraiserVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad AppraiserVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EquipmentVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EquipmentVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EquipmentVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad EquipmentVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Interaction") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Interaction");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Interaction>\n");
              }
            else
              {
                fprintf(stderr, "bad Interaction element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GageRandR") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GageRandR");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GageRandR>\n");
              }
            else
              {
                fprintf(stderr, "bad GageRandR element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "PartVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<PartVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PartVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad PartVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TotalVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Linearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Linearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Linearity>\n");
              }
            else
              {
                fprintf(stderr, "bad Linearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Bias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Bias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Bias>\n");
              }
            else
              {
                fprintf(stderr, "bad Bias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeLinearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeLinearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeLinearity>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeLinearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeBias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeBias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeBias>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeBias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GoodnessOfFit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GoodnessOfFit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GoodnessOfFit>\n");
              }
            else
              {
                fprintf(stderr, "bad GoodnessOfFit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionSlope") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionSlope");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionSlope>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionSlope element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionIntercept") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionIntercept");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionIntercept>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionIntercept element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TDistribution") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TDistribution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TDistribution>\n");
              }
            else
              {
                fprintf(stderr, "bad TDistribution element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<TotalNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupTotalNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupTotalNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupTotalNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupTotalNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EffectiveNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<EffectiveNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupEffectiveNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupEffectiveNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupEffectiveNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupEffectiveNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberSubgroups") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberSubgroups");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberSubgroups>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberSubgroups element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad NumericCharacteristicStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool StatsAreaType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "areaUnit")
        {
          XmlToken * areaUnitVal;
          if (this->areaUnit)
            {
              fprintf(stderr, "two values for areaUnit in StatsAreaType\n");
              returnValue = true;
              break;
            }
          areaUnitVal = new XmlToken(decl->val.c_str());
          if (areaUnitVal->bad)
            {
              delete areaUnitVal;
              fprintf(stderr, "bad value %s for areaUnit in StatsAreaType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->areaUnit = areaUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in StatsAreaType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->areaUnit;
      this->areaUnit = 0;
    }
  return returnValue;
}

XmlToken * StatsAreaType::getareaUnit()
{return areaUnit;}

void StatsAreaType::setareaUnit(XmlToken * areaUnitIn)
{areaUnit = areaUnitIn;}

/* ***************************************************************** */

/* class StatsArrayIdType

*/

StatsArrayIdType::StatsArrayIdType()
{
  Ids = 0;
  Exclusions = 0;
}

StatsArrayIdType::StatsArrayIdType(
 ArrayReferenceType * IdsIn,
 ExclusionsIdType * ExclusionsIn)
{
  Ids = IdsIn;
  Exclusions = ExclusionsIn;
}

StatsArrayIdType::~StatsArrayIdType()
{
  #ifndef NODESTRUCT
  delete Ids;
  delete Exclusions;
  #endif
}

void StatsArrayIdType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Ids");
  Ids->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Ids>\n");
  if (Exclusions)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Exclusions");
      Exclusions->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Exclusions>\n");
    }
  doSpaces(-INDENT, outFile);
}

ArrayReferenceType * StatsArrayIdType::getIds()
{return Ids;}

void StatsArrayIdType::setIds(ArrayReferenceType * IdsIn)
{Ids = IdsIn;}

ExclusionsIdType * StatsArrayIdType::getExclusions()
{return Exclusions;}

void StatsArrayIdType::setExclusions(ExclusionsIdType * ExclusionsIn)
{Exclusions = ExclusionsIn;}

/* ***************************************************************** */

/* class StatsBaseType

*/

StatsBaseType::StatsBaseType()
{
  Attributes = 0;
  CommonStatsValue = 0;
}

StatsBaseType::StatsBaseType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * CommonStatsValueIn)
{
  Attributes = AttributesIn;
  CommonStatsValue = CommonStatsValueIn;
}

StatsBaseType::~StatsBaseType()
{
  #ifndef NODESTRUCT
  delete Attributes;
  delete CommonStatsValue;
  #endif
}

void StatsBaseType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  {
    if (!CommonStatsValue)
      {
        fprintf(stderr, "CommonStatsValue list is missing\n");
        exit(1);
      }
    if (CommonStatsValue->size() == 0)
      {
        fprintf(stderr, "CommonStatsValue list is empty\n");
        exit(1);
      }
    if (CommonStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of CommonStatsValue list (%d) less than minimum required (1)\n",
                (int)CommonStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = CommonStatsValue->begin();
         iter != CommonStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "TotalNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<TotalNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupTotalNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupTotalNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupTotalNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupTotalNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EffectiveNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<EffectiveNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupEffectiveNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupEffectiveNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupEffectiveNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupEffectiveNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberSubgroups") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberSubgroups");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberSubgroups>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberSubgroups element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad CommonStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

AttributesType * StatsBaseType::getAttributes()
{return Attributes;}

void StatsBaseType::setAttributes(AttributesType * AttributesIn)
{Attributes = AttributesIn;}

StatsWithReferenceBaseTypeLisd * StatsBaseType::getCommonStatsValue()
{return CommonStatsValue;}

void StatsBaseType::setCommonStatsValue(StatsWithReferenceBaseTypeLisd * CommonStatsValueIn)
{CommonStatsValue = CommonStatsValueIn;}

/* ***************************************************************** */

/* class StatsEvalStatusEnumType

*/

StatsEvalStatusEnumType::StatsEvalStatusEnumType() :
  XmlNMTOKEN()
{
}

StatsEvalStatusEnumType::StatsEvalStatusEnumType(
 const char * valIn) :
  XmlNMTOKEN(
    valIn)
{
  if (!bad)
    bad = (strcmp(val.c_str(), "PASS") &&
           strcmp(val.c_str(), "FAIL") &&
           strcmp(val.c_str(), "INFORMATIONAL") &&
           strcmp(val.c_str(), "UNDEFINED"));
}

StatsEvalStatusEnumType::~StatsEvalStatusEnumType() {}

bool StatsEvalStatusEnumType::StatsEvalStatusEnumTypeIsBad()
{
  return (strcmp(val.c_str(), "PASS") &&
          strcmp(val.c_str(), "FAIL") &&
          strcmp(val.c_str(), "INFORMATIONAL") &&
          strcmp(val.c_str(), "UNDEFINED"));
}

void StatsEvalStatusEnumType::printName(FILE * outFile)
{
  fprintf(outFile, "StatsEvalStatusEnumType");
}

void StatsEvalStatusEnumType::printSelf(FILE * outFile)
{
  if (StatsEvalStatusEnumTypeIsBad())
    {
      fprintf(stderr, "bad StatsEvalStatusEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::printSelf(outFile);
}

void StatsEvalStatusEnumType::oPrintSelf(FILE * outFile)
{
  if (StatsEvalStatusEnumTypeIsBad())
    {
      fprintf(stderr, "bad StatsEvalStatusEnumType value, ");
      XmlNMTOKEN::printBad(stderr);
      fprintf(stderr, " exiting\n");
      exit(1);
    }
  XmlNMTOKEN::oPrintSelf(outFile);
}

/* ***************************************************************** */

/* class StatsEvalStatusType

*/

StatsEvalStatusType::StatsEvalStatusType()
{
  StatsEvalStatusTypePair = 0;
}

StatsEvalStatusType::StatsEvalStatusType(
 StatsEvalStatusTypeChoicePair * StatsEvalStatusTypePairIn)
{
  StatsEvalStatusTypePair = StatsEvalStatusTypePairIn;
}

StatsEvalStatusType::~StatsEvalStatusType()
{
  #ifndef NODESTRUCT
  delete StatsEvalStatusTypePair;
  #endif
}

void StatsEvalStatusType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  StatsEvalStatusTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

StatsEvalStatusTypeChoicePair * StatsEvalStatusType::getStatsEvalStatusTypePair()
{return StatsEvalStatusTypePair;}

void StatsEvalStatusType::setStatsEvalStatusTypePair(StatsEvalStatusTypeChoicePair * StatsEvalStatusTypePairIn)
{StatsEvalStatusTypePair = StatsEvalStatusTypePairIn;}
StatsEvalStatusTypeChoicePair::StatsEvalStatusTypeChoicePair() {}

StatsEvalStatusTypeChoicePair::StatsEvalStatusTypeChoicePair(
 whichOne StatsEvalStatusTypeTypeIn,
 StatsEvalStatusTypeVal StatsEvalStatusTypeValueIn)
{
  StatsEvalStatusTypeType = StatsEvalStatusTypeTypeIn;
  StatsEvalStatusTypeValue = StatsEvalStatusTypeValueIn;
}

StatsEvalStatusTypeChoicePair::~StatsEvalStatusTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (StatsEvalStatusTypeType == StatsEvalStatusEnumE)
    delete StatsEvalStatusTypeValue.StatsEvalStatusEnum;
  else if (StatsEvalStatusTypeType == OtherStatsEvalStatusE)
    delete StatsEvalStatusTypeValue.OtherStatsEvalStatus;
  #endif
}

void StatsEvalStatusTypeChoicePair::printSelf(FILE * outFile)
{
  if (StatsEvalStatusTypeType == StatsEvalStatusEnumE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StatsEvalStatusEnum");
      StatsEvalStatusTypeValue.StatsEvalStatusEnum->printSelf(outFile);
      fprintf(outFile, "</StatsEvalStatusEnum>\n");
    }
  else if (StatsEvalStatusTypeType == OtherStatsEvalStatusE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<OtherStatsEvalStatus");
      StatsEvalStatusTypeValue.OtherStatsEvalStatus->printSelf(outFile);
      fprintf(outFile, "</OtherStatsEvalStatus>\n");
    }
}

/* ***************************************************************** */

/* class StatsForceType

*/

StatsForceType::StatsForceType() :
  StatsNumericalBaseType()
{
  forceUnit = 0;
}

StatsForceType::StatsForceType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicStatsValueIn) :
  StatsNumericalBaseType(
    AttributesIn,
    NumericCharacteristicStatsValueIn)
{
  forceUnit = 0;
}

StatsForceType::StatsForceType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicStatsValueIn,
 XmlToken * forceUnitIn) :
  StatsNumericalBaseType(
    AttributesIn,
    NumericCharacteristicStatsValueIn)
{
  forceUnit = forceUnitIn;
}

StatsForceType::~StatsForceType()
{
  #ifndef NODESTRUCT
  delete forceUnit;
  #endif
}

void StatsForceType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (forceUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "forceUnit=\"");
      forceUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  {
    if (!NumericCharacteristicStatsValue)
      {
        fprintf(stderr, "NumericCharacteristicStatsValue list is missing\n");
        exit(1);
      }
    if (NumericCharacteristicStatsValue->size() == 0)
      {
        fprintf(stderr, "NumericCharacteristicStatsValue list is empty\n");
        exit(1);
      }
    if (NumericCharacteristicStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of NumericCharacteristicStatsValue list (%d) less than minimum required (1)\n",
                (int)NumericCharacteristicStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = NumericCharacteristicStatsValue->begin();
         iter != NumericCharacteristicStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "CommonStatsValue") == 0)
          {
            StatsWithReferenceBaseType * typ;
            if ((typ = dynamic_cast<StatsWithReferenceBaseType *>(basie)))
              {
                fprintf(outFile, "<CommonStatsValue");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CommonStatsValue>\n");
              }
            else
              {
                fprintf(stderr, "bad CommonStatsValue element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Average") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Average");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Average>\n");
              }
            else
              {
                fprintf(stderr, "bad Average element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupAverages") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupAverages");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupAverages>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupAverages element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Difference") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Difference");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Difference>\n");
              }
            else
              {
                fprintf(stderr, "bad Difference element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupDifferences") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupDifferences");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupDifferences>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupDifferences element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RootMeanSquare") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RootMeanSquare");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RootMeanSquare>\n");
              }
            else
              {
                fprintf(stderr, "bad RootMeanSquare element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Maximum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Maximum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Maximum>\n");
              }
            else
              {
                fprintf(stderr, "bad Maximum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMaxima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMaxima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMaxima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMaxima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Minimum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Minimum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Minimum>\n");
              }
            else
              {
                fprintf(stderr, "bad Minimum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMinima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMinima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMinima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMinima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Range") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Range");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Range>\n");
              }
            else
              {
                fprintf(stderr, "bad Range element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupRanges") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupRanges");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupRanges>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupRanges element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AverageRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AverageRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AverageRange>\n");
              }
            else
              {
                fprintf(stderr, "bad AverageRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "StandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<StandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</StandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad StandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Skew") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Skew");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Skew>\n");
              }
            else
              {
                fprintf(stderr, "bad Skew element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Kurtosis") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Kurtosis");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Kurtosis>\n");
              }
            else
              {
                fprintf(stderr, "bad Kurtosis element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Normality") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Normality");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Normality>\n");
              }
            else
              {
                fprintf(stderr, "bad Normality element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "ProcessVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<ProcessVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ProcessVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad ProcessVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EstimatedStandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EstimatedStandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EstimatedStandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad EstimatedStandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOutOfControl") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOutOfControl");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOutOfControl>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOutOfControl element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AppraiserVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AppraiserVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AppraiserVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad AppraiserVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EquipmentVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EquipmentVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EquipmentVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad EquipmentVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Interaction") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Interaction");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Interaction>\n");
              }
            else
              {
                fprintf(stderr, "bad Interaction element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GageRandR") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GageRandR");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GageRandR>\n");
              }
            else
              {
                fprintf(stderr, "bad GageRandR element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "PartVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<PartVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PartVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad PartVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TotalVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Linearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Linearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Linearity>\n");
              }
            else
              {
                fprintf(stderr, "bad Linearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Bias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Bias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Bias>\n");
              }
            else
              {
                fprintf(stderr, "bad Bias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeLinearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeLinearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeLinearity>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeLinearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeBias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeBias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeBias>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeBias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GoodnessOfFit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GoodnessOfFit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GoodnessOfFit>\n");
              }
            else
              {
                fprintf(stderr, "bad GoodnessOfFit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionSlope") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionSlope");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionSlope>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionSlope element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionIntercept") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionIntercept");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionIntercept>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionIntercept element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TDistribution") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TDistribution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TDistribution>\n");
              }
            else
              {
                fprintf(stderr, "bad TDistribution element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<TotalNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupTotalNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupTotalNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupTotalNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupTotalNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EffectiveNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<EffectiveNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupEffectiveNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupEffectiveNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupEffectiveNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupEffectiveNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberSubgroups") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberSubgroups");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberSubgroups>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberSubgroups element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad NumericCharacteristicStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool StatsForceType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "forceUnit")
        {
          XmlToken * forceUnitVal;
          if (this->forceUnit)
            {
              fprintf(stderr, "two values for forceUnit in StatsForceType\n");
              returnValue = true;
              break;
            }
          forceUnitVal = new XmlToken(decl->val.c_str());
          if (forceUnitVal->bad)
            {
              delete forceUnitVal;
              fprintf(stderr, "bad value %s for forceUnit in StatsForceType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->forceUnit = forceUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in StatsForceType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->forceUnit;
      this->forceUnit = 0;
    }
  return returnValue;
}

XmlToken * StatsForceType::getforceUnit()
{return forceUnit;}

void StatsForceType::setforceUnit(XmlToken * forceUnitIn)
{forceUnit = forceUnitIn;}

/* ***************************************************************** */

/* class StatsLinearType

*/

StatsLinearType::StatsLinearType() :
  StatsNumericalBaseType()
{
  linearUnit = 0;
}

StatsLinearType::StatsLinearType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicStatsValueIn) :
  StatsNumericalBaseType(
    AttributesIn,
    NumericCharacteristicStatsValueIn)
{
  linearUnit = 0;
}

StatsLinearType::StatsLinearType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicStatsValueIn,
 XmlToken * linearUnitIn) :
  StatsNumericalBaseType(
    AttributesIn,
    NumericCharacteristicStatsValueIn)
{
  linearUnit = linearUnitIn;
}

StatsLinearType::~StatsLinearType()
{
  #ifndef NODESTRUCT
  delete linearUnit;
  #endif
}

void StatsLinearType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (linearUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "linearUnit=\"");
      linearUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  {
    if (!NumericCharacteristicStatsValue)
      {
        fprintf(stderr, "NumericCharacteristicStatsValue list is missing\n");
        exit(1);
      }
    if (NumericCharacteristicStatsValue->size() == 0)
      {
        fprintf(stderr, "NumericCharacteristicStatsValue list is empty\n");
        exit(1);
      }
    if (NumericCharacteristicStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of NumericCharacteristicStatsValue list (%d) less than minimum required (1)\n",
                (int)NumericCharacteristicStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = NumericCharacteristicStatsValue->begin();
         iter != NumericCharacteristicStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "CommonStatsValue") == 0)
          {
            StatsWithReferenceBaseType * typ;
            if ((typ = dynamic_cast<StatsWithReferenceBaseType *>(basie)))
              {
                fprintf(outFile, "<CommonStatsValue");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CommonStatsValue>\n");
              }
            else
              {
                fprintf(stderr, "bad CommonStatsValue element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Average") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Average");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Average>\n");
              }
            else
              {
                fprintf(stderr, "bad Average element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupAverages") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupAverages");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupAverages>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupAverages element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Difference") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Difference");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Difference>\n");
              }
            else
              {
                fprintf(stderr, "bad Difference element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupDifferences") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupDifferences");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupDifferences>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupDifferences element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RootMeanSquare") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RootMeanSquare");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RootMeanSquare>\n");
              }
            else
              {
                fprintf(stderr, "bad RootMeanSquare element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Maximum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Maximum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Maximum>\n");
              }
            else
              {
                fprintf(stderr, "bad Maximum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMaxima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMaxima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMaxima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMaxima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Minimum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Minimum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Minimum>\n");
              }
            else
              {
                fprintf(stderr, "bad Minimum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMinima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMinima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMinima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMinima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Range") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Range");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Range>\n");
              }
            else
              {
                fprintf(stderr, "bad Range element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupRanges") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupRanges");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupRanges>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupRanges element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AverageRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AverageRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AverageRange>\n");
              }
            else
              {
                fprintf(stderr, "bad AverageRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "StandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<StandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</StandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad StandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Skew") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Skew");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Skew>\n");
              }
            else
              {
                fprintf(stderr, "bad Skew element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Kurtosis") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Kurtosis");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Kurtosis>\n");
              }
            else
              {
                fprintf(stderr, "bad Kurtosis element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Normality") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Normality");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Normality>\n");
              }
            else
              {
                fprintf(stderr, "bad Normality element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "ProcessVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<ProcessVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ProcessVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad ProcessVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EstimatedStandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EstimatedStandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EstimatedStandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad EstimatedStandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOutOfControl") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOutOfControl");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOutOfControl>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOutOfControl element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AppraiserVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AppraiserVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AppraiserVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad AppraiserVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EquipmentVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EquipmentVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EquipmentVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad EquipmentVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Interaction") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Interaction");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Interaction>\n");
              }
            else
              {
                fprintf(stderr, "bad Interaction element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GageRandR") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GageRandR");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GageRandR>\n");
              }
            else
              {
                fprintf(stderr, "bad GageRandR element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "PartVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<PartVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PartVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad PartVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TotalVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Linearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Linearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Linearity>\n");
              }
            else
              {
                fprintf(stderr, "bad Linearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Bias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Bias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Bias>\n");
              }
            else
              {
                fprintf(stderr, "bad Bias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeLinearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeLinearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeLinearity>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeLinearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeBias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeBias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeBias>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeBias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GoodnessOfFit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GoodnessOfFit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GoodnessOfFit>\n");
              }
            else
              {
                fprintf(stderr, "bad GoodnessOfFit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionSlope") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionSlope");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionSlope>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionSlope element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionIntercept") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionIntercept");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionIntercept>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionIntercept element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TDistribution") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TDistribution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TDistribution>\n");
              }
            else
              {
                fprintf(stderr, "bad TDistribution element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<TotalNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupTotalNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupTotalNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupTotalNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupTotalNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EffectiveNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<EffectiveNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupEffectiveNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupEffectiveNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupEffectiveNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupEffectiveNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberSubgroups") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberSubgroups");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberSubgroups>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberSubgroups element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad NumericCharacteristicStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool StatsLinearType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "linearUnit")
        {
          XmlToken * linearUnitVal;
          if (this->linearUnit)
            {
              fprintf(stderr, "two values for linearUnit in StatsLinearType\n");
              returnValue = true;
              break;
            }
          linearUnitVal = new XmlToken(decl->val.c_str());
          if (linearUnitVal->bad)
            {
              delete linearUnitVal;
              fprintf(stderr, "bad value %s for linearUnit in StatsLinearType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->linearUnit = linearUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in StatsLinearType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->linearUnit;
      this->linearUnit = 0;
    }
  return returnValue;
}

XmlToken * StatsLinearType::getlinearUnit()
{return linearUnit;}

void StatsLinearType::setlinearUnit(XmlToken * linearUnitIn)
{linearUnit = linearUnitIn;}

/* ***************************************************************** */

/* class StatsMassType

*/

StatsMassType::StatsMassType() :
  StatsNumericalBaseType()
{
  massUnit = 0;
}

StatsMassType::StatsMassType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicStatsValueIn) :
  StatsNumericalBaseType(
    AttributesIn,
    NumericCharacteristicStatsValueIn)
{
  massUnit = 0;
}

StatsMassType::StatsMassType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicStatsValueIn,
 XmlToken * massUnitIn) :
  StatsNumericalBaseType(
    AttributesIn,
    NumericCharacteristicStatsValueIn)
{
  massUnit = massUnitIn;
}

StatsMassType::~StatsMassType()
{
  #ifndef NODESTRUCT
  delete massUnit;
  #endif
}

void StatsMassType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (massUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "massUnit=\"");
      massUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  {
    if (!NumericCharacteristicStatsValue)
      {
        fprintf(stderr, "NumericCharacteristicStatsValue list is missing\n");
        exit(1);
      }
    if (NumericCharacteristicStatsValue->size() == 0)
      {
        fprintf(stderr, "NumericCharacteristicStatsValue list is empty\n");
        exit(1);
      }
    if (NumericCharacteristicStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of NumericCharacteristicStatsValue list (%d) less than minimum required (1)\n",
                (int)NumericCharacteristicStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = NumericCharacteristicStatsValue->begin();
         iter != NumericCharacteristicStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "CommonStatsValue") == 0)
          {
            StatsWithReferenceBaseType * typ;
            if ((typ = dynamic_cast<StatsWithReferenceBaseType *>(basie)))
              {
                fprintf(outFile, "<CommonStatsValue");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CommonStatsValue>\n");
              }
            else
              {
                fprintf(stderr, "bad CommonStatsValue element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Average") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Average");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Average>\n");
              }
            else
              {
                fprintf(stderr, "bad Average element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupAverages") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupAverages");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupAverages>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupAverages element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Difference") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Difference");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Difference>\n");
              }
            else
              {
                fprintf(stderr, "bad Difference element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupDifferences") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupDifferences");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupDifferences>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupDifferences element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RootMeanSquare") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RootMeanSquare");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RootMeanSquare>\n");
              }
            else
              {
                fprintf(stderr, "bad RootMeanSquare element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Maximum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Maximum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Maximum>\n");
              }
            else
              {
                fprintf(stderr, "bad Maximum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMaxima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMaxima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMaxima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMaxima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Minimum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Minimum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Minimum>\n");
              }
            else
              {
                fprintf(stderr, "bad Minimum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMinima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMinima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMinima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMinima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Range") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Range");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Range>\n");
              }
            else
              {
                fprintf(stderr, "bad Range element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupRanges") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupRanges");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupRanges>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupRanges element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AverageRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AverageRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AverageRange>\n");
              }
            else
              {
                fprintf(stderr, "bad AverageRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "StandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<StandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</StandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad StandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Skew") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Skew");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Skew>\n");
              }
            else
              {
                fprintf(stderr, "bad Skew element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Kurtosis") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Kurtosis");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Kurtosis>\n");
              }
            else
              {
                fprintf(stderr, "bad Kurtosis element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Normality") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Normality");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Normality>\n");
              }
            else
              {
                fprintf(stderr, "bad Normality element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "ProcessVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<ProcessVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ProcessVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad ProcessVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EstimatedStandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EstimatedStandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EstimatedStandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad EstimatedStandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOutOfControl") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOutOfControl");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOutOfControl>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOutOfControl element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AppraiserVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AppraiserVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AppraiserVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad AppraiserVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EquipmentVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EquipmentVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EquipmentVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad EquipmentVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Interaction") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Interaction");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Interaction>\n");
              }
            else
              {
                fprintf(stderr, "bad Interaction element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GageRandR") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GageRandR");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GageRandR>\n");
              }
            else
              {
                fprintf(stderr, "bad GageRandR element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "PartVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<PartVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PartVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad PartVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TotalVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Linearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Linearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Linearity>\n");
              }
            else
              {
                fprintf(stderr, "bad Linearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Bias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Bias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Bias>\n");
              }
            else
              {
                fprintf(stderr, "bad Bias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeLinearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeLinearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeLinearity>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeLinearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeBias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeBias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeBias>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeBias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GoodnessOfFit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GoodnessOfFit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GoodnessOfFit>\n");
              }
            else
              {
                fprintf(stderr, "bad GoodnessOfFit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionSlope") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionSlope");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionSlope>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionSlope element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionIntercept") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionIntercept");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionIntercept>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionIntercept element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TDistribution") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TDistribution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TDistribution>\n");
              }
            else
              {
                fprintf(stderr, "bad TDistribution element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<TotalNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupTotalNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupTotalNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupTotalNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupTotalNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EffectiveNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<EffectiveNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupEffectiveNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupEffectiveNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupEffectiveNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupEffectiveNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberSubgroups") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberSubgroups");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberSubgroups>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberSubgroups element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad NumericCharacteristicStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool StatsMassType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "massUnit")
        {
          XmlToken * massUnitVal;
          if (this->massUnit)
            {
              fprintf(stderr, "two values for massUnit in StatsMassType\n");
              returnValue = true;
              break;
            }
          massUnitVal = new XmlToken(decl->val.c_str());
          if (massUnitVal->bad)
            {
              delete massUnitVal;
              fprintf(stderr, "bad value %s for massUnit in StatsMassType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->massUnit = massUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in StatsMassType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->massUnit;
      this->massUnit = 0;
    }
  return returnValue;
}

XmlToken * StatsMassType::getmassUnit()
{return massUnit;}

void StatsMassType::setmassUnit(XmlToken * massUnitIn)
{massUnit = massUnitIn;}

/* ***************************************************************** */

/* class StatsNumericalBaseType

*/

StatsNumericalBaseType::StatsNumericalBaseType()
{
  Attributes = 0;
  NumericCharacteristicStatsValue = 0;
}

StatsNumericalBaseType::StatsNumericalBaseType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicStatsValueIn)
{
  Attributes = AttributesIn;
  NumericCharacteristicStatsValue = NumericCharacteristicStatsValueIn;
}

StatsNumericalBaseType::~StatsNumericalBaseType()
{
  #ifndef NODESTRUCT
  delete Attributes;
  delete NumericCharacteristicStatsValue;
  #endif
}

void StatsNumericalBaseType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  {
    if (!NumericCharacteristicStatsValue)
      {
        fprintf(stderr, "NumericCharacteristicStatsValue list is missing\n");
        exit(1);
      }
    if (NumericCharacteristicStatsValue->size() == 0)
      {
        fprintf(stderr, "NumericCharacteristicStatsValue list is empty\n");
        exit(1);
      }
    if (NumericCharacteristicStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of NumericCharacteristicStatsValue list (%d) less than minimum required (1)\n",
                (int)NumericCharacteristicStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = NumericCharacteristicStatsValue->begin();
         iter != NumericCharacteristicStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "CommonStatsValue") == 0)
          {
            StatsWithReferenceBaseType * typ;
            if ((typ = dynamic_cast<StatsWithReferenceBaseType *>(basie)))
              {
                fprintf(outFile, "<CommonStatsValue");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CommonStatsValue>\n");
              }
            else
              {
                fprintf(stderr, "bad CommonStatsValue element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Average") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Average");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Average>\n");
              }
            else
              {
                fprintf(stderr, "bad Average element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupAverages") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupAverages");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupAverages>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupAverages element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Difference") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Difference");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Difference>\n");
              }
            else
              {
                fprintf(stderr, "bad Difference element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupDifferences") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupDifferences");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupDifferences>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupDifferences element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RootMeanSquare") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RootMeanSquare");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RootMeanSquare>\n");
              }
            else
              {
                fprintf(stderr, "bad RootMeanSquare element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Maximum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Maximum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Maximum>\n");
              }
            else
              {
                fprintf(stderr, "bad Maximum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMaxima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMaxima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMaxima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMaxima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Minimum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Minimum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Minimum>\n");
              }
            else
              {
                fprintf(stderr, "bad Minimum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMinima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMinima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMinima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMinima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Range") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Range");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Range>\n");
              }
            else
              {
                fprintf(stderr, "bad Range element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupRanges") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupRanges");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupRanges>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupRanges element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AverageRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AverageRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AverageRange>\n");
              }
            else
              {
                fprintf(stderr, "bad AverageRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "StandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<StandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</StandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad StandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Skew") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Skew");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Skew>\n");
              }
            else
              {
                fprintf(stderr, "bad Skew element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Kurtosis") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Kurtosis");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Kurtosis>\n");
              }
            else
              {
                fprintf(stderr, "bad Kurtosis element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Normality") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Normality");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Normality>\n");
              }
            else
              {
                fprintf(stderr, "bad Normality element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "ProcessVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<ProcessVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ProcessVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad ProcessVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EstimatedStandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EstimatedStandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EstimatedStandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad EstimatedStandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOutOfControl") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOutOfControl");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOutOfControl>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOutOfControl element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AppraiserVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AppraiserVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AppraiserVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad AppraiserVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EquipmentVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EquipmentVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EquipmentVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad EquipmentVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Interaction") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Interaction");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Interaction>\n");
              }
            else
              {
                fprintf(stderr, "bad Interaction element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GageRandR") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GageRandR");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GageRandR>\n");
              }
            else
              {
                fprintf(stderr, "bad GageRandR element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "PartVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<PartVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PartVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad PartVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TotalVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Linearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Linearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Linearity>\n");
              }
            else
              {
                fprintf(stderr, "bad Linearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Bias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Bias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Bias>\n");
              }
            else
              {
                fprintf(stderr, "bad Bias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeLinearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeLinearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeLinearity>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeLinearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeBias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeBias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeBias>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeBias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GoodnessOfFit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GoodnessOfFit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GoodnessOfFit>\n");
              }
            else
              {
                fprintf(stderr, "bad GoodnessOfFit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionSlope") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionSlope");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionSlope>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionSlope element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionIntercept") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionIntercept");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionIntercept>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionIntercept element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TDistribution") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TDistribution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TDistribution>\n");
              }
            else
              {
                fprintf(stderr, "bad TDistribution element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<TotalNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupTotalNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupTotalNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupTotalNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupTotalNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EffectiveNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<EffectiveNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupEffectiveNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupEffectiveNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupEffectiveNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupEffectiveNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberSubgroups") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberSubgroups");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberSubgroups>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberSubgroups element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad NumericCharacteristicStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

AttributesType * StatsNumericalBaseType::getAttributes()
{return Attributes;}

void StatsNumericalBaseType::setAttributes(AttributesType * AttributesIn)
{Attributes = AttributesIn;}

StatsWithReferenceBaseTypeLisd * StatsNumericalBaseType::getNumericCharacteristicStatsValue()
{return NumericCharacteristicStatsValue;}

void StatsNumericalBaseType::setNumericCharacteristicStatsValue(StatsWithReferenceBaseTypeLisd * NumericCharacteristicStatsValueIn)
{NumericCharacteristicStatsValue = NumericCharacteristicStatsValueIn;}

/* ***************************************************************** */

/* class StatsPassFailType

*/

StatsPassFailType::StatsPassFailType() :
  StatsBaseType()
{
  PassFailStatsValue = 0;
}

StatsPassFailType::StatsPassFailType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * CommonStatsValueIn,
 StatsWithReferenceBaseTypeLisd * PassFailStatsValueIn) :
  StatsBaseType(
    AttributesIn,
    CommonStatsValueIn)
{
  PassFailStatsValue = PassFailStatsValueIn;
}

StatsPassFailType::~StatsPassFailType()
{
  #ifndef NODESTRUCT
  delete PassFailStatsValue;
  #endif
}

void StatsPassFailType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  {
    if (!CommonStatsValue)
      {
        fprintf(stderr, "CommonStatsValue list is missing\n");
        exit(1);
      }
    if (CommonStatsValue->size() == 0)
      {
        fprintf(stderr, "CommonStatsValue list is empty\n");
        exit(1);
      }
    if (CommonStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of CommonStatsValue list (%d) less than minimum required (1)\n",
                (int)CommonStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = CommonStatsValue->begin();
         iter != CommonStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "TotalNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<TotalNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupTotalNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupTotalNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupTotalNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupTotalNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EffectiveNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<EffectiveNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupEffectiveNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupEffectiveNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupEffectiveNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupEffectiveNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberSubgroups") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberSubgroups");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberSubgroups>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberSubgroups element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad CommonStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  {
    if (!PassFailStatsValue)
      {
        fprintf(stderr, "PassFailStatsValue list is missing\n");
        exit(1);
      }
    if (PassFailStatsValue->size() == 0)
      {
        fprintf(stderr, "PassFailStatsValue list is empty\n");
        exit(1);
      }
    if (PassFailStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of PassFailStatsValue list (%d) less than minimum required (1)\n",
                (int)PassFailStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = PassFailStatsValue->begin();
         iter != PassFailStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "FailurePercentage") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<FailurePercentage");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</FailurePercentage>\n");
              }
            else
              {
                fprintf(stderr, "bad FailurePercentage element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberFailures") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberFailures");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberFailures>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberFailures element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad PassFailStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

StatsWithReferenceBaseTypeLisd * StatsPassFailType::getPassFailStatsValue()
{return PassFailStatsValue;}

void StatsPassFailType::setPassFailStatsValue(StatsWithReferenceBaseTypeLisd * PassFailStatsValueIn)
{PassFailStatsValue = PassFailStatsValueIn;}

/* ***************************************************************** */

/* class StatsPressureType

*/

StatsPressureType::StatsPressureType() :
  StatsNumericalBaseType()
{
  pressureUnit = 0;
}

StatsPressureType::StatsPressureType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicStatsValueIn) :
  StatsNumericalBaseType(
    AttributesIn,
    NumericCharacteristicStatsValueIn)
{
  pressureUnit = 0;
}

StatsPressureType::StatsPressureType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicStatsValueIn,
 XmlToken * pressureUnitIn) :
  StatsNumericalBaseType(
    AttributesIn,
    NumericCharacteristicStatsValueIn)
{
  pressureUnit = pressureUnitIn;
}

StatsPressureType::~StatsPressureType()
{
  #ifndef NODESTRUCT
  delete pressureUnit;
  #endif
}

void StatsPressureType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (pressureUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "pressureUnit=\"");
      pressureUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  {
    if (!NumericCharacteristicStatsValue)
      {
        fprintf(stderr, "NumericCharacteristicStatsValue list is missing\n");
        exit(1);
      }
    if (NumericCharacteristicStatsValue->size() == 0)
      {
        fprintf(stderr, "NumericCharacteristicStatsValue list is empty\n");
        exit(1);
      }
    if (NumericCharacteristicStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of NumericCharacteristicStatsValue list (%d) less than minimum required (1)\n",
                (int)NumericCharacteristicStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = NumericCharacteristicStatsValue->begin();
         iter != NumericCharacteristicStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "CommonStatsValue") == 0)
          {
            StatsWithReferenceBaseType * typ;
            if ((typ = dynamic_cast<StatsWithReferenceBaseType *>(basie)))
              {
                fprintf(outFile, "<CommonStatsValue");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CommonStatsValue>\n");
              }
            else
              {
                fprintf(stderr, "bad CommonStatsValue element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Average") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Average");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Average>\n");
              }
            else
              {
                fprintf(stderr, "bad Average element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupAverages") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupAverages");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupAverages>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupAverages element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Difference") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Difference");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Difference>\n");
              }
            else
              {
                fprintf(stderr, "bad Difference element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupDifferences") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupDifferences");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupDifferences>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupDifferences element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RootMeanSquare") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RootMeanSquare");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RootMeanSquare>\n");
              }
            else
              {
                fprintf(stderr, "bad RootMeanSquare element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Maximum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Maximum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Maximum>\n");
              }
            else
              {
                fprintf(stderr, "bad Maximum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMaxima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMaxima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMaxima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMaxima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Minimum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Minimum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Minimum>\n");
              }
            else
              {
                fprintf(stderr, "bad Minimum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMinima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMinima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMinima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMinima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Range") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Range");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Range>\n");
              }
            else
              {
                fprintf(stderr, "bad Range element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupRanges") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupRanges");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupRanges>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupRanges element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AverageRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AverageRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AverageRange>\n");
              }
            else
              {
                fprintf(stderr, "bad AverageRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "StandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<StandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</StandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad StandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Skew") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Skew");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Skew>\n");
              }
            else
              {
                fprintf(stderr, "bad Skew element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Kurtosis") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Kurtosis");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Kurtosis>\n");
              }
            else
              {
                fprintf(stderr, "bad Kurtosis element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Normality") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Normality");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Normality>\n");
              }
            else
              {
                fprintf(stderr, "bad Normality element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "ProcessVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<ProcessVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ProcessVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad ProcessVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EstimatedStandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EstimatedStandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EstimatedStandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad EstimatedStandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOutOfControl") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOutOfControl");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOutOfControl>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOutOfControl element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AppraiserVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AppraiserVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AppraiserVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad AppraiserVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EquipmentVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EquipmentVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EquipmentVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad EquipmentVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Interaction") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Interaction");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Interaction>\n");
              }
            else
              {
                fprintf(stderr, "bad Interaction element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GageRandR") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GageRandR");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GageRandR>\n");
              }
            else
              {
                fprintf(stderr, "bad GageRandR element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "PartVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<PartVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PartVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad PartVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TotalVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Linearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Linearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Linearity>\n");
              }
            else
              {
                fprintf(stderr, "bad Linearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Bias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Bias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Bias>\n");
              }
            else
              {
                fprintf(stderr, "bad Bias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeLinearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeLinearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeLinearity>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeLinearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeBias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeBias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeBias>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeBias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GoodnessOfFit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GoodnessOfFit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GoodnessOfFit>\n");
              }
            else
              {
                fprintf(stderr, "bad GoodnessOfFit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionSlope") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionSlope");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionSlope>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionSlope element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionIntercept") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionIntercept");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionIntercept>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionIntercept element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TDistribution") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TDistribution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TDistribution>\n");
              }
            else
              {
                fprintf(stderr, "bad TDistribution element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<TotalNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupTotalNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupTotalNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupTotalNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupTotalNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EffectiveNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<EffectiveNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupEffectiveNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupEffectiveNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupEffectiveNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupEffectiveNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberSubgroups") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberSubgroups");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberSubgroups>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberSubgroups element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad NumericCharacteristicStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool StatsPressureType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "pressureUnit")
        {
          XmlToken * pressureUnitVal;
          if (this->pressureUnit)
            {
              fprintf(stderr, "two values for pressureUnit in StatsPressureType\n");
              returnValue = true;
              break;
            }
          pressureUnitVal = new XmlToken(decl->val.c_str());
          if (pressureUnitVal->bad)
            {
              delete pressureUnitVal;
              fprintf(stderr, "bad value %s for pressureUnit in StatsPressureType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->pressureUnit = pressureUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in StatsPressureType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->pressureUnit;
      this->pressureUnit = 0;
    }
  return returnValue;
}

XmlToken * StatsPressureType::getpressureUnit()
{return pressureUnit;}

void StatsPressureType::setpressureUnit(XmlToken * pressureUnitIn)
{pressureUnit = pressureUnitIn;}

/* ***************************************************************** */

/* class StatsSpeedType

*/

StatsSpeedType::StatsSpeedType() :
  StatsNumericalBaseType()
{
  speedUnit = 0;
}

StatsSpeedType::StatsSpeedType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicStatsValueIn) :
  StatsNumericalBaseType(
    AttributesIn,
    NumericCharacteristicStatsValueIn)
{
  speedUnit = 0;
}

StatsSpeedType::StatsSpeedType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicStatsValueIn,
 XmlToken * speedUnitIn) :
  StatsNumericalBaseType(
    AttributesIn,
    NumericCharacteristicStatsValueIn)
{
  speedUnit = speedUnitIn;
}

StatsSpeedType::~StatsSpeedType()
{
  #ifndef NODESTRUCT
  delete speedUnit;
  #endif
}

void StatsSpeedType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (speedUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "speedUnit=\"");
      speedUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  {
    if (!NumericCharacteristicStatsValue)
      {
        fprintf(stderr, "NumericCharacteristicStatsValue list is missing\n");
        exit(1);
      }
    if (NumericCharacteristicStatsValue->size() == 0)
      {
        fprintf(stderr, "NumericCharacteristicStatsValue list is empty\n");
        exit(1);
      }
    if (NumericCharacteristicStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of NumericCharacteristicStatsValue list (%d) less than minimum required (1)\n",
                (int)NumericCharacteristicStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = NumericCharacteristicStatsValue->begin();
         iter != NumericCharacteristicStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "CommonStatsValue") == 0)
          {
            StatsWithReferenceBaseType * typ;
            if ((typ = dynamic_cast<StatsWithReferenceBaseType *>(basie)))
              {
                fprintf(outFile, "<CommonStatsValue");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CommonStatsValue>\n");
              }
            else
              {
                fprintf(stderr, "bad CommonStatsValue element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Average") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Average");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Average>\n");
              }
            else
              {
                fprintf(stderr, "bad Average element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupAverages") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupAverages");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupAverages>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupAverages element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Difference") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Difference");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Difference>\n");
              }
            else
              {
                fprintf(stderr, "bad Difference element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupDifferences") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupDifferences");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupDifferences>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupDifferences element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RootMeanSquare") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RootMeanSquare");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RootMeanSquare>\n");
              }
            else
              {
                fprintf(stderr, "bad RootMeanSquare element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Maximum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Maximum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Maximum>\n");
              }
            else
              {
                fprintf(stderr, "bad Maximum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMaxima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMaxima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMaxima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMaxima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Minimum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Minimum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Minimum>\n");
              }
            else
              {
                fprintf(stderr, "bad Minimum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMinima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMinima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMinima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMinima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Range") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Range");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Range>\n");
              }
            else
              {
                fprintf(stderr, "bad Range element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupRanges") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupRanges");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupRanges>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupRanges element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AverageRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AverageRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AverageRange>\n");
              }
            else
              {
                fprintf(stderr, "bad AverageRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "StandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<StandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</StandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad StandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Skew") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Skew");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Skew>\n");
              }
            else
              {
                fprintf(stderr, "bad Skew element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Kurtosis") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Kurtosis");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Kurtosis>\n");
              }
            else
              {
                fprintf(stderr, "bad Kurtosis element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Normality") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Normality");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Normality>\n");
              }
            else
              {
                fprintf(stderr, "bad Normality element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "ProcessVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<ProcessVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ProcessVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad ProcessVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EstimatedStandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EstimatedStandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EstimatedStandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad EstimatedStandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOutOfControl") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOutOfControl");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOutOfControl>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOutOfControl element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AppraiserVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AppraiserVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AppraiserVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad AppraiserVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EquipmentVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EquipmentVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EquipmentVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad EquipmentVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Interaction") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Interaction");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Interaction>\n");
              }
            else
              {
                fprintf(stderr, "bad Interaction element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GageRandR") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GageRandR");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GageRandR>\n");
              }
            else
              {
                fprintf(stderr, "bad GageRandR element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "PartVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<PartVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PartVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad PartVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TotalVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Linearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Linearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Linearity>\n");
              }
            else
              {
                fprintf(stderr, "bad Linearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Bias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Bias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Bias>\n");
              }
            else
              {
                fprintf(stderr, "bad Bias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeLinearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeLinearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeLinearity>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeLinearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeBias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeBias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeBias>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeBias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GoodnessOfFit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GoodnessOfFit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GoodnessOfFit>\n");
              }
            else
              {
                fprintf(stderr, "bad GoodnessOfFit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionSlope") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionSlope");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionSlope>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionSlope element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionIntercept") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionIntercept");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionIntercept>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionIntercept element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TDistribution") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TDistribution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TDistribution>\n");
              }
            else
              {
                fprintf(stderr, "bad TDistribution element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<TotalNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupTotalNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupTotalNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupTotalNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupTotalNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EffectiveNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<EffectiveNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupEffectiveNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupEffectiveNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupEffectiveNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupEffectiveNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberSubgroups") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberSubgroups");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberSubgroups>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberSubgroups element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad NumericCharacteristicStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool StatsSpeedType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "speedUnit")
        {
          XmlToken * speedUnitVal;
          if (this->speedUnit)
            {
              fprintf(stderr, "two values for speedUnit in StatsSpeedType\n");
              returnValue = true;
              break;
            }
          speedUnitVal = new XmlToken(decl->val.c_str());
          if (speedUnitVal->bad)
            {
              delete speedUnitVal;
              fprintf(stderr, "bad value %s for speedUnit in StatsSpeedType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->speedUnit = speedUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in StatsSpeedType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->speedUnit;
      this->speedUnit = 0;
    }
  return returnValue;
}

XmlToken * StatsSpeedType::getspeedUnit()
{return speedUnit;}

void StatsSpeedType::setspeedUnit(XmlToken * speedUnitIn)
{speedUnit = speedUnitIn;}

/* ***************************************************************** */

/* class StatsTemperatureType

*/

StatsTemperatureType::StatsTemperatureType() :
  StatsNumericalBaseType()
{
  temperatureUnit = 0;
}

StatsTemperatureType::StatsTemperatureType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicStatsValueIn) :
  StatsNumericalBaseType(
    AttributesIn,
    NumericCharacteristicStatsValueIn)
{
  temperatureUnit = 0;
}

StatsTemperatureType::StatsTemperatureType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicStatsValueIn,
 XmlToken * temperatureUnitIn) :
  StatsNumericalBaseType(
    AttributesIn,
    NumericCharacteristicStatsValueIn)
{
  temperatureUnit = temperatureUnitIn;
}

StatsTemperatureType::~StatsTemperatureType()
{
  #ifndef NODESTRUCT
  delete temperatureUnit;
  #endif
}

void StatsTemperatureType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (temperatureUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "temperatureUnit=\"");
      temperatureUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  {
    if (!NumericCharacteristicStatsValue)
      {
        fprintf(stderr, "NumericCharacteristicStatsValue list is missing\n");
        exit(1);
      }
    if (NumericCharacteristicStatsValue->size() == 0)
      {
        fprintf(stderr, "NumericCharacteristicStatsValue list is empty\n");
        exit(1);
      }
    if (NumericCharacteristicStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of NumericCharacteristicStatsValue list (%d) less than minimum required (1)\n",
                (int)NumericCharacteristicStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = NumericCharacteristicStatsValue->begin();
         iter != NumericCharacteristicStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "CommonStatsValue") == 0)
          {
            StatsWithReferenceBaseType * typ;
            if ((typ = dynamic_cast<StatsWithReferenceBaseType *>(basie)))
              {
                fprintf(outFile, "<CommonStatsValue");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CommonStatsValue>\n");
              }
            else
              {
                fprintf(stderr, "bad CommonStatsValue element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Average") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Average");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Average>\n");
              }
            else
              {
                fprintf(stderr, "bad Average element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupAverages") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupAverages");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupAverages>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupAverages element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Difference") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Difference");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Difference>\n");
              }
            else
              {
                fprintf(stderr, "bad Difference element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupDifferences") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupDifferences");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupDifferences>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupDifferences element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RootMeanSquare") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RootMeanSquare");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RootMeanSquare>\n");
              }
            else
              {
                fprintf(stderr, "bad RootMeanSquare element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Maximum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Maximum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Maximum>\n");
              }
            else
              {
                fprintf(stderr, "bad Maximum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMaxima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMaxima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMaxima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMaxima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Minimum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Minimum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Minimum>\n");
              }
            else
              {
                fprintf(stderr, "bad Minimum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMinima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMinima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMinima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMinima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Range") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Range");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Range>\n");
              }
            else
              {
                fprintf(stderr, "bad Range element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupRanges") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupRanges");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupRanges>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupRanges element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AverageRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AverageRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AverageRange>\n");
              }
            else
              {
                fprintf(stderr, "bad AverageRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "StandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<StandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</StandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad StandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Skew") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Skew");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Skew>\n");
              }
            else
              {
                fprintf(stderr, "bad Skew element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Kurtosis") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Kurtosis");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Kurtosis>\n");
              }
            else
              {
                fprintf(stderr, "bad Kurtosis element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Normality") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Normality");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Normality>\n");
              }
            else
              {
                fprintf(stderr, "bad Normality element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "ProcessVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<ProcessVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ProcessVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad ProcessVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EstimatedStandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EstimatedStandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EstimatedStandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad EstimatedStandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOutOfControl") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOutOfControl");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOutOfControl>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOutOfControl element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AppraiserVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AppraiserVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AppraiserVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad AppraiserVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EquipmentVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EquipmentVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EquipmentVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad EquipmentVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Interaction") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Interaction");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Interaction>\n");
              }
            else
              {
                fprintf(stderr, "bad Interaction element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GageRandR") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GageRandR");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GageRandR>\n");
              }
            else
              {
                fprintf(stderr, "bad GageRandR element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "PartVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<PartVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PartVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad PartVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TotalVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Linearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Linearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Linearity>\n");
              }
            else
              {
                fprintf(stderr, "bad Linearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Bias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Bias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Bias>\n");
              }
            else
              {
                fprintf(stderr, "bad Bias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeLinearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeLinearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeLinearity>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeLinearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeBias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeBias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeBias>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeBias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GoodnessOfFit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GoodnessOfFit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GoodnessOfFit>\n");
              }
            else
              {
                fprintf(stderr, "bad GoodnessOfFit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionSlope") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionSlope");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionSlope>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionSlope element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionIntercept") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionIntercept");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionIntercept>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionIntercept element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TDistribution") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TDistribution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TDistribution>\n");
              }
            else
              {
                fprintf(stderr, "bad TDistribution element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<TotalNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupTotalNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupTotalNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupTotalNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupTotalNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EffectiveNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<EffectiveNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupEffectiveNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupEffectiveNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupEffectiveNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupEffectiveNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberSubgroups") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberSubgroups");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberSubgroups>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberSubgroups element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad NumericCharacteristicStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool StatsTemperatureType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "temperatureUnit")
        {
          XmlToken * temperatureUnitVal;
          if (this->temperatureUnit)
            {
              fprintf(stderr, "two values for temperatureUnit in StatsTemperatureType\n");
              returnValue = true;
              break;
            }
          temperatureUnitVal = new XmlToken(decl->val.c_str());
          if (temperatureUnitVal->bad)
            {
              delete temperatureUnitVal;
              fprintf(stderr, "bad value %s for temperatureUnit in StatsTemperatureType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->temperatureUnit = temperatureUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in StatsTemperatureType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->temperatureUnit;
      this->temperatureUnit = 0;
    }
  return returnValue;
}

XmlToken * StatsTemperatureType::gettemperatureUnit()
{return temperatureUnit;}

void StatsTemperatureType::settemperatureUnit(XmlToken * temperatureUnitIn)
{temperatureUnit = temperatureUnitIn;}

/* ***************************************************************** */

/* class StatsTimeType

*/

StatsTimeType::StatsTimeType() :
  StatsNumericalBaseType()
{
  timeUnit = 0;
}

StatsTimeType::StatsTimeType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicStatsValueIn) :
  StatsNumericalBaseType(
    AttributesIn,
    NumericCharacteristicStatsValueIn)
{
  timeUnit = 0;
}

StatsTimeType::StatsTimeType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicStatsValueIn,
 XmlToken * timeUnitIn) :
  StatsNumericalBaseType(
    AttributesIn,
    NumericCharacteristicStatsValueIn)
{
  timeUnit = timeUnitIn;
}

StatsTimeType::~StatsTimeType()
{
  #ifndef NODESTRUCT
  delete timeUnit;
  #endif
}

void StatsTimeType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (timeUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "timeUnit=\"");
      timeUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  {
    if (!NumericCharacteristicStatsValue)
      {
        fprintf(stderr, "NumericCharacteristicStatsValue list is missing\n");
        exit(1);
      }
    if (NumericCharacteristicStatsValue->size() == 0)
      {
        fprintf(stderr, "NumericCharacteristicStatsValue list is empty\n");
        exit(1);
      }
    if (NumericCharacteristicStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of NumericCharacteristicStatsValue list (%d) less than minimum required (1)\n",
                (int)NumericCharacteristicStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = NumericCharacteristicStatsValue->begin();
         iter != NumericCharacteristicStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "CommonStatsValue") == 0)
          {
            StatsWithReferenceBaseType * typ;
            if ((typ = dynamic_cast<StatsWithReferenceBaseType *>(basie)))
              {
                fprintf(outFile, "<CommonStatsValue");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CommonStatsValue>\n");
              }
            else
              {
                fprintf(stderr, "bad CommonStatsValue element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Average") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Average");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Average>\n");
              }
            else
              {
                fprintf(stderr, "bad Average element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupAverages") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupAverages");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupAverages>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupAverages element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Difference") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Difference");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Difference>\n");
              }
            else
              {
                fprintf(stderr, "bad Difference element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupDifferences") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupDifferences");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupDifferences>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupDifferences element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RootMeanSquare") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RootMeanSquare");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RootMeanSquare>\n");
              }
            else
              {
                fprintf(stderr, "bad RootMeanSquare element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Maximum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Maximum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Maximum>\n");
              }
            else
              {
                fprintf(stderr, "bad Maximum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMaxima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMaxima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMaxima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMaxima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Minimum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Minimum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Minimum>\n");
              }
            else
              {
                fprintf(stderr, "bad Minimum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMinima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMinima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMinima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMinima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Range") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Range");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Range>\n");
              }
            else
              {
                fprintf(stderr, "bad Range element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupRanges") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupRanges");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupRanges>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupRanges element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AverageRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AverageRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AverageRange>\n");
              }
            else
              {
                fprintf(stderr, "bad AverageRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "StandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<StandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</StandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad StandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Skew") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Skew");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Skew>\n");
              }
            else
              {
                fprintf(stderr, "bad Skew element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Kurtosis") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Kurtosis");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Kurtosis>\n");
              }
            else
              {
                fprintf(stderr, "bad Kurtosis element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Normality") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Normality");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Normality>\n");
              }
            else
              {
                fprintf(stderr, "bad Normality element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "ProcessVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<ProcessVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ProcessVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad ProcessVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EstimatedStandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EstimatedStandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EstimatedStandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad EstimatedStandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOutOfControl") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOutOfControl");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOutOfControl>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOutOfControl element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AppraiserVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AppraiserVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AppraiserVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad AppraiserVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EquipmentVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EquipmentVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EquipmentVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad EquipmentVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Interaction") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Interaction");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Interaction>\n");
              }
            else
              {
                fprintf(stderr, "bad Interaction element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GageRandR") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GageRandR");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GageRandR>\n");
              }
            else
              {
                fprintf(stderr, "bad GageRandR element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "PartVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<PartVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PartVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad PartVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TotalVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Linearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Linearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Linearity>\n");
              }
            else
              {
                fprintf(stderr, "bad Linearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Bias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Bias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Bias>\n");
              }
            else
              {
                fprintf(stderr, "bad Bias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeLinearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeLinearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeLinearity>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeLinearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeBias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeBias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeBias>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeBias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GoodnessOfFit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GoodnessOfFit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GoodnessOfFit>\n");
              }
            else
              {
                fprintf(stderr, "bad GoodnessOfFit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionSlope") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionSlope");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionSlope>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionSlope element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionIntercept") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionIntercept");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionIntercept>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionIntercept element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TDistribution") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TDistribution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TDistribution>\n");
              }
            else
              {
                fprintf(stderr, "bad TDistribution element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<TotalNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupTotalNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupTotalNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupTotalNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupTotalNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EffectiveNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<EffectiveNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupEffectiveNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupEffectiveNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupEffectiveNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupEffectiveNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberSubgroups") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberSubgroups");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberSubgroups>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberSubgroups element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad NumericCharacteristicStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool StatsTimeType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "timeUnit")
        {
          XmlToken * timeUnitVal;
          if (this->timeUnit)
            {
              fprintf(stderr, "two values for timeUnit in StatsTimeType\n");
              returnValue = true;
              break;
            }
          timeUnitVal = new XmlToken(decl->val.c_str());
          if (timeUnitVal->bad)
            {
              delete timeUnitVal;
              fprintf(stderr, "bad value %s for timeUnit in StatsTimeType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->timeUnit = timeUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in StatsTimeType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->timeUnit;
      this->timeUnit = 0;
    }
  return returnValue;
}

XmlToken * StatsTimeType::gettimeUnit()
{return timeUnit;}

void StatsTimeType::settimeUnit(XmlToken * timeUnitIn)
{timeUnit = timeUnitIn;}

/* ***************************************************************** */

/* class StatsUserDefinedUnitType

*/

StatsUserDefinedUnitType::StatsUserDefinedUnitType() :
  StatsNumericalBaseType()
{
  unitName = 0;
}

StatsUserDefinedUnitType::StatsUserDefinedUnitType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicStatsValueIn) :
  StatsNumericalBaseType(
    AttributesIn,
    NumericCharacteristicStatsValueIn)
{
  unitName = 0;
}

StatsUserDefinedUnitType::StatsUserDefinedUnitType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicStatsValueIn,
 XmlToken * unitNameIn) :
  StatsNumericalBaseType(
    AttributesIn,
    NumericCharacteristicStatsValueIn)
{
  unitName = unitNameIn;
}

StatsUserDefinedUnitType::~StatsUserDefinedUnitType()
{
  #ifndef NODESTRUCT
  delete unitName;
  #endif
}

void StatsUserDefinedUnitType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (unitName)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "unitName=\"");
      unitName->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"unitName\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  {
    if (!NumericCharacteristicStatsValue)
      {
        fprintf(stderr, "NumericCharacteristicStatsValue list is missing\n");
        exit(1);
      }
    if (NumericCharacteristicStatsValue->size() == 0)
      {
        fprintf(stderr, "NumericCharacteristicStatsValue list is empty\n");
        exit(1);
      }
    if (NumericCharacteristicStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of NumericCharacteristicStatsValue list (%d) less than minimum required (1)\n",
                (int)NumericCharacteristicStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = NumericCharacteristicStatsValue->begin();
         iter != NumericCharacteristicStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "CommonStatsValue") == 0)
          {
            StatsWithReferenceBaseType * typ;
            if ((typ = dynamic_cast<StatsWithReferenceBaseType *>(basie)))
              {
                fprintf(outFile, "<CommonStatsValue");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CommonStatsValue>\n");
              }
            else
              {
                fprintf(stderr, "bad CommonStatsValue element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Average") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Average");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Average>\n");
              }
            else
              {
                fprintf(stderr, "bad Average element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupAverages") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupAverages");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupAverages>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupAverages element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Difference") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Difference");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Difference>\n");
              }
            else
              {
                fprintf(stderr, "bad Difference element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupDifferences") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupDifferences");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupDifferences>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupDifferences element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RootMeanSquare") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RootMeanSquare");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RootMeanSquare>\n");
              }
            else
              {
                fprintf(stderr, "bad RootMeanSquare element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Maximum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Maximum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Maximum>\n");
              }
            else
              {
                fprintf(stderr, "bad Maximum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMaxima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMaxima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMaxima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMaxima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Minimum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Minimum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Minimum>\n");
              }
            else
              {
                fprintf(stderr, "bad Minimum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMinima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMinima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMinima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMinima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Range") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Range");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Range>\n");
              }
            else
              {
                fprintf(stderr, "bad Range element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupRanges") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupRanges");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupRanges>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupRanges element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AverageRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AverageRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AverageRange>\n");
              }
            else
              {
                fprintf(stderr, "bad AverageRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "StandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<StandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</StandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad StandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Skew") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Skew");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Skew>\n");
              }
            else
              {
                fprintf(stderr, "bad Skew element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Kurtosis") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Kurtosis");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Kurtosis>\n");
              }
            else
              {
                fprintf(stderr, "bad Kurtosis element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Normality") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Normality");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Normality>\n");
              }
            else
              {
                fprintf(stderr, "bad Normality element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "ProcessVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<ProcessVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ProcessVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad ProcessVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EstimatedStandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EstimatedStandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EstimatedStandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad EstimatedStandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOutOfControl") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOutOfControl");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOutOfControl>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOutOfControl element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AppraiserVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AppraiserVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AppraiserVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad AppraiserVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EquipmentVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EquipmentVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EquipmentVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad EquipmentVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Interaction") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Interaction");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Interaction>\n");
              }
            else
              {
                fprintf(stderr, "bad Interaction element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GageRandR") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GageRandR");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GageRandR>\n");
              }
            else
              {
                fprintf(stderr, "bad GageRandR element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "PartVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<PartVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PartVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad PartVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TotalVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Linearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Linearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Linearity>\n");
              }
            else
              {
                fprintf(stderr, "bad Linearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Bias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Bias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Bias>\n");
              }
            else
              {
                fprintf(stderr, "bad Bias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeLinearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeLinearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeLinearity>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeLinearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeBias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeBias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeBias>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeBias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GoodnessOfFit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GoodnessOfFit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GoodnessOfFit>\n");
              }
            else
              {
                fprintf(stderr, "bad GoodnessOfFit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionSlope") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionSlope");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionSlope>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionSlope element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionIntercept") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionIntercept");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionIntercept>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionIntercept element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TDistribution") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TDistribution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TDistribution>\n");
              }
            else
              {
                fprintf(stderr, "bad TDistribution element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<TotalNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupTotalNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupTotalNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupTotalNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupTotalNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EffectiveNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<EffectiveNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupEffectiveNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupEffectiveNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupEffectiveNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupEffectiveNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberSubgroups") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberSubgroups");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberSubgroups>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberSubgroups element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad NumericCharacteristicStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool StatsUserDefinedUnitType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "unitName")
        {
          XmlToken * unitNameVal;
          if (this->unitName)
            {
              fprintf(stderr, "two values for unitName in StatsUserDefinedUnitType\n");
              returnValue = true;
              break;
            }
          unitNameVal = new XmlToken(decl->val.c_str());
          if (unitNameVal->bad)
            {
              delete unitNameVal;
              fprintf(stderr, "bad value %s for unitName in StatsUserDefinedUnitType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->unitName = unitNameVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in StatsUserDefinedUnitType\n");
          returnValue = true;
          break;
        }
    }
  if (this->unitName == 0)
    {
      fprintf(stderr, "required attribute \"unitName\" missing in StatsUserDefinedUnitType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->unitName;
      this->unitName = 0;
    }
  return returnValue;
}

XmlToken * StatsUserDefinedUnitType::getunitName()
{return unitName;}

void StatsUserDefinedUnitType::setunitName(XmlToken * unitNameIn)
{unitName = unitNameIn;}

/* ***************************************************************** */

/* class StatsValuesType

*/

StatsValuesType::StatsValuesType()
{
  Values = 0;
  Exclusions = 0;
}

StatsValuesType::StatsValuesType(
 ListTokenType * ValuesIn,
 ExclusionsIndexType * ExclusionsIn)
{
  Values = ValuesIn;
  Exclusions = ExclusionsIn;
}

StatsValuesType::~StatsValuesType()
{
  #ifndef NODESTRUCT
  delete Values;
  delete Exclusions;
  #endif
}

void StatsValuesType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<Values");
  Values->printSelf(outFile);
  fprintf(outFile, "</Values>\n");
  if (Exclusions)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Exclusions");
      Exclusions->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Exclusions>\n");
    }
  doSpaces(-INDENT, outFile);
}

ListTokenType * StatsValuesType::getValues()
{return Values;}

void StatsValuesType::setValues(ListTokenType * ValuesIn)
{Values = ValuesIn;}

ExclusionsIndexType * StatsValuesType::getExclusions()
{return Exclusions;}

void StatsValuesType::setExclusions(ExclusionsIndexType * ExclusionsIn)
{Exclusions = ExclusionsIn;}

/* ***************************************************************** */

/* class StatsValuesTypeLisd

*/

StatsValuesTypeLisd::StatsValuesTypeLisd() {}

StatsValuesTypeLisd::StatsValuesTypeLisd(StatsValuesType * aStatsValuesType)
{
  push_back(aStatsValuesType);
}

StatsValuesTypeLisd::~StatsValuesTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<StatsValuesType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void StatsValuesTypeLisd::printSelf(FILE * outFile)
{
  std::list<StatsValuesType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class StatsWithTolAngularType

*/

StatsWithTolAngularType::StatsWithTolAngularType() :
  StatsWithTolNumericalBaseType()
{
  angularUnit = 0;
}

StatsWithTolAngularType::StatsWithTolAngularType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicWithTolStatsValueIn) :
  StatsWithTolNumericalBaseType(
    AttributesIn,
    NumericCharacteristicWithTolStatsValueIn)
{
  angularUnit = 0;
}

StatsWithTolAngularType::StatsWithTolAngularType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicWithTolStatsValueIn,
 XmlToken * angularUnitIn) :
  StatsWithTolNumericalBaseType(
    AttributesIn,
    NumericCharacteristicWithTolStatsValueIn)
{
  angularUnit = angularUnitIn;
}

StatsWithTolAngularType::~StatsWithTolAngularType()
{
  #ifndef NODESTRUCT
  delete angularUnit;
  #endif
}

void StatsWithTolAngularType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (angularUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "angularUnit=\"");
      angularUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  {
    if (!NumericCharacteristicWithTolStatsValue)
      {
        fprintf(stderr, "NumericCharacteristicWithTolStatsValue list is missing\n");
        exit(1);
      }
    if (NumericCharacteristicWithTolStatsValue->size() == 0)
      {
        fprintf(stderr, "NumericCharacteristicWithTolStatsValue list is empty\n");
        exit(1);
      }
    if (NumericCharacteristicWithTolStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of NumericCharacteristicWithTolStatsValue list (%d) less than minimum required (1)\n",
                (int)NumericCharacteristicWithTolStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = NumericCharacteristicWithTolStatsValue->begin();
         iter != NumericCharacteristicWithTolStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "NumericCharacteristicStatsValue") == 0)
          {
            StatsWithReferenceBaseType * typ;
            if ((typ = dynamic_cast<StatsWithReferenceBaseType *>(basie)))
              {
                fprintf(outFile, "<NumericCharacteristicStatsValue");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumericCharacteristicStatsValue>\n");
              }
            else
              {
                fprintf(stderr, "bad NumericCharacteristicStatsValue element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOutOfTolerance") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOutOfTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOutOfTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOutOfTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupNumbersOutOfTolerance") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupNumbersOutOfTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupNumbersOutOfTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupNumbersOutOfTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOverUpperTolerance") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOverUpperTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOverUpperTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOverUpperTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupNumbersOverUpperTolerance") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupNumbersOverUpperTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupNumbersOverUpperTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupNumbersOverUpperTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberUnderLowerTolerance") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberUnderLowerTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberUnderLowerTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberUnderLowerTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupNumbersUnderLowerTolerance") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupNumbersUnderLowerTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupNumbersUnderLowerTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupNumbersUnderLowerTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cp") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cp");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cp>\n");
              }
            else
              {
                fprintf(stderr, "bad Cp element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cpk") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cpk");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cpk>\n");
              }
            else
              {
                fprintf(stderr, "bad Cpk element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Pp") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Pp");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Pp>\n");
              }
            else
              {
                fprintf(stderr, "bad Pp element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Ppk") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Ppk");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Ppk>\n");
              }
            else
              {
                fprintf(stderr, "bad Ppk element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cm") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cm");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cm>\n");
              }
            else
              {
                fprintf(stderr, "bad Cm element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cmk") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cmk");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cmk>\n");
              }
            else
              {
                fprintf(stderr, "bad Cmk element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cpm") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cpm");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cpm>\n");
              }
            else
              {
                fprintf(stderr, "bad Cpm element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeAppraiserVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeAppraiserVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeAppraiserVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeAppraiserVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeEquipmentVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeEquipmentVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeEquipmentVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeEquipmentVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeInteraction") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeInteraction");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeInteraction>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeInteraction element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeGageRandR") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeGageRandR");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeGageRandR>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeGageRandR element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativePartVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativePartVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativePartVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativePartVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeTotalVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeTotalVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeTotalVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeTotalVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "CommonStatsValue") == 0)
          {
            StatsWithReferenceBaseType * typ;
            if ((typ = dynamic_cast<StatsWithReferenceBaseType *>(basie)))
              {
                fprintf(outFile, "<CommonStatsValue");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CommonStatsValue>\n");
              }
            else
              {
                fprintf(stderr, "bad CommonStatsValue element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Average") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Average");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Average>\n");
              }
            else
              {
                fprintf(stderr, "bad Average element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupAverages") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupAverages");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupAverages>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupAverages element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Difference") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Difference");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Difference>\n");
              }
            else
              {
                fprintf(stderr, "bad Difference element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupDifferences") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupDifferences");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupDifferences>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupDifferences element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RootMeanSquare") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RootMeanSquare");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RootMeanSquare>\n");
              }
            else
              {
                fprintf(stderr, "bad RootMeanSquare element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Maximum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Maximum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Maximum>\n");
              }
            else
              {
                fprintf(stderr, "bad Maximum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMaxima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMaxima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMaxima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMaxima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Minimum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Minimum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Minimum>\n");
              }
            else
              {
                fprintf(stderr, "bad Minimum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMinima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMinima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMinima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMinima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Range") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Range");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Range>\n");
              }
            else
              {
                fprintf(stderr, "bad Range element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupRanges") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupRanges");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupRanges>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupRanges element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AverageRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AverageRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AverageRange>\n");
              }
            else
              {
                fprintf(stderr, "bad AverageRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "StandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<StandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</StandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad StandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Skew") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Skew");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Skew>\n");
              }
            else
              {
                fprintf(stderr, "bad Skew element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Kurtosis") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Kurtosis");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Kurtosis>\n");
              }
            else
              {
                fprintf(stderr, "bad Kurtosis element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Normality") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Normality");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Normality>\n");
              }
            else
              {
                fprintf(stderr, "bad Normality element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "ProcessVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<ProcessVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ProcessVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad ProcessVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EstimatedStandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EstimatedStandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EstimatedStandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad EstimatedStandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOutOfControl") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOutOfControl");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOutOfControl>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOutOfControl element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AppraiserVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AppraiserVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AppraiserVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad AppraiserVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EquipmentVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EquipmentVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EquipmentVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad EquipmentVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Interaction") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Interaction");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Interaction>\n");
              }
            else
              {
                fprintf(stderr, "bad Interaction element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GageRandR") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GageRandR");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GageRandR>\n");
              }
            else
              {
                fprintf(stderr, "bad GageRandR element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "PartVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<PartVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PartVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad PartVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TotalVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Linearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Linearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Linearity>\n");
              }
            else
              {
                fprintf(stderr, "bad Linearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Bias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Bias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Bias>\n");
              }
            else
              {
                fprintf(stderr, "bad Bias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeLinearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeLinearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeLinearity>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeLinearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeBias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeBias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeBias>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeBias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GoodnessOfFit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GoodnessOfFit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GoodnessOfFit>\n");
              }
            else
              {
                fprintf(stderr, "bad GoodnessOfFit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionSlope") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionSlope");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionSlope>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionSlope element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionIntercept") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionIntercept");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionIntercept>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionIntercept element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TDistribution") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TDistribution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TDistribution>\n");
              }
            else
              {
                fprintf(stderr, "bad TDistribution element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<TotalNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupTotalNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupTotalNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupTotalNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupTotalNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EffectiveNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<EffectiveNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupEffectiveNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupEffectiveNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupEffectiveNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupEffectiveNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberSubgroups") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberSubgroups");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberSubgroups>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberSubgroups element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<TotalNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupTotalNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupTotalNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupTotalNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupTotalNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EffectiveNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<EffectiveNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupEffectiveNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupEffectiveNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupEffectiveNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupEffectiveNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberSubgroups") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberSubgroups");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberSubgroups>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberSubgroups element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad NumericCharacteristicWithTolStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool StatsWithTolAngularType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "angularUnit")
        {
          XmlToken * angularUnitVal;
          if (this->angularUnit)
            {
              fprintf(stderr, "two values for angularUnit in StatsWithTolAngularType\n");
              returnValue = true;
              break;
            }
          angularUnitVal = new XmlToken(decl->val.c_str());
          if (angularUnitVal->bad)
            {
              delete angularUnitVal;
              fprintf(stderr, "bad value %s for angularUnit in StatsWithTolAngularType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->angularUnit = angularUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in StatsWithTolAngularType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->angularUnit;
      this->angularUnit = 0;
    }
  return returnValue;
}

XmlToken * StatsWithTolAngularType::getangularUnit()
{return angularUnit;}

void StatsWithTolAngularType::setangularUnit(XmlToken * angularUnitIn)
{angularUnit = angularUnitIn;}

/* ***************************************************************** */

/* class StatsWithTolAreaType

*/

StatsWithTolAreaType::StatsWithTolAreaType() :
  StatsWithTolNumericalBaseType()
{
  areaUnit = 0;
}

StatsWithTolAreaType::StatsWithTolAreaType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicWithTolStatsValueIn) :
  StatsWithTolNumericalBaseType(
    AttributesIn,
    NumericCharacteristicWithTolStatsValueIn)
{
  areaUnit = 0;
}

StatsWithTolAreaType::StatsWithTolAreaType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicWithTolStatsValueIn,
 XmlToken * areaUnitIn) :
  StatsWithTolNumericalBaseType(
    AttributesIn,
    NumericCharacteristicWithTolStatsValueIn)
{
  areaUnit = areaUnitIn;
}

StatsWithTolAreaType::~StatsWithTolAreaType()
{
  #ifndef NODESTRUCT
  delete areaUnit;
  #endif
}

void StatsWithTolAreaType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (areaUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "areaUnit=\"");
      areaUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  {
    if (!NumericCharacteristicWithTolStatsValue)
      {
        fprintf(stderr, "NumericCharacteristicWithTolStatsValue list is missing\n");
        exit(1);
      }
    if (NumericCharacteristicWithTolStatsValue->size() == 0)
      {
        fprintf(stderr, "NumericCharacteristicWithTolStatsValue list is empty\n");
        exit(1);
      }
    if (NumericCharacteristicWithTolStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of NumericCharacteristicWithTolStatsValue list (%d) less than minimum required (1)\n",
                (int)NumericCharacteristicWithTolStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = NumericCharacteristicWithTolStatsValue->begin();
         iter != NumericCharacteristicWithTolStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "NumericCharacteristicStatsValue") == 0)
          {
            StatsWithReferenceBaseType * typ;
            if ((typ = dynamic_cast<StatsWithReferenceBaseType *>(basie)))
              {
                fprintf(outFile, "<NumericCharacteristicStatsValue");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumericCharacteristicStatsValue>\n");
              }
            else
              {
                fprintf(stderr, "bad NumericCharacteristicStatsValue element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOutOfTolerance") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOutOfTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOutOfTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOutOfTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupNumbersOutOfTolerance") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupNumbersOutOfTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupNumbersOutOfTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupNumbersOutOfTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOverUpperTolerance") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOverUpperTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOverUpperTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOverUpperTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupNumbersOverUpperTolerance") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupNumbersOverUpperTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupNumbersOverUpperTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupNumbersOverUpperTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberUnderLowerTolerance") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberUnderLowerTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberUnderLowerTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberUnderLowerTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupNumbersUnderLowerTolerance") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupNumbersUnderLowerTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupNumbersUnderLowerTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupNumbersUnderLowerTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cp") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cp");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cp>\n");
              }
            else
              {
                fprintf(stderr, "bad Cp element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cpk") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cpk");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cpk>\n");
              }
            else
              {
                fprintf(stderr, "bad Cpk element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Pp") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Pp");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Pp>\n");
              }
            else
              {
                fprintf(stderr, "bad Pp element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Ppk") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Ppk");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Ppk>\n");
              }
            else
              {
                fprintf(stderr, "bad Ppk element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cm") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cm");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cm>\n");
              }
            else
              {
                fprintf(stderr, "bad Cm element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cmk") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cmk");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cmk>\n");
              }
            else
              {
                fprintf(stderr, "bad Cmk element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cpm") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cpm");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cpm>\n");
              }
            else
              {
                fprintf(stderr, "bad Cpm element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeAppraiserVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeAppraiserVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeAppraiserVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeAppraiserVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeEquipmentVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeEquipmentVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeEquipmentVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeEquipmentVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeInteraction") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeInteraction");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeInteraction>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeInteraction element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeGageRandR") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeGageRandR");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeGageRandR>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeGageRandR element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativePartVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativePartVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativePartVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativePartVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeTotalVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeTotalVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeTotalVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeTotalVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "CommonStatsValue") == 0)
          {
            StatsWithReferenceBaseType * typ;
            if ((typ = dynamic_cast<StatsWithReferenceBaseType *>(basie)))
              {
                fprintf(outFile, "<CommonStatsValue");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CommonStatsValue>\n");
              }
            else
              {
                fprintf(stderr, "bad CommonStatsValue element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Average") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Average");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Average>\n");
              }
            else
              {
                fprintf(stderr, "bad Average element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupAverages") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupAverages");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupAverages>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupAverages element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Difference") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Difference");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Difference>\n");
              }
            else
              {
                fprintf(stderr, "bad Difference element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupDifferences") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupDifferences");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupDifferences>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupDifferences element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RootMeanSquare") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RootMeanSquare");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RootMeanSquare>\n");
              }
            else
              {
                fprintf(stderr, "bad RootMeanSquare element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Maximum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Maximum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Maximum>\n");
              }
            else
              {
                fprintf(stderr, "bad Maximum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMaxima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMaxima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMaxima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMaxima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Minimum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Minimum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Minimum>\n");
              }
            else
              {
                fprintf(stderr, "bad Minimum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMinima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMinima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMinima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMinima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Range") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Range");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Range>\n");
              }
            else
              {
                fprintf(stderr, "bad Range element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupRanges") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupRanges");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupRanges>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupRanges element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AverageRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AverageRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AverageRange>\n");
              }
            else
              {
                fprintf(stderr, "bad AverageRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "StandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<StandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</StandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad StandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Skew") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Skew");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Skew>\n");
              }
            else
              {
                fprintf(stderr, "bad Skew element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Kurtosis") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Kurtosis");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Kurtosis>\n");
              }
            else
              {
                fprintf(stderr, "bad Kurtosis element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Normality") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Normality");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Normality>\n");
              }
            else
              {
                fprintf(stderr, "bad Normality element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "ProcessVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<ProcessVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ProcessVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad ProcessVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EstimatedStandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EstimatedStandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EstimatedStandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad EstimatedStandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOutOfControl") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOutOfControl");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOutOfControl>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOutOfControl element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AppraiserVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AppraiserVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AppraiserVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad AppraiserVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EquipmentVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EquipmentVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EquipmentVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad EquipmentVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Interaction") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Interaction");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Interaction>\n");
              }
            else
              {
                fprintf(stderr, "bad Interaction element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GageRandR") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GageRandR");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GageRandR>\n");
              }
            else
              {
                fprintf(stderr, "bad GageRandR element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "PartVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<PartVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PartVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad PartVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TotalVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Linearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Linearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Linearity>\n");
              }
            else
              {
                fprintf(stderr, "bad Linearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Bias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Bias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Bias>\n");
              }
            else
              {
                fprintf(stderr, "bad Bias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeLinearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeLinearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeLinearity>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeLinearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeBias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeBias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeBias>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeBias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GoodnessOfFit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GoodnessOfFit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GoodnessOfFit>\n");
              }
            else
              {
                fprintf(stderr, "bad GoodnessOfFit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionSlope") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionSlope");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionSlope>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionSlope element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionIntercept") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionIntercept");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionIntercept>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionIntercept element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TDistribution") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TDistribution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TDistribution>\n");
              }
            else
              {
                fprintf(stderr, "bad TDistribution element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<TotalNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupTotalNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupTotalNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupTotalNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupTotalNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EffectiveNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<EffectiveNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupEffectiveNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupEffectiveNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupEffectiveNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupEffectiveNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberSubgroups") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberSubgroups");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberSubgroups>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberSubgroups element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<TotalNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupTotalNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupTotalNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupTotalNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupTotalNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EffectiveNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<EffectiveNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupEffectiveNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupEffectiveNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupEffectiveNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupEffectiveNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberSubgroups") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberSubgroups");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberSubgroups>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberSubgroups element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad NumericCharacteristicWithTolStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool StatsWithTolAreaType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "areaUnit")
        {
          XmlToken * areaUnitVal;
          if (this->areaUnit)
            {
              fprintf(stderr, "two values for areaUnit in StatsWithTolAreaType\n");
              returnValue = true;
              break;
            }
          areaUnitVal = new XmlToken(decl->val.c_str());
          if (areaUnitVal->bad)
            {
              delete areaUnitVal;
              fprintf(stderr, "bad value %s for areaUnit in StatsWithTolAreaType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->areaUnit = areaUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in StatsWithTolAreaType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->areaUnit;
      this->areaUnit = 0;
    }
  return returnValue;
}

XmlToken * StatsWithTolAreaType::getareaUnit()
{return areaUnit;}

void StatsWithTolAreaType::setareaUnit(XmlToken * areaUnitIn)
{areaUnit = areaUnitIn;}

/* ***************************************************************** */

/* class StatsWithTolForceType

*/

StatsWithTolForceType::StatsWithTolForceType() :
  StatsWithTolNumericalBaseType()
{
  forceUnit = 0;
}

StatsWithTolForceType::StatsWithTolForceType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicWithTolStatsValueIn) :
  StatsWithTolNumericalBaseType(
    AttributesIn,
    NumericCharacteristicWithTolStatsValueIn)
{
  forceUnit = 0;
}

StatsWithTolForceType::StatsWithTolForceType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicWithTolStatsValueIn,
 XmlToken * forceUnitIn) :
  StatsWithTolNumericalBaseType(
    AttributesIn,
    NumericCharacteristicWithTolStatsValueIn)
{
  forceUnit = forceUnitIn;
}

StatsWithTolForceType::~StatsWithTolForceType()
{
  #ifndef NODESTRUCT
  delete forceUnit;
  #endif
}

void StatsWithTolForceType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (forceUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "forceUnit=\"");
      forceUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  {
    if (!NumericCharacteristicWithTolStatsValue)
      {
        fprintf(stderr, "NumericCharacteristicWithTolStatsValue list is missing\n");
        exit(1);
      }
    if (NumericCharacteristicWithTolStatsValue->size() == 0)
      {
        fprintf(stderr, "NumericCharacteristicWithTolStatsValue list is empty\n");
        exit(1);
      }
    if (NumericCharacteristicWithTolStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of NumericCharacteristicWithTolStatsValue list (%d) less than minimum required (1)\n",
                (int)NumericCharacteristicWithTolStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = NumericCharacteristicWithTolStatsValue->begin();
         iter != NumericCharacteristicWithTolStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "NumericCharacteristicStatsValue") == 0)
          {
            StatsWithReferenceBaseType * typ;
            if ((typ = dynamic_cast<StatsWithReferenceBaseType *>(basie)))
              {
                fprintf(outFile, "<NumericCharacteristicStatsValue");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumericCharacteristicStatsValue>\n");
              }
            else
              {
                fprintf(stderr, "bad NumericCharacteristicStatsValue element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOutOfTolerance") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOutOfTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOutOfTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOutOfTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupNumbersOutOfTolerance") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupNumbersOutOfTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupNumbersOutOfTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupNumbersOutOfTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOverUpperTolerance") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOverUpperTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOverUpperTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOverUpperTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupNumbersOverUpperTolerance") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupNumbersOverUpperTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupNumbersOverUpperTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupNumbersOverUpperTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberUnderLowerTolerance") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberUnderLowerTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberUnderLowerTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberUnderLowerTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupNumbersUnderLowerTolerance") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupNumbersUnderLowerTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupNumbersUnderLowerTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupNumbersUnderLowerTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cp") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cp");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cp>\n");
              }
            else
              {
                fprintf(stderr, "bad Cp element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cpk") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cpk");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cpk>\n");
              }
            else
              {
                fprintf(stderr, "bad Cpk element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Pp") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Pp");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Pp>\n");
              }
            else
              {
                fprintf(stderr, "bad Pp element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Ppk") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Ppk");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Ppk>\n");
              }
            else
              {
                fprintf(stderr, "bad Ppk element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cm") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cm");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cm>\n");
              }
            else
              {
                fprintf(stderr, "bad Cm element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cmk") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cmk");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cmk>\n");
              }
            else
              {
                fprintf(stderr, "bad Cmk element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cpm") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cpm");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cpm>\n");
              }
            else
              {
                fprintf(stderr, "bad Cpm element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeAppraiserVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeAppraiserVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeAppraiserVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeAppraiserVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeEquipmentVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeEquipmentVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeEquipmentVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeEquipmentVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeInteraction") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeInteraction");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeInteraction>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeInteraction element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeGageRandR") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeGageRandR");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeGageRandR>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeGageRandR element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativePartVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativePartVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativePartVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativePartVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeTotalVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeTotalVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeTotalVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeTotalVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "CommonStatsValue") == 0)
          {
            StatsWithReferenceBaseType * typ;
            if ((typ = dynamic_cast<StatsWithReferenceBaseType *>(basie)))
              {
                fprintf(outFile, "<CommonStatsValue");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CommonStatsValue>\n");
              }
            else
              {
                fprintf(stderr, "bad CommonStatsValue element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Average") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Average");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Average>\n");
              }
            else
              {
                fprintf(stderr, "bad Average element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupAverages") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupAverages");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupAverages>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupAverages element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Difference") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Difference");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Difference>\n");
              }
            else
              {
                fprintf(stderr, "bad Difference element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupDifferences") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupDifferences");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupDifferences>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupDifferences element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RootMeanSquare") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RootMeanSquare");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RootMeanSquare>\n");
              }
            else
              {
                fprintf(stderr, "bad RootMeanSquare element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Maximum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Maximum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Maximum>\n");
              }
            else
              {
                fprintf(stderr, "bad Maximum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMaxima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMaxima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMaxima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMaxima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Minimum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Minimum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Minimum>\n");
              }
            else
              {
                fprintf(stderr, "bad Minimum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMinima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMinima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMinima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMinima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Range") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Range");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Range>\n");
              }
            else
              {
                fprintf(stderr, "bad Range element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupRanges") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupRanges");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupRanges>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupRanges element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AverageRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AverageRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AverageRange>\n");
              }
            else
              {
                fprintf(stderr, "bad AverageRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "StandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<StandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</StandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad StandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Skew") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Skew");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Skew>\n");
              }
            else
              {
                fprintf(stderr, "bad Skew element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Kurtosis") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Kurtosis");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Kurtosis>\n");
              }
            else
              {
                fprintf(stderr, "bad Kurtosis element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Normality") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Normality");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Normality>\n");
              }
            else
              {
                fprintf(stderr, "bad Normality element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "ProcessVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<ProcessVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ProcessVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad ProcessVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EstimatedStandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EstimatedStandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EstimatedStandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad EstimatedStandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOutOfControl") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOutOfControl");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOutOfControl>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOutOfControl element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AppraiserVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AppraiserVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AppraiserVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad AppraiserVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EquipmentVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EquipmentVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EquipmentVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad EquipmentVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Interaction") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Interaction");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Interaction>\n");
              }
            else
              {
                fprintf(stderr, "bad Interaction element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GageRandR") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GageRandR");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GageRandR>\n");
              }
            else
              {
                fprintf(stderr, "bad GageRandR element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "PartVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<PartVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PartVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad PartVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TotalVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Linearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Linearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Linearity>\n");
              }
            else
              {
                fprintf(stderr, "bad Linearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Bias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Bias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Bias>\n");
              }
            else
              {
                fprintf(stderr, "bad Bias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeLinearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeLinearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeLinearity>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeLinearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeBias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeBias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeBias>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeBias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GoodnessOfFit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GoodnessOfFit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GoodnessOfFit>\n");
              }
            else
              {
                fprintf(stderr, "bad GoodnessOfFit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionSlope") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionSlope");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionSlope>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionSlope element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionIntercept") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionIntercept");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionIntercept>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionIntercept element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TDistribution") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TDistribution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TDistribution>\n");
              }
            else
              {
                fprintf(stderr, "bad TDistribution element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<TotalNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupTotalNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupTotalNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupTotalNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupTotalNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EffectiveNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<EffectiveNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupEffectiveNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupEffectiveNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupEffectiveNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupEffectiveNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberSubgroups") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberSubgroups");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberSubgroups>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberSubgroups element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<TotalNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupTotalNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupTotalNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupTotalNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupTotalNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EffectiveNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<EffectiveNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupEffectiveNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupEffectiveNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupEffectiveNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupEffectiveNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberSubgroups") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberSubgroups");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberSubgroups>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberSubgroups element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad NumericCharacteristicWithTolStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool StatsWithTolForceType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "forceUnit")
        {
          XmlToken * forceUnitVal;
          if (this->forceUnit)
            {
              fprintf(stderr, "two values for forceUnit in StatsWithTolForceType\n");
              returnValue = true;
              break;
            }
          forceUnitVal = new XmlToken(decl->val.c_str());
          if (forceUnitVal->bad)
            {
              delete forceUnitVal;
              fprintf(stderr, "bad value %s for forceUnit in StatsWithTolForceType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->forceUnit = forceUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in StatsWithTolForceType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->forceUnit;
      this->forceUnit = 0;
    }
  return returnValue;
}

XmlToken * StatsWithTolForceType::getforceUnit()
{return forceUnit;}

void StatsWithTolForceType::setforceUnit(XmlToken * forceUnitIn)
{forceUnit = forceUnitIn;}

/* ***************************************************************** */

/* class StatsWithTolLinearType

*/

StatsWithTolLinearType::StatsWithTolLinearType() :
  StatsWithTolNumericalBaseType()
{
  linearUnit = 0;
}

StatsWithTolLinearType::StatsWithTolLinearType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicWithTolStatsValueIn) :
  StatsWithTolNumericalBaseType(
    AttributesIn,
    NumericCharacteristicWithTolStatsValueIn)
{
  linearUnit = 0;
}

StatsWithTolLinearType::StatsWithTolLinearType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicWithTolStatsValueIn,
 XmlToken * linearUnitIn) :
  StatsWithTolNumericalBaseType(
    AttributesIn,
    NumericCharacteristicWithTolStatsValueIn)
{
  linearUnit = linearUnitIn;
}

StatsWithTolLinearType::~StatsWithTolLinearType()
{
  #ifndef NODESTRUCT
  delete linearUnit;
  #endif
}

void StatsWithTolLinearType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (linearUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "linearUnit=\"");
      linearUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  {
    if (!NumericCharacteristicWithTolStatsValue)
      {
        fprintf(stderr, "NumericCharacteristicWithTolStatsValue list is missing\n");
        exit(1);
      }
    if (NumericCharacteristicWithTolStatsValue->size() == 0)
      {
        fprintf(stderr, "NumericCharacteristicWithTolStatsValue list is empty\n");
        exit(1);
      }
    if (NumericCharacteristicWithTolStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of NumericCharacteristicWithTolStatsValue list (%d) less than minimum required (1)\n",
                (int)NumericCharacteristicWithTolStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = NumericCharacteristicWithTolStatsValue->begin();
         iter != NumericCharacteristicWithTolStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "NumericCharacteristicStatsValue") == 0)
          {
            StatsWithReferenceBaseType * typ;
            if ((typ = dynamic_cast<StatsWithReferenceBaseType *>(basie)))
              {
                fprintf(outFile, "<NumericCharacteristicStatsValue");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumericCharacteristicStatsValue>\n");
              }
            else
              {
                fprintf(stderr, "bad NumericCharacteristicStatsValue element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOutOfTolerance") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOutOfTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOutOfTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOutOfTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupNumbersOutOfTolerance") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupNumbersOutOfTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupNumbersOutOfTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupNumbersOutOfTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOverUpperTolerance") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOverUpperTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOverUpperTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOverUpperTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupNumbersOverUpperTolerance") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupNumbersOverUpperTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupNumbersOverUpperTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupNumbersOverUpperTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberUnderLowerTolerance") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberUnderLowerTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberUnderLowerTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberUnderLowerTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupNumbersUnderLowerTolerance") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupNumbersUnderLowerTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupNumbersUnderLowerTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupNumbersUnderLowerTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cp") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cp");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cp>\n");
              }
            else
              {
                fprintf(stderr, "bad Cp element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cpk") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cpk");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cpk>\n");
              }
            else
              {
                fprintf(stderr, "bad Cpk element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Pp") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Pp");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Pp>\n");
              }
            else
              {
                fprintf(stderr, "bad Pp element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Ppk") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Ppk");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Ppk>\n");
              }
            else
              {
                fprintf(stderr, "bad Ppk element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cm") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cm");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cm>\n");
              }
            else
              {
                fprintf(stderr, "bad Cm element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cmk") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cmk");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cmk>\n");
              }
            else
              {
                fprintf(stderr, "bad Cmk element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cpm") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cpm");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cpm>\n");
              }
            else
              {
                fprintf(stderr, "bad Cpm element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeAppraiserVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeAppraiserVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeAppraiserVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeAppraiserVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeEquipmentVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeEquipmentVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeEquipmentVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeEquipmentVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeInteraction") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeInteraction");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeInteraction>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeInteraction element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeGageRandR") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeGageRandR");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeGageRandR>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeGageRandR element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativePartVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativePartVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativePartVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativePartVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeTotalVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeTotalVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeTotalVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeTotalVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "CommonStatsValue") == 0)
          {
            StatsWithReferenceBaseType * typ;
            if ((typ = dynamic_cast<StatsWithReferenceBaseType *>(basie)))
              {
                fprintf(outFile, "<CommonStatsValue");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CommonStatsValue>\n");
              }
            else
              {
                fprintf(stderr, "bad CommonStatsValue element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Average") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Average");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Average>\n");
              }
            else
              {
                fprintf(stderr, "bad Average element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupAverages") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupAverages");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupAverages>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupAverages element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Difference") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Difference");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Difference>\n");
              }
            else
              {
                fprintf(stderr, "bad Difference element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupDifferences") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupDifferences");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupDifferences>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupDifferences element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RootMeanSquare") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RootMeanSquare");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RootMeanSquare>\n");
              }
            else
              {
                fprintf(stderr, "bad RootMeanSquare element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Maximum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Maximum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Maximum>\n");
              }
            else
              {
                fprintf(stderr, "bad Maximum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMaxima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMaxima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMaxima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMaxima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Minimum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Minimum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Minimum>\n");
              }
            else
              {
                fprintf(stderr, "bad Minimum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMinima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMinima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMinima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMinima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Range") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Range");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Range>\n");
              }
            else
              {
                fprintf(stderr, "bad Range element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupRanges") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupRanges");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupRanges>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupRanges element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AverageRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AverageRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AverageRange>\n");
              }
            else
              {
                fprintf(stderr, "bad AverageRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "StandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<StandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</StandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad StandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Skew") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Skew");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Skew>\n");
              }
            else
              {
                fprintf(stderr, "bad Skew element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Kurtosis") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Kurtosis");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Kurtosis>\n");
              }
            else
              {
                fprintf(stderr, "bad Kurtosis element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Normality") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Normality");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Normality>\n");
              }
            else
              {
                fprintf(stderr, "bad Normality element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "ProcessVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<ProcessVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ProcessVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad ProcessVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EstimatedStandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EstimatedStandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EstimatedStandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad EstimatedStandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOutOfControl") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOutOfControl");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOutOfControl>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOutOfControl element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AppraiserVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AppraiserVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AppraiserVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad AppraiserVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EquipmentVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EquipmentVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EquipmentVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad EquipmentVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Interaction") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Interaction");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Interaction>\n");
              }
            else
              {
                fprintf(stderr, "bad Interaction element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GageRandR") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GageRandR");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GageRandR>\n");
              }
            else
              {
                fprintf(stderr, "bad GageRandR element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "PartVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<PartVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PartVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad PartVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TotalVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Linearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Linearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Linearity>\n");
              }
            else
              {
                fprintf(stderr, "bad Linearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Bias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Bias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Bias>\n");
              }
            else
              {
                fprintf(stderr, "bad Bias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeLinearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeLinearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeLinearity>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeLinearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeBias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeBias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeBias>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeBias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GoodnessOfFit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GoodnessOfFit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GoodnessOfFit>\n");
              }
            else
              {
                fprintf(stderr, "bad GoodnessOfFit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionSlope") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionSlope");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionSlope>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionSlope element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionIntercept") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionIntercept");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionIntercept>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionIntercept element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TDistribution") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TDistribution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TDistribution>\n");
              }
            else
              {
                fprintf(stderr, "bad TDistribution element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<TotalNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupTotalNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupTotalNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupTotalNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupTotalNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EffectiveNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<EffectiveNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupEffectiveNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupEffectiveNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupEffectiveNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupEffectiveNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberSubgroups") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberSubgroups");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberSubgroups>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberSubgroups element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<TotalNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupTotalNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupTotalNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupTotalNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupTotalNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EffectiveNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<EffectiveNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupEffectiveNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupEffectiveNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupEffectiveNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupEffectiveNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberSubgroups") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberSubgroups");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberSubgroups>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberSubgroups element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad NumericCharacteristicWithTolStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool StatsWithTolLinearType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "linearUnit")
        {
          XmlToken * linearUnitVal;
          if (this->linearUnit)
            {
              fprintf(stderr, "two values for linearUnit in StatsWithTolLinearType\n");
              returnValue = true;
              break;
            }
          linearUnitVal = new XmlToken(decl->val.c_str());
          if (linearUnitVal->bad)
            {
              delete linearUnitVal;
              fprintf(stderr, "bad value %s for linearUnit in StatsWithTolLinearType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->linearUnit = linearUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in StatsWithTolLinearType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->linearUnit;
      this->linearUnit = 0;
    }
  return returnValue;
}

XmlToken * StatsWithTolLinearType::getlinearUnit()
{return linearUnit;}

void StatsWithTolLinearType::setlinearUnit(XmlToken * linearUnitIn)
{linearUnit = linearUnitIn;}

/* ***************************************************************** */

/* class StatsWithTolMassType

*/

StatsWithTolMassType::StatsWithTolMassType() :
  StatsWithTolNumericalBaseType()
{
  massUnit = 0;
}

StatsWithTolMassType::StatsWithTolMassType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicWithTolStatsValueIn) :
  StatsWithTolNumericalBaseType(
    AttributesIn,
    NumericCharacteristicWithTolStatsValueIn)
{
  massUnit = 0;
}

StatsWithTolMassType::StatsWithTolMassType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicWithTolStatsValueIn,
 XmlToken * massUnitIn) :
  StatsWithTolNumericalBaseType(
    AttributesIn,
    NumericCharacteristicWithTolStatsValueIn)
{
  massUnit = massUnitIn;
}

StatsWithTolMassType::~StatsWithTolMassType()
{
  #ifndef NODESTRUCT
  delete massUnit;
  #endif
}

void StatsWithTolMassType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (massUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "massUnit=\"");
      massUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  {
    if (!NumericCharacteristicWithTolStatsValue)
      {
        fprintf(stderr, "NumericCharacteristicWithTolStatsValue list is missing\n");
        exit(1);
      }
    if (NumericCharacteristicWithTolStatsValue->size() == 0)
      {
        fprintf(stderr, "NumericCharacteristicWithTolStatsValue list is empty\n");
        exit(1);
      }
    if (NumericCharacteristicWithTolStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of NumericCharacteristicWithTolStatsValue list (%d) less than minimum required (1)\n",
                (int)NumericCharacteristicWithTolStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = NumericCharacteristicWithTolStatsValue->begin();
         iter != NumericCharacteristicWithTolStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "NumericCharacteristicStatsValue") == 0)
          {
            StatsWithReferenceBaseType * typ;
            if ((typ = dynamic_cast<StatsWithReferenceBaseType *>(basie)))
              {
                fprintf(outFile, "<NumericCharacteristicStatsValue");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumericCharacteristicStatsValue>\n");
              }
            else
              {
                fprintf(stderr, "bad NumericCharacteristicStatsValue element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOutOfTolerance") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOutOfTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOutOfTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOutOfTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupNumbersOutOfTolerance") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupNumbersOutOfTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupNumbersOutOfTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupNumbersOutOfTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOverUpperTolerance") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOverUpperTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOverUpperTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOverUpperTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupNumbersOverUpperTolerance") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupNumbersOverUpperTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupNumbersOverUpperTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupNumbersOverUpperTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberUnderLowerTolerance") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberUnderLowerTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberUnderLowerTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberUnderLowerTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupNumbersUnderLowerTolerance") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupNumbersUnderLowerTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupNumbersUnderLowerTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupNumbersUnderLowerTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cp") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cp");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cp>\n");
              }
            else
              {
                fprintf(stderr, "bad Cp element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cpk") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cpk");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cpk>\n");
              }
            else
              {
                fprintf(stderr, "bad Cpk element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Pp") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Pp");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Pp>\n");
              }
            else
              {
                fprintf(stderr, "bad Pp element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Ppk") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Ppk");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Ppk>\n");
              }
            else
              {
                fprintf(stderr, "bad Ppk element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cm") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cm");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cm>\n");
              }
            else
              {
                fprintf(stderr, "bad Cm element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cmk") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cmk");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cmk>\n");
              }
            else
              {
                fprintf(stderr, "bad Cmk element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cpm") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cpm");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cpm>\n");
              }
            else
              {
                fprintf(stderr, "bad Cpm element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeAppraiserVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeAppraiserVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeAppraiserVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeAppraiserVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeEquipmentVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeEquipmentVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeEquipmentVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeEquipmentVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeInteraction") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeInteraction");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeInteraction>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeInteraction element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeGageRandR") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeGageRandR");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeGageRandR>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeGageRandR element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativePartVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativePartVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativePartVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativePartVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeTotalVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeTotalVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeTotalVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeTotalVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "CommonStatsValue") == 0)
          {
            StatsWithReferenceBaseType * typ;
            if ((typ = dynamic_cast<StatsWithReferenceBaseType *>(basie)))
              {
                fprintf(outFile, "<CommonStatsValue");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CommonStatsValue>\n");
              }
            else
              {
                fprintf(stderr, "bad CommonStatsValue element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Average") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Average");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Average>\n");
              }
            else
              {
                fprintf(stderr, "bad Average element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupAverages") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupAverages");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupAverages>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupAverages element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Difference") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Difference");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Difference>\n");
              }
            else
              {
                fprintf(stderr, "bad Difference element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupDifferences") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupDifferences");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupDifferences>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupDifferences element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RootMeanSquare") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RootMeanSquare");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RootMeanSquare>\n");
              }
            else
              {
                fprintf(stderr, "bad RootMeanSquare element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Maximum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Maximum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Maximum>\n");
              }
            else
              {
                fprintf(stderr, "bad Maximum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMaxima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMaxima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMaxima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMaxima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Minimum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Minimum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Minimum>\n");
              }
            else
              {
                fprintf(stderr, "bad Minimum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMinima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMinima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMinima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMinima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Range") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Range");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Range>\n");
              }
            else
              {
                fprintf(stderr, "bad Range element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupRanges") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupRanges");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupRanges>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupRanges element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AverageRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AverageRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AverageRange>\n");
              }
            else
              {
                fprintf(stderr, "bad AverageRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "StandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<StandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</StandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad StandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Skew") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Skew");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Skew>\n");
              }
            else
              {
                fprintf(stderr, "bad Skew element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Kurtosis") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Kurtosis");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Kurtosis>\n");
              }
            else
              {
                fprintf(stderr, "bad Kurtosis element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Normality") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Normality");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Normality>\n");
              }
            else
              {
                fprintf(stderr, "bad Normality element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "ProcessVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<ProcessVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ProcessVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad ProcessVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EstimatedStandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EstimatedStandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EstimatedStandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad EstimatedStandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOutOfControl") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOutOfControl");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOutOfControl>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOutOfControl element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AppraiserVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AppraiserVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AppraiserVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad AppraiserVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EquipmentVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EquipmentVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EquipmentVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad EquipmentVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Interaction") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Interaction");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Interaction>\n");
              }
            else
              {
                fprintf(stderr, "bad Interaction element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GageRandR") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GageRandR");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GageRandR>\n");
              }
            else
              {
                fprintf(stderr, "bad GageRandR element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "PartVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<PartVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PartVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad PartVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TotalVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Linearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Linearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Linearity>\n");
              }
            else
              {
                fprintf(stderr, "bad Linearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Bias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Bias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Bias>\n");
              }
            else
              {
                fprintf(stderr, "bad Bias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeLinearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeLinearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeLinearity>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeLinearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeBias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeBias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeBias>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeBias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GoodnessOfFit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GoodnessOfFit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GoodnessOfFit>\n");
              }
            else
              {
                fprintf(stderr, "bad GoodnessOfFit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionSlope") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionSlope");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionSlope>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionSlope element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionIntercept") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionIntercept");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionIntercept>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionIntercept element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TDistribution") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TDistribution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TDistribution>\n");
              }
            else
              {
                fprintf(stderr, "bad TDistribution element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<TotalNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupTotalNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupTotalNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupTotalNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupTotalNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EffectiveNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<EffectiveNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupEffectiveNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupEffectiveNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupEffectiveNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupEffectiveNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberSubgroups") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberSubgroups");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberSubgroups>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberSubgroups element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<TotalNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupTotalNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupTotalNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupTotalNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupTotalNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EffectiveNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<EffectiveNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupEffectiveNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupEffectiveNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupEffectiveNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupEffectiveNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberSubgroups") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberSubgroups");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberSubgroups>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberSubgroups element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad NumericCharacteristicWithTolStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool StatsWithTolMassType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "massUnit")
        {
          XmlToken * massUnitVal;
          if (this->massUnit)
            {
              fprintf(stderr, "two values for massUnit in StatsWithTolMassType\n");
              returnValue = true;
              break;
            }
          massUnitVal = new XmlToken(decl->val.c_str());
          if (massUnitVal->bad)
            {
              delete massUnitVal;
              fprintf(stderr, "bad value %s for massUnit in StatsWithTolMassType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->massUnit = massUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in StatsWithTolMassType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->massUnit;
      this->massUnit = 0;
    }
  return returnValue;
}

XmlToken * StatsWithTolMassType::getmassUnit()
{return massUnit;}

void StatsWithTolMassType::setmassUnit(XmlToken * massUnitIn)
{massUnit = massUnitIn;}

/* ***************************************************************** */

/* class StatsWithTolNumericalBaseType

*/

StatsWithTolNumericalBaseType::StatsWithTolNumericalBaseType()
{
  Attributes = 0;
  NumericCharacteristicWithTolStatsValue = 0;
}

StatsWithTolNumericalBaseType::StatsWithTolNumericalBaseType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicWithTolStatsValueIn)
{
  Attributes = AttributesIn;
  NumericCharacteristicWithTolStatsValue = NumericCharacteristicWithTolStatsValueIn;
}

StatsWithTolNumericalBaseType::~StatsWithTolNumericalBaseType()
{
  #ifndef NODESTRUCT
  delete Attributes;
  delete NumericCharacteristicWithTolStatsValue;
  #endif
}

void StatsWithTolNumericalBaseType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  {
    if (!NumericCharacteristicWithTolStatsValue)
      {
        fprintf(stderr, "NumericCharacteristicWithTolStatsValue list is missing\n");
        exit(1);
      }
    if (NumericCharacteristicWithTolStatsValue->size() == 0)
      {
        fprintf(stderr, "NumericCharacteristicWithTolStatsValue list is empty\n");
        exit(1);
      }
    if (NumericCharacteristicWithTolStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of NumericCharacteristicWithTolStatsValue list (%d) less than minimum required (1)\n",
                (int)NumericCharacteristicWithTolStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = NumericCharacteristicWithTolStatsValue->begin();
         iter != NumericCharacteristicWithTolStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "NumericCharacteristicStatsValue") == 0)
          {
            StatsWithReferenceBaseType * typ;
            if ((typ = dynamic_cast<StatsWithReferenceBaseType *>(basie)))
              {
                fprintf(outFile, "<NumericCharacteristicStatsValue");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumericCharacteristicStatsValue>\n");
              }
            else
              {
                fprintf(stderr, "bad NumericCharacteristicStatsValue element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOutOfTolerance") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOutOfTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOutOfTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOutOfTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupNumbersOutOfTolerance") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupNumbersOutOfTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupNumbersOutOfTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupNumbersOutOfTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOverUpperTolerance") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOverUpperTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOverUpperTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOverUpperTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupNumbersOverUpperTolerance") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupNumbersOverUpperTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupNumbersOverUpperTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupNumbersOverUpperTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberUnderLowerTolerance") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberUnderLowerTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberUnderLowerTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberUnderLowerTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupNumbersUnderLowerTolerance") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupNumbersUnderLowerTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupNumbersUnderLowerTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupNumbersUnderLowerTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cp") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cp");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cp>\n");
              }
            else
              {
                fprintf(stderr, "bad Cp element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cpk") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cpk");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cpk>\n");
              }
            else
              {
                fprintf(stderr, "bad Cpk element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Pp") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Pp");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Pp>\n");
              }
            else
              {
                fprintf(stderr, "bad Pp element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Ppk") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Ppk");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Ppk>\n");
              }
            else
              {
                fprintf(stderr, "bad Ppk element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cm") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cm");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cm>\n");
              }
            else
              {
                fprintf(stderr, "bad Cm element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cmk") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cmk");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cmk>\n");
              }
            else
              {
                fprintf(stderr, "bad Cmk element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cpm") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cpm");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cpm>\n");
              }
            else
              {
                fprintf(stderr, "bad Cpm element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeAppraiserVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeAppraiserVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeAppraiserVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeAppraiserVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeEquipmentVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeEquipmentVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeEquipmentVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeEquipmentVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeInteraction") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeInteraction");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeInteraction>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeInteraction element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeGageRandR") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeGageRandR");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeGageRandR>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeGageRandR element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativePartVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativePartVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativePartVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativePartVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeTotalVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeTotalVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeTotalVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeTotalVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "CommonStatsValue") == 0)
          {
            StatsWithReferenceBaseType * typ;
            if ((typ = dynamic_cast<StatsWithReferenceBaseType *>(basie)))
              {
                fprintf(outFile, "<CommonStatsValue");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CommonStatsValue>\n");
              }
            else
              {
                fprintf(stderr, "bad CommonStatsValue element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Average") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Average");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Average>\n");
              }
            else
              {
                fprintf(stderr, "bad Average element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupAverages") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupAverages");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupAverages>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupAverages element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Difference") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Difference");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Difference>\n");
              }
            else
              {
                fprintf(stderr, "bad Difference element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupDifferences") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupDifferences");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupDifferences>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupDifferences element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RootMeanSquare") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RootMeanSquare");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RootMeanSquare>\n");
              }
            else
              {
                fprintf(stderr, "bad RootMeanSquare element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Maximum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Maximum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Maximum>\n");
              }
            else
              {
                fprintf(stderr, "bad Maximum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMaxima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMaxima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMaxima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMaxima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Minimum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Minimum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Minimum>\n");
              }
            else
              {
                fprintf(stderr, "bad Minimum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMinima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMinima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMinima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMinima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Range") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Range");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Range>\n");
              }
            else
              {
                fprintf(stderr, "bad Range element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupRanges") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupRanges");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupRanges>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupRanges element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AverageRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AverageRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AverageRange>\n");
              }
            else
              {
                fprintf(stderr, "bad AverageRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "StandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<StandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</StandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad StandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Skew") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Skew");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Skew>\n");
              }
            else
              {
                fprintf(stderr, "bad Skew element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Kurtosis") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Kurtosis");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Kurtosis>\n");
              }
            else
              {
                fprintf(stderr, "bad Kurtosis element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Normality") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Normality");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Normality>\n");
              }
            else
              {
                fprintf(stderr, "bad Normality element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "ProcessVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<ProcessVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ProcessVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad ProcessVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EstimatedStandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EstimatedStandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EstimatedStandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad EstimatedStandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOutOfControl") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOutOfControl");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOutOfControl>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOutOfControl element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AppraiserVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AppraiserVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AppraiserVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad AppraiserVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EquipmentVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EquipmentVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EquipmentVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad EquipmentVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Interaction") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Interaction");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Interaction>\n");
              }
            else
              {
                fprintf(stderr, "bad Interaction element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GageRandR") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GageRandR");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GageRandR>\n");
              }
            else
              {
                fprintf(stderr, "bad GageRandR element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "PartVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<PartVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PartVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad PartVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TotalVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Linearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Linearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Linearity>\n");
              }
            else
              {
                fprintf(stderr, "bad Linearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Bias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Bias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Bias>\n");
              }
            else
              {
                fprintf(stderr, "bad Bias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeLinearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeLinearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeLinearity>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeLinearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeBias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeBias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeBias>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeBias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GoodnessOfFit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GoodnessOfFit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GoodnessOfFit>\n");
              }
            else
              {
                fprintf(stderr, "bad GoodnessOfFit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionSlope") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionSlope");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionSlope>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionSlope element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionIntercept") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionIntercept");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionIntercept>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionIntercept element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TDistribution") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TDistribution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TDistribution>\n");
              }
            else
              {
                fprintf(stderr, "bad TDistribution element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<TotalNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupTotalNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupTotalNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupTotalNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupTotalNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EffectiveNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<EffectiveNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupEffectiveNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupEffectiveNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupEffectiveNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupEffectiveNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberSubgroups") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberSubgroups");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberSubgroups>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberSubgroups element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<TotalNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupTotalNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupTotalNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupTotalNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupTotalNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EffectiveNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<EffectiveNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupEffectiveNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupEffectiveNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupEffectiveNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupEffectiveNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberSubgroups") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberSubgroups");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberSubgroups>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberSubgroups element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad NumericCharacteristicWithTolStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

AttributesType * StatsWithTolNumericalBaseType::getAttributes()
{return Attributes;}

void StatsWithTolNumericalBaseType::setAttributes(AttributesType * AttributesIn)
{Attributes = AttributesIn;}

StatsWithReferenceBaseTypeLisd * StatsWithTolNumericalBaseType::getNumericCharacteristicWithTolStatsValue()
{return NumericCharacteristicWithTolStatsValue;}

void StatsWithTolNumericalBaseType::setNumericCharacteristicWithTolStatsValue(StatsWithReferenceBaseTypeLisd * NumericCharacteristicWithTolStatsValueIn)
{NumericCharacteristicWithTolStatsValue = NumericCharacteristicWithTolStatsValueIn;}

/* ***************************************************************** */

/* class StatsWithTolPressureType

*/

StatsWithTolPressureType::StatsWithTolPressureType() :
  StatsWithTolNumericalBaseType()
{
  pressureUnit = 0;
}

StatsWithTolPressureType::StatsWithTolPressureType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicWithTolStatsValueIn) :
  StatsWithTolNumericalBaseType(
    AttributesIn,
    NumericCharacteristicWithTolStatsValueIn)
{
  pressureUnit = 0;
}

StatsWithTolPressureType::StatsWithTolPressureType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicWithTolStatsValueIn,
 XmlToken * pressureUnitIn) :
  StatsWithTolNumericalBaseType(
    AttributesIn,
    NumericCharacteristicWithTolStatsValueIn)
{
  pressureUnit = pressureUnitIn;
}

StatsWithTolPressureType::~StatsWithTolPressureType()
{
  #ifndef NODESTRUCT
  delete pressureUnit;
  #endif
}

void StatsWithTolPressureType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (pressureUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "pressureUnit=\"");
      pressureUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  {
    if (!NumericCharacteristicWithTolStatsValue)
      {
        fprintf(stderr, "NumericCharacteristicWithTolStatsValue list is missing\n");
        exit(1);
      }
    if (NumericCharacteristicWithTolStatsValue->size() == 0)
      {
        fprintf(stderr, "NumericCharacteristicWithTolStatsValue list is empty\n");
        exit(1);
      }
    if (NumericCharacteristicWithTolStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of NumericCharacteristicWithTolStatsValue list (%d) less than minimum required (1)\n",
                (int)NumericCharacteristicWithTolStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = NumericCharacteristicWithTolStatsValue->begin();
         iter != NumericCharacteristicWithTolStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "NumericCharacteristicStatsValue") == 0)
          {
            StatsWithReferenceBaseType * typ;
            if ((typ = dynamic_cast<StatsWithReferenceBaseType *>(basie)))
              {
                fprintf(outFile, "<NumericCharacteristicStatsValue");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumericCharacteristicStatsValue>\n");
              }
            else
              {
                fprintf(stderr, "bad NumericCharacteristicStatsValue element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOutOfTolerance") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOutOfTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOutOfTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOutOfTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupNumbersOutOfTolerance") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupNumbersOutOfTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupNumbersOutOfTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupNumbersOutOfTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOverUpperTolerance") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOverUpperTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOverUpperTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOverUpperTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupNumbersOverUpperTolerance") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupNumbersOverUpperTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupNumbersOverUpperTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupNumbersOverUpperTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberUnderLowerTolerance") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberUnderLowerTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberUnderLowerTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberUnderLowerTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupNumbersUnderLowerTolerance") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupNumbersUnderLowerTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupNumbersUnderLowerTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupNumbersUnderLowerTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cp") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cp");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cp>\n");
              }
            else
              {
                fprintf(stderr, "bad Cp element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cpk") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cpk");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cpk>\n");
              }
            else
              {
                fprintf(stderr, "bad Cpk element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Pp") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Pp");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Pp>\n");
              }
            else
              {
                fprintf(stderr, "bad Pp element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Ppk") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Ppk");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Ppk>\n");
              }
            else
              {
                fprintf(stderr, "bad Ppk element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cm") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cm");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cm>\n");
              }
            else
              {
                fprintf(stderr, "bad Cm element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cmk") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cmk");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cmk>\n");
              }
            else
              {
                fprintf(stderr, "bad Cmk element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cpm") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cpm");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cpm>\n");
              }
            else
              {
                fprintf(stderr, "bad Cpm element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeAppraiserVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeAppraiserVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeAppraiserVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeAppraiserVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeEquipmentVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeEquipmentVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeEquipmentVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeEquipmentVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeInteraction") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeInteraction");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeInteraction>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeInteraction element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeGageRandR") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeGageRandR");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeGageRandR>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeGageRandR element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativePartVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativePartVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativePartVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativePartVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeTotalVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeTotalVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeTotalVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeTotalVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "CommonStatsValue") == 0)
          {
            StatsWithReferenceBaseType * typ;
            if ((typ = dynamic_cast<StatsWithReferenceBaseType *>(basie)))
              {
                fprintf(outFile, "<CommonStatsValue");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CommonStatsValue>\n");
              }
            else
              {
                fprintf(stderr, "bad CommonStatsValue element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Average") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Average");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Average>\n");
              }
            else
              {
                fprintf(stderr, "bad Average element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupAverages") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupAverages");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupAverages>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupAverages element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Difference") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Difference");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Difference>\n");
              }
            else
              {
                fprintf(stderr, "bad Difference element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupDifferences") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupDifferences");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupDifferences>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupDifferences element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RootMeanSquare") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RootMeanSquare");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RootMeanSquare>\n");
              }
            else
              {
                fprintf(stderr, "bad RootMeanSquare element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Maximum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Maximum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Maximum>\n");
              }
            else
              {
                fprintf(stderr, "bad Maximum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMaxima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMaxima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMaxima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMaxima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Minimum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Minimum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Minimum>\n");
              }
            else
              {
                fprintf(stderr, "bad Minimum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMinima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMinima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMinima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMinima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Range") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Range");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Range>\n");
              }
            else
              {
                fprintf(stderr, "bad Range element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupRanges") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupRanges");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupRanges>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupRanges element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AverageRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AverageRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AverageRange>\n");
              }
            else
              {
                fprintf(stderr, "bad AverageRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "StandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<StandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</StandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad StandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Skew") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Skew");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Skew>\n");
              }
            else
              {
                fprintf(stderr, "bad Skew element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Kurtosis") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Kurtosis");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Kurtosis>\n");
              }
            else
              {
                fprintf(stderr, "bad Kurtosis element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Normality") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Normality");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Normality>\n");
              }
            else
              {
                fprintf(stderr, "bad Normality element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "ProcessVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<ProcessVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ProcessVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad ProcessVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EstimatedStandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EstimatedStandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EstimatedStandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad EstimatedStandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOutOfControl") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOutOfControl");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOutOfControl>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOutOfControl element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AppraiserVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AppraiserVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AppraiserVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad AppraiserVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EquipmentVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EquipmentVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EquipmentVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad EquipmentVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Interaction") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Interaction");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Interaction>\n");
              }
            else
              {
                fprintf(stderr, "bad Interaction element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GageRandR") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GageRandR");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GageRandR>\n");
              }
            else
              {
                fprintf(stderr, "bad GageRandR element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "PartVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<PartVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PartVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad PartVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TotalVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Linearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Linearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Linearity>\n");
              }
            else
              {
                fprintf(stderr, "bad Linearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Bias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Bias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Bias>\n");
              }
            else
              {
                fprintf(stderr, "bad Bias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeLinearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeLinearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeLinearity>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeLinearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeBias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeBias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeBias>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeBias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GoodnessOfFit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GoodnessOfFit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GoodnessOfFit>\n");
              }
            else
              {
                fprintf(stderr, "bad GoodnessOfFit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionSlope") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionSlope");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionSlope>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionSlope element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionIntercept") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionIntercept");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionIntercept>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionIntercept element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TDistribution") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TDistribution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TDistribution>\n");
              }
            else
              {
                fprintf(stderr, "bad TDistribution element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<TotalNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupTotalNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupTotalNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupTotalNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupTotalNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EffectiveNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<EffectiveNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupEffectiveNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupEffectiveNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupEffectiveNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupEffectiveNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberSubgroups") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberSubgroups");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberSubgroups>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberSubgroups element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<TotalNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupTotalNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupTotalNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupTotalNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupTotalNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EffectiveNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<EffectiveNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupEffectiveNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupEffectiveNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupEffectiveNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupEffectiveNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberSubgroups") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberSubgroups");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberSubgroups>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberSubgroups element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad NumericCharacteristicWithTolStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool StatsWithTolPressureType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "pressureUnit")
        {
          XmlToken * pressureUnitVal;
          if (this->pressureUnit)
            {
              fprintf(stderr, "two values for pressureUnit in StatsWithTolPressureType\n");
              returnValue = true;
              break;
            }
          pressureUnitVal = new XmlToken(decl->val.c_str());
          if (pressureUnitVal->bad)
            {
              delete pressureUnitVal;
              fprintf(stderr, "bad value %s for pressureUnit in StatsWithTolPressureType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->pressureUnit = pressureUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in StatsWithTolPressureType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->pressureUnit;
      this->pressureUnit = 0;
    }
  return returnValue;
}

XmlToken * StatsWithTolPressureType::getpressureUnit()
{return pressureUnit;}

void StatsWithTolPressureType::setpressureUnit(XmlToken * pressureUnitIn)
{pressureUnit = pressureUnitIn;}

/* ***************************************************************** */

/* class StatsWithTolSpeedType

*/

StatsWithTolSpeedType::StatsWithTolSpeedType() :
  StatsWithTolNumericalBaseType()
{
  speedUnit = 0;
}

StatsWithTolSpeedType::StatsWithTolSpeedType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicWithTolStatsValueIn) :
  StatsWithTolNumericalBaseType(
    AttributesIn,
    NumericCharacteristicWithTolStatsValueIn)
{
  speedUnit = 0;
}

StatsWithTolSpeedType::StatsWithTolSpeedType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicWithTolStatsValueIn,
 XmlToken * speedUnitIn) :
  StatsWithTolNumericalBaseType(
    AttributesIn,
    NumericCharacteristicWithTolStatsValueIn)
{
  speedUnit = speedUnitIn;
}

StatsWithTolSpeedType::~StatsWithTolSpeedType()
{
  #ifndef NODESTRUCT
  delete speedUnit;
  #endif
}

void StatsWithTolSpeedType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (speedUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "speedUnit=\"");
      speedUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  {
    if (!NumericCharacteristicWithTolStatsValue)
      {
        fprintf(stderr, "NumericCharacteristicWithTolStatsValue list is missing\n");
        exit(1);
      }
    if (NumericCharacteristicWithTolStatsValue->size() == 0)
      {
        fprintf(stderr, "NumericCharacteristicWithTolStatsValue list is empty\n");
        exit(1);
      }
    if (NumericCharacteristicWithTolStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of NumericCharacteristicWithTolStatsValue list (%d) less than minimum required (1)\n",
                (int)NumericCharacteristicWithTolStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = NumericCharacteristicWithTolStatsValue->begin();
         iter != NumericCharacteristicWithTolStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "NumericCharacteristicStatsValue") == 0)
          {
            StatsWithReferenceBaseType * typ;
            if ((typ = dynamic_cast<StatsWithReferenceBaseType *>(basie)))
              {
                fprintf(outFile, "<NumericCharacteristicStatsValue");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumericCharacteristicStatsValue>\n");
              }
            else
              {
                fprintf(stderr, "bad NumericCharacteristicStatsValue element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOutOfTolerance") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOutOfTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOutOfTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOutOfTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupNumbersOutOfTolerance") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupNumbersOutOfTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupNumbersOutOfTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupNumbersOutOfTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOverUpperTolerance") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOverUpperTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOverUpperTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOverUpperTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupNumbersOverUpperTolerance") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupNumbersOverUpperTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupNumbersOverUpperTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupNumbersOverUpperTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberUnderLowerTolerance") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberUnderLowerTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberUnderLowerTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberUnderLowerTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupNumbersUnderLowerTolerance") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupNumbersUnderLowerTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupNumbersUnderLowerTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupNumbersUnderLowerTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cp") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cp");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cp>\n");
              }
            else
              {
                fprintf(stderr, "bad Cp element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cpk") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cpk");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cpk>\n");
              }
            else
              {
                fprintf(stderr, "bad Cpk element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Pp") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Pp");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Pp>\n");
              }
            else
              {
                fprintf(stderr, "bad Pp element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Ppk") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Ppk");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Ppk>\n");
              }
            else
              {
                fprintf(stderr, "bad Ppk element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cm") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cm");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cm>\n");
              }
            else
              {
                fprintf(stderr, "bad Cm element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cmk") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cmk");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cmk>\n");
              }
            else
              {
                fprintf(stderr, "bad Cmk element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cpm") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cpm");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cpm>\n");
              }
            else
              {
                fprintf(stderr, "bad Cpm element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeAppraiserVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeAppraiserVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeAppraiserVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeAppraiserVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeEquipmentVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeEquipmentVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeEquipmentVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeEquipmentVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeInteraction") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeInteraction");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeInteraction>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeInteraction element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeGageRandR") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeGageRandR");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeGageRandR>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeGageRandR element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativePartVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativePartVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativePartVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativePartVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeTotalVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeTotalVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeTotalVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeTotalVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "CommonStatsValue") == 0)
          {
            StatsWithReferenceBaseType * typ;
            if ((typ = dynamic_cast<StatsWithReferenceBaseType *>(basie)))
              {
                fprintf(outFile, "<CommonStatsValue");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CommonStatsValue>\n");
              }
            else
              {
                fprintf(stderr, "bad CommonStatsValue element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Average") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Average");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Average>\n");
              }
            else
              {
                fprintf(stderr, "bad Average element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupAverages") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupAverages");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupAverages>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupAverages element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Difference") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Difference");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Difference>\n");
              }
            else
              {
                fprintf(stderr, "bad Difference element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupDifferences") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupDifferences");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupDifferences>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupDifferences element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RootMeanSquare") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RootMeanSquare");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RootMeanSquare>\n");
              }
            else
              {
                fprintf(stderr, "bad RootMeanSquare element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Maximum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Maximum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Maximum>\n");
              }
            else
              {
                fprintf(stderr, "bad Maximum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMaxima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMaxima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMaxima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMaxima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Minimum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Minimum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Minimum>\n");
              }
            else
              {
                fprintf(stderr, "bad Minimum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMinima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMinima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMinima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMinima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Range") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Range");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Range>\n");
              }
            else
              {
                fprintf(stderr, "bad Range element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupRanges") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupRanges");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupRanges>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupRanges element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AverageRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AverageRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AverageRange>\n");
              }
            else
              {
                fprintf(stderr, "bad AverageRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "StandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<StandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</StandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad StandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Skew") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Skew");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Skew>\n");
              }
            else
              {
                fprintf(stderr, "bad Skew element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Kurtosis") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Kurtosis");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Kurtosis>\n");
              }
            else
              {
                fprintf(stderr, "bad Kurtosis element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Normality") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Normality");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Normality>\n");
              }
            else
              {
                fprintf(stderr, "bad Normality element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "ProcessVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<ProcessVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ProcessVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad ProcessVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EstimatedStandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EstimatedStandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EstimatedStandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad EstimatedStandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOutOfControl") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOutOfControl");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOutOfControl>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOutOfControl element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AppraiserVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AppraiserVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AppraiserVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad AppraiserVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EquipmentVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EquipmentVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EquipmentVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad EquipmentVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Interaction") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Interaction");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Interaction>\n");
              }
            else
              {
                fprintf(stderr, "bad Interaction element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GageRandR") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GageRandR");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GageRandR>\n");
              }
            else
              {
                fprintf(stderr, "bad GageRandR element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "PartVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<PartVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PartVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad PartVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TotalVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Linearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Linearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Linearity>\n");
              }
            else
              {
                fprintf(stderr, "bad Linearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Bias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Bias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Bias>\n");
              }
            else
              {
                fprintf(stderr, "bad Bias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeLinearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeLinearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeLinearity>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeLinearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeBias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeBias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeBias>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeBias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GoodnessOfFit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GoodnessOfFit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GoodnessOfFit>\n");
              }
            else
              {
                fprintf(stderr, "bad GoodnessOfFit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionSlope") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionSlope");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionSlope>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionSlope element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionIntercept") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionIntercept");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionIntercept>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionIntercept element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TDistribution") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TDistribution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TDistribution>\n");
              }
            else
              {
                fprintf(stderr, "bad TDistribution element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<TotalNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupTotalNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupTotalNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupTotalNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupTotalNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EffectiveNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<EffectiveNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupEffectiveNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupEffectiveNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupEffectiveNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupEffectiveNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberSubgroups") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberSubgroups");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberSubgroups>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberSubgroups element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<TotalNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupTotalNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupTotalNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupTotalNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupTotalNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EffectiveNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<EffectiveNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupEffectiveNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupEffectiveNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupEffectiveNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupEffectiveNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberSubgroups") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberSubgroups");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberSubgroups>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberSubgroups element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad NumericCharacteristicWithTolStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool StatsWithTolSpeedType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "speedUnit")
        {
          XmlToken * speedUnitVal;
          if (this->speedUnit)
            {
              fprintf(stderr, "two values for speedUnit in StatsWithTolSpeedType\n");
              returnValue = true;
              break;
            }
          speedUnitVal = new XmlToken(decl->val.c_str());
          if (speedUnitVal->bad)
            {
              delete speedUnitVal;
              fprintf(stderr, "bad value %s for speedUnit in StatsWithTolSpeedType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->speedUnit = speedUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in StatsWithTolSpeedType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->speedUnit;
      this->speedUnit = 0;
    }
  return returnValue;
}

XmlToken * StatsWithTolSpeedType::getspeedUnit()
{return speedUnit;}

void StatsWithTolSpeedType::setspeedUnit(XmlToken * speedUnitIn)
{speedUnit = speedUnitIn;}

/* ***************************************************************** */

/* class StatsWithTolTemperatureType

*/

StatsWithTolTemperatureType::StatsWithTolTemperatureType() :
  StatsWithTolNumericalBaseType()
{
  temperatureUnit = 0;
}

StatsWithTolTemperatureType::StatsWithTolTemperatureType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicWithTolStatsValueIn) :
  StatsWithTolNumericalBaseType(
    AttributesIn,
    NumericCharacteristicWithTolStatsValueIn)
{
  temperatureUnit = 0;
}

StatsWithTolTemperatureType::StatsWithTolTemperatureType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicWithTolStatsValueIn,
 XmlToken * temperatureUnitIn) :
  StatsWithTolNumericalBaseType(
    AttributesIn,
    NumericCharacteristicWithTolStatsValueIn)
{
  temperatureUnit = temperatureUnitIn;
}

StatsWithTolTemperatureType::~StatsWithTolTemperatureType()
{
  #ifndef NODESTRUCT
  delete temperatureUnit;
  #endif
}

void StatsWithTolTemperatureType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (temperatureUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "temperatureUnit=\"");
      temperatureUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  {
    if (!NumericCharacteristicWithTolStatsValue)
      {
        fprintf(stderr, "NumericCharacteristicWithTolStatsValue list is missing\n");
        exit(1);
      }
    if (NumericCharacteristicWithTolStatsValue->size() == 0)
      {
        fprintf(stderr, "NumericCharacteristicWithTolStatsValue list is empty\n");
        exit(1);
      }
    if (NumericCharacteristicWithTolStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of NumericCharacteristicWithTolStatsValue list (%d) less than minimum required (1)\n",
                (int)NumericCharacteristicWithTolStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = NumericCharacteristicWithTolStatsValue->begin();
         iter != NumericCharacteristicWithTolStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "NumericCharacteristicStatsValue") == 0)
          {
            StatsWithReferenceBaseType * typ;
            if ((typ = dynamic_cast<StatsWithReferenceBaseType *>(basie)))
              {
                fprintf(outFile, "<NumericCharacteristicStatsValue");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumericCharacteristicStatsValue>\n");
              }
            else
              {
                fprintf(stderr, "bad NumericCharacteristicStatsValue element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOutOfTolerance") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOutOfTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOutOfTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOutOfTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupNumbersOutOfTolerance") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupNumbersOutOfTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupNumbersOutOfTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupNumbersOutOfTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOverUpperTolerance") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOverUpperTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOverUpperTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOverUpperTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupNumbersOverUpperTolerance") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupNumbersOverUpperTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupNumbersOverUpperTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupNumbersOverUpperTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberUnderLowerTolerance") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberUnderLowerTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberUnderLowerTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberUnderLowerTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupNumbersUnderLowerTolerance") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupNumbersUnderLowerTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupNumbersUnderLowerTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupNumbersUnderLowerTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cp") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cp");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cp>\n");
              }
            else
              {
                fprintf(stderr, "bad Cp element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cpk") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cpk");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cpk>\n");
              }
            else
              {
                fprintf(stderr, "bad Cpk element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Pp") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Pp");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Pp>\n");
              }
            else
              {
                fprintf(stderr, "bad Pp element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Ppk") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Ppk");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Ppk>\n");
              }
            else
              {
                fprintf(stderr, "bad Ppk element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cm") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cm");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cm>\n");
              }
            else
              {
                fprintf(stderr, "bad Cm element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cmk") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cmk");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cmk>\n");
              }
            else
              {
                fprintf(stderr, "bad Cmk element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cpm") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cpm");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cpm>\n");
              }
            else
              {
                fprintf(stderr, "bad Cpm element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeAppraiserVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeAppraiserVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeAppraiserVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeAppraiserVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeEquipmentVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeEquipmentVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeEquipmentVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeEquipmentVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeInteraction") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeInteraction");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeInteraction>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeInteraction element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeGageRandR") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeGageRandR");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeGageRandR>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeGageRandR element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativePartVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativePartVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativePartVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativePartVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeTotalVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeTotalVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeTotalVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeTotalVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "CommonStatsValue") == 0)
          {
            StatsWithReferenceBaseType * typ;
            if ((typ = dynamic_cast<StatsWithReferenceBaseType *>(basie)))
              {
                fprintf(outFile, "<CommonStatsValue");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CommonStatsValue>\n");
              }
            else
              {
                fprintf(stderr, "bad CommonStatsValue element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Average") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Average");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Average>\n");
              }
            else
              {
                fprintf(stderr, "bad Average element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupAverages") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupAverages");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupAverages>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupAverages element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Difference") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Difference");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Difference>\n");
              }
            else
              {
                fprintf(stderr, "bad Difference element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupDifferences") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupDifferences");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupDifferences>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupDifferences element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RootMeanSquare") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RootMeanSquare");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RootMeanSquare>\n");
              }
            else
              {
                fprintf(stderr, "bad RootMeanSquare element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Maximum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Maximum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Maximum>\n");
              }
            else
              {
                fprintf(stderr, "bad Maximum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMaxima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMaxima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMaxima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMaxima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Minimum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Minimum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Minimum>\n");
              }
            else
              {
                fprintf(stderr, "bad Minimum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMinima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMinima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMinima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMinima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Range") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Range");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Range>\n");
              }
            else
              {
                fprintf(stderr, "bad Range element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupRanges") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupRanges");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupRanges>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupRanges element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AverageRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AverageRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AverageRange>\n");
              }
            else
              {
                fprintf(stderr, "bad AverageRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "StandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<StandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</StandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad StandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Skew") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Skew");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Skew>\n");
              }
            else
              {
                fprintf(stderr, "bad Skew element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Kurtosis") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Kurtosis");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Kurtosis>\n");
              }
            else
              {
                fprintf(stderr, "bad Kurtosis element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Normality") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Normality");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Normality>\n");
              }
            else
              {
                fprintf(stderr, "bad Normality element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "ProcessVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<ProcessVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ProcessVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad ProcessVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EstimatedStandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EstimatedStandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EstimatedStandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad EstimatedStandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOutOfControl") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOutOfControl");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOutOfControl>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOutOfControl element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AppraiserVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AppraiserVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AppraiserVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad AppraiserVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EquipmentVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EquipmentVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EquipmentVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad EquipmentVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Interaction") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Interaction");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Interaction>\n");
              }
            else
              {
                fprintf(stderr, "bad Interaction element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GageRandR") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GageRandR");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GageRandR>\n");
              }
            else
              {
                fprintf(stderr, "bad GageRandR element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "PartVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<PartVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PartVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad PartVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TotalVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Linearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Linearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Linearity>\n");
              }
            else
              {
                fprintf(stderr, "bad Linearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Bias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Bias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Bias>\n");
              }
            else
              {
                fprintf(stderr, "bad Bias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeLinearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeLinearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeLinearity>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeLinearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeBias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeBias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeBias>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeBias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GoodnessOfFit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GoodnessOfFit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GoodnessOfFit>\n");
              }
            else
              {
                fprintf(stderr, "bad GoodnessOfFit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionSlope") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionSlope");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionSlope>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionSlope element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionIntercept") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionIntercept");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionIntercept>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionIntercept element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TDistribution") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TDistribution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TDistribution>\n");
              }
            else
              {
                fprintf(stderr, "bad TDistribution element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<TotalNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupTotalNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupTotalNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupTotalNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupTotalNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EffectiveNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<EffectiveNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupEffectiveNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupEffectiveNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupEffectiveNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupEffectiveNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberSubgroups") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberSubgroups");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberSubgroups>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberSubgroups element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<TotalNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupTotalNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupTotalNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupTotalNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupTotalNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EffectiveNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<EffectiveNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupEffectiveNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupEffectiveNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupEffectiveNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupEffectiveNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberSubgroups") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberSubgroups");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberSubgroups>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberSubgroups element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad NumericCharacteristicWithTolStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool StatsWithTolTemperatureType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "temperatureUnit")
        {
          XmlToken * temperatureUnitVal;
          if (this->temperatureUnit)
            {
              fprintf(stderr, "two values for temperatureUnit in StatsWithTolTemperatureType\n");
              returnValue = true;
              break;
            }
          temperatureUnitVal = new XmlToken(decl->val.c_str());
          if (temperatureUnitVal->bad)
            {
              delete temperatureUnitVal;
              fprintf(stderr, "bad value %s for temperatureUnit in StatsWithTolTemperatureType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->temperatureUnit = temperatureUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in StatsWithTolTemperatureType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->temperatureUnit;
      this->temperatureUnit = 0;
    }
  return returnValue;
}

XmlToken * StatsWithTolTemperatureType::gettemperatureUnit()
{return temperatureUnit;}

void StatsWithTolTemperatureType::settemperatureUnit(XmlToken * temperatureUnitIn)
{temperatureUnit = temperatureUnitIn;}

/* ***************************************************************** */

/* class StatsWithTolTimeType

*/

StatsWithTolTimeType::StatsWithTolTimeType() :
  StatsWithTolNumericalBaseType()
{
  timeUnit = 0;
}

StatsWithTolTimeType::StatsWithTolTimeType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicWithTolStatsValueIn) :
  StatsWithTolNumericalBaseType(
    AttributesIn,
    NumericCharacteristicWithTolStatsValueIn)
{
  timeUnit = 0;
}

StatsWithTolTimeType::StatsWithTolTimeType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicWithTolStatsValueIn,
 XmlToken * timeUnitIn) :
  StatsWithTolNumericalBaseType(
    AttributesIn,
    NumericCharacteristicWithTolStatsValueIn)
{
  timeUnit = timeUnitIn;
}

StatsWithTolTimeType::~StatsWithTolTimeType()
{
  #ifndef NODESTRUCT
  delete timeUnit;
  #endif
}

void StatsWithTolTimeType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (timeUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "timeUnit=\"");
      timeUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  {
    if (!NumericCharacteristicWithTolStatsValue)
      {
        fprintf(stderr, "NumericCharacteristicWithTolStatsValue list is missing\n");
        exit(1);
      }
    if (NumericCharacteristicWithTolStatsValue->size() == 0)
      {
        fprintf(stderr, "NumericCharacteristicWithTolStatsValue list is empty\n");
        exit(1);
      }
    if (NumericCharacteristicWithTolStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of NumericCharacteristicWithTolStatsValue list (%d) less than minimum required (1)\n",
                (int)NumericCharacteristicWithTolStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = NumericCharacteristicWithTolStatsValue->begin();
         iter != NumericCharacteristicWithTolStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "NumericCharacteristicStatsValue") == 0)
          {
            StatsWithReferenceBaseType * typ;
            if ((typ = dynamic_cast<StatsWithReferenceBaseType *>(basie)))
              {
                fprintf(outFile, "<NumericCharacteristicStatsValue");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumericCharacteristicStatsValue>\n");
              }
            else
              {
                fprintf(stderr, "bad NumericCharacteristicStatsValue element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOutOfTolerance") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOutOfTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOutOfTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOutOfTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupNumbersOutOfTolerance") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupNumbersOutOfTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupNumbersOutOfTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupNumbersOutOfTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOverUpperTolerance") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOverUpperTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOverUpperTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOverUpperTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupNumbersOverUpperTolerance") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupNumbersOverUpperTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupNumbersOverUpperTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupNumbersOverUpperTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberUnderLowerTolerance") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberUnderLowerTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberUnderLowerTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberUnderLowerTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupNumbersUnderLowerTolerance") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupNumbersUnderLowerTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupNumbersUnderLowerTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupNumbersUnderLowerTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cp") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cp");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cp>\n");
              }
            else
              {
                fprintf(stderr, "bad Cp element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cpk") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cpk");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cpk>\n");
              }
            else
              {
                fprintf(stderr, "bad Cpk element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Pp") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Pp");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Pp>\n");
              }
            else
              {
                fprintf(stderr, "bad Pp element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Ppk") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Ppk");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Ppk>\n");
              }
            else
              {
                fprintf(stderr, "bad Ppk element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cm") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cm");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cm>\n");
              }
            else
              {
                fprintf(stderr, "bad Cm element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cmk") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cmk");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cmk>\n");
              }
            else
              {
                fprintf(stderr, "bad Cmk element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cpm") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cpm");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cpm>\n");
              }
            else
              {
                fprintf(stderr, "bad Cpm element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeAppraiserVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeAppraiserVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeAppraiserVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeAppraiserVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeEquipmentVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeEquipmentVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeEquipmentVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeEquipmentVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeInteraction") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeInteraction");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeInteraction>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeInteraction element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeGageRandR") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeGageRandR");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeGageRandR>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeGageRandR element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativePartVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativePartVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativePartVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativePartVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeTotalVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeTotalVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeTotalVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeTotalVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "CommonStatsValue") == 0)
          {
            StatsWithReferenceBaseType * typ;
            if ((typ = dynamic_cast<StatsWithReferenceBaseType *>(basie)))
              {
                fprintf(outFile, "<CommonStatsValue");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CommonStatsValue>\n");
              }
            else
              {
                fprintf(stderr, "bad CommonStatsValue element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Average") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Average");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Average>\n");
              }
            else
              {
                fprintf(stderr, "bad Average element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupAverages") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupAverages");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupAverages>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupAverages element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Difference") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Difference");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Difference>\n");
              }
            else
              {
                fprintf(stderr, "bad Difference element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupDifferences") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupDifferences");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupDifferences>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupDifferences element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RootMeanSquare") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RootMeanSquare");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RootMeanSquare>\n");
              }
            else
              {
                fprintf(stderr, "bad RootMeanSquare element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Maximum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Maximum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Maximum>\n");
              }
            else
              {
                fprintf(stderr, "bad Maximum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMaxima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMaxima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMaxima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMaxima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Minimum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Minimum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Minimum>\n");
              }
            else
              {
                fprintf(stderr, "bad Minimum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMinima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMinima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMinima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMinima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Range") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Range");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Range>\n");
              }
            else
              {
                fprintf(stderr, "bad Range element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupRanges") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupRanges");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupRanges>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupRanges element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AverageRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AverageRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AverageRange>\n");
              }
            else
              {
                fprintf(stderr, "bad AverageRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "StandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<StandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</StandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad StandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Skew") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Skew");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Skew>\n");
              }
            else
              {
                fprintf(stderr, "bad Skew element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Kurtosis") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Kurtosis");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Kurtosis>\n");
              }
            else
              {
                fprintf(stderr, "bad Kurtosis element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Normality") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Normality");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Normality>\n");
              }
            else
              {
                fprintf(stderr, "bad Normality element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "ProcessVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<ProcessVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ProcessVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad ProcessVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EstimatedStandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EstimatedStandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EstimatedStandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad EstimatedStandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOutOfControl") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOutOfControl");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOutOfControl>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOutOfControl element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AppraiserVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AppraiserVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AppraiserVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad AppraiserVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EquipmentVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EquipmentVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EquipmentVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad EquipmentVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Interaction") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Interaction");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Interaction>\n");
              }
            else
              {
                fprintf(stderr, "bad Interaction element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GageRandR") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GageRandR");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GageRandR>\n");
              }
            else
              {
                fprintf(stderr, "bad GageRandR element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "PartVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<PartVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PartVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad PartVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TotalVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Linearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Linearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Linearity>\n");
              }
            else
              {
                fprintf(stderr, "bad Linearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Bias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Bias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Bias>\n");
              }
            else
              {
                fprintf(stderr, "bad Bias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeLinearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeLinearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeLinearity>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeLinearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeBias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeBias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeBias>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeBias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GoodnessOfFit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GoodnessOfFit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GoodnessOfFit>\n");
              }
            else
              {
                fprintf(stderr, "bad GoodnessOfFit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionSlope") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionSlope");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionSlope>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionSlope element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionIntercept") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionIntercept");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionIntercept>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionIntercept element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TDistribution") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TDistribution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TDistribution>\n");
              }
            else
              {
                fprintf(stderr, "bad TDistribution element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<TotalNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupTotalNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupTotalNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupTotalNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupTotalNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EffectiveNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<EffectiveNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupEffectiveNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupEffectiveNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupEffectiveNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupEffectiveNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberSubgroups") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberSubgroups");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberSubgroups>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberSubgroups element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<TotalNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupTotalNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupTotalNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupTotalNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupTotalNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EffectiveNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<EffectiveNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupEffectiveNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupEffectiveNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupEffectiveNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupEffectiveNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberSubgroups") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberSubgroups");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberSubgroups>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberSubgroups element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad NumericCharacteristicWithTolStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool StatsWithTolTimeType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "timeUnit")
        {
          XmlToken * timeUnitVal;
          if (this->timeUnit)
            {
              fprintf(stderr, "two values for timeUnit in StatsWithTolTimeType\n");
              returnValue = true;
              break;
            }
          timeUnitVal = new XmlToken(decl->val.c_str());
          if (timeUnitVal->bad)
            {
              delete timeUnitVal;
              fprintf(stderr, "bad value %s for timeUnit in StatsWithTolTimeType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->timeUnit = timeUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in StatsWithTolTimeType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->timeUnit;
      this->timeUnit = 0;
    }
  return returnValue;
}

XmlToken * StatsWithTolTimeType::gettimeUnit()
{return timeUnit;}

void StatsWithTolTimeType::settimeUnit(XmlToken * timeUnitIn)
{timeUnit = timeUnitIn;}

/* ***************************************************************** */

/* class StatsWithTolUserDefinedUnitType

*/

StatsWithTolUserDefinedUnitType::StatsWithTolUserDefinedUnitType() :
  StatsWithTolNumericalBaseType()
{
  unitName = 0;
}

StatsWithTolUserDefinedUnitType::StatsWithTolUserDefinedUnitType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicWithTolStatsValueIn) :
  StatsWithTolNumericalBaseType(
    AttributesIn,
    NumericCharacteristicWithTolStatsValueIn)
{
  unitName = 0;
}

StatsWithTolUserDefinedUnitType::StatsWithTolUserDefinedUnitType(
 AttributesType * AttributesIn,
 StatsWithReferenceBaseTypeLisd * NumericCharacteristicWithTolStatsValueIn,
 XmlToken * unitNameIn) :
  StatsWithTolNumericalBaseType(
    AttributesIn,
    NumericCharacteristicWithTolStatsValueIn)
{
  unitName = unitNameIn;
}

StatsWithTolUserDefinedUnitType::~StatsWithTolUserDefinedUnitType()
{
  #ifndef NODESTRUCT
  delete unitName;
  #endif
}

void StatsWithTolUserDefinedUnitType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (unitName)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "unitName=\"");
      unitName->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"unitName\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  {
    if (!NumericCharacteristicWithTolStatsValue)
      {
        fprintf(stderr, "NumericCharacteristicWithTolStatsValue list is missing\n");
        exit(1);
      }
    if (NumericCharacteristicWithTolStatsValue->size() == 0)
      {
        fprintf(stderr, "NumericCharacteristicWithTolStatsValue list is empty\n");
        exit(1);
      }
    if (NumericCharacteristicWithTolStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of NumericCharacteristicWithTolStatsValue list (%d) less than minimum required (1)\n",
                (int)NumericCharacteristicWithTolStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = NumericCharacteristicWithTolStatsValue->begin();
         iter != NumericCharacteristicWithTolStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "NumericCharacteristicStatsValue") == 0)
          {
            StatsWithReferenceBaseType * typ;
            if ((typ = dynamic_cast<StatsWithReferenceBaseType *>(basie)))
              {
                fprintf(outFile, "<NumericCharacteristicStatsValue");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumericCharacteristicStatsValue>\n");
              }
            else
              {
                fprintf(stderr, "bad NumericCharacteristicStatsValue element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOutOfTolerance") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOutOfTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOutOfTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOutOfTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupNumbersOutOfTolerance") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupNumbersOutOfTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupNumbersOutOfTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupNumbersOutOfTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOverUpperTolerance") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOverUpperTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOverUpperTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOverUpperTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupNumbersOverUpperTolerance") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupNumbersOverUpperTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupNumbersOverUpperTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupNumbersOverUpperTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberUnderLowerTolerance") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberUnderLowerTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberUnderLowerTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberUnderLowerTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupNumbersUnderLowerTolerance") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupNumbersUnderLowerTolerance");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupNumbersUnderLowerTolerance>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupNumbersUnderLowerTolerance element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cp") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cp");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cp>\n");
              }
            else
              {
                fprintf(stderr, "bad Cp element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cpk") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cpk");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cpk>\n");
              }
            else
              {
                fprintf(stderr, "bad Cpk element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Pp") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Pp");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Pp>\n");
              }
            else
              {
                fprintf(stderr, "bad Pp element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Ppk") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Ppk");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Ppk>\n");
              }
            else
              {
                fprintf(stderr, "bad Ppk element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cm") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cm");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cm>\n");
              }
            else
              {
                fprintf(stderr, "bad Cm element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cmk") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cmk");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cmk>\n");
              }
            else
              {
                fprintf(stderr, "bad Cmk element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Cpm") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Cpm");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Cpm>\n");
              }
            else
              {
                fprintf(stderr, "bad Cpm element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeAppraiserVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeAppraiserVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeAppraiserVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeAppraiserVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeEquipmentVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeEquipmentVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeEquipmentVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeEquipmentVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeInteraction") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeInteraction");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeInteraction>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeInteraction element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeGageRandR") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeGageRandR");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeGageRandR>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeGageRandR element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativePartVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativePartVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativePartVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativePartVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeTotalVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeTotalVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeTotalVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeTotalVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "CommonStatsValue") == 0)
          {
            StatsWithReferenceBaseType * typ;
            if ((typ = dynamic_cast<StatsWithReferenceBaseType *>(basie)))
              {
                fprintf(outFile, "<CommonStatsValue");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</CommonStatsValue>\n");
              }
            else
              {
                fprintf(stderr, "bad CommonStatsValue element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Average") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Average");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Average>\n");
              }
            else
              {
                fprintf(stderr, "bad Average element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupAverages") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupAverages");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupAverages>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupAverages element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Difference") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Difference");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Difference>\n");
              }
            else
              {
                fprintf(stderr, "bad Difference element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupDifferences") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupDifferences");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupDifferences>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupDifferences element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RootMeanSquare") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RootMeanSquare");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RootMeanSquare>\n");
              }
            else
              {
                fprintf(stderr, "bad RootMeanSquare element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Maximum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Maximum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Maximum>\n");
              }
            else
              {
                fprintf(stderr, "bad Maximum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMaxima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMaxima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMaxima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMaxima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Minimum") == 0)
          {
            StatsMeasuredDecimalWithReferenceType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalWithReferenceType *>(basie)))
              {
                fprintf(outFile, "<Minimum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Minimum>\n");
              }
            else
              {
                fprintf(stderr, "bad Minimum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupMinima") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupMinima");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupMinima>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupMinima element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Range") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Range");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Range>\n");
              }
            else
              {
                fprintf(stderr, "bad Range element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupRanges") == 0)
          {
            SubgroupDecimalsType * typ;
            if ((typ = dynamic_cast<SubgroupDecimalsType *>(basie)))
              {
                fprintf(outFile, "<SubgroupRanges");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupRanges>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupRanges element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AverageRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AverageRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AverageRange>\n");
              }
            else
              {
                fprintf(stderr, "bad AverageRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "StandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<StandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</StandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad StandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Skew") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Skew");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Skew>\n");
              }
            else
              {
                fprintf(stderr, "bad Skew element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Kurtosis") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Kurtosis");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Kurtosis>\n");
              }
            else
              {
                fprintf(stderr, "bad Kurtosis element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Normality") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Normality");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Normality>\n");
              }
            else
              {
                fprintf(stderr, "bad Normality element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "ProcessVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<ProcessVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</ProcessVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad ProcessVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EstimatedStandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EstimatedStandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EstimatedStandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad EstimatedStandardDeviation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerControlLimitRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerControlLimitRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerControlLimitRange>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerControlLimitRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberOutOfControl") == 0)
          {
            StatsNonNegativeIntegerWithReferencesType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerWithReferencesType *>(basie)))
              {
                fprintf(outFile, "<NumberOutOfControl");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberOutOfControl>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberOutOfControl element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "AppraiserVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<AppraiserVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</AppraiserVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad AppraiserVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EquipmentVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<EquipmentVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EquipmentVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad EquipmentVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Interaction") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Interaction");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Interaction>\n");
              }
            else
              {
                fprintf(stderr, "bad Interaction element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GageRandR") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GageRandR");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GageRandR>\n");
              }
            else
              {
                fprintf(stderr, "bad GageRandR element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "PartVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<PartVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</PartVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad PartVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalVariation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TotalVariation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalVariation>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalVariation element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Linearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Linearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Linearity>\n");
              }
            else
              {
                fprintf(stderr, "bad Linearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "Bias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<Bias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</Bias>\n");
              }
            else
              {
                fprintf(stderr, "bad Bias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeLinearity") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeLinearity");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeLinearity>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeLinearity element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RelativeBias") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RelativeBias");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RelativeBias>\n");
              }
            else
              {
                fprintf(stderr, "bad RelativeBias element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "GoodnessOfFit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<GoodnessOfFit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</GoodnessOfFit>\n");
              }
            else
              {
                fprintf(stderr, "bad GoodnessOfFit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionSlope") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionSlope");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionSlope>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionSlope element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "RegressionIntercept") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<RegressionIntercept");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</RegressionIntercept>\n");
              }
            else
              {
                fprintf(stderr, "bad RegressionIntercept element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "UpperConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<UpperConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</UpperConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad UpperConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "LowerConfidenceLimit") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<LowerConfidenceLimit");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</LowerConfidenceLimit>\n");
              }
            else
              {
                fprintf(stderr, "bad LowerConfidenceLimit element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TDistribution") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<TDistribution");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TDistribution>\n");
              }
            else
              {
                fprintf(stderr, "bad TDistribution element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<TotalNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupTotalNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupTotalNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupTotalNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupTotalNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EffectiveNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<EffectiveNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupEffectiveNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupEffectiveNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupEffectiveNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupEffectiveNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberSubgroups") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberSubgroups");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberSubgroups>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberSubgroups element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "TotalNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<TotalNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</TotalNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad TotalNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupTotalNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupTotalNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupTotalNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupTotalNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "EffectiveNumber") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<EffectiveNumber");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</EffectiveNumber>\n");
              }
            else
              {
                fprintf(stderr, "bad EffectiveNumber element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SubgroupEffectiveNumbers") == 0)
          {
            SubgroupIntegersType * typ;
            if ((typ = dynamic_cast<SubgroupIntegersType *>(basie)))
              {
                fprintf(outFile, "<SubgroupEffectiveNumbers");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SubgroupEffectiveNumbers>\n");
              }
            else
              {
                fprintf(stderr, "bad SubgroupEffectiveNumbers element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "NumberSubgroups") == 0)
          {
            StatsNonNegativeIntegerType * typ;
            if ((typ = dynamic_cast<StatsNonNegativeIntegerType *>(basie)))
              {
                fprintf(outFile, "<NumberSubgroups");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</NumberSubgroups>\n");
              }
            else
              {
                fprintf(stderr, "bad NumberSubgroups element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad NumericCharacteristicWithTolStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool StatsWithTolUserDefinedUnitType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "unitName")
        {
          XmlToken * unitNameVal;
          if (this->unitName)
            {
              fprintf(stderr, "two values for unitName in StatsWithTolUserDefinedUnitType\n");
              returnValue = true;
              break;
            }
          unitNameVal = new XmlToken(decl->val.c_str());
          if (unitNameVal->bad)
            {
              delete unitNameVal;
              fprintf(stderr, "bad value %s for unitName in StatsWithTolUserDefinedUnitType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->unitName = unitNameVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in StatsWithTolUserDefinedUnitType\n");
          returnValue = true;
          break;
        }
    }
  if (this->unitName == 0)
    {
      fprintf(stderr, "required attribute \"unitName\" missing in StatsWithTolUserDefinedUnitType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->unitName;
      this->unitName = 0;
    }
  return returnValue;
}

XmlToken * StatsWithTolUserDefinedUnitType::getunitName()
{return unitName;}

void StatsWithTolUserDefinedUnitType::setunitName(XmlToken * unitNameIn)
{unitName = unitNameIn;}

/* ***************************************************************** */

/* class StraightnessCharacteristicStatsEvalType

*/

StraightnessCharacteristicStatsEvalType::StraightnessCharacteristicStatsEvalType() :
  FormCharacteristicStatsEvalBaseType()
{
  BonusStats = 0;
  MaxStraightnessStats = 0;
}

StraightnessCharacteristicStatsEvalType::StraightnessCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsWithTolLinearType * ValueStatsIn,
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn,
 OneSidedCapabilityCalculationEnumType * CapabilityCalculationMethodIn,
 StatsLinearType * BonusStatsIn,
 StatsLinearType * MaxStraightnessStatsIn) :
  FormCharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    ValueStatsIn,
    MaxValueStatsIn,
    MinValueStatsIn,
    CapabilityCalculationMethodIn)
{
  BonusStats = BonusStatsIn;
  MaxStraightnessStats = MaxStraightnessStatsIn;
}

StraightnessCharacteristicStatsEvalType::~StraightnessCharacteristicStatsEvalType()
{
  #ifndef NODESTRUCT
  delete BonusStats;
  delete MaxStraightnessStats;
  #endif
}

void StraightnessCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (ValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ValueStats");
      ValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ValueStats>\n");
    }
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  if (CapabilityCalculationMethod)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CapabilityCalculationMethod");
      CapabilityCalculationMethod->printSelf(outFile);
      fprintf(outFile, "</CapabilityCalculationMethod>\n");
    }
  if (BonusStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<BonusStats");
      BonusStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</BonusStats>\n");
    }
  if (MaxStraightnessStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxStraightnessStats");
      MaxStraightnessStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxStraightnessStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

StatsLinearType * StraightnessCharacteristicStatsEvalType::getBonusStats()
{return BonusStats;}

void StraightnessCharacteristicStatsEvalType::setBonusStats(StatsLinearType * BonusStatsIn)
{BonusStats = BonusStatsIn;}

StatsLinearType * StraightnessCharacteristicStatsEvalType::getMaxStraightnessStats()
{return MaxStraightnessStats;}

void StraightnessCharacteristicStatsEvalType::setMaxStraightnessStats(StatsLinearType * MaxStraightnessStatsIn)
{MaxStraightnessStats = MaxStraightnessStatsIn;}

/* ***************************************************************** */

/* class StudyIssueType

*/

StudyIssueType::StudyIssueType()
{
  id = 0;
  Traceability = 0;
  AssignableCauseIds = 0;
  CorrectiveActionIds = 0;
  Resolution = 0;
  StudyIssueType_1115 = 0;
}

StudyIssueType::StudyIssueType(
 InspectionTraceabilityType * TraceabilityIn,
 ArrayReferenceType * AssignableCauseIdsIn,
 ArrayReferenceType * CorrectiveActionIdsIn,
 XmlString * ResolutionIn,
 StudyIssueType_1115_Type * StudyIssueType_1115In)
{
  id = 0;
  Traceability = TraceabilityIn;
  AssignableCauseIds = AssignableCauseIdsIn;
  CorrectiveActionIds = CorrectiveActionIdsIn;
  Resolution = ResolutionIn;
  StudyIssueType_1115 = StudyIssueType_1115In;
}

StudyIssueType::StudyIssueType(
 QIFIdType * idIn,
 InspectionTraceabilityType * TraceabilityIn,
 ArrayReferenceType * AssignableCauseIdsIn,
 ArrayReferenceType * CorrectiveActionIdsIn,
 XmlString * ResolutionIn,
 StudyIssueType_1115_Type * StudyIssueType_1115In)
{
  id = idIn;
  Traceability = TraceabilityIn;
  AssignableCauseIds = AssignableCauseIdsIn;
  CorrectiveActionIds = CorrectiveActionIdsIn;
  Resolution = ResolutionIn;
  StudyIssueType_1115 = StudyIssueType_1115In;
}

StudyIssueType::~StudyIssueType()
{
  #ifndef NODESTRUCT
  delete id;
  delete Traceability;
  delete AssignableCauseIds;
  delete CorrectiveActionIds;
  delete Resolution;
  delete StudyIssueType_1115;
  #endif
}

void StudyIssueType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Traceability)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Traceability");
      Traceability->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Traceability>\n");
    }
  if (AssignableCauseIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AssignableCauseIds");
      AssignableCauseIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</AssignableCauseIds>\n");
    }
  if (CorrectiveActionIds)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CorrectiveActionIds");
      CorrectiveActionIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CorrectiveActionIds>\n");
    }
  if (Resolution)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Resolution");
      Resolution->printSelf(outFile);
      fprintf(outFile, "</Resolution>\n");
    }
  if (StudyIssueType_1115)
    {
  StudyIssueType_1115->printSelf(outFile);
    }
  doSpaces(-INDENT, outFile);
}

bool StudyIssueType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in StudyIssueType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->val.c_str());
          if (idVal->bad)
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in StudyIssueType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in StudyIssueType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id == 0)
    {
      fprintf(stderr, "required attribute \"id\" missing in StudyIssueType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

QIFIdType * StudyIssueType::getid()
{return id;}

void StudyIssueType::setid(QIFIdType * idIn)
{id = idIn;}

InspectionTraceabilityType * StudyIssueType::getTraceability()
{return Traceability;}

void StudyIssueType::setTraceability(InspectionTraceabilityType * TraceabilityIn)
{Traceability = TraceabilityIn;}

ArrayReferenceType * StudyIssueType::getAssignableCauseIds()
{return AssignableCauseIds;}

void StudyIssueType::setAssignableCauseIds(ArrayReferenceType * AssignableCauseIdsIn)
{AssignableCauseIds = AssignableCauseIdsIn;}

ArrayReferenceType * StudyIssueType::getCorrectiveActionIds()
{return CorrectiveActionIds;}

void StudyIssueType::setCorrectiveActionIds(ArrayReferenceType * CorrectiveActionIdsIn)
{CorrectiveActionIds = CorrectiveActionIdsIn;}

XmlString * StudyIssueType::getResolution()
{return Resolution;}

void StudyIssueType::setResolution(XmlString * ResolutionIn)
{Resolution = ResolutionIn;}

StudyIssueType_1115_Type * StudyIssueType::getStudyIssueType_1115()
{return StudyIssueType_1115;}

void StudyIssueType::setStudyIssueType_1115(StudyIssueType_1115_Type * StudyIssueType_1115In)
{StudyIssueType_1115 = StudyIssueType_1115In;}

/* ***************************************************************** */

/* class StudyIssueTypeLisd

*/

StudyIssueTypeLisd::StudyIssueTypeLisd() {}

StudyIssueTypeLisd::StudyIssueTypeLisd(StudyIssueType * aStudyIssueType)
{
  push_back(aStudyIssueType);
}

StudyIssueTypeLisd::~StudyIssueTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<StudyIssueType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void StudyIssueTypeLisd::printSelf(FILE * outFile)
{
  std::list<StudyIssueType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class StudyIssuesType

*/

StudyIssuesType::StudyIssuesType()
{
  n = 0;
  StudyIssue = 0;
}

StudyIssuesType::StudyIssuesType(
 StudyIssueTypeLisd * StudyIssueIn)
{
  n = 0;
  StudyIssue = StudyIssueIn;
}

StudyIssuesType::StudyIssuesType(
 NaturalType * nIn,
 StudyIssueTypeLisd * StudyIssueIn)
{
  n = nIn;
  StudyIssue = StudyIssueIn;
}

StudyIssuesType::~StudyIssuesType()
{
  #ifndef NODESTRUCT
  delete n;
  delete StudyIssue;
  #endif
}

void StudyIssuesType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!StudyIssue)
      {
        fprintf(stderr, "StudyIssue list is missing\n");
        exit(1);
      }
    if (StudyIssue->size() == 0)
      {
        fprintf(stderr, "StudyIssue list is empty\n");
        exit(1);
      }
    if (StudyIssue->size() < 1)
      {
        fprintf(stderr,
                "size of StudyIssue list (%d) less than minimum required (1)\n",
                (int)StudyIssue->size());
        exit(1);
      }
    std::list<StudyIssueType *>::iterator iter;
    for (iter = StudyIssue->begin();
         iter != StudyIssue->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<StudyIssue");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</StudyIssue>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool StudyIssuesType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in StudyIssuesType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->val.c_str());
          if (nVal->bad)
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in StudyIssuesType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in StudyIssuesType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in StudyIssuesType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * StudyIssuesType::getn()
{return n;}

void StudyIssuesType::setn(NaturalType * nIn)
{n = nIn;}

StudyIssueTypeLisd * StudyIssuesType::getStudyIssue()
{return StudyIssue;}

void StudyIssuesType::setStudyIssue(StudyIssueTypeLisd * StudyIssueIn)
{StudyIssue = StudyIssueIn;}

/* ***************************************************************** */

/* class SubgroupType

*/

SubgroupType::SubgroupType()
{
  id = 0;
  MeasuredIds = 0;
}

SubgroupType::SubgroupType(
 StatsArrayIdType * MeasuredIdsIn)
{
  id = 0;
  MeasuredIds = MeasuredIdsIn;
}

SubgroupType::SubgroupType(
 QIFIdType * idIn,
 StatsArrayIdType * MeasuredIdsIn)
{
  id = idIn;
  MeasuredIds = MeasuredIdsIn;
}

SubgroupType::~SubgroupType()
{
  #ifndef NODESTRUCT
  delete id;
  delete MeasuredIds;
  #endif
}

void SubgroupType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (id)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "id=\"");
      id->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"id\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "<MeasuredIds");
  MeasuredIds->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</MeasuredIds>\n");
  doSpaces(-INDENT, outFile);
}

bool SubgroupType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "id")
        {
          QIFIdType * idVal;
          if (this->id)
            {
              fprintf(stderr, "two values for id in SubgroupType\n");
              returnValue = true;
              break;
            }
          idVal = new QIFIdType(decl->val.c_str());
          if (idVal->bad)
            {
              delete idVal;
              fprintf(stderr, "bad value %s for id in SubgroupType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->id = idVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SubgroupType\n");
          returnValue = true;
          break;
        }
    }
  if (this->id == 0)
    {
      fprintf(stderr, "required attribute \"id\" missing in SubgroupType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->id;
      this->id = 0;
    }
  return returnValue;
}

QIFIdType * SubgroupType::getid()
{return id;}

void SubgroupType::setid(QIFIdType * idIn)
{id = idIn;}

StatsArrayIdType * SubgroupType::getMeasuredIds()
{return MeasuredIds;}

void SubgroupType::setMeasuredIds(StatsArrayIdType * MeasuredIdsIn)
{MeasuredIds = MeasuredIdsIn;}

/* ***************************************************************** */

/* class SubgroupTypeLisd

*/

SubgroupTypeLisd::SubgroupTypeLisd() {}

SubgroupTypeLisd::SubgroupTypeLisd(SubgroupType * aSubgroupType)
{
  push_back(aSubgroupType);
}

SubgroupTypeLisd::~SubgroupTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<SubgroupType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void SubgroupTypeLisd::printSelf(FILE * outFile)
{
  std::list<SubgroupType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class SubgroupValuesType

*/

SubgroupValuesType::SubgroupValuesType()
{
  n = 0;
  Subgroup = 0;
}

SubgroupValuesType::SubgroupValuesType(
 StatsValuesTypeLisd * SubgroupIn)
{
  n = 0;
  Subgroup = SubgroupIn;
}

SubgroupValuesType::SubgroupValuesType(
 NaturalType * nIn,
 StatsValuesTypeLisd * SubgroupIn)
{
  n = nIn;
  Subgroup = SubgroupIn;
}

SubgroupValuesType::~SubgroupValuesType()
{
  #ifndef NODESTRUCT
  delete n;
  delete Subgroup;
  #endif
}

void SubgroupValuesType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!Subgroup)
      {
        fprintf(stderr, "Subgroup list is missing\n");
        exit(1);
      }
    if (Subgroup->size() == 0)
      {
        fprintf(stderr, "Subgroup list is empty\n");
        exit(1);
      }
    if (Subgroup->size() < 1)
      {
        fprintf(stderr,
                "size of Subgroup list (%d) less than minimum required (1)\n",
                (int)Subgroup->size());
        exit(1);
      }
    std::list<StatsValuesType *>::iterator iter;
    for (iter = Subgroup->begin();
         iter != Subgroup->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<Subgroup");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</Subgroup>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool SubgroupValuesType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in SubgroupValuesType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->val.c_str());
          if (nVal->bad)
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in SubgroupValuesType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SubgroupValuesType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in SubgroupValuesType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * SubgroupValuesType::getn()
{return n;}

void SubgroupValuesType::setn(NaturalType * nIn)
{n = nIn;}

StatsValuesTypeLisd * SubgroupValuesType::getSubgroup()
{return Subgroup;}

void SubgroupValuesType::setSubgroup(StatsValuesTypeLisd * SubgroupIn)
{Subgroup = SubgroupIn;}

/* ***************************************************************** */

/* class SubgroupsType

*/

SubgroupsType::SubgroupsType()
{
  n = 0;
  Subgroup = 0;
}

SubgroupsType::SubgroupsType(
 SubgroupTypeLisd * SubgroupIn)
{
  n = 0;
  Subgroup = SubgroupIn;
}

SubgroupsType::SubgroupsType(
 NaturalType * nIn,
 SubgroupTypeLisd * SubgroupIn)
{
  n = nIn;
  Subgroup = SubgroupIn;
}

SubgroupsType::~SubgroupsType()
{
  #ifndef NODESTRUCT
  delete n;
  delete Subgroup;
  #endif
}

void SubgroupsType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!Subgroup)
      {
        fprintf(stderr, "Subgroup list is missing\n");
        exit(1);
      }
    if (Subgroup->size() == 0)
      {
        fprintf(stderr, "Subgroup list is empty\n");
        exit(1);
      }
    if (Subgroup->size() < 1)
      {
        fprintf(stderr,
                "size of Subgroup list (%d) less than minimum required (1)\n",
                (int)Subgroup->size());
        exit(1);
      }
    std::list<SubgroupType *>::iterator iter;
    for (iter = Subgroup->begin();
         iter != Subgroup->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<Subgroup");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</Subgroup>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool SubgroupsType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in SubgroupsType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->val.c_str());
          if (nVal->bad)
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in SubgroupsType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SubgroupsType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in SubgroupsType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * SubgroupsType::getn()
{return n;}

void SubgroupsType::setn(NaturalType * nIn)
{n = nIn;}

SubgroupTypeLisd * SubgroupsType::getSubgroup()
{return Subgroup;}

void SubgroupsType::setSubgroup(SubgroupTypeLisd * SubgroupIn)
{Subgroup = SubgroupIn;}

/* ***************************************************************** */

/* class SummariesStatisticsAngularType

*/

SummariesStatisticsAngularType::SummariesStatisticsAngularType()
{
  n = 0;
  AngularStatsSummary = 0;
}

SummariesStatisticsAngularType::SummariesStatisticsAngularType(
 SummaryStatisticsAngularTypeLisd * AngularStatsSummaryIn)
{
  n = 0;
  AngularStatsSummary = AngularStatsSummaryIn;
}

SummariesStatisticsAngularType::SummariesStatisticsAngularType(
 NaturalType * nIn,
 SummaryStatisticsAngularTypeLisd * AngularStatsSummaryIn)
{
  n = nIn;
  AngularStatsSummary = AngularStatsSummaryIn;
}

SummariesStatisticsAngularType::~SummariesStatisticsAngularType()
{
  #ifndef NODESTRUCT
  delete n;
  delete AngularStatsSummary;
  #endif
}

void SummariesStatisticsAngularType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!AngularStatsSummary)
      {
        fprintf(stderr, "AngularStatsSummary list is missing\n");
        exit(1);
      }
    if (AngularStatsSummary->size() == 0)
      {
        fprintf(stderr, "AngularStatsSummary list is empty\n");
        exit(1);
      }
    if (AngularStatsSummary->size() < 1)
      {
        fprintf(stderr,
                "size of AngularStatsSummary list (%d) less than minimum required (1)\n",
                (int)AngularStatsSummary->size());
        exit(1);
      }
    std::list<SummaryStatisticsAngularType *>::iterator iter;
    for (iter = AngularStatsSummary->begin();
         iter != AngularStatsSummary->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<AngularStatsSummary");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</AngularStatsSummary>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool SummariesStatisticsAngularType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in SummariesStatisticsAngularType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->val.c_str());
          if (nVal->bad)
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in SummariesStatisticsAngularType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SummariesStatisticsAngularType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in SummariesStatisticsAngularType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * SummariesStatisticsAngularType::getn()
{return n;}

void SummariesStatisticsAngularType::setn(NaturalType * nIn)
{n = nIn;}

SummaryStatisticsAngularTypeLisd * SummariesStatisticsAngularType::getAngularStatsSummary()
{return AngularStatsSummary;}

void SummariesStatisticsAngularType::setAngularStatsSummary(SummaryStatisticsAngularTypeLisd * AngularStatsSummaryIn)
{AngularStatsSummary = AngularStatsSummaryIn;}

/* ***************************************************************** */

/* class SummariesStatisticsAreaType

*/

SummariesStatisticsAreaType::SummariesStatisticsAreaType()
{
  n = 0;
  AreaStatsSummary = 0;
}

SummariesStatisticsAreaType::SummariesStatisticsAreaType(
 SummaryStatisticsAreaTypeLisd * AreaStatsSummaryIn)
{
  n = 0;
  AreaStatsSummary = AreaStatsSummaryIn;
}

SummariesStatisticsAreaType::SummariesStatisticsAreaType(
 NaturalType * nIn,
 SummaryStatisticsAreaTypeLisd * AreaStatsSummaryIn)
{
  n = nIn;
  AreaStatsSummary = AreaStatsSummaryIn;
}

SummariesStatisticsAreaType::~SummariesStatisticsAreaType()
{
  #ifndef NODESTRUCT
  delete n;
  delete AreaStatsSummary;
  #endif
}

void SummariesStatisticsAreaType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!AreaStatsSummary)
      {
        fprintf(stderr, "AreaStatsSummary list is missing\n");
        exit(1);
      }
    if (AreaStatsSummary->size() == 0)
      {
        fprintf(stderr, "AreaStatsSummary list is empty\n");
        exit(1);
      }
    if (AreaStatsSummary->size() < 1)
      {
        fprintf(stderr,
                "size of AreaStatsSummary list (%d) less than minimum required (1)\n",
                (int)AreaStatsSummary->size());
        exit(1);
      }
    std::list<SummaryStatisticsAreaType *>::iterator iter;
    for (iter = AreaStatsSummary->begin();
         iter != AreaStatsSummary->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<AreaStatsSummary");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</AreaStatsSummary>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool SummariesStatisticsAreaType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in SummariesStatisticsAreaType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->val.c_str());
          if (nVal->bad)
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in SummariesStatisticsAreaType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SummariesStatisticsAreaType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in SummariesStatisticsAreaType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * SummariesStatisticsAreaType::getn()
{return n;}

void SummariesStatisticsAreaType::setn(NaturalType * nIn)
{n = nIn;}

SummaryStatisticsAreaTypeLisd * SummariesStatisticsAreaType::getAreaStatsSummary()
{return AreaStatsSummary;}

void SummariesStatisticsAreaType::setAreaStatsSummary(SummaryStatisticsAreaTypeLisd * AreaStatsSummaryIn)
{AreaStatsSummary = AreaStatsSummaryIn;}

/* ***************************************************************** */

/* class SummariesStatisticsForceType

*/

SummariesStatisticsForceType::SummariesStatisticsForceType()
{
  n = 0;
  ForceStatsSummary = 0;
}

SummariesStatisticsForceType::SummariesStatisticsForceType(
 SummaryStatisticsForceTypeLisd * ForceStatsSummaryIn)
{
  n = 0;
  ForceStatsSummary = ForceStatsSummaryIn;
}

SummariesStatisticsForceType::SummariesStatisticsForceType(
 NaturalType * nIn,
 SummaryStatisticsForceTypeLisd * ForceStatsSummaryIn)
{
  n = nIn;
  ForceStatsSummary = ForceStatsSummaryIn;
}

SummariesStatisticsForceType::~SummariesStatisticsForceType()
{
  #ifndef NODESTRUCT
  delete n;
  delete ForceStatsSummary;
  #endif
}

void SummariesStatisticsForceType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!ForceStatsSummary)
      {
        fprintf(stderr, "ForceStatsSummary list is missing\n");
        exit(1);
      }
    if (ForceStatsSummary->size() == 0)
      {
        fprintf(stderr, "ForceStatsSummary list is empty\n");
        exit(1);
      }
    if (ForceStatsSummary->size() < 1)
      {
        fprintf(stderr,
                "size of ForceStatsSummary list (%d) less than minimum required (1)\n",
                (int)ForceStatsSummary->size());
        exit(1);
      }
    std::list<SummaryStatisticsForceType *>::iterator iter;
    for (iter = ForceStatsSummary->begin();
         iter != ForceStatsSummary->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<ForceStatsSummary");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</ForceStatsSummary>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool SummariesStatisticsForceType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in SummariesStatisticsForceType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->val.c_str());
          if (nVal->bad)
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in SummariesStatisticsForceType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SummariesStatisticsForceType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in SummariesStatisticsForceType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * SummariesStatisticsForceType::getn()
{return n;}

void SummariesStatisticsForceType::setn(NaturalType * nIn)
{n = nIn;}

SummaryStatisticsForceTypeLisd * SummariesStatisticsForceType::getForceStatsSummary()
{return ForceStatsSummary;}

void SummariesStatisticsForceType::setForceStatsSummary(SummaryStatisticsForceTypeLisd * ForceStatsSummaryIn)
{ForceStatsSummary = ForceStatsSummaryIn;}

/* ***************************************************************** */

/* class SummariesStatisticsLinearType

*/

SummariesStatisticsLinearType::SummariesStatisticsLinearType()
{
  n = 0;
  LinearStatsSummary = 0;
}

SummariesStatisticsLinearType::SummariesStatisticsLinearType(
 SummaryStatisticsLinearTypeLisd * LinearStatsSummaryIn)
{
  n = 0;
  LinearStatsSummary = LinearStatsSummaryIn;
}

SummariesStatisticsLinearType::SummariesStatisticsLinearType(
 NaturalType * nIn,
 SummaryStatisticsLinearTypeLisd * LinearStatsSummaryIn)
{
  n = nIn;
  LinearStatsSummary = LinearStatsSummaryIn;
}

SummariesStatisticsLinearType::~SummariesStatisticsLinearType()
{
  #ifndef NODESTRUCT
  delete n;
  delete LinearStatsSummary;
  #endif
}

void SummariesStatisticsLinearType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!LinearStatsSummary)
      {
        fprintf(stderr, "LinearStatsSummary list is missing\n");
        exit(1);
      }
    if (LinearStatsSummary->size() == 0)
      {
        fprintf(stderr, "LinearStatsSummary list is empty\n");
        exit(1);
      }
    if (LinearStatsSummary->size() < 1)
      {
        fprintf(stderr,
                "size of LinearStatsSummary list (%d) less than minimum required (1)\n",
                (int)LinearStatsSummary->size());
        exit(1);
      }
    std::list<SummaryStatisticsLinearType *>::iterator iter;
    for (iter = LinearStatsSummary->begin();
         iter != LinearStatsSummary->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<LinearStatsSummary");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</LinearStatsSummary>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool SummariesStatisticsLinearType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in SummariesStatisticsLinearType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->val.c_str());
          if (nVal->bad)
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in SummariesStatisticsLinearType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SummariesStatisticsLinearType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in SummariesStatisticsLinearType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * SummariesStatisticsLinearType::getn()
{return n;}

void SummariesStatisticsLinearType::setn(NaturalType * nIn)
{n = nIn;}

SummaryStatisticsLinearTypeLisd * SummariesStatisticsLinearType::getLinearStatsSummary()
{return LinearStatsSummary;}

void SummariesStatisticsLinearType::setLinearStatsSummary(SummaryStatisticsLinearTypeLisd * LinearStatsSummaryIn)
{LinearStatsSummary = LinearStatsSummaryIn;}

/* ***************************************************************** */

/* class SummariesStatisticsMassType

*/

SummariesStatisticsMassType::SummariesStatisticsMassType()
{
  n = 0;
  MassStatsSummary = 0;
}

SummariesStatisticsMassType::SummariesStatisticsMassType(
 SummaryStatisticsMassTypeLisd * MassStatsSummaryIn)
{
  n = 0;
  MassStatsSummary = MassStatsSummaryIn;
}

SummariesStatisticsMassType::SummariesStatisticsMassType(
 NaturalType * nIn,
 SummaryStatisticsMassTypeLisd * MassStatsSummaryIn)
{
  n = nIn;
  MassStatsSummary = MassStatsSummaryIn;
}

SummariesStatisticsMassType::~SummariesStatisticsMassType()
{
  #ifndef NODESTRUCT
  delete n;
  delete MassStatsSummary;
  #endif
}

void SummariesStatisticsMassType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!MassStatsSummary)
      {
        fprintf(stderr, "MassStatsSummary list is missing\n");
        exit(1);
      }
    if (MassStatsSummary->size() == 0)
      {
        fprintf(stderr, "MassStatsSummary list is empty\n");
        exit(1);
      }
    if (MassStatsSummary->size() < 1)
      {
        fprintf(stderr,
                "size of MassStatsSummary list (%d) less than minimum required (1)\n",
                (int)MassStatsSummary->size());
        exit(1);
      }
    std::list<SummaryStatisticsMassType *>::iterator iter;
    for (iter = MassStatsSummary->begin();
         iter != MassStatsSummary->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<MassStatsSummary");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</MassStatsSummary>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool SummariesStatisticsMassType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in SummariesStatisticsMassType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->val.c_str());
          if (nVal->bad)
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in SummariesStatisticsMassType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SummariesStatisticsMassType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in SummariesStatisticsMassType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * SummariesStatisticsMassType::getn()
{return n;}

void SummariesStatisticsMassType::setn(NaturalType * nIn)
{n = nIn;}

SummaryStatisticsMassTypeLisd * SummariesStatisticsMassType::getMassStatsSummary()
{return MassStatsSummary;}

void SummariesStatisticsMassType::setMassStatsSummary(SummaryStatisticsMassTypeLisd * MassStatsSummaryIn)
{MassStatsSummary = MassStatsSummaryIn;}

/* ***************************************************************** */

/* class SummariesStatisticsPressureType

*/

SummariesStatisticsPressureType::SummariesStatisticsPressureType()
{
  n = 0;
  PressureStatsSummary = 0;
}

SummariesStatisticsPressureType::SummariesStatisticsPressureType(
 SummaryStatisticsPressureTypeLisd * PressureStatsSummaryIn)
{
  n = 0;
  PressureStatsSummary = PressureStatsSummaryIn;
}

SummariesStatisticsPressureType::SummariesStatisticsPressureType(
 NaturalType * nIn,
 SummaryStatisticsPressureTypeLisd * PressureStatsSummaryIn)
{
  n = nIn;
  PressureStatsSummary = PressureStatsSummaryIn;
}

SummariesStatisticsPressureType::~SummariesStatisticsPressureType()
{
  #ifndef NODESTRUCT
  delete n;
  delete PressureStatsSummary;
  #endif
}

void SummariesStatisticsPressureType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!PressureStatsSummary)
      {
        fprintf(stderr, "PressureStatsSummary list is missing\n");
        exit(1);
      }
    if (PressureStatsSummary->size() == 0)
      {
        fprintf(stderr, "PressureStatsSummary list is empty\n");
        exit(1);
      }
    if (PressureStatsSummary->size() < 1)
      {
        fprintf(stderr,
                "size of PressureStatsSummary list (%d) less than minimum required (1)\n",
                (int)PressureStatsSummary->size());
        exit(1);
      }
    std::list<SummaryStatisticsPressureType *>::iterator iter;
    for (iter = PressureStatsSummary->begin();
         iter != PressureStatsSummary->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<PressureStatsSummary");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</PressureStatsSummary>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool SummariesStatisticsPressureType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in SummariesStatisticsPressureType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->val.c_str());
          if (nVal->bad)
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in SummariesStatisticsPressureType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SummariesStatisticsPressureType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in SummariesStatisticsPressureType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * SummariesStatisticsPressureType::getn()
{return n;}

void SummariesStatisticsPressureType::setn(NaturalType * nIn)
{n = nIn;}

SummaryStatisticsPressureTypeLisd * SummariesStatisticsPressureType::getPressureStatsSummary()
{return PressureStatsSummary;}

void SummariesStatisticsPressureType::setPressureStatsSummary(SummaryStatisticsPressureTypeLisd * PressureStatsSummaryIn)
{PressureStatsSummary = PressureStatsSummaryIn;}

/* ***************************************************************** */

/* class SummariesStatisticsSpeedType

*/

SummariesStatisticsSpeedType::SummariesStatisticsSpeedType()
{
  n = 0;
  SpeedStatsSummary = 0;
}

SummariesStatisticsSpeedType::SummariesStatisticsSpeedType(
 SummaryStatisticsSpeedTypeLisd * SpeedStatsSummaryIn)
{
  n = 0;
  SpeedStatsSummary = SpeedStatsSummaryIn;
}

SummariesStatisticsSpeedType::SummariesStatisticsSpeedType(
 NaturalType * nIn,
 SummaryStatisticsSpeedTypeLisd * SpeedStatsSummaryIn)
{
  n = nIn;
  SpeedStatsSummary = SpeedStatsSummaryIn;
}

SummariesStatisticsSpeedType::~SummariesStatisticsSpeedType()
{
  #ifndef NODESTRUCT
  delete n;
  delete SpeedStatsSummary;
  #endif
}

void SummariesStatisticsSpeedType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!SpeedStatsSummary)
      {
        fprintf(stderr, "SpeedStatsSummary list is missing\n");
        exit(1);
      }
    if (SpeedStatsSummary->size() == 0)
      {
        fprintf(stderr, "SpeedStatsSummary list is empty\n");
        exit(1);
      }
    if (SpeedStatsSummary->size() < 1)
      {
        fprintf(stderr,
                "size of SpeedStatsSummary list (%d) less than minimum required (1)\n",
                (int)SpeedStatsSummary->size());
        exit(1);
      }
    std::list<SummaryStatisticsSpeedType *>::iterator iter;
    for (iter = SpeedStatsSummary->begin();
         iter != SpeedStatsSummary->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<SpeedStatsSummary");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</SpeedStatsSummary>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool SummariesStatisticsSpeedType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in SummariesStatisticsSpeedType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->val.c_str());
          if (nVal->bad)
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in SummariesStatisticsSpeedType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SummariesStatisticsSpeedType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in SummariesStatisticsSpeedType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * SummariesStatisticsSpeedType::getn()
{return n;}

void SummariesStatisticsSpeedType::setn(NaturalType * nIn)
{n = nIn;}

SummaryStatisticsSpeedTypeLisd * SummariesStatisticsSpeedType::getSpeedStatsSummary()
{return SpeedStatsSummary;}

void SummariesStatisticsSpeedType::setSpeedStatsSummary(SummaryStatisticsSpeedTypeLisd * SpeedStatsSummaryIn)
{SpeedStatsSummary = SpeedStatsSummaryIn;}

/* ***************************************************************** */

/* class SummariesStatisticsTemperatureType

*/

SummariesStatisticsTemperatureType::SummariesStatisticsTemperatureType()
{
  n = 0;
  TemperatureStatsSummary = 0;
}

SummariesStatisticsTemperatureType::SummariesStatisticsTemperatureType(
 SummaryStatisticsTemperatureTypeLisd * TemperatureStatsSummaryIn)
{
  n = 0;
  TemperatureStatsSummary = TemperatureStatsSummaryIn;
}

SummariesStatisticsTemperatureType::SummariesStatisticsTemperatureType(
 NaturalType * nIn,
 SummaryStatisticsTemperatureTypeLisd * TemperatureStatsSummaryIn)
{
  n = nIn;
  TemperatureStatsSummary = TemperatureStatsSummaryIn;
}

SummariesStatisticsTemperatureType::~SummariesStatisticsTemperatureType()
{
  #ifndef NODESTRUCT
  delete n;
  delete TemperatureStatsSummary;
  #endif
}

void SummariesStatisticsTemperatureType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!TemperatureStatsSummary)
      {
        fprintf(stderr, "TemperatureStatsSummary list is missing\n");
        exit(1);
      }
    if (TemperatureStatsSummary->size() == 0)
      {
        fprintf(stderr, "TemperatureStatsSummary list is empty\n");
        exit(1);
      }
    if (TemperatureStatsSummary->size() < 1)
      {
        fprintf(stderr,
                "size of TemperatureStatsSummary list (%d) less than minimum required (1)\n",
                (int)TemperatureStatsSummary->size());
        exit(1);
      }
    std::list<SummaryStatisticsTemperatureType *>::iterator iter;
    for (iter = TemperatureStatsSummary->begin();
         iter != TemperatureStatsSummary->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<TemperatureStatsSummary");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</TemperatureStatsSummary>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool SummariesStatisticsTemperatureType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in SummariesStatisticsTemperatureType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->val.c_str());
          if (nVal->bad)
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in SummariesStatisticsTemperatureType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SummariesStatisticsTemperatureType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in SummariesStatisticsTemperatureType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * SummariesStatisticsTemperatureType::getn()
{return n;}

void SummariesStatisticsTemperatureType::setn(NaturalType * nIn)
{n = nIn;}

SummaryStatisticsTemperatureTypeLisd * SummariesStatisticsTemperatureType::getTemperatureStatsSummary()
{return TemperatureStatsSummary;}

void SummariesStatisticsTemperatureType::setTemperatureStatsSummary(SummaryStatisticsTemperatureTypeLisd * TemperatureStatsSummaryIn)
{TemperatureStatsSummary = TemperatureStatsSummaryIn;}

/* ***************************************************************** */

/* class SummariesStatisticsTimeType

*/

SummariesStatisticsTimeType::SummariesStatisticsTimeType()
{
  n = 0;
  TimeStatsSummary = 0;
}

SummariesStatisticsTimeType::SummariesStatisticsTimeType(
 SummaryStatisticsTimeTypeLisd * TimeStatsSummaryIn)
{
  n = 0;
  TimeStatsSummary = TimeStatsSummaryIn;
}

SummariesStatisticsTimeType::SummariesStatisticsTimeType(
 NaturalType * nIn,
 SummaryStatisticsTimeTypeLisd * TimeStatsSummaryIn)
{
  n = nIn;
  TimeStatsSummary = TimeStatsSummaryIn;
}

SummariesStatisticsTimeType::~SummariesStatisticsTimeType()
{
  #ifndef NODESTRUCT
  delete n;
  delete TimeStatsSummary;
  #endif
}

void SummariesStatisticsTimeType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!TimeStatsSummary)
      {
        fprintf(stderr, "TimeStatsSummary list is missing\n");
        exit(1);
      }
    if (TimeStatsSummary->size() == 0)
      {
        fprintf(stderr, "TimeStatsSummary list is empty\n");
        exit(1);
      }
    if (TimeStatsSummary->size() < 1)
      {
        fprintf(stderr,
                "size of TimeStatsSummary list (%d) less than minimum required (1)\n",
                (int)TimeStatsSummary->size());
        exit(1);
      }
    std::list<SummaryStatisticsTimeType *>::iterator iter;
    for (iter = TimeStatsSummary->begin();
         iter != TimeStatsSummary->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<TimeStatsSummary");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</TimeStatsSummary>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool SummariesStatisticsTimeType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in SummariesStatisticsTimeType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->val.c_str());
          if (nVal->bad)
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in SummariesStatisticsTimeType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SummariesStatisticsTimeType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in SummariesStatisticsTimeType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * SummariesStatisticsTimeType::getn()
{return n;}

void SummariesStatisticsTimeType::setn(NaturalType * nIn)
{n = nIn;}

SummaryStatisticsTimeTypeLisd * SummariesStatisticsTimeType::getTimeStatsSummary()
{return TimeStatsSummary;}

void SummariesStatisticsTimeType::setTimeStatsSummary(SummaryStatisticsTimeTypeLisd * TimeStatsSummaryIn)
{TimeStatsSummary = TimeStatsSummaryIn;}

/* ***************************************************************** */

/* class SummariesStatisticsType

*/

SummariesStatisticsType::SummariesStatisticsType()
{
  n = 0;
  StatsSummary = 0;
}

SummariesStatisticsType::SummariesStatisticsType(
 SummaryStatisticsTypeLisd * StatsSummaryIn)
{
  n = 0;
  StatsSummary = StatsSummaryIn;
}

SummariesStatisticsType::SummariesStatisticsType(
 NaturalType * nIn,
 SummaryStatisticsTypeLisd * StatsSummaryIn)
{
  n = nIn;
  StatsSummary = StatsSummaryIn;
}

SummariesStatisticsType::~SummariesStatisticsType()
{
  #ifndef NODESTRUCT
  delete n;
  delete StatsSummary;
  #endif
}

void SummariesStatisticsType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!StatsSummary)
      {
        fprintf(stderr, "StatsSummary list is missing\n");
        exit(1);
      }
    if (StatsSummary->size() == 0)
      {
        fprintf(stderr, "StatsSummary list is empty\n");
        exit(1);
      }
    if (StatsSummary->size() < 1)
      {
        fprintf(stderr,
                "size of StatsSummary list (%d) less than minimum required (1)\n",
                (int)StatsSummary->size());
        exit(1);
      }
    std::list<SummaryStatisticsType *>::iterator iter;
    for (iter = StatsSummary->begin();
         iter != StatsSummary->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<StatsSummary");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</StatsSummary>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool SummariesStatisticsType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in SummariesStatisticsType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->val.c_str());
          if (nVal->bad)
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in SummariesStatisticsType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SummariesStatisticsType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in SummariesStatisticsType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * SummariesStatisticsType::getn()
{return n;}

void SummariesStatisticsType::setn(NaturalType * nIn)
{n = nIn;}

SummaryStatisticsTypeLisd * SummariesStatisticsType::getStatsSummary()
{return StatsSummary;}

void SummariesStatisticsType::setStatsSummary(SummaryStatisticsTypeLisd * StatsSummaryIn)
{StatsSummary = StatsSummaryIn;}

/* ***************************************************************** */

/* class SummariesStatisticsUserDefinedUnitType

*/

SummariesStatisticsUserDefinedUnitType::SummariesStatisticsUserDefinedUnitType()
{
  n = 0;
  UserDefinedUnitStatsSummary = 0;
}

SummariesStatisticsUserDefinedUnitType::SummariesStatisticsUserDefinedUnitType(
 SummaryStatisticsUserDefinedUnitTypeLisd * UserDefinedUnitStatsSummaryIn)
{
  n = 0;
  UserDefinedUnitStatsSummary = UserDefinedUnitStatsSummaryIn;
}

SummariesStatisticsUserDefinedUnitType::SummariesStatisticsUserDefinedUnitType(
 NaturalType * nIn,
 SummaryStatisticsUserDefinedUnitTypeLisd * UserDefinedUnitStatsSummaryIn)
{
  n = nIn;
  UserDefinedUnitStatsSummary = UserDefinedUnitStatsSummaryIn;
}

SummariesStatisticsUserDefinedUnitType::~SummariesStatisticsUserDefinedUnitType()
{
  #ifndef NODESTRUCT
  delete n;
  delete UserDefinedUnitStatsSummary;
  #endif
}

void SummariesStatisticsUserDefinedUnitType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (n)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "n=\"");
      n->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"n\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  {
    if (!UserDefinedUnitStatsSummary)
      {
        fprintf(stderr, "UserDefinedUnitStatsSummary list is missing\n");
        exit(1);
      }
    if (UserDefinedUnitStatsSummary->size() == 0)
      {
        fprintf(stderr, "UserDefinedUnitStatsSummary list is empty\n");
        exit(1);
      }
    if (UserDefinedUnitStatsSummary->size() < 1)
      {
        fprintf(stderr,
                "size of UserDefinedUnitStatsSummary list (%d) less than minimum required (1)\n",
                (int)UserDefinedUnitStatsSummary->size());
        exit(1);
      }
    std::list<SummaryStatisticsUserDefinedUnitType *>::iterator iter;
    for (iter = UserDefinedUnitStatsSummary->begin();
         iter != UserDefinedUnitStatsSummary->end(); iter++)
      {
        doSpaces(0, outFile);
        fprintf(outFile, "<UserDefinedUnitStatsSummary");
        (*iter)->printSelf(outFile);
        doSpaces(0, outFile);
        fprintf(outFile, "</UserDefinedUnitStatsSummary>\n");
      }
  }
  doSpaces(-INDENT, outFile);
}

bool SummariesStatisticsUserDefinedUnitType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "n")
        {
          NaturalType * nVal;
          if (this->n)
            {
              fprintf(stderr, "two values for n in SummariesStatisticsUserDefinedUnitType\n");
              returnValue = true;
              break;
            }
          nVal = new NaturalType(decl->val.c_str());
          if (nVal->bad)
            {
              delete nVal;
              fprintf(stderr, "bad value %s for n in SummariesStatisticsUserDefinedUnitType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->n = nVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SummariesStatisticsUserDefinedUnitType\n");
          returnValue = true;
          break;
        }
    }
  if (this->n == 0)
    {
      fprintf(stderr, "required attribute \"n\" missing in SummariesStatisticsUserDefinedUnitType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->n;
      this->n = 0;
    }
  return returnValue;
}

NaturalType * SummariesStatisticsUserDefinedUnitType::getn()
{return n;}

void SummariesStatisticsUserDefinedUnitType::setn(NaturalType * nIn)
{n = nIn;}

SummaryStatisticsUserDefinedUnitTypeLisd * SummariesStatisticsUserDefinedUnitType::getUserDefinedUnitStatsSummary()
{return UserDefinedUnitStatsSummary;}

void SummariesStatisticsUserDefinedUnitType::setUserDefinedUnitStatsSummary(SummaryStatisticsUserDefinedUnitTypeLisd * UserDefinedUnitStatsSummaryIn)
{UserDefinedUnitStatsSummary = UserDefinedUnitStatsSummaryIn;}

/* ***************************************************************** */

/* class SummaryStatisticsAngularType

*/

SummaryStatisticsAngularType::SummaryStatisticsAngularType() :
  SummaryStatisticsType()
{
  angularUnit = 0;
}

SummaryStatisticsAngularType::SummaryStatisticsAngularType(
 AttributesType * AttributesIn,
 StatsValuesEnumType * TypeOfSummaryIn,
 StatsWithReferenceBaseTypeLisd * SummaryStatsValueIn) :
  SummaryStatisticsType(
    AttributesIn,
    TypeOfSummaryIn,
    SummaryStatsValueIn)
{
  angularUnit = 0;
}

SummaryStatisticsAngularType::SummaryStatisticsAngularType(
 AttributesType * AttributesIn,
 StatsValuesEnumType * TypeOfSummaryIn,
 StatsWithReferenceBaseTypeLisd * SummaryStatsValueIn,
 XmlToken * angularUnitIn) :
  SummaryStatisticsType(
    AttributesIn,
    TypeOfSummaryIn,
    SummaryStatsValueIn)
{
  angularUnit = angularUnitIn;
}

SummaryStatisticsAngularType::~SummaryStatisticsAngularType()
{
  #ifndef NODESTRUCT
  delete angularUnit;
  #endif
}

void SummaryStatisticsAngularType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (angularUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "angularUnit=\"");
      angularUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<TypeOfSummary");
  TypeOfSummary->printSelf(outFile);
  fprintf(outFile, "</TypeOfSummary>\n");
  {
    if (!SummaryStatsValue)
      {
        fprintf(stderr, "SummaryStatsValue list is missing\n");
        exit(1);
      }
    if (SummaryStatsValue->size() == 0)
      {
        fprintf(stderr, "SummaryStatsValue list is empty\n");
        exit(1);
      }
    if (SummaryStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of SummaryStatsValue list (%d) less than minimum required (1)\n",
                (int)SummaryStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = SummaryStatsValue->begin();
         iter != SummaryStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "SummaryAverage") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryAverage");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryAverage>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryAverage element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryMaximum") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryMaximum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryMaximum>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryMaximum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryMinimum") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryMinimum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryMinimum>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryMinimum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryRange>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryStandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryStandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryStandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryStandardDeviation element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad SummaryStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool SummaryStatisticsAngularType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "angularUnit")
        {
          XmlToken * angularUnitVal;
          if (this->angularUnit)
            {
              fprintf(stderr, "two values for angularUnit in SummaryStatisticsAngularType\n");
              returnValue = true;
              break;
            }
          angularUnitVal = new XmlToken(decl->val.c_str());
          if (angularUnitVal->bad)
            {
              delete angularUnitVal;
              fprintf(stderr, "bad value %s for angularUnit in SummaryStatisticsAngularType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->angularUnit = angularUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SummaryStatisticsAngularType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->angularUnit;
      this->angularUnit = 0;
    }
  return returnValue;
}

XmlToken * SummaryStatisticsAngularType::getangularUnit()
{return angularUnit;}

void SummaryStatisticsAngularType::setangularUnit(XmlToken * angularUnitIn)
{angularUnit = angularUnitIn;}

/* ***************************************************************** */

/* class SummaryStatisticsAngularTypeLisd

*/

SummaryStatisticsAngularTypeLisd::SummaryStatisticsAngularTypeLisd() {}

SummaryStatisticsAngularTypeLisd::SummaryStatisticsAngularTypeLisd(SummaryStatisticsAngularType * aSummaryStatisticsAngularType)
{
  push_back(aSummaryStatisticsAngularType);
}

SummaryStatisticsAngularTypeLisd::~SummaryStatisticsAngularTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<SummaryStatisticsAngularType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void SummaryStatisticsAngularTypeLisd::printSelf(FILE * outFile)
{
  std::list<SummaryStatisticsAngularType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class SummaryStatisticsAreaType

*/

SummaryStatisticsAreaType::SummaryStatisticsAreaType() :
  SummaryStatisticsType()
{
  areaUnit = 0;
}

SummaryStatisticsAreaType::SummaryStatisticsAreaType(
 AttributesType * AttributesIn,
 StatsValuesEnumType * TypeOfSummaryIn,
 StatsWithReferenceBaseTypeLisd * SummaryStatsValueIn) :
  SummaryStatisticsType(
    AttributesIn,
    TypeOfSummaryIn,
    SummaryStatsValueIn)
{
  areaUnit = 0;
}

SummaryStatisticsAreaType::SummaryStatisticsAreaType(
 AttributesType * AttributesIn,
 StatsValuesEnumType * TypeOfSummaryIn,
 StatsWithReferenceBaseTypeLisd * SummaryStatsValueIn,
 XmlToken * areaUnitIn) :
  SummaryStatisticsType(
    AttributesIn,
    TypeOfSummaryIn,
    SummaryStatsValueIn)
{
  areaUnit = areaUnitIn;
}

SummaryStatisticsAreaType::~SummaryStatisticsAreaType()
{
  #ifndef NODESTRUCT
  delete areaUnit;
  #endif
}

void SummaryStatisticsAreaType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (areaUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "areaUnit=\"");
      areaUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<TypeOfSummary");
  TypeOfSummary->printSelf(outFile);
  fprintf(outFile, "</TypeOfSummary>\n");
  {
    if (!SummaryStatsValue)
      {
        fprintf(stderr, "SummaryStatsValue list is missing\n");
        exit(1);
      }
    if (SummaryStatsValue->size() == 0)
      {
        fprintf(stderr, "SummaryStatsValue list is empty\n");
        exit(1);
      }
    if (SummaryStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of SummaryStatsValue list (%d) less than minimum required (1)\n",
                (int)SummaryStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = SummaryStatsValue->begin();
         iter != SummaryStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "SummaryAverage") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryAverage");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryAverage>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryAverage element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryMaximum") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryMaximum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryMaximum>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryMaximum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryMinimum") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryMinimum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryMinimum>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryMinimum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryRange>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryStandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryStandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryStandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryStandardDeviation element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad SummaryStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool SummaryStatisticsAreaType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "areaUnit")
        {
          XmlToken * areaUnitVal;
          if (this->areaUnit)
            {
              fprintf(stderr, "two values for areaUnit in SummaryStatisticsAreaType\n");
              returnValue = true;
              break;
            }
          areaUnitVal = new XmlToken(decl->val.c_str());
          if (areaUnitVal->bad)
            {
              delete areaUnitVal;
              fprintf(stderr, "bad value %s for areaUnit in SummaryStatisticsAreaType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->areaUnit = areaUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SummaryStatisticsAreaType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->areaUnit;
      this->areaUnit = 0;
    }
  return returnValue;
}

XmlToken * SummaryStatisticsAreaType::getareaUnit()
{return areaUnit;}

void SummaryStatisticsAreaType::setareaUnit(XmlToken * areaUnitIn)
{areaUnit = areaUnitIn;}

/* ***************************************************************** */

/* class SummaryStatisticsAreaTypeLisd

*/

SummaryStatisticsAreaTypeLisd::SummaryStatisticsAreaTypeLisd() {}

SummaryStatisticsAreaTypeLisd::SummaryStatisticsAreaTypeLisd(SummaryStatisticsAreaType * aSummaryStatisticsAreaType)
{
  push_back(aSummaryStatisticsAreaType);
}

SummaryStatisticsAreaTypeLisd::~SummaryStatisticsAreaTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<SummaryStatisticsAreaType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void SummaryStatisticsAreaTypeLisd::printSelf(FILE * outFile)
{
  std::list<SummaryStatisticsAreaType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class SummaryStatisticsForceType

*/

SummaryStatisticsForceType::SummaryStatisticsForceType() :
  SummaryStatisticsType()
{
  forceUnit = 0;
}

SummaryStatisticsForceType::SummaryStatisticsForceType(
 AttributesType * AttributesIn,
 StatsValuesEnumType * TypeOfSummaryIn,
 StatsWithReferenceBaseTypeLisd * SummaryStatsValueIn) :
  SummaryStatisticsType(
    AttributesIn,
    TypeOfSummaryIn,
    SummaryStatsValueIn)
{
  forceUnit = 0;
}

SummaryStatisticsForceType::SummaryStatisticsForceType(
 AttributesType * AttributesIn,
 StatsValuesEnumType * TypeOfSummaryIn,
 StatsWithReferenceBaseTypeLisd * SummaryStatsValueIn,
 XmlToken * forceUnitIn) :
  SummaryStatisticsType(
    AttributesIn,
    TypeOfSummaryIn,
    SummaryStatsValueIn)
{
  forceUnit = forceUnitIn;
}

SummaryStatisticsForceType::~SummaryStatisticsForceType()
{
  #ifndef NODESTRUCT
  delete forceUnit;
  #endif
}

void SummaryStatisticsForceType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (forceUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "forceUnit=\"");
      forceUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<TypeOfSummary");
  TypeOfSummary->printSelf(outFile);
  fprintf(outFile, "</TypeOfSummary>\n");
  {
    if (!SummaryStatsValue)
      {
        fprintf(stderr, "SummaryStatsValue list is missing\n");
        exit(1);
      }
    if (SummaryStatsValue->size() == 0)
      {
        fprintf(stderr, "SummaryStatsValue list is empty\n");
        exit(1);
      }
    if (SummaryStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of SummaryStatsValue list (%d) less than minimum required (1)\n",
                (int)SummaryStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = SummaryStatsValue->begin();
         iter != SummaryStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "SummaryAverage") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryAverage");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryAverage>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryAverage element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryMaximum") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryMaximum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryMaximum>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryMaximum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryMinimum") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryMinimum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryMinimum>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryMinimum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryRange>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryStandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryStandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryStandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryStandardDeviation element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad SummaryStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool SummaryStatisticsForceType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "forceUnit")
        {
          XmlToken * forceUnitVal;
          if (this->forceUnit)
            {
              fprintf(stderr, "two values for forceUnit in SummaryStatisticsForceType\n");
              returnValue = true;
              break;
            }
          forceUnitVal = new XmlToken(decl->val.c_str());
          if (forceUnitVal->bad)
            {
              delete forceUnitVal;
              fprintf(stderr, "bad value %s for forceUnit in SummaryStatisticsForceType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->forceUnit = forceUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SummaryStatisticsForceType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->forceUnit;
      this->forceUnit = 0;
    }
  return returnValue;
}

XmlToken * SummaryStatisticsForceType::getforceUnit()
{return forceUnit;}

void SummaryStatisticsForceType::setforceUnit(XmlToken * forceUnitIn)
{forceUnit = forceUnitIn;}

/* ***************************************************************** */

/* class SummaryStatisticsForceTypeLisd

*/

SummaryStatisticsForceTypeLisd::SummaryStatisticsForceTypeLisd() {}

SummaryStatisticsForceTypeLisd::SummaryStatisticsForceTypeLisd(SummaryStatisticsForceType * aSummaryStatisticsForceType)
{
  push_back(aSummaryStatisticsForceType);
}

SummaryStatisticsForceTypeLisd::~SummaryStatisticsForceTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<SummaryStatisticsForceType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void SummaryStatisticsForceTypeLisd::printSelf(FILE * outFile)
{
  std::list<SummaryStatisticsForceType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class SummaryStatisticsLinearType

*/

SummaryStatisticsLinearType::SummaryStatisticsLinearType() :
  SummaryStatisticsType()
{
  linearUnit = 0;
}

SummaryStatisticsLinearType::SummaryStatisticsLinearType(
 AttributesType * AttributesIn,
 StatsValuesEnumType * TypeOfSummaryIn,
 StatsWithReferenceBaseTypeLisd * SummaryStatsValueIn) :
  SummaryStatisticsType(
    AttributesIn,
    TypeOfSummaryIn,
    SummaryStatsValueIn)
{
  linearUnit = 0;
}

SummaryStatisticsLinearType::SummaryStatisticsLinearType(
 AttributesType * AttributesIn,
 StatsValuesEnumType * TypeOfSummaryIn,
 StatsWithReferenceBaseTypeLisd * SummaryStatsValueIn,
 XmlToken * linearUnitIn) :
  SummaryStatisticsType(
    AttributesIn,
    TypeOfSummaryIn,
    SummaryStatsValueIn)
{
  linearUnit = linearUnitIn;
}

SummaryStatisticsLinearType::~SummaryStatisticsLinearType()
{
  #ifndef NODESTRUCT
  delete linearUnit;
  #endif
}

void SummaryStatisticsLinearType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (linearUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "linearUnit=\"");
      linearUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<TypeOfSummary");
  TypeOfSummary->printSelf(outFile);
  fprintf(outFile, "</TypeOfSummary>\n");
  {
    if (!SummaryStatsValue)
      {
        fprintf(stderr, "SummaryStatsValue list is missing\n");
        exit(1);
      }
    if (SummaryStatsValue->size() == 0)
      {
        fprintf(stderr, "SummaryStatsValue list is empty\n");
        exit(1);
      }
    if (SummaryStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of SummaryStatsValue list (%d) less than minimum required (1)\n",
                (int)SummaryStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = SummaryStatsValue->begin();
         iter != SummaryStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "SummaryAverage") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryAverage");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryAverage>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryAverage element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryMaximum") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryMaximum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryMaximum>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryMaximum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryMinimum") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryMinimum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryMinimum>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryMinimum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryRange>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryStandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryStandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryStandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryStandardDeviation element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad SummaryStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool SummaryStatisticsLinearType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "linearUnit")
        {
          XmlToken * linearUnitVal;
          if (this->linearUnit)
            {
              fprintf(stderr, "two values for linearUnit in SummaryStatisticsLinearType\n");
              returnValue = true;
              break;
            }
          linearUnitVal = new XmlToken(decl->val.c_str());
          if (linearUnitVal->bad)
            {
              delete linearUnitVal;
              fprintf(stderr, "bad value %s for linearUnit in SummaryStatisticsLinearType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->linearUnit = linearUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SummaryStatisticsLinearType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->linearUnit;
      this->linearUnit = 0;
    }
  return returnValue;
}

XmlToken * SummaryStatisticsLinearType::getlinearUnit()
{return linearUnit;}

void SummaryStatisticsLinearType::setlinearUnit(XmlToken * linearUnitIn)
{linearUnit = linearUnitIn;}

/* ***************************************************************** */

/* class SummaryStatisticsLinearTypeLisd

*/

SummaryStatisticsLinearTypeLisd::SummaryStatisticsLinearTypeLisd() {}

SummaryStatisticsLinearTypeLisd::SummaryStatisticsLinearTypeLisd(SummaryStatisticsLinearType * aSummaryStatisticsLinearType)
{
  push_back(aSummaryStatisticsLinearType);
}

SummaryStatisticsLinearTypeLisd::~SummaryStatisticsLinearTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<SummaryStatisticsLinearType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void SummaryStatisticsLinearTypeLisd::printSelf(FILE * outFile)
{
  std::list<SummaryStatisticsLinearType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class SummaryStatisticsMassType

*/

SummaryStatisticsMassType::SummaryStatisticsMassType() :
  SummaryStatisticsType()
{
  massUnit = 0;
}

SummaryStatisticsMassType::SummaryStatisticsMassType(
 AttributesType * AttributesIn,
 StatsValuesEnumType * TypeOfSummaryIn,
 StatsWithReferenceBaseTypeLisd * SummaryStatsValueIn) :
  SummaryStatisticsType(
    AttributesIn,
    TypeOfSummaryIn,
    SummaryStatsValueIn)
{
  massUnit = 0;
}

SummaryStatisticsMassType::SummaryStatisticsMassType(
 AttributesType * AttributesIn,
 StatsValuesEnumType * TypeOfSummaryIn,
 StatsWithReferenceBaseTypeLisd * SummaryStatsValueIn,
 XmlToken * massUnitIn) :
  SummaryStatisticsType(
    AttributesIn,
    TypeOfSummaryIn,
    SummaryStatsValueIn)
{
  massUnit = massUnitIn;
}

SummaryStatisticsMassType::~SummaryStatisticsMassType()
{
  #ifndef NODESTRUCT
  delete massUnit;
  #endif
}

void SummaryStatisticsMassType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (massUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "massUnit=\"");
      massUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<TypeOfSummary");
  TypeOfSummary->printSelf(outFile);
  fprintf(outFile, "</TypeOfSummary>\n");
  {
    if (!SummaryStatsValue)
      {
        fprintf(stderr, "SummaryStatsValue list is missing\n");
        exit(1);
      }
    if (SummaryStatsValue->size() == 0)
      {
        fprintf(stderr, "SummaryStatsValue list is empty\n");
        exit(1);
      }
    if (SummaryStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of SummaryStatsValue list (%d) less than minimum required (1)\n",
                (int)SummaryStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = SummaryStatsValue->begin();
         iter != SummaryStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "SummaryAverage") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryAverage");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryAverage>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryAverage element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryMaximum") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryMaximum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryMaximum>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryMaximum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryMinimum") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryMinimum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryMinimum>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryMinimum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryRange>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryStandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryStandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryStandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryStandardDeviation element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad SummaryStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool SummaryStatisticsMassType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "massUnit")
        {
          XmlToken * massUnitVal;
          if (this->massUnit)
            {
              fprintf(stderr, "two values for massUnit in SummaryStatisticsMassType\n");
              returnValue = true;
              break;
            }
          massUnitVal = new XmlToken(decl->val.c_str());
          if (massUnitVal->bad)
            {
              delete massUnitVal;
              fprintf(stderr, "bad value %s for massUnit in SummaryStatisticsMassType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->massUnit = massUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SummaryStatisticsMassType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->massUnit;
      this->massUnit = 0;
    }
  return returnValue;
}

XmlToken * SummaryStatisticsMassType::getmassUnit()
{return massUnit;}

void SummaryStatisticsMassType::setmassUnit(XmlToken * massUnitIn)
{massUnit = massUnitIn;}

/* ***************************************************************** */

/* class SummaryStatisticsMassTypeLisd

*/

SummaryStatisticsMassTypeLisd::SummaryStatisticsMassTypeLisd() {}

SummaryStatisticsMassTypeLisd::SummaryStatisticsMassTypeLisd(SummaryStatisticsMassType * aSummaryStatisticsMassType)
{
  push_back(aSummaryStatisticsMassType);
}

SummaryStatisticsMassTypeLisd::~SummaryStatisticsMassTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<SummaryStatisticsMassType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void SummaryStatisticsMassTypeLisd::printSelf(FILE * outFile)
{
  std::list<SummaryStatisticsMassType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class SummaryStatisticsPressureType

*/

SummaryStatisticsPressureType::SummaryStatisticsPressureType() :
  SummaryStatisticsType()
{
  pressureUnit = 0;
}

SummaryStatisticsPressureType::SummaryStatisticsPressureType(
 AttributesType * AttributesIn,
 StatsValuesEnumType * TypeOfSummaryIn,
 StatsWithReferenceBaseTypeLisd * SummaryStatsValueIn) :
  SummaryStatisticsType(
    AttributesIn,
    TypeOfSummaryIn,
    SummaryStatsValueIn)
{
  pressureUnit = 0;
}

SummaryStatisticsPressureType::SummaryStatisticsPressureType(
 AttributesType * AttributesIn,
 StatsValuesEnumType * TypeOfSummaryIn,
 StatsWithReferenceBaseTypeLisd * SummaryStatsValueIn,
 XmlToken * pressureUnitIn) :
  SummaryStatisticsType(
    AttributesIn,
    TypeOfSummaryIn,
    SummaryStatsValueIn)
{
  pressureUnit = pressureUnitIn;
}

SummaryStatisticsPressureType::~SummaryStatisticsPressureType()
{
  #ifndef NODESTRUCT
  delete pressureUnit;
  #endif
}

void SummaryStatisticsPressureType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (pressureUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "pressureUnit=\"");
      pressureUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<TypeOfSummary");
  TypeOfSummary->printSelf(outFile);
  fprintf(outFile, "</TypeOfSummary>\n");
  {
    if (!SummaryStatsValue)
      {
        fprintf(stderr, "SummaryStatsValue list is missing\n");
        exit(1);
      }
    if (SummaryStatsValue->size() == 0)
      {
        fprintf(stderr, "SummaryStatsValue list is empty\n");
        exit(1);
      }
    if (SummaryStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of SummaryStatsValue list (%d) less than minimum required (1)\n",
                (int)SummaryStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = SummaryStatsValue->begin();
         iter != SummaryStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "SummaryAverage") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryAverage");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryAverage>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryAverage element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryMaximum") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryMaximum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryMaximum>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryMaximum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryMinimum") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryMinimum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryMinimum>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryMinimum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryRange>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryStandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryStandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryStandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryStandardDeviation element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad SummaryStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool SummaryStatisticsPressureType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "pressureUnit")
        {
          XmlToken * pressureUnitVal;
          if (this->pressureUnit)
            {
              fprintf(stderr, "two values for pressureUnit in SummaryStatisticsPressureType\n");
              returnValue = true;
              break;
            }
          pressureUnitVal = new XmlToken(decl->val.c_str());
          if (pressureUnitVal->bad)
            {
              delete pressureUnitVal;
              fprintf(stderr, "bad value %s for pressureUnit in SummaryStatisticsPressureType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->pressureUnit = pressureUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SummaryStatisticsPressureType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->pressureUnit;
      this->pressureUnit = 0;
    }
  return returnValue;
}

XmlToken * SummaryStatisticsPressureType::getpressureUnit()
{return pressureUnit;}

void SummaryStatisticsPressureType::setpressureUnit(XmlToken * pressureUnitIn)
{pressureUnit = pressureUnitIn;}

/* ***************************************************************** */

/* class SummaryStatisticsPressureTypeLisd

*/

SummaryStatisticsPressureTypeLisd::SummaryStatisticsPressureTypeLisd() {}

SummaryStatisticsPressureTypeLisd::SummaryStatisticsPressureTypeLisd(SummaryStatisticsPressureType * aSummaryStatisticsPressureType)
{
  push_back(aSummaryStatisticsPressureType);
}

SummaryStatisticsPressureTypeLisd::~SummaryStatisticsPressureTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<SummaryStatisticsPressureType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void SummaryStatisticsPressureTypeLisd::printSelf(FILE * outFile)
{
  std::list<SummaryStatisticsPressureType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class SummaryStatisticsSpeedType

*/

SummaryStatisticsSpeedType::SummaryStatisticsSpeedType() :
  SummaryStatisticsType()
{
  speedUnit = 0;
}

SummaryStatisticsSpeedType::SummaryStatisticsSpeedType(
 AttributesType * AttributesIn,
 StatsValuesEnumType * TypeOfSummaryIn,
 StatsWithReferenceBaseTypeLisd * SummaryStatsValueIn) :
  SummaryStatisticsType(
    AttributesIn,
    TypeOfSummaryIn,
    SummaryStatsValueIn)
{
  speedUnit = 0;
}

SummaryStatisticsSpeedType::SummaryStatisticsSpeedType(
 AttributesType * AttributesIn,
 StatsValuesEnumType * TypeOfSummaryIn,
 StatsWithReferenceBaseTypeLisd * SummaryStatsValueIn,
 XmlToken * speedUnitIn) :
  SummaryStatisticsType(
    AttributesIn,
    TypeOfSummaryIn,
    SummaryStatsValueIn)
{
  speedUnit = speedUnitIn;
}

SummaryStatisticsSpeedType::~SummaryStatisticsSpeedType()
{
  #ifndef NODESTRUCT
  delete speedUnit;
  #endif
}

void SummaryStatisticsSpeedType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (speedUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "speedUnit=\"");
      speedUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<TypeOfSummary");
  TypeOfSummary->printSelf(outFile);
  fprintf(outFile, "</TypeOfSummary>\n");
  {
    if (!SummaryStatsValue)
      {
        fprintf(stderr, "SummaryStatsValue list is missing\n");
        exit(1);
      }
    if (SummaryStatsValue->size() == 0)
      {
        fprintf(stderr, "SummaryStatsValue list is empty\n");
        exit(1);
      }
    if (SummaryStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of SummaryStatsValue list (%d) less than minimum required (1)\n",
                (int)SummaryStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = SummaryStatsValue->begin();
         iter != SummaryStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "SummaryAverage") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryAverage");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryAverage>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryAverage element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryMaximum") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryMaximum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryMaximum>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryMaximum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryMinimum") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryMinimum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryMinimum>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryMinimum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryRange>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryStandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryStandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryStandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryStandardDeviation element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad SummaryStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool SummaryStatisticsSpeedType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "speedUnit")
        {
          XmlToken * speedUnitVal;
          if (this->speedUnit)
            {
              fprintf(stderr, "two values for speedUnit in SummaryStatisticsSpeedType\n");
              returnValue = true;
              break;
            }
          speedUnitVal = new XmlToken(decl->val.c_str());
          if (speedUnitVal->bad)
            {
              delete speedUnitVal;
              fprintf(stderr, "bad value %s for speedUnit in SummaryStatisticsSpeedType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->speedUnit = speedUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SummaryStatisticsSpeedType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->speedUnit;
      this->speedUnit = 0;
    }
  return returnValue;
}

XmlToken * SummaryStatisticsSpeedType::getspeedUnit()
{return speedUnit;}

void SummaryStatisticsSpeedType::setspeedUnit(XmlToken * speedUnitIn)
{speedUnit = speedUnitIn;}

/* ***************************************************************** */

/* class SummaryStatisticsSpeedTypeLisd

*/

SummaryStatisticsSpeedTypeLisd::SummaryStatisticsSpeedTypeLisd() {}

SummaryStatisticsSpeedTypeLisd::SummaryStatisticsSpeedTypeLisd(SummaryStatisticsSpeedType * aSummaryStatisticsSpeedType)
{
  push_back(aSummaryStatisticsSpeedType);
}

SummaryStatisticsSpeedTypeLisd::~SummaryStatisticsSpeedTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<SummaryStatisticsSpeedType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void SummaryStatisticsSpeedTypeLisd::printSelf(FILE * outFile)
{
  std::list<SummaryStatisticsSpeedType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class SummaryStatisticsTemperatureType

*/

SummaryStatisticsTemperatureType::SummaryStatisticsTemperatureType() :
  SummaryStatisticsType()
{
  temperatureUnit = 0;
}

SummaryStatisticsTemperatureType::SummaryStatisticsTemperatureType(
 AttributesType * AttributesIn,
 StatsValuesEnumType * TypeOfSummaryIn,
 StatsWithReferenceBaseTypeLisd * SummaryStatsValueIn) :
  SummaryStatisticsType(
    AttributesIn,
    TypeOfSummaryIn,
    SummaryStatsValueIn)
{
  temperatureUnit = 0;
}

SummaryStatisticsTemperatureType::SummaryStatisticsTemperatureType(
 AttributesType * AttributesIn,
 StatsValuesEnumType * TypeOfSummaryIn,
 StatsWithReferenceBaseTypeLisd * SummaryStatsValueIn,
 XmlToken * temperatureUnitIn) :
  SummaryStatisticsType(
    AttributesIn,
    TypeOfSummaryIn,
    SummaryStatsValueIn)
{
  temperatureUnit = temperatureUnitIn;
}

SummaryStatisticsTemperatureType::~SummaryStatisticsTemperatureType()
{
  #ifndef NODESTRUCT
  delete temperatureUnit;
  #endif
}

void SummaryStatisticsTemperatureType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (temperatureUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "temperatureUnit=\"");
      temperatureUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<TypeOfSummary");
  TypeOfSummary->printSelf(outFile);
  fprintf(outFile, "</TypeOfSummary>\n");
  {
    if (!SummaryStatsValue)
      {
        fprintf(stderr, "SummaryStatsValue list is missing\n");
        exit(1);
      }
    if (SummaryStatsValue->size() == 0)
      {
        fprintf(stderr, "SummaryStatsValue list is empty\n");
        exit(1);
      }
    if (SummaryStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of SummaryStatsValue list (%d) less than minimum required (1)\n",
                (int)SummaryStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = SummaryStatsValue->begin();
         iter != SummaryStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "SummaryAverage") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryAverage");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryAverage>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryAverage element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryMaximum") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryMaximum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryMaximum>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryMaximum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryMinimum") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryMinimum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryMinimum>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryMinimum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryRange>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryStandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryStandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryStandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryStandardDeviation element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad SummaryStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool SummaryStatisticsTemperatureType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "temperatureUnit")
        {
          XmlToken * temperatureUnitVal;
          if (this->temperatureUnit)
            {
              fprintf(stderr, "two values for temperatureUnit in SummaryStatisticsTemperatureType\n");
              returnValue = true;
              break;
            }
          temperatureUnitVal = new XmlToken(decl->val.c_str());
          if (temperatureUnitVal->bad)
            {
              delete temperatureUnitVal;
              fprintf(stderr, "bad value %s for temperatureUnit in SummaryStatisticsTemperatureType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->temperatureUnit = temperatureUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SummaryStatisticsTemperatureType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->temperatureUnit;
      this->temperatureUnit = 0;
    }
  return returnValue;
}

XmlToken * SummaryStatisticsTemperatureType::gettemperatureUnit()
{return temperatureUnit;}

void SummaryStatisticsTemperatureType::settemperatureUnit(XmlToken * temperatureUnitIn)
{temperatureUnit = temperatureUnitIn;}

/* ***************************************************************** */

/* class SummaryStatisticsTemperatureTypeLisd

*/

SummaryStatisticsTemperatureTypeLisd::SummaryStatisticsTemperatureTypeLisd() {}

SummaryStatisticsTemperatureTypeLisd::SummaryStatisticsTemperatureTypeLisd(SummaryStatisticsTemperatureType * aSummaryStatisticsTemperatureType)
{
  push_back(aSummaryStatisticsTemperatureType);
}

SummaryStatisticsTemperatureTypeLisd::~SummaryStatisticsTemperatureTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<SummaryStatisticsTemperatureType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void SummaryStatisticsTemperatureTypeLisd::printSelf(FILE * outFile)
{
  std::list<SummaryStatisticsTemperatureType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class SummaryStatisticsTimeType

*/

SummaryStatisticsTimeType::SummaryStatisticsTimeType() :
  SummaryStatisticsType()
{
  timeUnit = 0;
}

SummaryStatisticsTimeType::SummaryStatisticsTimeType(
 AttributesType * AttributesIn,
 StatsValuesEnumType * TypeOfSummaryIn,
 StatsWithReferenceBaseTypeLisd * SummaryStatsValueIn) :
  SummaryStatisticsType(
    AttributesIn,
    TypeOfSummaryIn,
    SummaryStatsValueIn)
{
  timeUnit = 0;
}

SummaryStatisticsTimeType::SummaryStatisticsTimeType(
 AttributesType * AttributesIn,
 StatsValuesEnumType * TypeOfSummaryIn,
 StatsWithReferenceBaseTypeLisd * SummaryStatsValueIn,
 XmlToken * timeUnitIn) :
  SummaryStatisticsType(
    AttributesIn,
    TypeOfSummaryIn,
    SummaryStatsValueIn)
{
  timeUnit = timeUnitIn;
}

SummaryStatisticsTimeType::~SummaryStatisticsTimeType()
{
  #ifndef NODESTRUCT
  delete timeUnit;
  #endif
}

void SummaryStatisticsTimeType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (timeUnit)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "timeUnit=\"");
      timeUnit->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<TypeOfSummary");
  TypeOfSummary->printSelf(outFile);
  fprintf(outFile, "</TypeOfSummary>\n");
  {
    if (!SummaryStatsValue)
      {
        fprintf(stderr, "SummaryStatsValue list is missing\n");
        exit(1);
      }
    if (SummaryStatsValue->size() == 0)
      {
        fprintf(stderr, "SummaryStatsValue list is empty\n");
        exit(1);
      }
    if (SummaryStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of SummaryStatsValue list (%d) less than minimum required (1)\n",
                (int)SummaryStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = SummaryStatsValue->begin();
         iter != SummaryStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "SummaryAverage") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryAverage");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryAverage>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryAverage element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryMaximum") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryMaximum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryMaximum>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryMaximum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryMinimum") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryMinimum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryMinimum>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryMinimum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryRange>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryStandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryStandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryStandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryStandardDeviation element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad SummaryStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool SummaryStatisticsTimeType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "timeUnit")
        {
          XmlToken * timeUnitVal;
          if (this->timeUnit)
            {
              fprintf(stderr, "two values for timeUnit in SummaryStatisticsTimeType\n");
              returnValue = true;
              break;
            }
          timeUnitVal = new XmlToken(decl->val.c_str());
          if (timeUnitVal->bad)
            {
              delete timeUnitVal;
              fprintf(stderr, "bad value %s for timeUnit in SummaryStatisticsTimeType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->timeUnit = timeUnitVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SummaryStatisticsTimeType\n");
          returnValue = true;
          break;
        }
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->timeUnit;
      this->timeUnit = 0;
    }
  return returnValue;
}

XmlToken * SummaryStatisticsTimeType::gettimeUnit()
{return timeUnit;}

void SummaryStatisticsTimeType::settimeUnit(XmlToken * timeUnitIn)
{timeUnit = timeUnitIn;}

/* ***************************************************************** */

/* class SummaryStatisticsTimeTypeLisd

*/

SummaryStatisticsTimeTypeLisd::SummaryStatisticsTimeTypeLisd() {}

SummaryStatisticsTimeTypeLisd::SummaryStatisticsTimeTypeLisd(SummaryStatisticsTimeType * aSummaryStatisticsTimeType)
{
  push_back(aSummaryStatisticsTimeType);
}

SummaryStatisticsTimeTypeLisd::~SummaryStatisticsTimeTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<SummaryStatisticsTimeType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void SummaryStatisticsTimeTypeLisd::printSelf(FILE * outFile)
{
  std::list<SummaryStatisticsTimeType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class SummaryStatisticsType

*/

SummaryStatisticsType::SummaryStatisticsType()
{
  Attributes = 0;
  TypeOfSummary = 0;
  SummaryStatsValue = 0;
}

SummaryStatisticsType::SummaryStatisticsType(
 AttributesType * AttributesIn,
 StatsValuesEnumType * TypeOfSummaryIn,
 StatsWithReferenceBaseTypeLisd * SummaryStatsValueIn)
{
  Attributes = AttributesIn;
  TypeOfSummary = TypeOfSummaryIn;
  SummaryStatsValue = SummaryStatsValueIn;
}

SummaryStatisticsType::~SummaryStatisticsType()
{
  #ifndef NODESTRUCT
  delete Attributes;
  delete TypeOfSummary;
  delete SummaryStatsValue;
  #endif
}

void SummaryStatisticsType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<TypeOfSummary");
  TypeOfSummary->printSelf(outFile);
  fprintf(outFile, "</TypeOfSummary>\n");
  {
    if (!SummaryStatsValue)
      {
        fprintf(stderr, "SummaryStatsValue list is missing\n");
        exit(1);
      }
    if (SummaryStatsValue->size() == 0)
      {
        fprintf(stderr, "SummaryStatsValue list is empty\n");
        exit(1);
      }
    if (SummaryStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of SummaryStatsValue list (%d) less than minimum required (1)\n",
                (int)SummaryStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = SummaryStatsValue->begin();
         iter != SummaryStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "SummaryAverage") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryAverage");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryAverage>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryAverage element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryMaximum") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryMaximum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryMaximum>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryMaximum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryMinimum") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryMinimum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryMinimum>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryMinimum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryRange>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryStandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryStandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryStandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryStandardDeviation element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad SummaryStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

AttributesType * SummaryStatisticsType::getAttributes()
{return Attributes;}

void SummaryStatisticsType::setAttributes(AttributesType * AttributesIn)
{Attributes = AttributesIn;}

StatsValuesEnumType * SummaryStatisticsType::getTypeOfSummary()
{return TypeOfSummary;}

void SummaryStatisticsType::setTypeOfSummary(StatsValuesEnumType * TypeOfSummaryIn)
{TypeOfSummary = TypeOfSummaryIn;}

StatsWithReferenceBaseTypeLisd * SummaryStatisticsType::getSummaryStatsValue()
{return SummaryStatsValue;}

void SummaryStatisticsType::setSummaryStatsValue(StatsWithReferenceBaseTypeLisd * SummaryStatsValueIn)
{SummaryStatsValue = SummaryStatsValueIn;}

/* ***************************************************************** */

/* class SummaryStatisticsTypeLisd

*/

SummaryStatisticsTypeLisd::SummaryStatisticsTypeLisd() {}

SummaryStatisticsTypeLisd::SummaryStatisticsTypeLisd(SummaryStatisticsType * aSummaryStatisticsType)
{
  push_back(aSummaryStatisticsType);
}

SummaryStatisticsTypeLisd::~SummaryStatisticsTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<SummaryStatisticsType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void SummaryStatisticsTypeLisd::printSelf(FILE * outFile)
{
  std::list<SummaryStatisticsType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class SummaryStatisticsUserDefinedUnitType

*/

SummaryStatisticsUserDefinedUnitType::SummaryStatisticsUserDefinedUnitType() :
  SummaryStatisticsType()
{
  unitName = 0;
}

SummaryStatisticsUserDefinedUnitType::SummaryStatisticsUserDefinedUnitType(
 AttributesType * AttributesIn,
 StatsValuesEnumType * TypeOfSummaryIn,
 StatsWithReferenceBaseTypeLisd * SummaryStatsValueIn) :
  SummaryStatisticsType(
    AttributesIn,
    TypeOfSummaryIn,
    SummaryStatsValueIn)
{
  unitName = 0;
}

SummaryStatisticsUserDefinedUnitType::SummaryStatisticsUserDefinedUnitType(
 AttributesType * AttributesIn,
 StatsValuesEnumType * TypeOfSummaryIn,
 StatsWithReferenceBaseTypeLisd * SummaryStatsValueIn,
 XmlToken * unitNameIn) :
  SummaryStatisticsType(
    AttributesIn,
    TypeOfSummaryIn,
    SummaryStatsValueIn)
{
  unitName = unitNameIn;
}

SummaryStatisticsUserDefinedUnitType::~SummaryStatisticsUserDefinedUnitType()
{
  #ifndef NODESTRUCT
  delete unitName;
  #endif
}

void SummaryStatisticsUserDefinedUnitType::printSelf(FILE * outFile)
{
  bool printedOne;

  printedOne = false;
  if (unitName)
    {
      if (printedOne)
        {
          fprintf(outFile, "\n");
          doSpaces(0, outFile);
          fprintf(outFile, "  ");
        }
      else
        {
          fprintf(outFile, " ");
          printedOne = true;
        }
      fprintf(outFile, "unitName=\"");
      unitName->oPrintSelf(outFile);
      fprintf(outFile, "\"");
    }
  else
    {
      fprintf(stderr, "required attribute \"unitName\" missing\n");
      exit(1);
    }
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<TypeOfSummary");
  TypeOfSummary->printSelf(outFile);
  fprintf(outFile, "</TypeOfSummary>\n");
  {
    if (!SummaryStatsValue)
      {
        fprintf(stderr, "SummaryStatsValue list is missing\n");
        exit(1);
      }
    if (SummaryStatsValue->size() == 0)
      {
        fprintf(stderr, "SummaryStatsValue list is empty\n");
        exit(1);
      }
    if (SummaryStatsValue->size() < 1)
      {
        fprintf(stderr,
                "size of SummaryStatsValue list (%d) less than minimum required (1)\n",
                (int)SummaryStatsValue->size());
        exit(1);
      }
    std::list<StatsWithReferenceBaseType *>::iterator iter;
    for (iter = SummaryStatsValue->begin();
         iter != SummaryStatsValue->end(); iter++)
      {
        StatsWithReferenceBaseType * basie;
        basie = *iter;
        doSpaces(0, outFile);
        if (basie->printElement == 0)
          {
            fprintf(stderr, "element name missing\n");
            exit(1);
          }
        else if (strcmp(basie->printElement, "SummaryAverage") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryAverage");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryAverage>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryAverage element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryMaximum") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryMaximum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryMaximum>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryMaximum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryMinimum") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryMinimum");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryMinimum>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryMinimum element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryRange") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryRange");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryRange>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryRange element\n");
                exit(1);
              }
          }
        else if (strcmp(basie->printElement, "SummaryStandardDeviation") == 0)
          {
            StatsMeasuredDecimalType * typ;
            if ((typ = dynamic_cast<StatsMeasuredDecimalType *>(basie)))
              {
                fprintf(outFile, "<SummaryStandardDeviation");
                typ->printSelf(outFile);
                doSpaces(0, outFile);
                fprintf(outFile, "</SummaryStandardDeviation>\n");
              }
            else
              {
                fprintf(stderr, "bad SummaryStandardDeviation element\n");
                exit(1);
              }
          }
        else
          {
            fprintf(stderr, "bad SummaryStatsValue type\n");
            fprintf(stderr, " exiting\n");
            exit(1);
          }
      }
  }
  doSpaces(-INDENT, outFile);
}

bool SummaryStatisticsUserDefinedUnitType::badAttributes(
 AttributePairLisd * attributes)
{
  std::list<AttributePair *>::iterator iter;
  AttributePair * decl;
  bool returnValue;

  returnValue = false;
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      decl = *iter;
      if (decl->name == "unitName")
        {
          XmlToken * unitNameVal;
          if (this->unitName)
            {
              fprintf(stderr, "two values for unitName in SummaryStatisticsUserDefinedUnitType\n");
              returnValue = true;
              break;
            }
          unitNameVal = new XmlToken(decl->val.c_str());
          if (unitNameVal->bad)
            {
              delete unitNameVal;
              fprintf(stderr, "bad value %s for unitName in SummaryStatisticsUserDefinedUnitType\n",
                      decl->val.c_str());
              returnValue = true;
              break;
            }
          else
            this->unitName = unitNameVal;
        }
      else
        {
          fprintf(stderr, "bad attribute in SummaryStatisticsUserDefinedUnitType\n");
          returnValue = true;
          break;
        }
    }
  if (this->unitName == 0)
    {
      fprintf(stderr, "required attribute \"unitName\" missing in SummaryStatisticsUserDefinedUnitType\n");
      returnValue = true;
    }
  for (iter = attributes->begin(); iter != attributes->end(); iter++)
    {
      delete *iter;
    }
  attributes->clear();
  if (returnValue == true)
    {
      delete this->unitName;
      this->unitName = 0;
    }
  return returnValue;
}

XmlToken * SummaryStatisticsUserDefinedUnitType::getunitName()
{return unitName;}

void SummaryStatisticsUserDefinedUnitType::setunitName(XmlToken * unitNameIn)
{unitName = unitNameIn;}

/* ***************************************************************** */

/* class SummaryStatisticsUserDefinedUnitTypeLisd

*/

SummaryStatisticsUserDefinedUnitTypeLisd::SummaryStatisticsUserDefinedUnitTypeLisd() {}

SummaryStatisticsUserDefinedUnitTypeLisd::SummaryStatisticsUserDefinedUnitTypeLisd(SummaryStatisticsUserDefinedUnitType * aSummaryStatisticsUserDefinedUnitType)
{
  push_back(aSummaryStatisticsUserDefinedUnitType);
}

SummaryStatisticsUserDefinedUnitTypeLisd::~SummaryStatisticsUserDefinedUnitTypeLisd()
{
  #ifndef NODESTRUCT
  std::list<SummaryStatisticsUserDefinedUnitType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      delete *iter;
    }
  #endif
}

void SummaryStatisticsUserDefinedUnitTypeLisd::printSelf(FILE * outFile)
{
  std::list<SummaryStatisticsUserDefinedUnitType *>::iterator iter;

  for (iter = begin(); iter != end(); iter++)
    {
      (*iter)->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class SurfaceProfileCharacteristicStatsEvalType

*/

SurfaceProfileCharacteristicStatsEvalType::SurfaceProfileCharacteristicStatsEvalType() :
  ProfileCharacteristicStatsEvalBaseType() {}

SurfaceProfileCharacteristicStatsEvalType::SurfaceProfileCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsWithTolLinearType * ValueStatsIn,
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn,
 OneSidedCapabilityCalculationEnumType * CapabilityCalculationMethodIn,
 StatsLinearType * WorstPositiveDeviationStatsIn,
 StatsLinearType * WorstNegativeDeviationStatsIn,
 PointDeviationsStatsEvalType * PointDeviationsStatsIn,
 StatsPassFailType * DatumsOkStatsIn,
 CompositeSegmentsProfileStatsEvalType * CompositeSegmentsStatsIn) :
  ProfileCharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    ValueStatsIn,
    MaxValueStatsIn,
    MinValueStatsIn,
    CapabilityCalculationMethodIn,
    WorstPositiveDeviationStatsIn,
    WorstNegativeDeviationStatsIn,
    PointDeviationsStatsIn,
    DatumsOkStatsIn,
    CompositeSegmentsStatsIn)
{}

SurfaceProfileCharacteristicStatsEvalType::~SurfaceProfileCharacteristicStatsEvalType() {}

void SurfaceProfileCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (ValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ValueStats");
      ValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ValueStats>\n");
    }
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  if (CapabilityCalculationMethod)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CapabilityCalculationMethod");
      CapabilityCalculationMethod->printSelf(outFile);
      fprintf(outFile, "</CapabilityCalculationMethod>\n");
    }
  if (WorstPositiveDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WorstPositiveDeviationStats");
      WorstPositiveDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WorstPositiveDeviationStats>\n");
    }
  if (WorstNegativeDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WorstNegativeDeviationStats");
      WorstNegativeDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WorstNegativeDeviationStats>\n");
    }
  if (PointDeviationsStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointDeviationsStats");
      PointDeviationsStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointDeviationsStats>\n");
    }
  if (DatumsOkStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumsOkStats");
      DatumsOkStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DatumsOkStats>\n");
    }
  if (CompositeSegmentsStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CompositeSegmentsStats");
      CompositeSegmentsStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CompositeSegmentsStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class SurfaceProfileNonUniformCharacteristicStatsEvalType

*/

SurfaceProfileNonUniformCharacteristicStatsEvalType::SurfaceProfileNonUniformCharacteristicStatsEvalType() :
  ProfileCharacteristicStatsEvalBaseType() {}

SurfaceProfileNonUniformCharacteristicStatsEvalType::SurfaceProfileNonUniformCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsWithTolLinearType * ValueStatsIn,
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn,
 OneSidedCapabilityCalculationEnumType * CapabilityCalculationMethodIn,
 StatsLinearType * WorstPositiveDeviationStatsIn,
 StatsLinearType * WorstNegativeDeviationStatsIn,
 PointDeviationsStatsEvalType * PointDeviationsStatsIn,
 StatsPassFailType * DatumsOkStatsIn,
 CompositeSegmentsProfileStatsEvalType * CompositeSegmentsStatsIn) :
  ProfileCharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    ValueStatsIn,
    MaxValueStatsIn,
    MinValueStatsIn,
    CapabilityCalculationMethodIn,
    WorstPositiveDeviationStatsIn,
    WorstNegativeDeviationStatsIn,
    PointDeviationsStatsIn,
    DatumsOkStatsIn,
    CompositeSegmentsStatsIn)
{}

SurfaceProfileNonUniformCharacteristicStatsEvalType::~SurfaceProfileNonUniformCharacteristicStatsEvalType() {}

void SurfaceProfileNonUniformCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (ValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ValueStats");
      ValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ValueStats>\n");
    }
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  if (CapabilityCalculationMethod)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CapabilityCalculationMethod");
      CapabilityCalculationMethod->printSelf(outFile);
      fprintf(outFile, "</CapabilityCalculationMethod>\n");
    }
  if (WorstPositiveDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WorstPositiveDeviationStats");
      WorstPositiveDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WorstPositiveDeviationStats>\n");
    }
  if (WorstNegativeDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WorstNegativeDeviationStats");
      WorstNegativeDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WorstNegativeDeviationStats>\n");
    }
  if (PointDeviationsStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PointDeviationsStats");
      PointDeviationsStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PointDeviationsStats>\n");
    }
  if (DatumsOkStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumsOkStats");
      DatumsOkStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DatumsOkStats>\n");
    }
  if (CompositeSegmentsStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CompositeSegmentsStats");
      CompositeSegmentsStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CompositeSegmentsStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class SurfaceTextureCharacteristicStatsEvalType

*/

SurfaceTextureCharacteristicStatsEvalType::SurfaceTextureCharacteristicStatsEvalType() :
  CharacteristicStatsEvalBaseType()
{
  RoughnessAverageValueStats = 0;
}

SurfaceTextureCharacteristicStatsEvalType::SurfaceTextureCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsWithTolLinearType * RoughnessAverageValueStatsIn) :
  CharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn)
{
  RoughnessAverageValueStats = RoughnessAverageValueStatsIn;
}

SurfaceTextureCharacteristicStatsEvalType::~SurfaceTextureCharacteristicStatsEvalType()
{
  #ifndef NODESTRUCT
  delete RoughnessAverageValueStats;
  #endif
}

void SurfaceTextureCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (RoughnessAverageValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<RoughnessAverageValueStats");
      RoughnessAverageValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</RoughnessAverageValueStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

StatsWithTolLinearType * SurfaceTextureCharacteristicStatsEvalType::getRoughnessAverageValueStats()
{return RoughnessAverageValueStats;}

void SurfaceTextureCharacteristicStatsEvalType::setRoughnessAverageValueStats(StatsWithTolLinearType * RoughnessAverageValueStatsIn)
{RoughnessAverageValueStats = RoughnessAverageValueStatsIn;}

/* ***************************************************************** */

/* class SymmetryCharacteristicStatsEvalType

*/

SymmetryCharacteristicStatsEvalType::SymmetryCharacteristicStatsEvalType() :
  LocationCharacteristicStatsEvalType()
{
  CapabilityCalculationMethod = 0;
  CompositeSegmentsStats = 0;
}

SymmetryCharacteristicStatsEvalType::SymmetryCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsWithTolLinearType * ValueStatsIn,
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn,
 StatsPassFailType * DatumsOkStatsIn,
 OneSidedCapabilityCalculationEnumType * CapabilityCalculationMethodIn,
 CompositeSegmentsSymmetryStatsEvalType * CompositeSegmentsStatsIn) :
  LocationCharacteristicStatsEvalType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    ValueStatsIn,
    MaxValueStatsIn,
    MinValueStatsIn,
    DatumsOkStatsIn)
{
  CapabilityCalculationMethod = CapabilityCalculationMethodIn;
  CompositeSegmentsStats = CompositeSegmentsStatsIn;
}

SymmetryCharacteristicStatsEvalType::~SymmetryCharacteristicStatsEvalType()
{
  #ifndef NODESTRUCT
  delete CapabilityCalculationMethod;
  delete CompositeSegmentsStats;
  #endif
}

void SymmetryCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (ValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ValueStats");
      ValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ValueStats>\n");
    }
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  if (DatumsOkStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumsOkStats");
      DatumsOkStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DatumsOkStats>\n");
    }
  if (CapabilityCalculationMethod)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CapabilityCalculationMethod");
      CapabilityCalculationMethod->printSelf(outFile);
      fprintf(outFile, "</CapabilityCalculationMethod>\n");
    }
  if (CompositeSegmentsStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CompositeSegmentsStats");
      CompositeSegmentsStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CompositeSegmentsStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

OneSidedCapabilityCalculationEnumType * SymmetryCharacteristicStatsEvalType::getCapabilityCalculationMethod()
{return CapabilityCalculationMethod;}

void SymmetryCharacteristicStatsEvalType::setCapabilityCalculationMethod(OneSidedCapabilityCalculationEnumType * CapabilityCalculationMethodIn)
{CapabilityCalculationMethod = CapabilityCalculationMethodIn;}

CompositeSegmentsSymmetryStatsEvalType * SymmetryCharacteristicStatsEvalType::getCompositeSegmentsStats()
{return CompositeSegmentsStats;}

void SymmetryCharacteristicStatsEvalType::setCompositeSegmentsStats(CompositeSegmentsSymmetryStatsEvalType * CompositeSegmentsStatsIn)
{CompositeSegmentsStats = CompositeSegmentsStatsIn;}

/* ***************************************************************** */

/* class ThicknessCharacteristicStatsEvalType

*/

ThicknessCharacteristicStatsEvalType::ThicknessCharacteristicStatsEvalType() :
  LinearCharacteristicStatsEvalType() {}

ThicknessCharacteristicStatsEvalType::ThicknessCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 LinearCharacteristicStatsEvalTypeChoicePair * LinearCharacteristicStatsEvalTypePairIn) :
  LinearCharacteristicStatsEvalType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    LinearCharacteristicStatsEvalTypePairIn)
{}

ThicknessCharacteristicStatsEvalType::~ThicknessCharacteristicStatsEvalType() {}

void ThicknessCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  LinearCharacteristicStatsEvalTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class ThreadCharacteristicStatsEvalType

*/

ThreadCharacteristicStatsEvalType::ThreadCharacteristicStatsEvalType() :
  CharacteristicStatsEvalBaseType()
{
  ThreadStats = 0;
  PitchDiameterStats = 0;
  FunctionalSizeStats = 0;
}

ThreadCharacteristicStatsEvalType::ThreadCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsPassFailType * ThreadStatsIn,
 StatsLinearType * PitchDiameterStatsIn,
 StatsLinearType * FunctionalSizeStatsIn) :
  CharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn)
{
  ThreadStats = ThreadStatsIn;
  PitchDiameterStats = PitchDiameterStatsIn;
  FunctionalSizeStats = FunctionalSizeStatsIn;
}

ThreadCharacteristicStatsEvalType::~ThreadCharacteristicStatsEvalType()
{
  #ifndef NODESTRUCT
  delete ThreadStats;
  delete PitchDiameterStats;
  delete FunctionalSizeStats;
  #endif
}

void ThreadCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (ThreadStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ThreadStats");
      ThreadStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ThreadStats>\n");
    }
  if (PitchDiameterStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<PitchDiameterStats");
      PitchDiameterStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</PitchDiameterStats>\n");
    }
  if (FunctionalSizeStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<FunctionalSizeStats");
      FunctionalSizeStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</FunctionalSizeStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

StatsPassFailType * ThreadCharacteristicStatsEvalType::getThreadStats()
{return ThreadStats;}

void ThreadCharacteristicStatsEvalType::setThreadStats(StatsPassFailType * ThreadStatsIn)
{ThreadStats = ThreadStatsIn;}

StatsLinearType * ThreadCharacteristicStatsEvalType::getPitchDiameterStats()
{return PitchDiameterStats;}

void ThreadCharacteristicStatsEvalType::setPitchDiameterStats(StatsLinearType * PitchDiameterStatsIn)
{PitchDiameterStats = PitchDiameterStatsIn;}

StatsLinearType * ThreadCharacteristicStatsEvalType::getFunctionalSizeStats()
{return FunctionalSizeStats;}

void ThreadCharacteristicStatsEvalType::setFunctionalSizeStats(StatsLinearType * FunctionalSizeStatsIn)
{FunctionalSizeStats = FunctionalSizeStatsIn;}

/* ***************************************************************** */

/* class ToroidicityCharacteristicStatsEvalType

*/

ToroidicityCharacteristicStatsEvalType::ToroidicityCharacteristicStatsEvalType() :
  FormCharacteristicStatsEvalBaseType() {}

ToroidicityCharacteristicStatsEvalType::ToroidicityCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsWithTolLinearType * ValueStatsIn,
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn,
 OneSidedCapabilityCalculationEnumType * CapabilityCalculationMethodIn) :
  FormCharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    ValueStatsIn,
    MaxValueStatsIn,
    MinValueStatsIn,
    CapabilityCalculationMethodIn)
{}

ToroidicityCharacteristicStatsEvalType::~ToroidicityCharacteristicStatsEvalType() {}

void ToroidicityCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (ValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ValueStats");
      ValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ValueStats>\n");
    }
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  if (CapabilityCalculationMethod)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CapabilityCalculationMethod");
      CapabilityCalculationMethod->printSelf(outFile);
      fprintf(outFile, "</CapabilityCalculationMethod>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class TotalRunoutCharacteristicStatsEvalType

*/

TotalRunoutCharacteristicStatsEvalType::TotalRunoutCharacteristicStatsEvalType() :
  RunoutCharacteristicStatsEvalBaseType() {}

TotalRunoutCharacteristicStatsEvalType::TotalRunoutCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsWithTolLinearType * ValueStatsIn,
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn,
 OneSidedCapabilityCalculationEnumType * CapabilityCalculationMethodIn,
 StatsPassFailType * DatumsOkStatsIn) :
  RunoutCharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    ValueStatsIn,
    MaxValueStatsIn,
    MinValueStatsIn,
    CapabilityCalculationMethodIn,
    DatumsOkStatsIn)
{}

TotalRunoutCharacteristicStatsEvalType::~TotalRunoutCharacteristicStatsEvalType() {}

void TotalRunoutCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (ValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ValueStats");
      ValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</ValueStats>\n");
    }
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  if (CapabilityCalculationMethod)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CapabilityCalculationMethod");
      CapabilityCalculationMethod->printSelf(outFile);
      fprintf(outFile, "</CapabilityCalculationMethod>\n");
    }
  if (DatumsOkStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DatumsOkStats");
      DatumsOkStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DatumsOkStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class UserDefinedAngularCharacteristicStatsEvalType

*/

UserDefinedAngularCharacteristicStatsEvalType::UserDefinedAngularCharacteristicStatsEvalType() :
  CharacteristicStatsEvalBaseType()
{
  UserDefinedAngularCharacteristicStatsEvalTypePair = 0;
}

UserDefinedAngularCharacteristicStatsEvalType::UserDefinedAngularCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 UserDefinedAngularCharacteristicStatsEvalTypeChoicePair * UserDefinedAngularCharacteristicStatsEvalTypePairIn) :
  CharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn)
{
  UserDefinedAngularCharacteristicStatsEvalTypePair = UserDefinedAngularCharacteristicStatsEvalTypePairIn;
}

UserDefinedAngularCharacteristicStatsEvalType::~UserDefinedAngularCharacteristicStatsEvalType()
{
  #ifndef NODESTRUCT
  delete UserDefinedAngularCharacteristicStatsEvalTypePair;
  #endif
}

void UserDefinedAngularCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  UserDefinedAngularCharacteristicStatsEvalTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}
UserDefinedAngularCharacteristicStatsEvalTypeChoicePair * UserDefinedAngularCharacteristicStatsEvalType::getUserDefinedAngularCharacteristicStatsEvalTypeChoicePair()
{return UserDefinedAngularCharacteristicStatsEvalTypePair;}

void UserDefinedAngularCharacteristicStatsEvalType::setUserDefinedAngularCharacteristicStatsEvalTypeChoicePair(UserDefinedAngularCharacteristicStatsEvalTypeChoicePair * UserDefinedAngularCharacteristicStatsEvalTypePairIn)
{UserDefinedAngularCharacteristicStatsEvalTypePair = UserDefinedAngularCharacteristicStatsEvalTypePairIn;}

/* ***************************************************************** */

UserDefinedAngularCharacteristicStatsEvalTypeChoicePair::UserDefinedAngularCharacteristicStatsEvalTypeChoicePair() {}

UserDefinedAngularCharacteristicStatsEvalTypeChoicePair::UserDefinedAngularCharacteristicStatsEvalTypeChoicePair(
 whichOne UserDefinedAngularCharacteristicStatsEvalTypeTypeIn,
 UserDefinedAngularCharacteristicStatsEvalTypeVal UserDefinedAngularCharacteristicStatsEvalTypeValueIn)
{
  UserDefinedAngularCharacteristicStatsEvalTypeType = UserDefinedAngularCharacteristicStatsEvalTypeTypeIn;
  UserDefinedAngularCharacteristicStatsEvalTypeValue = UserDefinedAngularCharacteristicStatsEvalTypeValueIn;
}

UserDefinedAngularCharacteristicStatsEvalTypeChoicePair::~UserDefinedAngularCharacteristicStatsEvalTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (UserDefinedAngularCharacteristicStatsEvalTypeType == UserDefinedAngu_1116E)
    delete UserDefinedAngularCharacteristicStatsEvalTypeValue.UserDefinedAngu_1116;
  else if (UserDefinedAngularCharacteristicStatsEvalTypeType == UserDefinedAngu_1117E)
    delete UserDefinedAngularCharacteristicStatsEvalTypeValue.UserDefinedAngu_1117;
  else if (UserDefinedAngularCharacteristicStatsEvalTypeType == MinValueStatsE)
    delete UserDefinedAngularCharacteristicStatsEvalTypeValue.MinValueStats;
  else if (UserDefinedAngularCharacteristicStatsEvalTypeType == UserDefinedAngu_1118E)
    delete UserDefinedAngularCharacteristicStatsEvalTypeValue.UserDefinedAngu_1118;
  else if (UserDefinedAngularCharacteristicStatsEvalTypeType == UserDefinedAngu_1119E)
    delete UserDefinedAngularCharacteristicStatsEvalTypeValue.UserDefinedAngu_1119;
  else if (UserDefinedAngularCharacteristicStatsEvalTypeType == MinDeviationStatsE)
    delete UserDefinedAngularCharacteristicStatsEvalTypeValue.MinDeviationStats;
  #endif
}

void UserDefinedAngularCharacteristicStatsEvalTypeChoicePair::printSelf(FILE * outFile)
{
  if (UserDefinedAngularCharacteristicStatsEvalTypeType == UserDefinedAngu_1116E)
    {
      UserDefinedAngularCharacteristicStatsEvalTypeValue.UserDefinedAngu_1116->printSelf(outFile);
    }
  else if (UserDefinedAngularCharacteristicStatsEvalTypeType == UserDefinedAngu_1117E)
    {
      UserDefinedAngularCharacteristicStatsEvalTypeValue.UserDefinedAngu_1117->printSelf(outFile);
    }
  else if (UserDefinedAngularCharacteristicStatsEvalTypeType == MinValueStatsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      UserDefinedAngularCharacteristicStatsEvalTypeValue.MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  else if (UserDefinedAngularCharacteristicStatsEvalTypeType == UserDefinedAngu_1118E)
    {
      UserDefinedAngularCharacteristicStatsEvalTypeValue.UserDefinedAngu_1118->printSelf(outFile);
    }
  else if (UserDefinedAngularCharacteristicStatsEvalTypeType == UserDefinedAngu_1119E)
    {
      UserDefinedAngularCharacteristicStatsEvalTypeValue.UserDefinedAngu_1119->printSelf(outFile);
    }
  else if (UserDefinedAngularCharacteristicStatsEvalTypeType == MinDeviationStatsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      UserDefinedAngularCharacteristicStatsEvalTypeValue.MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

/* ***************************************************************** */

/* class UserDefinedAreaCharacteristicStatsEvalType

*/

UserDefinedAreaCharacteristicStatsEvalType::UserDefinedAreaCharacteristicStatsEvalType() :
  CharacteristicStatsEvalBaseType()
{
  UserDefinedAreaCharacteristicStatsEvalTypePair = 0;
}

UserDefinedAreaCharacteristicStatsEvalType::UserDefinedAreaCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 UserDefinedAreaCharacteristicStatsEvalTypeChoicePair * UserDefinedAreaCharacteristicStatsEvalTypePairIn) :
  CharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn)
{
  UserDefinedAreaCharacteristicStatsEvalTypePair = UserDefinedAreaCharacteristicStatsEvalTypePairIn;
}

UserDefinedAreaCharacteristicStatsEvalType::~UserDefinedAreaCharacteristicStatsEvalType()
{
  #ifndef NODESTRUCT
  delete UserDefinedAreaCharacteristicStatsEvalTypePair;
  #endif
}

void UserDefinedAreaCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  UserDefinedAreaCharacteristicStatsEvalTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}
UserDefinedAreaCharacteristicStatsEvalTypeChoicePair * UserDefinedAreaCharacteristicStatsEvalType::getUserDefinedAreaCharacteristicStatsEvalTypeChoicePair()
{return UserDefinedAreaCharacteristicStatsEvalTypePair;}

void UserDefinedAreaCharacteristicStatsEvalType::setUserDefinedAreaCharacteristicStatsEvalTypeChoicePair(UserDefinedAreaCharacteristicStatsEvalTypeChoicePair * UserDefinedAreaCharacteristicStatsEvalTypePairIn)
{UserDefinedAreaCharacteristicStatsEvalTypePair = UserDefinedAreaCharacteristicStatsEvalTypePairIn;}

/* ***************************************************************** */

UserDefinedAreaCharacteristicStatsEvalTypeChoicePair::UserDefinedAreaCharacteristicStatsEvalTypeChoicePair() {}

UserDefinedAreaCharacteristicStatsEvalTypeChoicePair::UserDefinedAreaCharacteristicStatsEvalTypeChoicePair(
 whichOne UserDefinedAreaCharacteristicStatsEvalTypeTypeIn,
 UserDefinedAreaCharacteristicStatsEvalTypeVal UserDefinedAreaCharacteristicStatsEvalTypeValueIn)
{
  UserDefinedAreaCharacteristicStatsEvalTypeType = UserDefinedAreaCharacteristicStatsEvalTypeTypeIn;
  UserDefinedAreaCharacteristicStatsEvalTypeValue = UserDefinedAreaCharacteristicStatsEvalTypeValueIn;
}

UserDefinedAreaCharacteristicStatsEvalTypeChoicePair::~UserDefinedAreaCharacteristicStatsEvalTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (UserDefinedAreaCharacteristicStatsEvalTypeType == UserDefinedArea_1120E)
    delete UserDefinedAreaCharacteristicStatsEvalTypeValue.UserDefinedArea_1120;
  else if (UserDefinedAreaCharacteristicStatsEvalTypeType == UserDefinedArea_1121E)
    delete UserDefinedAreaCharacteristicStatsEvalTypeValue.UserDefinedArea_1121;
  else if (UserDefinedAreaCharacteristicStatsEvalTypeType == MinValueStatsE)
    delete UserDefinedAreaCharacteristicStatsEvalTypeValue.MinValueStats;
  else if (UserDefinedAreaCharacteristicStatsEvalTypeType == UserDefinedArea_1122E)
    delete UserDefinedAreaCharacteristicStatsEvalTypeValue.UserDefinedArea_1122;
  else if (UserDefinedAreaCharacteristicStatsEvalTypeType == UserDefinedArea_1123E)
    delete UserDefinedAreaCharacteristicStatsEvalTypeValue.UserDefinedArea_1123;
  else if (UserDefinedAreaCharacteristicStatsEvalTypeType == MinDeviationStatsE)
    delete UserDefinedAreaCharacteristicStatsEvalTypeValue.MinDeviationStats;
  #endif
}

void UserDefinedAreaCharacteristicStatsEvalTypeChoicePair::printSelf(FILE * outFile)
{
  if (UserDefinedAreaCharacteristicStatsEvalTypeType == UserDefinedArea_1120E)
    {
      UserDefinedAreaCharacteristicStatsEvalTypeValue.UserDefinedArea_1120->printSelf(outFile);
    }
  else if (UserDefinedAreaCharacteristicStatsEvalTypeType == UserDefinedArea_1121E)
    {
      UserDefinedAreaCharacteristicStatsEvalTypeValue.UserDefinedArea_1121->printSelf(outFile);
    }
  else if (UserDefinedAreaCharacteristicStatsEvalTypeType == MinValueStatsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      UserDefinedAreaCharacteristicStatsEvalTypeValue.MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  else if (UserDefinedAreaCharacteristicStatsEvalTypeType == UserDefinedArea_1122E)
    {
      UserDefinedAreaCharacteristicStatsEvalTypeValue.UserDefinedArea_1122->printSelf(outFile);
    }
  else if (UserDefinedAreaCharacteristicStatsEvalTypeType == UserDefinedArea_1123E)
    {
      UserDefinedAreaCharacteristicStatsEvalTypeValue.UserDefinedArea_1123->printSelf(outFile);
    }
  else if (UserDefinedAreaCharacteristicStatsEvalTypeType == MinDeviationStatsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      UserDefinedAreaCharacteristicStatsEvalTypeValue.MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

/* ***************************************************************** */

/* class UserDefinedAttributeCharacteristicStatsEvalType

*/

UserDefinedAttributeCharacteristicStatsEvalType::UserDefinedAttributeCharacteristicStatsEvalType() :
  CharacteristicStatsEvalBaseType()
{
  AttributeStats = 0;
}

UserDefinedAttributeCharacteristicStatsEvalType::UserDefinedAttributeCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsPassFailType * AttributeStatsIn) :
  CharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn)
{
  AttributeStats = AttributeStatsIn;
}

UserDefinedAttributeCharacteristicStatsEvalType::~UserDefinedAttributeCharacteristicStatsEvalType()
{
  #ifndef NODESTRUCT
  delete AttributeStats;
  #endif
}

void UserDefinedAttributeCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (AttributeStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AttributeStats");
      AttributeStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</AttributeStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

StatsPassFailType * UserDefinedAttributeCharacteristicStatsEvalType::getAttributeStats()
{return AttributeStats;}

void UserDefinedAttributeCharacteristicStatsEvalType::setAttributeStats(StatsPassFailType * AttributeStatsIn)
{AttributeStats = AttributeStatsIn;}

/* ***************************************************************** */

/* class UserDefinedForceCharacteristicStatsEvalType

*/

UserDefinedForceCharacteristicStatsEvalType::UserDefinedForceCharacteristicStatsEvalType() :
  CharacteristicStatsEvalBaseType()
{
  UserDefinedForceCharacteristicStatsEvalTypePair = 0;
}

UserDefinedForceCharacteristicStatsEvalType::UserDefinedForceCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 UserDefinedForceCharacteristicStatsEvalTypeChoicePair * UserDefinedForceCharacteristicStatsEvalTypePairIn) :
  CharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn)
{
  UserDefinedForceCharacteristicStatsEvalTypePair = UserDefinedForceCharacteristicStatsEvalTypePairIn;
}

UserDefinedForceCharacteristicStatsEvalType::~UserDefinedForceCharacteristicStatsEvalType()
{
  #ifndef NODESTRUCT
  delete UserDefinedForceCharacteristicStatsEvalTypePair;
  #endif
}

void UserDefinedForceCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  UserDefinedForceCharacteristicStatsEvalTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}
UserDefinedForceCharacteristicStatsEvalTypeChoicePair * UserDefinedForceCharacteristicStatsEvalType::getUserDefinedForceCharacteristicStatsEvalTypeChoicePair()
{return UserDefinedForceCharacteristicStatsEvalTypePair;}

void UserDefinedForceCharacteristicStatsEvalType::setUserDefinedForceCharacteristicStatsEvalTypeChoicePair(UserDefinedForceCharacteristicStatsEvalTypeChoicePair * UserDefinedForceCharacteristicStatsEvalTypePairIn)
{UserDefinedForceCharacteristicStatsEvalTypePair = UserDefinedForceCharacteristicStatsEvalTypePairIn;}

/* ***************************************************************** */

UserDefinedForceCharacteristicStatsEvalTypeChoicePair::UserDefinedForceCharacteristicStatsEvalTypeChoicePair() {}

UserDefinedForceCharacteristicStatsEvalTypeChoicePair::UserDefinedForceCharacteristicStatsEvalTypeChoicePair(
 whichOne UserDefinedForceCharacteristicStatsEvalTypeTypeIn,
 UserDefinedForceCharacteristicStatsEvalTypeVal UserDefinedForceCharacteristicStatsEvalTypeValueIn)
{
  UserDefinedForceCharacteristicStatsEvalTypeType = UserDefinedForceCharacteristicStatsEvalTypeTypeIn;
  UserDefinedForceCharacteristicStatsEvalTypeValue = UserDefinedForceCharacteristicStatsEvalTypeValueIn;
}

UserDefinedForceCharacteristicStatsEvalTypeChoicePair::~UserDefinedForceCharacteristicStatsEvalTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (UserDefinedForceCharacteristicStatsEvalTypeType == UserDefinedForc_1124E)
    delete UserDefinedForceCharacteristicStatsEvalTypeValue.UserDefinedForc_1124;
  else if (UserDefinedForceCharacteristicStatsEvalTypeType == UserDefinedForc_1125E)
    delete UserDefinedForceCharacteristicStatsEvalTypeValue.UserDefinedForc_1125;
  else if (UserDefinedForceCharacteristicStatsEvalTypeType == MinValueStatsE)
    delete UserDefinedForceCharacteristicStatsEvalTypeValue.MinValueStats;
  else if (UserDefinedForceCharacteristicStatsEvalTypeType == UserDefinedForc_1126E)
    delete UserDefinedForceCharacteristicStatsEvalTypeValue.UserDefinedForc_1126;
  else if (UserDefinedForceCharacteristicStatsEvalTypeType == UserDefinedForc_1127E)
    delete UserDefinedForceCharacteristicStatsEvalTypeValue.UserDefinedForc_1127;
  else if (UserDefinedForceCharacteristicStatsEvalTypeType == MinDeviationStatsE)
    delete UserDefinedForceCharacteristicStatsEvalTypeValue.MinDeviationStats;
  #endif
}

void UserDefinedForceCharacteristicStatsEvalTypeChoicePair::printSelf(FILE * outFile)
{
  if (UserDefinedForceCharacteristicStatsEvalTypeType == UserDefinedForc_1124E)
    {
      UserDefinedForceCharacteristicStatsEvalTypeValue.UserDefinedForc_1124->printSelf(outFile);
    }
  else if (UserDefinedForceCharacteristicStatsEvalTypeType == UserDefinedForc_1125E)
    {
      UserDefinedForceCharacteristicStatsEvalTypeValue.UserDefinedForc_1125->printSelf(outFile);
    }
  else if (UserDefinedForceCharacteristicStatsEvalTypeType == MinValueStatsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      UserDefinedForceCharacteristicStatsEvalTypeValue.MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  else if (UserDefinedForceCharacteristicStatsEvalTypeType == UserDefinedForc_1126E)
    {
      UserDefinedForceCharacteristicStatsEvalTypeValue.UserDefinedForc_1126->printSelf(outFile);
    }
  else if (UserDefinedForceCharacteristicStatsEvalTypeType == UserDefinedForc_1127E)
    {
      UserDefinedForceCharacteristicStatsEvalTypeValue.UserDefinedForc_1127->printSelf(outFile);
    }
  else if (UserDefinedForceCharacteristicStatsEvalTypeType == MinDeviationStatsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      UserDefinedForceCharacteristicStatsEvalTypeValue.MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

/* ***************************************************************** */

/* class UserDefinedLinearCharacteristicStatsEvalType

*/

UserDefinedLinearCharacteristicStatsEvalType::UserDefinedLinearCharacteristicStatsEvalType() :
  CharacteristicStatsEvalBaseType()
{
  UserDefinedLinearCharacteristicStatsEvalTypePair = 0;
}

UserDefinedLinearCharacteristicStatsEvalType::UserDefinedLinearCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 UserDefinedLinearCharacteristicStatsEvalTypeChoicePair * UserDefinedLinearCharacteristicStatsEvalTypePairIn) :
  CharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn)
{
  UserDefinedLinearCharacteristicStatsEvalTypePair = UserDefinedLinearCharacteristicStatsEvalTypePairIn;
}

UserDefinedLinearCharacteristicStatsEvalType::~UserDefinedLinearCharacteristicStatsEvalType()
{
  #ifndef NODESTRUCT
  delete UserDefinedLinearCharacteristicStatsEvalTypePair;
  #endif
}

void UserDefinedLinearCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  UserDefinedLinearCharacteristicStatsEvalTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}
UserDefinedLinearCharacteristicStatsEvalTypeChoicePair * UserDefinedLinearCharacteristicStatsEvalType::getUserDefinedLinearCharacteristicStatsEvalTypeChoicePair()
{return UserDefinedLinearCharacteristicStatsEvalTypePair;}

void UserDefinedLinearCharacteristicStatsEvalType::setUserDefinedLinearCharacteristicStatsEvalTypeChoicePair(UserDefinedLinearCharacteristicStatsEvalTypeChoicePair * UserDefinedLinearCharacteristicStatsEvalTypePairIn)
{UserDefinedLinearCharacteristicStatsEvalTypePair = UserDefinedLinearCharacteristicStatsEvalTypePairIn;}

/* ***************************************************************** */

UserDefinedLinearCharacteristicStatsEvalTypeChoicePair::UserDefinedLinearCharacteristicStatsEvalTypeChoicePair() {}

UserDefinedLinearCharacteristicStatsEvalTypeChoicePair::UserDefinedLinearCharacteristicStatsEvalTypeChoicePair(
 whichOne UserDefinedLinearCharacteristicStatsEvalTypeTypeIn,
 UserDefinedLinearCharacteristicStatsEvalTypeVal UserDefinedLinearCharacteristicStatsEvalTypeValueIn)
{
  UserDefinedLinearCharacteristicStatsEvalTypeType = UserDefinedLinearCharacteristicStatsEvalTypeTypeIn;
  UserDefinedLinearCharacteristicStatsEvalTypeValue = UserDefinedLinearCharacteristicStatsEvalTypeValueIn;
}

UserDefinedLinearCharacteristicStatsEvalTypeChoicePair::~UserDefinedLinearCharacteristicStatsEvalTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (UserDefinedLinearCharacteristicStatsEvalTypeType == UserDefinedLine_1128E)
    delete UserDefinedLinearCharacteristicStatsEvalTypeValue.UserDefinedLine_1128;
  else if (UserDefinedLinearCharacteristicStatsEvalTypeType == UserDefinedLine_1129E)
    delete UserDefinedLinearCharacteristicStatsEvalTypeValue.UserDefinedLine_1129;
  else if (UserDefinedLinearCharacteristicStatsEvalTypeType == MinValueStatsE)
    delete UserDefinedLinearCharacteristicStatsEvalTypeValue.MinValueStats;
  else if (UserDefinedLinearCharacteristicStatsEvalTypeType == UserDefinedLine_1130E)
    delete UserDefinedLinearCharacteristicStatsEvalTypeValue.UserDefinedLine_1130;
  else if (UserDefinedLinearCharacteristicStatsEvalTypeType == UserDefinedLine_1131E)
    delete UserDefinedLinearCharacteristicStatsEvalTypeValue.UserDefinedLine_1131;
  else if (UserDefinedLinearCharacteristicStatsEvalTypeType == MinDeviationStatsE)
    delete UserDefinedLinearCharacteristicStatsEvalTypeValue.MinDeviationStats;
  #endif
}

void UserDefinedLinearCharacteristicStatsEvalTypeChoicePair::printSelf(FILE * outFile)
{
  if (UserDefinedLinearCharacteristicStatsEvalTypeType == UserDefinedLine_1128E)
    {
      UserDefinedLinearCharacteristicStatsEvalTypeValue.UserDefinedLine_1128->printSelf(outFile);
    }
  else if (UserDefinedLinearCharacteristicStatsEvalTypeType == UserDefinedLine_1129E)
    {
      UserDefinedLinearCharacteristicStatsEvalTypeValue.UserDefinedLine_1129->printSelf(outFile);
    }
  else if (UserDefinedLinearCharacteristicStatsEvalTypeType == MinValueStatsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      UserDefinedLinearCharacteristicStatsEvalTypeValue.MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  else if (UserDefinedLinearCharacteristicStatsEvalTypeType == UserDefinedLine_1130E)
    {
      UserDefinedLinearCharacteristicStatsEvalTypeValue.UserDefinedLine_1130->printSelf(outFile);
    }
  else if (UserDefinedLinearCharacteristicStatsEvalTypeType == UserDefinedLine_1131E)
    {
      UserDefinedLinearCharacteristicStatsEvalTypeValue.UserDefinedLine_1131->printSelf(outFile);
    }
  else if (UserDefinedLinearCharacteristicStatsEvalTypeType == MinDeviationStatsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      UserDefinedLinearCharacteristicStatsEvalTypeValue.MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

/* ***************************************************************** */

/* class UserDefinedMassCharacteristicStatsEvalType

*/

UserDefinedMassCharacteristicStatsEvalType::UserDefinedMassCharacteristicStatsEvalType() :
  CharacteristicStatsEvalBaseType()
{
  UserDefinedMassCharacteristicStatsEvalTypePair = 0;
}

UserDefinedMassCharacteristicStatsEvalType::UserDefinedMassCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 UserDefinedMassCharacteristicStatsEvalTypeChoicePair * UserDefinedMassCharacteristicStatsEvalTypePairIn) :
  CharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn)
{
  UserDefinedMassCharacteristicStatsEvalTypePair = UserDefinedMassCharacteristicStatsEvalTypePairIn;
}

UserDefinedMassCharacteristicStatsEvalType::~UserDefinedMassCharacteristicStatsEvalType()
{
  #ifndef NODESTRUCT
  delete UserDefinedMassCharacteristicStatsEvalTypePair;
  #endif
}

void UserDefinedMassCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  UserDefinedMassCharacteristicStatsEvalTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}
UserDefinedMassCharacteristicStatsEvalTypeChoicePair * UserDefinedMassCharacteristicStatsEvalType::getUserDefinedMassCharacteristicStatsEvalTypeChoicePair()
{return UserDefinedMassCharacteristicStatsEvalTypePair;}

void UserDefinedMassCharacteristicStatsEvalType::setUserDefinedMassCharacteristicStatsEvalTypeChoicePair(UserDefinedMassCharacteristicStatsEvalTypeChoicePair * UserDefinedMassCharacteristicStatsEvalTypePairIn)
{UserDefinedMassCharacteristicStatsEvalTypePair = UserDefinedMassCharacteristicStatsEvalTypePairIn;}

/* ***************************************************************** */

UserDefinedMassCharacteristicStatsEvalTypeChoicePair::UserDefinedMassCharacteristicStatsEvalTypeChoicePair() {}

UserDefinedMassCharacteristicStatsEvalTypeChoicePair::UserDefinedMassCharacteristicStatsEvalTypeChoicePair(
 whichOne UserDefinedMassCharacteristicStatsEvalTypeTypeIn,
 UserDefinedMassCharacteristicStatsEvalTypeVal UserDefinedMassCharacteristicStatsEvalTypeValueIn)
{
  UserDefinedMassCharacteristicStatsEvalTypeType = UserDefinedMassCharacteristicStatsEvalTypeTypeIn;
  UserDefinedMassCharacteristicStatsEvalTypeValue = UserDefinedMassCharacteristicStatsEvalTypeValueIn;
}

UserDefinedMassCharacteristicStatsEvalTypeChoicePair::~UserDefinedMassCharacteristicStatsEvalTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (UserDefinedMassCharacteristicStatsEvalTypeType == UserDefinedMass_1132E)
    delete UserDefinedMassCharacteristicStatsEvalTypeValue.UserDefinedMass_1132;
  else if (UserDefinedMassCharacteristicStatsEvalTypeType == UserDefinedMass_1133E)
    delete UserDefinedMassCharacteristicStatsEvalTypeValue.UserDefinedMass_1133;
  else if (UserDefinedMassCharacteristicStatsEvalTypeType == MinValueStatsE)
    delete UserDefinedMassCharacteristicStatsEvalTypeValue.MinValueStats;
  else if (UserDefinedMassCharacteristicStatsEvalTypeType == UserDefinedMass_1134E)
    delete UserDefinedMassCharacteristicStatsEvalTypeValue.UserDefinedMass_1134;
  else if (UserDefinedMassCharacteristicStatsEvalTypeType == UserDefinedMass_1135E)
    delete UserDefinedMassCharacteristicStatsEvalTypeValue.UserDefinedMass_1135;
  else if (UserDefinedMassCharacteristicStatsEvalTypeType == MinDeviationStatsE)
    delete UserDefinedMassCharacteristicStatsEvalTypeValue.MinDeviationStats;
  #endif
}

void UserDefinedMassCharacteristicStatsEvalTypeChoicePair::printSelf(FILE * outFile)
{
  if (UserDefinedMassCharacteristicStatsEvalTypeType == UserDefinedMass_1132E)
    {
      UserDefinedMassCharacteristicStatsEvalTypeValue.UserDefinedMass_1132->printSelf(outFile);
    }
  else if (UserDefinedMassCharacteristicStatsEvalTypeType == UserDefinedMass_1133E)
    {
      UserDefinedMassCharacteristicStatsEvalTypeValue.UserDefinedMass_1133->printSelf(outFile);
    }
  else if (UserDefinedMassCharacteristicStatsEvalTypeType == MinValueStatsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      UserDefinedMassCharacteristicStatsEvalTypeValue.MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  else if (UserDefinedMassCharacteristicStatsEvalTypeType == UserDefinedMass_1134E)
    {
      UserDefinedMassCharacteristicStatsEvalTypeValue.UserDefinedMass_1134->printSelf(outFile);
    }
  else if (UserDefinedMassCharacteristicStatsEvalTypeType == UserDefinedMass_1135E)
    {
      UserDefinedMassCharacteristicStatsEvalTypeValue.UserDefinedMass_1135->printSelf(outFile);
    }
  else if (UserDefinedMassCharacteristicStatsEvalTypeType == MinDeviationStatsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      UserDefinedMassCharacteristicStatsEvalTypeValue.MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

/* ***************************************************************** */

/* class UserDefinedPressureCharacteristicStatsEvalType

*/

UserDefinedPressureCharacteristicStatsEvalType::UserDefinedPressureCharacteristicStatsEvalType() :
  CharacteristicStatsEvalBaseType()
{
  UserDefinedPressureCharacteristicStatsEvalTypePair = 0;
}

UserDefinedPressureCharacteristicStatsEvalType::UserDefinedPressureCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 UserDefinedPressureCharacteristicStatsEvalTypeChoicePair * UserDefinedPressureCharacteristicStatsEvalTypePairIn) :
  CharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn)
{
  UserDefinedPressureCharacteristicStatsEvalTypePair = UserDefinedPressureCharacteristicStatsEvalTypePairIn;
}

UserDefinedPressureCharacteristicStatsEvalType::~UserDefinedPressureCharacteristicStatsEvalType()
{
  #ifndef NODESTRUCT
  delete UserDefinedPressureCharacteristicStatsEvalTypePair;
  #endif
}

void UserDefinedPressureCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  UserDefinedPressureCharacteristicStatsEvalTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}
UserDefinedPressureCharacteristicStatsEvalTypeChoicePair * UserDefinedPressureCharacteristicStatsEvalType::getUserDefinedPressureCharacteristicStatsEvalTypeChoicePair()
{return UserDefinedPressureCharacteristicStatsEvalTypePair;}

void UserDefinedPressureCharacteristicStatsEvalType::setUserDefinedPressureCharacteristicStatsEvalTypeChoicePair(UserDefinedPressureCharacteristicStatsEvalTypeChoicePair * UserDefinedPressureCharacteristicStatsEvalTypePairIn)
{UserDefinedPressureCharacteristicStatsEvalTypePair = UserDefinedPressureCharacteristicStatsEvalTypePairIn;}

/* ***************************************************************** */

UserDefinedPressureCharacteristicStatsEvalTypeChoicePair::UserDefinedPressureCharacteristicStatsEvalTypeChoicePair() {}

UserDefinedPressureCharacteristicStatsEvalTypeChoicePair::UserDefinedPressureCharacteristicStatsEvalTypeChoicePair(
 whichOne UserDefinedPressureCharacteristicStatsEvalTypeTypeIn,
 UserDefinedPressureCharacteristicStatsEvalTypeVal UserDefinedPressureCharacteristicStatsEvalTypeValueIn)
{
  UserDefinedPressureCharacteristicStatsEvalTypeType = UserDefinedPressureCharacteristicStatsEvalTypeTypeIn;
  UserDefinedPressureCharacteristicStatsEvalTypeValue = UserDefinedPressureCharacteristicStatsEvalTypeValueIn;
}

UserDefinedPressureCharacteristicStatsEvalTypeChoicePair::~UserDefinedPressureCharacteristicStatsEvalTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (UserDefinedPressureCharacteristicStatsEvalTypeType == UserDefinedPres_1136E)
    delete UserDefinedPressureCharacteristicStatsEvalTypeValue.UserDefinedPres_1136;
  else if (UserDefinedPressureCharacteristicStatsEvalTypeType == UserDefinedPres_1137E)
    delete UserDefinedPressureCharacteristicStatsEvalTypeValue.UserDefinedPres_1137;
  else if (UserDefinedPressureCharacteristicStatsEvalTypeType == MinValueStatsE)
    delete UserDefinedPressureCharacteristicStatsEvalTypeValue.MinValueStats;
  else if (UserDefinedPressureCharacteristicStatsEvalTypeType == UserDefinedPres_1138E)
    delete UserDefinedPressureCharacteristicStatsEvalTypeValue.UserDefinedPres_1138;
  else if (UserDefinedPressureCharacteristicStatsEvalTypeType == UserDefinedPres_1139E)
    delete UserDefinedPressureCharacteristicStatsEvalTypeValue.UserDefinedPres_1139;
  else if (UserDefinedPressureCharacteristicStatsEvalTypeType == MinDeviationStatsE)
    delete UserDefinedPressureCharacteristicStatsEvalTypeValue.MinDeviationStats;
  #endif
}

void UserDefinedPressureCharacteristicStatsEvalTypeChoicePair::printSelf(FILE * outFile)
{
  if (UserDefinedPressureCharacteristicStatsEvalTypeType == UserDefinedPres_1136E)
    {
      UserDefinedPressureCharacteristicStatsEvalTypeValue.UserDefinedPres_1136->printSelf(outFile);
    }
  else if (UserDefinedPressureCharacteristicStatsEvalTypeType == UserDefinedPres_1137E)
    {
      UserDefinedPressureCharacteristicStatsEvalTypeValue.UserDefinedPres_1137->printSelf(outFile);
    }
  else if (UserDefinedPressureCharacteristicStatsEvalTypeType == MinValueStatsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      UserDefinedPressureCharacteristicStatsEvalTypeValue.MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  else if (UserDefinedPressureCharacteristicStatsEvalTypeType == UserDefinedPres_1138E)
    {
      UserDefinedPressureCharacteristicStatsEvalTypeValue.UserDefinedPres_1138->printSelf(outFile);
    }
  else if (UserDefinedPressureCharacteristicStatsEvalTypeType == UserDefinedPres_1139E)
    {
      UserDefinedPressureCharacteristicStatsEvalTypeValue.UserDefinedPres_1139->printSelf(outFile);
    }
  else if (UserDefinedPressureCharacteristicStatsEvalTypeType == MinDeviationStatsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      UserDefinedPressureCharacteristicStatsEvalTypeValue.MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

/* ***************************************************************** */

/* class UserDefinedSpeedCharacteristicStatsEvalType

*/

UserDefinedSpeedCharacteristicStatsEvalType::UserDefinedSpeedCharacteristicStatsEvalType() :
  CharacteristicStatsEvalBaseType()
{
  UserDefinedSpeedCharacteristicStatsEvalTypePair = 0;
}

UserDefinedSpeedCharacteristicStatsEvalType::UserDefinedSpeedCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 UserDefinedSpeedCharacteristicStatsEvalTypeChoicePair * UserDefinedSpeedCharacteristicStatsEvalTypePairIn) :
  CharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn)
{
  UserDefinedSpeedCharacteristicStatsEvalTypePair = UserDefinedSpeedCharacteristicStatsEvalTypePairIn;
}

UserDefinedSpeedCharacteristicStatsEvalType::~UserDefinedSpeedCharacteristicStatsEvalType()
{
  #ifndef NODESTRUCT
  delete UserDefinedSpeedCharacteristicStatsEvalTypePair;
  #endif
}

void UserDefinedSpeedCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  UserDefinedSpeedCharacteristicStatsEvalTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}
UserDefinedSpeedCharacteristicStatsEvalTypeChoicePair * UserDefinedSpeedCharacteristicStatsEvalType::getUserDefinedSpeedCharacteristicStatsEvalTypeChoicePair()
{return UserDefinedSpeedCharacteristicStatsEvalTypePair;}

void UserDefinedSpeedCharacteristicStatsEvalType::setUserDefinedSpeedCharacteristicStatsEvalTypeChoicePair(UserDefinedSpeedCharacteristicStatsEvalTypeChoicePair * UserDefinedSpeedCharacteristicStatsEvalTypePairIn)
{UserDefinedSpeedCharacteristicStatsEvalTypePair = UserDefinedSpeedCharacteristicStatsEvalTypePairIn;}

/* ***************************************************************** */

UserDefinedSpeedCharacteristicStatsEvalTypeChoicePair::UserDefinedSpeedCharacteristicStatsEvalTypeChoicePair() {}

UserDefinedSpeedCharacteristicStatsEvalTypeChoicePair::UserDefinedSpeedCharacteristicStatsEvalTypeChoicePair(
 whichOne UserDefinedSpeedCharacteristicStatsEvalTypeTypeIn,
 UserDefinedSpeedCharacteristicStatsEvalTypeVal UserDefinedSpeedCharacteristicStatsEvalTypeValueIn)
{
  UserDefinedSpeedCharacteristicStatsEvalTypeType = UserDefinedSpeedCharacteristicStatsEvalTypeTypeIn;
  UserDefinedSpeedCharacteristicStatsEvalTypeValue = UserDefinedSpeedCharacteristicStatsEvalTypeValueIn;
}

UserDefinedSpeedCharacteristicStatsEvalTypeChoicePair::~UserDefinedSpeedCharacteristicStatsEvalTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (UserDefinedSpeedCharacteristicStatsEvalTypeType == UserDefinedSpee_1140E)
    delete UserDefinedSpeedCharacteristicStatsEvalTypeValue.UserDefinedSpee_1140;
  else if (UserDefinedSpeedCharacteristicStatsEvalTypeType == UserDefinedSpee_1141E)
    delete UserDefinedSpeedCharacteristicStatsEvalTypeValue.UserDefinedSpee_1141;
  else if (UserDefinedSpeedCharacteristicStatsEvalTypeType == MinValueStatsE)
    delete UserDefinedSpeedCharacteristicStatsEvalTypeValue.MinValueStats;
  else if (UserDefinedSpeedCharacteristicStatsEvalTypeType == UserDefinedSpee_1142E)
    delete UserDefinedSpeedCharacteristicStatsEvalTypeValue.UserDefinedSpee_1142;
  else if (UserDefinedSpeedCharacteristicStatsEvalTypeType == UserDefinedSpee_1143E)
    delete UserDefinedSpeedCharacteristicStatsEvalTypeValue.UserDefinedSpee_1143;
  else if (UserDefinedSpeedCharacteristicStatsEvalTypeType == MinDeviationStatsE)
    delete UserDefinedSpeedCharacteristicStatsEvalTypeValue.MinDeviationStats;
  #endif
}

void UserDefinedSpeedCharacteristicStatsEvalTypeChoicePair::printSelf(FILE * outFile)
{
  if (UserDefinedSpeedCharacteristicStatsEvalTypeType == UserDefinedSpee_1140E)
    {
      UserDefinedSpeedCharacteristicStatsEvalTypeValue.UserDefinedSpee_1140->printSelf(outFile);
    }
  else if (UserDefinedSpeedCharacteristicStatsEvalTypeType == UserDefinedSpee_1141E)
    {
      UserDefinedSpeedCharacteristicStatsEvalTypeValue.UserDefinedSpee_1141->printSelf(outFile);
    }
  else if (UserDefinedSpeedCharacteristicStatsEvalTypeType == MinValueStatsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      UserDefinedSpeedCharacteristicStatsEvalTypeValue.MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  else if (UserDefinedSpeedCharacteristicStatsEvalTypeType == UserDefinedSpee_1142E)
    {
      UserDefinedSpeedCharacteristicStatsEvalTypeValue.UserDefinedSpee_1142->printSelf(outFile);
    }
  else if (UserDefinedSpeedCharacteristicStatsEvalTypeType == UserDefinedSpee_1143E)
    {
      UserDefinedSpeedCharacteristicStatsEvalTypeValue.UserDefinedSpee_1143->printSelf(outFile);
    }
  else if (UserDefinedSpeedCharacteristicStatsEvalTypeType == MinDeviationStatsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      UserDefinedSpeedCharacteristicStatsEvalTypeValue.MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

/* ***************************************************************** */

/* class UserDefinedTemperatureCharacteristicStatsEvalType

*/

UserDefinedTemperatureCharacteristicStatsEvalType::UserDefinedTemperatureCharacteristicStatsEvalType() :
  CharacteristicStatsEvalBaseType()
{
  UserDefinedTemperatureCharacteristicStatsEvalTypePair = 0;
}

UserDefinedTemperatureCharacteristicStatsEvalType::UserDefinedTemperatureCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 UserDefinedTemperatureCharacteristicStatsEvalTypeChoicePair * UserDefinedTemperatureCharacteristicStatsEvalTypePairIn) :
  CharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn)
{
  UserDefinedTemperatureCharacteristicStatsEvalTypePair = UserDefinedTemperatureCharacteristicStatsEvalTypePairIn;
}

UserDefinedTemperatureCharacteristicStatsEvalType::~UserDefinedTemperatureCharacteristicStatsEvalType()
{
  #ifndef NODESTRUCT
  delete UserDefinedTemperatureCharacteristicStatsEvalTypePair;
  #endif
}

void UserDefinedTemperatureCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  UserDefinedTemperatureCharacteristicStatsEvalTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}
UserDefinedTemperatureCharacteristicStatsEvalTypeChoicePair * UserDefinedTemperatureCharacteristicStatsEvalType::getUserDefinedTemperatureCharacteristicStatsEvalTypeChoicePair()
{return UserDefinedTemperatureCharacteristicStatsEvalTypePair;}

void UserDefinedTemperatureCharacteristicStatsEvalType::setUserDefinedTemperatureCharacteristicStatsEvalTypeChoicePair(UserDefinedTemperatureCharacteristicStatsEvalTypeChoicePair * UserDefinedTemperatureCharacteristicStatsEvalTypePairIn)
{UserDefinedTemperatureCharacteristicStatsEvalTypePair = UserDefinedTemperatureCharacteristicStatsEvalTypePairIn;}

/* ***************************************************************** */

UserDefinedTemperatureCharacteristicStatsEvalTypeChoicePair::UserDefinedTemperatureCharacteristicStatsEvalTypeChoicePair() {}

UserDefinedTemperatureCharacteristicStatsEvalTypeChoicePair::UserDefinedTemperatureCharacteristicStatsEvalTypeChoicePair(
 whichOne UserDefinedTemperatureCharacteristicStatsEvalTypeTypeIn,
 UserDefinedTemperatureCharacteristicStatsEvalTypeVal UserDefinedTemperatureCharacteristicStatsEvalTypeValueIn)
{
  UserDefinedTemperatureCharacteristicStatsEvalTypeType = UserDefinedTemperatureCharacteristicStatsEvalTypeTypeIn;
  UserDefinedTemperatureCharacteristicStatsEvalTypeValue = UserDefinedTemperatureCharacteristicStatsEvalTypeValueIn;
}

UserDefinedTemperatureCharacteristicStatsEvalTypeChoicePair::~UserDefinedTemperatureCharacteristicStatsEvalTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (UserDefinedTemperatureCharacteristicStatsEvalTypeType == UserDefinedTemp_1144E)
    delete UserDefinedTemperatureCharacteristicStatsEvalTypeValue.UserDefinedTemp_1144;
  else if (UserDefinedTemperatureCharacteristicStatsEvalTypeType == UserDefinedTemp_1145E)
    delete UserDefinedTemperatureCharacteristicStatsEvalTypeValue.UserDefinedTemp_1145;
  else if (UserDefinedTemperatureCharacteristicStatsEvalTypeType == MinValueStatsE)
    delete UserDefinedTemperatureCharacteristicStatsEvalTypeValue.MinValueStats;
  else if (UserDefinedTemperatureCharacteristicStatsEvalTypeType == UserDefinedTemp_1146E)
    delete UserDefinedTemperatureCharacteristicStatsEvalTypeValue.UserDefinedTemp_1146;
  else if (UserDefinedTemperatureCharacteristicStatsEvalTypeType == UserDefinedTemp_1147E)
    delete UserDefinedTemperatureCharacteristicStatsEvalTypeValue.UserDefinedTemp_1147;
  else if (UserDefinedTemperatureCharacteristicStatsEvalTypeType == MinDeviationStatsE)
    delete UserDefinedTemperatureCharacteristicStatsEvalTypeValue.MinDeviationStats;
  #endif
}

void UserDefinedTemperatureCharacteristicStatsEvalTypeChoicePair::printSelf(FILE * outFile)
{
  if (UserDefinedTemperatureCharacteristicStatsEvalTypeType == UserDefinedTemp_1144E)
    {
      UserDefinedTemperatureCharacteristicStatsEvalTypeValue.UserDefinedTemp_1144->printSelf(outFile);
    }
  else if (UserDefinedTemperatureCharacteristicStatsEvalTypeType == UserDefinedTemp_1145E)
    {
      UserDefinedTemperatureCharacteristicStatsEvalTypeValue.UserDefinedTemp_1145->printSelf(outFile);
    }
  else if (UserDefinedTemperatureCharacteristicStatsEvalTypeType == MinValueStatsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      UserDefinedTemperatureCharacteristicStatsEvalTypeValue.MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  else if (UserDefinedTemperatureCharacteristicStatsEvalTypeType == UserDefinedTemp_1146E)
    {
      UserDefinedTemperatureCharacteristicStatsEvalTypeValue.UserDefinedTemp_1146->printSelf(outFile);
    }
  else if (UserDefinedTemperatureCharacteristicStatsEvalTypeType == UserDefinedTemp_1147E)
    {
      UserDefinedTemperatureCharacteristicStatsEvalTypeValue.UserDefinedTemp_1147->printSelf(outFile);
    }
  else if (UserDefinedTemperatureCharacteristicStatsEvalTypeType == MinDeviationStatsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      UserDefinedTemperatureCharacteristicStatsEvalTypeValue.MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

/* ***************************************************************** */

/* class UserDefinedTimeCharacteristicStatsEvalType

*/

UserDefinedTimeCharacteristicStatsEvalType::UserDefinedTimeCharacteristicStatsEvalType() :
  CharacteristicStatsEvalBaseType()
{
  UserDefinedTimeCharacteristicStatsEvalTypePair = 0;
}

UserDefinedTimeCharacteristicStatsEvalType::UserDefinedTimeCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 UserDefinedTimeCharacteristicStatsEvalTypeChoicePair * UserDefinedTimeCharacteristicStatsEvalTypePairIn) :
  CharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn)
{
  UserDefinedTimeCharacteristicStatsEvalTypePair = UserDefinedTimeCharacteristicStatsEvalTypePairIn;
}

UserDefinedTimeCharacteristicStatsEvalType::~UserDefinedTimeCharacteristicStatsEvalType()
{
  #ifndef NODESTRUCT
  delete UserDefinedTimeCharacteristicStatsEvalTypePair;
  #endif
}

void UserDefinedTimeCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  UserDefinedTimeCharacteristicStatsEvalTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}
UserDefinedTimeCharacteristicStatsEvalTypeChoicePair * UserDefinedTimeCharacteristicStatsEvalType::getUserDefinedTimeCharacteristicStatsEvalTypeChoicePair()
{return UserDefinedTimeCharacteristicStatsEvalTypePair;}

void UserDefinedTimeCharacteristicStatsEvalType::setUserDefinedTimeCharacteristicStatsEvalTypeChoicePair(UserDefinedTimeCharacteristicStatsEvalTypeChoicePair * UserDefinedTimeCharacteristicStatsEvalTypePairIn)
{UserDefinedTimeCharacteristicStatsEvalTypePair = UserDefinedTimeCharacteristicStatsEvalTypePairIn;}

/* ***************************************************************** */

UserDefinedTimeCharacteristicStatsEvalTypeChoicePair::UserDefinedTimeCharacteristicStatsEvalTypeChoicePair() {}

UserDefinedTimeCharacteristicStatsEvalTypeChoicePair::UserDefinedTimeCharacteristicStatsEvalTypeChoicePair(
 whichOne UserDefinedTimeCharacteristicStatsEvalTypeTypeIn,
 UserDefinedTimeCharacteristicStatsEvalTypeVal UserDefinedTimeCharacteristicStatsEvalTypeValueIn)
{
  UserDefinedTimeCharacteristicStatsEvalTypeType = UserDefinedTimeCharacteristicStatsEvalTypeTypeIn;
  UserDefinedTimeCharacteristicStatsEvalTypeValue = UserDefinedTimeCharacteristicStatsEvalTypeValueIn;
}

UserDefinedTimeCharacteristicStatsEvalTypeChoicePair::~UserDefinedTimeCharacteristicStatsEvalTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (UserDefinedTimeCharacteristicStatsEvalTypeType == UserDefinedTime_1148E)
    delete UserDefinedTimeCharacteristicStatsEvalTypeValue.UserDefinedTime_1148;
  else if (UserDefinedTimeCharacteristicStatsEvalTypeType == UserDefinedTime_1149E)
    delete UserDefinedTimeCharacteristicStatsEvalTypeValue.UserDefinedTime_1149;
  else if (UserDefinedTimeCharacteristicStatsEvalTypeType == MinValueStatsE)
    delete UserDefinedTimeCharacteristicStatsEvalTypeValue.MinValueStats;
  else if (UserDefinedTimeCharacteristicStatsEvalTypeType == UserDefinedTime_1150E)
    delete UserDefinedTimeCharacteristicStatsEvalTypeValue.UserDefinedTime_1150;
  else if (UserDefinedTimeCharacteristicStatsEvalTypeType == UserDefinedTime_1151E)
    delete UserDefinedTimeCharacteristicStatsEvalTypeValue.UserDefinedTime_1151;
  else if (UserDefinedTimeCharacteristicStatsEvalTypeType == MinDeviationStatsE)
    delete UserDefinedTimeCharacteristicStatsEvalTypeValue.MinDeviationStats;
  #endif
}

void UserDefinedTimeCharacteristicStatsEvalTypeChoicePair::printSelf(FILE * outFile)
{
  if (UserDefinedTimeCharacteristicStatsEvalTypeType == UserDefinedTime_1148E)
    {
      UserDefinedTimeCharacteristicStatsEvalTypeValue.UserDefinedTime_1148->printSelf(outFile);
    }
  else if (UserDefinedTimeCharacteristicStatsEvalTypeType == UserDefinedTime_1149E)
    {
      UserDefinedTimeCharacteristicStatsEvalTypeValue.UserDefinedTime_1149->printSelf(outFile);
    }
  else if (UserDefinedTimeCharacteristicStatsEvalTypeType == MinValueStatsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      UserDefinedTimeCharacteristicStatsEvalTypeValue.MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  else if (UserDefinedTimeCharacteristicStatsEvalTypeType == UserDefinedTime_1150E)
    {
      UserDefinedTimeCharacteristicStatsEvalTypeValue.UserDefinedTime_1150->printSelf(outFile);
    }
  else if (UserDefinedTimeCharacteristicStatsEvalTypeType == UserDefinedTime_1151E)
    {
      UserDefinedTimeCharacteristicStatsEvalTypeValue.UserDefinedTime_1151->printSelf(outFile);
    }
  else if (UserDefinedTimeCharacteristicStatsEvalTypeType == MinDeviationStatsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      UserDefinedTimeCharacteristicStatsEvalTypeValue.MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

/* ***************************************************************** */

/* class UserDefinedUnitCharacteristicStatsEvalType

*/

UserDefinedUnitCharacteristicStatsEvalType::UserDefinedUnitCharacteristicStatsEvalType() :
  CharacteristicStatsEvalBaseType()
{
  UserDefinedUnitCharacteristicStatsEvalTypePair = 0;
}

UserDefinedUnitCharacteristicStatsEvalType::UserDefinedUnitCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 UserDefinedUnitCharacteristicStatsEvalTypeChoicePair * UserDefinedUnitCharacteristicStatsEvalTypePairIn) :
  CharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn)
{
  UserDefinedUnitCharacteristicStatsEvalTypePair = UserDefinedUnitCharacteristicStatsEvalTypePairIn;
}

UserDefinedUnitCharacteristicStatsEvalType::~UserDefinedUnitCharacteristicStatsEvalType()
{
  #ifndef NODESTRUCT
  delete UserDefinedUnitCharacteristicStatsEvalTypePair;
  #endif
}

void UserDefinedUnitCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  UserDefinedUnitCharacteristicStatsEvalTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}
UserDefinedUnitCharacteristicStatsEvalTypeChoicePair * UserDefinedUnitCharacteristicStatsEvalType::getUserDefinedUnitCharacteristicStatsEvalTypeChoicePair()
{return UserDefinedUnitCharacteristicStatsEvalTypePair;}

void UserDefinedUnitCharacteristicStatsEvalType::setUserDefinedUnitCharacteristicStatsEvalTypeChoicePair(UserDefinedUnitCharacteristicStatsEvalTypeChoicePair * UserDefinedUnitCharacteristicStatsEvalTypePairIn)
{UserDefinedUnitCharacteristicStatsEvalTypePair = UserDefinedUnitCharacteristicStatsEvalTypePairIn;}

/* ***************************************************************** */

UserDefinedUnitCharacteristicStatsEvalTypeChoicePair::UserDefinedUnitCharacteristicStatsEvalTypeChoicePair() {}

UserDefinedUnitCharacteristicStatsEvalTypeChoicePair::UserDefinedUnitCharacteristicStatsEvalTypeChoicePair(
 whichOne UserDefinedUnitCharacteristicStatsEvalTypeTypeIn,
 UserDefinedUnitCharacteristicStatsEvalTypeVal UserDefinedUnitCharacteristicStatsEvalTypeValueIn)
{
  UserDefinedUnitCharacteristicStatsEvalTypeType = UserDefinedUnitCharacteristicStatsEvalTypeTypeIn;
  UserDefinedUnitCharacteristicStatsEvalTypeValue = UserDefinedUnitCharacteristicStatsEvalTypeValueIn;
}

UserDefinedUnitCharacteristicStatsEvalTypeChoicePair::~UserDefinedUnitCharacteristicStatsEvalTypeChoicePair()
{
  #ifndef NODESTRUCT
  if (UserDefinedUnitCharacteristicStatsEvalTypeType == UserDefinedUnit_1152E)
    delete UserDefinedUnitCharacteristicStatsEvalTypeValue.UserDefinedUnit_1152;
  else if (UserDefinedUnitCharacteristicStatsEvalTypeType == UserDefinedUnit_1153E)
    delete UserDefinedUnitCharacteristicStatsEvalTypeValue.UserDefinedUnit_1153;
  else if (UserDefinedUnitCharacteristicStatsEvalTypeType == MinValueStatsE)
    delete UserDefinedUnitCharacteristicStatsEvalTypeValue.MinValueStats;
  else if (UserDefinedUnitCharacteristicStatsEvalTypeType == UserDefinedUnit_1154E)
    delete UserDefinedUnitCharacteristicStatsEvalTypeValue.UserDefinedUnit_1154;
  else if (UserDefinedUnitCharacteristicStatsEvalTypeType == UserDefinedUnit_1155E)
    delete UserDefinedUnitCharacteristicStatsEvalTypeValue.UserDefinedUnit_1155;
  else if (UserDefinedUnitCharacteristicStatsEvalTypeType == MinDeviationStatsE)
    delete UserDefinedUnitCharacteristicStatsEvalTypeValue.MinDeviationStats;
  #endif
}

void UserDefinedUnitCharacteristicStatsEvalTypeChoicePair::printSelf(FILE * outFile)
{
  if (UserDefinedUnitCharacteristicStatsEvalTypeType == UserDefinedUnit_1152E)
    {
      UserDefinedUnitCharacteristicStatsEvalTypeValue.UserDefinedUnit_1152->printSelf(outFile);
    }
  else if (UserDefinedUnitCharacteristicStatsEvalTypeType == UserDefinedUnit_1153E)
    {
      UserDefinedUnitCharacteristicStatsEvalTypeValue.UserDefinedUnit_1153->printSelf(outFile);
    }
  else if (UserDefinedUnitCharacteristicStatsEvalTypeType == MinValueStatsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      UserDefinedUnitCharacteristicStatsEvalTypeValue.MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
  else if (UserDefinedUnitCharacteristicStatsEvalTypeType == UserDefinedUnit_1154E)
    {
      UserDefinedUnitCharacteristicStatsEvalTypeValue.UserDefinedUnit_1154->printSelf(outFile);
    }
  else if (UserDefinedUnitCharacteristicStatsEvalTypeType == UserDefinedUnit_1155E)
    {
      UserDefinedUnitCharacteristicStatsEvalTypeValue.UserDefinedUnit_1155->printSelf(outFile);
    }
  else if (UserDefinedUnitCharacteristicStatsEvalTypeType == MinDeviationStatsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      UserDefinedUnitCharacteristicStatsEvalTypeValue.MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

/* ***************************************************************** */

/* class WeldBevelCharacteristicStatsEvalType

*/

WeldBevelCharacteristicStatsEvalType::WeldBevelCharacteristicStatsEvalType() :
  WeldCharacteristicStatsEvalBaseType() {}

WeldBevelCharacteristicStatsEvalType::WeldBevelCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsPassFailType * WeldStatsIn) :
  WeldCharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    WeldStatsIn)
{}

WeldBevelCharacteristicStatsEvalType::~WeldBevelCharacteristicStatsEvalType() {}

void WeldBevelCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (WeldStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldStats");
      WeldStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class WeldCharacteristicStatsEvalBaseType

*/

WeldCharacteristicStatsEvalBaseType::WeldCharacteristicStatsEvalBaseType() :
  CharacteristicStatsEvalBaseType()
{
  WeldStats = 0;
}

WeldCharacteristicStatsEvalBaseType::WeldCharacteristicStatsEvalBaseType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsPassFailType * WeldStatsIn) :
  CharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn)
{
  WeldStats = WeldStatsIn;
}

WeldCharacteristicStatsEvalBaseType::~WeldCharacteristicStatsEvalBaseType()
{
  #ifndef NODESTRUCT
  delete WeldStats;
  #endif
}

void WeldCharacteristicStatsEvalBaseType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (WeldStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldStats");
      WeldStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

StatsPassFailType * WeldCharacteristicStatsEvalBaseType::getWeldStats()
{return WeldStats;}

void WeldCharacteristicStatsEvalBaseType::setWeldStats(StatsPassFailType * WeldStatsIn)
{WeldStats = WeldStatsIn;}

/* ***************************************************************** */

/* class WeldCompoundCharacteristicStatsEvalType

*/

WeldCompoundCharacteristicStatsEvalType::WeldCompoundCharacteristicStatsEvalType() :
  WeldCharacteristicStatsEvalBaseType() {}

WeldCompoundCharacteristicStatsEvalType::WeldCompoundCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsPassFailType * WeldStatsIn) :
  WeldCharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    WeldStatsIn)
{}

WeldCompoundCharacteristicStatsEvalType::~WeldCompoundCharacteristicStatsEvalType() {}

void WeldCompoundCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (WeldStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldStats");
      WeldStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class WeldEdgeCharacteristicStatsEvalType

*/

WeldEdgeCharacteristicStatsEvalType::WeldEdgeCharacteristicStatsEvalType() :
  WeldCharacteristicStatsEvalBaseType() {}

WeldEdgeCharacteristicStatsEvalType::WeldEdgeCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsPassFailType * WeldStatsIn) :
  WeldCharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    WeldStatsIn)
{}

WeldEdgeCharacteristicStatsEvalType::~WeldEdgeCharacteristicStatsEvalType() {}

void WeldEdgeCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (WeldStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldStats");
      WeldStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class WeldFilletCharacteristicStatsEvalType

*/

WeldFilletCharacteristicStatsEvalType::WeldFilletCharacteristicStatsEvalType() :
  WeldCharacteristicStatsEvalBaseType() {}

WeldFilletCharacteristicStatsEvalType::WeldFilletCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsPassFailType * WeldStatsIn) :
  WeldCharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    WeldStatsIn)
{}

WeldFilletCharacteristicStatsEvalType::~WeldFilletCharacteristicStatsEvalType() {}

void WeldFilletCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (WeldStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldStats");
      WeldStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class WeldFlareBevelCharacteristicStatsEvalType

*/

WeldFlareBevelCharacteristicStatsEvalType::WeldFlareBevelCharacteristicStatsEvalType() :
  WeldCharacteristicStatsEvalBaseType() {}

WeldFlareBevelCharacteristicStatsEvalType::WeldFlareBevelCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsPassFailType * WeldStatsIn) :
  WeldCharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    WeldStatsIn)
{}

WeldFlareBevelCharacteristicStatsEvalType::~WeldFlareBevelCharacteristicStatsEvalType() {}

void WeldFlareBevelCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (WeldStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldStats");
      WeldStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class WeldFlareVCharacteristicStatsEvalType

*/

WeldFlareVCharacteristicStatsEvalType::WeldFlareVCharacteristicStatsEvalType() :
  WeldCharacteristicStatsEvalBaseType() {}

WeldFlareVCharacteristicStatsEvalType::WeldFlareVCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsPassFailType * WeldStatsIn) :
  WeldCharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    WeldStatsIn)
{}

WeldFlareVCharacteristicStatsEvalType::~WeldFlareVCharacteristicStatsEvalType() {}

void WeldFlareVCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (WeldStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldStats");
      WeldStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class WeldJCharacteristicStatsEvalType

*/

WeldJCharacteristicStatsEvalType::WeldJCharacteristicStatsEvalType() :
  WeldCharacteristicStatsEvalBaseType() {}

WeldJCharacteristicStatsEvalType::WeldJCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsPassFailType * WeldStatsIn) :
  WeldCharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    WeldStatsIn)
{}

WeldJCharacteristicStatsEvalType::~WeldJCharacteristicStatsEvalType() {}

void WeldJCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (WeldStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldStats");
      WeldStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class WeldPlugCharacteristicStatsEvalType

*/

WeldPlugCharacteristicStatsEvalType::WeldPlugCharacteristicStatsEvalType() :
  WeldCharacteristicStatsEvalBaseType() {}

WeldPlugCharacteristicStatsEvalType::WeldPlugCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsPassFailType * WeldStatsIn) :
  WeldCharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    WeldStatsIn)
{}

WeldPlugCharacteristicStatsEvalType::~WeldPlugCharacteristicStatsEvalType() {}

void WeldPlugCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (WeldStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldStats");
      WeldStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class WeldScarfCharacteristicStatsEvalType

*/

WeldScarfCharacteristicStatsEvalType::WeldScarfCharacteristicStatsEvalType() :
  WeldCharacteristicStatsEvalBaseType() {}

WeldScarfCharacteristicStatsEvalType::WeldScarfCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsPassFailType * WeldStatsIn) :
  WeldCharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    WeldStatsIn)
{}

WeldScarfCharacteristicStatsEvalType::~WeldScarfCharacteristicStatsEvalType() {}

void WeldScarfCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (WeldStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldStats");
      WeldStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class WeldSeamCharacteristicStatsEvalType

*/

WeldSeamCharacteristicStatsEvalType::WeldSeamCharacteristicStatsEvalType() :
  WeldCharacteristicStatsEvalBaseType() {}

WeldSeamCharacteristicStatsEvalType::WeldSeamCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsPassFailType * WeldStatsIn) :
  WeldCharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    WeldStatsIn)
{}

WeldSeamCharacteristicStatsEvalType::~WeldSeamCharacteristicStatsEvalType() {}

void WeldSeamCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (WeldStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldStats");
      WeldStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class WeldSlotCharacteristicStatsEvalType

*/

WeldSlotCharacteristicStatsEvalType::WeldSlotCharacteristicStatsEvalType() :
  WeldCharacteristicStatsEvalBaseType() {}

WeldSlotCharacteristicStatsEvalType::WeldSlotCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsPassFailType * WeldStatsIn) :
  WeldCharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    WeldStatsIn)
{}

WeldSlotCharacteristicStatsEvalType::~WeldSlotCharacteristicStatsEvalType() {}

void WeldSlotCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (WeldStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldStats");
      WeldStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class WeldSpotCharacteristicStatsEvalType

*/

WeldSpotCharacteristicStatsEvalType::WeldSpotCharacteristicStatsEvalType() :
  WeldCharacteristicStatsEvalBaseType() {}

WeldSpotCharacteristicStatsEvalType::WeldSpotCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsPassFailType * WeldStatsIn) :
  WeldCharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    WeldStatsIn)
{}

WeldSpotCharacteristicStatsEvalType::~WeldSpotCharacteristicStatsEvalType() {}

void WeldSpotCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (WeldStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldStats");
      WeldStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class WeldSquareCharacteristicStatsEvalType

*/

WeldSquareCharacteristicStatsEvalType::WeldSquareCharacteristicStatsEvalType() :
  WeldCharacteristicStatsEvalBaseType() {}

WeldSquareCharacteristicStatsEvalType::WeldSquareCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsPassFailType * WeldStatsIn) :
  WeldCharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    WeldStatsIn)
{}

WeldSquareCharacteristicStatsEvalType::~WeldSquareCharacteristicStatsEvalType() {}

void WeldSquareCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (WeldStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldStats");
      WeldStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class WeldStudCharacteristicStatsEvalType

*/

WeldStudCharacteristicStatsEvalType::WeldStudCharacteristicStatsEvalType() :
  WeldCharacteristicStatsEvalBaseType() {}

WeldStudCharacteristicStatsEvalType::WeldStudCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsPassFailType * WeldStatsIn) :
  WeldCharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    WeldStatsIn)
{}

WeldStudCharacteristicStatsEvalType::~WeldStudCharacteristicStatsEvalType() {}

void WeldStudCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (WeldStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldStats");
      WeldStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class WeldSurfacingCharacteristicStatsEvalType

*/

WeldSurfacingCharacteristicStatsEvalType::WeldSurfacingCharacteristicStatsEvalType() :
  WeldCharacteristicStatsEvalBaseType() {}

WeldSurfacingCharacteristicStatsEvalType::WeldSurfacingCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsPassFailType * WeldStatsIn) :
  WeldCharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    WeldStatsIn)
{}

WeldSurfacingCharacteristicStatsEvalType::~WeldSurfacingCharacteristicStatsEvalType() {}

void WeldSurfacingCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (WeldStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldStats");
      WeldStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class WeldUCharacteristicStatsEvalType

*/

WeldUCharacteristicStatsEvalType::WeldUCharacteristicStatsEvalType() :
  WeldCharacteristicStatsEvalBaseType() {}

WeldUCharacteristicStatsEvalType::WeldUCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsPassFailType * WeldStatsIn) :
  WeldCharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    WeldStatsIn)
{}

WeldUCharacteristicStatsEvalType::~WeldUCharacteristicStatsEvalType() {}

void WeldUCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (WeldStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldStats");
      WeldStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class WeldVCharacteristicStatsEvalType

*/

WeldVCharacteristicStatsEvalType::WeldVCharacteristicStatsEvalType() :
  WeldCharacteristicStatsEvalBaseType() {}

WeldVCharacteristicStatsEvalType::WeldVCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 StatsPassFailType * WeldStatsIn) :
  WeldCharacteristicStatsEvalBaseType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    WeldStatsIn)
{}

WeldVCharacteristicStatsEvalType::~WeldVCharacteristicStatsEvalType() {}

void WeldVCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  if (WeldStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<WeldStats");
      WeldStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</WeldStats>\n");
    }
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class WidthCharacteristicStatsEvalType

*/

WidthCharacteristicStatsEvalType::WidthCharacteristicStatsEvalType() :
  LinearCharacteristicStatsEvalType() {}

WidthCharacteristicStatsEvalType::WidthCharacteristicStatsEvalType(
 AttributesType * AttributesIn,
 CharacteristicS_1105_Type * CharacteristicS_1105In,
 CharacteristicS_1106_Type * CharacteristicS_1106In,
 StatsEvalStatusType * StatusIn,
 StudyIssuesType * StudyIssuesIn,
 DistributionTransformationType * DistributionTransformationIn,
 LinearCharacteristicStatsEvalTypeChoicePair * LinearCharacteristicStatsEvalTypePairIn) :
  LinearCharacteristicStatsEvalType(
    AttributesIn,
    CharacteristicS_1105In,
    CharacteristicS_1106In,
    StatusIn,
    StudyIssuesIn,
    DistributionTransformationIn,
    LinearCharacteristicStatsEvalTypePairIn)
{}

WidthCharacteristicStatsEvalType::~WidthCharacteristicStatsEvalType() {}

void WidthCharacteristicStatsEvalType::printSelf(FILE * outFile)
{
  fprintf(outFile, ">\n");
  doSpaces(+INDENT, outFile);
  if (Attributes)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Attributes");
      Attributes->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Attributes>\n");
    }
  if (CharacteristicS_1105)
    {
  CharacteristicS_1105->printSelf(outFile);
    }
  if (CharacteristicS_1106)
    {
  CharacteristicS_1106->printSelf(outFile);
    }
  doSpaces(0, outFile);
  fprintf(outFile, "<Status");
  Status->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</Status>\n");
  if (StudyIssues)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StudyIssues");
      StudyIssues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</StudyIssues>\n");
    }
  if (DistributionTransformation)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<DistributionTransformation");
      DistributionTransformation->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</DistributionTransformation>\n");
    }
  LinearCharacteristicStatsEvalTypePair->printSelf(outFile);
  doSpaces(-INDENT, outFile);
}

/* ***************************************************************** */

/* class AngularCharacte_1100_Type

*/

AngularCharacte_1100_Type::AngularCharacte_1100_Type()
{
  ValueStats = 0;
  MaxValueStats = 0;
  MinValueStats = 0;
}

AngularCharacte_1100_Type::AngularCharacte_1100_Type(
 StatsWithTolAngularType * ValueStatsIn,
 StatsAngularType * MaxValueStatsIn,
 StatsAngularType * MinValueStatsIn)
{
  ValueStats = ValueStatsIn;
  MaxValueStats = MaxValueStatsIn;
  MinValueStats = MinValueStatsIn;
}

AngularCharacte_1100_Type::~AngularCharacte_1100_Type()
{
  #ifndef NODESTRUCT
  delete ValueStats;
  delete MaxValueStats;
  delete MinValueStats;
  #endif
}

void AngularCharacte_1100_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<ValueStats");
  ValueStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ValueStats>\n");
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
}

StatsWithTolAngularType * AngularCharacte_1100_Type::getValueStats()
{return ValueStats;}

void AngularCharacte_1100_Type::setValueStats(StatsWithTolAngularType * ValueStatsIn)
{ValueStats = ValueStatsIn;}

StatsAngularType * AngularCharacte_1100_Type::getMaxValueStats()
{return MaxValueStats;}

void AngularCharacte_1100_Type::setMaxValueStats(StatsAngularType * MaxValueStatsIn)
{MaxValueStats = MaxValueStatsIn;}

StatsAngularType * AngularCharacte_1100_Type::getMinValueStats()
{return MinValueStats;}

void AngularCharacte_1100_Type::setMinValueStats(StatsAngularType * MinValueStatsIn)
{MinValueStats = MinValueStatsIn;}

/* ***************************************************************** */

/* class AngularCharacte_1101_Type

*/

AngularCharacte_1101_Type::AngularCharacte_1101_Type()
{
  MaxValueStats = 0;
  MinValueStats = 0;
}

AngularCharacte_1101_Type::AngularCharacte_1101_Type(
 StatsAngularType * MaxValueStatsIn,
 StatsAngularType * MinValueStatsIn)
{
  MaxValueStats = MaxValueStatsIn;
  MinValueStats = MinValueStatsIn;
}

AngularCharacte_1101_Type::~AngularCharacte_1101_Type()
{
  #ifndef NODESTRUCT
  delete MaxValueStats;
  delete MinValueStats;
  #endif
}

void AngularCharacte_1101_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxValueStats");
  MaxValueStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</MaxValueStats>\n");
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
}

StatsAngularType * AngularCharacte_1101_Type::getMaxValueStats()
{return MaxValueStats;}

void AngularCharacte_1101_Type::setMaxValueStats(StatsAngularType * MaxValueStatsIn)
{MaxValueStats = MaxValueStatsIn;}

StatsAngularType * AngularCharacte_1101_Type::getMinValueStats()
{return MinValueStats;}

void AngularCharacte_1101_Type::setMinValueStats(StatsAngularType * MinValueStatsIn)
{MinValueStats = MinValueStatsIn;}

/* ***************************************************************** */

/* class AngularCharacte_1102_Type

*/

AngularCharacte_1102_Type::AngularCharacte_1102_Type()
{
  DeviationStats = 0;
  MaxDeviationStats = 0;
  MinDeviationStats = 0;
}

AngularCharacte_1102_Type::AngularCharacte_1102_Type(
 StatsWithTolAngularType * DeviationStatsIn,
 StatsAngularType * MaxDeviationStatsIn,
 StatsAngularType * MinDeviationStatsIn)
{
  DeviationStats = DeviationStatsIn;
  MaxDeviationStats = MaxDeviationStatsIn;
  MinDeviationStats = MinDeviationStatsIn;
}

AngularCharacte_1102_Type::~AngularCharacte_1102_Type()
{
  #ifndef NODESTRUCT
  delete DeviationStats;
  delete MaxDeviationStats;
  delete MinDeviationStats;
  #endif
}

void AngularCharacte_1102_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<DeviationStats");
  DeviationStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeviationStats>\n");
  if (MaxDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxDeviationStats");
      MaxDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxDeviationStats>\n");
    }
  if (MinDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

StatsWithTolAngularType * AngularCharacte_1102_Type::getDeviationStats()
{return DeviationStats;}

void AngularCharacte_1102_Type::setDeviationStats(StatsWithTolAngularType * DeviationStatsIn)
{DeviationStats = DeviationStatsIn;}

StatsAngularType * AngularCharacte_1102_Type::getMaxDeviationStats()
{return MaxDeviationStats;}

void AngularCharacte_1102_Type::setMaxDeviationStats(StatsAngularType * MaxDeviationStatsIn)
{MaxDeviationStats = MaxDeviationStatsIn;}

StatsAngularType * AngularCharacte_1102_Type::getMinDeviationStats()
{return MinDeviationStats;}

void AngularCharacte_1102_Type::setMinDeviationStats(StatsAngularType * MinDeviationStatsIn)
{MinDeviationStats = MinDeviationStatsIn;}

/* ***************************************************************** */

/* class AngularCharacte_1103_Type

*/

AngularCharacte_1103_Type::AngularCharacte_1103_Type()
{
  MaxDeviationStats = 0;
  MinDeviationStats = 0;
}

AngularCharacte_1103_Type::AngularCharacte_1103_Type(
 StatsAngularType * MaxDeviationStatsIn,
 StatsAngularType * MinDeviationStatsIn)
{
  MaxDeviationStats = MaxDeviationStatsIn;
  MinDeviationStats = MinDeviationStatsIn;
}

AngularCharacte_1103_Type::~AngularCharacte_1103_Type()
{
  #ifndef NODESTRUCT
  delete MaxDeviationStats;
  delete MinDeviationStats;
  #endif
}

void AngularCharacte_1103_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxDeviationStats");
  MaxDeviationStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</MaxDeviationStats>\n");
  if (MinDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

StatsAngularType * AngularCharacte_1103_Type::getMaxDeviationStats()
{return MaxDeviationStats;}

void AngularCharacte_1103_Type::setMaxDeviationStats(StatsAngularType * MaxDeviationStatsIn)
{MaxDeviationStats = MaxDeviationStatsIn;}

StatsAngularType * AngularCharacte_1103_Type::getMinDeviationStats()
{return MinDeviationStats;}

void AngularCharacte_1103_Type::setMinDeviationStats(StatsAngularType * MinDeviationStatsIn)
{MinDeviationStats = MinDeviationStatsIn;}

/* ***************************************************************** */

/* class AssignableCause_1104_Type

*/

AssignableCause_1104_Type::AssignableCause_1104_Type()
{
  AssignableCause_1104_TypePair = 0;
}

AssignableCause_1104_Type::AssignableCause_1104_Type(
 AssignableCause_1104_TypeChoicePair * AssignableCause_1104_TypePairIn)
{
  AssignableCause_1104_TypePair = AssignableCause_1104_TypePairIn;
}

AssignableCause_1104_Type::~AssignableCause_1104_Type()
{
  #ifndef NODESTRUCT
  delete AssignableCause_1104_TypePair;
  #endif
}

void AssignableCause_1104_Type::printSelf(FILE * outFile)
{
  AssignableCause_1104_TypePair->printSelf(outFile);
}

AssignableCause_1104_TypeChoicePair * AssignableCause_1104_Type::getAssignableCause_1104_TypePair()
{return AssignableCause_1104_TypePair;}

void AssignableCause_1104_Type::setAssignableCause_1104_TypePair(AssignableCause_1104_TypeChoicePair * AssignableCause_1104_TypePairIn)
{AssignableCause_1104_TypePair = AssignableCause_1104_TypePairIn;}
AssignableCause_1104_TypeChoicePair::AssignableCause_1104_TypeChoicePair() {}

AssignableCause_1104_TypeChoicePair::AssignableCause_1104_TypeChoicePair(
 whichOne AssignableCause_1104_TypeTypeIn,
 AssignableCause_1104_TypeVal AssignableCause_1104_TypeValueIn)
{
  AssignableCause_1104_TypeType = AssignableCause_1104_TypeTypeIn;
  AssignableCause_1104_TypeValue = AssignableCause_1104_TypeValueIn;
}

AssignableCause_1104_TypeChoicePair::~AssignableCause_1104_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (AssignableCause_1104_TypeType == DescriptionE)
    delete AssignableCause_1104_TypeValue.Description;
  else if (AssignableCause_1104_TypeType == AssignableCauseEnumE)
    delete AssignableCause_1104_TypeValue.AssignableCauseEnum;
  #endif
}

void AssignableCause_1104_TypeChoicePair::printSelf(FILE * outFile)
{
  if (AssignableCause_1104_TypeType == DescriptionE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Description");
      AssignableCause_1104_TypeValue.Description->printSelf(outFile);
      fprintf(outFile, "</Description>\n");
    }
  else if (AssignableCause_1104_TypeType == AssignableCauseEnumE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AssignableCauseEnum");
      AssignableCause_1104_TypeValue.AssignableCauseEnum->printSelf(outFile);
      fprintf(outFile, "</AssignableCauseEnum>\n");
    }
}

/* ***************************************************************** */

/* class CharacteristicS_1105_Type

*/

CharacteristicS_1105_Type::CharacteristicS_1105_Type()
{
  CharacteristicS_1105_TypePair = 0;
}

CharacteristicS_1105_Type::CharacteristicS_1105_Type(
 CharacteristicS_1105_TypeChoicePair * CharacteristicS_1105_TypePairIn)
{
  CharacteristicS_1105_TypePair = CharacteristicS_1105_TypePairIn;
}

CharacteristicS_1105_Type::~CharacteristicS_1105_Type()
{
  #ifndef NODESTRUCT
  delete CharacteristicS_1105_TypePair;
  #endif
}

void CharacteristicS_1105_Type::printSelf(FILE * outFile)
{
  if (CharacteristicS_1105_TypePair)
    {
      CharacteristicS_1105_TypePair->printSelf(outFile);
    }
}

CharacteristicS_1105_TypeChoicePair * CharacteristicS_1105_Type::getCharacteristicS_1105_TypePair()
{return CharacteristicS_1105_TypePair;}

void CharacteristicS_1105_Type::setCharacteristicS_1105_TypePair(CharacteristicS_1105_TypeChoicePair * CharacteristicS_1105_TypePairIn)
{CharacteristicS_1105_TypePair = CharacteristicS_1105_TypePairIn;}
CharacteristicS_1105_TypeChoicePair::CharacteristicS_1105_TypeChoicePair() {}

CharacteristicS_1105_TypeChoicePair::CharacteristicS_1105_TypeChoicePair(
 whichOne CharacteristicS_1105_TypeTypeIn,
 CharacteristicS_1105_TypeVal CharacteristicS_1105_TypeValueIn)
{
  CharacteristicS_1105_TypeType = CharacteristicS_1105_TypeTypeIn;
  CharacteristicS_1105_TypeValue = CharacteristicS_1105_TypeValueIn;
}

CharacteristicS_1105_TypeChoicePair::~CharacteristicS_1105_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (CharacteristicS_1105_TypeType == SoftwareIdE)
    delete CharacteristicS_1105_TypeValue.SoftwareId;
  else if (CharacteristicS_1105_TypeType == StandardIdE)
    delete CharacteristicS_1105_TypeValue.StandardId;
  else if (CharacteristicS_1105_TypeType == AlgorithmIdE)
    delete CharacteristicS_1105_TypeValue.AlgorithmId;
  #endif
}

void CharacteristicS_1105_TypeChoicePair::printSelf(FILE * outFile)
{
  if (CharacteristicS_1105_TypeType == SoftwareIdE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SoftwareId");
      CharacteristicS_1105_TypeValue.SoftwareId->printSelf(outFile);
      fprintf(outFile, "</SoftwareId>\n");
    }
  else if (CharacteristicS_1105_TypeType == StandardIdE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<StandardId");
      CharacteristicS_1105_TypeValue.StandardId->printSelf(outFile);
      fprintf(outFile, "</StandardId>\n");
    }
  else if (CharacteristicS_1105_TypeType == AlgorithmIdE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<AlgorithmId");
      CharacteristicS_1105_TypeValue.AlgorithmId->printSelf(outFile);
      fprintf(outFile, "</AlgorithmId>\n");
    }
}

/* ***************************************************************** */

/* class CharacteristicS_1106_Type

*/

CharacteristicS_1106_Type::CharacteristicS_1106_Type()
{
  CharacteristicS_1106_TypePair = 0;
}

CharacteristicS_1106_Type::CharacteristicS_1106_Type(
 CharacteristicS_1106_TypeChoicePair * CharacteristicS_1106_TypePairIn)
{
  CharacteristicS_1106_TypePair = CharacteristicS_1106_TypePairIn;
}

CharacteristicS_1106_Type::~CharacteristicS_1106_Type()
{
  #ifndef NODESTRUCT
  delete CharacteristicS_1106_TypePair;
  #endif
}

void CharacteristicS_1106_Type::printSelf(FILE * outFile)
{
  if (CharacteristicS_1106_TypePair)
    {
      CharacteristicS_1106_TypePair->printSelf(outFile);
    }
}

CharacteristicS_1106_TypeChoicePair * CharacteristicS_1106_Type::getCharacteristicS_1106_TypePair()
{return CharacteristicS_1106_TypePair;}

void CharacteristicS_1106_Type::setCharacteristicS_1106_TypePair(CharacteristicS_1106_TypeChoicePair * CharacteristicS_1106_TypePairIn)
{CharacteristicS_1106_TypePair = CharacteristicS_1106_TypePairIn;}
CharacteristicS_1106_TypeChoicePair::CharacteristicS_1106_TypeChoicePair() {}

CharacteristicS_1106_TypeChoicePair::CharacteristicS_1106_TypeChoicePair(
 whichOne CharacteristicS_1106_TypeTypeIn,
 CharacteristicS_1106_TypeVal CharacteristicS_1106_TypeValueIn)
{
  CharacteristicS_1106_TypeType = CharacteristicS_1106_TypeTypeIn;
  CharacteristicS_1106_TypeValue = CharacteristicS_1106_TypeValueIn;
}

CharacteristicS_1106_TypeChoicePair::~CharacteristicS_1106_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (CharacteristicS_1106_TypeType == CharacteristicS_1156E)
    delete CharacteristicS_1106_TypeValue.CharacteristicS_1156;
  else if (CharacteristicS_1106_TypeType == CharacteristicS_1157E)
    delete CharacteristicS_1106_TypeValue.CharacteristicS_1157;
  #endif
}

void CharacteristicS_1106_TypeChoicePair::printSelf(FILE * outFile)
{
  if (CharacteristicS_1106_TypeType == CharacteristicS_1156E)
    {
      CharacteristicS_1106_TypeValue.CharacteristicS_1156->printSelf(outFile);
    }
  else if (CharacteristicS_1106_TypeType == CharacteristicS_1157E)
    {
      CharacteristicS_1106_TypeValue.CharacteristicS_1157->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class CorrectiveActio_1107_Type

*/

CorrectiveActio_1107_Type::CorrectiveActio_1107_Type()
{
  CorrectiveActio_1107_TypePair = 0;
}

CorrectiveActio_1107_Type::CorrectiveActio_1107_Type(
 CorrectiveActio_1107_TypeChoicePair * CorrectiveActio_1107_TypePairIn)
{
  CorrectiveActio_1107_TypePair = CorrectiveActio_1107_TypePairIn;
}

CorrectiveActio_1107_Type::~CorrectiveActio_1107_Type()
{
  #ifndef NODESTRUCT
  delete CorrectiveActio_1107_TypePair;
  #endif
}

void CorrectiveActio_1107_Type::printSelf(FILE * outFile)
{
  CorrectiveActio_1107_TypePair->printSelf(outFile);
}

CorrectiveActio_1107_TypeChoicePair * CorrectiveActio_1107_Type::getCorrectiveActio_1107_TypePair()
{return CorrectiveActio_1107_TypePair;}

void CorrectiveActio_1107_Type::setCorrectiveActio_1107_TypePair(CorrectiveActio_1107_TypeChoicePair * CorrectiveActio_1107_TypePairIn)
{CorrectiveActio_1107_TypePair = CorrectiveActio_1107_TypePairIn;}
CorrectiveActio_1107_TypeChoicePair::CorrectiveActio_1107_TypeChoicePair() {}

CorrectiveActio_1107_TypeChoicePair::CorrectiveActio_1107_TypeChoicePair(
 whichOne CorrectiveActio_1107_TypeTypeIn,
 CorrectiveActio_1107_TypeVal CorrectiveActio_1107_TypeValueIn)
{
  CorrectiveActio_1107_TypeType = CorrectiveActio_1107_TypeTypeIn;
  CorrectiveActio_1107_TypeValue = CorrectiveActio_1107_TypeValueIn;
}

CorrectiveActio_1107_TypeChoicePair::~CorrectiveActio_1107_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (CorrectiveActio_1107_TypeType == ActionToTakeE)
    delete CorrectiveActio_1107_TypeValue.ActionToTake;
  else if (CorrectiveActio_1107_TypeType == ActionToTakeEnumE)
    delete CorrectiveActio_1107_TypeValue.ActionToTakeEnum;
  #endif
}

void CorrectiveActio_1107_TypeChoicePair::printSelf(FILE * outFile)
{
  if (CorrectiveActio_1107_TypeType == ActionToTakeE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActionToTake");
      CorrectiveActio_1107_TypeValue.ActionToTake->printSelf(outFile);
      fprintf(outFile, "</ActionToTake>\n");
    }
  else if (CorrectiveActio_1107_TypeType == ActionToTakeEnumE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ActionToTakeEnum");
      CorrectiveActio_1107_TypeValue.ActionToTakeEnum->printSelf(outFile);
      fprintf(outFile, "</ActionToTakeEnum>\n");
    }
}

/* ***************************************************************** */

/* class CriterionDecima_1108_Type

*/

CriterionDecima_1108_Type::CriterionDecima_1108_Type()
{
  NumberAllowedExceptions = 0;
  ExtremeLimit = 0;
}

CriterionDecima_1108_Type::CriterionDecima_1108_Type(
 LimitingNumberType * NumberAllowedExceptionsIn,
 XmlDecimal * ExtremeLimitIn)
{
  NumberAllowedExceptions = NumberAllowedExceptionsIn;
  ExtremeLimit = ExtremeLimitIn;
}

CriterionDecima_1108_Type::~CriterionDecima_1108_Type()
{
  #ifndef NODESTRUCT
  delete NumberAllowedExceptions;
  delete ExtremeLimit;
  #endif
}

void CriterionDecima_1108_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<NumberAllowedExceptions");
  NumberAllowedExceptions->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</NumberAllowedExceptions>\n");
  if (ExtremeLimit)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ExtremeLimit");
      ExtremeLimit->printSelf(outFile);
      fprintf(outFile, "</ExtremeLimit>\n");
    }
}

LimitingNumberType * CriterionDecima_1108_Type::getNumberAllowedExceptions()
{return NumberAllowedExceptions;}

void CriterionDecima_1108_Type::setNumberAllowedExceptions(LimitingNumberType * NumberAllowedExceptionsIn)
{NumberAllowedExceptions = NumberAllowedExceptionsIn;}

XmlDecimal * CriterionDecima_1108_Type::getExtremeLimit()
{return ExtremeLimit;}

void CriterionDecima_1108_Type::setExtremeLimit(XmlDecimal * ExtremeLimitIn)
{ExtremeLimit = ExtremeLimitIn;}

/* ***************************************************************** */

/* class CriterionIntege_1109_Type

*/

CriterionIntege_1109_Type::CriterionIntege_1109_Type()
{
  NumberAllowedExceptions = 0;
  ExtremeLimit = 0;
}

CriterionIntege_1109_Type::CriterionIntege_1109_Type(
 LimitingNumberType * NumberAllowedExceptionsIn,
 XmlPositiveInteger * ExtremeLimitIn)
{
  NumberAllowedExceptions = NumberAllowedExceptionsIn;
  ExtremeLimit = ExtremeLimitIn;
}

CriterionIntege_1109_Type::~CriterionIntege_1109_Type()
{
  #ifndef NODESTRUCT
  delete NumberAllowedExceptions;
  delete ExtremeLimit;
  #endif
}

void CriterionIntege_1109_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<NumberAllowedExceptions");
  NumberAllowedExceptions->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</NumberAllowedExceptions>\n");
  if (ExtremeLimit)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<ExtremeLimit");
      ExtremeLimit->printSelf(outFile);
      fprintf(outFile, "</ExtremeLimit>\n");
    }
}

LimitingNumberType * CriterionIntege_1109_Type::getNumberAllowedExceptions()
{return NumberAllowedExceptions;}

void CriterionIntege_1109_Type::setNumberAllowedExceptions(LimitingNumberType * NumberAllowedExceptionsIn)
{NumberAllowedExceptions = NumberAllowedExceptionsIn;}

XmlPositiveInteger * CriterionIntege_1109_Type::getExtremeLimit()
{return ExtremeLimit;}

void CriterionIntege_1109_Type::setExtremeLimit(XmlPositiveInteger * ExtremeLimitIn)
{ExtremeLimit = ExtremeLimitIn;}

/* ***************************************************************** */

/* class LinearCharacter_1110_Type

*/

LinearCharacter_1110_Type::LinearCharacter_1110_Type()
{
  ValueStats = 0;
  MaxValueStats = 0;
  MinValueStats = 0;
}

LinearCharacter_1110_Type::LinearCharacter_1110_Type(
 StatsWithTolLinearType * ValueStatsIn,
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn)
{
  ValueStats = ValueStatsIn;
  MaxValueStats = MaxValueStatsIn;
  MinValueStats = MinValueStatsIn;
}

LinearCharacter_1110_Type::~LinearCharacter_1110_Type()
{
  #ifndef NODESTRUCT
  delete ValueStats;
  delete MaxValueStats;
  delete MinValueStats;
  #endif
}

void LinearCharacter_1110_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<ValueStats");
  ValueStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ValueStats>\n");
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
}

StatsWithTolLinearType * LinearCharacter_1110_Type::getValueStats()
{return ValueStats;}

void LinearCharacter_1110_Type::setValueStats(StatsWithTolLinearType * ValueStatsIn)
{ValueStats = ValueStatsIn;}

StatsLinearType * LinearCharacter_1110_Type::getMaxValueStats()
{return MaxValueStats;}

void LinearCharacter_1110_Type::setMaxValueStats(StatsLinearType * MaxValueStatsIn)
{MaxValueStats = MaxValueStatsIn;}

StatsLinearType * LinearCharacter_1110_Type::getMinValueStats()
{return MinValueStats;}

void LinearCharacter_1110_Type::setMinValueStats(StatsLinearType * MinValueStatsIn)
{MinValueStats = MinValueStatsIn;}

/* ***************************************************************** */

/* class LinearCharacter_1111_Type

*/

LinearCharacter_1111_Type::LinearCharacter_1111_Type()
{
  MaxValueStats = 0;
  MinValueStats = 0;
}

LinearCharacter_1111_Type::LinearCharacter_1111_Type(
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn)
{
  MaxValueStats = MaxValueStatsIn;
  MinValueStats = MinValueStatsIn;
}

LinearCharacter_1111_Type::~LinearCharacter_1111_Type()
{
  #ifndef NODESTRUCT
  delete MaxValueStats;
  delete MinValueStats;
  #endif
}

void LinearCharacter_1111_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxValueStats");
  MaxValueStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</MaxValueStats>\n");
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
}

StatsLinearType * LinearCharacter_1111_Type::getMaxValueStats()
{return MaxValueStats;}

void LinearCharacter_1111_Type::setMaxValueStats(StatsLinearType * MaxValueStatsIn)
{MaxValueStats = MaxValueStatsIn;}

StatsLinearType * LinearCharacter_1111_Type::getMinValueStats()
{return MinValueStats;}

void LinearCharacter_1111_Type::setMinValueStats(StatsLinearType * MinValueStatsIn)
{MinValueStats = MinValueStatsIn;}

/* ***************************************************************** */

/* class LinearCharacter_1112_Type

*/

LinearCharacter_1112_Type::LinearCharacter_1112_Type()
{
  DeviationStats = 0;
  MaxDeviationStats = 0;
  MinDeviationStats = 0;
}

LinearCharacter_1112_Type::LinearCharacter_1112_Type(
 StatsWithTolLinearType * DeviationStatsIn,
 StatsLinearType * MaxDeviationStatsIn,
 StatsLinearType * MinDeviationStatsIn)
{
  DeviationStats = DeviationStatsIn;
  MaxDeviationStats = MaxDeviationStatsIn;
  MinDeviationStats = MinDeviationStatsIn;
}

LinearCharacter_1112_Type::~LinearCharacter_1112_Type()
{
  #ifndef NODESTRUCT
  delete DeviationStats;
  delete MaxDeviationStats;
  delete MinDeviationStats;
  #endif
}

void LinearCharacter_1112_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<DeviationStats");
  DeviationStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeviationStats>\n");
  if (MaxDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxDeviationStats");
      MaxDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxDeviationStats>\n");
    }
  if (MinDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

StatsWithTolLinearType * LinearCharacter_1112_Type::getDeviationStats()
{return DeviationStats;}

void LinearCharacter_1112_Type::setDeviationStats(StatsWithTolLinearType * DeviationStatsIn)
{DeviationStats = DeviationStatsIn;}

StatsLinearType * LinearCharacter_1112_Type::getMaxDeviationStats()
{return MaxDeviationStats;}

void LinearCharacter_1112_Type::setMaxDeviationStats(StatsLinearType * MaxDeviationStatsIn)
{MaxDeviationStats = MaxDeviationStatsIn;}

StatsLinearType * LinearCharacter_1112_Type::getMinDeviationStats()
{return MinDeviationStats;}

void LinearCharacter_1112_Type::setMinDeviationStats(StatsLinearType * MinDeviationStatsIn)
{MinDeviationStats = MinDeviationStatsIn;}

/* ***************************************************************** */

/* class LinearCharacter_1113_Type

*/

LinearCharacter_1113_Type::LinearCharacter_1113_Type()
{
  MaxDeviationStats = 0;
  MinDeviationStats = 0;
}

LinearCharacter_1113_Type::LinearCharacter_1113_Type(
 StatsLinearType * MaxDeviationStatsIn,
 StatsLinearType * MinDeviationStatsIn)
{
  MaxDeviationStats = MaxDeviationStatsIn;
  MinDeviationStats = MinDeviationStatsIn;
}

LinearCharacter_1113_Type::~LinearCharacter_1113_Type()
{
  #ifndef NODESTRUCT
  delete MaxDeviationStats;
  delete MinDeviationStats;
  #endif
}

void LinearCharacter_1113_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxDeviationStats");
  MaxDeviationStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</MaxDeviationStats>\n");
  if (MinDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

StatsLinearType * LinearCharacter_1113_Type::getMaxDeviationStats()
{return MaxDeviationStats;}

void LinearCharacter_1113_Type::setMaxDeviationStats(StatsLinearType * MaxDeviationStatsIn)
{MaxDeviationStats = MaxDeviationStatsIn;}

StatsLinearType * LinearCharacter_1113_Type::getMinDeviationStats()
{return MinDeviationStats;}

void LinearCharacter_1113_Type::setMinDeviationStats(StatsLinearType * MinDeviationStatsIn)
{MinDeviationStats = MinDeviationStatsIn;}

/* ***************************************************************** */

/* class SamplingMethodT_1114_Type

*/

SamplingMethodT_1114_Type::SamplingMethodT_1114_Type()
{
  SamplingMethodT_1114_TypePair = 0;
}

SamplingMethodT_1114_Type::SamplingMethodT_1114_Type(
 SamplingMethodT_1114_TypeChoicePair * SamplingMethodT_1114_TypePairIn)
{
  SamplingMethodT_1114_TypePair = SamplingMethodT_1114_TypePairIn;
}

SamplingMethodT_1114_Type::~SamplingMethodT_1114_Type()
{
  #ifndef NODESTRUCT
  delete SamplingMethodT_1114_TypePair;
  #endif
}

void SamplingMethodT_1114_Type::printSelf(FILE * outFile)
{
  SamplingMethodT_1114_TypePair->printSelf(outFile);
}

SamplingMethodT_1114_TypeChoicePair * SamplingMethodT_1114_Type::getSamplingMethodT_1114_TypePair()
{return SamplingMethodT_1114_TypePair;}

void SamplingMethodT_1114_Type::setSamplingMethodT_1114_TypePair(SamplingMethodT_1114_TypeChoicePair * SamplingMethodT_1114_TypePairIn)
{SamplingMethodT_1114_TypePair = SamplingMethodT_1114_TypePairIn;}
SamplingMethodT_1114_TypeChoicePair::SamplingMethodT_1114_TypeChoicePair() {}

SamplingMethodT_1114_TypeChoicePair::SamplingMethodT_1114_TypeChoicePair(
 whichOne SamplingMethodT_1114_TypeTypeIn,
 SamplingMethodT_1114_TypeVal SamplingMethodT_1114_TypeValueIn)
{
  SamplingMethodT_1114_TypeType = SamplingMethodT_1114_TypeTypeIn;
  SamplingMethodT_1114_TypeValue = SamplingMethodT_1114_TypeValueIn;
}

SamplingMethodT_1114_TypeChoicePair::~SamplingMethodT_1114_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (SamplingMethodT_1114_TypeType == SamplingPeriodE)
    delete SamplingMethodT_1114_TypeValue.SamplingPeriod;
  else if (SamplingMethodT_1114_TypeType == SamplingMethodT_1158E)
    delete SamplingMethodT_1114_TypeValue.SamplingMethodT_1158;
  #endif
}

void SamplingMethodT_1114_TypeChoicePair::printSelf(FILE * outFile)
{
  if (SamplingMethodT_1114_TypeType == SamplingPeriodE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SamplingPeriod");
      SamplingMethodT_1114_TypeValue.SamplingPeriod->printSelf(outFile);
      fprintf(outFile, "</SamplingPeriod>\n");
    }
  else if (SamplingMethodT_1114_TypeType == SamplingMethodT_1158E)
    {
      SamplingMethodT_1114_TypeValue.SamplingMethodT_1158->printSelf(outFile);
    }
}

/* ***************************************************************** */

/* class StudyIssueType_1115_Type

*/

StudyIssueType_1115_Type::StudyIssueType_1115_Type()
{
  StudyIssueType_1115_TypePair = 0;
}

StudyIssueType_1115_Type::StudyIssueType_1115_Type(
 StudyIssueType_1115_TypeChoicePair * StudyIssueType_1115_TypePairIn)
{
  StudyIssueType_1115_TypePair = StudyIssueType_1115_TypePairIn;
}

StudyIssueType_1115_Type::~StudyIssueType_1115_Type()
{
  #ifndef NODESTRUCT
  delete StudyIssueType_1115_TypePair;
  #endif
}

void StudyIssueType_1115_Type::printSelf(FILE * outFile)
{
  if (StudyIssueType_1115_TypePair)
    {
      StudyIssueType_1115_TypePair->printSelf(outFile);
    }
}

StudyIssueType_1115_TypeChoicePair * StudyIssueType_1115_Type::getStudyIssueType_1115_TypePair()
{return StudyIssueType_1115_TypePair;}

void StudyIssueType_1115_Type::setStudyIssueType_1115_TypePair(StudyIssueType_1115_TypeChoicePair * StudyIssueType_1115_TypePairIn)
{StudyIssueType_1115_TypePair = StudyIssueType_1115_TypePairIn;}
StudyIssueType_1115_TypeChoicePair::StudyIssueType_1115_TypeChoicePair() {}

StudyIssueType_1115_TypeChoicePair::StudyIssueType_1115_TypeChoicePair(
 whichOne StudyIssueType_1115_TypeTypeIn,
 StudyIssueType_1115_TypeVal StudyIssueType_1115_TypeValueIn)
{
  StudyIssueType_1115_TypeType = StudyIssueType_1115_TypeTypeIn;
  StudyIssueType_1115_TypeValue = StudyIssueType_1115_TypeValueIn;
}

StudyIssueType_1115_TypeChoicePair::~StudyIssueType_1115_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (StudyIssueType_1115_TypeType == CharacteristicMeasurementIdsE)
    delete StudyIssueType_1115_TypeValue.CharacteristicMeasurementIds;
  else if (StudyIssueType_1115_TypeType == SubgroupIdsE)
    delete StudyIssueType_1115_TypeValue.SubgroupIds;
  #endif
}

void StudyIssueType_1115_TypeChoicePair::printSelf(FILE * outFile)
{
  if (StudyIssueType_1115_TypeType == CharacteristicMeasurementIdsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<CharacteristicMeasurementIds");
      StudyIssueType_1115_TypeValue.CharacteristicMeasurementIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</CharacteristicMeasurementIds>\n");
    }
  else if (StudyIssueType_1115_TypeType == SubgroupIdsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubgroupIds");
      StudyIssueType_1115_TypeValue.SubgroupIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubgroupIds>\n");
    }
}

/* ***************************************************************** */

/* class UserDefinedAngu_1116_Type

*/

UserDefinedAngu_1116_Type::UserDefinedAngu_1116_Type()
{
  ValueStats = 0;
  MaxValueStats = 0;
  MinValueStats = 0;
}

UserDefinedAngu_1116_Type::UserDefinedAngu_1116_Type(
 StatsWithTolAngularType * ValueStatsIn,
 StatsAngularType * MaxValueStatsIn,
 StatsAngularType * MinValueStatsIn)
{
  ValueStats = ValueStatsIn;
  MaxValueStats = MaxValueStatsIn;
  MinValueStats = MinValueStatsIn;
}

UserDefinedAngu_1116_Type::~UserDefinedAngu_1116_Type()
{
  #ifndef NODESTRUCT
  delete ValueStats;
  delete MaxValueStats;
  delete MinValueStats;
  #endif
}

void UserDefinedAngu_1116_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<ValueStats");
  ValueStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ValueStats>\n");
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
}

StatsWithTolAngularType * UserDefinedAngu_1116_Type::getValueStats()
{return ValueStats;}

void UserDefinedAngu_1116_Type::setValueStats(StatsWithTolAngularType * ValueStatsIn)
{ValueStats = ValueStatsIn;}

StatsAngularType * UserDefinedAngu_1116_Type::getMaxValueStats()
{return MaxValueStats;}

void UserDefinedAngu_1116_Type::setMaxValueStats(StatsAngularType * MaxValueStatsIn)
{MaxValueStats = MaxValueStatsIn;}

StatsAngularType * UserDefinedAngu_1116_Type::getMinValueStats()
{return MinValueStats;}

void UserDefinedAngu_1116_Type::setMinValueStats(StatsAngularType * MinValueStatsIn)
{MinValueStats = MinValueStatsIn;}

/* ***************************************************************** */

/* class UserDefinedAngu_1117_Type

*/

UserDefinedAngu_1117_Type::UserDefinedAngu_1117_Type()
{
  MaxValueStats = 0;
  MinValueStats = 0;
}

UserDefinedAngu_1117_Type::UserDefinedAngu_1117_Type(
 StatsAngularType * MaxValueStatsIn,
 StatsAngularType * MinValueStatsIn)
{
  MaxValueStats = MaxValueStatsIn;
  MinValueStats = MinValueStatsIn;
}

UserDefinedAngu_1117_Type::~UserDefinedAngu_1117_Type()
{
  #ifndef NODESTRUCT
  delete MaxValueStats;
  delete MinValueStats;
  #endif
}

void UserDefinedAngu_1117_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxValueStats");
  MaxValueStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</MaxValueStats>\n");
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
}

StatsAngularType * UserDefinedAngu_1117_Type::getMaxValueStats()
{return MaxValueStats;}

void UserDefinedAngu_1117_Type::setMaxValueStats(StatsAngularType * MaxValueStatsIn)
{MaxValueStats = MaxValueStatsIn;}

StatsAngularType * UserDefinedAngu_1117_Type::getMinValueStats()
{return MinValueStats;}

void UserDefinedAngu_1117_Type::setMinValueStats(StatsAngularType * MinValueStatsIn)
{MinValueStats = MinValueStatsIn;}

/* ***************************************************************** */

/* class UserDefinedAngu_1118_Type

*/

UserDefinedAngu_1118_Type::UserDefinedAngu_1118_Type()
{
  DeviationStats = 0;
  MaxDeviationStats = 0;
  MinDeviationStats = 0;
}

UserDefinedAngu_1118_Type::UserDefinedAngu_1118_Type(
 StatsWithTolAngularType * DeviationStatsIn,
 StatsAngularType * MaxDeviationStatsIn,
 StatsAngularType * MinDeviationStatsIn)
{
  DeviationStats = DeviationStatsIn;
  MaxDeviationStats = MaxDeviationStatsIn;
  MinDeviationStats = MinDeviationStatsIn;
}

UserDefinedAngu_1118_Type::~UserDefinedAngu_1118_Type()
{
  #ifndef NODESTRUCT
  delete DeviationStats;
  delete MaxDeviationStats;
  delete MinDeviationStats;
  #endif
}

void UserDefinedAngu_1118_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<DeviationStats");
  DeviationStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeviationStats>\n");
  if (MaxDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxDeviationStats");
      MaxDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxDeviationStats>\n");
    }
  if (MinDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

StatsWithTolAngularType * UserDefinedAngu_1118_Type::getDeviationStats()
{return DeviationStats;}

void UserDefinedAngu_1118_Type::setDeviationStats(StatsWithTolAngularType * DeviationStatsIn)
{DeviationStats = DeviationStatsIn;}

StatsAngularType * UserDefinedAngu_1118_Type::getMaxDeviationStats()
{return MaxDeviationStats;}

void UserDefinedAngu_1118_Type::setMaxDeviationStats(StatsAngularType * MaxDeviationStatsIn)
{MaxDeviationStats = MaxDeviationStatsIn;}

StatsAngularType * UserDefinedAngu_1118_Type::getMinDeviationStats()
{return MinDeviationStats;}

void UserDefinedAngu_1118_Type::setMinDeviationStats(StatsAngularType * MinDeviationStatsIn)
{MinDeviationStats = MinDeviationStatsIn;}

/* ***************************************************************** */

/* class UserDefinedAngu_1119_Type

*/

UserDefinedAngu_1119_Type::UserDefinedAngu_1119_Type()
{
  MaxDeviationStats = 0;
  MinDeviationStats = 0;
}

UserDefinedAngu_1119_Type::UserDefinedAngu_1119_Type(
 StatsAngularType * MaxDeviationStatsIn,
 StatsAngularType * MinDeviationStatsIn)
{
  MaxDeviationStats = MaxDeviationStatsIn;
  MinDeviationStats = MinDeviationStatsIn;
}

UserDefinedAngu_1119_Type::~UserDefinedAngu_1119_Type()
{
  #ifndef NODESTRUCT
  delete MaxDeviationStats;
  delete MinDeviationStats;
  #endif
}

void UserDefinedAngu_1119_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxDeviationStats");
  MaxDeviationStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</MaxDeviationStats>\n");
  if (MinDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

StatsAngularType * UserDefinedAngu_1119_Type::getMaxDeviationStats()
{return MaxDeviationStats;}

void UserDefinedAngu_1119_Type::setMaxDeviationStats(StatsAngularType * MaxDeviationStatsIn)
{MaxDeviationStats = MaxDeviationStatsIn;}

StatsAngularType * UserDefinedAngu_1119_Type::getMinDeviationStats()
{return MinDeviationStats;}

void UserDefinedAngu_1119_Type::setMinDeviationStats(StatsAngularType * MinDeviationStatsIn)
{MinDeviationStats = MinDeviationStatsIn;}

/* ***************************************************************** */

/* class UserDefinedArea_1120_Type

*/

UserDefinedArea_1120_Type::UserDefinedArea_1120_Type()
{
  ValueStats = 0;
  MaxValueStats = 0;
  MinValueStats = 0;
}

UserDefinedArea_1120_Type::UserDefinedArea_1120_Type(
 StatsWithTolAreaType * ValueStatsIn,
 StatsAreaType * MaxValueStatsIn,
 StatsAreaType * MinValueStatsIn)
{
  ValueStats = ValueStatsIn;
  MaxValueStats = MaxValueStatsIn;
  MinValueStats = MinValueStatsIn;
}

UserDefinedArea_1120_Type::~UserDefinedArea_1120_Type()
{
  #ifndef NODESTRUCT
  delete ValueStats;
  delete MaxValueStats;
  delete MinValueStats;
  #endif
}

void UserDefinedArea_1120_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<ValueStats");
  ValueStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ValueStats>\n");
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
}

StatsWithTolAreaType * UserDefinedArea_1120_Type::getValueStats()
{return ValueStats;}

void UserDefinedArea_1120_Type::setValueStats(StatsWithTolAreaType * ValueStatsIn)
{ValueStats = ValueStatsIn;}

StatsAreaType * UserDefinedArea_1120_Type::getMaxValueStats()
{return MaxValueStats;}

void UserDefinedArea_1120_Type::setMaxValueStats(StatsAreaType * MaxValueStatsIn)
{MaxValueStats = MaxValueStatsIn;}

StatsAreaType * UserDefinedArea_1120_Type::getMinValueStats()
{return MinValueStats;}

void UserDefinedArea_1120_Type::setMinValueStats(StatsAreaType * MinValueStatsIn)
{MinValueStats = MinValueStatsIn;}

/* ***************************************************************** */

/* class UserDefinedArea_1121_Type

*/

UserDefinedArea_1121_Type::UserDefinedArea_1121_Type()
{
  MaxValueStats = 0;
  MinValueStats = 0;
}

UserDefinedArea_1121_Type::UserDefinedArea_1121_Type(
 StatsAreaType * MaxValueStatsIn,
 StatsAreaType * MinValueStatsIn)
{
  MaxValueStats = MaxValueStatsIn;
  MinValueStats = MinValueStatsIn;
}

UserDefinedArea_1121_Type::~UserDefinedArea_1121_Type()
{
  #ifndef NODESTRUCT
  delete MaxValueStats;
  delete MinValueStats;
  #endif
}

void UserDefinedArea_1121_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxValueStats");
  MaxValueStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</MaxValueStats>\n");
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
}

StatsAreaType * UserDefinedArea_1121_Type::getMaxValueStats()
{return MaxValueStats;}

void UserDefinedArea_1121_Type::setMaxValueStats(StatsAreaType * MaxValueStatsIn)
{MaxValueStats = MaxValueStatsIn;}

StatsAreaType * UserDefinedArea_1121_Type::getMinValueStats()
{return MinValueStats;}

void UserDefinedArea_1121_Type::setMinValueStats(StatsAreaType * MinValueStatsIn)
{MinValueStats = MinValueStatsIn;}

/* ***************************************************************** */

/* class UserDefinedArea_1122_Type

*/

UserDefinedArea_1122_Type::UserDefinedArea_1122_Type()
{
  DeviationStats = 0;
  MaxDeviationStats = 0;
  MinDeviationStats = 0;
}

UserDefinedArea_1122_Type::UserDefinedArea_1122_Type(
 StatsWithTolAreaType * DeviationStatsIn,
 StatsAreaType * MaxDeviationStatsIn,
 StatsAreaType * MinDeviationStatsIn)
{
  DeviationStats = DeviationStatsIn;
  MaxDeviationStats = MaxDeviationStatsIn;
  MinDeviationStats = MinDeviationStatsIn;
}

UserDefinedArea_1122_Type::~UserDefinedArea_1122_Type()
{
  #ifndef NODESTRUCT
  delete DeviationStats;
  delete MaxDeviationStats;
  delete MinDeviationStats;
  #endif
}

void UserDefinedArea_1122_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<DeviationStats");
  DeviationStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeviationStats>\n");
  if (MaxDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxDeviationStats");
      MaxDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxDeviationStats>\n");
    }
  if (MinDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

StatsWithTolAreaType * UserDefinedArea_1122_Type::getDeviationStats()
{return DeviationStats;}

void UserDefinedArea_1122_Type::setDeviationStats(StatsWithTolAreaType * DeviationStatsIn)
{DeviationStats = DeviationStatsIn;}

StatsAreaType * UserDefinedArea_1122_Type::getMaxDeviationStats()
{return MaxDeviationStats;}

void UserDefinedArea_1122_Type::setMaxDeviationStats(StatsAreaType * MaxDeviationStatsIn)
{MaxDeviationStats = MaxDeviationStatsIn;}

StatsAreaType * UserDefinedArea_1122_Type::getMinDeviationStats()
{return MinDeviationStats;}

void UserDefinedArea_1122_Type::setMinDeviationStats(StatsAreaType * MinDeviationStatsIn)
{MinDeviationStats = MinDeviationStatsIn;}

/* ***************************************************************** */

/* class UserDefinedArea_1123_Type

*/

UserDefinedArea_1123_Type::UserDefinedArea_1123_Type()
{
  MaxDeviationStats = 0;
  MinDeviationStats = 0;
}

UserDefinedArea_1123_Type::UserDefinedArea_1123_Type(
 StatsAreaType * MaxDeviationStatsIn,
 StatsAreaType * MinDeviationStatsIn)
{
  MaxDeviationStats = MaxDeviationStatsIn;
  MinDeviationStats = MinDeviationStatsIn;
}

UserDefinedArea_1123_Type::~UserDefinedArea_1123_Type()
{
  #ifndef NODESTRUCT
  delete MaxDeviationStats;
  delete MinDeviationStats;
  #endif
}

void UserDefinedArea_1123_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxDeviationStats");
  MaxDeviationStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</MaxDeviationStats>\n");
  if (MinDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

StatsAreaType * UserDefinedArea_1123_Type::getMaxDeviationStats()
{return MaxDeviationStats;}

void UserDefinedArea_1123_Type::setMaxDeviationStats(StatsAreaType * MaxDeviationStatsIn)
{MaxDeviationStats = MaxDeviationStatsIn;}

StatsAreaType * UserDefinedArea_1123_Type::getMinDeviationStats()
{return MinDeviationStats;}

void UserDefinedArea_1123_Type::setMinDeviationStats(StatsAreaType * MinDeviationStatsIn)
{MinDeviationStats = MinDeviationStatsIn;}

/* ***************************************************************** */

/* class UserDefinedForc_1124_Type

*/

UserDefinedForc_1124_Type::UserDefinedForc_1124_Type()
{
  ValueStats = 0;
  MaxValueStats = 0;
  MinValueStats = 0;
}

UserDefinedForc_1124_Type::UserDefinedForc_1124_Type(
 StatsWithTolForceType * ValueStatsIn,
 StatsForceType * MaxValueStatsIn,
 StatsForceType * MinValueStatsIn)
{
  ValueStats = ValueStatsIn;
  MaxValueStats = MaxValueStatsIn;
  MinValueStats = MinValueStatsIn;
}

UserDefinedForc_1124_Type::~UserDefinedForc_1124_Type()
{
  #ifndef NODESTRUCT
  delete ValueStats;
  delete MaxValueStats;
  delete MinValueStats;
  #endif
}

void UserDefinedForc_1124_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<ValueStats");
  ValueStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ValueStats>\n");
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
}

StatsWithTolForceType * UserDefinedForc_1124_Type::getValueStats()
{return ValueStats;}

void UserDefinedForc_1124_Type::setValueStats(StatsWithTolForceType * ValueStatsIn)
{ValueStats = ValueStatsIn;}

StatsForceType * UserDefinedForc_1124_Type::getMaxValueStats()
{return MaxValueStats;}

void UserDefinedForc_1124_Type::setMaxValueStats(StatsForceType * MaxValueStatsIn)
{MaxValueStats = MaxValueStatsIn;}

StatsForceType * UserDefinedForc_1124_Type::getMinValueStats()
{return MinValueStats;}

void UserDefinedForc_1124_Type::setMinValueStats(StatsForceType * MinValueStatsIn)
{MinValueStats = MinValueStatsIn;}

/* ***************************************************************** */

/* class UserDefinedForc_1125_Type

*/

UserDefinedForc_1125_Type::UserDefinedForc_1125_Type()
{
  MaxValueStats = 0;
  MinValueStats = 0;
}

UserDefinedForc_1125_Type::UserDefinedForc_1125_Type(
 StatsForceType * MaxValueStatsIn,
 StatsForceType * MinValueStatsIn)
{
  MaxValueStats = MaxValueStatsIn;
  MinValueStats = MinValueStatsIn;
}

UserDefinedForc_1125_Type::~UserDefinedForc_1125_Type()
{
  #ifndef NODESTRUCT
  delete MaxValueStats;
  delete MinValueStats;
  #endif
}

void UserDefinedForc_1125_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxValueStats");
  MaxValueStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</MaxValueStats>\n");
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
}

StatsForceType * UserDefinedForc_1125_Type::getMaxValueStats()
{return MaxValueStats;}

void UserDefinedForc_1125_Type::setMaxValueStats(StatsForceType * MaxValueStatsIn)
{MaxValueStats = MaxValueStatsIn;}

StatsForceType * UserDefinedForc_1125_Type::getMinValueStats()
{return MinValueStats;}

void UserDefinedForc_1125_Type::setMinValueStats(StatsForceType * MinValueStatsIn)
{MinValueStats = MinValueStatsIn;}

/* ***************************************************************** */

/* class UserDefinedForc_1126_Type

*/

UserDefinedForc_1126_Type::UserDefinedForc_1126_Type()
{
  DeviationStats = 0;
  MaxDeviationStats = 0;
  MinDeviationStats = 0;
}

UserDefinedForc_1126_Type::UserDefinedForc_1126_Type(
 StatsWithTolForceType * DeviationStatsIn,
 StatsForceType * MaxDeviationStatsIn,
 StatsForceType * MinDeviationStatsIn)
{
  DeviationStats = DeviationStatsIn;
  MaxDeviationStats = MaxDeviationStatsIn;
  MinDeviationStats = MinDeviationStatsIn;
}

UserDefinedForc_1126_Type::~UserDefinedForc_1126_Type()
{
  #ifndef NODESTRUCT
  delete DeviationStats;
  delete MaxDeviationStats;
  delete MinDeviationStats;
  #endif
}

void UserDefinedForc_1126_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<DeviationStats");
  DeviationStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeviationStats>\n");
  if (MaxDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxDeviationStats");
      MaxDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxDeviationStats>\n");
    }
  if (MinDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

StatsWithTolForceType * UserDefinedForc_1126_Type::getDeviationStats()
{return DeviationStats;}

void UserDefinedForc_1126_Type::setDeviationStats(StatsWithTolForceType * DeviationStatsIn)
{DeviationStats = DeviationStatsIn;}

StatsForceType * UserDefinedForc_1126_Type::getMaxDeviationStats()
{return MaxDeviationStats;}

void UserDefinedForc_1126_Type::setMaxDeviationStats(StatsForceType * MaxDeviationStatsIn)
{MaxDeviationStats = MaxDeviationStatsIn;}

StatsForceType * UserDefinedForc_1126_Type::getMinDeviationStats()
{return MinDeviationStats;}

void UserDefinedForc_1126_Type::setMinDeviationStats(StatsForceType * MinDeviationStatsIn)
{MinDeviationStats = MinDeviationStatsIn;}

/* ***************************************************************** */

/* class UserDefinedForc_1127_Type

*/

UserDefinedForc_1127_Type::UserDefinedForc_1127_Type()
{
  MaxDeviationStats = 0;
  MinDeviationStats = 0;
}

UserDefinedForc_1127_Type::UserDefinedForc_1127_Type(
 StatsForceType * MaxDeviationStatsIn,
 StatsForceType * MinDeviationStatsIn)
{
  MaxDeviationStats = MaxDeviationStatsIn;
  MinDeviationStats = MinDeviationStatsIn;
}

UserDefinedForc_1127_Type::~UserDefinedForc_1127_Type()
{
  #ifndef NODESTRUCT
  delete MaxDeviationStats;
  delete MinDeviationStats;
  #endif
}

void UserDefinedForc_1127_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxDeviationStats");
  MaxDeviationStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</MaxDeviationStats>\n");
  if (MinDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

StatsForceType * UserDefinedForc_1127_Type::getMaxDeviationStats()
{return MaxDeviationStats;}

void UserDefinedForc_1127_Type::setMaxDeviationStats(StatsForceType * MaxDeviationStatsIn)
{MaxDeviationStats = MaxDeviationStatsIn;}

StatsForceType * UserDefinedForc_1127_Type::getMinDeviationStats()
{return MinDeviationStats;}

void UserDefinedForc_1127_Type::setMinDeviationStats(StatsForceType * MinDeviationStatsIn)
{MinDeviationStats = MinDeviationStatsIn;}

/* ***************************************************************** */

/* class UserDefinedLine_1128_Type

*/

UserDefinedLine_1128_Type::UserDefinedLine_1128_Type()
{
  ValueStats = 0;
  MaxValueStats = 0;
  MinValueStats = 0;
}

UserDefinedLine_1128_Type::UserDefinedLine_1128_Type(
 StatsWithTolLinearType * ValueStatsIn,
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn)
{
  ValueStats = ValueStatsIn;
  MaxValueStats = MaxValueStatsIn;
  MinValueStats = MinValueStatsIn;
}

UserDefinedLine_1128_Type::~UserDefinedLine_1128_Type()
{
  #ifndef NODESTRUCT
  delete ValueStats;
  delete MaxValueStats;
  delete MinValueStats;
  #endif
}

void UserDefinedLine_1128_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<ValueStats");
  ValueStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ValueStats>\n");
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
}

StatsWithTolLinearType * UserDefinedLine_1128_Type::getValueStats()
{return ValueStats;}

void UserDefinedLine_1128_Type::setValueStats(StatsWithTolLinearType * ValueStatsIn)
{ValueStats = ValueStatsIn;}

StatsLinearType * UserDefinedLine_1128_Type::getMaxValueStats()
{return MaxValueStats;}

void UserDefinedLine_1128_Type::setMaxValueStats(StatsLinearType * MaxValueStatsIn)
{MaxValueStats = MaxValueStatsIn;}

StatsLinearType * UserDefinedLine_1128_Type::getMinValueStats()
{return MinValueStats;}

void UserDefinedLine_1128_Type::setMinValueStats(StatsLinearType * MinValueStatsIn)
{MinValueStats = MinValueStatsIn;}

/* ***************************************************************** */

/* class UserDefinedLine_1129_Type

*/

UserDefinedLine_1129_Type::UserDefinedLine_1129_Type()
{
  MaxValueStats = 0;
  MinValueStats = 0;
}

UserDefinedLine_1129_Type::UserDefinedLine_1129_Type(
 StatsLinearType * MaxValueStatsIn,
 StatsLinearType * MinValueStatsIn)
{
  MaxValueStats = MaxValueStatsIn;
  MinValueStats = MinValueStatsIn;
}

UserDefinedLine_1129_Type::~UserDefinedLine_1129_Type()
{
  #ifndef NODESTRUCT
  delete MaxValueStats;
  delete MinValueStats;
  #endif
}

void UserDefinedLine_1129_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxValueStats");
  MaxValueStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</MaxValueStats>\n");
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
}

StatsLinearType * UserDefinedLine_1129_Type::getMaxValueStats()
{return MaxValueStats;}

void UserDefinedLine_1129_Type::setMaxValueStats(StatsLinearType * MaxValueStatsIn)
{MaxValueStats = MaxValueStatsIn;}

StatsLinearType * UserDefinedLine_1129_Type::getMinValueStats()
{return MinValueStats;}

void UserDefinedLine_1129_Type::setMinValueStats(StatsLinearType * MinValueStatsIn)
{MinValueStats = MinValueStatsIn;}

/* ***************************************************************** */

/* class UserDefinedLine_1130_Type

*/

UserDefinedLine_1130_Type::UserDefinedLine_1130_Type()
{
  DeviationStats = 0;
  MaxDeviationStats = 0;
  MinDeviationStats = 0;
}

UserDefinedLine_1130_Type::UserDefinedLine_1130_Type(
 StatsWithTolLinearType * DeviationStatsIn,
 StatsLinearType * MaxDeviationStatsIn,
 StatsLinearType * MinDeviationStatsIn)
{
  DeviationStats = DeviationStatsIn;
  MaxDeviationStats = MaxDeviationStatsIn;
  MinDeviationStats = MinDeviationStatsIn;
}

UserDefinedLine_1130_Type::~UserDefinedLine_1130_Type()
{
  #ifndef NODESTRUCT
  delete DeviationStats;
  delete MaxDeviationStats;
  delete MinDeviationStats;
  #endif
}

void UserDefinedLine_1130_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<DeviationStats");
  DeviationStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeviationStats>\n");
  if (MaxDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxDeviationStats");
      MaxDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxDeviationStats>\n");
    }
  if (MinDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

StatsWithTolLinearType * UserDefinedLine_1130_Type::getDeviationStats()
{return DeviationStats;}

void UserDefinedLine_1130_Type::setDeviationStats(StatsWithTolLinearType * DeviationStatsIn)
{DeviationStats = DeviationStatsIn;}

StatsLinearType * UserDefinedLine_1130_Type::getMaxDeviationStats()
{return MaxDeviationStats;}

void UserDefinedLine_1130_Type::setMaxDeviationStats(StatsLinearType * MaxDeviationStatsIn)
{MaxDeviationStats = MaxDeviationStatsIn;}

StatsLinearType * UserDefinedLine_1130_Type::getMinDeviationStats()
{return MinDeviationStats;}

void UserDefinedLine_1130_Type::setMinDeviationStats(StatsLinearType * MinDeviationStatsIn)
{MinDeviationStats = MinDeviationStatsIn;}

/* ***************************************************************** */

/* class UserDefinedLine_1131_Type

*/

UserDefinedLine_1131_Type::UserDefinedLine_1131_Type()
{
  MaxDeviationStats = 0;
  MinDeviationStats = 0;
}

UserDefinedLine_1131_Type::UserDefinedLine_1131_Type(
 StatsLinearType * MaxDeviationStatsIn,
 StatsLinearType * MinDeviationStatsIn)
{
  MaxDeviationStats = MaxDeviationStatsIn;
  MinDeviationStats = MinDeviationStatsIn;
}

UserDefinedLine_1131_Type::~UserDefinedLine_1131_Type()
{
  #ifndef NODESTRUCT
  delete MaxDeviationStats;
  delete MinDeviationStats;
  #endif
}

void UserDefinedLine_1131_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxDeviationStats");
  MaxDeviationStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</MaxDeviationStats>\n");
  if (MinDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

StatsLinearType * UserDefinedLine_1131_Type::getMaxDeviationStats()
{return MaxDeviationStats;}

void UserDefinedLine_1131_Type::setMaxDeviationStats(StatsLinearType * MaxDeviationStatsIn)
{MaxDeviationStats = MaxDeviationStatsIn;}

StatsLinearType * UserDefinedLine_1131_Type::getMinDeviationStats()
{return MinDeviationStats;}

void UserDefinedLine_1131_Type::setMinDeviationStats(StatsLinearType * MinDeviationStatsIn)
{MinDeviationStats = MinDeviationStatsIn;}

/* ***************************************************************** */

/* class UserDefinedMass_1132_Type

*/

UserDefinedMass_1132_Type::UserDefinedMass_1132_Type()
{
  ValueStats = 0;
  MaxValueStats = 0;
  MinValueStats = 0;
}

UserDefinedMass_1132_Type::UserDefinedMass_1132_Type(
 StatsWithTolMassType * ValueStatsIn,
 StatsMassType * MaxValueStatsIn,
 StatsMassType * MinValueStatsIn)
{
  ValueStats = ValueStatsIn;
  MaxValueStats = MaxValueStatsIn;
  MinValueStats = MinValueStatsIn;
}

UserDefinedMass_1132_Type::~UserDefinedMass_1132_Type()
{
  #ifndef NODESTRUCT
  delete ValueStats;
  delete MaxValueStats;
  delete MinValueStats;
  #endif
}

void UserDefinedMass_1132_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<ValueStats");
  ValueStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ValueStats>\n");
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
}

StatsWithTolMassType * UserDefinedMass_1132_Type::getValueStats()
{return ValueStats;}

void UserDefinedMass_1132_Type::setValueStats(StatsWithTolMassType * ValueStatsIn)
{ValueStats = ValueStatsIn;}

StatsMassType * UserDefinedMass_1132_Type::getMaxValueStats()
{return MaxValueStats;}

void UserDefinedMass_1132_Type::setMaxValueStats(StatsMassType * MaxValueStatsIn)
{MaxValueStats = MaxValueStatsIn;}

StatsMassType * UserDefinedMass_1132_Type::getMinValueStats()
{return MinValueStats;}

void UserDefinedMass_1132_Type::setMinValueStats(StatsMassType * MinValueStatsIn)
{MinValueStats = MinValueStatsIn;}

/* ***************************************************************** */

/* class UserDefinedMass_1133_Type

*/

UserDefinedMass_1133_Type::UserDefinedMass_1133_Type()
{
  MaxValueStats = 0;
  MinValueStats = 0;
}

UserDefinedMass_1133_Type::UserDefinedMass_1133_Type(
 StatsMassType * MaxValueStatsIn,
 StatsMassType * MinValueStatsIn)
{
  MaxValueStats = MaxValueStatsIn;
  MinValueStats = MinValueStatsIn;
}

UserDefinedMass_1133_Type::~UserDefinedMass_1133_Type()
{
  #ifndef NODESTRUCT
  delete MaxValueStats;
  delete MinValueStats;
  #endif
}

void UserDefinedMass_1133_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxValueStats");
  MaxValueStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</MaxValueStats>\n");
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
}

StatsMassType * UserDefinedMass_1133_Type::getMaxValueStats()
{return MaxValueStats;}

void UserDefinedMass_1133_Type::setMaxValueStats(StatsMassType * MaxValueStatsIn)
{MaxValueStats = MaxValueStatsIn;}

StatsMassType * UserDefinedMass_1133_Type::getMinValueStats()
{return MinValueStats;}

void UserDefinedMass_1133_Type::setMinValueStats(StatsMassType * MinValueStatsIn)
{MinValueStats = MinValueStatsIn;}

/* ***************************************************************** */

/* class UserDefinedMass_1134_Type

*/

UserDefinedMass_1134_Type::UserDefinedMass_1134_Type()
{
  DeviationStats = 0;
  MaxDeviationStats = 0;
  MinDeviationStats = 0;
}

UserDefinedMass_1134_Type::UserDefinedMass_1134_Type(
 StatsWithTolMassType * DeviationStatsIn,
 StatsMassType * MaxDeviationStatsIn,
 StatsMassType * MinDeviationStatsIn)
{
  DeviationStats = DeviationStatsIn;
  MaxDeviationStats = MaxDeviationStatsIn;
  MinDeviationStats = MinDeviationStatsIn;
}

UserDefinedMass_1134_Type::~UserDefinedMass_1134_Type()
{
  #ifndef NODESTRUCT
  delete DeviationStats;
  delete MaxDeviationStats;
  delete MinDeviationStats;
  #endif
}

void UserDefinedMass_1134_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<DeviationStats");
  DeviationStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeviationStats>\n");
  if (MaxDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxDeviationStats");
      MaxDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxDeviationStats>\n");
    }
  if (MinDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

StatsWithTolMassType * UserDefinedMass_1134_Type::getDeviationStats()
{return DeviationStats;}

void UserDefinedMass_1134_Type::setDeviationStats(StatsWithTolMassType * DeviationStatsIn)
{DeviationStats = DeviationStatsIn;}

StatsMassType * UserDefinedMass_1134_Type::getMaxDeviationStats()
{return MaxDeviationStats;}

void UserDefinedMass_1134_Type::setMaxDeviationStats(StatsMassType * MaxDeviationStatsIn)
{MaxDeviationStats = MaxDeviationStatsIn;}

StatsMassType * UserDefinedMass_1134_Type::getMinDeviationStats()
{return MinDeviationStats;}

void UserDefinedMass_1134_Type::setMinDeviationStats(StatsMassType * MinDeviationStatsIn)
{MinDeviationStats = MinDeviationStatsIn;}

/* ***************************************************************** */

/* class UserDefinedMass_1135_Type

*/

UserDefinedMass_1135_Type::UserDefinedMass_1135_Type()
{
  MaxDeviationStats = 0;
  MinDeviationStats = 0;
}

UserDefinedMass_1135_Type::UserDefinedMass_1135_Type(
 StatsMassType * MaxDeviationStatsIn,
 StatsMassType * MinDeviationStatsIn)
{
  MaxDeviationStats = MaxDeviationStatsIn;
  MinDeviationStats = MinDeviationStatsIn;
}

UserDefinedMass_1135_Type::~UserDefinedMass_1135_Type()
{
  #ifndef NODESTRUCT
  delete MaxDeviationStats;
  delete MinDeviationStats;
  #endif
}

void UserDefinedMass_1135_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxDeviationStats");
  MaxDeviationStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</MaxDeviationStats>\n");
  if (MinDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

StatsMassType * UserDefinedMass_1135_Type::getMaxDeviationStats()
{return MaxDeviationStats;}

void UserDefinedMass_1135_Type::setMaxDeviationStats(StatsMassType * MaxDeviationStatsIn)
{MaxDeviationStats = MaxDeviationStatsIn;}

StatsMassType * UserDefinedMass_1135_Type::getMinDeviationStats()
{return MinDeviationStats;}

void UserDefinedMass_1135_Type::setMinDeviationStats(StatsMassType * MinDeviationStatsIn)
{MinDeviationStats = MinDeviationStatsIn;}

/* ***************************************************************** */

/* class UserDefinedPres_1136_Type

*/

UserDefinedPres_1136_Type::UserDefinedPres_1136_Type()
{
  ValueStats = 0;
  MaxValueStats = 0;
  MinValueStats = 0;
}

UserDefinedPres_1136_Type::UserDefinedPres_1136_Type(
 StatsWithTolPressureType * ValueStatsIn,
 StatsPressureType * MaxValueStatsIn,
 StatsPressureType * MinValueStatsIn)
{
  ValueStats = ValueStatsIn;
  MaxValueStats = MaxValueStatsIn;
  MinValueStats = MinValueStatsIn;
}

UserDefinedPres_1136_Type::~UserDefinedPres_1136_Type()
{
  #ifndef NODESTRUCT
  delete ValueStats;
  delete MaxValueStats;
  delete MinValueStats;
  #endif
}

void UserDefinedPres_1136_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<ValueStats");
  ValueStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ValueStats>\n");
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
}

StatsWithTolPressureType * UserDefinedPres_1136_Type::getValueStats()
{return ValueStats;}

void UserDefinedPres_1136_Type::setValueStats(StatsWithTolPressureType * ValueStatsIn)
{ValueStats = ValueStatsIn;}

StatsPressureType * UserDefinedPres_1136_Type::getMaxValueStats()
{return MaxValueStats;}

void UserDefinedPres_1136_Type::setMaxValueStats(StatsPressureType * MaxValueStatsIn)
{MaxValueStats = MaxValueStatsIn;}

StatsPressureType * UserDefinedPres_1136_Type::getMinValueStats()
{return MinValueStats;}

void UserDefinedPres_1136_Type::setMinValueStats(StatsPressureType * MinValueStatsIn)
{MinValueStats = MinValueStatsIn;}

/* ***************************************************************** */

/* class UserDefinedPres_1137_Type

*/

UserDefinedPres_1137_Type::UserDefinedPres_1137_Type()
{
  MaxValueStats = 0;
  MinValueStats = 0;
}

UserDefinedPres_1137_Type::UserDefinedPres_1137_Type(
 StatsPressureType * MaxValueStatsIn,
 StatsPressureType * MinValueStatsIn)
{
  MaxValueStats = MaxValueStatsIn;
  MinValueStats = MinValueStatsIn;
}

UserDefinedPres_1137_Type::~UserDefinedPres_1137_Type()
{
  #ifndef NODESTRUCT
  delete MaxValueStats;
  delete MinValueStats;
  #endif
}

void UserDefinedPres_1137_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxValueStats");
  MaxValueStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</MaxValueStats>\n");
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
}

StatsPressureType * UserDefinedPres_1137_Type::getMaxValueStats()
{return MaxValueStats;}

void UserDefinedPres_1137_Type::setMaxValueStats(StatsPressureType * MaxValueStatsIn)
{MaxValueStats = MaxValueStatsIn;}

StatsPressureType * UserDefinedPres_1137_Type::getMinValueStats()
{return MinValueStats;}

void UserDefinedPres_1137_Type::setMinValueStats(StatsPressureType * MinValueStatsIn)
{MinValueStats = MinValueStatsIn;}

/* ***************************************************************** */

/* class UserDefinedPres_1138_Type

*/

UserDefinedPres_1138_Type::UserDefinedPres_1138_Type()
{
  DeviationStats = 0;
  MaxDeviationStats = 0;
  MinDeviationStats = 0;
}

UserDefinedPres_1138_Type::UserDefinedPres_1138_Type(
 StatsWithTolPressureType * DeviationStatsIn,
 StatsPressureType * MaxDeviationStatsIn,
 StatsPressureType * MinDeviationStatsIn)
{
  DeviationStats = DeviationStatsIn;
  MaxDeviationStats = MaxDeviationStatsIn;
  MinDeviationStats = MinDeviationStatsIn;
}

UserDefinedPres_1138_Type::~UserDefinedPres_1138_Type()
{
  #ifndef NODESTRUCT
  delete DeviationStats;
  delete MaxDeviationStats;
  delete MinDeviationStats;
  #endif
}

void UserDefinedPres_1138_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<DeviationStats");
  DeviationStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeviationStats>\n");
  if (MaxDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxDeviationStats");
      MaxDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxDeviationStats>\n");
    }
  if (MinDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

StatsWithTolPressureType * UserDefinedPres_1138_Type::getDeviationStats()
{return DeviationStats;}

void UserDefinedPres_1138_Type::setDeviationStats(StatsWithTolPressureType * DeviationStatsIn)
{DeviationStats = DeviationStatsIn;}

StatsPressureType * UserDefinedPres_1138_Type::getMaxDeviationStats()
{return MaxDeviationStats;}

void UserDefinedPres_1138_Type::setMaxDeviationStats(StatsPressureType * MaxDeviationStatsIn)
{MaxDeviationStats = MaxDeviationStatsIn;}

StatsPressureType * UserDefinedPres_1138_Type::getMinDeviationStats()
{return MinDeviationStats;}

void UserDefinedPres_1138_Type::setMinDeviationStats(StatsPressureType * MinDeviationStatsIn)
{MinDeviationStats = MinDeviationStatsIn;}

/* ***************************************************************** */

/* class UserDefinedPres_1139_Type

*/

UserDefinedPres_1139_Type::UserDefinedPres_1139_Type()
{
  MaxDeviationStats = 0;
  MinDeviationStats = 0;
}

UserDefinedPres_1139_Type::UserDefinedPres_1139_Type(
 StatsPressureType * MaxDeviationStatsIn,
 StatsPressureType * MinDeviationStatsIn)
{
  MaxDeviationStats = MaxDeviationStatsIn;
  MinDeviationStats = MinDeviationStatsIn;
}

UserDefinedPres_1139_Type::~UserDefinedPres_1139_Type()
{
  #ifndef NODESTRUCT
  delete MaxDeviationStats;
  delete MinDeviationStats;
  #endif
}

void UserDefinedPres_1139_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxDeviationStats");
  MaxDeviationStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</MaxDeviationStats>\n");
  if (MinDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

StatsPressureType * UserDefinedPres_1139_Type::getMaxDeviationStats()
{return MaxDeviationStats;}

void UserDefinedPres_1139_Type::setMaxDeviationStats(StatsPressureType * MaxDeviationStatsIn)
{MaxDeviationStats = MaxDeviationStatsIn;}

StatsPressureType * UserDefinedPres_1139_Type::getMinDeviationStats()
{return MinDeviationStats;}

void UserDefinedPres_1139_Type::setMinDeviationStats(StatsPressureType * MinDeviationStatsIn)
{MinDeviationStats = MinDeviationStatsIn;}

/* ***************************************************************** */

/* class UserDefinedSpee_1140_Type

*/

UserDefinedSpee_1140_Type::UserDefinedSpee_1140_Type()
{
  ValueStats = 0;
  MaxValueStats = 0;
  MinValueStats = 0;
}

UserDefinedSpee_1140_Type::UserDefinedSpee_1140_Type(
 StatsWithTolSpeedType * ValueStatsIn,
 StatsSpeedType * MaxValueStatsIn,
 StatsSpeedType * MinValueStatsIn)
{
  ValueStats = ValueStatsIn;
  MaxValueStats = MaxValueStatsIn;
  MinValueStats = MinValueStatsIn;
}

UserDefinedSpee_1140_Type::~UserDefinedSpee_1140_Type()
{
  #ifndef NODESTRUCT
  delete ValueStats;
  delete MaxValueStats;
  delete MinValueStats;
  #endif
}

void UserDefinedSpee_1140_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<ValueStats");
  ValueStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ValueStats>\n");
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
}

StatsWithTolSpeedType * UserDefinedSpee_1140_Type::getValueStats()
{return ValueStats;}

void UserDefinedSpee_1140_Type::setValueStats(StatsWithTolSpeedType * ValueStatsIn)
{ValueStats = ValueStatsIn;}

StatsSpeedType * UserDefinedSpee_1140_Type::getMaxValueStats()
{return MaxValueStats;}

void UserDefinedSpee_1140_Type::setMaxValueStats(StatsSpeedType * MaxValueStatsIn)
{MaxValueStats = MaxValueStatsIn;}

StatsSpeedType * UserDefinedSpee_1140_Type::getMinValueStats()
{return MinValueStats;}

void UserDefinedSpee_1140_Type::setMinValueStats(StatsSpeedType * MinValueStatsIn)
{MinValueStats = MinValueStatsIn;}

/* ***************************************************************** */

/* class UserDefinedSpee_1141_Type

*/

UserDefinedSpee_1141_Type::UserDefinedSpee_1141_Type()
{
  MaxValueStats = 0;
  MinValueStats = 0;
}

UserDefinedSpee_1141_Type::UserDefinedSpee_1141_Type(
 StatsSpeedType * MaxValueStatsIn,
 StatsSpeedType * MinValueStatsIn)
{
  MaxValueStats = MaxValueStatsIn;
  MinValueStats = MinValueStatsIn;
}

UserDefinedSpee_1141_Type::~UserDefinedSpee_1141_Type()
{
  #ifndef NODESTRUCT
  delete MaxValueStats;
  delete MinValueStats;
  #endif
}

void UserDefinedSpee_1141_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxValueStats");
  MaxValueStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</MaxValueStats>\n");
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
}

StatsSpeedType * UserDefinedSpee_1141_Type::getMaxValueStats()
{return MaxValueStats;}

void UserDefinedSpee_1141_Type::setMaxValueStats(StatsSpeedType * MaxValueStatsIn)
{MaxValueStats = MaxValueStatsIn;}

StatsSpeedType * UserDefinedSpee_1141_Type::getMinValueStats()
{return MinValueStats;}

void UserDefinedSpee_1141_Type::setMinValueStats(StatsSpeedType * MinValueStatsIn)
{MinValueStats = MinValueStatsIn;}

/* ***************************************************************** */

/* class UserDefinedSpee_1142_Type

*/

UserDefinedSpee_1142_Type::UserDefinedSpee_1142_Type()
{
  DeviationStats = 0;
  MaxDeviationStats = 0;
  MinDeviationStats = 0;
}

UserDefinedSpee_1142_Type::UserDefinedSpee_1142_Type(
 StatsWithTolSpeedType * DeviationStatsIn,
 StatsSpeedType * MaxDeviationStatsIn,
 StatsSpeedType * MinDeviationStatsIn)
{
  DeviationStats = DeviationStatsIn;
  MaxDeviationStats = MaxDeviationStatsIn;
  MinDeviationStats = MinDeviationStatsIn;
}

UserDefinedSpee_1142_Type::~UserDefinedSpee_1142_Type()
{
  #ifndef NODESTRUCT
  delete DeviationStats;
  delete MaxDeviationStats;
  delete MinDeviationStats;
  #endif
}

void UserDefinedSpee_1142_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<DeviationStats");
  DeviationStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeviationStats>\n");
  if (MaxDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxDeviationStats");
      MaxDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxDeviationStats>\n");
    }
  if (MinDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

StatsWithTolSpeedType * UserDefinedSpee_1142_Type::getDeviationStats()
{return DeviationStats;}

void UserDefinedSpee_1142_Type::setDeviationStats(StatsWithTolSpeedType * DeviationStatsIn)
{DeviationStats = DeviationStatsIn;}

StatsSpeedType * UserDefinedSpee_1142_Type::getMaxDeviationStats()
{return MaxDeviationStats;}

void UserDefinedSpee_1142_Type::setMaxDeviationStats(StatsSpeedType * MaxDeviationStatsIn)
{MaxDeviationStats = MaxDeviationStatsIn;}

StatsSpeedType * UserDefinedSpee_1142_Type::getMinDeviationStats()
{return MinDeviationStats;}

void UserDefinedSpee_1142_Type::setMinDeviationStats(StatsSpeedType * MinDeviationStatsIn)
{MinDeviationStats = MinDeviationStatsIn;}

/* ***************************************************************** */

/* class UserDefinedSpee_1143_Type

*/

UserDefinedSpee_1143_Type::UserDefinedSpee_1143_Type()
{
  MaxDeviationStats = 0;
  MinDeviationStats = 0;
}

UserDefinedSpee_1143_Type::UserDefinedSpee_1143_Type(
 StatsSpeedType * MaxDeviationStatsIn,
 StatsSpeedType * MinDeviationStatsIn)
{
  MaxDeviationStats = MaxDeviationStatsIn;
  MinDeviationStats = MinDeviationStatsIn;
}

UserDefinedSpee_1143_Type::~UserDefinedSpee_1143_Type()
{
  #ifndef NODESTRUCT
  delete MaxDeviationStats;
  delete MinDeviationStats;
  #endif
}

void UserDefinedSpee_1143_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxDeviationStats");
  MaxDeviationStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</MaxDeviationStats>\n");
  if (MinDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

StatsSpeedType * UserDefinedSpee_1143_Type::getMaxDeviationStats()
{return MaxDeviationStats;}

void UserDefinedSpee_1143_Type::setMaxDeviationStats(StatsSpeedType * MaxDeviationStatsIn)
{MaxDeviationStats = MaxDeviationStatsIn;}

StatsSpeedType * UserDefinedSpee_1143_Type::getMinDeviationStats()
{return MinDeviationStats;}

void UserDefinedSpee_1143_Type::setMinDeviationStats(StatsSpeedType * MinDeviationStatsIn)
{MinDeviationStats = MinDeviationStatsIn;}

/* ***************************************************************** */

/* class UserDefinedTemp_1144_Type

*/

UserDefinedTemp_1144_Type::UserDefinedTemp_1144_Type()
{
  ValueStats = 0;
  MaxValueStats = 0;
  MinValueStats = 0;
}

UserDefinedTemp_1144_Type::UserDefinedTemp_1144_Type(
 StatsWithTolTemperatureType * ValueStatsIn,
 StatsTemperatureType * MaxValueStatsIn,
 StatsTemperatureType * MinValueStatsIn)
{
  ValueStats = ValueStatsIn;
  MaxValueStats = MaxValueStatsIn;
  MinValueStats = MinValueStatsIn;
}

UserDefinedTemp_1144_Type::~UserDefinedTemp_1144_Type()
{
  #ifndef NODESTRUCT
  delete ValueStats;
  delete MaxValueStats;
  delete MinValueStats;
  #endif
}

void UserDefinedTemp_1144_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<ValueStats");
  ValueStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ValueStats>\n");
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
}

StatsWithTolTemperatureType * UserDefinedTemp_1144_Type::getValueStats()
{return ValueStats;}

void UserDefinedTemp_1144_Type::setValueStats(StatsWithTolTemperatureType * ValueStatsIn)
{ValueStats = ValueStatsIn;}

StatsTemperatureType * UserDefinedTemp_1144_Type::getMaxValueStats()
{return MaxValueStats;}

void UserDefinedTemp_1144_Type::setMaxValueStats(StatsTemperatureType * MaxValueStatsIn)
{MaxValueStats = MaxValueStatsIn;}

StatsTemperatureType * UserDefinedTemp_1144_Type::getMinValueStats()
{return MinValueStats;}

void UserDefinedTemp_1144_Type::setMinValueStats(StatsTemperatureType * MinValueStatsIn)
{MinValueStats = MinValueStatsIn;}

/* ***************************************************************** */

/* class UserDefinedTemp_1145_Type

*/

UserDefinedTemp_1145_Type::UserDefinedTemp_1145_Type()
{
  MaxValueStats = 0;
  MinValueStats = 0;
}

UserDefinedTemp_1145_Type::UserDefinedTemp_1145_Type(
 StatsTemperatureType * MaxValueStatsIn,
 StatsTemperatureType * MinValueStatsIn)
{
  MaxValueStats = MaxValueStatsIn;
  MinValueStats = MinValueStatsIn;
}

UserDefinedTemp_1145_Type::~UserDefinedTemp_1145_Type()
{
  #ifndef NODESTRUCT
  delete MaxValueStats;
  delete MinValueStats;
  #endif
}

void UserDefinedTemp_1145_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxValueStats");
  MaxValueStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</MaxValueStats>\n");
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
}

StatsTemperatureType * UserDefinedTemp_1145_Type::getMaxValueStats()
{return MaxValueStats;}

void UserDefinedTemp_1145_Type::setMaxValueStats(StatsTemperatureType * MaxValueStatsIn)
{MaxValueStats = MaxValueStatsIn;}

StatsTemperatureType * UserDefinedTemp_1145_Type::getMinValueStats()
{return MinValueStats;}

void UserDefinedTemp_1145_Type::setMinValueStats(StatsTemperatureType * MinValueStatsIn)
{MinValueStats = MinValueStatsIn;}

/* ***************************************************************** */

/* class UserDefinedTemp_1146_Type

*/

UserDefinedTemp_1146_Type::UserDefinedTemp_1146_Type()
{
  DeviationStats = 0;
  MaxDeviationStats = 0;
  MinDeviationStats = 0;
}

UserDefinedTemp_1146_Type::UserDefinedTemp_1146_Type(
 StatsWithTolTemperatureType * DeviationStatsIn,
 StatsTemperatureType * MaxDeviationStatsIn,
 StatsTemperatureType * MinDeviationStatsIn)
{
  DeviationStats = DeviationStatsIn;
  MaxDeviationStats = MaxDeviationStatsIn;
  MinDeviationStats = MinDeviationStatsIn;
}

UserDefinedTemp_1146_Type::~UserDefinedTemp_1146_Type()
{
  #ifndef NODESTRUCT
  delete DeviationStats;
  delete MaxDeviationStats;
  delete MinDeviationStats;
  #endif
}

void UserDefinedTemp_1146_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<DeviationStats");
  DeviationStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeviationStats>\n");
  if (MaxDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxDeviationStats");
      MaxDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxDeviationStats>\n");
    }
  if (MinDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

StatsWithTolTemperatureType * UserDefinedTemp_1146_Type::getDeviationStats()
{return DeviationStats;}

void UserDefinedTemp_1146_Type::setDeviationStats(StatsWithTolTemperatureType * DeviationStatsIn)
{DeviationStats = DeviationStatsIn;}

StatsTemperatureType * UserDefinedTemp_1146_Type::getMaxDeviationStats()
{return MaxDeviationStats;}

void UserDefinedTemp_1146_Type::setMaxDeviationStats(StatsTemperatureType * MaxDeviationStatsIn)
{MaxDeviationStats = MaxDeviationStatsIn;}

StatsTemperatureType * UserDefinedTemp_1146_Type::getMinDeviationStats()
{return MinDeviationStats;}

void UserDefinedTemp_1146_Type::setMinDeviationStats(StatsTemperatureType * MinDeviationStatsIn)
{MinDeviationStats = MinDeviationStatsIn;}

/* ***************************************************************** */

/* class UserDefinedTemp_1147_Type

*/

UserDefinedTemp_1147_Type::UserDefinedTemp_1147_Type()
{
  MaxDeviationStats = 0;
  MinDeviationStats = 0;
}

UserDefinedTemp_1147_Type::UserDefinedTemp_1147_Type(
 StatsTemperatureType * MaxDeviationStatsIn,
 StatsTemperatureType * MinDeviationStatsIn)
{
  MaxDeviationStats = MaxDeviationStatsIn;
  MinDeviationStats = MinDeviationStatsIn;
}

UserDefinedTemp_1147_Type::~UserDefinedTemp_1147_Type()
{
  #ifndef NODESTRUCT
  delete MaxDeviationStats;
  delete MinDeviationStats;
  #endif
}

void UserDefinedTemp_1147_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxDeviationStats");
  MaxDeviationStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</MaxDeviationStats>\n");
  if (MinDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

StatsTemperatureType * UserDefinedTemp_1147_Type::getMaxDeviationStats()
{return MaxDeviationStats;}

void UserDefinedTemp_1147_Type::setMaxDeviationStats(StatsTemperatureType * MaxDeviationStatsIn)
{MaxDeviationStats = MaxDeviationStatsIn;}

StatsTemperatureType * UserDefinedTemp_1147_Type::getMinDeviationStats()
{return MinDeviationStats;}

void UserDefinedTemp_1147_Type::setMinDeviationStats(StatsTemperatureType * MinDeviationStatsIn)
{MinDeviationStats = MinDeviationStatsIn;}

/* ***************************************************************** */

/* class UserDefinedTime_1148_Type

*/

UserDefinedTime_1148_Type::UserDefinedTime_1148_Type()
{
  ValueStats = 0;
  MaxValueStats = 0;
  MinValueStats = 0;
}

UserDefinedTime_1148_Type::UserDefinedTime_1148_Type(
 StatsWithTolTimeType * ValueStatsIn,
 StatsTimeType * MaxValueStatsIn,
 StatsTimeType * MinValueStatsIn)
{
  ValueStats = ValueStatsIn;
  MaxValueStats = MaxValueStatsIn;
  MinValueStats = MinValueStatsIn;
}

UserDefinedTime_1148_Type::~UserDefinedTime_1148_Type()
{
  #ifndef NODESTRUCT
  delete ValueStats;
  delete MaxValueStats;
  delete MinValueStats;
  #endif
}

void UserDefinedTime_1148_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<ValueStats");
  ValueStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ValueStats>\n");
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
}

StatsWithTolTimeType * UserDefinedTime_1148_Type::getValueStats()
{return ValueStats;}

void UserDefinedTime_1148_Type::setValueStats(StatsWithTolTimeType * ValueStatsIn)
{ValueStats = ValueStatsIn;}

StatsTimeType * UserDefinedTime_1148_Type::getMaxValueStats()
{return MaxValueStats;}

void UserDefinedTime_1148_Type::setMaxValueStats(StatsTimeType * MaxValueStatsIn)
{MaxValueStats = MaxValueStatsIn;}

StatsTimeType * UserDefinedTime_1148_Type::getMinValueStats()
{return MinValueStats;}

void UserDefinedTime_1148_Type::setMinValueStats(StatsTimeType * MinValueStatsIn)
{MinValueStats = MinValueStatsIn;}

/* ***************************************************************** */

/* class UserDefinedTime_1149_Type

*/

UserDefinedTime_1149_Type::UserDefinedTime_1149_Type()
{
  MaxValueStats = 0;
  MinValueStats = 0;
}

UserDefinedTime_1149_Type::UserDefinedTime_1149_Type(
 StatsTimeType * MaxValueStatsIn,
 StatsTimeType * MinValueStatsIn)
{
  MaxValueStats = MaxValueStatsIn;
  MinValueStats = MinValueStatsIn;
}

UserDefinedTime_1149_Type::~UserDefinedTime_1149_Type()
{
  #ifndef NODESTRUCT
  delete MaxValueStats;
  delete MinValueStats;
  #endif
}

void UserDefinedTime_1149_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxValueStats");
  MaxValueStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</MaxValueStats>\n");
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
}

StatsTimeType * UserDefinedTime_1149_Type::getMaxValueStats()
{return MaxValueStats;}

void UserDefinedTime_1149_Type::setMaxValueStats(StatsTimeType * MaxValueStatsIn)
{MaxValueStats = MaxValueStatsIn;}

StatsTimeType * UserDefinedTime_1149_Type::getMinValueStats()
{return MinValueStats;}

void UserDefinedTime_1149_Type::setMinValueStats(StatsTimeType * MinValueStatsIn)
{MinValueStats = MinValueStatsIn;}

/* ***************************************************************** */

/* class UserDefinedTime_1150_Type

*/

UserDefinedTime_1150_Type::UserDefinedTime_1150_Type()
{
  DeviationStats = 0;
  MaxDeviationStats = 0;
  MinDeviationStats = 0;
}

UserDefinedTime_1150_Type::UserDefinedTime_1150_Type(
 StatsWithTolTimeType * DeviationStatsIn,
 StatsTimeType * MaxDeviationStatsIn,
 StatsTimeType * MinDeviationStatsIn)
{
  DeviationStats = DeviationStatsIn;
  MaxDeviationStats = MaxDeviationStatsIn;
  MinDeviationStats = MinDeviationStatsIn;
}

UserDefinedTime_1150_Type::~UserDefinedTime_1150_Type()
{
  #ifndef NODESTRUCT
  delete DeviationStats;
  delete MaxDeviationStats;
  delete MinDeviationStats;
  #endif
}

void UserDefinedTime_1150_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<DeviationStats");
  DeviationStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeviationStats>\n");
  if (MaxDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxDeviationStats");
      MaxDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxDeviationStats>\n");
    }
  if (MinDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

StatsWithTolTimeType * UserDefinedTime_1150_Type::getDeviationStats()
{return DeviationStats;}

void UserDefinedTime_1150_Type::setDeviationStats(StatsWithTolTimeType * DeviationStatsIn)
{DeviationStats = DeviationStatsIn;}

StatsTimeType * UserDefinedTime_1150_Type::getMaxDeviationStats()
{return MaxDeviationStats;}

void UserDefinedTime_1150_Type::setMaxDeviationStats(StatsTimeType * MaxDeviationStatsIn)
{MaxDeviationStats = MaxDeviationStatsIn;}

StatsTimeType * UserDefinedTime_1150_Type::getMinDeviationStats()
{return MinDeviationStats;}

void UserDefinedTime_1150_Type::setMinDeviationStats(StatsTimeType * MinDeviationStatsIn)
{MinDeviationStats = MinDeviationStatsIn;}

/* ***************************************************************** */

/* class UserDefinedTime_1151_Type

*/

UserDefinedTime_1151_Type::UserDefinedTime_1151_Type()
{
  MaxDeviationStats = 0;
  MinDeviationStats = 0;
}

UserDefinedTime_1151_Type::UserDefinedTime_1151_Type(
 StatsTimeType * MaxDeviationStatsIn,
 StatsTimeType * MinDeviationStatsIn)
{
  MaxDeviationStats = MaxDeviationStatsIn;
  MinDeviationStats = MinDeviationStatsIn;
}

UserDefinedTime_1151_Type::~UserDefinedTime_1151_Type()
{
  #ifndef NODESTRUCT
  delete MaxDeviationStats;
  delete MinDeviationStats;
  #endif
}

void UserDefinedTime_1151_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxDeviationStats");
  MaxDeviationStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</MaxDeviationStats>\n");
  if (MinDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

StatsTimeType * UserDefinedTime_1151_Type::getMaxDeviationStats()
{return MaxDeviationStats;}

void UserDefinedTime_1151_Type::setMaxDeviationStats(StatsTimeType * MaxDeviationStatsIn)
{MaxDeviationStats = MaxDeviationStatsIn;}

StatsTimeType * UserDefinedTime_1151_Type::getMinDeviationStats()
{return MinDeviationStats;}

void UserDefinedTime_1151_Type::setMinDeviationStats(StatsTimeType * MinDeviationStatsIn)
{MinDeviationStats = MinDeviationStatsIn;}

/* ***************************************************************** */

/* class UserDefinedUnit_1152_Type

*/

UserDefinedUnit_1152_Type::UserDefinedUnit_1152_Type()
{
  ValueStats = 0;
  MaxValueStats = 0;
  MinValueStats = 0;
}

UserDefinedUnit_1152_Type::UserDefinedUnit_1152_Type(
 StatsWithTolUserDefinedUnitType * ValueStatsIn,
 StatsUserDefinedUnitType * MaxValueStatsIn,
 StatsUserDefinedUnitType * MinValueStatsIn)
{
  ValueStats = ValueStatsIn;
  MaxValueStats = MaxValueStatsIn;
  MinValueStats = MinValueStatsIn;
}

UserDefinedUnit_1152_Type::~UserDefinedUnit_1152_Type()
{
  #ifndef NODESTRUCT
  delete ValueStats;
  delete MaxValueStats;
  delete MinValueStats;
  #endif
}

void UserDefinedUnit_1152_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<ValueStats");
  ValueStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</ValueStats>\n");
  if (MaxValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxValueStats");
      MaxValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxValueStats>\n");
    }
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
}

StatsWithTolUserDefinedUnitType * UserDefinedUnit_1152_Type::getValueStats()
{return ValueStats;}

void UserDefinedUnit_1152_Type::setValueStats(StatsWithTolUserDefinedUnitType * ValueStatsIn)
{ValueStats = ValueStatsIn;}

StatsUserDefinedUnitType * UserDefinedUnit_1152_Type::getMaxValueStats()
{return MaxValueStats;}

void UserDefinedUnit_1152_Type::setMaxValueStats(StatsUserDefinedUnitType * MaxValueStatsIn)
{MaxValueStats = MaxValueStatsIn;}

StatsUserDefinedUnitType * UserDefinedUnit_1152_Type::getMinValueStats()
{return MinValueStats;}

void UserDefinedUnit_1152_Type::setMinValueStats(StatsUserDefinedUnitType * MinValueStatsIn)
{MinValueStats = MinValueStatsIn;}

/* ***************************************************************** */

/* class UserDefinedUnit_1153_Type

*/

UserDefinedUnit_1153_Type::UserDefinedUnit_1153_Type()
{
  MaxValueStats = 0;
  MinValueStats = 0;
}

UserDefinedUnit_1153_Type::UserDefinedUnit_1153_Type(
 StatsUserDefinedUnitType * MaxValueStatsIn,
 StatsUserDefinedUnitType * MinValueStatsIn)
{
  MaxValueStats = MaxValueStatsIn;
  MinValueStats = MinValueStatsIn;
}

UserDefinedUnit_1153_Type::~UserDefinedUnit_1153_Type()
{
  #ifndef NODESTRUCT
  delete MaxValueStats;
  delete MinValueStats;
  #endif
}

void UserDefinedUnit_1153_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxValueStats");
  MaxValueStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</MaxValueStats>\n");
  if (MinValueStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinValueStats");
      MinValueStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinValueStats>\n");
    }
}

StatsUserDefinedUnitType * UserDefinedUnit_1153_Type::getMaxValueStats()
{return MaxValueStats;}

void UserDefinedUnit_1153_Type::setMaxValueStats(StatsUserDefinedUnitType * MaxValueStatsIn)
{MaxValueStats = MaxValueStatsIn;}

StatsUserDefinedUnitType * UserDefinedUnit_1153_Type::getMinValueStats()
{return MinValueStats;}

void UserDefinedUnit_1153_Type::setMinValueStats(StatsUserDefinedUnitType * MinValueStatsIn)
{MinValueStats = MinValueStatsIn;}

/* ***************************************************************** */

/* class UserDefinedUnit_1154_Type

*/

UserDefinedUnit_1154_Type::UserDefinedUnit_1154_Type()
{
  DeviationStats = 0;
  MaxDeviationStats = 0;
  MinDeviationStats = 0;
}

UserDefinedUnit_1154_Type::UserDefinedUnit_1154_Type(
 StatsWithTolUserDefinedUnitType * DeviationStatsIn,
 StatsUserDefinedUnitType * MaxDeviationStatsIn,
 StatsUserDefinedUnitType * MinDeviationStatsIn)
{
  DeviationStats = DeviationStatsIn;
  MaxDeviationStats = MaxDeviationStatsIn;
  MinDeviationStats = MinDeviationStatsIn;
}

UserDefinedUnit_1154_Type::~UserDefinedUnit_1154_Type()
{
  #ifndef NODESTRUCT
  delete DeviationStats;
  delete MaxDeviationStats;
  delete MinDeviationStats;
  #endif
}

void UserDefinedUnit_1154_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<DeviationStats");
  DeviationStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</DeviationStats>\n");
  if (MaxDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MaxDeviationStats");
      MaxDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MaxDeviationStats>\n");
    }
  if (MinDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

StatsWithTolUserDefinedUnitType * UserDefinedUnit_1154_Type::getDeviationStats()
{return DeviationStats;}

void UserDefinedUnit_1154_Type::setDeviationStats(StatsWithTolUserDefinedUnitType * DeviationStatsIn)
{DeviationStats = DeviationStatsIn;}

StatsUserDefinedUnitType * UserDefinedUnit_1154_Type::getMaxDeviationStats()
{return MaxDeviationStats;}

void UserDefinedUnit_1154_Type::setMaxDeviationStats(StatsUserDefinedUnitType * MaxDeviationStatsIn)
{MaxDeviationStats = MaxDeviationStatsIn;}

StatsUserDefinedUnitType * UserDefinedUnit_1154_Type::getMinDeviationStats()
{return MinDeviationStats;}

void UserDefinedUnit_1154_Type::setMinDeviationStats(StatsUserDefinedUnitType * MinDeviationStatsIn)
{MinDeviationStats = MinDeviationStatsIn;}

/* ***************************************************************** */

/* class UserDefinedUnit_1155_Type

*/

UserDefinedUnit_1155_Type::UserDefinedUnit_1155_Type()
{
  MaxDeviationStats = 0;
  MinDeviationStats = 0;
}

UserDefinedUnit_1155_Type::UserDefinedUnit_1155_Type(
 StatsUserDefinedUnitType * MaxDeviationStatsIn,
 StatsUserDefinedUnitType * MinDeviationStatsIn)
{
  MaxDeviationStats = MaxDeviationStatsIn;
  MinDeviationStats = MinDeviationStatsIn;
}

UserDefinedUnit_1155_Type::~UserDefinedUnit_1155_Type()
{
  #ifndef NODESTRUCT
  delete MaxDeviationStats;
  delete MinDeviationStats;
  #endif
}

void UserDefinedUnit_1155_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<MaxDeviationStats");
  MaxDeviationStats->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</MaxDeviationStats>\n");
  if (MinDeviationStats)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MinDeviationStats");
      MinDeviationStats->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MinDeviationStats>\n");
    }
}

StatsUserDefinedUnitType * UserDefinedUnit_1155_Type::getMaxDeviationStats()
{return MaxDeviationStats;}

void UserDefinedUnit_1155_Type::setMaxDeviationStats(StatsUserDefinedUnitType * MaxDeviationStatsIn)
{MaxDeviationStats = MaxDeviationStatsIn;}

StatsUserDefinedUnitType * UserDefinedUnit_1155_Type::getMinDeviationStats()
{return MinDeviationStats;}

void UserDefinedUnit_1155_Type::setMinDeviationStats(StatsUserDefinedUnitType * MinDeviationStatsIn)
{MinDeviationStats = MinDeviationStatsIn;}

/* ***************************************************************** */

/* class CharacteristicS_1156_Type

*/

CharacteristicS_1156_Type::CharacteristicS_1156_Type()
{
  CharacteristicS_1156_TypePair = 0;
}

CharacteristicS_1156_Type::CharacteristicS_1156_Type(
 CharacteristicS_1156_TypeChoicePair * CharacteristicS_1156_TypePairIn)
{
  CharacteristicS_1156_TypePair = CharacteristicS_1156_TypePairIn;
}

CharacteristicS_1156_Type::~CharacteristicS_1156_Type()
{
  #ifndef NODESTRUCT
  delete CharacteristicS_1156_TypePair;
  #endif
}

void CharacteristicS_1156_Type::printSelf(FILE * outFile)
{
  CharacteristicS_1156_TypePair->printSelf(outFile);
}

CharacteristicS_1156_TypeChoicePair * CharacteristicS_1156_Type::getCharacteristicS_1156_TypePair()
{return CharacteristicS_1156_TypePair;}

void CharacteristicS_1156_Type::setCharacteristicS_1156_TypePair(CharacteristicS_1156_TypeChoicePair * CharacteristicS_1156_TypePairIn)
{CharacteristicS_1156_TypePair = CharacteristicS_1156_TypePairIn;}
CharacteristicS_1156_TypeChoicePair::CharacteristicS_1156_TypeChoicePair() {}

CharacteristicS_1156_TypeChoicePair::CharacteristicS_1156_TypeChoicePair(
 whichOne CharacteristicS_1156_TypeTypeIn,
 CharacteristicS_1156_TypeVal CharacteristicS_1156_TypeValueIn)
{
  CharacteristicS_1156_TypeType = CharacteristicS_1156_TypeTypeIn;
  CharacteristicS_1156_TypeValue = CharacteristicS_1156_TypeValueIn;
}

CharacteristicS_1156_TypeChoicePair::~CharacteristicS_1156_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (CharacteristicS_1156_TypeType == MeasuredIdsE)
    delete CharacteristicS_1156_TypeValue.MeasuredIds;
  else if (CharacteristicS_1156_TypeType == SubgroupsE)
    delete CharacteristicS_1156_TypeValue.Subgroups;
  #endif
}

void CharacteristicS_1156_TypeChoicePair::printSelf(FILE * outFile)
{
  if (CharacteristicS_1156_TypeType == MeasuredIdsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasuredIds");
      CharacteristicS_1156_TypeValue.MeasuredIds->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasuredIds>\n");
    }
  else if (CharacteristicS_1156_TypeType == SubgroupsE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<Subgroups");
      CharacteristicS_1156_TypeValue.Subgroups->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</Subgroups>\n");
    }
}

/* ***************************************************************** */

/* class CharacteristicS_1157_Type

*/

CharacteristicS_1157_Type::CharacteristicS_1157_Type()
{
  CharacteristicS_1157_TypePair = 0;
}

CharacteristicS_1157_Type::CharacteristicS_1157_Type(
 CharacteristicS_1157_TypeChoicePair * CharacteristicS_1157_TypePairIn)
{
  CharacteristicS_1157_TypePair = CharacteristicS_1157_TypePairIn;
}

CharacteristicS_1157_Type::~CharacteristicS_1157_Type()
{
  #ifndef NODESTRUCT
  delete CharacteristicS_1157_TypePair;
  #endif
}

void CharacteristicS_1157_Type::printSelf(FILE * outFile)
{
  CharacteristicS_1157_TypePair->printSelf(outFile);
}

CharacteristicS_1157_TypeChoicePair * CharacteristicS_1157_Type::getCharacteristicS_1157_TypePair()
{return CharacteristicS_1157_TypePair;}

void CharacteristicS_1157_Type::setCharacteristicS_1157_TypePair(CharacteristicS_1157_TypeChoicePair * CharacteristicS_1157_TypePairIn)
{CharacteristicS_1157_TypePair = CharacteristicS_1157_TypePairIn;}
CharacteristicS_1157_TypeChoicePair::CharacteristicS_1157_TypeChoicePair() {}

CharacteristicS_1157_TypeChoicePair::CharacteristicS_1157_TypeChoicePair(
 whichOne CharacteristicS_1157_TypeTypeIn,
 CharacteristicS_1157_TypeVal CharacteristicS_1157_TypeValueIn)
{
  CharacteristicS_1157_TypeType = CharacteristicS_1157_TypeTypeIn;
  CharacteristicS_1157_TypeValue = CharacteristicS_1157_TypeValueIn;
}

CharacteristicS_1157_TypeChoicePair::~CharacteristicS_1157_TypeChoicePair()
{
  #ifndef NODESTRUCT
  if (CharacteristicS_1157_TypeType == MeasuredValuesE)
    delete CharacteristicS_1157_TypeValue.MeasuredValues;
  else if (CharacteristicS_1157_TypeType == SubgroupValuesE)
    delete CharacteristicS_1157_TypeValue.SubgroupValues;
  #endif
}

void CharacteristicS_1157_TypeChoicePair::printSelf(FILE * outFile)
{
  if (CharacteristicS_1157_TypeType == MeasuredValuesE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<MeasuredValues");
      CharacteristicS_1157_TypeValue.MeasuredValues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</MeasuredValues>\n");
    }
  else if (CharacteristicS_1157_TypeType == SubgroupValuesE)
    {
      doSpaces(0, outFile);
      fprintf(outFile, "<SubgroupValues");
      CharacteristicS_1157_TypeValue.SubgroupValues->printSelf(outFile);
      doSpaces(0, outFile);
      fprintf(outFile, "</SubgroupValues>\n");
    }
}

/* ***************************************************************** */

/* class SamplingMethodT_1158_Type

*/

SamplingMethodT_1158_Type::SamplingMethodT_1158_Type()
{
  SamplingFrequency = 0;
  SamplingInterval = 0;
}

SamplingMethodT_1158_Type::SamplingMethodT_1158_Type(
 XmlPositiveInteger * SamplingFrequencyIn,
 SamplingIntervalType * SamplingIntervalIn)
{
  SamplingFrequency = SamplingFrequencyIn;
  SamplingInterval = SamplingIntervalIn;
}

SamplingMethodT_1158_Type::~SamplingMethodT_1158_Type()
{
  #ifndef NODESTRUCT
  delete SamplingFrequency;
  delete SamplingInterval;
  #endif
}

void SamplingMethodT_1158_Type::printSelf(FILE * outFile)
{
  doSpaces(0, outFile);
  fprintf(outFile, "<SamplingFrequency");
  SamplingFrequency->printSelf(outFile);
  fprintf(outFile, "</SamplingFrequency>\n");
  doSpaces(0, outFile);
  fprintf(outFile, "<SamplingInterval");
  SamplingInterval->printSelf(outFile);
  doSpaces(0, outFile);
  fprintf(outFile, "</SamplingInterval>\n");
}

XmlPositiveInteger * SamplingMethodT_1158_Type::getSamplingFrequency()
{return SamplingFrequency;}

void SamplingMethodT_1158_Type::setSamplingFrequency(XmlPositiveInteger * SamplingFrequencyIn)
{SamplingFrequency = SamplingFrequencyIn;}

SamplingIntervalType * SamplingMethodT_1158_Type::getSamplingInterval()
{return SamplingInterval;}

void SamplingMethodT_1158_Type::setSamplingInterval(SamplingIntervalType * SamplingIntervalIn)
{SamplingInterval = SamplingIntervalIn;}

/* ***************************************************************** */

