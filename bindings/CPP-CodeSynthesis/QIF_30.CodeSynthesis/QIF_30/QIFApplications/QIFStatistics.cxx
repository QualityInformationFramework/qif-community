// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "QIFStatistics.hxx"

namespace xsd
{
  namespace qif30
  {
    // StatisticalStudyPlanBaseType
    //

    const StatisticalStudyPlanBaseType::Version_optional& StatisticalStudyPlanBaseType::
    Version () const
    {
      return this->Version_;
    }

    StatisticalStudyPlanBaseType::Version_optional& StatisticalStudyPlanBaseType::
    Version ()
    {
      return this->Version_;
    }

    void StatisticalStudyPlanBaseType::
    Version (const Version_type& x)
    {
      this->Version_.set (x);
    }

    void StatisticalStudyPlanBaseType::
    Version (const Version_optional& x)
    {
      this->Version_ = x;
    }

    void StatisticalStudyPlanBaseType::
    Version (::std::unique_ptr< Version_type > x)
    {
      this->Version_.set (std::move (x));
    }

    const StatisticalStudyPlanBaseType::Attributes_optional& StatisticalStudyPlanBaseType::
    Attributes () const
    {
      return this->Attributes_;
    }

    StatisticalStudyPlanBaseType::Attributes_optional& StatisticalStudyPlanBaseType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void StatisticalStudyPlanBaseType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void StatisticalStudyPlanBaseType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void StatisticalStudyPlanBaseType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const StatisticalStudyPlanBaseType::FeatureItemIds_optional& StatisticalStudyPlanBaseType::
    FeatureItemIds () const
    {
      return this->FeatureItemIds_;
    }

    StatisticalStudyPlanBaseType::FeatureItemIds_optional& StatisticalStudyPlanBaseType::
    FeatureItemIds ()
    {
      return this->FeatureItemIds_;
    }

    void StatisticalStudyPlanBaseType::
    FeatureItemIds (const FeatureItemIds_type& x)
    {
      this->FeatureItemIds_.set (x);
    }

    void StatisticalStudyPlanBaseType::
    FeatureItemIds (const FeatureItemIds_optional& x)
    {
      this->FeatureItemIds_ = x;
    }

    void StatisticalStudyPlanBaseType::
    FeatureItemIds (::std::unique_ptr< FeatureItemIds_type > x)
    {
      this->FeatureItemIds_.set (std::move (x));
    }

    const StatisticalStudyPlanBaseType::CalculateAverageFeatures_optional& StatisticalStudyPlanBaseType::
    CalculateAverageFeatures () const
    {
      return this->CalculateAverageFeatures_;
    }

    StatisticalStudyPlanBaseType::CalculateAverageFeatures_optional& StatisticalStudyPlanBaseType::
    CalculateAverageFeatures ()
    {
      return this->CalculateAverageFeatures_;
    }

    void StatisticalStudyPlanBaseType::
    CalculateAverageFeatures (const CalculateAverageFeatures_type& x)
    {
      this->CalculateAverageFeatures_.set (x);
    }

    void StatisticalStudyPlanBaseType::
    CalculateAverageFeatures (const CalculateAverageFeatures_optional& x)
    {
      this->CalculateAverageFeatures_ = x;
    }

    const StatisticalStudyPlanBaseType::CharacteristicItemIds_optional& StatisticalStudyPlanBaseType::
    CharacteristicItemIds () const
    {
      return this->CharacteristicItemIds_;
    }

    StatisticalStudyPlanBaseType::CharacteristicItemIds_optional& StatisticalStudyPlanBaseType::
    CharacteristicItemIds ()
    {
      return this->CharacteristicItemIds_;
    }

    void StatisticalStudyPlanBaseType::
    CharacteristicItemIds (const CharacteristicItemIds_type& x)
    {
      this->CharacteristicItemIds_.set (x);
    }

    void StatisticalStudyPlanBaseType::
    CharacteristicItemIds (const CharacteristicItemIds_optional& x)
    {
      this->CharacteristicItemIds_ = x;
    }

    void StatisticalStudyPlanBaseType::
    CharacteristicItemIds (::std::unique_ptr< CharacteristicItemIds_type > x)
    {
      this->CharacteristicItemIds_.set (std::move (x));
    }

    const StatisticalStudyPlanBaseType::StatsValuesPerChar_sequence& StatisticalStudyPlanBaseType::
    StatsValuesPerChar () const
    {
      return this->StatsValuesPerChar_;
    }

    StatisticalStudyPlanBaseType::StatsValuesPerChar_sequence& StatisticalStudyPlanBaseType::
    StatsValuesPerChar ()
    {
      return this->StatsValuesPerChar_;
    }

    void StatisticalStudyPlanBaseType::
    StatsValuesPerChar (const StatsValuesPerChar_sequence& s)
    {
      this->StatsValuesPerChar_ = s;
    }

    const StatisticalStudyPlanBaseType::StatsValuesPerSubgroup_sequence& StatisticalStudyPlanBaseType::
    StatsValuesPerSubgroup () const
    {
      return this->StatsValuesPerSubgroup_;
    }

    StatisticalStudyPlanBaseType::StatsValuesPerSubgroup_sequence& StatisticalStudyPlanBaseType::
    StatsValuesPerSubgroup ()
    {
      return this->StatsValuesPerSubgroup_;
    }

    void StatisticalStudyPlanBaseType::
    StatsValuesPerSubgroup (const StatsValuesPerSubgroup_sequence& s)
    {
      this->StatsValuesPerSubgroup_ = s;
    }

    const StatisticalStudyPlanBaseType::StatsValuesSummarys_sequence& StatisticalStudyPlanBaseType::
    StatsValuesSummarys () const
    {
      return this->StatsValuesSummarys_;
    }

    StatisticalStudyPlanBaseType::StatsValuesSummarys_sequence& StatisticalStudyPlanBaseType::
    StatsValuesSummarys ()
    {
      return this->StatsValuesSummarys_;
    }

    void StatisticalStudyPlanBaseType::
    StatsValuesSummarys (const StatsValuesSummarys_sequence& s)
    {
      this->StatsValuesSummarys_ = s;
    }

    const StatisticalStudyPlanBaseType::PreInspectionTraceability_optional& StatisticalStudyPlanBaseType::
    PreInspectionTraceability () const
    {
      return this->PreInspectionTraceability_;
    }

    StatisticalStudyPlanBaseType::PreInspectionTraceability_optional& StatisticalStudyPlanBaseType::
    PreInspectionTraceability ()
    {
      return this->PreInspectionTraceability_;
    }

    void StatisticalStudyPlanBaseType::
    PreInspectionTraceability (const PreInspectionTraceability_type& x)
    {
      this->PreInspectionTraceability_.set (x);
    }

    void StatisticalStudyPlanBaseType::
    PreInspectionTraceability (const PreInspectionTraceability_optional& x)
    {
      this->PreInspectionTraceability_ = x;
    }

    void StatisticalStudyPlanBaseType::
    PreInspectionTraceability (::std::unique_ptr< PreInspectionTraceability_type > x)
    {
      this->PreInspectionTraceability_.set (std::move (x));
    }

    const StatisticalStudyPlanBaseType::Name_optional& StatisticalStudyPlanBaseType::
    Name () const
    {
      return this->Name_;
    }

    StatisticalStudyPlanBaseType::Name_optional& StatisticalStudyPlanBaseType::
    Name ()
    {
      return this->Name_;
    }

    void StatisticalStudyPlanBaseType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void StatisticalStudyPlanBaseType::
    Name (const Name_optional& x)
    {
      this->Name_ = x;
    }

    void StatisticalStudyPlanBaseType::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const StatisticalStudyPlanBaseType::Description_optional& StatisticalStudyPlanBaseType::
    Description () const
    {
      return this->Description_;
    }

    StatisticalStudyPlanBaseType::Description_optional& StatisticalStudyPlanBaseType::
    Description ()
    {
      return this->Description_;
    }

    void StatisticalStudyPlanBaseType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void StatisticalStudyPlanBaseType::
    Description (const Description_optional& x)
    {
      this->Description_ = x;
    }

    void StatisticalStudyPlanBaseType::
    Description (::std::unique_ptr< Description_type > x)
    {
      this->Description_.set (std::move (x));
    }

    const StatisticalStudyPlanBaseType::PlanId_optional& StatisticalStudyPlanBaseType::
    PlanId () const
    {
      return this->PlanId_;
    }

    StatisticalStudyPlanBaseType::PlanId_optional& StatisticalStudyPlanBaseType::
    PlanId ()
    {
      return this->PlanId_;
    }

    void StatisticalStudyPlanBaseType::
    PlanId (const PlanId_type& x)
    {
      this->PlanId_.set (x);
    }

    void StatisticalStudyPlanBaseType::
    PlanId (const PlanId_optional& x)
    {
      this->PlanId_ = x;
    }

    void StatisticalStudyPlanBaseType::
    PlanId (::std::unique_ptr< PlanId_type > x)
    {
      this->PlanId_.set (std::move (x));
    }

    const StatisticalStudyPlanBaseType::SoftwareId_optional& StatisticalStudyPlanBaseType::
    SoftwareId () const
    {
      return this->SoftwareId_;
    }

    StatisticalStudyPlanBaseType::SoftwareId_optional& StatisticalStudyPlanBaseType::
    SoftwareId ()
    {
      return this->SoftwareId_;
    }

    void StatisticalStudyPlanBaseType::
    SoftwareId (const SoftwareId_type& x)
    {
      this->SoftwareId_.set (x);
    }

    void StatisticalStudyPlanBaseType::
    SoftwareId (const SoftwareId_optional& x)
    {
      this->SoftwareId_ = x;
    }

    void StatisticalStudyPlanBaseType::
    SoftwareId (::std::unique_ptr< SoftwareId_type > x)
    {
      this->SoftwareId_.set (std::move (x));
    }

    const StatisticalStudyPlanBaseType::StandardId_optional& StatisticalStudyPlanBaseType::
    StandardId () const
    {
      return this->StandardId_;
    }

    StatisticalStudyPlanBaseType::StandardId_optional& StatisticalStudyPlanBaseType::
    StandardId ()
    {
      return this->StandardId_;
    }

    void StatisticalStudyPlanBaseType::
    StandardId (const StandardId_type& x)
    {
      this->StandardId_.set (x);
    }

    void StatisticalStudyPlanBaseType::
    StandardId (const StandardId_optional& x)
    {
      this->StandardId_ = x;
    }

    void StatisticalStudyPlanBaseType::
    StandardId (::std::unique_ptr< StandardId_type > x)
    {
      this->StandardId_.set (std::move (x));
    }

    const StatisticalStudyPlanBaseType::CorrectiveActionPlanId_optional& StatisticalStudyPlanBaseType::
    CorrectiveActionPlanId () const
    {
      return this->CorrectiveActionPlanId_;
    }

    StatisticalStudyPlanBaseType::CorrectiveActionPlanId_optional& StatisticalStudyPlanBaseType::
    CorrectiveActionPlanId ()
    {
      return this->CorrectiveActionPlanId_;
    }

    void StatisticalStudyPlanBaseType::
    CorrectiveActionPlanId (const CorrectiveActionPlanId_type& x)
    {
      this->CorrectiveActionPlanId_.set (x);
    }

    void StatisticalStudyPlanBaseType::
    CorrectiveActionPlanId (const CorrectiveActionPlanId_optional& x)
    {
      this->CorrectiveActionPlanId_ = x;
    }

    void StatisticalStudyPlanBaseType::
    CorrectiveActionPlanId (::std::unique_ptr< CorrectiveActionPlanId_type > x)
    {
      this->CorrectiveActionPlanId_.set (std::move (x));
    }

    const StatisticalStudyPlanBaseType::id_type& StatisticalStudyPlanBaseType::
    id () const
    {
      return this->id_.get ();
    }

    StatisticalStudyPlanBaseType::id_type& StatisticalStudyPlanBaseType::
    id ()
    {
      return this->id_.get ();
    }

    void StatisticalStudyPlanBaseType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void StatisticalStudyPlanBaseType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // AbsoluteLimitsByUnitType
    //

    const AbsoluteLimitsByUnitType::LinearLimit_optional& AbsoluteLimitsByUnitType::
    LinearLimit () const
    {
      return this->LinearLimit_;
    }

    AbsoluteLimitsByUnitType::LinearLimit_optional& AbsoluteLimitsByUnitType::
    LinearLimit ()
    {
      return this->LinearLimit_;
    }

    void AbsoluteLimitsByUnitType::
    LinearLimit (const LinearLimit_type& x)
    {
      this->LinearLimit_.set (x);
    }

    void AbsoluteLimitsByUnitType::
    LinearLimit (const LinearLimit_optional& x)
    {
      this->LinearLimit_ = x;
    }

    void AbsoluteLimitsByUnitType::
    LinearLimit (::std::unique_ptr< LinearLimit_type > x)
    {
      this->LinearLimit_.set (std::move (x));
    }

    const AbsoluteLimitsByUnitType::AngularLimit_optional& AbsoluteLimitsByUnitType::
    AngularLimit () const
    {
      return this->AngularLimit_;
    }

    AbsoluteLimitsByUnitType::AngularLimit_optional& AbsoluteLimitsByUnitType::
    AngularLimit ()
    {
      return this->AngularLimit_;
    }

    void AbsoluteLimitsByUnitType::
    AngularLimit (const AngularLimit_type& x)
    {
      this->AngularLimit_.set (x);
    }

    void AbsoluteLimitsByUnitType::
    AngularLimit (const AngularLimit_optional& x)
    {
      this->AngularLimit_ = x;
    }

    void AbsoluteLimitsByUnitType::
    AngularLimit (::std::unique_ptr< AngularLimit_type > x)
    {
      this->AngularLimit_.set (std::move (x));
    }

    const AbsoluteLimitsByUnitType::AreaLimit_optional& AbsoluteLimitsByUnitType::
    AreaLimit () const
    {
      return this->AreaLimit_;
    }

    AbsoluteLimitsByUnitType::AreaLimit_optional& AbsoluteLimitsByUnitType::
    AreaLimit ()
    {
      return this->AreaLimit_;
    }

    void AbsoluteLimitsByUnitType::
    AreaLimit (const AreaLimit_type& x)
    {
      this->AreaLimit_.set (x);
    }

    void AbsoluteLimitsByUnitType::
    AreaLimit (const AreaLimit_optional& x)
    {
      this->AreaLimit_ = x;
    }

    void AbsoluteLimitsByUnitType::
    AreaLimit (::std::unique_ptr< AreaLimit_type > x)
    {
      this->AreaLimit_.set (std::move (x));
    }

    const AbsoluteLimitsByUnitType::ForceLimit_optional& AbsoluteLimitsByUnitType::
    ForceLimit () const
    {
      return this->ForceLimit_;
    }

    AbsoluteLimitsByUnitType::ForceLimit_optional& AbsoluteLimitsByUnitType::
    ForceLimit ()
    {
      return this->ForceLimit_;
    }

    void AbsoluteLimitsByUnitType::
    ForceLimit (const ForceLimit_type& x)
    {
      this->ForceLimit_.set (x);
    }

    void AbsoluteLimitsByUnitType::
    ForceLimit (const ForceLimit_optional& x)
    {
      this->ForceLimit_ = x;
    }

    void AbsoluteLimitsByUnitType::
    ForceLimit (::std::unique_ptr< ForceLimit_type > x)
    {
      this->ForceLimit_.set (std::move (x));
    }

    const AbsoluteLimitsByUnitType::MassLimit_optional& AbsoluteLimitsByUnitType::
    MassLimit () const
    {
      return this->MassLimit_;
    }

    AbsoluteLimitsByUnitType::MassLimit_optional& AbsoluteLimitsByUnitType::
    MassLimit ()
    {
      return this->MassLimit_;
    }

    void AbsoluteLimitsByUnitType::
    MassLimit (const MassLimit_type& x)
    {
      this->MassLimit_.set (x);
    }

    void AbsoluteLimitsByUnitType::
    MassLimit (const MassLimit_optional& x)
    {
      this->MassLimit_ = x;
    }

    void AbsoluteLimitsByUnitType::
    MassLimit (::std::unique_ptr< MassLimit_type > x)
    {
      this->MassLimit_.set (std::move (x));
    }

    const AbsoluteLimitsByUnitType::PressureLimit_optional& AbsoluteLimitsByUnitType::
    PressureLimit () const
    {
      return this->PressureLimit_;
    }

    AbsoluteLimitsByUnitType::PressureLimit_optional& AbsoluteLimitsByUnitType::
    PressureLimit ()
    {
      return this->PressureLimit_;
    }

    void AbsoluteLimitsByUnitType::
    PressureLimit (const PressureLimit_type& x)
    {
      this->PressureLimit_.set (x);
    }

    void AbsoluteLimitsByUnitType::
    PressureLimit (const PressureLimit_optional& x)
    {
      this->PressureLimit_ = x;
    }

    void AbsoluteLimitsByUnitType::
    PressureLimit (::std::unique_ptr< PressureLimit_type > x)
    {
      this->PressureLimit_.set (std::move (x));
    }

    const AbsoluteLimitsByUnitType::SpeedLimit_optional& AbsoluteLimitsByUnitType::
    SpeedLimit () const
    {
      return this->SpeedLimit_;
    }

    AbsoluteLimitsByUnitType::SpeedLimit_optional& AbsoluteLimitsByUnitType::
    SpeedLimit ()
    {
      return this->SpeedLimit_;
    }

    void AbsoluteLimitsByUnitType::
    SpeedLimit (const SpeedLimit_type& x)
    {
      this->SpeedLimit_.set (x);
    }

    void AbsoluteLimitsByUnitType::
    SpeedLimit (const SpeedLimit_optional& x)
    {
      this->SpeedLimit_ = x;
    }

    void AbsoluteLimitsByUnitType::
    SpeedLimit (::std::unique_ptr< SpeedLimit_type > x)
    {
      this->SpeedLimit_.set (std::move (x));
    }

    const AbsoluteLimitsByUnitType::TemperatureLimit_optional& AbsoluteLimitsByUnitType::
    TemperatureLimit () const
    {
      return this->TemperatureLimit_;
    }

    AbsoluteLimitsByUnitType::TemperatureLimit_optional& AbsoluteLimitsByUnitType::
    TemperatureLimit ()
    {
      return this->TemperatureLimit_;
    }

    void AbsoluteLimitsByUnitType::
    TemperatureLimit (const TemperatureLimit_type& x)
    {
      this->TemperatureLimit_.set (x);
    }

    void AbsoluteLimitsByUnitType::
    TemperatureLimit (const TemperatureLimit_optional& x)
    {
      this->TemperatureLimit_ = x;
    }

    void AbsoluteLimitsByUnitType::
    TemperatureLimit (::std::unique_ptr< TemperatureLimit_type > x)
    {
      this->TemperatureLimit_.set (std::move (x));
    }

    const AbsoluteLimitsByUnitType::TimeLimit_optional& AbsoluteLimitsByUnitType::
    TimeLimit () const
    {
      return this->TimeLimit_;
    }

    AbsoluteLimitsByUnitType::TimeLimit_optional& AbsoluteLimitsByUnitType::
    TimeLimit ()
    {
      return this->TimeLimit_;
    }

    void AbsoluteLimitsByUnitType::
    TimeLimit (const TimeLimit_type& x)
    {
      this->TimeLimit_.set (x);
    }

    void AbsoluteLimitsByUnitType::
    TimeLimit (const TimeLimit_optional& x)
    {
      this->TimeLimit_ = x;
    }

    void AbsoluteLimitsByUnitType::
    TimeLimit (::std::unique_ptr< TimeLimit_type > x)
    {
      this->TimeLimit_.set (std::move (x));
    }

    const AbsoluteLimitsByUnitType::UserDefinedUnitLimit_sequence& AbsoluteLimitsByUnitType::
    UserDefinedUnitLimit () const
    {
      return this->UserDefinedUnitLimit_;
    }

    AbsoluteLimitsByUnitType::UserDefinedUnitLimit_sequence& AbsoluteLimitsByUnitType::
    UserDefinedUnitLimit ()
    {
      return this->UserDefinedUnitLimit_;
    }

    void AbsoluteLimitsByUnitType::
    UserDefinedUnitLimit (const UserDefinedUnitLimit_sequence& s)
    {
      this->UserDefinedUnitLimit_ = s;
    }

    const AbsoluteLimitsByUnitType::n_type& AbsoluteLimitsByUnitType::
    n () const
    {
      return this->n_.get ();
    }

    AbsoluteLimitsByUnitType::n_type& AbsoluteLimitsByUnitType::
    n ()
    {
      return this->n_.get ();
    }

    void AbsoluteLimitsByUnitType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void AbsoluteLimitsByUnitType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // LinearityStudyPlanType
    //

    const LinearityStudyPlanType::MeasurementDeviceIds_optional& LinearityStudyPlanType::
    MeasurementDeviceIds () const
    {
      return this->MeasurementDeviceIds_;
    }

    LinearityStudyPlanType::MeasurementDeviceIds_optional& LinearityStudyPlanType::
    MeasurementDeviceIds ()
    {
      return this->MeasurementDeviceIds_;
    }

    void LinearityStudyPlanType::
    MeasurementDeviceIds (const MeasurementDeviceIds_type& x)
    {
      this->MeasurementDeviceIds_.set (x);
    }

    void LinearityStudyPlanType::
    MeasurementDeviceIds (const MeasurementDeviceIds_optional& x)
    {
      this->MeasurementDeviceIds_ = x;
    }

    void LinearityStudyPlanType::
    MeasurementDeviceIds (::std::unique_ptr< MeasurementDeviceIds_type > x)
    {
      this->MeasurementDeviceIds_.set (std::move (x));
    }

    const LinearityStudyPlanType::GoodnessOfFitThreshold_optional& LinearityStudyPlanType::
    GoodnessOfFitThreshold () const
    {
      return this->GoodnessOfFitThreshold_;
    }

    LinearityStudyPlanType::GoodnessOfFitThreshold_optional& LinearityStudyPlanType::
    GoodnessOfFitThreshold ()
    {
      return this->GoodnessOfFitThreshold_;
    }

    void LinearityStudyPlanType::
    GoodnessOfFitThreshold (const GoodnessOfFitThreshold_type& x)
    {
      this->GoodnessOfFitThreshold_.set (x);
    }

    void LinearityStudyPlanType::
    GoodnessOfFitThreshold (const GoodnessOfFitThreshold_optional& x)
    {
      this->GoodnessOfFitThreshold_ = x;
    }

    const LinearityStudyPlanType::AbsoluteMinimums_optional& LinearityStudyPlanType::
    AbsoluteMinimums () const
    {
      return this->AbsoluteMinimums_;
    }

    LinearityStudyPlanType::AbsoluteMinimums_optional& LinearityStudyPlanType::
    AbsoluteMinimums ()
    {
      return this->AbsoluteMinimums_;
    }

    void LinearityStudyPlanType::
    AbsoluteMinimums (const AbsoluteMinimums_type& x)
    {
      this->AbsoluteMinimums_.set (x);
    }

    void LinearityStudyPlanType::
    AbsoluteMinimums (const AbsoluteMinimums_optional& x)
    {
      this->AbsoluteMinimums_ = x;
    }

    void LinearityStudyPlanType::
    AbsoluteMinimums (::std::unique_ptr< AbsoluteMinimums_type > x)
    {
      this->AbsoluteMinimums_.set (std::move (x));
    }

    const LinearityStudyPlanType::RelativeLinearityMinimum_optional& LinearityStudyPlanType::
    RelativeLinearityMinimum () const
    {
      return this->RelativeLinearityMinimum_;
    }

    LinearityStudyPlanType::RelativeLinearityMinimum_optional& LinearityStudyPlanType::
    RelativeLinearityMinimum ()
    {
      return this->RelativeLinearityMinimum_;
    }

    void LinearityStudyPlanType::
    RelativeLinearityMinimum (const RelativeLinearityMinimum_type& x)
    {
      this->RelativeLinearityMinimum_.set (x);
    }

    void LinearityStudyPlanType::
    RelativeLinearityMinimum (const RelativeLinearityMinimum_optional& x)
    {
      this->RelativeLinearityMinimum_ = x;
    }


    // StabilityStudyPlanType
    //

    const StabilityStudyPlanType::MeasurementDeviceIds_optional& StabilityStudyPlanType::
    MeasurementDeviceIds () const
    {
      return this->MeasurementDeviceIds_;
    }

    StabilityStudyPlanType::MeasurementDeviceIds_optional& StabilityStudyPlanType::
    MeasurementDeviceIds ()
    {
      return this->MeasurementDeviceIds_;
    }

    void StabilityStudyPlanType::
    MeasurementDeviceIds (const MeasurementDeviceIds_type& x)
    {
      this->MeasurementDeviceIds_.set (x);
    }

    void StabilityStudyPlanType::
    MeasurementDeviceIds (const MeasurementDeviceIds_optional& x)
    {
      this->MeasurementDeviceIds_ = x;
    }

    void StabilityStudyPlanType::
    MeasurementDeviceIds (::std::unique_ptr< MeasurementDeviceIds_type > x)
    {
      this->MeasurementDeviceIds_.set (std::move (x));
    }

    const StabilityStudyPlanType::SampleSize_type& StabilityStudyPlanType::
    SampleSize () const
    {
      return this->SampleSize_.get ();
    }

    StabilityStudyPlanType::SampleSize_type& StabilityStudyPlanType::
    SampleSize ()
    {
      return this->SampleSize_.get ();
    }

    void StabilityStudyPlanType::
    SampleSize (const SampleSize_type& x)
    {
      this->SampleSize_.set (x);
    }

    const StabilityStudyPlanType::SampleFrequency_type& StabilityStudyPlanType::
    SampleFrequency () const
    {
      return this->SampleFrequency_.get ();
    }

    StabilityStudyPlanType::SampleFrequency_type& StabilityStudyPlanType::
    SampleFrequency ()
    {
      return this->SampleFrequency_.get ();
    }

    void StabilityStudyPlanType::
    SampleFrequency (const SampleFrequency_type& x)
    {
      this->SampleFrequency_.set (x);
    }

    const StabilityStudyPlanType::SamplingInterval_type& StabilityStudyPlanType::
    SamplingInterval () const
    {
      return this->SamplingInterval_.get ();
    }

    StabilityStudyPlanType::SamplingInterval_type& StabilityStudyPlanType::
    SamplingInterval ()
    {
      return this->SamplingInterval_.get ();
    }

    void StabilityStudyPlanType::
    SamplingInterval (const SamplingInterval_type& x)
    {
      this->SamplingInterval_.set (x);
    }

    void StabilityStudyPlanType::
    SamplingInterval (::std::unique_ptr< SamplingInterval_type > x)
    {
      this->SamplingInterval_.set (std::move (x));
    }


    // MultipleProductInstanceStudyPlanBaseType
    //

    const MultipleProductInstanceStudyPlanBaseType::NumberOfSamples_type& MultipleProductInstanceStudyPlanBaseType::
    NumberOfSamples () const
    {
      return this->NumberOfSamples_.get ();
    }

    MultipleProductInstanceStudyPlanBaseType::NumberOfSamples_type& MultipleProductInstanceStudyPlanBaseType::
    NumberOfSamples ()
    {
      return this->NumberOfSamples_.get ();
    }

    void MultipleProductInstanceStudyPlanBaseType::
    NumberOfSamples (const NumberOfSamples_type& x)
    {
      this->NumberOfSamples_.set (x);
    }

    const MultipleProductInstanceStudyPlanBaseType::SubgroupSize_optional& MultipleProductInstanceStudyPlanBaseType::
    SubgroupSize () const
    {
      return this->SubgroupSize_;
    }

    MultipleProductInstanceStudyPlanBaseType::SubgroupSize_optional& MultipleProductInstanceStudyPlanBaseType::
    SubgroupSize ()
    {
      return this->SubgroupSize_;
    }

    void MultipleProductInstanceStudyPlanBaseType::
    SubgroupSize (const SubgroupSize_type& x)
    {
      this->SubgroupSize_.set (x);
    }

    void MultipleProductInstanceStudyPlanBaseType::
    SubgroupSize (const SubgroupSize_optional& x)
    {
      this->SubgroupSize_ = x;
    }


    // BiasStudyPlanType
    //

    const BiasStudyPlanType::MeasurementDeviceIds_optional& BiasStudyPlanType::
    MeasurementDeviceIds () const
    {
      return this->MeasurementDeviceIds_;
    }

    BiasStudyPlanType::MeasurementDeviceIds_optional& BiasStudyPlanType::
    MeasurementDeviceIds ()
    {
      return this->MeasurementDeviceIds_;
    }

    void BiasStudyPlanType::
    MeasurementDeviceIds (const MeasurementDeviceIds_type& x)
    {
      this->MeasurementDeviceIds_.set (x);
    }

    void BiasStudyPlanType::
    MeasurementDeviceIds (const MeasurementDeviceIds_optional& x)
    {
      this->MeasurementDeviceIds_ = x;
    }

    void BiasStudyPlanType::
    MeasurementDeviceIds (::std::unique_ptr< MeasurementDeviceIds_type > x)
    {
      this->MeasurementDeviceIds_.set (std::move (x));
    }


    // FirstArticleStudyPlanType
    //

    const FirstArticleStudyPlanType::InSpecRatio_type& FirstArticleStudyPlanType::
    InSpecRatio () const
    {
      return this->InSpecRatio_.get ();
    }

    FirstArticleStudyPlanType::InSpecRatio_type& FirstArticleStudyPlanType::
    InSpecRatio ()
    {
      return this->InSpecRatio_.get ();
    }

    void FirstArticleStudyPlanType::
    InSpecRatio (const InSpecRatio_type& x)
    {
      this->InSpecRatio_.set (x);
    }

    const FirstArticleStudyPlanType::AbsoluteMaximums_optional& FirstArticleStudyPlanType::
    AbsoluteMaximums () const
    {
      return this->AbsoluteMaximums_;
    }

    FirstArticleStudyPlanType::AbsoluteMaximums_optional& FirstArticleStudyPlanType::
    AbsoluteMaximums ()
    {
      return this->AbsoluteMaximums_;
    }

    void FirstArticleStudyPlanType::
    AbsoluteMaximums (const AbsoluteMaximums_type& x)
    {
      this->AbsoluteMaximums_.set (x);
    }

    void FirstArticleStudyPlanType::
    AbsoluteMaximums (const AbsoluteMaximums_optional& x)
    {
      this->AbsoluteMaximums_ = x;
    }

    void FirstArticleStudyPlanType::
    AbsoluteMaximums (::std::unique_ptr< AbsoluteMaximums_type > x)
    {
      this->AbsoluteMaximums_.set (std::move (x));
    }

    const FirstArticleStudyPlanType::RelativeMaximum_optional& FirstArticleStudyPlanType::
    RelativeMaximum () const
    {
      return this->RelativeMaximum_;
    }

    FirstArticleStudyPlanType::RelativeMaximum_optional& FirstArticleStudyPlanType::
    RelativeMaximum ()
    {
      return this->RelativeMaximum_;
    }

    void FirstArticleStudyPlanType::
    RelativeMaximum (const RelativeMaximum_type& x)
    {
      this->RelativeMaximum_.set (x);
    }

    void FirstArticleStudyPlanType::
    RelativeMaximum (const RelativeMaximum_optional& x)
    {
      this->RelativeMaximum_ = x;
    }


    // ProcessDifferenceStudyPlanType
    //

    const ProcessDifferenceStudyPlanType::NumberOfSamples_type& ProcessDifferenceStudyPlanType::
    NumberOfSamples () const
    {
      return this->NumberOfSamples_.get ();
    }

    ProcessDifferenceStudyPlanType::NumberOfSamples_type& ProcessDifferenceStudyPlanType::
    NumberOfSamples ()
    {
      return this->NumberOfSamples_.get ();
    }

    void ProcessDifferenceStudyPlanType::
    NumberOfSamples (const NumberOfSamples_type& x)
    {
      this->NumberOfSamples_.set (x);
    }

    const ProcessDifferenceStudyPlanType::SubgroupSize_type& ProcessDifferenceStudyPlanType::
    SubgroupSize () const
    {
      return this->SubgroupSize_.get ();
    }

    ProcessDifferenceStudyPlanType::SubgroupSize_type& ProcessDifferenceStudyPlanType::
    SubgroupSize ()
    {
      return this->SubgroupSize_.get ();
    }

    void ProcessDifferenceStudyPlanType::
    SubgroupSize (const SubgroupSize_type& x)
    {
      this->SubgroupSize_.set (x);
    }

    ProcessDifferenceStudyPlanType::SubgroupSize_type ProcessDifferenceStudyPlanType::
    SubgroupSize_default_value ()
    {
      return SubgroupSize_type (2ULL);
    }

    const ProcessDifferenceStudyPlanType::ManufacturingProcessId_optional& ProcessDifferenceStudyPlanType::
    ManufacturingProcessId () const
    {
      return this->ManufacturingProcessId_;
    }

    ProcessDifferenceStudyPlanType::ManufacturingProcessId_optional& ProcessDifferenceStudyPlanType::
    ManufacturingProcessId ()
    {
      return this->ManufacturingProcessId_;
    }

    void ProcessDifferenceStudyPlanType::
    ManufacturingProcessId (const ManufacturingProcessId_type& x)
    {
      this->ManufacturingProcessId_.set (x);
    }

    void ProcessDifferenceStudyPlanType::
    ManufacturingProcessId (const ManufacturingProcessId_optional& x)
    {
      this->ManufacturingProcessId_ = x;
    }

    void ProcessDifferenceStudyPlanType::
    ManufacturingProcessId (::std::unique_ptr< ManufacturingProcessId_type > x)
    {
      this->ManufacturingProcessId_.set (std::move (x));
    }

    const ProcessDifferenceStudyPlanType::AbsoluteDifferences_optional& ProcessDifferenceStudyPlanType::
    AbsoluteDifferences () const
    {
      return this->AbsoluteDifferences_;
    }

    ProcessDifferenceStudyPlanType::AbsoluteDifferences_optional& ProcessDifferenceStudyPlanType::
    AbsoluteDifferences ()
    {
      return this->AbsoluteDifferences_;
    }

    void ProcessDifferenceStudyPlanType::
    AbsoluteDifferences (const AbsoluteDifferences_type& x)
    {
      this->AbsoluteDifferences_.set (x);
    }

    void ProcessDifferenceStudyPlanType::
    AbsoluteDifferences (const AbsoluteDifferences_optional& x)
    {
      this->AbsoluteDifferences_ = x;
    }

    void ProcessDifferenceStudyPlanType::
    AbsoluteDifferences (::std::unique_ptr< AbsoluteDifferences_type > x)
    {
      this->AbsoluteDifferences_.set (std::move (x));
    }

    const ProcessDifferenceStudyPlanType::RelativeDifference_optional& ProcessDifferenceStudyPlanType::
    RelativeDifference () const
    {
      return this->RelativeDifference_;
    }

    ProcessDifferenceStudyPlanType::RelativeDifference_optional& ProcessDifferenceStudyPlanType::
    RelativeDifference ()
    {
      return this->RelativeDifference_;
    }

    void ProcessDifferenceStudyPlanType::
    RelativeDifference (const RelativeDifference_type& x)
    {
      this->RelativeDifference_.set (x);
    }

    void ProcessDifferenceStudyPlanType::
    RelativeDifference (const RelativeDifference_optional& x)
    {
      this->RelativeDifference_ = x;
    }


    // SimpleStudyPlanType
    //


    // CapabilityStudyPlanType
    //

    const CapabilityStudyPlanType::CpkThreshold_optional& CapabilityStudyPlanType::
    CpkThreshold () const
    {
      return this->CpkThreshold_;
    }

    CapabilityStudyPlanType::CpkThreshold_optional& CapabilityStudyPlanType::
    CpkThreshold ()
    {
      return this->CpkThreshold_;
    }

    void CapabilityStudyPlanType::
    CpkThreshold (const CpkThreshold_type& x)
    {
      this->CpkThreshold_.set (x);
    }

    void CapabilityStudyPlanType::
    CpkThreshold (const CpkThreshold_optional& x)
    {
      this->CpkThreshold_ = x;
    }

    void CapabilityStudyPlanType::
    CpkThreshold (::std::unique_ptr< CpkThreshold_type > x)
    {
      this->CpkThreshold_.set (std::move (x));
    }

    const CapabilityStudyPlanType::PpkThreshold_optional& CapabilityStudyPlanType::
    PpkThreshold () const
    {
      return this->PpkThreshold_;
    }

    CapabilityStudyPlanType::PpkThreshold_optional& CapabilityStudyPlanType::
    PpkThreshold ()
    {
      return this->PpkThreshold_;
    }

    void CapabilityStudyPlanType::
    PpkThreshold (const PpkThreshold_type& x)
    {
      this->PpkThreshold_.set (x);
    }

    void CapabilityStudyPlanType::
    PpkThreshold (const PpkThreshold_optional& x)
    {
      this->PpkThreshold_ = x;
    }

    void CapabilityStudyPlanType::
    PpkThreshold (::std::unique_ptr< PpkThreshold_type > x)
    {
      this->PpkThreshold_.set (std::move (x));
    }


    // GageRandRStudyEnumType
    //

    GageRandRStudyEnumType::
    GageRandRStudyEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    GageRandRStudyEnumType::
    GageRandRStudyEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_GageRandRStudyEnumType_literals_[v])
    {
    }

    GageRandRStudyEnumType::
    GageRandRStudyEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    GageRandRStudyEnumType::
    GageRandRStudyEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    GageRandRStudyEnumType::
    GageRandRStudyEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    GageRandRStudyEnumType::
    GageRandRStudyEnumType (const GageRandRStudyEnumType& v,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    GageRandRStudyEnumType& GageRandRStudyEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_GageRandRStudyEnumType_literals_[v]);

      return *this;
    }


    // CriteriaByUnitType
    //

    const CriteriaByUnitType::LinearCriterion_optional& CriteriaByUnitType::
    LinearCriterion () const
    {
      return this->LinearCriterion_;
    }

    CriteriaByUnitType::LinearCriterion_optional& CriteriaByUnitType::
    LinearCriterion ()
    {
      return this->LinearCriterion_;
    }

    void CriteriaByUnitType::
    LinearCriterion (const LinearCriterion_type& x)
    {
      this->LinearCriterion_.set (x);
    }

    void CriteriaByUnitType::
    LinearCriterion (const LinearCriterion_optional& x)
    {
      this->LinearCriterion_ = x;
    }

    void CriteriaByUnitType::
    LinearCriterion (::std::unique_ptr< LinearCriterion_type > x)
    {
      this->LinearCriterion_.set (std::move (x));
    }

    const CriteriaByUnitType::AngularCriterion_optional& CriteriaByUnitType::
    AngularCriterion () const
    {
      return this->AngularCriterion_;
    }

    CriteriaByUnitType::AngularCriterion_optional& CriteriaByUnitType::
    AngularCriterion ()
    {
      return this->AngularCriterion_;
    }

    void CriteriaByUnitType::
    AngularCriterion (const AngularCriterion_type& x)
    {
      this->AngularCriterion_.set (x);
    }

    void CriteriaByUnitType::
    AngularCriterion (const AngularCriterion_optional& x)
    {
      this->AngularCriterion_ = x;
    }

    void CriteriaByUnitType::
    AngularCriterion (::std::unique_ptr< AngularCriterion_type > x)
    {
      this->AngularCriterion_.set (std::move (x));
    }

    const CriteriaByUnitType::AreaCriterion_optional& CriteriaByUnitType::
    AreaCriterion () const
    {
      return this->AreaCriterion_;
    }

    CriteriaByUnitType::AreaCriterion_optional& CriteriaByUnitType::
    AreaCriterion ()
    {
      return this->AreaCriterion_;
    }

    void CriteriaByUnitType::
    AreaCriterion (const AreaCriterion_type& x)
    {
      this->AreaCriterion_.set (x);
    }

    void CriteriaByUnitType::
    AreaCriterion (const AreaCriterion_optional& x)
    {
      this->AreaCriterion_ = x;
    }

    void CriteriaByUnitType::
    AreaCriterion (::std::unique_ptr< AreaCriterion_type > x)
    {
      this->AreaCriterion_.set (std::move (x));
    }

    const CriteriaByUnitType::ForceCriterion_optional& CriteriaByUnitType::
    ForceCriterion () const
    {
      return this->ForceCriterion_;
    }

    CriteriaByUnitType::ForceCriterion_optional& CriteriaByUnitType::
    ForceCriterion ()
    {
      return this->ForceCriterion_;
    }

    void CriteriaByUnitType::
    ForceCriterion (const ForceCriterion_type& x)
    {
      this->ForceCriterion_.set (x);
    }

    void CriteriaByUnitType::
    ForceCriterion (const ForceCriterion_optional& x)
    {
      this->ForceCriterion_ = x;
    }

    void CriteriaByUnitType::
    ForceCriterion (::std::unique_ptr< ForceCriterion_type > x)
    {
      this->ForceCriterion_.set (std::move (x));
    }

    const CriteriaByUnitType::MassCriterion_optional& CriteriaByUnitType::
    MassCriterion () const
    {
      return this->MassCriterion_;
    }

    CriteriaByUnitType::MassCriterion_optional& CriteriaByUnitType::
    MassCriterion ()
    {
      return this->MassCriterion_;
    }

    void CriteriaByUnitType::
    MassCriterion (const MassCriterion_type& x)
    {
      this->MassCriterion_.set (x);
    }

    void CriteriaByUnitType::
    MassCriterion (const MassCriterion_optional& x)
    {
      this->MassCriterion_ = x;
    }

    void CriteriaByUnitType::
    MassCriterion (::std::unique_ptr< MassCriterion_type > x)
    {
      this->MassCriterion_.set (std::move (x));
    }

    const CriteriaByUnitType::PressureCriterion_optional& CriteriaByUnitType::
    PressureCriterion () const
    {
      return this->PressureCriterion_;
    }

    CriteriaByUnitType::PressureCriterion_optional& CriteriaByUnitType::
    PressureCriterion ()
    {
      return this->PressureCriterion_;
    }

    void CriteriaByUnitType::
    PressureCriterion (const PressureCriterion_type& x)
    {
      this->PressureCriterion_.set (x);
    }

    void CriteriaByUnitType::
    PressureCriterion (const PressureCriterion_optional& x)
    {
      this->PressureCriterion_ = x;
    }

    void CriteriaByUnitType::
    PressureCriterion (::std::unique_ptr< PressureCriterion_type > x)
    {
      this->PressureCriterion_.set (std::move (x));
    }

    const CriteriaByUnitType::SpeedCriterion_optional& CriteriaByUnitType::
    SpeedCriterion () const
    {
      return this->SpeedCriterion_;
    }

    CriteriaByUnitType::SpeedCriterion_optional& CriteriaByUnitType::
    SpeedCriterion ()
    {
      return this->SpeedCriterion_;
    }

    void CriteriaByUnitType::
    SpeedCriterion (const SpeedCriterion_type& x)
    {
      this->SpeedCriterion_.set (x);
    }

    void CriteriaByUnitType::
    SpeedCriterion (const SpeedCriterion_optional& x)
    {
      this->SpeedCriterion_ = x;
    }

    void CriteriaByUnitType::
    SpeedCriterion (::std::unique_ptr< SpeedCriterion_type > x)
    {
      this->SpeedCriterion_.set (std::move (x));
    }

    const CriteriaByUnitType::TemperatureCriterion_optional& CriteriaByUnitType::
    TemperatureCriterion () const
    {
      return this->TemperatureCriterion_;
    }

    CriteriaByUnitType::TemperatureCriterion_optional& CriteriaByUnitType::
    TemperatureCriterion ()
    {
      return this->TemperatureCriterion_;
    }

    void CriteriaByUnitType::
    TemperatureCriterion (const TemperatureCriterion_type& x)
    {
      this->TemperatureCriterion_.set (x);
    }

    void CriteriaByUnitType::
    TemperatureCriterion (const TemperatureCriterion_optional& x)
    {
      this->TemperatureCriterion_ = x;
    }

    void CriteriaByUnitType::
    TemperatureCriterion (::std::unique_ptr< TemperatureCriterion_type > x)
    {
      this->TemperatureCriterion_.set (std::move (x));
    }

    const CriteriaByUnitType::TimeCriterion_optional& CriteriaByUnitType::
    TimeCriterion () const
    {
      return this->TimeCriterion_;
    }

    CriteriaByUnitType::TimeCriterion_optional& CriteriaByUnitType::
    TimeCriterion ()
    {
      return this->TimeCriterion_;
    }

    void CriteriaByUnitType::
    TimeCriterion (const TimeCriterion_type& x)
    {
      this->TimeCriterion_.set (x);
    }

    void CriteriaByUnitType::
    TimeCriterion (const TimeCriterion_optional& x)
    {
      this->TimeCriterion_ = x;
    }

    void CriteriaByUnitType::
    TimeCriterion (::std::unique_ptr< TimeCriterion_type > x)
    {
      this->TimeCriterion_.set (std::move (x));
    }

    const CriteriaByUnitType::UserDefinedUnitCriterion_sequence& CriteriaByUnitType::
    UserDefinedUnitCriterion () const
    {
      return this->UserDefinedUnitCriterion_;
    }

    CriteriaByUnitType::UserDefinedUnitCriterion_sequence& CriteriaByUnitType::
    UserDefinedUnitCriterion ()
    {
      return this->UserDefinedUnitCriterion_;
    }

    void CriteriaByUnitType::
    UserDefinedUnitCriterion (const UserDefinedUnitCriterion_sequence& s)
    {
      this->UserDefinedUnitCriterion_ = s;
    }

    const CriteriaByUnitType::n_type& CriteriaByUnitType::
    n () const
    {
      return this->n_.get ();
    }

    CriteriaByUnitType::n_type& CriteriaByUnitType::
    n ()
    {
      return this->n_.get ();
    }

    void CriteriaByUnitType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void CriteriaByUnitType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // GageRandRStudyPlanType
    //

    const GageRandRStudyPlanType::MeasurementDeviceIds_optional& GageRandRStudyPlanType::
    MeasurementDeviceIds () const
    {
      return this->MeasurementDeviceIds_;
    }

    GageRandRStudyPlanType::MeasurementDeviceIds_optional& GageRandRStudyPlanType::
    MeasurementDeviceIds ()
    {
      return this->MeasurementDeviceIds_;
    }

    void GageRandRStudyPlanType::
    MeasurementDeviceIds (const MeasurementDeviceIds_type& x)
    {
      this->MeasurementDeviceIds_.set (x);
    }

    void GageRandRStudyPlanType::
    MeasurementDeviceIds (const MeasurementDeviceIds_optional& x)
    {
      this->MeasurementDeviceIds_ = x;
    }

    void GageRandRStudyPlanType::
    MeasurementDeviceIds (::std::unique_ptr< MeasurementDeviceIds_type > x)
    {
      this->MeasurementDeviceIds_.set (std::move (x));
    }

    const GageRandRStudyPlanType::RandRStudyType_type& GageRandRStudyPlanType::
    RandRStudyType () const
    {
      return this->RandRStudyType_.get ();
    }

    GageRandRStudyPlanType::RandRStudyType_type& GageRandRStudyPlanType::
    RandRStudyType ()
    {
      return this->RandRStudyType_.get ();
    }

    void GageRandRStudyPlanType::
    RandRStudyType (const RandRStudyType_type& x)
    {
      this->RandRStudyType_.set (x);
    }

    void GageRandRStudyPlanType::
    RandRStudyType (::std::unique_ptr< RandRStudyType_type > x)
    {
      this->RandRStudyType_.set (std::move (x));
    }

    const GageRandRStudyPlanType::NumberOfAppraisers_type& GageRandRStudyPlanType::
    NumberOfAppraisers () const
    {
      return this->NumberOfAppraisers_.get ();
    }

    GageRandRStudyPlanType::NumberOfAppraisers_type& GageRandRStudyPlanType::
    NumberOfAppraisers ()
    {
      return this->NumberOfAppraisers_.get ();
    }

    void GageRandRStudyPlanType::
    NumberOfAppraisers (const NumberOfAppraisers_type& x)
    {
      this->NumberOfAppraisers_.set (x);
    }

    const GageRandRStudyPlanType::NumberOfParts_type& GageRandRStudyPlanType::
    NumberOfParts () const
    {
      return this->NumberOfParts_.get ();
    }

    GageRandRStudyPlanType::NumberOfParts_type& GageRandRStudyPlanType::
    NumberOfParts ()
    {
      return this->NumberOfParts_.get ();
    }

    void GageRandRStudyPlanType::
    NumberOfParts (const NumberOfParts_type& x)
    {
      this->NumberOfParts_.set (x);
    }

    const GageRandRStudyPlanType::NumberOfTrials_type& GageRandRStudyPlanType::
    NumberOfTrials () const
    {
      return this->NumberOfTrials_.get ();
    }

    GageRandRStudyPlanType::NumberOfTrials_type& GageRandRStudyPlanType::
    NumberOfTrials ()
    {
      return this->NumberOfTrials_.get ();
    }

    void GageRandRStudyPlanType::
    NumberOfTrials (const NumberOfTrials_type& x)
    {
      this->NumberOfTrials_.set (x);
    }

    const GageRandRStudyPlanType::MaximumRelativeAppraiserVariation_optional& GageRandRStudyPlanType::
    MaximumRelativeAppraiserVariation () const
    {
      return this->MaximumRelativeAppraiserVariation_;
    }

    GageRandRStudyPlanType::MaximumRelativeAppraiserVariation_optional& GageRandRStudyPlanType::
    MaximumRelativeAppraiserVariation ()
    {
      return this->MaximumRelativeAppraiserVariation_;
    }

    void GageRandRStudyPlanType::
    MaximumRelativeAppraiserVariation (const MaximumRelativeAppraiserVariation_type& x)
    {
      this->MaximumRelativeAppraiserVariation_.set (x);
    }

    void GageRandRStudyPlanType::
    MaximumRelativeAppraiserVariation (const MaximumRelativeAppraiserVariation_optional& x)
    {
      this->MaximumRelativeAppraiserVariation_ = x;
    }

    void GageRandRStudyPlanType::
    MaximumRelativeAppraiserVariation (::std::unique_ptr< MaximumRelativeAppraiserVariation_type > x)
    {
      this->MaximumRelativeAppraiserVariation_.set (std::move (x));
    }

    const GageRandRStudyPlanType::MaximumAbsoluteAppraiserVariation_optional& GageRandRStudyPlanType::
    MaximumAbsoluteAppraiserVariation () const
    {
      return this->MaximumAbsoluteAppraiserVariation_;
    }

    GageRandRStudyPlanType::MaximumAbsoluteAppraiserVariation_optional& GageRandRStudyPlanType::
    MaximumAbsoluteAppraiserVariation ()
    {
      return this->MaximumAbsoluteAppraiserVariation_;
    }

    void GageRandRStudyPlanType::
    MaximumAbsoluteAppraiserVariation (const MaximumAbsoluteAppraiserVariation_type& x)
    {
      this->MaximumAbsoluteAppraiserVariation_.set (x);
    }

    void GageRandRStudyPlanType::
    MaximumAbsoluteAppraiserVariation (const MaximumAbsoluteAppraiserVariation_optional& x)
    {
      this->MaximumAbsoluteAppraiserVariation_ = x;
    }

    void GageRandRStudyPlanType::
    MaximumAbsoluteAppraiserVariation (::std::unique_ptr< MaximumAbsoluteAppraiserVariation_type > x)
    {
      this->MaximumAbsoluteAppraiserVariation_.set (std::move (x));
    }

    const GageRandRStudyPlanType::MaximumRelativeEquipmentVariation_optional& GageRandRStudyPlanType::
    MaximumRelativeEquipmentVariation () const
    {
      return this->MaximumRelativeEquipmentVariation_;
    }

    GageRandRStudyPlanType::MaximumRelativeEquipmentVariation_optional& GageRandRStudyPlanType::
    MaximumRelativeEquipmentVariation ()
    {
      return this->MaximumRelativeEquipmentVariation_;
    }

    void GageRandRStudyPlanType::
    MaximumRelativeEquipmentVariation (const MaximumRelativeEquipmentVariation_type& x)
    {
      this->MaximumRelativeEquipmentVariation_.set (x);
    }

    void GageRandRStudyPlanType::
    MaximumRelativeEquipmentVariation (const MaximumRelativeEquipmentVariation_optional& x)
    {
      this->MaximumRelativeEquipmentVariation_ = x;
    }

    void GageRandRStudyPlanType::
    MaximumRelativeEquipmentVariation (::std::unique_ptr< MaximumRelativeEquipmentVariation_type > x)
    {
      this->MaximumRelativeEquipmentVariation_.set (std::move (x));
    }

    const GageRandRStudyPlanType::MaximumAbsoluteEquipmentVariation_optional& GageRandRStudyPlanType::
    MaximumAbsoluteEquipmentVariation () const
    {
      return this->MaximumAbsoluteEquipmentVariation_;
    }

    GageRandRStudyPlanType::MaximumAbsoluteEquipmentVariation_optional& GageRandRStudyPlanType::
    MaximumAbsoluteEquipmentVariation ()
    {
      return this->MaximumAbsoluteEquipmentVariation_;
    }

    void GageRandRStudyPlanType::
    MaximumAbsoluteEquipmentVariation (const MaximumAbsoluteEquipmentVariation_type& x)
    {
      this->MaximumAbsoluteEquipmentVariation_.set (x);
    }

    void GageRandRStudyPlanType::
    MaximumAbsoluteEquipmentVariation (const MaximumAbsoluteEquipmentVariation_optional& x)
    {
      this->MaximumAbsoluteEquipmentVariation_ = x;
    }

    void GageRandRStudyPlanType::
    MaximumAbsoluteEquipmentVariation (::std::unique_ptr< MaximumAbsoluteEquipmentVariation_type > x)
    {
      this->MaximumAbsoluteEquipmentVariation_.set (std::move (x));
    }

    const GageRandRStudyPlanType::MaximumRelativeTotalRandR_optional& GageRandRStudyPlanType::
    MaximumRelativeTotalRandR () const
    {
      return this->MaximumRelativeTotalRandR_;
    }

    GageRandRStudyPlanType::MaximumRelativeTotalRandR_optional& GageRandRStudyPlanType::
    MaximumRelativeTotalRandR ()
    {
      return this->MaximumRelativeTotalRandR_;
    }

    void GageRandRStudyPlanType::
    MaximumRelativeTotalRandR (const MaximumRelativeTotalRandR_type& x)
    {
      this->MaximumRelativeTotalRandR_.set (x);
    }

    void GageRandRStudyPlanType::
    MaximumRelativeTotalRandR (const MaximumRelativeTotalRandR_optional& x)
    {
      this->MaximumRelativeTotalRandR_ = x;
    }

    void GageRandRStudyPlanType::
    MaximumRelativeTotalRandR (::std::unique_ptr< MaximumRelativeTotalRandR_type > x)
    {
      this->MaximumRelativeTotalRandR_.set (std::move (x));
    }

    const GageRandRStudyPlanType::MaximumAbsoluteTotalRandR_optional& GageRandRStudyPlanType::
    MaximumAbsoluteTotalRandR () const
    {
      return this->MaximumAbsoluteTotalRandR_;
    }

    GageRandRStudyPlanType::MaximumAbsoluteTotalRandR_optional& GageRandRStudyPlanType::
    MaximumAbsoluteTotalRandR ()
    {
      return this->MaximumAbsoluteTotalRandR_;
    }

    void GageRandRStudyPlanType::
    MaximumAbsoluteTotalRandR (const MaximumAbsoluteTotalRandR_type& x)
    {
      this->MaximumAbsoluteTotalRandR_.set (x);
    }

    void GageRandRStudyPlanType::
    MaximumAbsoluteTotalRandR (const MaximumAbsoluteTotalRandR_optional& x)
    {
      this->MaximumAbsoluteTotalRandR_ = x;
    }

    void GageRandRStudyPlanType::
    MaximumAbsoluteTotalRandR (::std::unique_ptr< MaximumAbsoluteTotalRandR_type > x)
    {
      this->MaximumAbsoluteTotalRandR_.set (std::move (x));
    }


    // ControlMethodType
    //

    const ControlMethodType::AssignableCauseIds_optional& ControlMethodType::
    AssignableCauseIds () const
    {
      return this->AssignableCauseIds_;
    }

    ControlMethodType::AssignableCauseIds_optional& ControlMethodType::
    AssignableCauseIds ()
    {
      return this->AssignableCauseIds_;
    }

    void ControlMethodType::
    AssignableCauseIds (const AssignableCauseIds_type& x)
    {
      this->AssignableCauseIds_.set (x);
    }

    void ControlMethodType::
    AssignableCauseIds (const AssignableCauseIds_optional& x)
    {
      this->AssignableCauseIds_ = x;
    }

    void ControlMethodType::
    AssignableCauseIds (::std::unique_ptr< AssignableCauseIds_type > x)
    {
      this->AssignableCauseIds_.set (std::move (x));
    }

    const ControlMethodType::Attributes_optional& ControlMethodType::
    Attributes () const
    {
      return this->Attributes_;
    }

    ControlMethodType::Attributes_optional& ControlMethodType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void ControlMethodType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void ControlMethodType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void ControlMethodType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const ControlMethodType::NumOutOfTolerance_optional& ControlMethodType::
    NumOutOfTolerance () const
    {
      return this->NumOutOfTolerance_;
    }

    ControlMethodType::NumOutOfTolerance_optional& ControlMethodType::
    NumOutOfTolerance ()
    {
      return this->NumOutOfTolerance_;
    }

    void ControlMethodType::
    NumOutOfTolerance (const NumOutOfTolerance_type& x)
    {
      this->NumOutOfTolerance_.set (x);
    }

    void ControlMethodType::
    NumOutOfTolerance (const NumOutOfTolerance_optional& x)
    {
      this->NumOutOfTolerance_ = x;
    }

    void ControlMethodType::
    NumOutOfTolerance (::std::unique_ptr< NumOutOfTolerance_type > x)
    {
      this->NumOutOfTolerance_.set (std::move (x));
    }

    const ControlMethodType::CpThreshold_optional& ControlMethodType::
    CpThreshold () const
    {
      return this->CpThreshold_;
    }

    ControlMethodType::CpThreshold_optional& ControlMethodType::
    CpThreshold ()
    {
      return this->CpThreshold_;
    }

    void ControlMethodType::
    CpThreshold (const CpThreshold_type& x)
    {
      this->CpThreshold_.set (x);
    }

    void ControlMethodType::
    CpThreshold (const CpThreshold_optional& x)
    {
      this->CpThreshold_ = x;
    }

    void ControlMethodType::
    CpThreshold (::std::unique_ptr< CpThreshold_type > x)
    {
      this->CpThreshold_.set (std::move (x));
    }

    const ControlMethodType::CpkThreshold_optional& ControlMethodType::
    CpkThreshold () const
    {
      return this->CpkThreshold_;
    }

    ControlMethodType::CpkThreshold_optional& ControlMethodType::
    CpkThreshold ()
    {
      return this->CpkThreshold_;
    }

    void ControlMethodType::
    CpkThreshold (const CpkThreshold_type& x)
    {
      this->CpkThreshold_.set (x);
    }

    void ControlMethodType::
    CpkThreshold (const CpkThreshold_optional& x)
    {
      this->CpkThreshold_ = x;
    }

    void ControlMethodType::
    CpkThreshold (::std::unique_ptr< CpkThreshold_type > x)
    {
      this->CpkThreshold_.set (std::move (x));
    }

    const ControlMethodType::PpThreshold_optional& ControlMethodType::
    PpThreshold () const
    {
      return this->PpThreshold_;
    }

    ControlMethodType::PpThreshold_optional& ControlMethodType::
    PpThreshold ()
    {
      return this->PpThreshold_;
    }

    void ControlMethodType::
    PpThreshold (const PpThreshold_type& x)
    {
      this->PpThreshold_.set (x);
    }

    void ControlMethodType::
    PpThreshold (const PpThreshold_optional& x)
    {
      this->PpThreshold_ = x;
    }

    void ControlMethodType::
    PpThreshold (::std::unique_ptr< PpThreshold_type > x)
    {
      this->PpThreshold_.set (std::move (x));
    }

    const ControlMethodType::PpkThreshold_optional& ControlMethodType::
    PpkThreshold () const
    {
      return this->PpkThreshold_;
    }

    ControlMethodType::PpkThreshold_optional& ControlMethodType::
    PpkThreshold ()
    {
      return this->PpkThreshold_;
    }

    void ControlMethodType::
    PpkThreshold (const PpkThreshold_type& x)
    {
      this->PpkThreshold_.set (x);
    }

    void ControlMethodType::
    PpkThreshold (const PpkThreshold_optional& x)
    {
      this->PpkThreshold_ = x;
    }

    void ControlMethodType::
    PpkThreshold (::std::unique_ptr< PpkThreshold_type > x)
    {
      this->PpkThreshold_.set (std::move (x));
    }

    const ControlMethodType::NumOutOfControl_optional& ControlMethodType::
    NumOutOfControl () const
    {
      return this->NumOutOfControl_;
    }

    ControlMethodType::NumOutOfControl_optional& ControlMethodType::
    NumOutOfControl ()
    {
      return this->NumOutOfControl_;
    }

    void ControlMethodType::
    NumOutOfControl (const NumOutOfControl_type& x)
    {
      this->NumOutOfControl_.set (x);
    }

    void ControlMethodType::
    NumOutOfControl (const NumOutOfControl_optional& x)
    {
      this->NumOutOfControl_ = x;
    }

    void ControlMethodType::
    NumOutOfControl (::std::unique_ptr< NumOutOfControl_type > x)
    {
      this->NumOutOfControl_.set (std::move (x));
    }

    const ControlMethodType::TrendGrouping_optional& ControlMethodType::
    TrendGrouping () const
    {
      return this->TrendGrouping_;
    }

    ControlMethodType::TrendGrouping_optional& ControlMethodType::
    TrendGrouping ()
    {
      return this->TrendGrouping_;
    }

    void ControlMethodType::
    TrendGrouping (const TrendGrouping_type& x)
    {
      this->TrendGrouping_.set (x);
    }

    void ControlMethodType::
    TrendGrouping (const TrendGrouping_optional& x)
    {
      this->TrendGrouping_ = x;
    }

    void ControlMethodType::
    TrendGrouping (::std::unique_ptr< TrendGrouping_type > x)
    {
      this->TrendGrouping_.set (std::move (x));
    }

    const ControlMethodType::SkewGrouping_optional& ControlMethodType::
    SkewGrouping () const
    {
      return this->SkewGrouping_;
    }

    ControlMethodType::SkewGrouping_optional& ControlMethodType::
    SkewGrouping ()
    {
      return this->SkewGrouping_;
    }

    void ControlMethodType::
    SkewGrouping (const SkewGrouping_type& x)
    {
      this->SkewGrouping_.set (x);
    }

    void ControlMethodType::
    SkewGrouping (const SkewGrouping_optional& x)
    {
      this->SkewGrouping_ = x;
    }

    void ControlMethodType::
    SkewGrouping (::std::unique_ptr< SkewGrouping_type > x)
    {
      this->SkewGrouping_.set (std::move (x));
    }

    const ControlMethodType::OneThirdGrouping_optional& ControlMethodType::
    OneThirdGrouping () const
    {
      return this->OneThirdGrouping_;
    }

    ControlMethodType::OneThirdGrouping_optional& ControlMethodType::
    OneThirdGrouping ()
    {
      return this->OneThirdGrouping_;
    }

    void ControlMethodType::
    OneThirdGrouping (const OneThirdGrouping_type& x)
    {
      this->OneThirdGrouping_.set (x);
    }

    void ControlMethodType::
    OneThirdGrouping (const OneThirdGrouping_optional& x)
    {
      this->OneThirdGrouping_ = x;
    }

    void ControlMethodType::
    OneThirdGrouping (::std::unique_ptr< OneThirdGrouping_type > x)
    {
      this->OneThirdGrouping_.set (std::move (x));
    }

    const ControlMethodType::TwoThirdsGrouping_optional& ControlMethodType::
    TwoThirdsGrouping () const
    {
      return this->TwoThirdsGrouping_;
    }

    ControlMethodType::TwoThirdsGrouping_optional& ControlMethodType::
    TwoThirdsGrouping ()
    {
      return this->TwoThirdsGrouping_;
    }

    void ControlMethodType::
    TwoThirdsGrouping (const TwoThirdsGrouping_type& x)
    {
      this->TwoThirdsGrouping_.set (x);
    }

    void ControlMethodType::
    TwoThirdsGrouping (const TwoThirdsGrouping_optional& x)
    {
      this->TwoThirdsGrouping_ = x;
    }

    void ControlMethodType::
    TwoThirdsGrouping (::std::unique_ptr< TwoThirdsGrouping_type > x)
    {
      this->TwoThirdsGrouping_.set (std::move (x));
    }

    const ControlMethodType::Oscillation_optional& ControlMethodType::
    Oscillation () const
    {
      return this->Oscillation_;
    }

    ControlMethodType::Oscillation_optional& ControlMethodType::
    Oscillation ()
    {
      return this->Oscillation_;
    }

    void ControlMethodType::
    Oscillation (const Oscillation_type& x)
    {
      this->Oscillation_.set (x);
    }

    void ControlMethodType::
    Oscillation (const Oscillation_optional& x)
    {
      this->Oscillation_ = x;
    }

    void ControlMethodType::
    Oscillation (::std::unique_ptr< Oscillation_type > x)
    {
      this->Oscillation_.set (std::move (x));
    }

    const ControlMethodType::Stratification_optional& ControlMethodType::
    Stratification () const
    {
      return this->Stratification_;
    }

    ControlMethodType::Stratification_optional& ControlMethodType::
    Stratification ()
    {
      return this->Stratification_;
    }

    void ControlMethodType::
    Stratification (const Stratification_type& x)
    {
      this->Stratification_.set (x);
    }

    void ControlMethodType::
    Stratification (const Stratification_optional& x)
    {
      this->Stratification_ = x;
    }

    void ControlMethodType::
    Stratification (::std::unique_ptr< Stratification_type > x)
    {
      this->Stratification_.set (std::move (x));
    }

    const ControlMethodType::NumOutOfControlRng_optional& ControlMethodType::
    NumOutOfControlRng () const
    {
      return this->NumOutOfControlRng_;
    }

    ControlMethodType::NumOutOfControlRng_optional& ControlMethodType::
    NumOutOfControlRng ()
    {
      return this->NumOutOfControlRng_;
    }

    void ControlMethodType::
    NumOutOfControlRng (const NumOutOfControlRng_type& x)
    {
      this->NumOutOfControlRng_.set (x);
    }

    void ControlMethodType::
    NumOutOfControlRng (const NumOutOfControlRng_optional& x)
    {
      this->NumOutOfControlRng_ = x;
    }

    void ControlMethodType::
    NumOutOfControlRng (::std::unique_ptr< NumOutOfControlRng_type > x)
    {
      this->NumOutOfControlRng_.set (std::move (x));
    }

    const ControlMethodType::id_type& ControlMethodType::
    id () const
    {
      return this->id_.get ();
    }

    ControlMethodType::id_type& ControlMethodType::
    id ()
    {
      return this->id_.get ();
    }

    void ControlMethodType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void ControlMethodType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // ControlMethodsType
    //

    const ControlMethodsType::ControlMethod_sequence& ControlMethodsType::
    ControlMethod () const
    {
      return this->ControlMethod_;
    }

    ControlMethodsType::ControlMethod_sequence& ControlMethodsType::
    ControlMethod ()
    {
      return this->ControlMethod_;
    }

    void ControlMethodsType::
    ControlMethod (const ControlMethod_sequence& s)
    {
      this->ControlMethod_ = s;
    }

    const ControlMethodsType::n_type& ControlMethodsType::
    n () const
    {
      return this->n_.get ();
    }

    ControlMethodsType::n_type& ControlMethodsType::
    n ()
    {
      return this->n_.get ();
    }

    void ControlMethodsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void ControlMethodsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ProductionStudyPlanType
    //

    const ProductionStudyPlanType::SamplingMethod_type& ProductionStudyPlanType::
    SamplingMethod () const
    {
      return this->SamplingMethod_.get ();
    }

    ProductionStudyPlanType::SamplingMethod_type& ProductionStudyPlanType::
    SamplingMethod ()
    {
      return this->SamplingMethod_.get ();
    }

    void ProductionStudyPlanType::
    SamplingMethod (const SamplingMethod_type& x)
    {
      this->SamplingMethod_.set (x);
    }

    void ProductionStudyPlanType::
    SamplingMethod (::std::unique_ptr< SamplingMethod_type > x)
    {
      this->SamplingMethod_.set (std::move (x));
    }

    const ProductionStudyPlanType::ControlMethods_type& ProductionStudyPlanType::
    ControlMethods () const
    {
      return this->ControlMethods_.get ();
    }

    ProductionStudyPlanType::ControlMethods_type& ProductionStudyPlanType::
    ControlMethods ()
    {
      return this->ControlMethods_.get ();
    }

    void ProductionStudyPlanType::
    ControlMethods (const ControlMethods_type& x)
    {
      this->ControlMethods_.set (x);
    }

    void ProductionStudyPlanType::
    ControlMethods (::std::unique_ptr< ControlMethods_type > x)
    {
      this->ControlMethods_.set (std::move (x));
    }


    // StatisticalStudyResultsBaseType
    //

    const StatisticalStudyResultsBaseType::ThisStatisticalStudyResultsInstanceQPId_optional& StatisticalStudyResultsBaseType::
    ThisStatisticalStudyResultsInstanceQPId () const
    {
      return this->ThisStatisticalStudyResultsInstanceQPId_;
    }

    StatisticalStudyResultsBaseType::ThisStatisticalStudyResultsInstanceQPId_optional& StatisticalStudyResultsBaseType::
    ThisStatisticalStudyResultsInstanceQPId ()
    {
      return this->ThisStatisticalStudyResultsInstanceQPId_;
    }

    void StatisticalStudyResultsBaseType::
    ThisStatisticalStudyResultsInstanceQPId (const ThisStatisticalStudyResultsInstanceQPId_type& x)
    {
      this->ThisStatisticalStudyResultsInstanceQPId_.set (x);
    }

    void StatisticalStudyResultsBaseType::
    ThisStatisticalStudyResultsInstanceQPId (const ThisStatisticalStudyResultsInstanceQPId_optional& x)
    {
      this->ThisStatisticalStudyResultsInstanceQPId_ = x;
    }

    void StatisticalStudyResultsBaseType::
    ThisStatisticalStudyResultsInstanceQPId (::std::unique_ptr< ThisStatisticalStudyResultsInstanceQPId_type > x)
    {
      this->ThisStatisticalStudyResultsInstanceQPId_.set (std::move (x));
    }

    const StatisticalStudyResultsBaseType::Attributes_optional& StatisticalStudyResultsBaseType::
    Attributes () const
    {
      return this->Attributes_;
    }

    StatisticalStudyResultsBaseType::Attributes_optional& StatisticalStudyResultsBaseType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void StatisticalStudyResultsBaseType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void StatisticalStudyResultsBaseType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void StatisticalStudyResultsBaseType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const StatisticalStudyResultsBaseType::Status_type& StatisticalStudyResultsBaseType::
    Status () const
    {
      return this->Status_.get ();
    }

    StatisticalStudyResultsBaseType::Status_type& StatisticalStudyResultsBaseType::
    Status ()
    {
      return this->Status_.get ();
    }

    void StatisticalStudyResultsBaseType::
    Status (const Status_type& x)
    {
      this->Status_.set (x);
    }

    void StatisticalStudyResultsBaseType::
    Status (::std::unique_ptr< Status_type > x)
    {
      this->Status_.set (std::move (x));
    }

    const StatisticalStudyResultsBaseType::SoftwareId_optional& StatisticalStudyResultsBaseType::
    SoftwareId () const
    {
      return this->SoftwareId_;
    }

    StatisticalStudyResultsBaseType::SoftwareId_optional& StatisticalStudyResultsBaseType::
    SoftwareId ()
    {
      return this->SoftwareId_;
    }

    void StatisticalStudyResultsBaseType::
    SoftwareId (const SoftwareId_type& x)
    {
      this->SoftwareId_.set (x);
    }

    void StatisticalStudyResultsBaseType::
    SoftwareId (const SoftwareId_optional& x)
    {
      this->SoftwareId_ = x;
    }

    void StatisticalStudyResultsBaseType::
    SoftwareId (::std::unique_ptr< SoftwareId_type > x)
    {
      this->SoftwareId_.set (std::move (x));
    }

    const StatisticalStudyResultsBaseType::StandardId_optional& StatisticalStudyResultsBaseType::
    StandardId () const
    {
      return this->StandardId_;
    }

    StatisticalStudyResultsBaseType::StandardId_optional& StatisticalStudyResultsBaseType::
    StandardId ()
    {
      return this->StandardId_;
    }

    void StatisticalStudyResultsBaseType::
    StandardId (const StandardId_type& x)
    {
      this->StandardId_.set (x);
    }

    void StatisticalStudyResultsBaseType::
    StandardId (const StandardId_optional& x)
    {
      this->StandardId_ = x;
    }

    void StatisticalStudyResultsBaseType::
    StandardId (::std::unique_ptr< StandardId_type > x)
    {
      this->StandardId_.set (std::move (x));
    }

    const StatisticalStudyResultsBaseType::StudyIssues_optional& StatisticalStudyResultsBaseType::
    StudyIssues () const
    {
      return this->StudyIssues_;
    }

    StatisticalStudyResultsBaseType::StudyIssues_optional& StatisticalStudyResultsBaseType::
    StudyIssues ()
    {
      return this->StudyIssues_;
    }

    void StatisticalStudyResultsBaseType::
    StudyIssues (const StudyIssues_type& x)
    {
      this->StudyIssues_.set (x);
    }

    void StatisticalStudyResultsBaseType::
    StudyIssues (const StudyIssues_optional& x)
    {
      this->StudyIssues_ = x;
    }

    void StatisticalStudyResultsBaseType::
    StudyIssues (::std::unique_ptr< StudyIssues_type > x)
    {
      this->StudyIssues_.set (std::move (x));
    }

    const StatisticalStudyResultsBaseType::InspectionTraceability_optional& StatisticalStudyResultsBaseType::
    InspectionTraceability () const
    {
      return this->InspectionTraceability_;
    }

    StatisticalStudyResultsBaseType::InspectionTraceability_optional& StatisticalStudyResultsBaseType::
    InspectionTraceability ()
    {
      return this->InspectionTraceability_;
    }

    void StatisticalStudyResultsBaseType::
    InspectionTraceability (const InspectionTraceability_type& x)
    {
      this->InspectionTraceability_.set (x);
    }

    void StatisticalStudyResultsBaseType::
    InspectionTraceability (const InspectionTraceability_optional& x)
    {
      this->InspectionTraceability_ = x;
    }

    void StatisticalStudyResultsBaseType::
    InspectionTraceability (::std::unique_ptr< InspectionTraceability_type > x)
    {
      this->InspectionTraceability_.set (std::move (x));
    }

    const StatisticalStudyResultsBaseType::Name_optional& StatisticalStudyResultsBaseType::
    Name () const
    {
      return this->Name_;
    }

    StatisticalStudyResultsBaseType::Name_optional& StatisticalStudyResultsBaseType::
    Name ()
    {
      return this->Name_;
    }

    void StatisticalStudyResultsBaseType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void StatisticalStudyResultsBaseType::
    Name (const Name_optional& x)
    {
      this->Name_ = x;
    }

    void StatisticalStudyResultsBaseType::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const StatisticalStudyResultsBaseType::Description_optional& StatisticalStudyResultsBaseType::
    Description () const
    {
      return this->Description_;
    }

    StatisticalStudyResultsBaseType::Description_optional& StatisticalStudyResultsBaseType::
    Description ()
    {
      return this->Description_;
    }

    void StatisticalStudyResultsBaseType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void StatisticalStudyResultsBaseType::
    Description (const Description_optional& x)
    {
      this->Description_ = x;
    }

    void StatisticalStudyResultsBaseType::
    Description (::std::unique_ptr< Description_type > x)
    {
      this->Description_.set (std::move (x));
    }

    const StatisticalStudyResultsBaseType::StudyId_optional& StatisticalStudyResultsBaseType::
    StudyId () const
    {
      return this->StudyId_;
    }

    StatisticalStudyResultsBaseType::StudyId_optional& StatisticalStudyResultsBaseType::
    StudyId ()
    {
      return this->StudyId_;
    }

    void StatisticalStudyResultsBaseType::
    StudyId (const StudyId_type& x)
    {
      this->StudyId_.set (x);
    }

    void StatisticalStudyResultsBaseType::
    StudyId (const StudyId_optional& x)
    {
      this->StudyId_ = x;
    }

    void StatisticalStudyResultsBaseType::
    StudyId (::std::unique_ptr< StudyId_type > x)
    {
      this->StudyId_.set (std::move (x));
    }

    const StatisticalStudyResultsBaseType::ResultsIds_optional& StatisticalStudyResultsBaseType::
    ResultsIds () const
    {
      return this->ResultsIds_;
    }

    StatisticalStudyResultsBaseType::ResultsIds_optional& StatisticalStudyResultsBaseType::
    ResultsIds ()
    {
      return this->ResultsIds_;
    }

    void StatisticalStudyResultsBaseType::
    ResultsIds (const ResultsIds_type& x)
    {
      this->ResultsIds_.set (x);
    }

    void StatisticalStudyResultsBaseType::
    ResultsIds (const ResultsIds_optional& x)
    {
      this->ResultsIds_ = x;
    }

    void StatisticalStudyResultsBaseType::
    ResultsIds (::std::unique_ptr< ResultsIds_type > x)
    {
      this->ResultsIds_.set (std::move (x));
    }

    const StatisticalStudyResultsBaseType::ResultsQPIds_sequence& StatisticalStudyResultsBaseType::
    ResultsQPIds () const
    {
      return this->ResultsQPIds_;
    }

    StatisticalStudyResultsBaseType::ResultsQPIds_sequence& StatisticalStudyResultsBaseType::
    ResultsQPIds ()
    {
      return this->ResultsQPIds_;
    }

    void StatisticalStudyResultsBaseType::
    ResultsQPIds (const ResultsQPIds_sequence& s)
    {
      this->ResultsQPIds_ = s;
    }

    const StatisticalStudyResultsBaseType::ResultsFiles_optional& StatisticalStudyResultsBaseType::
    ResultsFiles () const
    {
      return this->ResultsFiles_;
    }

    StatisticalStudyResultsBaseType::ResultsFiles_optional& StatisticalStudyResultsBaseType::
    ResultsFiles ()
    {
      return this->ResultsFiles_;
    }

    void StatisticalStudyResultsBaseType::
    ResultsFiles (const ResultsFiles_type& x)
    {
      this->ResultsFiles_.set (x);
    }

    void StatisticalStudyResultsBaseType::
    ResultsFiles (const ResultsFiles_optional& x)
    {
      this->ResultsFiles_ = x;
    }

    void StatisticalStudyResultsBaseType::
    ResultsFiles (::std::unique_ptr< ResultsFiles_type > x)
    {
      this->ResultsFiles_.set (std::move (x));
    }

    const StatisticalStudyResultsBaseType::AverageFeatures_optional& StatisticalStudyResultsBaseType::
    AverageFeatures () const
    {
      return this->AverageFeatures_;
    }

    StatisticalStudyResultsBaseType::AverageFeatures_optional& StatisticalStudyResultsBaseType::
    AverageFeatures ()
    {
      return this->AverageFeatures_;
    }

    void StatisticalStudyResultsBaseType::
    AverageFeatures (const AverageFeatures_type& x)
    {
      this->AverageFeatures_.set (x);
    }

    void StatisticalStudyResultsBaseType::
    AverageFeatures (const AverageFeatures_optional& x)
    {
      this->AverageFeatures_ = x;
    }

    void StatisticalStudyResultsBaseType::
    AverageFeatures (::std::unique_ptr< AverageFeatures_type > x)
    {
      this->AverageFeatures_.set (std::move (x));
    }

    const StatisticalStudyResultsBaseType::CharacteristicsStats_optional& StatisticalStudyResultsBaseType::
    CharacteristicsStats () const
    {
      return this->CharacteristicsStats_;
    }

    StatisticalStudyResultsBaseType::CharacteristicsStats_optional& StatisticalStudyResultsBaseType::
    CharacteristicsStats ()
    {
      return this->CharacteristicsStats_;
    }

    void StatisticalStudyResultsBaseType::
    CharacteristicsStats (const CharacteristicsStats_type& x)
    {
      this->CharacteristicsStats_.set (x);
    }

    void StatisticalStudyResultsBaseType::
    CharacteristicsStats (const CharacteristicsStats_optional& x)
    {
      this->CharacteristicsStats_ = x;
    }

    void StatisticalStudyResultsBaseType::
    CharacteristicsStats (::std::unique_ptr< CharacteristicsStats_type > x)
    {
      this->CharacteristicsStats_.set (std::move (x));
    }

    const StatisticalStudyResultsBaseType::LinearStatsSummaries_optional& StatisticalStudyResultsBaseType::
    LinearStatsSummaries () const
    {
      return this->LinearStatsSummaries_;
    }

    StatisticalStudyResultsBaseType::LinearStatsSummaries_optional& StatisticalStudyResultsBaseType::
    LinearStatsSummaries ()
    {
      return this->LinearStatsSummaries_;
    }

    void StatisticalStudyResultsBaseType::
    LinearStatsSummaries (const LinearStatsSummaries_type& x)
    {
      this->LinearStatsSummaries_.set (x);
    }

    void StatisticalStudyResultsBaseType::
    LinearStatsSummaries (const LinearStatsSummaries_optional& x)
    {
      this->LinearStatsSummaries_ = x;
    }

    void StatisticalStudyResultsBaseType::
    LinearStatsSummaries (::std::unique_ptr< LinearStatsSummaries_type > x)
    {
      this->LinearStatsSummaries_.set (std::move (x));
    }

    const StatisticalStudyResultsBaseType::AngularStatsSummaries_optional& StatisticalStudyResultsBaseType::
    AngularStatsSummaries () const
    {
      return this->AngularStatsSummaries_;
    }

    StatisticalStudyResultsBaseType::AngularStatsSummaries_optional& StatisticalStudyResultsBaseType::
    AngularStatsSummaries ()
    {
      return this->AngularStatsSummaries_;
    }

    void StatisticalStudyResultsBaseType::
    AngularStatsSummaries (const AngularStatsSummaries_type& x)
    {
      this->AngularStatsSummaries_.set (x);
    }

    void StatisticalStudyResultsBaseType::
    AngularStatsSummaries (const AngularStatsSummaries_optional& x)
    {
      this->AngularStatsSummaries_ = x;
    }

    void StatisticalStudyResultsBaseType::
    AngularStatsSummaries (::std::unique_ptr< AngularStatsSummaries_type > x)
    {
      this->AngularStatsSummaries_.set (std::move (x));
    }

    const StatisticalStudyResultsBaseType::AreaStatsSummaries_optional& StatisticalStudyResultsBaseType::
    AreaStatsSummaries () const
    {
      return this->AreaStatsSummaries_;
    }

    StatisticalStudyResultsBaseType::AreaStatsSummaries_optional& StatisticalStudyResultsBaseType::
    AreaStatsSummaries ()
    {
      return this->AreaStatsSummaries_;
    }

    void StatisticalStudyResultsBaseType::
    AreaStatsSummaries (const AreaStatsSummaries_type& x)
    {
      this->AreaStatsSummaries_.set (x);
    }

    void StatisticalStudyResultsBaseType::
    AreaStatsSummaries (const AreaStatsSummaries_optional& x)
    {
      this->AreaStatsSummaries_ = x;
    }

    void StatisticalStudyResultsBaseType::
    AreaStatsSummaries (::std::unique_ptr< AreaStatsSummaries_type > x)
    {
      this->AreaStatsSummaries_.set (std::move (x));
    }

    const StatisticalStudyResultsBaseType::ForceStatsSummaries_optional& StatisticalStudyResultsBaseType::
    ForceStatsSummaries () const
    {
      return this->ForceStatsSummaries_;
    }

    StatisticalStudyResultsBaseType::ForceStatsSummaries_optional& StatisticalStudyResultsBaseType::
    ForceStatsSummaries ()
    {
      return this->ForceStatsSummaries_;
    }

    void StatisticalStudyResultsBaseType::
    ForceStatsSummaries (const ForceStatsSummaries_type& x)
    {
      this->ForceStatsSummaries_.set (x);
    }

    void StatisticalStudyResultsBaseType::
    ForceStatsSummaries (const ForceStatsSummaries_optional& x)
    {
      this->ForceStatsSummaries_ = x;
    }

    void StatisticalStudyResultsBaseType::
    ForceStatsSummaries (::std::unique_ptr< ForceStatsSummaries_type > x)
    {
      this->ForceStatsSummaries_.set (std::move (x));
    }

    const StatisticalStudyResultsBaseType::MassStatsSummaries_optional& StatisticalStudyResultsBaseType::
    MassStatsSummaries () const
    {
      return this->MassStatsSummaries_;
    }

    StatisticalStudyResultsBaseType::MassStatsSummaries_optional& StatisticalStudyResultsBaseType::
    MassStatsSummaries ()
    {
      return this->MassStatsSummaries_;
    }

    void StatisticalStudyResultsBaseType::
    MassStatsSummaries (const MassStatsSummaries_type& x)
    {
      this->MassStatsSummaries_.set (x);
    }

    void StatisticalStudyResultsBaseType::
    MassStatsSummaries (const MassStatsSummaries_optional& x)
    {
      this->MassStatsSummaries_ = x;
    }

    void StatisticalStudyResultsBaseType::
    MassStatsSummaries (::std::unique_ptr< MassStatsSummaries_type > x)
    {
      this->MassStatsSummaries_.set (std::move (x));
    }

    const StatisticalStudyResultsBaseType::PressureStatsSummaries_optional& StatisticalStudyResultsBaseType::
    PressureStatsSummaries () const
    {
      return this->PressureStatsSummaries_;
    }

    StatisticalStudyResultsBaseType::PressureStatsSummaries_optional& StatisticalStudyResultsBaseType::
    PressureStatsSummaries ()
    {
      return this->PressureStatsSummaries_;
    }

    void StatisticalStudyResultsBaseType::
    PressureStatsSummaries (const PressureStatsSummaries_type& x)
    {
      this->PressureStatsSummaries_.set (x);
    }

    void StatisticalStudyResultsBaseType::
    PressureStatsSummaries (const PressureStatsSummaries_optional& x)
    {
      this->PressureStatsSummaries_ = x;
    }

    void StatisticalStudyResultsBaseType::
    PressureStatsSummaries (::std::unique_ptr< PressureStatsSummaries_type > x)
    {
      this->PressureStatsSummaries_.set (std::move (x));
    }

    const StatisticalStudyResultsBaseType::SpeedStatsSummaries_optional& StatisticalStudyResultsBaseType::
    SpeedStatsSummaries () const
    {
      return this->SpeedStatsSummaries_;
    }

    StatisticalStudyResultsBaseType::SpeedStatsSummaries_optional& StatisticalStudyResultsBaseType::
    SpeedStatsSummaries ()
    {
      return this->SpeedStatsSummaries_;
    }

    void StatisticalStudyResultsBaseType::
    SpeedStatsSummaries (const SpeedStatsSummaries_type& x)
    {
      this->SpeedStatsSummaries_.set (x);
    }

    void StatisticalStudyResultsBaseType::
    SpeedStatsSummaries (const SpeedStatsSummaries_optional& x)
    {
      this->SpeedStatsSummaries_ = x;
    }

    void StatisticalStudyResultsBaseType::
    SpeedStatsSummaries (::std::unique_ptr< SpeedStatsSummaries_type > x)
    {
      this->SpeedStatsSummaries_.set (std::move (x));
    }

    const StatisticalStudyResultsBaseType::TemperatureStatsSummaries_optional& StatisticalStudyResultsBaseType::
    TemperatureStatsSummaries () const
    {
      return this->TemperatureStatsSummaries_;
    }

    StatisticalStudyResultsBaseType::TemperatureStatsSummaries_optional& StatisticalStudyResultsBaseType::
    TemperatureStatsSummaries ()
    {
      return this->TemperatureStatsSummaries_;
    }

    void StatisticalStudyResultsBaseType::
    TemperatureStatsSummaries (const TemperatureStatsSummaries_type& x)
    {
      this->TemperatureStatsSummaries_.set (x);
    }

    void StatisticalStudyResultsBaseType::
    TemperatureStatsSummaries (const TemperatureStatsSummaries_optional& x)
    {
      this->TemperatureStatsSummaries_ = x;
    }

    void StatisticalStudyResultsBaseType::
    TemperatureStatsSummaries (::std::unique_ptr< TemperatureStatsSummaries_type > x)
    {
      this->TemperatureStatsSummaries_.set (std::move (x));
    }

    const StatisticalStudyResultsBaseType::TimeStatsSummaries_optional& StatisticalStudyResultsBaseType::
    TimeStatsSummaries () const
    {
      return this->TimeStatsSummaries_;
    }

    StatisticalStudyResultsBaseType::TimeStatsSummaries_optional& StatisticalStudyResultsBaseType::
    TimeStatsSummaries ()
    {
      return this->TimeStatsSummaries_;
    }

    void StatisticalStudyResultsBaseType::
    TimeStatsSummaries (const TimeStatsSummaries_type& x)
    {
      this->TimeStatsSummaries_.set (x);
    }

    void StatisticalStudyResultsBaseType::
    TimeStatsSummaries (const TimeStatsSummaries_optional& x)
    {
      this->TimeStatsSummaries_ = x;
    }

    void StatisticalStudyResultsBaseType::
    TimeStatsSummaries (::std::unique_ptr< TimeStatsSummaries_type > x)
    {
      this->TimeStatsSummaries_.set (std::move (x));
    }

    const StatisticalStudyResultsBaseType::UserDefinedUnitStatsSummaries_optional& StatisticalStudyResultsBaseType::
    UserDefinedUnitStatsSummaries () const
    {
      return this->UserDefinedUnitStatsSummaries_;
    }

    StatisticalStudyResultsBaseType::UserDefinedUnitStatsSummaries_optional& StatisticalStudyResultsBaseType::
    UserDefinedUnitStatsSummaries ()
    {
      return this->UserDefinedUnitStatsSummaries_;
    }

    void StatisticalStudyResultsBaseType::
    UserDefinedUnitStatsSummaries (const UserDefinedUnitStatsSummaries_type& x)
    {
      this->UserDefinedUnitStatsSummaries_.set (x);
    }

    void StatisticalStudyResultsBaseType::
    UserDefinedUnitStatsSummaries (const UserDefinedUnitStatsSummaries_optional& x)
    {
      this->UserDefinedUnitStatsSummaries_ = x;
    }

    void StatisticalStudyResultsBaseType::
    UserDefinedUnitStatsSummaries (::std::unique_ptr< UserDefinedUnitStatsSummaries_type > x)
    {
      this->UserDefinedUnitStatsSummaries_.set (std::move (x));
    }

    const StatisticalStudyResultsBaseType::StatsSummaries_optional& StatisticalStudyResultsBaseType::
    StatsSummaries () const
    {
      return this->StatsSummaries_;
    }

    StatisticalStudyResultsBaseType::StatsSummaries_optional& StatisticalStudyResultsBaseType::
    StatsSummaries ()
    {
      return this->StatsSummaries_;
    }

    void StatisticalStudyResultsBaseType::
    StatsSummaries (const StatsSummaries_type& x)
    {
      this->StatsSummaries_.set (x);
    }

    void StatisticalStudyResultsBaseType::
    StatsSummaries (const StatsSummaries_optional& x)
    {
      this->StatsSummaries_ = x;
    }

    void StatisticalStudyResultsBaseType::
    StatsSummaries (::std::unique_ptr< StatsSummaries_type > x)
    {
      this->StatsSummaries_.set (std::move (x));
    }

    const StatisticalStudyResultsBaseType::id_type& StatisticalStudyResultsBaseType::
    id () const
    {
      return this->id_.get ();
    }

    StatisticalStudyResultsBaseType::id_type& StatisticalStudyResultsBaseType::
    id ()
    {
      return this->id_.get ();
    }

    void StatisticalStudyResultsBaseType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void StatisticalStudyResultsBaseType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // LinearityStudyResultsType
    //

    const LinearityStudyResultsType::SampleSize_type& LinearityStudyResultsType::
    SampleSize () const
    {
      return this->SampleSize_.get ();
    }

    LinearityStudyResultsType::SampleSize_type& LinearityStudyResultsType::
    SampleSize ()
    {
      return this->SampleSize_.get ();
    }

    void LinearityStudyResultsType::
    SampleSize (const SampleSize_type& x)
    {
      this->SampleSize_.set (x);
    }

    const LinearityStudyResultsType::MeasurementDeviceIds_optional& LinearityStudyResultsType::
    MeasurementDeviceIds () const
    {
      return this->MeasurementDeviceIds_;
    }

    LinearityStudyResultsType::MeasurementDeviceIds_optional& LinearityStudyResultsType::
    MeasurementDeviceIds ()
    {
      return this->MeasurementDeviceIds_;
    }

    void LinearityStudyResultsType::
    MeasurementDeviceIds (const MeasurementDeviceIds_type& x)
    {
      this->MeasurementDeviceIds_.set (x);
    }

    void LinearityStudyResultsType::
    MeasurementDeviceIds (const MeasurementDeviceIds_optional& x)
    {
      this->MeasurementDeviceIds_ = x;
    }

    void LinearityStudyResultsType::
    MeasurementDeviceIds (::std::unique_ptr< MeasurementDeviceIds_type > x)
    {
      this->MeasurementDeviceIds_.set (std::move (x));
    }

    const LinearityStudyResultsType::GoodnessOfFit_optional& LinearityStudyResultsType::
    GoodnessOfFit () const
    {
      return this->GoodnessOfFit_;
    }

    LinearityStudyResultsType::GoodnessOfFit_optional& LinearityStudyResultsType::
    GoodnessOfFit ()
    {
      return this->GoodnessOfFit_;
    }

    void LinearityStudyResultsType::
    GoodnessOfFit (const GoodnessOfFit_type& x)
    {
      this->GoodnessOfFit_.set (x);
    }

    void LinearityStudyResultsType::
    GoodnessOfFit (const GoodnessOfFit_optional& x)
    {
      this->GoodnessOfFit_ = x;
    }

    void LinearityStudyResultsType::
    GoodnessOfFit (::std::unique_ptr< GoodnessOfFit_type > x)
    {
      this->GoodnessOfFit_.set (std::move (x));
    }

    const LinearityStudyResultsType::LinearAbsoluteLinearity_optional& LinearityStudyResultsType::
    LinearAbsoluteLinearity () const
    {
      return this->LinearAbsoluteLinearity_;
    }

    LinearityStudyResultsType::LinearAbsoluteLinearity_optional& LinearityStudyResultsType::
    LinearAbsoluteLinearity ()
    {
      return this->LinearAbsoluteLinearity_;
    }

    void LinearityStudyResultsType::
    LinearAbsoluteLinearity (const LinearAbsoluteLinearity_type& x)
    {
      this->LinearAbsoluteLinearity_.set (x);
    }

    void LinearityStudyResultsType::
    LinearAbsoluteLinearity (const LinearAbsoluteLinearity_optional& x)
    {
      this->LinearAbsoluteLinearity_ = x;
    }

    void LinearityStudyResultsType::
    LinearAbsoluteLinearity (::std::unique_ptr< LinearAbsoluteLinearity_type > x)
    {
      this->LinearAbsoluteLinearity_.set (std::move (x));
    }

    const LinearityStudyResultsType::AngularAbsoluteLinearity_optional& LinearityStudyResultsType::
    AngularAbsoluteLinearity () const
    {
      return this->AngularAbsoluteLinearity_;
    }

    LinearityStudyResultsType::AngularAbsoluteLinearity_optional& LinearityStudyResultsType::
    AngularAbsoluteLinearity ()
    {
      return this->AngularAbsoluteLinearity_;
    }

    void LinearityStudyResultsType::
    AngularAbsoluteLinearity (const AngularAbsoluteLinearity_type& x)
    {
      this->AngularAbsoluteLinearity_.set (x);
    }

    void LinearityStudyResultsType::
    AngularAbsoluteLinearity (const AngularAbsoluteLinearity_optional& x)
    {
      this->AngularAbsoluteLinearity_ = x;
    }

    void LinearityStudyResultsType::
    AngularAbsoluteLinearity (::std::unique_ptr< AngularAbsoluteLinearity_type > x)
    {
      this->AngularAbsoluteLinearity_.set (std::move (x));
    }

    const LinearityStudyResultsType::AreaAbsoluteLinearity_optional& LinearityStudyResultsType::
    AreaAbsoluteLinearity () const
    {
      return this->AreaAbsoluteLinearity_;
    }

    LinearityStudyResultsType::AreaAbsoluteLinearity_optional& LinearityStudyResultsType::
    AreaAbsoluteLinearity ()
    {
      return this->AreaAbsoluteLinearity_;
    }

    void LinearityStudyResultsType::
    AreaAbsoluteLinearity (const AreaAbsoluteLinearity_type& x)
    {
      this->AreaAbsoluteLinearity_.set (x);
    }

    void LinearityStudyResultsType::
    AreaAbsoluteLinearity (const AreaAbsoluteLinearity_optional& x)
    {
      this->AreaAbsoluteLinearity_ = x;
    }

    void LinearityStudyResultsType::
    AreaAbsoluteLinearity (::std::unique_ptr< AreaAbsoluteLinearity_type > x)
    {
      this->AreaAbsoluteLinearity_.set (std::move (x));
    }

    const LinearityStudyResultsType::ForceAbsoluteLinearity_optional& LinearityStudyResultsType::
    ForceAbsoluteLinearity () const
    {
      return this->ForceAbsoluteLinearity_;
    }

    LinearityStudyResultsType::ForceAbsoluteLinearity_optional& LinearityStudyResultsType::
    ForceAbsoluteLinearity ()
    {
      return this->ForceAbsoluteLinearity_;
    }

    void LinearityStudyResultsType::
    ForceAbsoluteLinearity (const ForceAbsoluteLinearity_type& x)
    {
      this->ForceAbsoluteLinearity_.set (x);
    }

    void LinearityStudyResultsType::
    ForceAbsoluteLinearity (const ForceAbsoluteLinearity_optional& x)
    {
      this->ForceAbsoluteLinearity_ = x;
    }

    void LinearityStudyResultsType::
    ForceAbsoluteLinearity (::std::unique_ptr< ForceAbsoluteLinearity_type > x)
    {
      this->ForceAbsoluteLinearity_.set (std::move (x));
    }

    const LinearityStudyResultsType::MassAbsoluteLinearity_optional& LinearityStudyResultsType::
    MassAbsoluteLinearity () const
    {
      return this->MassAbsoluteLinearity_;
    }

    LinearityStudyResultsType::MassAbsoluteLinearity_optional& LinearityStudyResultsType::
    MassAbsoluteLinearity ()
    {
      return this->MassAbsoluteLinearity_;
    }

    void LinearityStudyResultsType::
    MassAbsoluteLinearity (const MassAbsoluteLinearity_type& x)
    {
      this->MassAbsoluteLinearity_.set (x);
    }

    void LinearityStudyResultsType::
    MassAbsoluteLinearity (const MassAbsoluteLinearity_optional& x)
    {
      this->MassAbsoluteLinearity_ = x;
    }

    void LinearityStudyResultsType::
    MassAbsoluteLinearity (::std::unique_ptr< MassAbsoluteLinearity_type > x)
    {
      this->MassAbsoluteLinearity_.set (std::move (x));
    }

    const LinearityStudyResultsType::PressureAbsoluteLinearity_optional& LinearityStudyResultsType::
    PressureAbsoluteLinearity () const
    {
      return this->PressureAbsoluteLinearity_;
    }

    LinearityStudyResultsType::PressureAbsoluteLinearity_optional& LinearityStudyResultsType::
    PressureAbsoluteLinearity ()
    {
      return this->PressureAbsoluteLinearity_;
    }

    void LinearityStudyResultsType::
    PressureAbsoluteLinearity (const PressureAbsoluteLinearity_type& x)
    {
      this->PressureAbsoluteLinearity_.set (x);
    }

    void LinearityStudyResultsType::
    PressureAbsoluteLinearity (const PressureAbsoluteLinearity_optional& x)
    {
      this->PressureAbsoluteLinearity_ = x;
    }

    void LinearityStudyResultsType::
    PressureAbsoluteLinearity (::std::unique_ptr< PressureAbsoluteLinearity_type > x)
    {
      this->PressureAbsoluteLinearity_.set (std::move (x));
    }

    const LinearityStudyResultsType::SpeedAbsoluteLinearity_optional& LinearityStudyResultsType::
    SpeedAbsoluteLinearity () const
    {
      return this->SpeedAbsoluteLinearity_;
    }

    LinearityStudyResultsType::SpeedAbsoluteLinearity_optional& LinearityStudyResultsType::
    SpeedAbsoluteLinearity ()
    {
      return this->SpeedAbsoluteLinearity_;
    }

    void LinearityStudyResultsType::
    SpeedAbsoluteLinearity (const SpeedAbsoluteLinearity_type& x)
    {
      this->SpeedAbsoluteLinearity_.set (x);
    }

    void LinearityStudyResultsType::
    SpeedAbsoluteLinearity (const SpeedAbsoluteLinearity_optional& x)
    {
      this->SpeedAbsoluteLinearity_ = x;
    }

    void LinearityStudyResultsType::
    SpeedAbsoluteLinearity (::std::unique_ptr< SpeedAbsoluteLinearity_type > x)
    {
      this->SpeedAbsoluteLinearity_.set (std::move (x));
    }

    const LinearityStudyResultsType::TemperatureAbsoluteLinearity_optional& LinearityStudyResultsType::
    TemperatureAbsoluteLinearity () const
    {
      return this->TemperatureAbsoluteLinearity_;
    }

    LinearityStudyResultsType::TemperatureAbsoluteLinearity_optional& LinearityStudyResultsType::
    TemperatureAbsoluteLinearity ()
    {
      return this->TemperatureAbsoluteLinearity_;
    }

    void LinearityStudyResultsType::
    TemperatureAbsoluteLinearity (const TemperatureAbsoluteLinearity_type& x)
    {
      this->TemperatureAbsoluteLinearity_.set (x);
    }

    void LinearityStudyResultsType::
    TemperatureAbsoluteLinearity (const TemperatureAbsoluteLinearity_optional& x)
    {
      this->TemperatureAbsoluteLinearity_ = x;
    }

    void LinearityStudyResultsType::
    TemperatureAbsoluteLinearity (::std::unique_ptr< TemperatureAbsoluteLinearity_type > x)
    {
      this->TemperatureAbsoluteLinearity_.set (std::move (x));
    }

    const LinearityStudyResultsType::TimeAbsoluteLinearity_optional& LinearityStudyResultsType::
    TimeAbsoluteLinearity () const
    {
      return this->TimeAbsoluteLinearity_;
    }

    LinearityStudyResultsType::TimeAbsoluteLinearity_optional& LinearityStudyResultsType::
    TimeAbsoluteLinearity ()
    {
      return this->TimeAbsoluteLinearity_;
    }

    void LinearityStudyResultsType::
    TimeAbsoluteLinearity (const TimeAbsoluteLinearity_type& x)
    {
      this->TimeAbsoluteLinearity_.set (x);
    }

    void LinearityStudyResultsType::
    TimeAbsoluteLinearity (const TimeAbsoluteLinearity_optional& x)
    {
      this->TimeAbsoluteLinearity_ = x;
    }

    void LinearityStudyResultsType::
    TimeAbsoluteLinearity (::std::unique_ptr< TimeAbsoluteLinearity_type > x)
    {
      this->TimeAbsoluteLinearity_.set (std::move (x));
    }

    const LinearityStudyResultsType::UserDefinedUnitAbsoluteLinearity_optional& LinearityStudyResultsType::
    UserDefinedUnitAbsoluteLinearity () const
    {
      return this->UserDefinedUnitAbsoluteLinearity_;
    }

    LinearityStudyResultsType::UserDefinedUnitAbsoluteLinearity_optional& LinearityStudyResultsType::
    UserDefinedUnitAbsoluteLinearity ()
    {
      return this->UserDefinedUnitAbsoluteLinearity_;
    }

    void LinearityStudyResultsType::
    UserDefinedUnitAbsoluteLinearity (const UserDefinedUnitAbsoluteLinearity_type& x)
    {
      this->UserDefinedUnitAbsoluteLinearity_.set (x);
    }

    void LinearityStudyResultsType::
    UserDefinedUnitAbsoluteLinearity (const UserDefinedUnitAbsoluteLinearity_optional& x)
    {
      this->UserDefinedUnitAbsoluteLinearity_ = x;
    }

    void LinearityStudyResultsType::
    UserDefinedUnitAbsoluteLinearity (::std::unique_ptr< UserDefinedUnitAbsoluteLinearity_type > x)
    {
      this->UserDefinedUnitAbsoluteLinearity_.set (std::move (x));
    }

    const LinearityStudyResultsType::RelativeLinearity_optional& LinearityStudyResultsType::
    RelativeLinearity () const
    {
      return this->RelativeLinearity_;
    }

    LinearityStudyResultsType::RelativeLinearity_optional& LinearityStudyResultsType::
    RelativeLinearity ()
    {
      return this->RelativeLinearity_;
    }

    void LinearityStudyResultsType::
    RelativeLinearity (const RelativeLinearity_type& x)
    {
      this->RelativeLinearity_.set (x);
    }

    void LinearityStudyResultsType::
    RelativeLinearity (const RelativeLinearity_optional& x)
    {
      this->RelativeLinearity_ = x;
    }

    void LinearityStudyResultsType::
    RelativeLinearity (::std::unique_ptr< RelativeLinearity_type > x)
    {
      this->RelativeLinearity_.set (std::move (x));
    }


    // StabilityStudyResultsType
    //

    const StabilityStudyResultsType::SampleSize_type& StabilityStudyResultsType::
    SampleSize () const
    {
      return this->SampleSize_.get ();
    }

    StabilityStudyResultsType::SampleSize_type& StabilityStudyResultsType::
    SampleSize ()
    {
      return this->SampleSize_.get ();
    }

    void StabilityStudyResultsType::
    SampleSize (const SampleSize_type& x)
    {
      this->SampleSize_.set (x);
    }

    const StabilityStudyResultsType::MeasurementDeviceIds_optional& StabilityStudyResultsType::
    MeasurementDeviceIds () const
    {
      return this->MeasurementDeviceIds_;
    }

    StabilityStudyResultsType::MeasurementDeviceIds_optional& StabilityStudyResultsType::
    MeasurementDeviceIds ()
    {
      return this->MeasurementDeviceIds_;
    }

    void StabilityStudyResultsType::
    MeasurementDeviceIds (const MeasurementDeviceIds_type& x)
    {
      this->MeasurementDeviceIds_.set (x);
    }

    void StabilityStudyResultsType::
    MeasurementDeviceIds (const MeasurementDeviceIds_optional& x)
    {
      this->MeasurementDeviceIds_ = x;
    }

    void StabilityStudyResultsType::
    MeasurementDeviceIds (::std::unique_ptr< MeasurementDeviceIds_type > x)
    {
      this->MeasurementDeviceIds_.set (std::move (x));
    }


    // BiasStudyResultsType
    //

    const BiasStudyResultsType::SampleSize_type& BiasStudyResultsType::
    SampleSize () const
    {
      return this->SampleSize_.get ();
    }

    BiasStudyResultsType::SampleSize_type& BiasStudyResultsType::
    SampleSize ()
    {
      return this->SampleSize_.get ();
    }

    void BiasStudyResultsType::
    SampleSize (const SampleSize_type& x)
    {
      this->SampleSize_.set (x);
    }

    const BiasStudyResultsType::MeasurementDeviceIds_optional& BiasStudyResultsType::
    MeasurementDeviceIds () const
    {
      return this->MeasurementDeviceIds_;
    }

    BiasStudyResultsType::MeasurementDeviceIds_optional& BiasStudyResultsType::
    MeasurementDeviceIds ()
    {
      return this->MeasurementDeviceIds_;
    }

    void BiasStudyResultsType::
    MeasurementDeviceIds (const MeasurementDeviceIds_type& x)
    {
      this->MeasurementDeviceIds_.set (x);
    }

    void BiasStudyResultsType::
    MeasurementDeviceIds (const MeasurementDeviceIds_optional& x)
    {
      this->MeasurementDeviceIds_ = x;
    }

    void BiasStudyResultsType::
    MeasurementDeviceIds (::std::unique_ptr< MeasurementDeviceIds_type > x)
    {
      this->MeasurementDeviceIds_.set (std::move (x));
    }


    // AbsoluteMeasurementsByUnitType
    //

    const AbsoluteMeasurementsByUnitType::LinearMeasurement_optional& AbsoluteMeasurementsByUnitType::
    LinearMeasurement () const
    {
      return this->LinearMeasurement_;
    }

    AbsoluteMeasurementsByUnitType::LinearMeasurement_optional& AbsoluteMeasurementsByUnitType::
    LinearMeasurement ()
    {
      return this->LinearMeasurement_;
    }

    void AbsoluteMeasurementsByUnitType::
    LinearMeasurement (const LinearMeasurement_type& x)
    {
      this->LinearMeasurement_.set (x);
    }

    void AbsoluteMeasurementsByUnitType::
    LinearMeasurement (const LinearMeasurement_optional& x)
    {
      this->LinearMeasurement_ = x;
    }

    void AbsoluteMeasurementsByUnitType::
    LinearMeasurement (::std::unique_ptr< LinearMeasurement_type > x)
    {
      this->LinearMeasurement_.set (std::move (x));
    }

    const AbsoluteMeasurementsByUnitType::AngularMeasurement_optional& AbsoluteMeasurementsByUnitType::
    AngularMeasurement () const
    {
      return this->AngularMeasurement_;
    }

    AbsoluteMeasurementsByUnitType::AngularMeasurement_optional& AbsoluteMeasurementsByUnitType::
    AngularMeasurement ()
    {
      return this->AngularMeasurement_;
    }

    void AbsoluteMeasurementsByUnitType::
    AngularMeasurement (const AngularMeasurement_type& x)
    {
      this->AngularMeasurement_.set (x);
    }

    void AbsoluteMeasurementsByUnitType::
    AngularMeasurement (const AngularMeasurement_optional& x)
    {
      this->AngularMeasurement_ = x;
    }

    void AbsoluteMeasurementsByUnitType::
    AngularMeasurement (::std::unique_ptr< AngularMeasurement_type > x)
    {
      this->AngularMeasurement_.set (std::move (x));
    }

    const AbsoluteMeasurementsByUnitType::AreaMeasurement_optional& AbsoluteMeasurementsByUnitType::
    AreaMeasurement () const
    {
      return this->AreaMeasurement_;
    }

    AbsoluteMeasurementsByUnitType::AreaMeasurement_optional& AbsoluteMeasurementsByUnitType::
    AreaMeasurement ()
    {
      return this->AreaMeasurement_;
    }

    void AbsoluteMeasurementsByUnitType::
    AreaMeasurement (const AreaMeasurement_type& x)
    {
      this->AreaMeasurement_.set (x);
    }

    void AbsoluteMeasurementsByUnitType::
    AreaMeasurement (const AreaMeasurement_optional& x)
    {
      this->AreaMeasurement_ = x;
    }

    void AbsoluteMeasurementsByUnitType::
    AreaMeasurement (::std::unique_ptr< AreaMeasurement_type > x)
    {
      this->AreaMeasurement_.set (std::move (x));
    }

    const AbsoluteMeasurementsByUnitType::ForceMeasurement_optional& AbsoluteMeasurementsByUnitType::
    ForceMeasurement () const
    {
      return this->ForceMeasurement_;
    }

    AbsoluteMeasurementsByUnitType::ForceMeasurement_optional& AbsoluteMeasurementsByUnitType::
    ForceMeasurement ()
    {
      return this->ForceMeasurement_;
    }

    void AbsoluteMeasurementsByUnitType::
    ForceMeasurement (const ForceMeasurement_type& x)
    {
      this->ForceMeasurement_.set (x);
    }

    void AbsoluteMeasurementsByUnitType::
    ForceMeasurement (const ForceMeasurement_optional& x)
    {
      this->ForceMeasurement_ = x;
    }

    void AbsoluteMeasurementsByUnitType::
    ForceMeasurement (::std::unique_ptr< ForceMeasurement_type > x)
    {
      this->ForceMeasurement_.set (std::move (x));
    }

    const AbsoluteMeasurementsByUnitType::MassMeasurement_optional& AbsoluteMeasurementsByUnitType::
    MassMeasurement () const
    {
      return this->MassMeasurement_;
    }

    AbsoluteMeasurementsByUnitType::MassMeasurement_optional& AbsoluteMeasurementsByUnitType::
    MassMeasurement ()
    {
      return this->MassMeasurement_;
    }

    void AbsoluteMeasurementsByUnitType::
    MassMeasurement (const MassMeasurement_type& x)
    {
      this->MassMeasurement_.set (x);
    }

    void AbsoluteMeasurementsByUnitType::
    MassMeasurement (const MassMeasurement_optional& x)
    {
      this->MassMeasurement_ = x;
    }

    void AbsoluteMeasurementsByUnitType::
    MassMeasurement (::std::unique_ptr< MassMeasurement_type > x)
    {
      this->MassMeasurement_.set (std::move (x));
    }

    const AbsoluteMeasurementsByUnitType::PressureMeasurement_optional& AbsoluteMeasurementsByUnitType::
    PressureMeasurement () const
    {
      return this->PressureMeasurement_;
    }

    AbsoluteMeasurementsByUnitType::PressureMeasurement_optional& AbsoluteMeasurementsByUnitType::
    PressureMeasurement ()
    {
      return this->PressureMeasurement_;
    }

    void AbsoluteMeasurementsByUnitType::
    PressureMeasurement (const PressureMeasurement_type& x)
    {
      this->PressureMeasurement_.set (x);
    }

    void AbsoluteMeasurementsByUnitType::
    PressureMeasurement (const PressureMeasurement_optional& x)
    {
      this->PressureMeasurement_ = x;
    }

    void AbsoluteMeasurementsByUnitType::
    PressureMeasurement (::std::unique_ptr< PressureMeasurement_type > x)
    {
      this->PressureMeasurement_.set (std::move (x));
    }

    const AbsoluteMeasurementsByUnitType::SpeedMeasurement_optional& AbsoluteMeasurementsByUnitType::
    SpeedMeasurement () const
    {
      return this->SpeedMeasurement_;
    }

    AbsoluteMeasurementsByUnitType::SpeedMeasurement_optional& AbsoluteMeasurementsByUnitType::
    SpeedMeasurement ()
    {
      return this->SpeedMeasurement_;
    }

    void AbsoluteMeasurementsByUnitType::
    SpeedMeasurement (const SpeedMeasurement_type& x)
    {
      this->SpeedMeasurement_.set (x);
    }

    void AbsoluteMeasurementsByUnitType::
    SpeedMeasurement (const SpeedMeasurement_optional& x)
    {
      this->SpeedMeasurement_ = x;
    }

    void AbsoluteMeasurementsByUnitType::
    SpeedMeasurement (::std::unique_ptr< SpeedMeasurement_type > x)
    {
      this->SpeedMeasurement_.set (std::move (x));
    }

    const AbsoluteMeasurementsByUnitType::TemperatureMeasurement_optional& AbsoluteMeasurementsByUnitType::
    TemperatureMeasurement () const
    {
      return this->TemperatureMeasurement_;
    }

    AbsoluteMeasurementsByUnitType::TemperatureMeasurement_optional& AbsoluteMeasurementsByUnitType::
    TemperatureMeasurement ()
    {
      return this->TemperatureMeasurement_;
    }

    void AbsoluteMeasurementsByUnitType::
    TemperatureMeasurement (const TemperatureMeasurement_type& x)
    {
      this->TemperatureMeasurement_.set (x);
    }

    void AbsoluteMeasurementsByUnitType::
    TemperatureMeasurement (const TemperatureMeasurement_optional& x)
    {
      this->TemperatureMeasurement_ = x;
    }

    void AbsoluteMeasurementsByUnitType::
    TemperatureMeasurement (::std::unique_ptr< TemperatureMeasurement_type > x)
    {
      this->TemperatureMeasurement_.set (std::move (x));
    }

    const AbsoluteMeasurementsByUnitType::TimeMeasurement_optional& AbsoluteMeasurementsByUnitType::
    TimeMeasurement () const
    {
      return this->TimeMeasurement_;
    }

    AbsoluteMeasurementsByUnitType::TimeMeasurement_optional& AbsoluteMeasurementsByUnitType::
    TimeMeasurement ()
    {
      return this->TimeMeasurement_;
    }

    void AbsoluteMeasurementsByUnitType::
    TimeMeasurement (const TimeMeasurement_type& x)
    {
      this->TimeMeasurement_.set (x);
    }

    void AbsoluteMeasurementsByUnitType::
    TimeMeasurement (const TimeMeasurement_optional& x)
    {
      this->TimeMeasurement_ = x;
    }

    void AbsoluteMeasurementsByUnitType::
    TimeMeasurement (::std::unique_ptr< TimeMeasurement_type > x)
    {
      this->TimeMeasurement_.set (std::move (x));
    }

    const AbsoluteMeasurementsByUnitType::UserDefinedUnitMeasurement_sequence& AbsoluteMeasurementsByUnitType::
    UserDefinedUnitMeasurement () const
    {
      return this->UserDefinedUnitMeasurement_;
    }

    AbsoluteMeasurementsByUnitType::UserDefinedUnitMeasurement_sequence& AbsoluteMeasurementsByUnitType::
    UserDefinedUnitMeasurement ()
    {
      return this->UserDefinedUnitMeasurement_;
    }

    void AbsoluteMeasurementsByUnitType::
    UserDefinedUnitMeasurement (const UserDefinedUnitMeasurement_sequence& s)
    {
      this->UserDefinedUnitMeasurement_ = s;
    }

    const AbsoluteMeasurementsByUnitType::n_type& AbsoluteMeasurementsByUnitType::
    n () const
    {
      return this->n_.get ();
    }

    AbsoluteMeasurementsByUnitType::n_type& AbsoluteMeasurementsByUnitType::
    n ()
    {
      return this->n_.get ();
    }

    void AbsoluteMeasurementsByUnitType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void AbsoluteMeasurementsByUnitType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // FirstArticleStudyResultsType
    //

    const FirstArticleStudyResultsType::InSpecRatio_optional& FirstArticleStudyResultsType::
    InSpecRatio () const
    {
      return this->InSpecRatio_;
    }

    FirstArticleStudyResultsType::InSpecRatio_optional& FirstArticleStudyResultsType::
    InSpecRatio ()
    {
      return this->InSpecRatio_;
    }

    void FirstArticleStudyResultsType::
    InSpecRatio (const InSpecRatio_type& x)
    {
      this->InSpecRatio_.set (x);
    }

    void FirstArticleStudyResultsType::
    InSpecRatio (const InSpecRatio_optional& x)
    {
      this->InSpecRatio_ = x;
    }

    const FirstArticleStudyResultsType::AbsoluteMaximums_optional& FirstArticleStudyResultsType::
    AbsoluteMaximums () const
    {
      return this->AbsoluteMaximums_;
    }

    FirstArticleStudyResultsType::AbsoluteMaximums_optional& FirstArticleStudyResultsType::
    AbsoluteMaximums ()
    {
      return this->AbsoluteMaximums_;
    }

    void FirstArticleStudyResultsType::
    AbsoluteMaximums (const AbsoluteMaximums_type& x)
    {
      this->AbsoluteMaximums_.set (x);
    }

    void FirstArticleStudyResultsType::
    AbsoluteMaximums (const AbsoluteMaximums_optional& x)
    {
      this->AbsoluteMaximums_ = x;
    }

    void FirstArticleStudyResultsType::
    AbsoluteMaximums (::std::unique_ptr< AbsoluteMaximums_type > x)
    {
      this->AbsoluteMaximums_.set (std::move (x));
    }

    const FirstArticleStudyResultsType::RelativeMaximum_optional& FirstArticleStudyResultsType::
    RelativeMaximum () const
    {
      return this->RelativeMaximum_;
    }

    FirstArticleStudyResultsType::RelativeMaximum_optional& FirstArticleStudyResultsType::
    RelativeMaximum ()
    {
      return this->RelativeMaximum_;
    }

    void FirstArticleStudyResultsType::
    RelativeMaximum (const RelativeMaximum_type& x)
    {
      this->RelativeMaximum_.set (x);
    }

    void FirstArticleStudyResultsType::
    RelativeMaximum (const RelativeMaximum_optional& x)
    {
      this->RelativeMaximum_ = x;
    }

    void FirstArticleStudyResultsType::
    RelativeMaximum (::std::unique_ptr< RelativeMaximum_type > x)
    {
      this->RelativeMaximum_.set (std::move (x));
    }


    // ProcessDifferenceStudyResultsType
    //

    const ProcessDifferenceStudyResultsType::NumberOfSamples_type& ProcessDifferenceStudyResultsType::
    NumberOfSamples () const
    {
      return this->NumberOfSamples_.get ();
    }

    ProcessDifferenceStudyResultsType::NumberOfSamples_type& ProcessDifferenceStudyResultsType::
    NumberOfSamples ()
    {
      return this->NumberOfSamples_.get ();
    }

    void ProcessDifferenceStudyResultsType::
    NumberOfSamples (const NumberOfSamples_type& x)
    {
      this->NumberOfSamples_.set (x);
    }

    const ProcessDifferenceStudyResultsType::SubgroupSize_type& ProcessDifferenceStudyResultsType::
    SubgroupSize () const
    {
      return this->SubgroupSize_.get ();
    }

    ProcessDifferenceStudyResultsType::SubgroupSize_type& ProcessDifferenceStudyResultsType::
    SubgroupSize ()
    {
      return this->SubgroupSize_.get ();
    }

    void ProcessDifferenceStudyResultsType::
    SubgroupSize (const SubgroupSize_type& x)
    {
      this->SubgroupSize_.set (x);
    }

    ProcessDifferenceStudyResultsType::SubgroupSize_type ProcessDifferenceStudyResultsType::
    SubgroupSize_default_value ()
    {
      return SubgroupSize_type (2ULL);
    }

    const ProcessDifferenceStudyResultsType::ManufacturingProcessId_optional& ProcessDifferenceStudyResultsType::
    ManufacturingProcessId () const
    {
      return this->ManufacturingProcessId_;
    }

    ProcessDifferenceStudyResultsType::ManufacturingProcessId_optional& ProcessDifferenceStudyResultsType::
    ManufacturingProcessId ()
    {
      return this->ManufacturingProcessId_;
    }

    void ProcessDifferenceStudyResultsType::
    ManufacturingProcessId (const ManufacturingProcessId_type& x)
    {
      this->ManufacturingProcessId_.set (x);
    }

    void ProcessDifferenceStudyResultsType::
    ManufacturingProcessId (const ManufacturingProcessId_optional& x)
    {
      this->ManufacturingProcessId_ = x;
    }

    void ProcessDifferenceStudyResultsType::
    ManufacturingProcessId (::std::unique_ptr< ManufacturingProcessId_type > x)
    {
      this->ManufacturingProcessId_.set (std::move (x));
    }

    const ProcessDifferenceStudyResultsType::AbsoluteDifferences_optional& ProcessDifferenceStudyResultsType::
    AbsoluteDifferences () const
    {
      return this->AbsoluteDifferences_;
    }

    ProcessDifferenceStudyResultsType::AbsoluteDifferences_optional& ProcessDifferenceStudyResultsType::
    AbsoluteDifferences ()
    {
      return this->AbsoluteDifferences_;
    }

    void ProcessDifferenceStudyResultsType::
    AbsoluteDifferences (const AbsoluteDifferences_type& x)
    {
      this->AbsoluteDifferences_.set (x);
    }

    void ProcessDifferenceStudyResultsType::
    AbsoluteDifferences (const AbsoluteDifferences_optional& x)
    {
      this->AbsoluteDifferences_ = x;
    }

    void ProcessDifferenceStudyResultsType::
    AbsoluteDifferences (::std::unique_ptr< AbsoluteDifferences_type > x)
    {
      this->AbsoluteDifferences_.set (std::move (x));
    }

    const ProcessDifferenceStudyResultsType::RelativeDifference_optional& ProcessDifferenceStudyResultsType::
    RelativeDifference () const
    {
      return this->RelativeDifference_;
    }

    ProcessDifferenceStudyResultsType::RelativeDifference_optional& ProcessDifferenceStudyResultsType::
    RelativeDifference ()
    {
      return this->RelativeDifference_;
    }

    void ProcessDifferenceStudyResultsType::
    RelativeDifference (const RelativeDifference_type& x)
    {
      this->RelativeDifference_.set (x);
    }

    void ProcessDifferenceStudyResultsType::
    RelativeDifference (const RelativeDifference_optional& x)
    {
      this->RelativeDifference_ = x;
    }

    void ProcessDifferenceStudyResultsType::
    RelativeDifference (::std::unique_ptr< RelativeDifference_type > x)
    {
      this->RelativeDifference_.set (std::move (x));
    }


    // MultipleProductInstanceStudyResultsBaseType
    //

    const MultipleProductInstanceStudyResultsBaseType::NumberOfSamples_type& MultipleProductInstanceStudyResultsBaseType::
    NumberOfSamples () const
    {
      return this->NumberOfSamples_.get ();
    }

    MultipleProductInstanceStudyResultsBaseType::NumberOfSamples_type& MultipleProductInstanceStudyResultsBaseType::
    NumberOfSamples ()
    {
      return this->NumberOfSamples_.get ();
    }

    void MultipleProductInstanceStudyResultsBaseType::
    NumberOfSamples (const NumberOfSamples_type& x)
    {
      this->NumberOfSamples_.set (x);
    }

    const MultipleProductInstanceStudyResultsBaseType::SubgroupSize_optional& MultipleProductInstanceStudyResultsBaseType::
    SubgroupSize () const
    {
      return this->SubgroupSize_;
    }

    MultipleProductInstanceStudyResultsBaseType::SubgroupSize_optional& MultipleProductInstanceStudyResultsBaseType::
    SubgroupSize ()
    {
      return this->SubgroupSize_;
    }

    void MultipleProductInstanceStudyResultsBaseType::
    SubgroupSize (const SubgroupSize_type& x)
    {
      this->SubgroupSize_.set (x);
    }

    void MultipleProductInstanceStudyResultsBaseType::
    SubgroupSize (const SubgroupSize_optional& x)
    {
      this->SubgroupSize_ = x;
    }


    // SimpleStudyResultsType
    //


    // CapabilityStudyResultsType
    //


    // GageRandRStudyResultsType
    //

    const GageRandRStudyResultsType::MeasurementDeviceIds_optional& GageRandRStudyResultsType::
    MeasurementDeviceIds () const
    {
      return this->MeasurementDeviceIds_;
    }

    GageRandRStudyResultsType::MeasurementDeviceIds_optional& GageRandRStudyResultsType::
    MeasurementDeviceIds ()
    {
      return this->MeasurementDeviceIds_;
    }

    void GageRandRStudyResultsType::
    MeasurementDeviceIds (const MeasurementDeviceIds_type& x)
    {
      this->MeasurementDeviceIds_.set (x);
    }

    void GageRandRStudyResultsType::
    MeasurementDeviceIds (const MeasurementDeviceIds_optional& x)
    {
      this->MeasurementDeviceIds_ = x;
    }

    void GageRandRStudyResultsType::
    MeasurementDeviceIds (::std::unique_ptr< MeasurementDeviceIds_type > x)
    {
      this->MeasurementDeviceIds_.set (std::move (x));
    }

    const GageRandRStudyResultsType::NumberOfAppraisers_type& GageRandRStudyResultsType::
    NumberOfAppraisers () const
    {
      return this->NumberOfAppraisers_.get ();
    }

    GageRandRStudyResultsType::NumberOfAppraisers_type& GageRandRStudyResultsType::
    NumberOfAppraisers ()
    {
      return this->NumberOfAppraisers_.get ();
    }

    void GageRandRStudyResultsType::
    NumberOfAppraisers (const NumberOfAppraisers_type& x)
    {
      this->NumberOfAppraisers_.set (x);
    }

    const GageRandRStudyResultsType::NumberOfParts_type& GageRandRStudyResultsType::
    NumberOfParts () const
    {
      return this->NumberOfParts_.get ();
    }

    GageRandRStudyResultsType::NumberOfParts_type& GageRandRStudyResultsType::
    NumberOfParts ()
    {
      return this->NumberOfParts_.get ();
    }

    void GageRandRStudyResultsType::
    NumberOfParts (const NumberOfParts_type& x)
    {
      this->NumberOfParts_.set (x);
    }

    const GageRandRStudyResultsType::NumberOfTrials_type& GageRandRStudyResultsType::
    NumberOfTrials () const
    {
      return this->NumberOfTrials_.get ();
    }

    GageRandRStudyResultsType::NumberOfTrials_type& GageRandRStudyResultsType::
    NumberOfTrials ()
    {
      return this->NumberOfTrials_.get ();
    }

    void GageRandRStudyResultsType::
    NumberOfTrials (const NumberOfTrials_type& x)
    {
      this->NumberOfTrials_.set (x);
    }


    // ProductionStudyResultsType
    //

    const ProductionStudyResultsType::ControlIssueDetailsList_sequence& ProductionStudyResultsType::
    ControlIssueDetailsList () const
    {
      return this->ControlIssueDetailsList_;
    }

    ProductionStudyResultsType::ControlIssueDetailsList_sequence& ProductionStudyResultsType::
    ControlIssueDetailsList ()
    {
      return this->ControlIssueDetailsList_;
    }

    void ProductionStudyResultsType::
    ControlIssueDetailsList (const ControlIssueDetailsList_sequence& s)
    {
      this->ControlIssueDetailsList_ = s;
    }


    // StatisticalStudyPlansType
    //

    const StatisticalStudyPlansType::StatisticalStudyPlan_sequence& StatisticalStudyPlansType::
    StatisticalStudyPlan () const
    {
      return this->StatisticalStudyPlan_;
    }

    StatisticalStudyPlansType::StatisticalStudyPlan_sequence& StatisticalStudyPlansType::
    StatisticalStudyPlan ()
    {
      return this->StatisticalStudyPlan_;
    }

    void StatisticalStudyPlansType::
    StatisticalStudyPlan (const StatisticalStudyPlan_sequence& s)
    {
      this->StatisticalStudyPlan_ = s;
    }

    const StatisticalStudyPlansType::n_type& StatisticalStudyPlansType::
    n () const
    {
      return this->n_.get ();
    }

    StatisticalStudyPlansType::n_type& StatisticalStudyPlansType::
    n ()
    {
      return this->n_.get ();
    }

    void StatisticalStudyPlansType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void StatisticalStudyPlansType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // StatisticalStudiesResultsType
    //

    const StatisticalStudiesResultsType::StatisticalStudyResults_sequence& StatisticalStudiesResultsType::
    StatisticalStudyResults () const
    {
      return this->StatisticalStudyResults_;
    }

    StatisticalStudiesResultsType::StatisticalStudyResults_sequence& StatisticalStudiesResultsType::
    StatisticalStudyResults ()
    {
      return this->StatisticalStudyResults_;
    }

    void StatisticalStudiesResultsType::
    StatisticalStudyResults (const StatisticalStudyResults_sequence& s)
    {
      this->StatisticalStudyResults_ = s;
    }

    const StatisticalStudiesResultsType::n_type& StatisticalStudiesResultsType::
    n () const
    {
      return this->n_.get ();
    }

    StatisticalStudiesResultsType::n_type& StatisticalStudiesResultsType::
    n ()
    {
      return this->n_.get ();
    }

    void StatisticalStudiesResultsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void StatisticalStudiesResultsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // CorrectiveActionPlanType
    //

    const CorrectiveActionPlanType::Version_optional& CorrectiveActionPlanType::
    Version () const
    {
      return this->Version_;
    }

    CorrectiveActionPlanType::Version_optional& CorrectiveActionPlanType::
    Version ()
    {
      return this->Version_;
    }

    void CorrectiveActionPlanType::
    Version (const Version_type& x)
    {
      this->Version_.set (x);
    }

    void CorrectiveActionPlanType::
    Version (const Version_optional& x)
    {
      this->Version_ = x;
    }

    void CorrectiveActionPlanType::
    Version (::std::unique_ptr< Version_type > x)
    {
      this->Version_.set (std::move (x));
    }

    const CorrectiveActionPlanType::Attributes_optional& CorrectiveActionPlanType::
    Attributes () const
    {
      return this->Attributes_;
    }

    CorrectiveActionPlanType::Attributes_optional& CorrectiveActionPlanType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void CorrectiveActionPlanType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void CorrectiveActionPlanType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void CorrectiveActionPlanType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const CorrectiveActionPlanType::AssignableCauses_type& CorrectiveActionPlanType::
    AssignableCauses () const
    {
      return this->AssignableCauses_.get ();
    }

    CorrectiveActionPlanType::AssignableCauses_type& CorrectiveActionPlanType::
    AssignableCauses ()
    {
      return this->AssignableCauses_.get ();
    }

    void CorrectiveActionPlanType::
    AssignableCauses (const AssignableCauses_type& x)
    {
      this->AssignableCauses_.set (x);
    }

    void CorrectiveActionPlanType::
    AssignableCauses (::std::unique_ptr< AssignableCauses_type > x)
    {
      this->AssignableCauses_.set (std::move (x));
    }

    const CorrectiveActionPlanType::CorrectiveActions_type& CorrectiveActionPlanType::
    CorrectiveActions () const
    {
      return this->CorrectiveActions_.get ();
    }

    CorrectiveActionPlanType::CorrectiveActions_type& CorrectiveActionPlanType::
    CorrectiveActions ()
    {
      return this->CorrectiveActions_.get ();
    }

    void CorrectiveActionPlanType::
    CorrectiveActions (const CorrectiveActions_type& x)
    {
      this->CorrectiveActions_.set (x);
    }

    void CorrectiveActionPlanType::
    CorrectiveActions (::std::unique_ptr< CorrectiveActions_type > x)
    {
      this->CorrectiveActions_.set (std::move (x));
    }

    const CorrectiveActionPlanType::id_type& CorrectiveActionPlanType::
    id () const
    {
      return this->id_.get ();
    }

    CorrectiveActionPlanType::id_type& CorrectiveActionPlanType::
    id ()
    {
      return this->id_.get ();
    }

    void CorrectiveActionPlanType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void CorrectiveActionPlanType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // CorrectiveActionPlansType
    //

    const CorrectiveActionPlansType::CorrectiveActionPlan_sequence& CorrectiveActionPlansType::
    CorrectiveActionPlan () const
    {
      return this->CorrectiveActionPlan_;
    }

    CorrectiveActionPlansType::CorrectiveActionPlan_sequence& CorrectiveActionPlansType::
    CorrectiveActionPlan ()
    {
      return this->CorrectiveActionPlan_;
    }

    void CorrectiveActionPlansType::
    CorrectiveActionPlan (const CorrectiveActionPlan_sequence& s)
    {
      this->CorrectiveActionPlan_ = s;
    }

    const CorrectiveActionPlansType::n_type& CorrectiveActionPlansType::
    n () const
    {
      return this->n_.get ();
    }

    CorrectiveActionPlansType::n_type& CorrectiveActionPlansType::
    n ()
    {
      return this->n_.get ();
    }

    void CorrectiveActionPlansType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void CorrectiveActionPlansType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // StatisticsType
    //

    const StatisticsType::StatisticalStudyPlans_optional& StatisticsType::
    StatisticalStudyPlans () const
    {
      return this->StatisticalStudyPlans_;
    }

    StatisticsType::StatisticalStudyPlans_optional& StatisticsType::
    StatisticalStudyPlans ()
    {
      return this->StatisticalStudyPlans_;
    }

    void StatisticsType::
    StatisticalStudyPlans (const StatisticalStudyPlans_type& x)
    {
      this->StatisticalStudyPlans_.set (x);
    }

    void StatisticsType::
    StatisticalStudyPlans (const StatisticalStudyPlans_optional& x)
    {
      this->StatisticalStudyPlans_ = x;
    }

    void StatisticsType::
    StatisticalStudyPlans (::std::unique_ptr< StatisticalStudyPlans_type > x)
    {
      this->StatisticalStudyPlans_.set (std::move (x));
    }

    const StatisticsType::StatisticalStudiesResults_optional& StatisticsType::
    StatisticalStudiesResults () const
    {
      return this->StatisticalStudiesResults_;
    }

    StatisticsType::StatisticalStudiesResults_optional& StatisticsType::
    StatisticalStudiesResults ()
    {
      return this->StatisticalStudiesResults_;
    }

    void StatisticsType::
    StatisticalStudiesResults (const StatisticalStudiesResults_type& x)
    {
      this->StatisticalStudiesResults_.set (x);
    }

    void StatisticsType::
    StatisticalStudiesResults (const StatisticalStudiesResults_optional& x)
    {
      this->StatisticalStudiesResults_ = x;
    }

    void StatisticsType::
    StatisticalStudiesResults (::std::unique_ptr< StatisticalStudiesResults_type > x)
    {
      this->StatisticalStudiesResults_.set (std::move (x));
    }

    const StatisticsType::CorrectiveActionPlans_optional& StatisticsType::
    CorrectiveActionPlans () const
    {
      return this->CorrectiveActionPlans_;
    }

    StatisticsType::CorrectiveActionPlans_optional& StatisticsType::
    CorrectiveActionPlans ()
    {
      return this->CorrectiveActionPlans_;
    }

    void StatisticsType::
    CorrectiveActionPlans (const CorrectiveActionPlans_type& x)
    {
      this->CorrectiveActionPlans_.set (x);
    }

    void StatisticsType::
    CorrectiveActionPlans (const CorrectiveActionPlans_optional& x)
    {
      this->CorrectiveActionPlans_ = x;
    }

    void StatisticsType::
    CorrectiveActionPlans (::std::unique_ptr< CorrectiveActionPlans_type > x)
    {
      this->CorrectiveActionPlans_.set (std::move (x));
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, wchar_t >
  type_factory_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    // StatisticalStudyPlanBaseType
    //

    StatisticalStudyPlanBaseType::
    StatisticalStudyPlanBaseType ()
    : ::xml_schema::type (),
      Version_ (this),
      Attributes_ (this),
      FeatureItemIds_ (this),
      CalculateAverageFeatures_ (this),
      CharacteristicItemIds_ (this),
      StatsValuesPerChar_ (this),
      StatsValuesPerSubgroup_ (this),
      StatsValuesSummarys_ (this),
      PreInspectionTraceability_ (this),
      Name_ (this),
      Description_ (this),
      PlanId_ (this),
      SoftwareId_ (this),
      StandardId_ (this),
      CorrectiveActionPlanId_ (this),
      id_ (this)
    {
    }

    StatisticalStudyPlanBaseType::
    StatisticalStudyPlanBaseType (const id_type& id)
    : ::xml_schema::type (),
      Version_ (this),
      Attributes_ (this),
      FeatureItemIds_ (this),
      CalculateAverageFeatures_ (this),
      CharacteristicItemIds_ (this),
      StatsValuesPerChar_ (this),
      StatsValuesPerSubgroup_ (this),
      StatsValuesSummarys_ (this),
      PreInspectionTraceability_ (this),
      Name_ (this),
      Description_ (this),
      PlanId_ (this),
      SoftwareId_ (this),
      StandardId_ (this),
      CorrectiveActionPlanId_ (this),
      id_ (id, this)
    {
    }

    StatisticalStudyPlanBaseType::
    StatisticalStudyPlanBaseType (const StatisticalStudyPlanBaseType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Version_ (x.Version_, f, this),
      Attributes_ (x.Attributes_, f, this),
      FeatureItemIds_ (x.FeatureItemIds_, f, this),
      CalculateAverageFeatures_ (x.CalculateAverageFeatures_, f, this),
      CharacteristicItemIds_ (x.CharacteristicItemIds_, f, this),
      StatsValuesPerChar_ (x.StatsValuesPerChar_, f, this),
      StatsValuesPerSubgroup_ (x.StatsValuesPerSubgroup_, f, this),
      StatsValuesSummarys_ (x.StatsValuesSummarys_, f, this),
      PreInspectionTraceability_ (x.PreInspectionTraceability_, f, this),
      Name_ (x.Name_, f, this),
      Description_ (x.Description_, f, this),
      PlanId_ (x.PlanId_, f, this),
      SoftwareId_ (x.SoftwareId_, f, this),
      StandardId_ (x.StandardId_, f, this),
      CorrectiveActionPlanId_ (x.CorrectiveActionPlanId_, f, this),
      id_ (x.id_, f, this)
    {
    }

    StatisticalStudyPlanBaseType::
    StatisticalStudyPlanBaseType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Version_ (this),
      Attributes_ (this),
      FeatureItemIds_ (this),
      CalculateAverageFeatures_ (this),
      CharacteristicItemIds_ (this),
      StatsValuesPerChar_ (this),
      StatsValuesPerSubgroup_ (this),
      StatsValuesSummarys_ (this),
      PreInspectionTraceability_ (this),
      Name_ (this),
      Description_ (this),
      PlanId_ (this),
      SoftwareId_ (this),
      StandardId_ (this),
      CorrectiveActionPlanId_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void StatisticalStudyPlanBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Version
        //
        if (n.name () == L"Version" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Version_type > r (
            Version_traits::create (i, f, this));

          if (!this->Version_)
          {
            this->Version_.set (::std::move (r));
            continue;
          }
        }

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        // FeatureItemIds
        //
        if (n.name () == L"FeatureItemIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FeatureItemIds_type > r (
            FeatureItemIds_traits::create (i, f, this));

          if (!this->FeatureItemIds_)
          {
            this->FeatureItemIds_.set (::std::move (r));
            continue;
          }
        }

        // CalculateAverageFeatures
        //
        if (n.name () == L"CalculateAverageFeatures" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->CalculateAverageFeatures_)
          {
            this->CalculateAverageFeatures_.set (CalculateAverageFeatures_traits::create (i, f, this));
            continue;
          }
        }

        // CharacteristicItemIds
        //
        if (n.name () == L"CharacteristicItemIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CharacteristicItemIds_type > r (
            CharacteristicItemIds_traits::create (i, f, this));

          if (!this->CharacteristicItemIds_)
          {
            this->CharacteristicItemIds_.set (::std::move (r));
            continue;
          }
        }

        // StatsValuesPerChar
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"StatsValuesPerChar",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< StatsValuesPerChar_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< StatsValuesPerChar_type > r (
              dynamic_cast< StatsValuesPerChar_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->StatsValuesPerChar_.push_back (::std::move (r));
            continue;
          }
        }

        // StatsValuesPerSubgroup
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"StatsValuesPerSubgroup",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< StatsValuesPerSubgroup_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< StatsValuesPerSubgroup_type > r (
              dynamic_cast< StatsValuesPerSubgroup_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->StatsValuesPerSubgroup_.push_back (::std::move (r));
            continue;
          }
        }

        // StatsValuesSummarys
        //
        if (n.name () == L"StatsValuesSummarys" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StatsValuesSummarys_type > r (
            StatsValuesSummarys_traits::create (i, f, this));

          this->StatsValuesSummarys_.push_back (::std::move (r));
          continue;
        }

        // PreInspectionTraceability
        //
        if (n.name () == L"PreInspectionTraceability" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PreInspectionTraceability_type > r (
            PreInspectionTraceability_traits::create (i, f, this));

          if (!this->PreInspectionTraceability_)
          {
            this->PreInspectionTraceability_.set (::std::move (r));
            continue;
          }
        }

        // Name
        //
        if (n.name () == L"Name" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!this->Name_)
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // Description
        //
        if (n.name () == L"Description" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!this->Description_)
          {
            this->Description_.set (::std::move (r));
            continue;
          }
        }

        // PlanId
        //
        if (n.name () == L"PlanId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PlanId_type > r (
            PlanId_traits::create (i, f, this));

          if (!this->PlanId_)
          {
            this->PlanId_.set (::std::move (r));
            continue;
          }
        }

        // SoftwareId
        //
        if (n.name () == L"SoftwareId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SoftwareId_type > r (
            SoftwareId_traits::create (i, f, this));

          if (!this->SoftwareId_)
          {
            this->SoftwareId_.set (::std::move (r));
            continue;
          }
        }

        // StandardId
        //
        if (n.name () == L"StandardId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StandardId_type > r (
            StandardId_traits::create (i, f, this));

          if (!this->StandardId_)
          {
            this->StandardId_.set (::std::move (r));
            continue;
          }
        }

        // CorrectiveActionPlanId
        //
        if (n.name () == L"CorrectiveActionPlanId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CorrectiveActionPlanId_type > r (
            CorrectiveActionPlanId_traits::create (i, f, this));

          if (!this->CorrectiveActionPlanId_)
          {
            this->CorrectiveActionPlanId_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    StatisticalStudyPlanBaseType& StatisticalStudyPlanBaseType::
    operator= (const StatisticalStudyPlanBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Version_ = x.Version_;
        this->Attributes_ = x.Attributes_;
        this->FeatureItemIds_ = x.FeatureItemIds_;
        this->CalculateAverageFeatures_ = x.CalculateAverageFeatures_;
        this->CharacteristicItemIds_ = x.CharacteristicItemIds_;
        this->StatsValuesPerChar_ = x.StatsValuesPerChar_;
        this->StatsValuesPerSubgroup_ = x.StatsValuesPerSubgroup_;
        this->StatsValuesSummarys_ = x.StatsValuesSummarys_;
        this->PreInspectionTraceability_ = x.PreInspectionTraceability_;
        this->Name_ = x.Name_;
        this->Description_ = x.Description_;
        this->PlanId_ = x.PlanId_;
        this->SoftwareId_ = x.SoftwareId_;
        this->StandardId_ = x.StandardId_;
        this->CorrectiveActionPlanId_ = x.CorrectiveActionPlanId_;
        this->id_ = x.id_;
      }

      return *this;
    }

    StatisticalStudyPlanBaseType::
    ~StatisticalStudyPlanBaseType ()
    {
    }

    // AbsoluteLimitsByUnitType
    //

    AbsoluteLimitsByUnitType::
    AbsoluteLimitsByUnitType ()
    : ::xml_schema::type (),
      LinearLimit_ (this),
      AngularLimit_ (this),
      AreaLimit_ (this),
      ForceLimit_ (this),
      MassLimit_ (this),
      PressureLimit_ (this),
      SpeedLimit_ (this),
      TemperatureLimit_ (this),
      TimeLimit_ (this),
      UserDefinedUnitLimit_ (this),
      n_ (this)
    {
    }

    AbsoluteLimitsByUnitType::
    AbsoluteLimitsByUnitType (const n_type& n)
    : ::xml_schema::type (),
      LinearLimit_ (this),
      AngularLimit_ (this),
      AreaLimit_ (this),
      ForceLimit_ (this),
      MassLimit_ (this),
      PressureLimit_ (this),
      SpeedLimit_ (this),
      TemperatureLimit_ (this),
      TimeLimit_ (this),
      UserDefinedUnitLimit_ (this),
      n_ (n, this)
    {
    }

    AbsoluteLimitsByUnitType::
    AbsoluteLimitsByUnitType (const AbsoluteLimitsByUnitType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      LinearLimit_ (x.LinearLimit_, f, this),
      AngularLimit_ (x.AngularLimit_, f, this),
      AreaLimit_ (x.AreaLimit_, f, this),
      ForceLimit_ (x.ForceLimit_, f, this),
      MassLimit_ (x.MassLimit_, f, this),
      PressureLimit_ (x.PressureLimit_, f, this),
      SpeedLimit_ (x.SpeedLimit_, f, this),
      TemperatureLimit_ (x.TemperatureLimit_, f, this),
      TimeLimit_ (x.TimeLimit_, f, this),
      UserDefinedUnitLimit_ (x.UserDefinedUnitLimit_, f, this),
      n_ (x.n_, f, this)
    {
    }

    AbsoluteLimitsByUnitType::
    AbsoluteLimitsByUnitType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      LinearLimit_ (this),
      AngularLimit_ (this),
      AreaLimit_ (this),
      ForceLimit_ (this),
      MassLimit_ (this),
      PressureLimit_ (this),
      SpeedLimit_ (this),
      TemperatureLimit_ (this),
      TimeLimit_ (this),
      UserDefinedUnitLimit_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void AbsoluteLimitsByUnitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // LinearLimit
        //
        if (n.name () == L"LinearLimit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LinearLimit_type > r (
            LinearLimit_traits::create (i, f, this));

          if (!this->LinearLimit_)
          {
            this->LinearLimit_.set (::std::move (r));
            continue;
          }
        }

        // AngularLimit
        //
        if (n.name () == L"AngularLimit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AngularLimit_type > r (
            AngularLimit_traits::create (i, f, this));

          if (!this->AngularLimit_)
          {
            this->AngularLimit_.set (::std::move (r));
            continue;
          }
        }

        // AreaLimit
        //
        if (n.name () == L"AreaLimit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AreaLimit_type > r (
            AreaLimit_traits::create (i, f, this));

          if (!this->AreaLimit_)
          {
            this->AreaLimit_.set (::std::move (r));
            continue;
          }
        }

        // ForceLimit
        //
        if (n.name () == L"ForceLimit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ForceLimit_type > r (
            ForceLimit_traits::create (i, f, this));

          if (!this->ForceLimit_)
          {
            this->ForceLimit_.set (::std::move (r));
            continue;
          }
        }

        // MassLimit
        //
        if (n.name () == L"MassLimit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MassLimit_type > r (
            MassLimit_traits::create (i, f, this));

          if (!this->MassLimit_)
          {
            this->MassLimit_.set (::std::move (r));
            continue;
          }
        }

        // PressureLimit
        //
        if (n.name () == L"PressureLimit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PressureLimit_type > r (
            PressureLimit_traits::create (i, f, this));

          if (!this->PressureLimit_)
          {
            this->PressureLimit_.set (::std::move (r));
            continue;
          }
        }

        // SpeedLimit
        //
        if (n.name () == L"SpeedLimit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SpeedLimit_type > r (
            SpeedLimit_traits::create (i, f, this));

          if (!this->SpeedLimit_)
          {
            this->SpeedLimit_.set (::std::move (r));
            continue;
          }
        }

        // TemperatureLimit
        //
        if (n.name () == L"TemperatureLimit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TemperatureLimit_type > r (
            TemperatureLimit_traits::create (i, f, this));

          if (!this->TemperatureLimit_)
          {
            this->TemperatureLimit_.set (::std::move (r));
            continue;
          }
        }

        // TimeLimit
        //
        if (n.name () == L"TimeLimit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TimeLimit_type > r (
            TimeLimit_traits::create (i, f, this));

          if (!this->TimeLimit_)
          {
            this->TimeLimit_.set (::std::move (r));
            continue;
          }
        }

        // UserDefinedUnitLimit
        //
        if (n.name () == L"UserDefinedUnitLimit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDefinedUnitLimit_type > r (
            UserDefinedUnitLimit_traits::create (i, f, this));

          this->UserDefinedUnitLimit_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    AbsoluteLimitsByUnitType* AbsoluteLimitsByUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AbsoluteLimitsByUnitType (*this, f, c);
    }

    AbsoluteLimitsByUnitType& AbsoluteLimitsByUnitType::
    operator= (const AbsoluteLimitsByUnitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->LinearLimit_ = x.LinearLimit_;
        this->AngularLimit_ = x.AngularLimit_;
        this->AreaLimit_ = x.AreaLimit_;
        this->ForceLimit_ = x.ForceLimit_;
        this->MassLimit_ = x.MassLimit_;
        this->PressureLimit_ = x.PressureLimit_;
        this->SpeedLimit_ = x.SpeedLimit_;
        this->TemperatureLimit_ = x.TemperatureLimit_;
        this->TimeLimit_ = x.TimeLimit_;
        this->UserDefinedUnitLimit_ = x.UserDefinedUnitLimit_;
        this->n_ = x.n_;
      }

      return *this;
    }

    AbsoluteLimitsByUnitType::
    ~AbsoluteLimitsByUnitType ()
    {
    }

    // LinearityStudyPlanType
    //

    LinearityStudyPlanType::
    LinearityStudyPlanType ()
    : ::xsd::qif30::StatisticalStudyPlanBaseType (),
      MeasurementDeviceIds_ (this),
      GoodnessOfFitThreshold_ (this),
      AbsoluteMinimums_ (this),
      RelativeLinearityMinimum_ (this)
    {
    }

    LinearityStudyPlanType::
    LinearityStudyPlanType (const id_type& id)
    : ::xsd::qif30::StatisticalStudyPlanBaseType (id),
      MeasurementDeviceIds_ (this),
      GoodnessOfFitThreshold_ (this),
      AbsoluteMinimums_ (this),
      RelativeLinearityMinimum_ (this)
    {
    }

    LinearityStudyPlanType::
    LinearityStudyPlanType (const LinearityStudyPlanType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::StatisticalStudyPlanBaseType (x, f, c),
      MeasurementDeviceIds_ (x.MeasurementDeviceIds_, f, this),
      GoodnessOfFitThreshold_ (x.GoodnessOfFitThreshold_, f, this),
      AbsoluteMinimums_ (x.AbsoluteMinimums_, f, this),
      RelativeLinearityMinimum_ (x.RelativeLinearityMinimum_, f, this)
    {
    }

    LinearityStudyPlanType::
    LinearityStudyPlanType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::StatisticalStudyPlanBaseType (e, f | ::xml_schema::flags::base, c),
      MeasurementDeviceIds_ (this),
      GoodnessOfFitThreshold_ (this),
      AbsoluteMinimums_ (this),
      RelativeLinearityMinimum_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void LinearityStudyPlanType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatisticalStudyPlanBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MeasurementDeviceIds
        //
        if (n.name () == L"MeasurementDeviceIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeasurementDeviceIds_type > r (
            MeasurementDeviceIds_traits::create (i, f, this));

          if (!this->MeasurementDeviceIds_)
          {
            this->MeasurementDeviceIds_.set (::std::move (r));
            continue;
          }
        }

        // GoodnessOfFitThreshold
        //
        if (n.name () == L"GoodnessOfFitThreshold" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->GoodnessOfFitThreshold_)
          {
            this->GoodnessOfFitThreshold_.set (GoodnessOfFitThreshold_traits::create (i, f, this));
            continue;
          }
        }

        // AbsoluteMinimums
        //
        if (n.name () == L"AbsoluteMinimums" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AbsoluteMinimums_type > r (
            AbsoluteMinimums_traits::create (i, f, this));

          if (!this->AbsoluteMinimums_)
          {
            this->AbsoluteMinimums_.set (::std::move (r));
            continue;
          }
        }

        // RelativeLinearityMinimum
        //
        if (n.name () == L"RelativeLinearityMinimum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->RelativeLinearityMinimum_)
          {
            this->RelativeLinearityMinimum_.set (RelativeLinearityMinimum_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }
    }

    LinearityStudyPlanType* LinearityStudyPlanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LinearityStudyPlanType (*this, f, c);
    }

    LinearityStudyPlanType& LinearityStudyPlanType::
    operator= (const LinearityStudyPlanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatisticalStudyPlanBaseType& > (*this) = x;
        this->MeasurementDeviceIds_ = x.MeasurementDeviceIds_;
        this->GoodnessOfFitThreshold_ = x.GoodnessOfFitThreshold_;
        this->AbsoluteMinimums_ = x.AbsoluteMinimums_;
        this->RelativeLinearityMinimum_ = x.RelativeLinearityMinimum_;
      }

      return *this;
    }

    LinearityStudyPlanType::
    ~LinearityStudyPlanType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, LinearityStudyPlanType >
    _xsd_LinearityStudyPlanType_type_factory_init (
      L"LinearityStudyPlanType",
      L"http://qifstandards.org/xsd/qif3");

    // StabilityStudyPlanType
    //

    StabilityStudyPlanType::
    StabilityStudyPlanType ()
    : ::xsd::qif30::StatisticalStudyPlanBaseType (),
      MeasurementDeviceIds_ (this),
      SampleSize_ (this),
      SampleFrequency_ (this),
      SamplingInterval_ (this)
    {
    }

    StabilityStudyPlanType::
    StabilityStudyPlanType (const id_type& id,
                            const SampleSize_type& SampleSize,
                            const SampleFrequency_type& SampleFrequency,
                            const SamplingInterval_type& SamplingInterval)
    : ::xsd::qif30::StatisticalStudyPlanBaseType (id),
      MeasurementDeviceIds_ (this),
      SampleSize_ (SampleSize, this),
      SampleFrequency_ (SampleFrequency, this),
      SamplingInterval_ (SamplingInterval, this)
    {
    }

    StabilityStudyPlanType::
    StabilityStudyPlanType (const id_type& id,
                            const SampleSize_type& SampleSize,
                            const SampleFrequency_type& SampleFrequency,
                            ::std::unique_ptr< SamplingInterval_type > SamplingInterval)
    : ::xsd::qif30::StatisticalStudyPlanBaseType (id),
      MeasurementDeviceIds_ (this),
      SampleSize_ (SampleSize, this),
      SampleFrequency_ (SampleFrequency, this),
      SamplingInterval_ (std::move (SamplingInterval), this)
    {
    }

    StabilityStudyPlanType::
    StabilityStudyPlanType (const StabilityStudyPlanType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::StatisticalStudyPlanBaseType (x, f, c),
      MeasurementDeviceIds_ (x.MeasurementDeviceIds_, f, this),
      SampleSize_ (x.SampleSize_, f, this),
      SampleFrequency_ (x.SampleFrequency_, f, this),
      SamplingInterval_ (x.SamplingInterval_, f, this)
    {
    }

    StabilityStudyPlanType::
    StabilityStudyPlanType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::StatisticalStudyPlanBaseType (e, f | ::xml_schema::flags::base, c),
      MeasurementDeviceIds_ (this),
      SampleSize_ (this),
      SampleFrequency_ (this),
      SamplingInterval_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void StabilityStudyPlanType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatisticalStudyPlanBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MeasurementDeviceIds
        //
        if (n.name () == L"MeasurementDeviceIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeasurementDeviceIds_type > r (
            MeasurementDeviceIds_traits::create (i, f, this));

          if (!this->MeasurementDeviceIds_)
          {
            this->MeasurementDeviceIds_.set (::std::move (r));
            continue;
          }
        }

        // SampleSize
        //
        if (n.name () == L"SampleSize" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!SampleSize_.present ())
          {
            this->SampleSize_.set (SampleSize_traits::create (i, f, this));
            continue;
          }
        }

        // SampleFrequency
        //
        if (n.name () == L"SampleFrequency" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!SampleFrequency_.present ())
          {
            this->SampleFrequency_.set (SampleFrequency_traits::create (i, f, this));
            continue;
          }
        }

        // SamplingInterval
        //
        if (n.name () == L"SamplingInterval" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SamplingInterval_type > r (
            SamplingInterval_traits::create (i, f, this));

          if (!SamplingInterval_.present ())
          {
            this->SamplingInterval_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SampleSize_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SampleSize",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!SampleFrequency_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SampleFrequency",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!SamplingInterval_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SamplingInterval",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    StabilityStudyPlanType* StabilityStudyPlanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StabilityStudyPlanType (*this, f, c);
    }

    StabilityStudyPlanType& StabilityStudyPlanType::
    operator= (const StabilityStudyPlanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatisticalStudyPlanBaseType& > (*this) = x;
        this->MeasurementDeviceIds_ = x.MeasurementDeviceIds_;
        this->SampleSize_ = x.SampleSize_;
        this->SampleFrequency_ = x.SampleFrequency_;
        this->SamplingInterval_ = x.SamplingInterval_;
      }

      return *this;
    }

    StabilityStudyPlanType::
    ~StabilityStudyPlanType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, StabilityStudyPlanType >
    _xsd_StabilityStudyPlanType_type_factory_init (
      L"StabilityStudyPlanType",
      L"http://qifstandards.org/xsd/qif3");

    // MultipleProductInstanceStudyPlanBaseType
    //

    MultipleProductInstanceStudyPlanBaseType::
    MultipleProductInstanceStudyPlanBaseType ()
    : ::xsd::qif30::StatisticalStudyPlanBaseType (),
      NumberOfSamples_ (this),
      SubgroupSize_ (this)
    {
    }

    MultipleProductInstanceStudyPlanBaseType::
    MultipleProductInstanceStudyPlanBaseType (const id_type& id,
                                              const NumberOfSamples_type& NumberOfSamples)
    : ::xsd::qif30::StatisticalStudyPlanBaseType (id),
      NumberOfSamples_ (NumberOfSamples, this),
      SubgroupSize_ (this)
    {
    }

    MultipleProductInstanceStudyPlanBaseType::
    MultipleProductInstanceStudyPlanBaseType (const MultipleProductInstanceStudyPlanBaseType& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xsd::qif30::StatisticalStudyPlanBaseType (x, f, c),
      NumberOfSamples_ (x.NumberOfSamples_, f, this),
      SubgroupSize_ (x.SubgroupSize_, f, this)
    {
    }

    MultipleProductInstanceStudyPlanBaseType::
    MultipleProductInstanceStudyPlanBaseType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xsd::qif30::StatisticalStudyPlanBaseType (e, f | ::xml_schema::flags::base, c),
      NumberOfSamples_ (this),
      SubgroupSize_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void MultipleProductInstanceStudyPlanBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatisticalStudyPlanBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // NumberOfSamples
        //
        if (n.name () == L"NumberOfSamples" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!NumberOfSamples_.present ())
          {
            this->NumberOfSamples_.set (NumberOfSamples_traits::create (i, f, this));
            continue;
          }
        }

        // SubgroupSize
        //
        if (n.name () == L"SubgroupSize" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->SubgroupSize_)
          {
            this->SubgroupSize_.set (SubgroupSize_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!NumberOfSamples_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"NumberOfSamples",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    MultipleProductInstanceStudyPlanBaseType& MultipleProductInstanceStudyPlanBaseType::
    operator= (const MultipleProductInstanceStudyPlanBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatisticalStudyPlanBaseType& > (*this) = x;
        this->NumberOfSamples_ = x.NumberOfSamples_;
        this->SubgroupSize_ = x.SubgroupSize_;
      }

      return *this;
    }

    MultipleProductInstanceStudyPlanBaseType::
    ~MultipleProductInstanceStudyPlanBaseType ()
    {
    }

    // BiasStudyPlanType
    //

    BiasStudyPlanType::
    BiasStudyPlanType ()
    : ::xsd::qif30::MultipleProductInstanceStudyPlanBaseType (),
      MeasurementDeviceIds_ (this)
    {
    }

    BiasStudyPlanType::
    BiasStudyPlanType (const id_type& id,
                       const NumberOfSamples_type& NumberOfSamples)
    : ::xsd::qif30::MultipleProductInstanceStudyPlanBaseType (id,
                                                              NumberOfSamples),
      MeasurementDeviceIds_ (this)
    {
    }

    BiasStudyPlanType::
    BiasStudyPlanType (const BiasStudyPlanType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::MultipleProductInstanceStudyPlanBaseType (x, f, c),
      MeasurementDeviceIds_ (x.MeasurementDeviceIds_, f, this)
    {
    }

    BiasStudyPlanType::
    BiasStudyPlanType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::MultipleProductInstanceStudyPlanBaseType (e, f | ::xml_schema::flags::base, c),
      MeasurementDeviceIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void BiasStudyPlanType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::MultipleProductInstanceStudyPlanBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MeasurementDeviceIds
        //
        if (n.name () == L"MeasurementDeviceIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeasurementDeviceIds_type > r (
            MeasurementDeviceIds_traits::create (i, f, this));

          if (!this->MeasurementDeviceIds_)
          {
            this->MeasurementDeviceIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    BiasStudyPlanType* BiasStudyPlanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BiasStudyPlanType (*this, f, c);
    }

    BiasStudyPlanType& BiasStudyPlanType::
    operator= (const BiasStudyPlanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::MultipleProductInstanceStudyPlanBaseType& > (*this) = x;
        this->MeasurementDeviceIds_ = x.MeasurementDeviceIds_;
      }

      return *this;
    }

    BiasStudyPlanType::
    ~BiasStudyPlanType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, BiasStudyPlanType >
    _xsd_BiasStudyPlanType_type_factory_init (
      L"BiasStudyPlanType",
      L"http://qifstandards.org/xsd/qif3");

    // FirstArticleStudyPlanType
    //

    FirstArticleStudyPlanType::
    FirstArticleStudyPlanType ()
    : ::xsd::qif30::StatisticalStudyPlanBaseType (),
      InSpecRatio_ (this),
      AbsoluteMaximums_ (this),
      RelativeMaximum_ (this)
    {
    }

    FirstArticleStudyPlanType::
    FirstArticleStudyPlanType (const id_type& id,
                               const InSpecRatio_type& InSpecRatio)
    : ::xsd::qif30::StatisticalStudyPlanBaseType (id),
      InSpecRatio_ (InSpecRatio, this),
      AbsoluteMaximums_ (this),
      RelativeMaximum_ (this)
    {
    }

    FirstArticleStudyPlanType::
    FirstArticleStudyPlanType (const FirstArticleStudyPlanType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::StatisticalStudyPlanBaseType (x, f, c),
      InSpecRatio_ (x.InSpecRatio_, f, this),
      AbsoluteMaximums_ (x.AbsoluteMaximums_, f, this),
      RelativeMaximum_ (x.RelativeMaximum_, f, this)
    {
    }

    FirstArticleStudyPlanType::
    FirstArticleStudyPlanType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::StatisticalStudyPlanBaseType (e, f | ::xml_schema::flags::base, c),
      InSpecRatio_ (this),
      AbsoluteMaximums_ (this),
      RelativeMaximum_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FirstArticleStudyPlanType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatisticalStudyPlanBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // InSpecRatio
        //
        if (n.name () == L"InSpecRatio" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!InSpecRatio_.present ())
          {
            this->InSpecRatio_.set (InSpecRatio_traits::create (i, f, this));
            continue;
          }
        }

        // AbsoluteMaximums
        //
        if (n.name () == L"AbsoluteMaximums" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AbsoluteMaximums_type > r (
            AbsoluteMaximums_traits::create (i, f, this));

          if (!this->AbsoluteMaximums_)
          {
            this->AbsoluteMaximums_.set (::std::move (r));
            continue;
          }
        }

        // RelativeMaximum
        //
        if (n.name () == L"RelativeMaximum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->RelativeMaximum_)
          {
            this->RelativeMaximum_.set (RelativeMaximum_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!InSpecRatio_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"InSpecRatio",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    FirstArticleStudyPlanType* FirstArticleStudyPlanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FirstArticleStudyPlanType (*this, f, c);
    }

    FirstArticleStudyPlanType& FirstArticleStudyPlanType::
    operator= (const FirstArticleStudyPlanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatisticalStudyPlanBaseType& > (*this) = x;
        this->InSpecRatio_ = x.InSpecRatio_;
        this->AbsoluteMaximums_ = x.AbsoluteMaximums_;
        this->RelativeMaximum_ = x.RelativeMaximum_;
      }

      return *this;
    }

    FirstArticleStudyPlanType::
    ~FirstArticleStudyPlanType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, FirstArticleStudyPlanType >
    _xsd_FirstArticleStudyPlanType_type_factory_init (
      L"FirstArticleStudyPlanType",
      L"http://qifstandards.org/xsd/qif3");

    // ProcessDifferenceStudyPlanType
    //

    ProcessDifferenceStudyPlanType::
    ProcessDifferenceStudyPlanType ()
    : ::xsd::qif30::StatisticalStudyPlanBaseType (),
      NumberOfSamples_ (this),
      SubgroupSize_ (this),
      ManufacturingProcessId_ (this),
      AbsoluteDifferences_ (this),
      RelativeDifference_ (this)
    {
    }

    ProcessDifferenceStudyPlanType::
    ProcessDifferenceStudyPlanType (const id_type& id,
                                    const NumberOfSamples_type& NumberOfSamples,
                                    const SubgroupSize_type& SubgroupSize)
    : ::xsd::qif30::StatisticalStudyPlanBaseType (id),
      NumberOfSamples_ (NumberOfSamples, this),
      SubgroupSize_ (SubgroupSize, this),
      ManufacturingProcessId_ (this),
      AbsoluteDifferences_ (this),
      RelativeDifference_ (this)
    {
    }

    ProcessDifferenceStudyPlanType::
    ProcessDifferenceStudyPlanType (const ProcessDifferenceStudyPlanType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::StatisticalStudyPlanBaseType (x, f, c),
      NumberOfSamples_ (x.NumberOfSamples_, f, this),
      SubgroupSize_ (x.SubgroupSize_, f, this),
      ManufacturingProcessId_ (x.ManufacturingProcessId_, f, this),
      AbsoluteDifferences_ (x.AbsoluteDifferences_, f, this),
      RelativeDifference_ (x.RelativeDifference_, f, this)
    {
    }

    ProcessDifferenceStudyPlanType::
    ProcessDifferenceStudyPlanType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::StatisticalStudyPlanBaseType (e, f | ::xml_schema::flags::base, c),
      NumberOfSamples_ (this),
      SubgroupSize_ (this),
      ManufacturingProcessId_ (this),
      AbsoluteDifferences_ (this),
      RelativeDifference_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ProcessDifferenceStudyPlanType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatisticalStudyPlanBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // NumberOfSamples
        //
        if (n.name () == L"NumberOfSamples" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!NumberOfSamples_.present ())
          {
            this->NumberOfSamples_.set (NumberOfSamples_traits::create (i, f, this));
            continue;
          }
        }

        // SubgroupSize
        //
        if (n.name () == L"SubgroupSize" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!SubgroupSize_.present ())
          {
            this->SubgroupSize_.set (SubgroupSize_traits::create (i, f, this));
            continue;
          }
        }

        // ManufacturingProcessId
        //
        if (n.name () == L"ManufacturingProcessId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ManufacturingProcessId_type > r (
            ManufacturingProcessId_traits::create (i, f, this));

          if (!this->ManufacturingProcessId_)
          {
            this->ManufacturingProcessId_.set (::std::move (r));
            continue;
          }
        }

        // AbsoluteDifferences
        //
        if (n.name () == L"AbsoluteDifferences" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AbsoluteDifferences_type > r (
            AbsoluteDifferences_traits::create (i, f, this));

          if (!this->AbsoluteDifferences_)
          {
            this->AbsoluteDifferences_.set (::std::move (r));
            continue;
          }
        }

        // RelativeDifference
        //
        if (n.name () == L"RelativeDifference" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->RelativeDifference_)
          {
            this->RelativeDifference_.set (RelativeDifference_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!NumberOfSamples_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"NumberOfSamples",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!SubgroupSize_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SubgroupSize",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ProcessDifferenceStudyPlanType* ProcessDifferenceStudyPlanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ProcessDifferenceStudyPlanType (*this, f, c);
    }

    ProcessDifferenceStudyPlanType& ProcessDifferenceStudyPlanType::
    operator= (const ProcessDifferenceStudyPlanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatisticalStudyPlanBaseType& > (*this) = x;
        this->NumberOfSamples_ = x.NumberOfSamples_;
        this->SubgroupSize_ = x.SubgroupSize_;
        this->ManufacturingProcessId_ = x.ManufacturingProcessId_;
        this->AbsoluteDifferences_ = x.AbsoluteDifferences_;
        this->RelativeDifference_ = x.RelativeDifference_;
      }

      return *this;
    }

    ProcessDifferenceStudyPlanType::
    ~ProcessDifferenceStudyPlanType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ProcessDifferenceStudyPlanType >
    _xsd_ProcessDifferenceStudyPlanType_type_factory_init (
      L"ProcessDifferenceStudyPlanType",
      L"http://qifstandards.org/xsd/qif3");

    // SimpleStudyPlanType
    //

    SimpleStudyPlanType::
    SimpleStudyPlanType ()
    : ::xsd::qif30::MultipleProductInstanceStudyPlanBaseType ()
    {
    }

    SimpleStudyPlanType::
    SimpleStudyPlanType (const id_type& id,
                         const NumberOfSamples_type& NumberOfSamples)
    : ::xsd::qif30::MultipleProductInstanceStudyPlanBaseType (id,
                                                              NumberOfSamples)
    {
    }

    SimpleStudyPlanType::
    SimpleStudyPlanType (const SimpleStudyPlanType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::MultipleProductInstanceStudyPlanBaseType (x, f, c)
    {
    }

    SimpleStudyPlanType::
    SimpleStudyPlanType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::MultipleProductInstanceStudyPlanBaseType (e, f, c)
    {
    }

    SimpleStudyPlanType* SimpleStudyPlanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SimpleStudyPlanType (*this, f, c);
    }

    SimpleStudyPlanType::
    ~SimpleStudyPlanType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SimpleStudyPlanType >
    _xsd_SimpleStudyPlanType_type_factory_init (
      L"SimpleStudyPlanType",
      L"http://qifstandards.org/xsd/qif3");

    // CapabilityStudyPlanType
    //

    CapabilityStudyPlanType::
    CapabilityStudyPlanType ()
    : ::xsd::qif30::MultipleProductInstanceStudyPlanBaseType (),
      CpkThreshold_ (this),
      PpkThreshold_ (this)
    {
    }

    CapabilityStudyPlanType::
    CapabilityStudyPlanType (const id_type& id,
                             const NumberOfSamples_type& NumberOfSamples)
    : ::xsd::qif30::MultipleProductInstanceStudyPlanBaseType (id,
                                                              NumberOfSamples),
      CpkThreshold_ (this),
      PpkThreshold_ (this)
    {
    }

    CapabilityStudyPlanType::
    CapabilityStudyPlanType (const CapabilityStudyPlanType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::MultipleProductInstanceStudyPlanBaseType (x, f, c),
      CpkThreshold_ (x.CpkThreshold_, f, this),
      PpkThreshold_ (x.PpkThreshold_, f, this)
    {
    }

    CapabilityStudyPlanType::
    CapabilityStudyPlanType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::MultipleProductInstanceStudyPlanBaseType (e, f | ::xml_schema::flags::base, c),
      CpkThreshold_ (this),
      PpkThreshold_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CapabilityStudyPlanType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::MultipleProductInstanceStudyPlanBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CpkThreshold
        //
        if (n.name () == L"CpkThreshold" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CpkThreshold_type > r (
            CpkThreshold_traits::create (i, f, this));

          if (!this->CpkThreshold_)
          {
            this->CpkThreshold_.set (::std::move (r));
            continue;
          }
        }

        // PpkThreshold
        //
        if (n.name () == L"PpkThreshold" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PpkThreshold_type > r (
            PpkThreshold_traits::create (i, f, this));

          if (!this->PpkThreshold_)
          {
            this->PpkThreshold_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CapabilityStudyPlanType* CapabilityStudyPlanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CapabilityStudyPlanType (*this, f, c);
    }

    CapabilityStudyPlanType& CapabilityStudyPlanType::
    operator= (const CapabilityStudyPlanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::MultipleProductInstanceStudyPlanBaseType& > (*this) = x;
        this->CpkThreshold_ = x.CpkThreshold_;
        this->PpkThreshold_ = x.PpkThreshold_;
      }

      return *this;
    }

    CapabilityStudyPlanType::
    ~CapabilityStudyPlanType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CapabilityStudyPlanType >
    _xsd_CapabilityStudyPlanType_type_factory_init (
      L"CapabilityStudyPlanType",
      L"http://qifstandards.org/xsd/qif3");

    // GageRandRStudyEnumType
    //

    GageRandRStudyEnumType::
    GageRandRStudyEnumType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_GageRandRStudyEnumType_convert ();
    }

    GageRandRStudyEnumType::
    GageRandRStudyEnumType (const xercesc::DOMAttr& a,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_GageRandRStudyEnumType_convert ();
    }

    GageRandRStudyEnumType::
    GageRandRStudyEnumType (const ::std::wstring& s,
                            const xercesc::DOMElement* e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_GageRandRStudyEnumType_convert ();
    }

    GageRandRStudyEnumType* GageRandRStudyEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class GageRandRStudyEnumType (*this, f, c);
    }

    GageRandRStudyEnumType::value GageRandRStudyEnumType::
    _xsd_GageRandRStudyEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_GageRandRStudyEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_GageRandRStudyEnumType_indexes_,
                        _xsd_GageRandRStudyEnumType_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_GageRandRStudyEnumType_indexes_ + 3 || _xsd_GageRandRStudyEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const GageRandRStudyEnumType::
    _xsd_GageRandRStudyEnumType_literals_[3] =
    {
      L"RANGE",
      L"AVGANDRANGE",
      L"ANOVA"
    };

    const GageRandRStudyEnumType::value GageRandRStudyEnumType::
    _xsd_GageRandRStudyEnumType_indexes_[3] =
    {
      ::xsd::qif30::GageRandRStudyEnumType::ANOVA,
      ::xsd::qif30::GageRandRStudyEnumType::AVGANDRANGE,
      ::xsd::qif30::GageRandRStudyEnumType::RANGE
    };

    // CriteriaByUnitType
    //

    CriteriaByUnitType::
    CriteriaByUnitType ()
    : ::xml_schema::type (),
      LinearCriterion_ (this),
      AngularCriterion_ (this),
      AreaCriterion_ (this),
      ForceCriterion_ (this),
      MassCriterion_ (this),
      PressureCriterion_ (this),
      SpeedCriterion_ (this),
      TemperatureCriterion_ (this),
      TimeCriterion_ (this),
      UserDefinedUnitCriterion_ (this),
      n_ (this)
    {
    }

    CriteriaByUnitType::
    CriteriaByUnitType (const n_type& n)
    : ::xml_schema::type (),
      LinearCriterion_ (this),
      AngularCriterion_ (this),
      AreaCriterion_ (this),
      ForceCriterion_ (this),
      MassCriterion_ (this),
      PressureCriterion_ (this),
      SpeedCriterion_ (this),
      TemperatureCriterion_ (this),
      TimeCriterion_ (this),
      UserDefinedUnitCriterion_ (this),
      n_ (n, this)
    {
    }

    CriteriaByUnitType::
    CriteriaByUnitType (const CriteriaByUnitType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      LinearCriterion_ (x.LinearCriterion_, f, this),
      AngularCriterion_ (x.AngularCriterion_, f, this),
      AreaCriterion_ (x.AreaCriterion_, f, this),
      ForceCriterion_ (x.ForceCriterion_, f, this),
      MassCriterion_ (x.MassCriterion_, f, this),
      PressureCriterion_ (x.PressureCriterion_, f, this),
      SpeedCriterion_ (x.SpeedCriterion_, f, this),
      TemperatureCriterion_ (x.TemperatureCriterion_, f, this),
      TimeCriterion_ (x.TimeCriterion_, f, this),
      UserDefinedUnitCriterion_ (x.UserDefinedUnitCriterion_, f, this),
      n_ (x.n_, f, this)
    {
    }

    CriteriaByUnitType::
    CriteriaByUnitType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      LinearCriterion_ (this),
      AngularCriterion_ (this),
      AreaCriterion_ (this),
      ForceCriterion_ (this),
      MassCriterion_ (this),
      PressureCriterion_ (this),
      SpeedCriterion_ (this),
      TemperatureCriterion_ (this),
      TimeCriterion_ (this),
      UserDefinedUnitCriterion_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CriteriaByUnitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // LinearCriterion
        //
        if (n.name () == L"LinearCriterion" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LinearCriterion_type > r (
            LinearCriterion_traits::create (i, f, this));

          if (!this->LinearCriterion_)
          {
            this->LinearCriterion_.set (::std::move (r));
            continue;
          }
        }

        // AngularCriterion
        //
        if (n.name () == L"AngularCriterion" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AngularCriterion_type > r (
            AngularCriterion_traits::create (i, f, this));

          if (!this->AngularCriterion_)
          {
            this->AngularCriterion_.set (::std::move (r));
            continue;
          }
        }

        // AreaCriterion
        //
        if (n.name () == L"AreaCriterion" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AreaCriterion_type > r (
            AreaCriterion_traits::create (i, f, this));

          if (!this->AreaCriterion_)
          {
            this->AreaCriterion_.set (::std::move (r));
            continue;
          }
        }

        // ForceCriterion
        //
        if (n.name () == L"ForceCriterion" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ForceCriterion_type > r (
            ForceCriterion_traits::create (i, f, this));

          if (!this->ForceCriterion_)
          {
            this->ForceCriterion_.set (::std::move (r));
            continue;
          }
        }

        // MassCriterion
        //
        if (n.name () == L"MassCriterion" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MassCriterion_type > r (
            MassCriterion_traits::create (i, f, this));

          if (!this->MassCriterion_)
          {
            this->MassCriterion_.set (::std::move (r));
            continue;
          }
        }

        // PressureCriterion
        //
        if (n.name () == L"PressureCriterion" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PressureCriterion_type > r (
            PressureCriterion_traits::create (i, f, this));

          if (!this->PressureCriterion_)
          {
            this->PressureCriterion_.set (::std::move (r));
            continue;
          }
        }

        // SpeedCriterion
        //
        if (n.name () == L"SpeedCriterion" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SpeedCriterion_type > r (
            SpeedCriterion_traits::create (i, f, this));

          if (!this->SpeedCriterion_)
          {
            this->SpeedCriterion_.set (::std::move (r));
            continue;
          }
        }

        // TemperatureCriterion
        //
        if (n.name () == L"TemperatureCriterion" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TemperatureCriterion_type > r (
            TemperatureCriterion_traits::create (i, f, this));

          if (!this->TemperatureCriterion_)
          {
            this->TemperatureCriterion_.set (::std::move (r));
            continue;
          }
        }

        // TimeCriterion
        //
        if (n.name () == L"TimeCriterion" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TimeCriterion_type > r (
            TimeCriterion_traits::create (i, f, this));

          if (!this->TimeCriterion_)
          {
            this->TimeCriterion_.set (::std::move (r));
            continue;
          }
        }

        // UserDefinedUnitCriterion
        //
        if (n.name () == L"UserDefinedUnitCriterion" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDefinedUnitCriterion_type > r (
            UserDefinedUnitCriterion_traits::create (i, f, this));

          this->UserDefinedUnitCriterion_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    CriteriaByUnitType* CriteriaByUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CriteriaByUnitType (*this, f, c);
    }

    CriteriaByUnitType& CriteriaByUnitType::
    operator= (const CriteriaByUnitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->LinearCriterion_ = x.LinearCriterion_;
        this->AngularCriterion_ = x.AngularCriterion_;
        this->AreaCriterion_ = x.AreaCriterion_;
        this->ForceCriterion_ = x.ForceCriterion_;
        this->MassCriterion_ = x.MassCriterion_;
        this->PressureCriterion_ = x.PressureCriterion_;
        this->SpeedCriterion_ = x.SpeedCriterion_;
        this->TemperatureCriterion_ = x.TemperatureCriterion_;
        this->TimeCriterion_ = x.TimeCriterion_;
        this->UserDefinedUnitCriterion_ = x.UserDefinedUnitCriterion_;
        this->n_ = x.n_;
      }

      return *this;
    }

    CriteriaByUnitType::
    ~CriteriaByUnitType ()
    {
    }

    // GageRandRStudyPlanType
    //

    GageRandRStudyPlanType::
    GageRandRStudyPlanType ()
    : ::xsd::qif30::StatisticalStudyPlanBaseType (),
      MeasurementDeviceIds_ (this),
      RandRStudyType_ (this),
      NumberOfAppraisers_ (this),
      NumberOfParts_ (this),
      NumberOfTrials_ (this),
      MaximumRelativeAppraiserVariation_ (this),
      MaximumAbsoluteAppraiserVariation_ (this),
      MaximumRelativeEquipmentVariation_ (this),
      MaximumAbsoluteEquipmentVariation_ (this),
      MaximumRelativeTotalRandR_ (this),
      MaximumAbsoluteTotalRandR_ (this)
    {
    }

    GageRandRStudyPlanType::
    GageRandRStudyPlanType (const id_type& id,
                            const RandRStudyType_type& RandRStudyType,
                            const NumberOfAppraisers_type& NumberOfAppraisers,
                            const NumberOfParts_type& NumberOfParts,
                            const NumberOfTrials_type& NumberOfTrials)
    : ::xsd::qif30::StatisticalStudyPlanBaseType (id),
      MeasurementDeviceIds_ (this),
      RandRStudyType_ (RandRStudyType, this),
      NumberOfAppraisers_ (NumberOfAppraisers, this),
      NumberOfParts_ (NumberOfParts, this),
      NumberOfTrials_ (NumberOfTrials, this),
      MaximumRelativeAppraiserVariation_ (this),
      MaximumAbsoluteAppraiserVariation_ (this),
      MaximumRelativeEquipmentVariation_ (this),
      MaximumAbsoluteEquipmentVariation_ (this),
      MaximumRelativeTotalRandR_ (this),
      MaximumAbsoluteTotalRandR_ (this)
    {
    }

    GageRandRStudyPlanType::
    GageRandRStudyPlanType (const GageRandRStudyPlanType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::StatisticalStudyPlanBaseType (x, f, c),
      MeasurementDeviceIds_ (x.MeasurementDeviceIds_, f, this),
      RandRStudyType_ (x.RandRStudyType_, f, this),
      NumberOfAppraisers_ (x.NumberOfAppraisers_, f, this),
      NumberOfParts_ (x.NumberOfParts_, f, this),
      NumberOfTrials_ (x.NumberOfTrials_, f, this),
      MaximumRelativeAppraiserVariation_ (x.MaximumRelativeAppraiserVariation_, f, this),
      MaximumAbsoluteAppraiserVariation_ (x.MaximumAbsoluteAppraiserVariation_, f, this),
      MaximumRelativeEquipmentVariation_ (x.MaximumRelativeEquipmentVariation_, f, this),
      MaximumAbsoluteEquipmentVariation_ (x.MaximumAbsoluteEquipmentVariation_, f, this),
      MaximumRelativeTotalRandR_ (x.MaximumRelativeTotalRandR_, f, this),
      MaximumAbsoluteTotalRandR_ (x.MaximumAbsoluteTotalRandR_, f, this)
    {
    }

    GageRandRStudyPlanType::
    GageRandRStudyPlanType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::StatisticalStudyPlanBaseType (e, f | ::xml_schema::flags::base, c),
      MeasurementDeviceIds_ (this),
      RandRStudyType_ (this),
      NumberOfAppraisers_ (this),
      NumberOfParts_ (this),
      NumberOfTrials_ (this),
      MaximumRelativeAppraiserVariation_ (this),
      MaximumAbsoluteAppraiserVariation_ (this),
      MaximumRelativeEquipmentVariation_ (this),
      MaximumAbsoluteEquipmentVariation_ (this),
      MaximumRelativeTotalRandR_ (this),
      MaximumAbsoluteTotalRandR_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void GageRandRStudyPlanType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatisticalStudyPlanBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MeasurementDeviceIds
        //
        if (n.name () == L"MeasurementDeviceIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeasurementDeviceIds_type > r (
            MeasurementDeviceIds_traits::create (i, f, this));

          if (!this->MeasurementDeviceIds_)
          {
            this->MeasurementDeviceIds_.set (::std::move (r));
            continue;
          }
        }

        // RandRStudyType
        //
        if (n.name () == L"RandRStudyType" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RandRStudyType_type > r (
            RandRStudyType_traits::create (i, f, this));

          if (!RandRStudyType_.present ())
          {
            this->RandRStudyType_.set (::std::move (r));
            continue;
          }
        }

        // NumberOfAppraisers
        //
        if (n.name () == L"NumberOfAppraisers" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!NumberOfAppraisers_.present ())
          {
            this->NumberOfAppraisers_.set (NumberOfAppraisers_traits::create (i, f, this));
            continue;
          }
        }

        // NumberOfParts
        //
        if (n.name () == L"NumberOfParts" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!NumberOfParts_.present ())
          {
            this->NumberOfParts_.set (NumberOfParts_traits::create (i, f, this));
            continue;
          }
        }

        // NumberOfTrials
        //
        if (n.name () == L"NumberOfTrials" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!NumberOfTrials_.present ())
          {
            this->NumberOfTrials_.set (NumberOfTrials_traits::create (i, f, this));
            continue;
          }
        }

        // MaximumRelativeAppraiserVariation
        //
        if (n.name () == L"MaximumRelativeAppraiserVariation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaximumRelativeAppraiserVariation_type > r (
            MaximumRelativeAppraiserVariation_traits::create (i, f, this));

          if (!this->MaximumRelativeAppraiserVariation_)
          {
            this->MaximumRelativeAppraiserVariation_.set (::std::move (r));
            continue;
          }
        }

        // MaximumAbsoluteAppraiserVariation
        //
        if (n.name () == L"MaximumAbsoluteAppraiserVariation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaximumAbsoluteAppraiserVariation_type > r (
            MaximumAbsoluteAppraiserVariation_traits::create (i, f, this));

          if (!this->MaximumAbsoluteAppraiserVariation_)
          {
            this->MaximumAbsoluteAppraiserVariation_.set (::std::move (r));
            continue;
          }
        }

        // MaximumRelativeEquipmentVariation
        //
        if (n.name () == L"MaximumRelativeEquipmentVariation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaximumRelativeEquipmentVariation_type > r (
            MaximumRelativeEquipmentVariation_traits::create (i, f, this));

          if (!this->MaximumRelativeEquipmentVariation_)
          {
            this->MaximumRelativeEquipmentVariation_.set (::std::move (r));
            continue;
          }
        }

        // MaximumAbsoluteEquipmentVariation
        //
        if (n.name () == L"MaximumAbsoluteEquipmentVariation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaximumAbsoluteEquipmentVariation_type > r (
            MaximumAbsoluteEquipmentVariation_traits::create (i, f, this));

          if (!this->MaximumAbsoluteEquipmentVariation_)
          {
            this->MaximumAbsoluteEquipmentVariation_.set (::std::move (r));
            continue;
          }
        }

        // MaximumRelativeTotalRandR
        //
        if (n.name () == L"MaximumRelativeTotalRandR" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaximumRelativeTotalRandR_type > r (
            MaximumRelativeTotalRandR_traits::create (i, f, this));

          if (!this->MaximumRelativeTotalRandR_)
          {
            this->MaximumRelativeTotalRandR_.set (::std::move (r));
            continue;
          }
        }

        // MaximumAbsoluteTotalRandR
        //
        if (n.name () == L"MaximumAbsoluteTotalRandR" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MaximumAbsoluteTotalRandR_type > r (
            MaximumAbsoluteTotalRandR_traits::create (i, f, this));

          if (!this->MaximumAbsoluteTotalRandR_)
          {
            this->MaximumAbsoluteTotalRandR_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!RandRStudyType_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"RandRStudyType",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!NumberOfAppraisers_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"NumberOfAppraisers",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!NumberOfParts_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"NumberOfParts",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!NumberOfTrials_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"NumberOfTrials",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    GageRandRStudyPlanType* GageRandRStudyPlanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class GageRandRStudyPlanType (*this, f, c);
    }

    GageRandRStudyPlanType& GageRandRStudyPlanType::
    operator= (const GageRandRStudyPlanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatisticalStudyPlanBaseType& > (*this) = x;
        this->MeasurementDeviceIds_ = x.MeasurementDeviceIds_;
        this->RandRStudyType_ = x.RandRStudyType_;
        this->NumberOfAppraisers_ = x.NumberOfAppraisers_;
        this->NumberOfParts_ = x.NumberOfParts_;
        this->NumberOfTrials_ = x.NumberOfTrials_;
        this->MaximumRelativeAppraiserVariation_ = x.MaximumRelativeAppraiserVariation_;
        this->MaximumAbsoluteAppraiserVariation_ = x.MaximumAbsoluteAppraiserVariation_;
        this->MaximumRelativeEquipmentVariation_ = x.MaximumRelativeEquipmentVariation_;
        this->MaximumAbsoluteEquipmentVariation_ = x.MaximumAbsoluteEquipmentVariation_;
        this->MaximumRelativeTotalRandR_ = x.MaximumRelativeTotalRandR_;
        this->MaximumAbsoluteTotalRandR_ = x.MaximumAbsoluteTotalRandR_;
      }

      return *this;
    }

    GageRandRStudyPlanType::
    ~GageRandRStudyPlanType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, GageRandRStudyPlanType >
    _xsd_GageRandRStudyPlanType_type_factory_init (
      L"GageRandRStudyPlanType",
      L"http://qifstandards.org/xsd/qif3");

    // ControlMethodType
    //

    ControlMethodType::
    ControlMethodType ()
    : ::xml_schema::type (),
      AssignableCauseIds_ (this),
      Attributes_ (this),
      NumOutOfTolerance_ (this),
      CpThreshold_ (this),
      CpkThreshold_ (this),
      PpThreshold_ (this),
      PpkThreshold_ (this),
      NumOutOfControl_ (this),
      TrendGrouping_ (this),
      SkewGrouping_ (this),
      OneThirdGrouping_ (this),
      TwoThirdsGrouping_ (this),
      Oscillation_ (this),
      Stratification_ (this),
      NumOutOfControlRng_ (this),
      id_ (this)
    {
    }

    ControlMethodType::
    ControlMethodType (const id_type& id)
    : ::xml_schema::type (),
      AssignableCauseIds_ (this),
      Attributes_ (this),
      NumOutOfTolerance_ (this),
      CpThreshold_ (this),
      CpkThreshold_ (this),
      PpThreshold_ (this),
      PpkThreshold_ (this),
      NumOutOfControl_ (this),
      TrendGrouping_ (this),
      SkewGrouping_ (this),
      OneThirdGrouping_ (this),
      TwoThirdsGrouping_ (this),
      Oscillation_ (this),
      Stratification_ (this),
      NumOutOfControlRng_ (this),
      id_ (id, this)
    {
    }

    ControlMethodType::
    ControlMethodType (const ControlMethodType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      AssignableCauseIds_ (x.AssignableCauseIds_, f, this),
      Attributes_ (x.Attributes_, f, this),
      NumOutOfTolerance_ (x.NumOutOfTolerance_, f, this),
      CpThreshold_ (x.CpThreshold_, f, this),
      CpkThreshold_ (x.CpkThreshold_, f, this),
      PpThreshold_ (x.PpThreshold_, f, this),
      PpkThreshold_ (x.PpkThreshold_, f, this),
      NumOutOfControl_ (x.NumOutOfControl_, f, this),
      TrendGrouping_ (x.TrendGrouping_, f, this),
      SkewGrouping_ (x.SkewGrouping_, f, this),
      OneThirdGrouping_ (x.OneThirdGrouping_, f, this),
      TwoThirdsGrouping_ (x.TwoThirdsGrouping_, f, this),
      Oscillation_ (x.Oscillation_, f, this),
      Stratification_ (x.Stratification_, f, this),
      NumOutOfControlRng_ (x.NumOutOfControlRng_, f, this),
      id_ (x.id_, f, this)
    {
    }

    ControlMethodType::
    ControlMethodType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AssignableCauseIds_ (this),
      Attributes_ (this),
      NumOutOfTolerance_ (this),
      CpThreshold_ (this),
      CpkThreshold_ (this),
      PpThreshold_ (this),
      PpkThreshold_ (this),
      NumOutOfControl_ (this),
      TrendGrouping_ (this),
      SkewGrouping_ (this),
      OneThirdGrouping_ (this),
      TwoThirdsGrouping_ (this),
      Oscillation_ (this),
      Stratification_ (this),
      NumOutOfControlRng_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ControlMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AssignableCauseIds
        //
        if (n.name () == L"AssignableCauseIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AssignableCauseIds_type > r (
            AssignableCauseIds_traits::create (i, f, this));

          if (!this->AssignableCauseIds_)
          {
            this->AssignableCauseIds_.set (::std::move (r));
            continue;
          }
        }

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        // NumOutOfTolerance
        //
        if (n.name () == L"NumOutOfTolerance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NumOutOfTolerance_type > r (
            NumOutOfTolerance_traits::create (i, f, this));

          if (!this->NumOutOfTolerance_)
          {
            this->NumOutOfTolerance_.set (::std::move (r));
            continue;
          }
        }

        // CpThreshold
        //
        if (n.name () == L"CpThreshold" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CpThreshold_type > r (
            CpThreshold_traits::create (i, f, this));

          if (!this->CpThreshold_)
          {
            this->CpThreshold_.set (::std::move (r));
            continue;
          }
        }

        // CpkThreshold
        //
        if (n.name () == L"CpkThreshold" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CpkThreshold_type > r (
            CpkThreshold_traits::create (i, f, this));

          if (!this->CpkThreshold_)
          {
            this->CpkThreshold_.set (::std::move (r));
            continue;
          }
        }

        // PpThreshold
        //
        if (n.name () == L"PpThreshold" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PpThreshold_type > r (
            PpThreshold_traits::create (i, f, this));

          if (!this->PpThreshold_)
          {
            this->PpThreshold_.set (::std::move (r));
            continue;
          }
        }

        // PpkThreshold
        //
        if (n.name () == L"PpkThreshold" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PpkThreshold_type > r (
            PpkThreshold_traits::create (i, f, this));

          if (!this->PpkThreshold_)
          {
            this->PpkThreshold_.set (::std::move (r));
            continue;
          }
        }

        // NumOutOfControl
        //
        if (n.name () == L"NumOutOfControl" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NumOutOfControl_type > r (
            NumOutOfControl_traits::create (i, f, this));

          if (!this->NumOutOfControl_)
          {
            this->NumOutOfControl_.set (::std::move (r));
            continue;
          }
        }

        // TrendGrouping
        //
        if (n.name () == L"TrendGrouping" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TrendGrouping_type > r (
            TrendGrouping_traits::create (i, f, this));

          if (!this->TrendGrouping_)
          {
            this->TrendGrouping_.set (::std::move (r));
            continue;
          }
        }

        // SkewGrouping
        //
        if (n.name () == L"SkewGrouping" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SkewGrouping_type > r (
            SkewGrouping_traits::create (i, f, this));

          if (!this->SkewGrouping_)
          {
            this->SkewGrouping_.set (::std::move (r));
            continue;
          }
        }

        // OneThirdGrouping
        //
        if (n.name () == L"OneThirdGrouping" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OneThirdGrouping_type > r (
            OneThirdGrouping_traits::create (i, f, this));

          if (!this->OneThirdGrouping_)
          {
            this->OneThirdGrouping_.set (::std::move (r));
            continue;
          }
        }

        // TwoThirdsGrouping
        //
        if (n.name () == L"TwoThirdsGrouping" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TwoThirdsGrouping_type > r (
            TwoThirdsGrouping_traits::create (i, f, this));

          if (!this->TwoThirdsGrouping_)
          {
            this->TwoThirdsGrouping_.set (::std::move (r));
            continue;
          }
        }

        // Oscillation
        //
        if (n.name () == L"Oscillation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Oscillation_type > r (
            Oscillation_traits::create (i, f, this));

          if (!this->Oscillation_)
          {
            this->Oscillation_.set (::std::move (r));
            continue;
          }
        }

        // Stratification
        //
        if (n.name () == L"Stratification" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Stratification_type > r (
            Stratification_traits::create (i, f, this));

          if (!this->Stratification_)
          {
            this->Stratification_.set (::std::move (r));
            continue;
          }
        }

        // NumOutOfControlRng
        //
        if (n.name () == L"NumOutOfControlRng" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NumOutOfControlRng_type > r (
            NumOutOfControlRng_traits::create (i, f, this));

          if (!this->NumOutOfControlRng_)
          {
            this->NumOutOfControlRng_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    ControlMethodType* ControlMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ControlMethodType (*this, f, c);
    }

    ControlMethodType& ControlMethodType::
    operator= (const ControlMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->AssignableCauseIds_ = x.AssignableCauseIds_;
        this->Attributes_ = x.Attributes_;
        this->NumOutOfTolerance_ = x.NumOutOfTolerance_;
        this->CpThreshold_ = x.CpThreshold_;
        this->CpkThreshold_ = x.CpkThreshold_;
        this->PpThreshold_ = x.PpThreshold_;
        this->PpkThreshold_ = x.PpkThreshold_;
        this->NumOutOfControl_ = x.NumOutOfControl_;
        this->TrendGrouping_ = x.TrendGrouping_;
        this->SkewGrouping_ = x.SkewGrouping_;
        this->OneThirdGrouping_ = x.OneThirdGrouping_;
        this->TwoThirdsGrouping_ = x.TwoThirdsGrouping_;
        this->Oscillation_ = x.Oscillation_;
        this->Stratification_ = x.Stratification_;
        this->NumOutOfControlRng_ = x.NumOutOfControlRng_;
        this->id_ = x.id_;
      }

      return *this;
    }

    ControlMethodType::
    ~ControlMethodType ()
    {
    }

    // ControlMethodsType
    //

    ControlMethodsType::
    ControlMethodsType ()
    : ::xml_schema::type (),
      ControlMethod_ (this),
      n_ (this)
    {
    }

    ControlMethodsType::
    ControlMethodsType (const n_type& n)
    : ::xml_schema::type (),
      ControlMethod_ (this),
      n_ (n, this)
    {
    }

    ControlMethodsType::
    ControlMethodsType (const ControlMethodsType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ControlMethod_ (x.ControlMethod_, f, this),
      n_ (x.n_, f, this)
    {
    }

    ControlMethodsType::
    ControlMethodsType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ControlMethod_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ControlMethodsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ControlMethod
        //
        if (n.name () == L"ControlMethod" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ControlMethod_type > r (
            ControlMethod_traits::create (i, f, this));

          this->ControlMethod_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    ControlMethodsType* ControlMethodsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ControlMethodsType (*this, f, c);
    }

    ControlMethodsType& ControlMethodsType::
    operator= (const ControlMethodsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ControlMethod_ = x.ControlMethod_;
        this->n_ = x.n_;
      }

      return *this;
    }

    ControlMethodsType::
    ~ControlMethodsType ()
    {
    }

    // ProductionStudyPlanType
    //

    ProductionStudyPlanType::
    ProductionStudyPlanType ()
    : ::xsd::qif30::MultipleProductInstanceStudyPlanBaseType (),
      SamplingMethod_ (this),
      ControlMethods_ (this)
    {
    }

    ProductionStudyPlanType::
    ProductionStudyPlanType (const id_type& id,
                             const NumberOfSamples_type& NumberOfSamples,
                             const SamplingMethod_type& SamplingMethod,
                             const ControlMethods_type& ControlMethods)
    : ::xsd::qif30::MultipleProductInstanceStudyPlanBaseType (id,
                                                              NumberOfSamples),
      SamplingMethod_ (SamplingMethod, this),
      ControlMethods_ (ControlMethods, this)
    {
    }

    ProductionStudyPlanType::
    ProductionStudyPlanType (const id_type& id,
                             const NumberOfSamples_type& NumberOfSamples,
                             ::std::unique_ptr< SamplingMethod_type > SamplingMethod,
                             ::std::unique_ptr< ControlMethods_type > ControlMethods)
    : ::xsd::qif30::MultipleProductInstanceStudyPlanBaseType (id,
                                                              NumberOfSamples),
      SamplingMethod_ (std::move (SamplingMethod), this),
      ControlMethods_ (std::move (ControlMethods), this)
    {
    }

    ProductionStudyPlanType::
    ProductionStudyPlanType (const ProductionStudyPlanType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::MultipleProductInstanceStudyPlanBaseType (x, f, c),
      SamplingMethod_ (x.SamplingMethod_, f, this),
      ControlMethods_ (x.ControlMethods_, f, this)
    {
    }

    ProductionStudyPlanType::
    ProductionStudyPlanType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::MultipleProductInstanceStudyPlanBaseType (e, f | ::xml_schema::flags::base, c),
      SamplingMethod_ (this),
      ControlMethods_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ProductionStudyPlanType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::MultipleProductInstanceStudyPlanBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SamplingMethod
        //
        if (n.name () == L"SamplingMethod" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SamplingMethod_type > r (
            SamplingMethod_traits::create (i, f, this));

          if (!SamplingMethod_.present ())
          {
            this->SamplingMethod_.set (::std::move (r));
            continue;
          }
        }

        // ControlMethods
        //
        if (n.name () == L"ControlMethods" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ControlMethods_type > r (
            ControlMethods_traits::create (i, f, this));

          if (!ControlMethods_.present ())
          {
            this->ControlMethods_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SamplingMethod_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SamplingMethod",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ControlMethods_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ControlMethods",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ProductionStudyPlanType* ProductionStudyPlanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ProductionStudyPlanType (*this, f, c);
    }

    ProductionStudyPlanType& ProductionStudyPlanType::
    operator= (const ProductionStudyPlanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::MultipleProductInstanceStudyPlanBaseType& > (*this) = x;
        this->SamplingMethod_ = x.SamplingMethod_;
        this->ControlMethods_ = x.ControlMethods_;
      }

      return *this;
    }

    ProductionStudyPlanType::
    ~ProductionStudyPlanType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ProductionStudyPlanType >
    _xsd_ProductionStudyPlanType_type_factory_init (
      L"ProductionStudyPlanType",
      L"http://qifstandards.org/xsd/qif3");

    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_FirstArticleStudyPlan_element_factory_init (
      L"StatisticalStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      L"FirstArticleStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::FirstArticleStudyPlanType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_LinearityStudyPlan_element_factory_init (
      L"StatisticalStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      L"LinearityStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::LinearityStudyPlanType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SimpleStudyPlan_element_factory_init (
      L"StatisticalStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      L"SimpleStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SimpleStudyPlanType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_BiasStudyPlan_element_factory_init (
      L"StatisticalStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      L"BiasStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::BiasStudyPlanType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_StabilityStudyPlan_element_factory_init (
      L"StatisticalStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      L"StabilityStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StabilityStudyPlanType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ProcessDifferenceStudyPlan_element_factory_init (
      L"StatisticalStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      L"ProcessDifferenceStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ProcessDifferenceStudyPlanType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CapabilityStudyPlan_element_factory_init (
      L"StatisticalStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      L"CapabilityStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CapabilityStudyPlanType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_GageRandRStudyPlan_element_factory_init (
      L"StatisticalStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      L"GageRandRStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::GageRandRStudyPlanType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ProductionStudyPlan_element_factory_init (
      L"StatisticalStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      L"ProductionStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ProductionStudyPlanType >);


    // StatisticalStudyResultsBaseType
    //

    StatisticalStudyResultsBaseType::
    StatisticalStudyResultsBaseType ()
    : ::xml_schema::type (),
      ThisStatisticalStudyResultsInstanceQPId_ (this),
      Attributes_ (this),
      Status_ (this),
      SoftwareId_ (this),
      StandardId_ (this),
      StudyIssues_ (this),
      InspectionTraceability_ (this),
      Name_ (this),
      Description_ (this),
      StudyId_ (this),
      ResultsIds_ (this),
      ResultsQPIds_ (this),
      ResultsFiles_ (this),
      AverageFeatures_ (this),
      CharacteristicsStats_ (this),
      LinearStatsSummaries_ (this),
      AngularStatsSummaries_ (this),
      AreaStatsSummaries_ (this),
      ForceStatsSummaries_ (this),
      MassStatsSummaries_ (this),
      PressureStatsSummaries_ (this),
      SpeedStatsSummaries_ (this),
      TemperatureStatsSummaries_ (this),
      TimeStatsSummaries_ (this),
      UserDefinedUnitStatsSummaries_ (this),
      StatsSummaries_ (this),
      id_ (this)
    {
    }

    StatisticalStudyResultsBaseType::
    StatisticalStudyResultsBaseType (const Status_type& Status,
                                     const id_type& id)
    : ::xml_schema::type (),
      ThisStatisticalStudyResultsInstanceQPId_ (this),
      Attributes_ (this),
      Status_ (Status, this),
      SoftwareId_ (this),
      StandardId_ (this),
      StudyIssues_ (this),
      InspectionTraceability_ (this),
      Name_ (this),
      Description_ (this),
      StudyId_ (this),
      ResultsIds_ (this),
      ResultsQPIds_ (this),
      ResultsFiles_ (this),
      AverageFeatures_ (this),
      CharacteristicsStats_ (this),
      LinearStatsSummaries_ (this),
      AngularStatsSummaries_ (this),
      AreaStatsSummaries_ (this),
      ForceStatsSummaries_ (this),
      MassStatsSummaries_ (this),
      PressureStatsSummaries_ (this),
      SpeedStatsSummaries_ (this),
      TemperatureStatsSummaries_ (this),
      TimeStatsSummaries_ (this),
      UserDefinedUnitStatsSummaries_ (this),
      StatsSummaries_ (this),
      id_ (id, this)
    {
    }

    StatisticalStudyResultsBaseType::
    StatisticalStudyResultsBaseType (::std::unique_ptr< Status_type > Status,
                                     const id_type& id)
    : ::xml_schema::type (),
      ThisStatisticalStudyResultsInstanceQPId_ (this),
      Attributes_ (this),
      Status_ (std::move (Status), this),
      SoftwareId_ (this),
      StandardId_ (this),
      StudyIssues_ (this),
      InspectionTraceability_ (this),
      Name_ (this),
      Description_ (this),
      StudyId_ (this),
      ResultsIds_ (this),
      ResultsQPIds_ (this),
      ResultsFiles_ (this),
      AverageFeatures_ (this),
      CharacteristicsStats_ (this),
      LinearStatsSummaries_ (this),
      AngularStatsSummaries_ (this),
      AreaStatsSummaries_ (this),
      ForceStatsSummaries_ (this),
      MassStatsSummaries_ (this),
      PressureStatsSummaries_ (this),
      SpeedStatsSummaries_ (this),
      TemperatureStatsSummaries_ (this),
      TimeStatsSummaries_ (this),
      UserDefinedUnitStatsSummaries_ (this),
      StatsSummaries_ (this),
      id_ (id, this)
    {
    }

    StatisticalStudyResultsBaseType::
    StatisticalStudyResultsBaseType (const StatisticalStudyResultsBaseType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ThisStatisticalStudyResultsInstanceQPId_ (x.ThisStatisticalStudyResultsInstanceQPId_, f, this),
      Attributes_ (x.Attributes_, f, this),
      Status_ (x.Status_, f, this),
      SoftwareId_ (x.SoftwareId_, f, this),
      StandardId_ (x.StandardId_, f, this),
      StudyIssues_ (x.StudyIssues_, f, this),
      InspectionTraceability_ (x.InspectionTraceability_, f, this),
      Name_ (x.Name_, f, this),
      Description_ (x.Description_, f, this),
      StudyId_ (x.StudyId_, f, this),
      ResultsIds_ (x.ResultsIds_, f, this),
      ResultsQPIds_ (x.ResultsQPIds_, f, this),
      ResultsFiles_ (x.ResultsFiles_, f, this),
      AverageFeatures_ (x.AverageFeatures_, f, this),
      CharacteristicsStats_ (x.CharacteristicsStats_, f, this),
      LinearStatsSummaries_ (x.LinearStatsSummaries_, f, this),
      AngularStatsSummaries_ (x.AngularStatsSummaries_, f, this),
      AreaStatsSummaries_ (x.AreaStatsSummaries_, f, this),
      ForceStatsSummaries_ (x.ForceStatsSummaries_, f, this),
      MassStatsSummaries_ (x.MassStatsSummaries_, f, this),
      PressureStatsSummaries_ (x.PressureStatsSummaries_, f, this),
      SpeedStatsSummaries_ (x.SpeedStatsSummaries_, f, this),
      TemperatureStatsSummaries_ (x.TemperatureStatsSummaries_, f, this),
      TimeStatsSummaries_ (x.TimeStatsSummaries_, f, this),
      UserDefinedUnitStatsSummaries_ (x.UserDefinedUnitStatsSummaries_, f, this),
      StatsSummaries_ (x.StatsSummaries_, f, this),
      id_ (x.id_, f, this)
    {
    }

    StatisticalStudyResultsBaseType::
    StatisticalStudyResultsBaseType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ThisStatisticalStudyResultsInstanceQPId_ (this),
      Attributes_ (this),
      Status_ (this),
      SoftwareId_ (this),
      StandardId_ (this),
      StudyIssues_ (this),
      InspectionTraceability_ (this),
      Name_ (this),
      Description_ (this),
      StudyId_ (this),
      ResultsIds_ (this),
      ResultsQPIds_ (this),
      ResultsFiles_ (this),
      AverageFeatures_ (this),
      CharacteristicsStats_ (this),
      LinearStatsSummaries_ (this),
      AngularStatsSummaries_ (this),
      AreaStatsSummaries_ (this),
      ForceStatsSummaries_ (this),
      MassStatsSummaries_ (this),
      PressureStatsSummaries_ (this),
      SpeedStatsSummaries_ (this),
      TemperatureStatsSummaries_ (this),
      TimeStatsSummaries_ (this),
      UserDefinedUnitStatsSummaries_ (this),
      StatsSummaries_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void StatisticalStudyResultsBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ThisStatisticalStudyResultsInstanceQPId
        //
        if (n.name () == L"ThisStatisticalStudyResultsInstanceQPId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThisStatisticalStudyResultsInstanceQPId_type > r (
            ThisStatisticalStudyResultsInstanceQPId_traits::create (i, f, this));

          if (!this->ThisStatisticalStudyResultsInstanceQPId_)
          {
            this->ThisStatisticalStudyResultsInstanceQPId_.set (::std::move (r));
            continue;
          }
        }

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        // Status
        //
        if (n.name () == L"Status" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Status_type > r (
            Status_traits::create (i, f, this));

          if (!Status_.present ())
          {
            this->Status_.set (::std::move (r));
            continue;
          }
        }

        // SoftwareId
        //
        if (n.name () == L"SoftwareId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SoftwareId_type > r (
            SoftwareId_traits::create (i, f, this));

          if (!this->SoftwareId_)
          {
            this->SoftwareId_.set (::std::move (r));
            continue;
          }
        }

        // StandardId
        //
        if (n.name () == L"StandardId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StandardId_type > r (
            StandardId_traits::create (i, f, this));

          if (!this->StandardId_)
          {
            this->StandardId_.set (::std::move (r));
            continue;
          }
        }

        // StudyIssues
        //
        if (n.name () == L"StudyIssues" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StudyIssues_type > r (
            StudyIssues_traits::create (i, f, this));

          if (!this->StudyIssues_)
          {
            this->StudyIssues_.set (::std::move (r));
            continue;
          }
        }

        // InspectionTraceability
        //
        if (n.name () == L"InspectionTraceability" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< InspectionTraceability_type > r (
            InspectionTraceability_traits::create (i, f, this));

          if (!this->InspectionTraceability_)
          {
            this->InspectionTraceability_.set (::std::move (r));
            continue;
          }
        }

        // Name
        //
        if (n.name () == L"Name" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!this->Name_)
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // Description
        //
        if (n.name () == L"Description" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!this->Description_)
          {
            this->Description_.set (::std::move (r));
            continue;
          }
        }

        // StudyId
        //
        if (n.name () == L"StudyId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StudyId_type > r (
            StudyId_traits::create (i, f, this));

          if (!this->StudyId_)
          {
            this->StudyId_.set (::std::move (r));
            continue;
          }
        }

        // ResultsIds
        //
        if (n.name () == L"ResultsIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ResultsIds_type > r (
            ResultsIds_traits::create (i, f, this));

          if (!this->ResultsIds_)
          {
            this->ResultsIds_.set (::std::move (r));
            continue;
          }
        }

        // ResultsQPIds
        //
        if (n.name () == L"ResultsQPIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ResultsQPIds_type > r (
            ResultsQPIds_traits::create (i, f, this));

          this->ResultsQPIds_.push_back (::std::move (r));
          continue;
        }

        // ResultsFiles
        //
        if (n.name () == L"ResultsFiles" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ResultsFiles_type > r (
            ResultsFiles_traits::create (i, f, this));

          if (!this->ResultsFiles_)
          {
            this->ResultsFiles_.set (::std::move (r));
            continue;
          }
        }

        // AverageFeatures
        //
        if (n.name () == L"AverageFeatures" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AverageFeatures_type > r (
            AverageFeatures_traits::create (i, f, this));

          if (!this->AverageFeatures_)
          {
            this->AverageFeatures_.set (::std::move (r));
            continue;
          }
        }

        // CharacteristicsStats
        //
        if (n.name () == L"CharacteristicsStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CharacteristicsStats_type > r (
            CharacteristicsStats_traits::create (i, f, this));

          if (!this->CharacteristicsStats_)
          {
            this->CharacteristicsStats_.set (::std::move (r));
            continue;
          }
        }

        // LinearStatsSummaries
        //
        if (n.name () == L"LinearStatsSummaries" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LinearStatsSummaries_type > r (
            LinearStatsSummaries_traits::create (i, f, this));

          if (!this->LinearStatsSummaries_)
          {
            this->LinearStatsSummaries_.set (::std::move (r));
            continue;
          }
        }

        // AngularStatsSummaries
        //
        if (n.name () == L"AngularStatsSummaries" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AngularStatsSummaries_type > r (
            AngularStatsSummaries_traits::create (i, f, this));

          if (!this->AngularStatsSummaries_)
          {
            this->AngularStatsSummaries_.set (::std::move (r));
            continue;
          }
        }

        // AreaStatsSummaries
        //
        if (n.name () == L"AreaStatsSummaries" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AreaStatsSummaries_type > r (
            AreaStatsSummaries_traits::create (i, f, this));

          if (!this->AreaStatsSummaries_)
          {
            this->AreaStatsSummaries_.set (::std::move (r));
            continue;
          }
        }

        // ForceStatsSummaries
        //
        if (n.name () == L"ForceStatsSummaries" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ForceStatsSummaries_type > r (
            ForceStatsSummaries_traits::create (i, f, this));

          if (!this->ForceStatsSummaries_)
          {
            this->ForceStatsSummaries_.set (::std::move (r));
            continue;
          }
        }

        // MassStatsSummaries
        //
        if (n.name () == L"MassStatsSummaries" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MassStatsSummaries_type > r (
            MassStatsSummaries_traits::create (i, f, this));

          if (!this->MassStatsSummaries_)
          {
            this->MassStatsSummaries_.set (::std::move (r));
            continue;
          }
        }

        // PressureStatsSummaries
        //
        if (n.name () == L"PressureStatsSummaries" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PressureStatsSummaries_type > r (
            PressureStatsSummaries_traits::create (i, f, this));

          if (!this->PressureStatsSummaries_)
          {
            this->PressureStatsSummaries_.set (::std::move (r));
            continue;
          }
        }

        // SpeedStatsSummaries
        //
        if (n.name () == L"SpeedStatsSummaries" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SpeedStatsSummaries_type > r (
            SpeedStatsSummaries_traits::create (i, f, this));

          if (!this->SpeedStatsSummaries_)
          {
            this->SpeedStatsSummaries_.set (::std::move (r));
            continue;
          }
        }

        // TemperatureStatsSummaries
        //
        if (n.name () == L"TemperatureStatsSummaries" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TemperatureStatsSummaries_type > r (
            TemperatureStatsSummaries_traits::create (i, f, this));

          if (!this->TemperatureStatsSummaries_)
          {
            this->TemperatureStatsSummaries_.set (::std::move (r));
            continue;
          }
        }

        // TimeStatsSummaries
        //
        if (n.name () == L"TimeStatsSummaries" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TimeStatsSummaries_type > r (
            TimeStatsSummaries_traits::create (i, f, this));

          if (!this->TimeStatsSummaries_)
          {
            this->TimeStatsSummaries_.set (::std::move (r));
            continue;
          }
        }

        // UserDefinedUnitStatsSummaries
        //
        if (n.name () == L"UserDefinedUnitStatsSummaries" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDefinedUnitStatsSummaries_type > r (
            UserDefinedUnitStatsSummaries_traits::create (i, f, this));

          if (!this->UserDefinedUnitStatsSummaries_)
          {
            this->UserDefinedUnitStatsSummaries_.set (::std::move (r));
            continue;
          }
        }

        // StatsSummaries
        //
        if (n.name () == L"StatsSummaries" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StatsSummaries_type > r (
            StatsSummaries_traits::create (i, f, this));

          if (!this->StatsSummaries_)
          {
            this->StatsSummaries_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Status_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Status",
          L"http://qifstandards.org/xsd/qif3");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    StatisticalStudyResultsBaseType& StatisticalStudyResultsBaseType::
    operator= (const StatisticalStudyResultsBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ThisStatisticalStudyResultsInstanceQPId_ = x.ThisStatisticalStudyResultsInstanceQPId_;
        this->Attributes_ = x.Attributes_;
        this->Status_ = x.Status_;
        this->SoftwareId_ = x.SoftwareId_;
        this->StandardId_ = x.StandardId_;
        this->StudyIssues_ = x.StudyIssues_;
        this->InspectionTraceability_ = x.InspectionTraceability_;
        this->Name_ = x.Name_;
        this->Description_ = x.Description_;
        this->StudyId_ = x.StudyId_;
        this->ResultsIds_ = x.ResultsIds_;
        this->ResultsQPIds_ = x.ResultsQPIds_;
        this->ResultsFiles_ = x.ResultsFiles_;
        this->AverageFeatures_ = x.AverageFeatures_;
        this->CharacteristicsStats_ = x.CharacteristicsStats_;
        this->LinearStatsSummaries_ = x.LinearStatsSummaries_;
        this->AngularStatsSummaries_ = x.AngularStatsSummaries_;
        this->AreaStatsSummaries_ = x.AreaStatsSummaries_;
        this->ForceStatsSummaries_ = x.ForceStatsSummaries_;
        this->MassStatsSummaries_ = x.MassStatsSummaries_;
        this->PressureStatsSummaries_ = x.PressureStatsSummaries_;
        this->SpeedStatsSummaries_ = x.SpeedStatsSummaries_;
        this->TemperatureStatsSummaries_ = x.TemperatureStatsSummaries_;
        this->TimeStatsSummaries_ = x.TimeStatsSummaries_;
        this->UserDefinedUnitStatsSummaries_ = x.UserDefinedUnitStatsSummaries_;
        this->StatsSummaries_ = x.StatsSummaries_;
        this->id_ = x.id_;
      }

      return *this;
    }

    StatisticalStudyResultsBaseType::
    ~StatisticalStudyResultsBaseType ()
    {
    }

    // LinearityStudyResultsType
    //

    LinearityStudyResultsType::
    LinearityStudyResultsType ()
    : ::xsd::qif30::StatisticalStudyResultsBaseType (),
      SampleSize_ (this),
      MeasurementDeviceIds_ (this),
      GoodnessOfFit_ (this),
      LinearAbsoluteLinearity_ (this),
      AngularAbsoluteLinearity_ (this),
      AreaAbsoluteLinearity_ (this),
      ForceAbsoluteLinearity_ (this),
      MassAbsoluteLinearity_ (this),
      PressureAbsoluteLinearity_ (this),
      SpeedAbsoluteLinearity_ (this),
      TemperatureAbsoluteLinearity_ (this),
      TimeAbsoluteLinearity_ (this),
      UserDefinedUnitAbsoluteLinearity_ (this),
      RelativeLinearity_ (this)
    {
    }

    LinearityStudyResultsType::
    LinearityStudyResultsType (const Status_type& Status,
                               const id_type& id,
                               const SampleSize_type& SampleSize)
    : ::xsd::qif30::StatisticalStudyResultsBaseType (Status,
                                                     id),
      SampleSize_ (SampleSize, this),
      MeasurementDeviceIds_ (this),
      GoodnessOfFit_ (this),
      LinearAbsoluteLinearity_ (this),
      AngularAbsoluteLinearity_ (this),
      AreaAbsoluteLinearity_ (this),
      ForceAbsoluteLinearity_ (this),
      MassAbsoluteLinearity_ (this),
      PressureAbsoluteLinearity_ (this),
      SpeedAbsoluteLinearity_ (this),
      TemperatureAbsoluteLinearity_ (this),
      TimeAbsoluteLinearity_ (this),
      UserDefinedUnitAbsoluteLinearity_ (this),
      RelativeLinearity_ (this)
    {
    }

    LinearityStudyResultsType::
    LinearityStudyResultsType (::std::unique_ptr< Status_type > Status,
                               const id_type& id,
                               const SampleSize_type& SampleSize)
    : ::xsd::qif30::StatisticalStudyResultsBaseType (std::move (Status),
                                                     id),
      SampleSize_ (SampleSize, this),
      MeasurementDeviceIds_ (this),
      GoodnessOfFit_ (this),
      LinearAbsoluteLinearity_ (this),
      AngularAbsoluteLinearity_ (this),
      AreaAbsoluteLinearity_ (this),
      ForceAbsoluteLinearity_ (this),
      MassAbsoluteLinearity_ (this),
      PressureAbsoluteLinearity_ (this),
      SpeedAbsoluteLinearity_ (this),
      TemperatureAbsoluteLinearity_ (this),
      TimeAbsoluteLinearity_ (this),
      UserDefinedUnitAbsoluteLinearity_ (this),
      RelativeLinearity_ (this)
    {
    }

    LinearityStudyResultsType::
    LinearityStudyResultsType (const LinearityStudyResultsType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::StatisticalStudyResultsBaseType (x, f, c),
      SampleSize_ (x.SampleSize_, f, this),
      MeasurementDeviceIds_ (x.MeasurementDeviceIds_, f, this),
      GoodnessOfFit_ (x.GoodnessOfFit_, f, this),
      LinearAbsoluteLinearity_ (x.LinearAbsoluteLinearity_, f, this),
      AngularAbsoluteLinearity_ (x.AngularAbsoluteLinearity_, f, this),
      AreaAbsoluteLinearity_ (x.AreaAbsoluteLinearity_, f, this),
      ForceAbsoluteLinearity_ (x.ForceAbsoluteLinearity_, f, this),
      MassAbsoluteLinearity_ (x.MassAbsoluteLinearity_, f, this),
      PressureAbsoluteLinearity_ (x.PressureAbsoluteLinearity_, f, this),
      SpeedAbsoluteLinearity_ (x.SpeedAbsoluteLinearity_, f, this),
      TemperatureAbsoluteLinearity_ (x.TemperatureAbsoluteLinearity_, f, this),
      TimeAbsoluteLinearity_ (x.TimeAbsoluteLinearity_, f, this),
      UserDefinedUnitAbsoluteLinearity_ (x.UserDefinedUnitAbsoluteLinearity_, f, this),
      RelativeLinearity_ (x.RelativeLinearity_, f, this)
    {
    }

    LinearityStudyResultsType::
    LinearityStudyResultsType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::StatisticalStudyResultsBaseType (e, f | ::xml_schema::flags::base, c),
      SampleSize_ (this),
      MeasurementDeviceIds_ (this),
      GoodnessOfFit_ (this),
      LinearAbsoluteLinearity_ (this),
      AngularAbsoluteLinearity_ (this),
      AreaAbsoluteLinearity_ (this),
      ForceAbsoluteLinearity_ (this),
      MassAbsoluteLinearity_ (this),
      PressureAbsoluteLinearity_ (this),
      SpeedAbsoluteLinearity_ (this),
      TemperatureAbsoluteLinearity_ (this),
      TimeAbsoluteLinearity_ (this),
      UserDefinedUnitAbsoluteLinearity_ (this),
      RelativeLinearity_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void LinearityStudyResultsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatisticalStudyResultsBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SampleSize
        //
        if (n.name () == L"SampleSize" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!SampleSize_.present ())
          {
            this->SampleSize_.set (SampleSize_traits::create (i, f, this));
            continue;
          }
        }

        // MeasurementDeviceIds
        //
        if (n.name () == L"MeasurementDeviceIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeasurementDeviceIds_type > r (
            MeasurementDeviceIds_traits::create (i, f, this));

          if (!this->MeasurementDeviceIds_)
          {
            this->MeasurementDeviceIds_.set (::std::move (r));
            continue;
          }
        }

        // GoodnessOfFit
        //
        if (n.name () == L"GoodnessOfFit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< GoodnessOfFit_type > r (
            GoodnessOfFit_traits::create (i, f, this));

          if (!this->GoodnessOfFit_)
          {
            this->GoodnessOfFit_.set (::std::move (r));
            continue;
          }
        }

        // LinearAbsoluteLinearity
        //
        if (n.name () == L"LinearAbsoluteLinearity" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LinearAbsoluteLinearity_type > r (
            LinearAbsoluteLinearity_traits::create (i, f, this));

          if (!this->LinearAbsoluteLinearity_)
          {
            this->LinearAbsoluteLinearity_.set (::std::move (r));
            continue;
          }
        }

        // AngularAbsoluteLinearity
        //
        if (n.name () == L"AngularAbsoluteLinearity" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AngularAbsoluteLinearity_type > r (
            AngularAbsoluteLinearity_traits::create (i, f, this));

          if (!this->AngularAbsoluteLinearity_)
          {
            this->AngularAbsoluteLinearity_.set (::std::move (r));
            continue;
          }
        }

        // AreaAbsoluteLinearity
        //
        if (n.name () == L"AreaAbsoluteLinearity" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AreaAbsoluteLinearity_type > r (
            AreaAbsoluteLinearity_traits::create (i, f, this));

          if (!this->AreaAbsoluteLinearity_)
          {
            this->AreaAbsoluteLinearity_.set (::std::move (r));
            continue;
          }
        }

        // ForceAbsoluteLinearity
        //
        if (n.name () == L"ForceAbsoluteLinearity" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ForceAbsoluteLinearity_type > r (
            ForceAbsoluteLinearity_traits::create (i, f, this));

          if (!this->ForceAbsoluteLinearity_)
          {
            this->ForceAbsoluteLinearity_.set (::std::move (r));
            continue;
          }
        }

        // MassAbsoluteLinearity
        //
        if (n.name () == L"MassAbsoluteLinearity" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MassAbsoluteLinearity_type > r (
            MassAbsoluteLinearity_traits::create (i, f, this));

          if (!this->MassAbsoluteLinearity_)
          {
            this->MassAbsoluteLinearity_.set (::std::move (r));
            continue;
          }
        }

        // PressureAbsoluteLinearity
        //
        if (n.name () == L"PressureAbsoluteLinearity" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PressureAbsoluteLinearity_type > r (
            PressureAbsoluteLinearity_traits::create (i, f, this));

          if (!this->PressureAbsoluteLinearity_)
          {
            this->PressureAbsoluteLinearity_.set (::std::move (r));
            continue;
          }
        }

        // SpeedAbsoluteLinearity
        //
        if (n.name () == L"SpeedAbsoluteLinearity" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SpeedAbsoluteLinearity_type > r (
            SpeedAbsoluteLinearity_traits::create (i, f, this));

          if (!this->SpeedAbsoluteLinearity_)
          {
            this->SpeedAbsoluteLinearity_.set (::std::move (r));
            continue;
          }
        }

        // TemperatureAbsoluteLinearity
        //
        if (n.name () == L"TemperatureAbsoluteLinearity" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TemperatureAbsoluteLinearity_type > r (
            TemperatureAbsoluteLinearity_traits::create (i, f, this));

          if (!this->TemperatureAbsoluteLinearity_)
          {
            this->TemperatureAbsoluteLinearity_.set (::std::move (r));
            continue;
          }
        }

        // TimeAbsoluteLinearity
        //
        if (n.name () == L"TimeAbsoluteLinearity" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TimeAbsoluteLinearity_type > r (
            TimeAbsoluteLinearity_traits::create (i, f, this));

          if (!this->TimeAbsoluteLinearity_)
          {
            this->TimeAbsoluteLinearity_.set (::std::move (r));
            continue;
          }
        }

        // UserDefinedUnitAbsoluteLinearity
        //
        if (n.name () == L"UserDefinedUnitAbsoluteLinearity" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDefinedUnitAbsoluteLinearity_type > r (
            UserDefinedUnitAbsoluteLinearity_traits::create (i, f, this));

          if (!this->UserDefinedUnitAbsoluteLinearity_)
          {
            this->UserDefinedUnitAbsoluteLinearity_.set (::std::move (r));
            continue;
          }
        }

        // RelativeLinearity
        //
        if (n.name () == L"RelativeLinearity" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RelativeLinearity_type > r (
            RelativeLinearity_traits::create (i, f, this));

          if (!this->RelativeLinearity_)
          {
            this->RelativeLinearity_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SampleSize_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SampleSize",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    LinearityStudyResultsType* LinearityStudyResultsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LinearityStudyResultsType (*this, f, c);
    }

    LinearityStudyResultsType& LinearityStudyResultsType::
    operator= (const LinearityStudyResultsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatisticalStudyResultsBaseType& > (*this) = x;
        this->SampleSize_ = x.SampleSize_;
        this->MeasurementDeviceIds_ = x.MeasurementDeviceIds_;
        this->GoodnessOfFit_ = x.GoodnessOfFit_;
        this->LinearAbsoluteLinearity_ = x.LinearAbsoluteLinearity_;
        this->AngularAbsoluteLinearity_ = x.AngularAbsoluteLinearity_;
        this->AreaAbsoluteLinearity_ = x.AreaAbsoluteLinearity_;
        this->ForceAbsoluteLinearity_ = x.ForceAbsoluteLinearity_;
        this->MassAbsoluteLinearity_ = x.MassAbsoluteLinearity_;
        this->PressureAbsoluteLinearity_ = x.PressureAbsoluteLinearity_;
        this->SpeedAbsoluteLinearity_ = x.SpeedAbsoluteLinearity_;
        this->TemperatureAbsoluteLinearity_ = x.TemperatureAbsoluteLinearity_;
        this->TimeAbsoluteLinearity_ = x.TimeAbsoluteLinearity_;
        this->UserDefinedUnitAbsoluteLinearity_ = x.UserDefinedUnitAbsoluteLinearity_;
        this->RelativeLinearity_ = x.RelativeLinearity_;
      }

      return *this;
    }

    LinearityStudyResultsType::
    ~LinearityStudyResultsType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, LinearityStudyResultsType >
    _xsd_LinearityStudyResultsType_type_factory_init (
      L"LinearityStudyResultsType",
      L"http://qifstandards.org/xsd/qif3");

    // StabilityStudyResultsType
    //

    StabilityStudyResultsType::
    StabilityStudyResultsType ()
    : ::xsd::qif30::StatisticalStudyResultsBaseType (),
      SampleSize_ (this),
      MeasurementDeviceIds_ (this)
    {
    }

    StabilityStudyResultsType::
    StabilityStudyResultsType (const Status_type& Status,
                               const id_type& id,
                               const SampleSize_type& SampleSize)
    : ::xsd::qif30::StatisticalStudyResultsBaseType (Status,
                                                     id),
      SampleSize_ (SampleSize, this),
      MeasurementDeviceIds_ (this)
    {
    }

    StabilityStudyResultsType::
    StabilityStudyResultsType (::std::unique_ptr< Status_type > Status,
                               const id_type& id,
                               const SampleSize_type& SampleSize)
    : ::xsd::qif30::StatisticalStudyResultsBaseType (std::move (Status),
                                                     id),
      SampleSize_ (SampleSize, this),
      MeasurementDeviceIds_ (this)
    {
    }

    StabilityStudyResultsType::
    StabilityStudyResultsType (const StabilityStudyResultsType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::StatisticalStudyResultsBaseType (x, f, c),
      SampleSize_ (x.SampleSize_, f, this),
      MeasurementDeviceIds_ (x.MeasurementDeviceIds_, f, this)
    {
    }

    StabilityStudyResultsType::
    StabilityStudyResultsType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::StatisticalStudyResultsBaseType (e, f | ::xml_schema::flags::base, c),
      SampleSize_ (this),
      MeasurementDeviceIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void StabilityStudyResultsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatisticalStudyResultsBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SampleSize
        //
        if (n.name () == L"SampleSize" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!SampleSize_.present ())
          {
            this->SampleSize_.set (SampleSize_traits::create (i, f, this));
            continue;
          }
        }

        // MeasurementDeviceIds
        //
        if (n.name () == L"MeasurementDeviceIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeasurementDeviceIds_type > r (
            MeasurementDeviceIds_traits::create (i, f, this));

          if (!this->MeasurementDeviceIds_)
          {
            this->MeasurementDeviceIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SampleSize_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SampleSize",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    StabilityStudyResultsType* StabilityStudyResultsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StabilityStudyResultsType (*this, f, c);
    }

    StabilityStudyResultsType& StabilityStudyResultsType::
    operator= (const StabilityStudyResultsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatisticalStudyResultsBaseType& > (*this) = x;
        this->SampleSize_ = x.SampleSize_;
        this->MeasurementDeviceIds_ = x.MeasurementDeviceIds_;
      }

      return *this;
    }

    StabilityStudyResultsType::
    ~StabilityStudyResultsType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, StabilityStudyResultsType >
    _xsd_StabilityStudyResultsType_type_factory_init (
      L"StabilityStudyResultsType",
      L"http://qifstandards.org/xsd/qif3");

    // BiasStudyResultsType
    //

    BiasStudyResultsType::
    BiasStudyResultsType ()
    : ::xsd::qif30::StatisticalStudyResultsBaseType (),
      SampleSize_ (this),
      MeasurementDeviceIds_ (this)
    {
    }

    BiasStudyResultsType::
    BiasStudyResultsType (const Status_type& Status,
                          const id_type& id,
                          const SampleSize_type& SampleSize)
    : ::xsd::qif30::StatisticalStudyResultsBaseType (Status,
                                                     id),
      SampleSize_ (SampleSize, this),
      MeasurementDeviceIds_ (this)
    {
    }

    BiasStudyResultsType::
    BiasStudyResultsType (::std::unique_ptr< Status_type > Status,
                          const id_type& id,
                          const SampleSize_type& SampleSize)
    : ::xsd::qif30::StatisticalStudyResultsBaseType (std::move (Status),
                                                     id),
      SampleSize_ (SampleSize, this),
      MeasurementDeviceIds_ (this)
    {
    }

    BiasStudyResultsType::
    BiasStudyResultsType (const BiasStudyResultsType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::StatisticalStudyResultsBaseType (x, f, c),
      SampleSize_ (x.SampleSize_, f, this),
      MeasurementDeviceIds_ (x.MeasurementDeviceIds_, f, this)
    {
    }

    BiasStudyResultsType::
    BiasStudyResultsType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::StatisticalStudyResultsBaseType (e, f | ::xml_schema::flags::base, c),
      SampleSize_ (this),
      MeasurementDeviceIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void BiasStudyResultsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatisticalStudyResultsBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SampleSize
        //
        if (n.name () == L"SampleSize" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!SampleSize_.present ())
          {
            this->SampleSize_.set (SampleSize_traits::create (i, f, this));
            continue;
          }
        }

        // MeasurementDeviceIds
        //
        if (n.name () == L"MeasurementDeviceIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeasurementDeviceIds_type > r (
            MeasurementDeviceIds_traits::create (i, f, this));

          if (!this->MeasurementDeviceIds_)
          {
            this->MeasurementDeviceIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SampleSize_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SampleSize",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    BiasStudyResultsType* BiasStudyResultsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BiasStudyResultsType (*this, f, c);
    }

    BiasStudyResultsType& BiasStudyResultsType::
    operator= (const BiasStudyResultsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatisticalStudyResultsBaseType& > (*this) = x;
        this->SampleSize_ = x.SampleSize_;
        this->MeasurementDeviceIds_ = x.MeasurementDeviceIds_;
      }

      return *this;
    }

    BiasStudyResultsType::
    ~BiasStudyResultsType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, BiasStudyResultsType >
    _xsd_BiasStudyResultsType_type_factory_init (
      L"BiasStudyResultsType",
      L"http://qifstandards.org/xsd/qif3");

    // AbsoluteMeasurementsByUnitType
    //

    AbsoluteMeasurementsByUnitType::
    AbsoluteMeasurementsByUnitType ()
    : ::xml_schema::type (),
      LinearMeasurement_ (this),
      AngularMeasurement_ (this),
      AreaMeasurement_ (this),
      ForceMeasurement_ (this),
      MassMeasurement_ (this),
      PressureMeasurement_ (this),
      SpeedMeasurement_ (this),
      TemperatureMeasurement_ (this),
      TimeMeasurement_ (this),
      UserDefinedUnitMeasurement_ (this),
      n_ (this)
    {
    }

    AbsoluteMeasurementsByUnitType::
    AbsoluteMeasurementsByUnitType (const n_type& n)
    : ::xml_schema::type (),
      LinearMeasurement_ (this),
      AngularMeasurement_ (this),
      AreaMeasurement_ (this),
      ForceMeasurement_ (this),
      MassMeasurement_ (this),
      PressureMeasurement_ (this),
      SpeedMeasurement_ (this),
      TemperatureMeasurement_ (this),
      TimeMeasurement_ (this),
      UserDefinedUnitMeasurement_ (this),
      n_ (n, this)
    {
    }

    AbsoluteMeasurementsByUnitType::
    AbsoluteMeasurementsByUnitType (const AbsoluteMeasurementsByUnitType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      LinearMeasurement_ (x.LinearMeasurement_, f, this),
      AngularMeasurement_ (x.AngularMeasurement_, f, this),
      AreaMeasurement_ (x.AreaMeasurement_, f, this),
      ForceMeasurement_ (x.ForceMeasurement_, f, this),
      MassMeasurement_ (x.MassMeasurement_, f, this),
      PressureMeasurement_ (x.PressureMeasurement_, f, this),
      SpeedMeasurement_ (x.SpeedMeasurement_, f, this),
      TemperatureMeasurement_ (x.TemperatureMeasurement_, f, this),
      TimeMeasurement_ (x.TimeMeasurement_, f, this),
      UserDefinedUnitMeasurement_ (x.UserDefinedUnitMeasurement_, f, this),
      n_ (x.n_, f, this)
    {
    }

    AbsoluteMeasurementsByUnitType::
    AbsoluteMeasurementsByUnitType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      LinearMeasurement_ (this),
      AngularMeasurement_ (this),
      AreaMeasurement_ (this),
      ForceMeasurement_ (this),
      MassMeasurement_ (this),
      PressureMeasurement_ (this),
      SpeedMeasurement_ (this),
      TemperatureMeasurement_ (this),
      TimeMeasurement_ (this),
      UserDefinedUnitMeasurement_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void AbsoluteMeasurementsByUnitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // LinearMeasurement
        //
        if (n.name () == L"LinearMeasurement" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LinearMeasurement_type > r (
            LinearMeasurement_traits::create (i, f, this));

          if (!this->LinearMeasurement_)
          {
            this->LinearMeasurement_.set (::std::move (r));
            continue;
          }
        }

        // AngularMeasurement
        //
        if (n.name () == L"AngularMeasurement" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AngularMeasurement_type > r (
            AngularMeasurement_traits::create (i, f, this));

          if (!this->AngularMeasurement_)
          {
            this->AngularMeasurement_.set (::std::move (r));
            continue;
          }
        }

        // AreaMeasurement
        //
        if (n.name () == L"AreaMeasurement" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AreaMeasurement_type > r (
            AreaMeasurement_traits::create (i, f, this));

          if (!this->AreaMeasurement_)
          {
            this->AreaMeasurement_.set (::std::move (r));
            continue;
          }
        }

        // ForceMeasurement
        //
        if (n.name () == L"ForceMeasurement" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ForceMeasurement_type > r (
            ForceMeasurement_traits::create (i, f, this));

          if (!this->ForceMeasurement_)
          {
            this->ForceMeasurement_.set (::std::move (r));
            continue;
          }
        }

        // MassMeasurement
        //
        if (n.name () == L"MassMeasurement" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MassMeasurement_type > r (
            MassMeasurement_traits::create (i, f, this));

          if (!this->MassMeasurement_)
          {
            this->MassMeasurement_.set (::std::move (r));
            continue;
          }
        }

        // PressureMeasurement
        //
        if (n.name () == L"PressureMeasurement" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PressureMeasurement_type > r (
            PressureMeasurement_traits::create (i, f, this));

          if (!this->PressureMeasurement_)
          {
            this->PressureMeasurement_.set (::std::move (r));
            continue;
          }
        }

        // SpeedMeasurement
        //
        if (n.name () == L"SpeedMeasurement" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SpeedMeasurement_type > r (
            SpeedMeasurement_traits::create (i, f, this));

          if (!this->SpeedMeasurement_)
          {
            this->SpeedMeasurement_.set (::std::move (r));
            continue;
          }
        }

        // TemperatureMeasurement
        //
        if (n.name () == L"TemperatureMeasurement" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TemperatureMeasurement_type > r (
            TemperatureMeasurement_traits::create (i, f, this));

          if (!this->TemperatureMeasurement_)
          {
            this->TemperatureMeasurement_.set (::std::move (r));
            continue;
          }
        }

        // TimeMeasurement
        //
        if (n.name () == L"TimeMeasurement" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TimeMeasurement_type > r (
            TimeMeasurement_traits::create (i, f, this));

          if (!this->TimeMeasurement_)
          {
            this->TimeMeasurement_.set (::std::move (r));
            continue;
          }
        }

        // UserDefinedUnitMeasurement
        //
        if (n.name () == L"UserDefinedUnitMeasurement" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDefinedUnitMeasurement_type > r (
            UserDefinedUnitMeasurement_traits::create (i, f, this));

          this->UserDefinedUnitMeasurement_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    AbsoluteMeasurementsByUnitType* AbsoluteMeasurementsByUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AbsoluteMeasurementsByUnitType (*this, f, c);
    }

    AbsoluteMeasurementsByUnitType& AbsoluteMeasurementsByUnitType::
    operator= (const AbsoluteMeasurementsByUnitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->LinearMeasurement_ = x.LinearMeasurement_;
        this->AngularMeasurement_ = x.AngularMeasurement_;
        this->AreaMeasurement_ = x.AreaMeasurement_;
        this->ForceMeasurement_ = x.ForceMeasurement_;
        this->MassMeasurement_ = x.MassMeasurement_;
        this->PressureMeasurement_ = x.PressureMeasurement_;
        this->SpeedMeasurement_ = x.SpeedMeasurement_;
        this->TemperatureMeasurement_ = x.TemperatureMeasurement_;
        this->TimeMeasurement_ = x.TimeMeasurement_;
        this->UserDefinedUnitMeasurement_ = x.UserDefinedUnitMeasurement_;
        this->n_ = x.n_;
      }

      return *this;
    }

    AbsoluteMeasurementsByUnitType::
    ~AbsoluteMeasurementsByUnitType ()
    {
    }

    // FirstArticleStudyResultsType
    //

    FirstArticleStudyResultsType::
    FirstArticleStudyResultsType ()
    : ::xsd::qif30::StatisticalStudyResultsBaseType (),
      InSpecRatio_ (this),
      AbsoluteMaximums_ (this),
      RelativeMaximum_ (this)
    {
    }

    FirstArticleStudyResultsType::
    FirstArticleStudyResultsType (const Status_type& Status,
                                  const id_type& id)
    : ::xsd::qif30::StatisticalStudyResultsBaseType (Status,
                                                     id),
      InSpecRatio_ (this),
      AbsoluteMaximums_ (this),
      RelativeMaximum_ (this)
    {
    }

    FirstArticleStudyResultsType::
    FirstArticleStudyResultsType (::std::unique_ptr< Status_type > Status,
                                  const id_type& id)
    : ::xsd::qif30::StatisticalStudyResultsBaseType (std::move (Status),
                                                     id),
      InSpecRatio_ (this),
      AbsoluteMaximums_ (this),
      RelativeMaximum_ (this)
    {
    }

    FirstArticleStudyResultsType::
    FirstArticleStudyResultsType (const FirstArticleStudyResultsType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::StatisticalStudyResultsBaseType (x, f, c),
      InSpecRatio_ (x.InSpecRatio_, f, this),
      AbsoluteMaximums_ (x.AbsoluteMaximums_, f, this),
      RelativeMaximum_ (x.RelativeMaximum_, f, this)
    {
    }

    FirstArticleStudyResultsType::
    FirstArticleStudyResultsType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::StatisticalStudyResultsBaseType (e, f | ::xml_schema::flags::base, c),
      InSpecRatio_ (this),
      AbsoluteMaximums_ (this),
      RelativeMaximum_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FirstArticleStudyResultsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatisticalStudyResultsBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // InSpecRatio
        //
        if (n.name () == L"InSpecRatio" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->InSpecRatio_)
          {
            this->InSpecRatio_.set (InSpecRatio_traits::create (i, f, this));
            continue;
          }
        }

        // AbsoluteMaximums
        //
        if (n.name () == L"AbsoluteMaximums" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AbsoluteMaximums_type > r (
            AbsoluteMaximums_traits::create (i, f, this));

          if (!this->AbsoluteMaximums_)
          {
            this->AbsoluteMaximums_.set (::std::move (r));
            continue;
          }
        }

        // RelativeMaximum
        //
        if (n.name () == L"RelativeMaximum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RelativeMaximum_type > r (
            RelativeMaximum_traits::create (i, f, this));

          if (!this->RelativeMaximum_)
          {
            this->RelativeMaximum_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    FirstArticleStudyResultsType* FirstArticleStudyResultsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FirstArticleStudyResultsType (*this, f, c);
    }

    FirstArticleStudyResultsType& FirstArticleStudyResultsType::
    operator= (const FirstArticleStudyResultsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatisticalStudyResultsBaseType& > (*this) = x;
        this->InSpecRatio_ = x.InSpecRatio_;
        this->AbsoluteMaximums_ = x.AbsoluteMaximums_;
        this->RelativeMaximum_ = x.RelativeMaximum_;
      }

      return *this;
    }

    FirstArticleStudyResultsType::
    ~FirstArticleStudyResultsType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, FirstArticleStudyResultsType >
    _xsd_FirstArticleStudyResultsType_type_factory_init (
      L"FirstArticleStudyResultsType",
      L"http://qifstandards.org/xsd/qif3");

    // ProcessDifferenceStudyResultsType
    //

    ProcessDifferenceStudyResultsType::
    ProcessDifferenceStudyResultsType ()
    : ::xsd::qif30::StatisticalStudyResultsBaseType (),
      NumberOfSamples_ (this),
      SubgroupSize_ (this),
      ManufacturingProcessId_ (this),
      AbsoluteDifferences_ (this),
      RelativeDifference_ (this)
    {
    }

    ProcessDifferenceStudyResultsType::
    ProcessDifferenceStudyResultsType (const Status_type& Status,
                                       const id_type& id,
                                       const NumberOfSamples_type& NumberOfSamples,
                                       const SubgroupSize_type& SubgroupSize)
    : ::xsd::qif30::StatisticalStudyResultsBaseType (Status,
                                                     id),
      NumberOfSamples_ (NumberOfSamples, this),
      SubgroupSize_ (SubgroupSize, this),
      ManufacturingProcessId_ (this),
      AbsoluteDifferences_ (this),
      RelativeDifference_ (this)
    {
    }

    ProcessDifferenceStudyResultsType::
    ProcessDifferenceStudyResultsType (::std::unique_ptr< Status_type > Status,
                                       const id_type& id,
                                       const NumberOfSamples_type& NumberOfSamples,
                                       const SubgroupSize_type& SubgroupSize)
    : ::xsd::qif30::StatisticalStudyResultsBaseType (std::move (Status),
                                                     id),
      NumberOfSamples_ (NumberOfSamples, this),
      SubgroupSize_ (SubgroupSize, this),
      ManufacturingProcessId_ (this),
      AbsoluteDifferences_ (this),
      RelativeDifference_ (this)
    {
    }

    ProcessDifferenceStudyResultsType::
    ProcessDifferenceStudyResultsType (const ProcessDifferenceStudyResultsType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::StatisticalStudyResultsBaseType (x, f, c),
      NumberOfSamples_ (x.NumberOfSamples_, f, this),
      SubgroupSize_ (x.SubgroupSize_, f, this),
      ManufacturingProcessId_ (x.ManufacturingProcessId_, f, this),
      AbsoluteDifferences_ (x.AbsoluteDifferences_, f, this),
      RelativeDifference_ (x.RelativeDifference_, f, this)
    {
    }

    ProcessDifferenceStudyResultsType::
    ProcessDifferenceStudyResultsType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::StatisticalStudyResultsBaseType (e, f | ::xml_schema::flags::base, c),
      NumberOfSamples_ (this),
      SubgroupSize_ (this),
      ManufacturingProcessId_ (this),
      AbsoluteDifferences_ (this),
      RelativeDifference_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ProcessDifferenceStudyResultsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatisticalStudyResultsBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // NumberOfSamples
        //
        if (n.name () == L"NumberOfSamples" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!NumberOfSamples_.present ())
          {
            this->NumberOfSamples_.set (NumberOfSamples_traits::create (i, f, this));
            continue;
          }
        }

        // SubgroupSize
        //
        if (n.name () == L"SubgroupSize" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!SubgroupSize_.present ())
          {
            this->SubgroupSize_.set (SubgroupSize_traits::create (i, f, this));
            continue;
          }
        }

        // ManufacturingProcessId
        //
        if (n.name () == L"ManufacturingProcessId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ManufacturingProcessId_type > r (
            ManufacturingProcessId_traits::create (i, f, this));

          if (!this->ManufacturingProcessId_)
          {
            this->ManufacturingProcessId_.set (::std::move (r));
            continue;
          }
        }

        // AbsoluteDifferences
        //
        if (n.name () == L"AbsoluteDifferences" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AbsoluteDifferences_type > r (
            AbsoluteDifferences_traits::create (i, f, this));

          if (!this->AbsoluteDifferences_)
          {
            this->AbsoluteDifferences_.set (::std::move (r));
            continue;
          }
        }

        // RelativeDifference
        //
        if (n.name () == L"RelativeDifference" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RelativeDifference_type > r (
            RelativeDifference_traits::create (i, f, this));

          if (!this->RelativeDifference_)
          {
            this->RelativeDifference_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!NumberOfSamples_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"NumberOfSamples",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!SubgroupSize_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SubgroupSize",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ProcessDifferenceStudyResultsType* ProcessDifferenceStudyResultsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ProcessDifferenceStudyResultsType (*this, f, c);
    }

    ProcessDifferenceStudyResultsType& ProcessDifferenceStudyResultsType::
    operator= (const ProcessDifferenceStudyResultsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatisticalStudyResultsBaseType& > (*this) = x;
        this->NumberOfSamples_ = x.NumberOfSamples_;
        this->SubgroupSize_ = x.SubgroupSize_;
        this->ManufacturingProcessId_ = x.ManufacturingProcessId_;
        this->AbsoluteDifferences_ = x.AbsoluteDifferences_;
        this->RelativeDifference_ = x.RelativeDifference_;
      }

      return *this;
    }

    ProcessDifferenceStudyResultsType::
    ~ProcessDifferenceStudyResultsType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ProcessDifferenceStudyResultsType >
    _xsd_ProcessDifferenceStudyResultsType_type_factory_init (
      L"ProcessDifferenceStudyResultsType",
      L"http://qifstandards.org/xsd/qif3");

    // MultipleProductInstanceStudyResultsBaseType
    //

    MultipleProductInstanceStudyResultsBaseType::
    MultipleProductInstanceStudyResultsBaseType ()
    : ::xsd::qif30::StatisticalStudyResultsBaseType (),
      NumberOfSamples_ (this),
      SubgroupSize_ (this)
    {
    }

    MultipleProductInstanceStudyResultsBaseType::
    MultipleProductInstanceStudyResultsBaseType (const Status_type& Status,
                                                 const id_type& id,
                                                 const NumberOfSamples_type& NumberOfSamples)
    : ::xsd::qif30::StatisticalStudyResultsBaseType (Status,
                                                     id),
      NumberOfSamples_ (NumberOfSamples, this),
      SubgroupSize_ (this)
    {
    }

    MultipleProductInstanceStudyResultsBaseType::
    MultipleProductInstanceStudyResultsBaseType (::std::unique_ptr< Status_type > Status,
                                                 const id_type& id,
                                                 const NumberOfSamples_type& NumberOfSamples)
    : ::xsd::qif30::StatisticalStudyResultsBaseType (std::move (Status),
                                                     id),
      NumberOfSamples_ (NumberOfSamples, this),
      SubgroupSize_ (this)
    {
    }

    MultipleProductInstanceStudyResultsBaseType::
    MultipleProductInstanceStudyResultsBaseType (const MultipleProductInstanceStudyResultsBaseType& x,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
    : ::xsd::qif30::StatisticalStudyResultsBaseType (x, f, c),
      NumberOfSamples_ (x.NumberOfSamples_, f, this),
      SubgroupSize_ (x.SubgroupSize_, f, this)
    {
    }

    MultipleProductInstanceStudyResultsBaseType::
    MultipleProductInstanceStudyResultsBaseType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
    : ::xsd::qif30::StatisticalStudyResultsBaseType (e, f | ::xml_schema::flags::base, c),
      NumberOfSamples_ (this),
      SubgroupSize_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void MultipleProductInstanceStudyResultsBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatisticalStudyResultsBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // NumberOfSamples
        //
        if (n.name () == L"NumberOfSamples" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!NumberOfSamples_.present ())
          {
            this->NumberOfSamples_.set (NumberOfSamples_traits::create (i, f, this));
            continue;
          }
        }

        // SubgroupSize
        //
        if (n.name () == L"SubgroupSize" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->SubgroupSize_)
          {
            this->SubgroupSize_.set (SubgroupSize_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!NumberOfSamples_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"NumberOfSamples",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    MultipleProductInstanceStudyResultsBaseType& MultipleProductInstanceStudyResultsBaseType::
    operator= (const MultipleProductInstanceStudyResultsBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatisticalStudyResultsBaseType& > (*this) = x;
        this->NumberOfSamples_ = x.NumberOfSamples_;
        this->SubgroupSize_ = x.SubgroupSize_;
      }

      return *this;
    }

    MultipleProductInstanceStudyResultsBaseType::
    ~MultipleProductInstanceStudyResultsBaseType ()
    {
    }

    // SimpleStudyResultsType
    //

    SimpleStudyResultsType::
    SimpleStudyResultsType ()
    : ::xsd::qif30::MultipleProductInstanceStudyResultsBaseType ()
    {
    }

    SimpleStudyResultsType::
    SimpleStudyResultsType (const Status_type& Status,
                            const id_type& id,
                            const NumberOfSamples_type& NumberOfSamples)
    : ::xsd::qif30::MultipleProductInstanceStudyResultsBaseType (Status,
                                                                 id,
                                                                 NumberOfSamples)
    {
    }

    SimpleStudyResultsType::
    SimpleStudyResultsType (::std::unique_ptr< Status_type > Status,
                            const id_type& id,
                            const NumberOfSamples_type& NumberOfSamples)
    : ::xsd::qif30::MultipleProductInstanceStudyResultsBaseType (std::move (Status),
                                                                 id,
                                                                 NumberOfSamples)
    {
    }

    SimpleStudyResultsType::
    SimpleStudyResultsType (const SimpleStudyResultsType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::MultipleProductInstanceStudyResultsBaseType (x, f, c)
    {
    }

    SimpleStudyResultsType::
    SimpleStudyResultsType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::MultipleProductInstanceStudyResultsBaseType (e, f, c)
    {
    }

    SimpleStudyResultsType* SimpleStudyResultsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SimpleStudyResultsType (*this, f, c);
    }

    SimpleStudyResultsType::
    ~SimpleStudyResultsType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SimpleStudyResultsType >
    _xsd_SimpleStudyResultsType_type_factory_init (
      L"SimpleStudyResultsType",
      L"http://qifstandards.org/xsd/qif3");

    // CapabilityStudyResultsType
    //

    CapabilityStudyResultsType::
    CapabilityStudyResultsType ()
    : ::xsd::qif30::MultipleProductInstanceStudyResultsBaseType ()
    {
    }

    CapabilityStudyResultsType::
    CapabilityStudyResultsType (const Status_type& Status,
                                const id_type& id,
                                const NumberOfSamples_type& NumberOfSamples)
    : ::xsd::qif30::MultipleProductInstanceStudyResultsBaseType (Status,
                                                                 id,
                                                                 NumberOfSamples)
    {
    }

    CapabilityStudyResultsType::
    CapabilityStudyResultsType (::std::unique_ptr< Status_type > Status,
                                const id_type& id,
                                const NumberOfSamples_type& NumberOfSamples)
    : ::xsd::qif30::MultipleProductInstanceStudyResultsBaseType (std::move (Status),
                                                                 id,
                                                                 NumberOfSamples)
    {
    }

    CapabilityStudyResultsType::
    CapabilityStudyResultsType (const CapabilityStudyResultsType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::MultipleProductInstanceStudyResultsBaseType (x, f, c)
    {
    }

    CapabilityStudyResultsType::
    CapabilityStudyResultsType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::MultipleProductInstanceStudyResultsBaseType (e, f, c)
    {
    }

    CapabilityStudyResultsType* CapabilityStudyResultsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CapabilityStudyResultsType (*this, f, c);
    }

    CapabilityStudyResultsType::
    ~CapabilityStudyResultsType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CapabilityStudyResultsType >
    _xsd_CapabilityStudyResultsType_type_factory_init (
      L"CapabilityStudyResultsType",
      L"http://qifstandards.org/xsd/qif3");

    // GageRandRStudyResultsType
    //

    GageRandRStudyResultsType::
    GageRandRStudyResultsType ()
    : ::xsd::qif30::StatisticalStudyResultsBaseType (),
      MeasurementDeviceIds_ (this),
      NumberOfAppraisers_ (this),
      NumberOfParts_ (this),
      NumberOfTrials_ (this)
    {
    }

    GageRandRStudyResultsType::
    GageRandRStudyResultsType (const Status_type& Status,
                               const id_type& id,
                               const NumberOfAppraisers_type& NumberOfAppraisers,
                               const NumberOfParts_type& NumberOfParts,
                               const NumberOfTrials_type& NumberOfTrials)
    : ::xsd::qif30::StatisticalStudyResultsBaseType (Status,
                                                     id),
      MeasurementDeviceIds_ (this),
      NumberOfAppraisers_ (NumberOfAppraisers, this),
      NumberOfParts_ (NumberOfParts, this),
      NumberOfTrials_ (NumberOfTrials, this)
    {
    }

    GageRandRStudyResultsType::
    GageRandRStudyResultsType (::std::unique_ptr< Status_type > Status,
                               const id_type& id,
                               const NumberOfAppraisers_type& NumberOfAppraisers,
                               const NumberOfParts_type& NumberOfParts,
                               const NumberOfTrials_type& NumberOfTrials)
    : ::xsd::qif30::StatisticalStudyResultsBaseType (std::move (Status),
                                                     id),
      MeasurementDeviceIds_ (this),
      NumberOfAppraisers_ (NumberOfAppraisers, this),
      NumberOfParts_ (NumberOfParts, this),
      NumberOfTrials_ (NumberOfTrials, this)
    {
    }

    GageRandRStudyResultsType::
    GageRandRStudyResultsType (const GageRandRStudyResultsType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::StatisticalStudyResultsBaseType (x, f, c),
      MeasurementDeviceIds_ (x.MeasurementDeviceIds_, f, this),
      NumberOfAppraisers_ (x.NumberOfAppraisers_, f, this),
      NumberOfParts_ (x.NumberOfParts_, f, this),
      NumberOfTrials_ (x.NumberOfTrials_, f, this)
    {
    }

    GageRandRStudyResultsType::
    GageRandRStudyResultsType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::StatisticalStudyResultsBaseType (e, f | ::xml_schema::flags::base, c),
      MeasurementDeviceIds_ (this),
      NumberOfAppraisers_ (this),
      NumberOfParts_ (this),
      NumberOfTrials_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void GageRandRStudyResultsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatisticalStudyResultsBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MeasurementDeviceIds
        //
        if (n.name () == L"MeasurementDeviceIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeasurementDeviceIds_type > r (
            MeasurementDeviceIds_traits::create (i, f, this));

          if (!this->MeasurementDeviceIds_)
          {
            this->MeasurementDeviceIds_.set (::std::move (r));
            continue;
          }
        }

        // NumberOfAppraisers
        //
        if (n.name () == L"NumberOfAppraisers" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!NumberOfAppraisers_.present ())
          {
            this->NumberOfAppraisers_.set (NumberOfAppraisers_traits::create (i, f, this));
            continue;
          }
        }

        // NumberOfParts
        //
        if (n.name () == L"NumberOfParts" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!NumberOfParts_.present ())
          {
            this->NumberOfParts_.set (NumberOfParts_traits::create (i, f, this));
            continue;
          }
        }

        // NumberOfTrials
        //
        if (n.name () == L"NumberOfTrials" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!NumberOfTrials_.present ())
          {
            this->NumberOfTrials_.set (NumberOfTrials_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!NumberOfAppraisers_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"NumberOfAppraisers",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!NumberOfParts_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"NumberOfParts",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!NumberOfTrials_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"NumberOfTrials",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    GageRandRStudyResultsType* GageRandRStudyResultsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class GageRandRStudyResultsType (*this, f, c);
    }

    GageRandRStudyResultsType& GageRandRStudyResultsType::
    operator= (const GageRandRStudyResultsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatisticalStudyResultsBaseType& > (*this) = x;
        this->MeasurementDeviceIds_ = x.MeasurementDeviceIds_;
        this->NumberOfAppraisers_ = x.NumberOfAppraisers_;
        this->NumberOfParts_ = x.NumberOfParts_;
        this->NumberOfTrials_ = x.NumberOfTrials_;
      }

      return *this;
    }

    GageRandRStudyResultsType::
    ~GageRandRStudyResultsType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, GageRandRStudyResultsType >
    _xsd_GageRandRStudyResultsType_type_factory_init (
      L"GageRandRStudyResultsType",
      L"http://qifstandards.org/xsd/qif3");

    // ProductionStudyResultsType
    //

    ProductionStudyResultsType::
    ProductionStudyResultsType ()
    : ::xsd::qif30::MultipleProductInstanceStudyResultsBaseType (),
      ControlIssueDetailsList_ (this)
    {
    }

    ProductionStudyResultsType::
    ProductionStudyResultsType (const Status_type& Status,
                                const id_type& id,
                                const NumberOfSamples_type& NumberOfSamples)
    : ::xsd::qif30::MultipleProductInstanceStudyResultsBaseType (Status,
                                                                 id,
                                                                 NumberOfSamples),
      ControlIssueDetailsList_ (this)
    {
    }

    ProductionStudyResultsType::
    ProductionStudyResultsType (::std::unique_ptr< Status_type > Status,
                                const id_type& id,
                                const NumberOfSamples_type& NumberOfSamples)
    : ::xsd::qif30::MultipleProductInstanceStudyResultsBaseType (std::move (Status),
                                                                 id,
                                                                 NumberOfSamples),
      ControlIssueDetailsList_ (this)
    {
    }

    ProductionStudyResultsType::
    ProductionStudyResultsType (const ProductionStudyResultsType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::MultipleProductInstanceStudyResultsBaseType (x, f, c),
      ControlIssueDetailsList_ (x.ControlIssueDetailsList_, f, this)
    {
    }

    ProductionStudyResultsType::
    ProductionStudyResultsType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::MultipleProductInstanceStudyResultsBaseType (e, f | ::xml_schema::flags::base, c),
      ControlIssueDetailsList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ProductionStudyResultsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::MultipleProductInstanceStudyResultsBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ControlIssueDetailsList
        //
        if (n.name () == L"ControlIssueDetailsList" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ControlIssueDetailsList_type > r (
            ControlIssueDetailsList_traits::create (i, f, this));

          this->ControlIssueDetailsList_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    ProductionStudyResultsType* ProductionStudyResultsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ProductionStudyResultsType (*this, f, c);
    }

    ProductionStudyResultsType& ProductionStudyResultsType::
    operator= (const ProductionStudyResultsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::MultipleProductInstanceStudyResultsBaseType& > (*this) = x;
        this->ControlIssueDetailsList_ = x.ControlIssueDetailsList_;
      }

      return *this;
    }

    ProductionStudyResultsType::
    ~ProductionStudyResultsType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ProductionStudyResultsType >
    _xsd_ProductionStudyResultsType_type_factory_init (
      L"ProductionStudyResultsType",
      L"http://qifstandards.org/xsd/qif3");

    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_FirstArticleStudyResults_element_factory_init (
      L"StatisticalStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      L"FirstArticleStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::FirstArticleStudyResultsType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_LinearityStudyResults_element_factory_init (
      L"StatisticalStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      L"LinearityStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::LinearityStudyResultsType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SimpleStudyResults_element_factory_init (
      L"StatisticalStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      L"SimpleStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SimpleStudyResultsType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_BiasStudyResults_element_factory_init (
      L"StatisticalStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      L"BiasStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::BiasStudyResultsType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_StabilityStudyResults_element_factory_init (
      L"StatisticalStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      L"StabilityStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::StabilityStudyResultsType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CapabilityStudyResults_element_factory_init (
      L"StatisticalStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      L"CapabilityStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CapabilityStudyResultsType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ProcessDifferenceStudyResults_element_factory_init (
      L"StatisticalStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      L"ProcessDifferenceStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ProcessDifferenceStudyResultsType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_GageRandRStudyResults_element_factory_init (
      L"StatisticalStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      L"GageRandRStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::GageRandRStudyResultsType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ProductionStudyResults_element_factory_init (
      L"StatisticalStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      L"ProductionStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ProductionStudyResultsType >);


    // StatisticalStudyPlansType
    //

    StatisticalStudyPlansType::
    StatisticalStudyPlansType ()
    : ::xml_schema::type (),
      StatisticalStudyPlan_ (this),
      n_ (this)
    {
    }

    StatisticalStudyPlansType::
    StatisticalStudyPlansType (const n_type& n)
    : ::xml_schema::type (),
      StatisticalStudyPlan_ (this),
      n_ (n, this)
    {
    }

    StatisticalStudyPlansType::
    StatisticalStudyPlansType (const StatisticalStudyPlansType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      StatisticalStudyPlan_ (x.StatisticalStudyPlan_, f, this),
      n_ (x.n_, f, this)
    {
    }

    StatisticalStudyPlansType::
    StatisticalStudyPlansType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      StatisticalStudyPlan_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void StatisticalStudyPlansType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // StatisticalStudyPlan
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"StatisticalStudyPlan",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< StatisticalStudyPlan_type > r (
              dynamic_cast< StatisticalStudyPlan_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->StatisticalStudyPlan_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    StatisticalStudyPlansType* StatisticalStudyPlansType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StatisticalStudyPlansType (*this, f, c);
    }

    StatisticalStudyPlansType& StatisticalStudyPlansType::
    operator= (const StatisticalStudyPlansType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->StatisticalStudyPlan_ = x.StatisticalStudyPlan_;
        this->n_ = x.n_;
      }

      return *this;
    }

    StatisticalStudyPlansType::
    ~StatisticalStudyPlansType ()
    {
    }

    // StatisticalStudiesResultsType
    //

    StatisticalStudiesResultsType::
    StatisticalStudiesResultsType ()
    : ::xml_schema::type (),
      StatisticalStudyResults_ (this),
      n_ (this)
    {
    }

    StatisticalStudiesResultsType::
    StatisticalStudiesResultsType (const n_type& n)
    : ::xml_schema::type (),
      StatisticalStudyResults_ (this),
      n_ (n, this)
    {
    }

    StatisticalStudiesResultsType::
    StatisticalStudiesResultsType (const StatisticalStudiesResultsType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      StatisticalStudyResults_ (x.StatisticalStudyResults_, f, this),
      n_ (x.n_, f, this)
    {
    }

    StatisticalStudiesResultsType::
    StatisticalStudiesResultsType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      StatisticalStudyResults_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void StatisticalStudiesResultsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // StatisticalStudyResults
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"StatisticalStudyResults",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< StatisticalStudyResults_type > r (
              dynamic_cast< StatisticalStudyResults_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->StatisticalStudyResults_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    StatisticalStudiesResultsType* StatisticalStudiesResultsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StatisticalStudiesResultsType (*this, f, c);
    }

    StatisticalStudiesResultsType& StatisticalStudiesResultsType::
    operator= (const StatisticalStudiesResultsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->StatisticalStudyResults_ = x.StatisticalStudyResults_;
        this->n_ = x.n_;
      }

      return *this;
    }

    StatisticalStudiesResultsType::
    ~StatisticalStudiesResultsType ()
    {
    }

    // CorrectiveActionPlanType
    //

    CorrectiveActionPlanType::
    CorrectiveActionPlanType ()
    : ::xml_schema::type (),
      Version_ (this),
      Attributes_ (this),
      AssignableCauses_ (this),
      CorrectiveActions_ (this),
      id_ (this)
    {
    }

    CorrectiveActionPlanType::
    CorrectiveActionPlanType (const AssignableCauses_type& AssignableCauses,
                              const CorrectiveActions_type& CorrectiveActions,
                              const id_type& id)
    : ::xml_schema::type (),
      Version_ (this),
      Attributes_ (this),
      AssignableCauses_ (AssignableCauses, this),
      CorrectiveActions_ (CorrectiveActions, this),
      id_ (id, this)
    {
    }

    CorrectiveActionPlanType::
    CorrectiveActionPlanType (::std::unique_ptr< AssignableCauses_type > AssignableCauses,
                              ::std::unique_ptr< CorrectiveActions_type > CorrectiveActions,
                              const id_type& id)
    : ::xml_schema::type (),
      Version_ (this),
      Attributes_ (this),
      AssignableCauses_ (std::move (AssignableCauses), this),
      CorrectiveActions_ (std::move (CorrectiveActions), this),
      id_ (id, this)
    {
    }

    CorrectiveActionPlanType::
    CorrectiveActionPlanType (const CorrectiveActionPlanType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Version_ (x.Version_, f, this),
      Attributes_ (x.Attributes_, f, this),
      AssignableCauses_ (x.AssignableCauses_, f, this),
      CorrectiveActions_ (x.CorrectiveActions_, f, this),
      id_ (x.id_, f, this)
    {
    }

    CorrectiveActionPlanType::
    CorrectiveActionPlanType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Version_ (this),
      Attributes_ (this),
      AssignableCauses_ (this),
      CorrectiveActions_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CorrectiveActionPlanType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Version
        //
        if (n.name () == L"Version" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Version_type > r (
            Version_traits::create (i, f, this));

          if (!this->Version_)
          {
            this->Version_.set (::std::move (r));
            continue;
          }
        }

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        // AssignableCauses
        //
        if (n.name () == L"AssignableCauses" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AssignableCauses_type > r (
            AssignableCauses_traits::create (i, f, this));

          if (!AssignableCauses_.present ())
          {
            this->AssignableCauses_.set (::std::move (r));
            continue;
          }
        }

        // CorrectiveActions
        //
        if (n.name () == L"CorrectiveActions" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CorrectiveActions_type > r (
            CorrectiveActions_traits::create (i, f, this));

          if (!CorrectiveActions_.present ())
          {
            this->CorrectiveActions_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!AssignableCauses_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"AssignableCauses",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!CorrectiveActions_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CorrectiveActions",
          L"http://qifstandards.org/xsd/qif3");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    CorrectiveActionPlanType* CorrectiveActionPlanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CorrectiveActionPlanType (*this, f, c);
    }

    CorrectiveActionPlanType& CorrectiveActionPlanType::
    operator= (const CorrectiveActionPlanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Version_ = x.Version_;
        this->Attributes_ = x.Attributes_;
        this->AssignableCauses_ = x.AssignableCauses_;
        this->CorrectiveActions_ = x.CorrectiveActions_;
        this->id_ = x.id_;
      }

      return *this;
    }

    CorrectiveActionPlanType::
    ~CorrectiveActionPlanType ()
    {
    }

    // CorrectiveActionPlansType
    //

    CorrectiveActionPlansType::
    CorrectiveActionPlansType ()
    : ::xml_schema::type (),
      CorrectiveActionPlan_ (this),
      n_ (this)
    {
    }

    CorrectiveActionPlansType::
    CorrectiveActionPlansType (const n_type& n)
    : ::xml_schema::type (),
      CorrectiveActionPlan_ (this),
      n_ (n, this)
    {
    }

    CorrectiveActionPlansType::
    CorrectiveActionPlansType (const CorrectiveActionPlansType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CorrectiveActionPlan_ (x.CorrectiveActionPlan_, f, this),
      n_ (x.n_, f, this)
    {
    }

    CorrectiveActionPlansType::
    CorrectiveActionPlansType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CorrectiveActionPlan_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CorrectiveActionPlansType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CorrectiveActionPlan
        //
        if (n.name () == L"CorrectiveActionPlan" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CorrectiveActionPlan_type > r (
            CorrectiveActionPlan_traits::create (i, f, this));

          this->CorrectiveActionPlan_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    CorrectiveActionPlansType* CorrectiveActionPlansType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CorrectiveActionPlansType (*this, f, c);
    }

    CorrectiveActionPlansType& CorrectiveActionPlansType::
    operator= (const CorrectiveActionPlansType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CorrectiveActionPlan_ = x.CorrectiveActionPlan_;
        this->n_ = x.n_;
      }

      return *this;
    }

    CorrectiveActionPlansType::
    ~CorrectiveActionPlansType ()
    {
    }

    // StatisticsType
    //

    StatisticsType::
    StatisticsType ()
    : ::xml_schema::type (),
      StatisticalStudyPlans_ (this),
      StatisticalStudiesResults_ (this),
      CorrectiveActionPlans_ (this)
    {
    }

    StatisticsType::
    StatisticsType (const StatisticsType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      StatisticalStudyPlans_ (x.StatisticalStudyPlans_, f, this),
      StatisticalStudiesResults_ (x.StatisticalStudiesResults_, f, this),
      CorrectiveActionPlans_ (x.CorrectiveActionPlans_, f, this)
    {
    }

    StatisticsType::
    StatisticsType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      StatisticalStudyPlans_ (this),
      StatisticalStudiesResults_ (this),
      CorrectiveActionPlans_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void StatisticsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // StatisticalStudyPlans
        //
        if (n.name () == L"StatisticalStudyPlans" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StatisticalStudyPlans_type > r (
            StatisticalStudyPlans_traits::create (i, f, this));

          if (!this->StatisticalStudyPlans_)
          {
            this->StatisticalStudyPlans_.set (::std::move (r));
            continue;
          }
        }

        // StatisticalStudiesResults
        //
        if (n.name () == L"StatisticalStudiesResults" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StatisticalStudiesResults_type > r (
            StatisticalStudiesResults_traits::create (i, f, this));

          if (!this->StatisticalStudiesResults_)
          {
            this->StatisticalStudiesResults_.set (::std::move (r));
            continue;
          }
        }

        // CorrectiveActionPlans
        //
        if (n.name () == L"CorrectiveActionPlans" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CorrectiveActionPlans_type > r (
            CorrectiveActionPlans_traits::create (i, f, this));

          if (!this->CorrectiveActionPlans_)
          {
            this->CorrectiveActionPlans_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    StatisticsType* StatisticsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StatisticsType (*this, f, c);
    }

    StatisticsType& StatisticsType::
    operator= (const StatisticsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->StatisticalStudyPlans_ = x.StatisticalStudyPlans_;
        this->StatisticalStudiesResults_ = x.StatisticalStudiesResults_;
        this->CorrectiveActionPlans_ = x.CorrectiveActionPlans_;
      }

      return *this;
    }

    StatisticsType::
    ~StatisticsType ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  namespace qif30
  {
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, wchar_t >
  type_serializer_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    void
    operator<< (xercesc::DOMElement& e, const StatisticalStudyPlanBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Version
      //
      if (i.Version ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Version",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Version ();
      }

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // FeatureItemIds
      //
      if (i.FeatureItemIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FeatureItemIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FeatureItemIds ();
      }

      // CalculateAverageFeatures
      //
      if (i.CalculateAverageFeatures ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CalculateAverageFeatures",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CalculateAverageFeatures ();
      }

      // CharacteristicItemIds
      //
      if (i.CharacteristicItemIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CharacteristicItemIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CharacteristicItemIds ();
      }

      // StatsValuesPerChar
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (StatisticalStudyPlanBaseType::StatsValuesPerChar_const_iterator
             b (i.StatsValuesPerChar ().begin ()), n (i.StatsValuesPerChar ().end ());
             b != n; ++b)
        {
          const StatisticalStudyPlanBaseType::StatsValuesPerChar_type& x (*b);

          if (typeid (StatisticalStudyPlanBaseType::StatsValuesPerChar_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"StatsValuesPerChar",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"StatsValuesPerChar",
              L"http://qifstandards.org/xsd/qif3",
              false, true, e, x);
        }
      }

      // StatsValuesPerSubgroup
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (StatisticalStudyPlanBaseType::StatsValuesPerSubgroup_const_iterator
             b (i.StatsValuesPerSubgroup ().begin ()), n (i.StatsValuesPerSubgroup ().end ());
             b != n; ++b)
        {
          const StatisticalStudyPlanBaseType::StatsValuesPerSubgroup_type& x (*b);

          if (typeid (StatisticalStudyPlanBaseType::StatsValuesPerSubgroup_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"StatsValuesPerSubgroup",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"StatsValuesPerSubgroup",
              L"http://qifstandards.org/xsd/qif3",
              false, true, e, x);
        }
      }

      // StatsValuesSummarys
      //
      for (StatisticalStudyPlanBaseType::StatsValuesSummarys_const_iterator
           b (i.StatsValuesSummarys ().begin ()), n (i.StatsValuesSummarys ().end ());
           b != n; ++b)
      {
        const StatisticalStudyPlanBaseType::StatsValuesSummarys_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StatsValuesSummarys",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // PreInspectionTraceability
      //
      if (i.PreInspectionTraceability ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PreInspectionTraceability",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PreInspectionTraceability ();
      }

      // Name
      //
      if (i.Name ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Name",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Name ();
      }

      // Description
      //
      if (i.Description ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Description",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Description ();
      }

      // PlanId
      //
      if (i.PlanId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PlanId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PlanId ();
      }

      // SoftwareId
      //
      if (i.SoftwareId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SoftwareId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SoftwareId ();
      }

      // StandardId
      //
      if (i.StandardId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StandardId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.StandardId ();
      }

      // CorrectiveActionPlanId
      //
      if (i.CorrectiveActionPlanId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CorrectiveActionPlanId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CorrectiveActionPlanId ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AbsoluteLimitsByUnitType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // LinearLimit
      //
      if (i.LinearLimit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LinearLimit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LinearLimit ();
      }

      // AngularLimit
      //
      if (i.AngularLimit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AngularLimit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AngularLimit ();
      }

      // AreaLimit
      //
      if (i.AreaLimit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AreaLimit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AreaLimit ();
      }

      // ForceLimit
      //
      if (i.ForceLimit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ForceLimit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ForceLimit ();
      }

      // MassLimit
      //
      if (i.MassLimit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MassLimit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MassLimit ();
      }

      // PressureLimit
      //
      if (i.PressureLimit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PressureLimit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PressureLimit ();
      }

      // SpeedLimit
      //
      if (i.SpeedLimit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SpeedLimit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SpeedLimit ();
      }

      // TemperatureLimit
      //
      if (i.TemperatureLimit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TemperatureLimit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TemperatureLimit ();
      }

      // TimeLimit
      //
      if (i.TimeLimit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TimeLimit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TimeLimit ();
      }

      // UserDefinedUnitLimit
      //
      for (AbsoluteLimitsByUnitType::UserDefinedUnitLimit_const_iterator
           b (i.UserDefinedUnitLimit ().begin ()), n (i.UserDefinedUnitLimit ().end ());
           b != n; ++b)
      {
        const AbsoluteLimitsByUnitType::UserDefinedUnitLimit_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDefinedUnitLimit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LinearityStudyPlanType& i)
    {
      e << static_cast< const ::xsd::qif30::StatisticalStudyPlanBaseType& > (i);

      // MeasurementDeviceIds
      //
      if (i.MeasurementDeviceIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeasurementDeviceIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MeasurementDeviceIds ();
      }

      // GoodnessOfFitThreshold
      //
      if (i.GoodnessOfFitThreshold ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"GoodnessOfFitThreshold",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_decimal(*i.GoodnessOfFitThreshold ());
      }

      // AbsoluteMinimums
      //
      if (i.AbsoluteMinimums ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AbsoluteMinimums",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AbsoluteMinimums ();
      }

      // RelativeLinearityMinimum
      //
      if (i.RelativeLinearityMinimum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RelativeLinearityMinimum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_decimal(*i.RelativeLinearityMinimum ());
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, LinearityStudyPlanType >
    _xsd_LinearityStudyPlanType_type_serializer_init (
      L"LinearityStudyPlanType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const StabilityStudyPlanType& i)
    {
      e << static_cast< const ::xsd::qif30::StatisticalStudyPlanBaseType& > (i);

      // MeasurementDeviceIds
      //
      if (i.MeasurementDeviceIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeasurementDeviceIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MeasurementDeviceIds ();
      }

      // SampleSize
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SampleSize",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SampleSize ();
      }

      // SampleFrequency
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SampleFrequency",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SampleFrequency ();
      }

      // SamplingInterval
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SamplingInterval",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SamplingInterval ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, StabilityStudyPlanType >
    _xsd_StabilityStudyPlanType_type_serializer_init (
      L"StabilityStudyPlanType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const MultipleProductInstanceStudyPlanBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::StatisticalStudyPlanBaseType& > (i);

      // NumberOfSamples
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NumberOfSamples",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.NumberOfSamples ();
      }

      // SubgroupSize
      //
      if (i.SubgroupSize ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SubgroupSize",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SubgroupSize ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const BiasStudyPlanType& i)
    {
      e << static_cast< const ::xsd::qif30::MultipleProductInstanceStudyPlanBaseType& > (i);

      // MeasurementDeviceIds
      //
      if (i.MeasurementDeviceIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeasurementDeviceIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MeasurementDeviceIds ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, BiasStudyPlanType >
    _xsd_BiasStudyPlanType_type_serializer_init (
      L"BiasStudyPlanType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const FirstArticleStudyPlanType& i)
    {
      e << static_cast< const ::xsd::qif30::StatisticalStudyPlanBaseType& > (i);

      // InSpecRatio
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"InSpecRatio",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_decimal(i.InSpecRatio ());
      }

      // AbsoluteMaximums
      //
      if (i.AbsoluteMaximums ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AbsoluteMaximums",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AbsoluteMaximums ();
      }

      // RelativeMaximum
      //
      if (i.RelativeMaximum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RelativeMaximum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_decimal(*i.RelativeMaximum ());
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, FirstArticleStudyPlanType >
    _xsd_FirstArticleStudyPlanType_type_serializer_init (
      L"FirstArticleStudyPlanType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ProcessDifferenceStudyPlanType& i)
    {
      e << static_cast< const ::xsd::qif30::StatisticalStudyPlanBaseType& > (i);

      // NumberOfSamples
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NumberOfSamples",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.NumberOfSamples ();
      }

      // SubgroupSize
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SubgroupSize",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SubgroupSize ();
      }

      // ManufacturingProcessId
      //
      if (i.ManufacturingProcessId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ManufacturingProcessId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ManufacturingProcessId ();
      }

      // AbsoluteDifferences
      //
      if (i.AbsoluteDifferences ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AbsoluteDifferences",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AbsoluteDifferences ();
      }

      // RelativeDifference
      //
      if (i.RelativeDifference ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RelativeDifference",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_decimal(*i.RelativeDifference ());
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ProcessDifferenceStudyPlanType >
    _xsd_ProcessDifferenceStudyPlanType_type_serializer_init (
      L"ProcessDifferenceStudyPlanType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const SimpleStudyPlanType& i)
    {
      e << static_cast< const ::xsd::qif30::MultipleProductInstanceStudyPlanBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SimpleStudyPlanType >
    _xsd_SimpleStudyPlanType_type_serializer_init (
      L"SimpleStudyPlanType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CapabilityStudyPlanType& i)
    {
      e << static_cast< const ::xsd::qif30::MultipleProductInstanceStudyPlanBaseType& > (i);

      // CpkThreshold
      //
      if (i.CpkThreshold ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CpkThreshold",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CpkThreshold ();
      }

      // PpkThreshold
      //
      if (i.PpkThreshold ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PpkThreshold",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PpkThreshold ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CapabilityStudyPlanType >
    _xsd_CapabilityStudyPlanType_type_serializer_init (
      L"CapabilityStudyPlanType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const GageRandRStudyEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const GageRandRStudyEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const GageRandRStudyEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const CriteriaByUnitType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // LinearCriterion
      //
      if (i.LinearCriterion ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LinearCriterion",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LinearCriterion ();
      }

      // AngularCriterion
      //
      if (i.AngularCriterion ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AngularCriterion",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AngularCriterion ();
      }

      // AreaCriterion
      //
      if (i.AreaCriterion ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AreaCriterion",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AreaCriterion ();
      }

      // ForceCriterion
      //
      if (i.ForceCriterion ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ForceCriterion",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ForceCriterion ();
      }

      // MassCriterion
      //
      if (i.MassCriterion ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MassCriterion",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MassCriterion ();
      }

      // PressureCriterion
      //
      if (i.PressureCriterion ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PressureCriterion",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PressureCriterion ();
      }

      // SpeedCriterion
      //
      if (i.SpeedCriterion ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SpeedCriterion",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SpeedCriterion ();
      }

      // TemperatureCriterion
      //
      if (i.TemperatureCriterion ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TemperatureCriterion",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TemperatureCriterion ();
      }

      // TimeCriterion
      //
      if (i.TimeCriterion ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TimeCriterion",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TimeCriterion ();
      }

      // UserDefinedUnitCriterion
      //
      for (CriteriaByUnitType::UserDefinedUnitCriterion_const_iterator
           b (i.UserDefinedUnitCriterion ().begin ()), n (i.UserDefinedUnitCriterion ().end ());
           b != n; ++b)
      {
        const CriteriaByUnitType::UserDefinedUnitCriterion_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDefinedUnitCriterion",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const GageRandRStudyPlanType& i)
    {
      e << static_cast< const ::xsd::qif30::StatisticalStudyPlanBaseType& > (i);

      // MeasurementDeviceIds
      //
      if (i.MeasurementDeviceIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeasurementDeviceIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MeasurementDeviceIds ();
      }

      // RandRStudyType
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RandRStudyType",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.RandRStudyType ();
      }

      // NumberOfAppraisers
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NumberOfAppraisers",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.NumberOfAppraisers ();
      }

      // NumberOfParts
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NumberOfParts",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.NumberOfParts ();
      }

      // NumberOfTrials
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NumberOfTrials",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.NumberOfTrials ();
      }

      // MaximumRelativeAppraiserVariation
      //
      if (i.MaximumRelativeAppraiserVariation ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaximumRelativeAppraiserVariation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaximumRelativeAppraiserVariation ();
      }

      // MaximumAbsoluteAppraiserVariation
      //
      if (i.MaximumAbsoluteAppraiserVariation ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaximumAbsoluteAppraiserVariation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaximumAbsoluteAppraiserVariation ();
      }

      // MaximumRelativeEquipmentVariation
      //
      if (i.MaximumRelativeEquipmentVariation ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaximumRelativeEquipmentVariation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaximumRelativeEquipmentVariation ();
      }

      // MaximumAbsoluteEquipmentVariation
      //
      if (i.MaximumAbsoluteEquipmentVariation ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaximumAbsoluteEquipmentVariation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaximumAbsoluteEquipmentVariation ();
      }

      // MaximumRelativeTotalRandR
      //
      if (i.MaximumRelativeTotalRandR ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaximumRelativeTotalRandR",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaximumRelativeTotalRandR ();
      }

      // MaximumAbsoluteTotalRandR
      //
      if (i.MaximumAbsoluteTotalRandR ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MaximumAbsoluteTotalRandR",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MaximumAbsoluteTotalRandR ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, GageRandRStudyPlanType >
    _xsd_GageRandRStudyPlanType_type_serializer_init (
      L"GageRandRStudyPlanType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ControlMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // AssignableCauseIds
      //
      if (i.AssignableCauseIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AssignableCauseIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AssignableCauseIds ();
      }

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // NumOutOfTolerance
      //
      if (i.NumOutOfTolerance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NumOutOfTolerance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.NumOutOfTolerance ();
      }

      // CpThreshold
      //
      if (i.CpThreshold ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CpThreshold",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CpThreshold ();
      }

      // CpkThreshold
      //
      if (i.CpkThreshold ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CpkThreshold",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CpkThreshold ();
      }

      // PpThreshold
      //
      if (i.PpThreshold ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PpThreshold",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PpThreshold ();
      }

      // PpkThreshold
      //
      if (i.PpkThreshold ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PpkThreshold",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PpkThreshold ();
      }

      // NumOutOfControl
      //
      if (i.NumOutOfControl ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NumOutOfControl",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.NumOutOfControl ();
      }

      // TrendGrouping
      //
      if (i.TrendGrouping ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TrendGrouping",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TrendGrouping ();
      }

      // SkewGrouping
      //
      if (i.SkewGrouping ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SkewGrouping",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SkewGrouping ();
      }

      // OneThirdGrouping
      //
      if (i.OneThirdGrouping ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OneThirdGrouping",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OneThirdGrouping ();
      }

      // TwoThirdsGrouping
      //
      if (i.TwoThirdsGrouping ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TwoThirdsGrouping",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TwoThirdsGrouping ();
      }

      // Oscillation
      //
      if (i.Oscillation ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Oscillation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Oscillation ();
      }

      // Stratification
      //
      if (i.Stratification ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Stratification",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Stratification ();
      }

      // NumOutOfControlRng
      //
      if (i.NumOutOfControlRng ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NumOutOfControlRng",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.NumOutOfControlRng ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ControlMethodsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ControlMethod
      //
      for (ControlMethodsType::ControlMethod_const_iterator
           b (i.ControlMethod ().begin ()), n (i.ControlMethod ().end ());
           b != n; ++b)
      {
        const ControlMethodsType::ControlMethod_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ControlMethod",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ProductionStudyPlanType& i)
    {
      e << static_cast< const ::xsd::qif30::MultipleProductInstanceStudyPlanBaseType& > (i);

      // SamplingMethod
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SamplingMethod",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SamplingMethod ();
      }

      // ControlMethods
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ControlMethods",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ControlMethods ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ProductionStudyPlanType >
    _xsd_ProductionStudyPlanType_type_serializer_init (
      L"ProductionStudyPlanType",
      L"http://qifstandards.org/xsd/qif3");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::FirstArticleStudyPlanType >
    _xsd_FirstArticleStudyPlan_element_serializer_init (
      L"StatisticalStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      L"FirstArticleStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::FirstArticleStudyPlanType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::LinearityStudyPlanType >
    _xsd_LinearityStudyPlan_element_serializer_init (
      L"StatisticalStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      L"LinearityStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::LinearityStudyPlanType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SimpleStudyPlanType >
    _xsd_SimpleStudyPlan_element_serializer_init (
      L"StatisticalStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      L"SimpleStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SimpleStudyPlanType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::BiasStudyPlanType >
    _xsd_BiasStudyPlan_element_serializer_init (
      L"StatisticalStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      L"BiasStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::BiasStudyPlanType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StabilityStudyPlanType >
    _xsd_StabilityStudyPlan_element_serializer_init (
      L"StatisticalStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      L"StabilityStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StabilityStudyPlanType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ProcessDifferenceStudyPlanType >
    _xsd_ProcessDifferenceStudyPlan_element_serializer_init (
      L"StatisticalStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      L"ProcessDifferenceStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ProcessDifferenceStudyPlanType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CapabilityStudyPlanType >
    _xsd_CapabilityStudyPlan_element_serializer_init (
      L"StatisticalStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      L"CapabilityStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CapabilityStudyPlanType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::GageRandRStudyPlanType >
    _xsd_GageRandRStudyPlan_element_serializer_init (
      L"StatisticalStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      L"GageRandRStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::GageRandRStudyPlanType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ProductionStudyPlanType >
    _xsd_ProductionStudyPlan_element_serializer_init (
      L"StatisticalStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      L"ProductionStudyPlan",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ProductionStudyPlanType >);


    void
    operator<< (xercesc::DOMElement& e, const StatisticalStudyResultsBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ThisStatisticalStudyResultsInstanceQPId
      //
      if (i.ThisStatisticalStudyResultsInstanceQPId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThisStatisticalStudyResultsInstanceQPId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThisStatisticalStudyResultsInstanceQPId ();
      }

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // Status
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Status",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Status ();
      }

      // SoftwareId
      //
      if (i.SoftwareId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SoftwareId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SoftwareId ();
      }

      // StandardId
      //
      if (i.StandardId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StandardId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.StandardId ();
      }

      // StudyIssues
      //
      if (i.StudyIssues ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StudyIssues",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.StudyIssues ();
      }

      // InspectionTraceability
      //
      if (i.InspectionTraceability ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"InspectionTraceability",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.InspectionTraceability ();
      }

      // Name
      //
      if (i.Name ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Name",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Name ();
      }

      // Description
      //
      if (i.Description ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Description",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Description ();
      }

      // StudyId
      //
      if (i.StudyId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StudyId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.StudyId ();
      }

      // ResultsIds
      //
      if (i.ResultsIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ResultsIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ResultsIds ();
      }

      // ResultsQPIds
      //
      for (StatisticalStudyResultsBaseType::ResultsQPIds_const_iterator
           b (i.ResultsQPIds ().begin ()), n (i.ResultsQPIds ().end ());
           b != n; ++b)
      {
        const StatisticalStudyResultsBaseType::ResultsQPIds_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ResultsQPIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // ResultsFiles
      //
      if (i.ResultsFiles ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ResultsFiles",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ResultsFiles ();
      }

      // AverageFeatures
      //
      if (i.AverageFeatures ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AverageFeatures",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AverageFeatures ();
      }

      // CharacteristicsStats
      //
      if (i.CharacteristicsStats ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CharacteristicsStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CharacteristicsStats ();
      }

      // LinearStatsSummaries
      //
      if (i.LinearStatsSummaries ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LinearStatsSummaries",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LinearStatsSummaries ();
      }

      // AngularStatsSummaries
      //
      if (i.AngularStatsSummaries ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AngularStatsSummaries",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AngularStatsSummaries ();
      }

      // AreaStatsSummaries
      //
      if (i.AreaStatsSummaries ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AreaStatsSummaries",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AreaStatsSummaries ();
      }

      // ForceStatsSummaries
      //
      if (i.ForceStatsSummaries ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ForceStatsSummaries",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ForceStatsSummaries ();
      }

      // MassStatsSummaries
      //
      if (i.MassStatsSummaries ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MassStatsSummaries",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MassStatsSummaries ();
      }

      // PressureStatsSummaries
      //
      if (i.PressureStatsSummaries ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PressureStatsSummaries",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PressureStatsSummaries ();
      }

      // SpeedStatsSummaries
      //
      if (i.SpeedStatsSummaries ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SpeedStatsSummaries",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SpeedStatsSummaries ();
      }

      // TemperatureStatsSummaries
      //
      if (i.TemperatureStatsSummaries ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TemperatureStatsSummaries",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TemperatureStatsSummaries ();
      }

      // TimeStatsSummaries
      //
      if (i.TimeStatsSummaries ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TimeStatsSummaries",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TimeStatsSummaries ();
      }

      // UserDefinedUnitStatsSummaries
      //
      if (i.UserDefinedUnitStatsSummaries ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDefinedUnitStatsSummaries",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UserDefinedUnitStatsSummaries ();
      }

      // StatsSummaries
      //
      if (i.StatsSummaries ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StatsSummaries",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.StatsSummaries ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LinearityStudyResultsType& i)
    {
      e << static_cast< const ::xsd::qif30::StatisticalStudyResultsBaseType& > (i);

      // SampleSize
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SampleSize",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SampleSize ();
      }

      // MeasurementDeviceIds
      //
      if (i.MeasurementDeviceIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeasurementDeviceIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MeasurementDeviceIds ();
      }

      // GoodnessOfFit
      //
      if (i.GoodnessOfFit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"GoodnessOfFit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.GoodnessOfFit ();
      }

      // LinearAbsoluteLinearity
      //
      if (i.LinearAbsoluteLinearity ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LinearAbsoluteLinearity",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LinearAbsoluteLinearity ();
      }

      // AngularAbsoluteLinearity
      //
      if (i.AngularAbsoluteLinearity ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AngularAbsoluteLinearity",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AngularAbsoluteLinearity ();
      }

      // AreaAbsoluteLinearity
      //
      if (i.AreaAbsoluteLinearity ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AreaAbsoluteLinearity",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AreaAbsoluteLinearity ();
      }

      // ForceAbsoluteLinearity
      //
      if (i.ForceAbsoluteLinearity ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ForceAbsoluteLinearity",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ForceAbsoluteLinearity ();
      }

      // MassAbsoluteLinearity
      //
      if (i.MassAbsoluteLinearity ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MassAbsoluteLinearity",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MassAbsoluteLinearity ();
      }

      // PressureAbsoluteLinearity
      //
      if (i.PressureAbsoluteLinearity ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PressureAbsoluteLinearity",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PressureAbsoluteLinearity ();
      }

      // SpeedAbsoluteLinearity
      //
      if (i.SpeedAbsoluteLinearity ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SpeedAbsoluteLinearity",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SpeedAbsoluteLinearity ();
      }

      // TemperatureAbsoluteLinearity
      //
      if (i.TemperatureAbsoluteLinearity ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TemperatureAbsoluteLinearity",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TemperatureAbsoluteLinearity ();
      }

      // TimeAbsoluteLinearity
      //
      if (i.TimeAbsoluteLinearity ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TimeAbsoluteLinearity",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TimeAbsoluteLinearity ();
      }

      // UserDefinedUnitAbsoluteLinearity
      //
      if (i.UserDefinedUnitAbsoluteLinearity ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDefinedUnitAbsoluteLinearity",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UserDefinedUnitAbsoluteLinearity ();
      }

      // RelativeLinearity
      //
      if (i.RelativeLinearity ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RelativeLinearity",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.RelativeLinearity ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, LinearityStudyResultsType >
    _xsd_LinearityStudyResultsType_type_serializer_init (
      L"LinearityStudyResultsType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const StabilityStudyResultsType& i)
    {
      e << static_cast< const ::xsd::qif30::StatisticalStudyResultsBaseType& > (i);

      // SampleSize
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SampleSize",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SampleSize ();
      }

      // MeasurementDeviceIds
      //
      if (i.MeasurementDeviceIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeasurementDeviceIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MeasurementDeviceIds ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, StabilityStudyResultsType >
    _xsd_StabilityStudyResultsType_type_serializer_init (
      L"StabilityStudyResultsType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const BiasStudyResultsType& i)
    {
      e << static_cast< const ::xsd::qif30::StatisticalStudyResultsBaseType& > (i);

      // SampleSize
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SampleSize",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SampleSize ();
      }

      // MeasurementDeviceIds
      //
      if (i.MeasurementDeviceIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeasurementDeviceIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MeasurementDeviceIds ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, BiasStudyResultsType >
    _xsd_BiasStudyResultsType_type_serializer_init (
      L"BiasStudyResultsType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const AbsoluteMeasurementsByUnitType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // LinearMeasurement
      //
      if (i.LinearMeasurement ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LinearMeasurement",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LinearMeasurement ();
      }

      // AngularMeasurement
      //
      if (i.AngularMeasurement ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AngularMeasurement",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AngularMeasurement ();
      }

      // AreaMeasurement
      //
      if (i.AreaMeasurement ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AreaMeasurement",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AreaMeasurement ();
      }

      // ForceMeasurement
      //
      if (i.ForceMeasurement ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ForceMeasurement",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ForceMeasurement ();
      }

      // MassMeasurement
      //
      if (i.MassMeasurement ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MassMeasurement",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MassMeasurement ();
      }

      // PressureMeasurement
      //
      if (i.PressureMeasurement ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PressureMeasurement",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PressureMeasurement ();
      }

      // SpeedMeasurement
      //
      if (i.SpeedMeasurement ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SpeedMeasurement",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SpeedMeasurement ();
      }

      // TemperatureMeasurement
      //
      if (i.TemperatureMeasurement ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TemperatureMeasurement",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TemperatureMeasurement ();
      }

      // TimeMeasurement
      //
      if (i.TimeMeasurement ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TimeMeasurement",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TimeMeasurement ();
      }

      // UserDefinedUnitMeasurement
      //
      for (AbsoluteMeasurementsByUnitType::UserDefinedUnitMeasurement_const_iterator
           b (i.UserDefinedUnitMeasurement ().begin ()), n (i.UserDefinedUnitMeasurement ().end ());
           b != n; ++b)
      {
        const AbsoluteMeasurementsByUnitType::UserDefinedUnitMeasurement_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDefinedUnitMeasurement",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const FirstArticleStudyResultsType& i)
    {
      e << static_cast< const ::xsd::qif30::StatisticalStudyResultsBaseType& > (i);

      // InSpecRatio
      //
      if (i.InSpecRatio ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"InSpecRatio",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_decimal(*i.InSpecRatio ());
      }

      // AbsoluteMaximums
      //
      if (i.AbsoluteMaximums ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AbsoluteMaximums",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AbsoluteMaximums ();
      }

      // RelativeMaximum
      //
      if (i.RelativeMaximum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RelativeMaximum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.RelativeMaximum ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, FirstArticleStudyResultsType >
    _xsd_FirstArticleStudyResultsType_type_serializer_init (
      L"FirstArticleStudyResultsType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ProcessDifferenceStudyResultsType& i)
    {
      e << static_cast< const ::xsd::qif30::StatisticalStudyResultsBaseType& > (i);

      // NumberOfSamples
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NumberOfSamples",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.NumberOfSamples ();
      }

      // SubgroupSize
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SubgroupSize",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SubgroupSize ();
      }

      // ManufacturingProcessId
      //
      if (i.ManufacturingProcessId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ManufacturingProcessId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ManufacturingProcessId ();
      }

      // AbsoluteDifferences
      //
      if (i.AbsoluteDifferences ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AbsoluteDifferences",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AbsoluteDifferences ();
      }

      // RelativeDifference
      //
      if (i.RelativeDifference ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RelativeDifference",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.RelativeDifference ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ProcessDifferenceStudyResultsType >
    _xsd_ProcessDifferenceStudyResultsType_type_serializer_init (
      L"ProcessDifferenceStudyResultsType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const MultipleProductInstanceStudyResultsBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::StatisticalStudyResultsBaseType& > (i);

      // NumberOfSamples
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NumberOfSamples",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.NumberOfSamples ();
      }

      // SubgroupSize
      //
      if (i.SubgroupSize ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SubgroupSize",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SubgroupSize ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SimpleStudyResultsType& i)
    {
      e << static_cast< const ::xsd::qif30::MultipleProductInstanceStudyResultsBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SimpleStudyResultsType >
    _xsd_SimpleStudyResultsType_type_serializer_init (
      L"SimpleStudyResultsType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CapabilityStudyResultsType& i)
    {
      e << static_cast< const ::xsd::qif30::MultipleProductInstanceStudyResultsBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CapabilityStudyResultsType >
    _xsd_CapabilityStudyResultsType_type_serializer_init (
      L"CapabilityStudyResultsType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const GageRandRStudyResultsType& i)
    {
      e << static_cast< const ::xsd::qif30::StatisticalStudyResultsBaseType& > (i);

      // MeasurementDeviceIds
      //
      if (i.MeasurementDeviceIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeasurementDeviceIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MeasurementDeviceIds ();
      }

      // NumberOfAppraisers
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NumberOfAppraisers",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.NumberOfAppraisers ();
      }

      // NumberOfParts
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NumberOfParts",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.NumberOfParts ();
      }

      // NumberOfTrials
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NumberOfTrials",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.NumberOfTrials ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, GageRandRStudyResultsType >
    _xsd_GageRandRStudyResultsType_type_serializer_init (
      L"GageRandRStudyResultsType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ProductionStudyResultsType& i)
    {
      e << static_cast< const ::xsd::qif30::MultipleProductInstanceStudyResultsBaseType& > (i);

      // ControlIssueDetailsList
      //
      for (ProductionStudyResultsType::ControlIssueDetailsList_const_iterator
           b (i.ControlIssueDetailsList ().begin ()), n (i.ControlIssueDetailsList ().end ());
           b != n; ++b)
      {
        const ProductionStudyResultsType::ControlIssueDetailsList_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ControlIssueDetailsList",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ProductionStudyResultsType >
    _xsd_ProductionStudyResultsType_type_serializer_init (
      L"ProductionStudyResultsType",
      L"http://qifstandards.org/xsd/qif3");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::FirstArticleStudyResultsType >
    _xsd_FirstArticleStudyResults_element_serializer_init (
      L"StatisticalStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      L"FirstArticleStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::FirstArticleStudyResultsType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::LinearityStudyResultsType >
    _xsd_LinearityStudyResults_element_serializer_init (
      L"StatisticalStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      L"LinearityStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::LinearityStudyResultsType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SimpleStudyResultsType >
    _xsd_SimpleStudyResults_element_serializer_init (
      L"StatisticalStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      L"SimpleStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SimpleStudyResultsType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::BiasStudyResultsType >
    _xsd_BiasStudyResults_element_serializer_init (
      L"StatisticalStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      L"BiasStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::BiasStudyResultsType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::StabilityStudyResultsType >
    _xsd_StabilityStudyResults_element_serializer_init (
      L"StatisticalStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      L"StabilityStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::StabilityStudyResultsType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CapabilityStudyResultsType >
    _xsd_CapabilityStudyResults_element_serializer_init (
      L"StatisticalStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      L"CapabilityStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CapabilityStudyResultsType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ProcessDifferenceStudyResultsType >
    _xsd_ProcessDifferenceStudyResults_element_serializer_init (
      L"StatisticalStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      L"ProcessDifferenceStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ProcessDifferenceStudyResultsType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::GageRandRStudyResultsType >
    _xsd_GageRandRStudyResults_element_serializer_init (
      L"StatisticalStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      L"GageRandRStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::GageRandRStudyResultsType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ProductionStudyResultsType >
    _xsd_ProductionStudyResults_element_serializer_init (
      L"StatisticalStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      L"ProductionStudyResults",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ProductionStudyResultsType >);


    void
    operator<< (xercesc::DOMElement& e, const StatisticalStudyPlansType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // StatisticalStudyPlan
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (StatisticalStudyPlansType::StatisticalStudyPlan_const_iterator
             b (i.StatisticalStudyPlan ().begin ()), n (i.StatisticalStudyPlan ().end ());
             b != n; ++b)
        {
          const StatisticalStudyPlansType::StatisticalStudyPlan_type& x (*b);

          if (typeid (StatisticalStudyPlansType::StatisticalStudyPlan_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"StatisticalStudyPlan",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"StatisticalStudyPlan",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StatisticalStudiesResultsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // StatisticalStudyResults
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (StatisticalStudiesResultsType::StatisticalStudyResults_const_iterator
             b (i.StatisticalStudyResults ().begin ()), n (i.StatisticalStudyResults ().end ());
             b != n; ++b)
        {
          const StatisticalStudiesResultsType::StatisticalStudyResults_type& x (*b);

          if (typeid (StatisticalStudiesResultsType::StatisticalStudyResults_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"StatisticalStudyResults",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"StatisticalStudyResults",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CorrectiveActionPlanType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Version
      //
      if (i.Version ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Version",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Version ();
      }

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // AssignableCauses
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AssignableCauses",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.AssignableCauses ();
      }

      // CorrectiveActions
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CorrectiveActions",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.CorrectiveActions ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CorrectiveActionPlansType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CorrectiveActionPlan
      //
      for (CorrectiveActionPlansType::CorrectiveActionPlan_const_iterator
           b (i.CorrectiveActionPlan ().begin ()), n (i.CorrectiveActionPlan ().end ());
           b != n; ++b)
      {
        const CorrectiveActionPlansType::CorrectiveActionPlan_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CorrectiveActionPlan",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StatisticsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // StatisticalStudyPlans
      //
      if (i.StatisticalStudyPlans ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StatisticalStudyPlans",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.StatisticalStudyPlans ();
      }

      // StatisticalStudiesResults
      //
      if (i.StatisticalStudiesResults ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StatisticalStudiesResults",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.StatisticalStudiesResults ();
      }

      // CorrectiveActionPlans
      //
      if (i.CorrectiveActionPlans ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CorrectiveActionPlans",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CorrectiveActionPlans ();
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

