// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

#ifndef CXX___QIFAPPLICATIONS_QIFMEASUREMENT_RESOURCES_HXX
#define CXX___QIFAPPLICATIONS_QIFMEASUREMENT_RESOURCES_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_WCHAR
#define XSD_USE_WCHAR
#endif

#ifndef XSD_CXX_TREE_USE_WCHAR
#define XSD_CXX_TREE_USE_WCHAR
#endif

// Begin prologue.
//
#include "..\\export.hxx"
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (LIBXSD_VERSION != 400002000000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< wchar_t, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< wchar_t, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< wchar_t, string > normalized_string;
  typedef ::xsd::cxx::tree::token< wchar_t, normalized_string > token;
  typedef ::xsd::cxx::tree::name< wchar_t, token > name;
  typedef ::xsd::cxx::tree::nmtoken< wchar_t, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< wchar_t, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< wchar_t, name > ncname;
  typedef ::xsd::cxx::tree::language< wchar_t, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< wchar_t, ncname > id;
  typedef ::xsd::cxx::tree::idref< wchar_t, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< wchar_t, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< wchar_t, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< wchar_t, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< wchar_t > buffer;
  typedef ::xsd::cxx::tree::base64_binary< wchar_t, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< wchar_t, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< wchar_t, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< wchar_t, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< wchar_t, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< wchar_t, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< wchar_t, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< wchar_t, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< wchar_t, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< wchar_t, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< wchar_t, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< wchar_t, ncname > entity;
  typedef ::xsd::cxx::tree::entities< wchar_t, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< wchar_t > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< wchar_t > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< wchar_t > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< wchar_t > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< wchar_t > error;
  typedef ::xsd::cxx::tree::diagnostics< wchar_t > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< wchar_t > exception;
  typedef ::xsd::cxx::tree::bounds< wchar_t > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< wchar_t > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< wchar_t > parsing;
  typedef ::xsd::cxx::tree::expected_element< wchar_t > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< wchar_t > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< wchar_t > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< wchar_t > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< wchar_t > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< wchar_t > no_prefix_mapping;
  typedef ::xsd::cxx::tree::no_type_info< wchar_t > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< wchar_t > not_derived;
  typedef ::xsd::cxx::tree::serialization< wchar_t > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< wchar_t > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace xsd
{
  namespace qif30
  {
    class MeasurementResourcesType;
    class MeasurementResourceBaseType;
    class CarriageType;
    class CarriagesType;
    class FixturesType;
    class MeasurementRoomType;
    class MeasurementRoomsType;
    class FixtureType;
    class SensorType;
    class LaserType;
    class DetachableSensorBaseType;
    class DetachableSensorsType;
    class ToolsType;
    class ToolBaseType;
    class ToolWithIntegratedSensorBaseType;
    class ToolWithLVDTSensorType;
    class ToolWithCapacitiveSensorType;
    class ToolWithEddyCurrentSensorType;
    class ToolWithConfocalChromaticSensorType;
    class ToolWithDrawWireSensorType;
    class ToolWithMagnetoInductiveSensorType;
    class ToolWithDVRTSensorType;
    class ToolWithLaserTriangulationSensorType;
    class ToolWithStructuredLightSensorType;
    class ToolWithUltrasonicSensorType;
    class ToolWithSimpleTactileProbeSensorType;
    class ToolWithComplexTactileProbeSensorType;
    class ToolWithCCDCameraSensorType;
    class ToolWithDetachableSensorsType;
    class MeasurementDevicesType;
    class MeasurementDeviceType;
    class ManualMeasurementDeviceType;
    class UniversalDeviceType;
    class TemperatureCompensationEnumType;
    class TemperatureCompensationType;
    class WorkingVolumeBaseType;
    class ClosedShellSetWorkingVolumeType;
    class ClosedShellSetType;
    class CartesianWorkingVolumeType;
    class SphericalWorkingVolumeType;
    class CylindricalWorkingVolumeType;
    class UserDefinedWorkingVolumeType;
    class LinearOrRotaryAxisType;
    class UserDefinedAxisType;
    class EffectiveWorkingVolumeBaseType;
    class EffectiveCylindricalWorkingVolumeType;
    class EffectiveSphericalWorkingVolumeType;
    class EffectiveCartesianWorkingVolumeType;
    class EffectiveClosedShellSetWorkingVolumeType;
    class EffectiveUserDefinedWorkingVolumeType;
    class UserAxisBaseType;
    class LinearAxisType;
    class RotaryAxisType;
    class ResolutionBaseType;
    class LinearResolutionType;
    class CartesianResolutionType;
    class XYZResolutionType;
    class RAPZResolutionType;
    class SphericalResolutionType;
    class CombinedSphericalResolutionType;
    class UserDefinedResolutionType;
    class ABCResolutionType;
    class CombinedUserDefinedResolutionType;
    class CalibrationMasterType;
    class CalibrationType;
    class CalibrationsType;
    class QualificationsType;
    class QualificationType;
    class TemperaturesType;
    class TemperatureType;
    class LinearVariableDifferentialTransformerEnumType;
    class LinearVariableDifferentialTransformerSensorType;
    class CapacitiveSensorType;
    class EddyCurrentSensorType;
    class ConfocalChromaticSensorType;
    class DrawWireSensorType;
    class MagnetoInductiveSensorType;
    class DifferentialVariableReluctanceTransducerSensorType;
    class LaserTriangulationSensorType;
    class StructuredLightSensorType;
    class UltrasonicSensorType;
    class TipEndGeometryEnumType;
    class TipEndGeometryType;
    class TactileProbeSensorBaseType;
    class SimpleTactileProbeSensorType;
    class ComplexTactileProbeSensorType;
    class LocatedTipsType;
    class ProbeTipType;
    class LocatedTipType;
    class ChargeCoupledDeviceCameraSensorType;
    class CMMType;
    class CartesianCMMType;
    class MultipleCarriageCartesianCMMType;
    class LightPenCMMType;
    class ParallelLinkCMMType;
    class AACMMType;
    class CaliperType;
    class CaliperDialType;
    class CaliperDigitalType;
    class MicrometerType;
    class MicrometerAnalogType;
    class MicrometerDigitalType;
    class GageDeviceType;
    class SineBarType;
    class TheodoliteType;
    class UniversalLengthMeasuringType;
    class ComputedTomographyType;
    class OpticalComparatorType;
    class MicroscopeType;
    class AutocollimatorType;
    class LaserTrackerType;
    class LaserRadarType;
    class StiffnessType;
    class CMMDirectionEnumType;
    class CartesianCMMGeometryType;
    class CartesianCMMGeometryEnumType;
    class CMMAxisDirectionsBaseType;
    class CartesianCMMAxisDirectionsType;
    class XYZLinearSpecificationType;
    class TargetMirrorEnumType;
    class MeasurementDeviceScalesBaseType;
    class CartesianMeasurementDeviceScalesType;
    class MeasurementDeviceScaleType;
    class ScaleReferenceEnumType;
    class TypeOfScaleEnumType;
    class TypeOfScaleType;
    class CMMSpeedsBaseType;
    class CartesianCMMSpeedsType;
    class ParallelLinkCMMSpeedsType;
    class FunctionDiscreteType;
    class LengthFunctionDiscreteType;
    class AngleFunctionDiscreteType;
    class MeasurementDeviceAccuracyBaseType;
    class NumericalLengthAccuracyType;
    class EnvironmentalRangeType;
    class CartesianCMMAccuracyType;
    class AACMMAccuracyType;
    class CartesianCMMAccuraciesType;
    class AACMMAccuraciesType;
    class AccuracySourceType;
    class AccuracySourceEnumType;
    class CMMAccuracyTestBaseType;
    class FPSTestType;
    class CartesianCMMB89TestType;
    class AACMMB89TestType;
    class EffectiveDiameterPerformanceTestType;
    class SinglePointArticulationPerformanceTestType;
    class VolumetricPerformanceTestType;
    class TwentyLinearValuesType;
    class ISO10360TestType;
    class LinearErrorType;
    class LesserErrorType;
    class PointAccuracyTestType;
    class AngularErrorType;
    class RotaryTableType;
    class TableErrorsType;
  }
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "../QIFLibrary/IntermediatesPMI.hxx"

#include "../QIFLibrary/Topology.hxx"

#include "../QIFLibrary/Geometry.hxx"

namespace xsd
{
  namespace qif30
  {
    class QIF30_SYMBOL_DECL MeasurementResourcesType: public ::xml_schema::type
    {
      public:
      // Version
      //
      typedef ::xsd::qif30::VersionType Version_type;
      typedef ::xsd::cxx::tree::optional< Version_type > Version_optional;
      typedef ::xsd::cxx::tree::traits< Version_type, wchar_t > Version_traits;

      const Version_optional&
      Version () const;

      Version_optional&
      Version ();

      void
      Version (const Version_type& x);

      void
      Version (const Version_optional& x);

      void
      Version (::std::unique_ptr< Version_type > p);

      // Fixtures
      //
      typedef ::xsd::qif30::FixturesType Fixtures_type;
      typedef ::xsd::cxx::tree::optional< Fixtures_type > Fixtures_optional;
      typedef ::xsd::cxx::tree::traits< Fixtures_type, wchar_t > Fixtures_traits;

      const Fixtures_optional&
      Fixtures () const;

      Fixtures_optional&
      Fixtures ();

      void
      Fixtures (const Fixtures_type& x);

      void
      Fixtures (const Fixtures_optional& x);

      void
      Fixtures (::std::unique_ptr< Fixtures_type > p);

      // MeasurementRooms
      //
      typedef ::xsd::qif30::MeasurementRoomsType MeasurementRooms_type;
      typedef ::xsd::cxx::tree::optional< MeasurementRooms_type > MeasurementRooms_optional;
      typedef ::xsd::cxx::tree::traits< MeasurementRooms_type, wchar_t > MeasurementRooms_traits;

      const MeasurementRooms_optional&
      MeasurementRooms () const;

      MeasurementRooms_optional&
      MeasurementRooms ();

      void
      MeasurementRooms (const MeasurementRooms_type& x);

      void
      MeasurementRooms (const MeasurementRooms_optional& x);

      void
      MeasurementRooms (::std::unique_ptr< MeasurementRooms_type > p);

      // MeasurementDevices
      //
      typedef ::xsd::qif30::MeasurementDevicesType MeasurementDevices_type;
      typedef ::xsd::cxx::tree::optional< MeasurementDevices_type > MeasurementDevices_optional;
      typedef ::xsd::cxx::tree::traits< MeasurementDevices_type, wchar_t > MeasurementDevices_traits;

      const MeasurementDevices_optional&
      MeasurementDevices () const;

      MeasurementDevices_optional&
      MeasurementDevices ();

      void
      MeasurementDevices (const MeasurementDevices_type& x);

      void
      MeasurementDevices (const MeasurementDevices_optional& x);

      void
      MeasurementDevices (::std::unique_ptr< MeasurementDevices_type > p);

      // DetachableSensors
      //
      typedef ::xsd::qif30::DetachableSensorsType DetachableSensors_type;
      typedef ::xsd::cxx::tree::optional< DetachableSensors_type > DetachableSensors_optional;
      typedef ::xsd::cxx::tree::traits< DetachableSensors_type, wchar_t > DetachableSensors_traits;

      const DetachableSensors_optional&
      DetachableSensors () const;

      DetachableSensors_optional&
      DetachableSensors ();

      void
      DetachableSensors (const DetachableSensors_type& x);

      void
      DetachableSensors (const DetachableSensors_optional& x);

      void
      DetachableSensors (::std::unique_ptr< DetachableSensors_type > p);

      // Tools
      //
      typedef ::xsd::qif30::ToolsType Tools_type;
      typedef ::xsd::cxx::tree::optional< Tools_type > Tools_optional;
      typedef ::xsd::cxx::tree::traits< Tools_type, wchar_t > Tools_traits;

      const Tools_optional&
      Tools () const;

      Tools_optional&
      Tools ();

      void
      Tools (const Tools_type& x);

      void
      Tools (const Tools_optional& x);

      void
      Tools (::std::unique_ptr< Tools_type > p);

      // Constructors.
      //
      MeasurementResourcesType ();

      MeasurementResourcesType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      MeasurementResourcesType (const MeasurementResourcesType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual MeasurementResourcesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasurementResourcesType&
      operator= (const MeasurementResourcesType& x);

      virtual 
      ~MeasurementResourcesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Version_optional Version_;
      Fixtures_optional Fixtures_;
      MeasurementRooms_optional MeasurementRooms_;
      MeasurementDevices_optional MeasurementDevices_;
      DetachableSensors_optional DetachableSensors_;
      Tools_optional Tools_;
    };

    class QIF30_SYMBOL_DECL MeasurementResourceBaseType: public ::xml_schema::type
    {
      public:
      // Name
      //
      typedef ::xml_schema::token Name_type;
      typedef ::xsd::cxx::tree::traits< Name_type, wchar_t > Name_traits;

      const Name_type&
      Name () const;

      Name_type&
      Name ();

      void
      Name (const Name_type& x);

      void
      Name (::std::unique_ptr< Name_type > p);

      // Description
      //
      typedef ::xml_schema::string Description_type;
      typedef ::xsd::cxx::tree::optional< Description_type > Description_optional;
      typedef ::xsd::cxx::tree::traits< Description_type, wchar_t > Description_traits;

      const Description_optional&
      Description () const;

      Description_optional&
      Description ();

      void
      Description (const Description_type& x);

      void
      Description (const Description_optional& x);

      void
      Description (::std::unique_ptr< Description_type > p);

      // Manufacturer
      //
      typedef ::xml_schema::string Manufacturer_type;
      typedef ::xsd::cxx::tree::optional< Manufacturer_type > Manufacturer_optional;
      typedef ::xsd::cxx::tree::traits< Manufacturer_type, wchar_t > Manufacturer_traits;

      const Manufacturer_optional&
      Manufacturer () const;

      Manufacturer_optional&
      Manufacturer ();

      void
      Manufacturer (const Manufacturer_type& x);

      void
      Manufacturer (const Manufacturer_optional& x);

      void
      Manufacturer (::std::unique_ptr< Manufacturer_type > p);

      // ModelNumber
      //
      typedef ::xml_schema::string ModelNumber_type;
      typedef ::xsd::cxx::tree::optional< ModelNumber_type > ModelNumber_optional;
      typedef ::xsd::cxx::tree::traits< ModelNumber_type, wchar_t > ModelNumber_traits;

      const ModelNumber_optional&
      ModelNumber () const;

      ModelNumber_optional&
      ModelNumber ();

      void
      ModelNumber (const ModelNumber_type& x);

      void
      ModelNumber (const ModelNumber_optional& x);

      void
      ModelNumber (::std::unique_ptr< ModelNumber_type > p);

      // SerialNumber
      //
      typedef ::xml_schema::string SerialNumber_type;
      typedef ::xsd::cxx::tree::optional< SerialNumber_type > SerialNumber_optional;
      typedef ::xsd::cxx::tree::traits< SerialNumber_type, wchar_t > SerialNumber_traits;

      const SerialNumber_optional&
      SerialNumber () const;

      SerialNumber_optional&
      SerialNumber ();

      void
      SerialNumber (const SerialNumber_type& x);

      void
      SerialNumber (const SerialNumber_optional& x);

      void
      SerialNumber (::std::unique_ptr< SerialNumber_type > p);

      // Mass
      //
      typedef ::xsd::qif30::MassValueType Mass_type;
      typedef ::xsd::cxx::tree::optional< Mass_type > Mass_optional;
      typedef ::xsd::cxx::tree::traits< Mass_type, wchar_t > Mass_traits;

      const Mass_optional&
      Mass () const;

      Mass_optional&
      Mass ();

      void
      Mass (const Mass_type& x);

      void
      Mass (const Mass_optional& x);

      void
      Mass (::std::unique_ptr< Mass_type > p);

      // Size
      //
      typedef ::xsd::qif30::CartesianWorkingVolumeType Size_type;
      typedef ::xsd::cxx::tree::optional< Size_type > Size_optional;
      typedef ::xsd::cxx::tree::traits< Size_type, wchar_t > Size_traits;

      const Size_optional&
      Size () const;

      Size_optional&
      Size ();

      void
      Size (const Size_type& x);

      void
      Size (const Size_optional& x);

      void
      Size (::std::unique_ptr< Size_type > p);

      // LocationId
      //
      typedef ::xsd::qif30::QIFReferenceType LocationId_type;
      typedef ::xsd::cxx::tree::optional< LocationId_type > LocationId_optional;
      typedef ::xsd::cxx::tree::traits< LocationId_type, wchar_t > LocationId_traits;

      const LocationId_optional&
      LocationId () const;

      LocationId_optional&
      LocationId ();

      void
      LocationId (const LocationId_type& x);

      void
      LocationId (const LocationId_optional& x);

      void
      LocationId (::std::unique_ptr< LocationId_type > p);

      // Location
      //
      typedef ::xsd::qif30::LocationType Location_type;
      typedef ::xsd::cxx::tree::optional< Location_type > Location_optional;
      typedef ::xsd::cxx::tree::traits< Location_type, wchar_t > Location_traits;

      const Location_optional&
      Location () const;

      Location_optional&
      Location ();

      void
      Location (const Location_type& x);

      void
      Location (const Location_optional& x);

      void
      Location (::std::unique_ptr< Location_type > p);

      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      MeasurementResourceBaseType ();

      MeasurementResourceBaseType (const Name_type&,
                                   const id_type&);

      MeasurementResourceBaseType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      MeasurementResourceBaseType (const MeasurementResourceBaseType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual MeasurementResourceBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      MeasurementResourceBaseType&
      operator= (const MeasurementResourceBaseType& x);

      virtual 
      ~MeasurementResourceBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Name_type > Name_;
      Description_optional Description_;
      Manufacturer_optional Manufacturer_;
      ModelNumber_optional ModelNumber_;
      SerialNumber_optional SerialNumber_;
      Mass_optional Mass_;
      Size_optional Size_;
      LocationId_optional LocationId_;
      Location_optional Location_;
      Attributes_optional Attributes_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL CarriageType: public ::xsd::qif30::MeasurementResourceBaseType
    {
      public:
      // ToolIds
      //
      typedef ::xsd::qif30::ArrayReferenceType ToolIds_type;
      typedef ::xsd::cxx::tree::optional< ToolIds_type > ToolIds_optional;
      typedef ::xsd::cxx::tree::traits< ToolIds_type, wchar_t > ToolIds_traits;

      const ToolIds_optional&
      ToolIds () const;

      ToolIds_optional&
      ToolIds ();

      void
      ToolIds (const ToolIds_type& x);

      void
      ToolIds (const ToolIds_optional& x);

      void
      ToolIds (::std::unique_ptr< ToolIds_type > p);

      // Constructors.
      //
      CarriageType ();

      CarriageType (const Name_type&,
                    const id_type&);

      CarriageType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      CarriageType (const CarriageType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual CarriageType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CarriageType&
      operator= (const CarriageType& x);

      virtual 
      ~CarriageType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ToolIds_optional ToolIds_;
    };

    class QIF30_SYMBOL_DECL CarriagesType: public ::xml_schema::type
    {
      public:
      // Carriage
      //
      typedef ::xsd::qif30::CarriageType Carriage_type;
      typedef ::xsd::cxx::tree::sequence< Carriage_type > Carriage_sequence;
      typedef xsd::cxx::tree::sequence< Carriage_type >::iterator Carriage_iterator;
      typedef xsd::cxx::tree::sequence< Carriage_type >::const_iterator Carriage_const_iterator;
      typedef ::xsd::cxx::tree::traits< Carriage_type, wchar_t > Carriage_traits;

      const Carriage_sequence&
      Carriage () const;

      Carriage_sequence&
      Carriage ();

      void
      Carriage (const Carriage_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      CarriagesType ();

      CarriagesType (const n_type&);

      CarriagesType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      CarriagesType (const CarriagesType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual CarriagesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CarriagesType&
      operator= (const CarriagesType& x);

      virtual 
      ~CarriagesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Carriage_sequence Carriage_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL FixturesType: public ::xml_schema::type
    {
      public:
      // Fixture
      //
      typedef ::xsd::qif30::FixtureType Fixture_type;
      typedef ::xsd::cxx::tree::sequence< Fixture_type > Fixture_sequence;
      typedef xsd::cxx::tree::sequence< Fixture_type >::iterator Fixture_iterator;
      typedef xsd::cxx::tree::sequence< Fixture_type >::const_iterator Fixture_const_iterator;
      typedef ::xsd::cxx::tree::traits< Fixture_type, wchar_t > Fixture_traits;

      const Fixture_sequence&
      Fixture () const;

      Fixture_sequence&
      Fixture ();

      void
      Fixture (const Fixture_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      FixturesType ();

      FixturesType (const n_type&);

      FixturesType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      FixturesType (const FixturesType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual FixturesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FixturesType&
      operator= (const FixturesType& x);

      virtual 
      ~FixturesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Fixture_sequence Fixture_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL MeasurementRoomType: public ::xsd::qif30::MeasurementResourceBaseType
    {
      public:
      // TemperatureRangeMin
      //
      typedef ::xsd::qif30::TemperatureType TemperatureRangeMin_type;
      typedef ::xsd::cxx::tree::traits< TemperatureRangeMin_type, wchar_t > TemperatureRangeMin_traits;

      const TemperatureRangeMin_type&
      TemperatureRangeMin () const;

      TemperatureRangeMin_type&
      TemperatureRangeMin ();

      void
      TemperatureRangeMin (const TemperatureRangeMin_type& x);

      void
      TemperatureRangeMin (::std::unique_ptr< TemperatureRangeMin_type > p);

      // TemperatureRangeMax
      //
      typedef ::xsd::qif30::TemperatureType TemperatureRangeMax_type;
      typedef ::xsd::cxx::tree::traits< TemperatureRangeMax_type, wchar_t > TemperatureRangeMax_traits;

      const TemperatureRangeMax_type&
      TemperatureRangeMax () const;

      TemperatureRangeMax_type&
      TemperatureRangeMax ();

      void
      TemperatureRangeMax (const TemperatureRangeMax_type& x);

      void
      TemperatureRangeMax (::std::unique_ptr< TemperatureRangeMax_type > p);

      // TemperatureControlMin
      //
      typedef ::xsd::qif30::TemperatureType TemperatureControlMin_type;
      typedef ::xsd::cxx::tree::traits< TemperatureControlMin_type, wchar_t > TemperatureControlMin_traits;

      const TemperatureControlMin_type&
      TemperatureControlMin () const;

      TemperatureControlMin_type&
      TemperatureControlMin ();

      void
      TemperatureControlMin (const TemperatureControlMin_type& x);

      void
      TemperatureControlMin (::std::unique_ptr< TemperatureControlMin_type > p);

      // TemperatureControlMax
      //
      typedef ::xsd::qif30::TemperatureType TemperatureControlMax_type;
      typedef ::xsd::cxx::tree::traits< TemperatureControlMax_type, wchar_t > TemperatureControlMax_traits;

      const TemperatureControlMax_type&
      TemperatureControlMax () const;

      TemperatureControlMax_type&
      TemperatureControlMax ();

      void
      TemperatureControlMax (const TemperatureControlMax_type& x);

      void
      TemperatureControlMax (::std::unique_ptr< TemperatureControlMax_type > p);

      // RelativeHumidityRangeMin
      //
      typedef ::xsd::qif30::FractionType RelativeHumidityRangeMin_type;
      typedef ::xsd::cxx::tree::traits< RelativeHumidityRangeMin_type, wchar_t > RelativeHumidityRangeMin_traits;

      const RelativeHumidityRangeMin_type&
      RelativeHumidityRangeMin () const;

      RelativeHumidityRangeMin_type&
      RelativeHumidityRangeMin ();

      void
      RelativeHumidityRangeMin (const RelativeHumidityRangeMin_type& x);

      void
      RelativeHumidityRangeMin (::std::unique_ptr< RelativeHumidityRangeMin_type > p);

      // RelativeHumidityRangeMax
      //
      typedef ::xsd::qif30::FractionType RelativeHumidityRangeMax_type;
      typedef ::xsd::cxx::tree::traits< RelativeHumidityRangeMax_type, wchar_t > RelativeHumidityRangeMax_traits;

      const RelativeHumidityRangeMax_type&
      RelativeHumidityRangeMax () const;

      RelativeHumidityRangeMax_type&
      RelativeHumidityRangeMax ();

      void
      RelativeHumidityRangeMax (const RelativeHumidityRangeMax_type& x);

      void
      RelativeHumidityRangeMax (::std::unique_ptr< RelativeHumidityRangeMax_type > p);

      // RelativeHumidityControlMin
      //
      typedef ::xsd::qif30::FractionType RelativeHumidityControlMin_type;
      typedef ::xsd::cxx::tree::traits< RelativeHumidityControlMin_type, wchar_t > RelativeHumidityControlMin_traits;

      const RelativeHumidityControlMin_type&
      RelativeHumidityControlMin () const;

      RelativeHumidityControlMin_type&
      RelativeHumidityControlMin ();

      void
      RelativeHumidityControlMin (const RelativeHumidityControlMin_type& x);

      void
      RelativeHumidityControlMin (::std::unique_ptr< RelativeHumidityControlMin_type > p);

      // RelativeHumidityControlMax
      //
      typedef ::xsd::qif30::FractionType RelativeHumidityControlMax_type;
      typedef ::xsd::cxx::tree::traits< RelativeHumidityControlMax_type, wchar_t > RelativeHumidityControlMax_traits;

      const RelativeHumidityControlMax_type&
      RelativeHumidityControlMax () const;

      RelativeHumidityControlMax_type&
      RelativeHumidityControlMax ();

      void
      RelativeHumidityControlMax (const RelativeHumidityControlMax_type& x);

      void
      RelativeHumidityControlMax (::std::unique_ptr< RelativeHumidityControlMax_type > p);

      // Constructors.
      //
      MeasurementRoomType ();

      MeasurementRoomType (const Name_type&,
                           const id_type&,
                           const TemperatureRangeMin_type&,
                           const TemperatureRangeMax_type&,
                           const TemperatureControlMin_type&,
                           const TemperatureControlMax_type&,
                           const RelativeHumidityRangeMin_type&,
                           const RelativeHumidityRangeMax_type&,
                           const RelativeHumidityControlMin_type&,
                           const RelativeHumidityControlMax_type&);

      MeasurementRoomType (const Name_type&,
                           const id_type&,
                           ::std::unique_ptr< TemperatureRangeMin_type >,
                           ::std::unique_ptr< TemperatureRangeMax_type >,
                           ::std::unique_ptr< TemperatureControlMin_type >,
                           ::std::unique_ptr< TemperatureControlMax_type >,
                           ::std::unique_ptr< RelativeHumidityRangeMin_type >,
                           ::std::unique_ptr< RelativeHumidityRangeMax_type >,
                           ::std::unique_ptr< RelativeHumidityControlMin_type >,
                           ::std::unique_ptr< RelativeHumidityControlMax_type >);

      MeasurementRoomType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      MeasurementRoomType (const MeasurementRoomType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual MeasurementRoomType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasurementRoomType&
      operator= (const MeasurementRoomType& x);

      virtual 
      ~MeasurementRoomType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< TemperatureRangeMin_type > TemperatureRangeMin_;
      ::xsd::cxx::tree::one< TemperatureRangeMax_type > TemperatureRangeMax_;
      ::xsd::cxx::tree::one< TemperatureControlMin_type > TemperatureControlMin_;
      ::xsd::cxx::tree::one< TemperatureControlMax_type > TemperatureControlMax_;
      ::xsd::cxx::tree::one< RelativeHumidityRangeMin_type > RelativeHumidityRangeMin_;
      ::xsd::cxx::tree::one< RelativeHumidityRangeMax_type > RelativeHumidityRangeMax_;
      ::xsd::cxx::tree::one< RelativeHumidityControlMin_type > RelativeHumidityControlMin_;
      ::xsd::cxx::tree::one< RelativeHumidityControlMax_type > RelativeHumidityControlMax_;
    };

    class QIF30_SYMBOL_DECL MeasurementRoomsType: public ::xml_schema::type
    {
      public:
      // MeasurementRoom
      //
      typedef ::xsd::qif30::MeasurementRoomType MeasurementRoom_type;
      typedef ::xsd::cxx::tree::sequence< MeasurementRoom_type > MeasurementRoom_sequence;
      typedef xsd::cxx::tree::sequence< MeasurementRoom_type >::iterator MeasurementRoom_iterator;
      typedef xsd::cxx::tree::sequence< MeasurementRoom_type >::const_iterator MeasurementRoom_const_iterator;
      typedef ::xsd::cxx::tree::traits< MeasurementRoom_type, wchar_t > MeasurementRoom_traits;

      const MeasurementRoom_sequence&
      MeasurementRoom () const;

      MeasurementRoom_sequence&
      MeasurementRoom ();

      void
      MeasurementRoom (const MeasurementRoom_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      MeasurementRoomsType ();

      MeasurementRoomsType (const n_type&);

      MeasurementRoomsType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      MeasurementRoomsType (const MeasurementRoomsType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual MeasurementRoomsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasurementRoomsType&
      operator= (const MeasurementRoomsType& x);

      virtual 
      ~MeasurementRoomsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MeasurementRoom_sequence MeasurementRoom_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL FixtureType: public ::xsd::qif30::MeasurementResourceBaseType
    {
      public:
      // Constructors.
      //
      FixtureType ();

      FixtureType (const Name_type&,
                   const id_type&);

      FixtureType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      FixtureType (const FixtureType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual FixtureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      FixtureType&
      operator= (const FixtureType&) = default;
#endif

      virtual 
      ~FixtureType ();
    };

    class QIF30_SYMBOL_DECL SensorType: public ::xsd::qif30::MeasurementResourceBaseType
    {
      public:
      // ProtectionClass
      //
      typedef ::xml_schema::string ProtectionClass_type;
      typedef ::xsd::cxx::tree::optional< ProtectionClass_type > ProtectionClass_optional;
      typedef ::xsd::cxx::tree::traits< ProtectionClass_type, wchar_t > ProtectionClass_traits;

      const ProtectionClass_optional&
      ProtectionClass () const;

      ProtectionClass_optional&
      ProtectionClass ();

      void
      ProtectionClass (const ProtectionClass_type& x);

      void
      ProtectionClass (const ProtectionClass_optional& x);

      void
      ProtectionClass (::std::unique_ptr< ProtectionClass_type > p);

      // LinearityError
      //
      typedef ::xml_schema::string LinearityError_type;
      typedef ::xsd::cxx::tree::optional< LinearityError_type > LinearityError_optional;
      typedef ::xsd::cxx::tree::traits< LinearityError_type, wchar_t > LinearityError_traits;

      const LinearityError_optional&
      LinearityError () const;

      LinearityError_optional&
      LinearityError ();

      void
      LinearityError (const LinearityError_type& x);

      void
      LinearityError (const LinearityError_optional& x);

      void
      LinearityError (::std::unique_ptr< LinearityError_type > p);

      // Repeatability
      //
      typedef ::xsd::qif30::LinearValueType Repeatability_type;
      typedef ::xsd::cxx::tree::optional< Repeatability_type > Repeatability_optional;
      typedef ::xsd::cxx::tree::traits< Repeatability_type, wchar_t > Repeatability_traits;

      const Repeatability_optional&
      Repeatability () const;

      Repeatability_optional&
      Repeatability ();

      void
      Repeatability (const Repeatability_type& x);

      void
      Repeatability (const Repeatability_optional& x);

      void
      Repeatability (::std::unique_ptr< Repeatability_type > p);

      // Sensitivity
      //
      typedef ::xml_schema::decimal Sensitivity_type;
      typedef ::xsd::cxx::tree::optional< Sensitivity_type > Sensitivity_optional;
      typedef ::xsd::cxx::tree::traits< Sensitivity_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > Sensitivity_traits;

      const Sensitivity_optional&
      Sensitivity () const;

      Sensitivity_optional&
      Sensitivity ();

      void
      Sensitivity (const Sensitivity_type& x);

      void
      Sensitivity (const Sensitivity_optional& x);

      // Resolution
      //
      typedef ::xsd::qif30::LinearValueType Resolution_type;
      typedef ::xsd::cxx::tree::optional< Resolution_type > Resolution_optional;
      typedef ::xsd::cxx::tree::traits< Resolution_type, wchar_t > Resolution_traits;

      const Resolution_optional&
      Resolution () const;

      Resolution_optional&
      Resolution ();

      void
      Resolution (const Resolution_type& x);

      void
      Resolution (const Resolution_optional& x);

      void
      Resolution (::std::unique_ptr< Resolution_type > p);

      // EnvironmentalRange
      //
      typedef ::xsd::qif30::EnvironmentalRangeType EnvironmentalRange_type;
      typedef ::xsd::cxx::tree::optional< EnvironmentalRange_type > EnvironmentalRange_optional;
      typedef ::xsd::cxx::tree::traits< EnvironmentalRange_type, wchar_t > EnvironmentalRange_traits;

      const EnvironmentalRange_optional&
      EnvironmentalRange () const;

      EnvironmentalRange_optional&
      EnvironmentalRange ();

      void
      EnvironmentalRange (const EnvironmentalRange_type& x);

      void
      EnvironmentalRange (const EnvironmentalRange_optional& x);

      void
      EnvironmentalRange (::std::unique_ptr< EnvironmentalRange_type > p);

      // Constructors.
      //
      SensorType ();

      SensorType (const Name_type&,
                  const id_type&);

      SensorType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      SensorType (const SensorType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual SensorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SensorType&
      operator= (const SensorType& x);

      virtual 
      ~SensorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ProtectionClass_optional ProtectionClass_;
      LinearityError_optional LinearityError_;
      Repeatability_optional Repeatability_;
      Sensitivity_optional Sensitivity_;
      Resolution_optional Resolution_;
      EnvironmentalRange_optional EnvironmentalRange_;
    };

    class QIF30_SYMBOL_DECL LaserType: public ::xsd::qif30::MeasurementResourceBaseType
    {
      public:
      // LaserSource
      //
      typedef ::xml_schema::string LaserSource_type;
      typedef ::xsd::cxx::tree::optional< LaserSource_type > LaserSource_optional;
      typedef ::xsd::cxx::tree::traits< LaserSource_type, wchar_t > LaserSource_traits;

      const LaserSource_optional&
      LaserSource () const;

      LaserSource_optional&
      LaserSource ();

      void
      LaserSource (const LaserSource_type& x);

      void
      LaserSource (const LaserSource_optional& x);

      void
      LaserSource (::std::unique_ptr< LaserSource_type > p);

      // LaserWaveLength
      //
      typedef ::xsd::qif30::LinearValueType LaserWaveLength_type;
      typedef ::xsd::cxx::tree::optional< LaserWaveLength_type > LaserWaveLength_optional;
      typedef ::xsd::cxx::tree::traits< LaserWaveLength_type, wchar_t > LaserWaveLength_traits;

      const LaserWaveLength_optional&
      LaserWaveLength () const;

      LaserWaveLength_optional&
      LaserWaveLength ();

      void
      LaserWaveLength (const LaserWaveLength_type& x);

      void
      LaserWaveLength (const LaserWaveLength_optional& x);

      void
      LaserWaveLength (::std::unique_ptr< LaserWaveLength_type > p);

      // LaserPower
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType LaserPower_type;
      typedef ::xsd::cxx::tree::optional< LaserPower_type > LaserPower_optional;
      typedef ::xsd::cxx::tree::traits< LaserPower_type, wchar_t > LaserPower_traits;

      const LaserPower_optional&
      LaserPower () const;

      LaserPower_optional&
      LaserPower ();

      void
      LaserPower (const LaserPower_type& x);

      void
      LaserPower (const LaserPower_optional& x);

      void
      LaserPower (::std::unique_ptr< LaserPower_type > p);

      // LaserSafetyClass
      //
      typedef ::xml_schema::string LaserSafetyClass_type;
      typedef ::xsd::cxx::tree::optional< LaserSafetyClass_type > LaserSafetyClass_optional;
      typedef ::xsd::cxx::tree::traits< LaserSafetyClass_type, wchar_t > LaserSafetyClass_traits;

      const LaserSafetyClass_optional&
      LaserSafetyClass () const;

      LaserSafetyClass_optional&
      LaserSafetyClass ();

      void
      LaserSafetyClass (const LaserSafetyClass_type& x);

      void
      LaserSafetyClass (const LaserSafetyClass_optional& x);

      void
      LaserSafetyClass (::std::unique_ptr< LaserSafetyClass_type > p);

      // LaserEffectiveLength
      //
      typedef ::xsd::qif30::LinearValueType LaserEffectiveLength_type;
      typedef ::xsd::cxx::tree::optional< LaserEffectiveLength_type > LaserEffectiveLength_optional;
      typedef ::xsd::cxx::tree::traits< LaserEffectiveLength_type, wchar_t > LaserEffectiveLength_traits;

      const LaserEffectiveLength_optional&
      LaserEffectiveLength () const;

      LaserEffectiveLength_optional&
      LaserEffectiveLength ();

      void
      LaserEffectiveLength (const LaserEffectiveLength_type& x);

      void
      LaserEffectiveLength (const LaserEffectiveLength_optional& x);

      void
      LaserEffectiveLength (::std::unique_ptr< LaserEffectiveLength_type > p);

      // LaserSpotSize
      //
      typedef ::xsd::qif30::LinearValueType LaserSpotSize_type;
      typedef ::xsd::cxx::tree::optional< LaserSpotSize_type > LaserSpotSize_optional;
      typedef ::xsd::cxx::tree::traits< LaserSpotSize_type, wchar_t > LaserSpotSize_traits;

      const LaserSpotSize_optional&
      LaserSpotSize () const;

      LaserSpotSize_optional&
      LaserSpotSize ();

      void
      LaserSpotSize (const LaserSpotSize_type& x);

      void
      LaserSpotSize (const LaserSpotSize_optional& x);

      void
      LaserSpotSize (::std::unique_ptr< LaserSpotSize_type > p);

      // LaserPowerSupply
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType LaserPowerSupply_type;
      typedef ::xsd::cxx::tree::optional< LaserPowerSupply_type > LaserPowerSupply_optional;
      typedef ::xsd::cxx::tree::traits< LaserPowerSupply_type, wchar_t > LaserPowerSupply_traits;

      const LaserPowerSupply_optional&
      LaserPowerSupply () const;

      LaserPowerSupply_optional&
      LaserPowerSupply ();

      void
      LaserPowerSupply (const LaserPowerSupply_type& x);

      void
      LaserPowerSupply (const LaserPowerSupply_optional& x);

      void
      LaserPowerSupply (::std::unique_ptr< LaserPowerSupply_type > p);

      // Constructors.
      //
      LaserType ();

      LaserType (const Name_type&,
                 const id_type&);

      LaserType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      LaserType (const LaserType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual LaserType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LaserType&
      operator= (const LaserType& x);

      virtual 
      ~LaserType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      LaserSource_optional LaserSource_;
      LaserWaveLength_optional LaserWaveLength_;
      LaserPower_optional LaserPower_;
      LaserSafetyClass_optional LaserSafetyClass_;
      LaserEffectiveLength_optional LaserEffectiveLength_;
      LaserSpotSize_optional LaserSpotSize_;
      LaserPowerSupply_optional LaserPowerSupply_;
    };

    class QIF30_SYMBOL_DECL DetachableSensorBaseType: public ::xsd::qif30::SensorType
    {
      public:
      // Constructors.
      //
      DetachableSensorBaseType ();

      DetachableSensorBaseType (const Name_type&,
                                const id_type&);

      DetachableSensorBaseType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      DetachableSensorBaseType (const DetachableSensorBaseType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual DetachableSensorBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      DetachableSensorBaseType&
      operator= (const DetachableSensorBaseType&) = default;
#endif

      virtual 
      ~DetachableSensorBaseType ();
    };

    class QIF30_SYMBOL_DECL DetachableSensorsType: public ::xml_schema::type
    {
      public:
      // DetachableSensor
      //
      typedef ::xsd::qif30::DetachableSensorBaseType DetachableSensor_type;
      typedef ::xsd::cxx::tree::sequence< DetachableSensor_type > DetachableSensor_sequence;
      typedef xsd::cxx::tree::sequence< DetachableSensor_type >::iterator DetachableSensor_iterator;
      typedef xsd::cxx::tree::sequence< DetachableSensor_type >::const_iterator DetachableSensor_const_iterator;
      typedef ::xsd::cxx::tree::traits< DetachableSensor_type, wchar_t > DetachableSensor_traits;

      const DetachableSensor_sequence&
      DetachableSensor () const;

      DetachableSensor_sequence&
      DetachableSensor ();

      void
      DetachableSensor (const DetachableSensor_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      DetachableSensorsType ();

      DetachableSensorsType (const n_type&);

      DetachableSensorsType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      DetachableSensorsType (const DetachableSensorsType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual DetachableSensorsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DetachableSensorsType&
      operator= (const DetachableSensorsType& x);

      virtual 
      ~DetachableSensorsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      DetachableSensor_sequence DetachableSensor_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ToolsType: public ::xml_schema::type
    {
      public:
      // Tool
      //
      typedef ::xsd::qif30::ToolBaseType Tool_type;
      typedef ::xsd::cxx::tree::sequence< Tool_type > Tool_sequence;
      typedef xsd::cxx::tree::sequence< Tool_type >::iterator Tool_iterator;
      typedef xsd::cxx::tree::sequence< Tool_type >::const_iterator Tool_const_iterator;
      typedef ::xsd::cxx::tree::traits< Tool_type, wchar_t > Tool_traits;

      const Tool_sequence&
      Tool () const;

      Tool_sequence&
      Tool ();

      void
      Tool (const Tool_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      ToolsType ();

      ToolsType (const n_type&);

      ToolsType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      ToolsType (const ToolsType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual ToolsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToolsType&
      operator= (const ToolsType& x);

      virtual 
      ~ToolsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Tool_sequence Tool_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ToolBaseType: public ::xsd::qif30::MeasurementResourceBaseType
    {
      public:
      // Constructors.
      //
      ToolBaseType ();

      ToolBaseType (const Name_type&,
                    const id_type&);

      ToolBaseType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      ToolBaseType (const ToolBaseType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual ToolBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      ToolBaseType&
      operator= (const ToolBaseType&) = default;
#endif

      virtual 
      ~ToolBaseType ();
    };

    class QIF30_SYMBOL_DECL ToolWithIntegratedSensorBaseType: public ::xsd::qif30::ToolBaseType
    {
      public:
      // Constructors.
      //
      ToolWithIntegratedSensorBaseType ();

      ToolWithIntegratedSensorBaseType (const Name_type&,
                                        const id_type&);

      ToolWithIntegratedSensorBaseType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      ToolWithIntegratedSensorBaseType (const ToolWithIntegratedSensorBaseType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual ToolWithIntegratedSensorBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      ToolWithIntegratedSensorBaseType&
      operator= (const ToolWithIntegratedSensorBaseType&) = default;
#endif

      virtual 
      ~ToolWithIntegratedSensorBaseType ();
    };

    class QIF30_SYMBOL_DECL ToolWithLVDTSensorType: public ::xsd::qif30::ToolWithIntegratedSensorBaseType
    {
      public:
      // LVDTSensor
      //
      typedef ::xsd::qif30::LinearVariableDifferentialTransformerSensorType LVDTSensor_type;
      typedef ::xsd::cxx::tree::traits< LVDTSensor_type, wchar_t > LVDTSensor_traits;

      const LVDTSensor_type&
      LVDTSensor () const;

      LVDTSensor_type&
      LVDTSensor ();

      void
      LVDTSensor (const LVDTSensor_type& x);

      void
      LVDTSensor (::std::unique_ptr< LVDTSensor_type > p);

      // Constructors.
      //
      ToolWithLVDTSensorType ();

      ToolWithLVDTSensorType (const Name_type&,
                              const id_type&,
                              const LVDTSensor_type&);

      ToolWithLVDTSensorType (const Name_type&,
                              const id_type&,
                              ::std::unique_ptr< LVDTSensor_type >);

      ToolWithLVDTSensorType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      ToolWithLVDTSensorType (const ToolWithLVDTSensorType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual ToolWithLVDTSensorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToolWithLVDTSensorType&
      operator= (const ToolWithLVDTSensorType& x);

      virtual 
      ~ToolWithLVDTSensorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< LVDTSensor_type > LVDTSensor_;
    };

    class QIF30_SYMBOL_DECL ToolWithCapacitiveSensorType: public ::xsd::qif30::ToolWithIntegratedSensorBaseType
    {
      public:
      // CapacitiveSensor
      //
      typedef ::xsd::qif30::CapacitiveSensorType CapacitiveSensor_type;
      typedef ::xsd::cxx::tree::traits< CapacitiveSensor_type, wchar_t > CapacitiveSensor_traits;

      const CapacitiveSensor_type&
      CapacitiveSensor () const;

      CapacitiveSensor_type&
      CapacitiveSensor ();

      void
      CapacitiveSensor (const CapacitiveSensor_type& x);

      void
      CapacitiveSensor (::std::unique_ptr< CapacitiveSensor_type > p);

      // Constructors.
      //
      ToolWithCapacitiveSensorType ();

      ToolWithCapacitiveSensorType (const Name_type&,
                                    const id_type&,
                                    const CapacitiveSensor_type&);

      ToolWithCapacitiveSensorType (const Name_type&,
                                    const id_type&,
                                    ::std::unique_ptr< CapacitiveSensor_type >);

      ToolWithCapacitiveSensorType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      ToolWithCapacitiveSensorType (const ToolWithCapacitiveSensorType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual ToolWithCapacitiveSensorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToolWithCapacitiveSensorType&
      operator= (const ToolWithCapacitiveSensorType& x);

      virtual 
      ~ToolWithCapacitiveSensorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< CapacitiveSensor_type > CapacitiveSensor_;
    };

    class QIF30_SYMBOL_DECL ToolWithEddyCurrentSensorType: public ::xsd::qif30::ToolWithIntegratedSensorBaseType
    {
      public:
      // EddyCurrentSensor
      //
      typedef ::xsd::qif30::EddyCurrentSensorType EddyCurrentSensor_type;
      typedef ::xsd::cxx::tree::traits< EddyCurrentSensor_type, wchar_t > EddyCurrentSensor_traits;

      const EddyCurrentSensor_type&
      EddyCurrentSensor () const;

      EddyCurrentSensor_type&
      EddyCurrentSensor ();

      void
      EddyCurrentSensor (const EddyCurrentSensor_type& x);

      void
      EddyCurrentSensor (::std::unique_ptr< EddyCurrentSensor_type > p);

      // Constructors.
      //
      ToolWithEddyCurrentSensorType ();

      ToolWithEddyCurrentSensorType (const Name_type&,
                                     const id_type&,
                                     const EddyCurrentSensor_type&);

      ToolWithEddyCurrentSensorType (const Name_type&,
                                     const id_type&,
                                     ::std::unique_ptr< EddyCurrentSensor_type >);

      ToolWithEddyCurrentSensorType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      ToolWithEddyCurrentSensorType (const ToolWithEddyCurrentSensorType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual ToolWithEddyCurrentSensorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToolWithEddyCurrentSensorType&
      operator= (const ToolWithEddyCurrentSensorType& x);

      virtual 
      ~ToolWithEddyCurrentSensorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< EddyCurrentSensor_type > EddyCurrentSensor_;
    };

    class QIF30_SYMBOL_DECL ToolWithConfocalChromaticSensorType: public ::xsd::qif30::ToolWithIntegratedSensorBaseType
    {
      public:
      // ConfocalChromaticSensor
      //
      typedef ::xsd::qif30::ConfocalChromaticSensorType ConfocalChromaticSensor_type;
      typedef ::xsd::cxx::tree::traits< ConfocalChromaticSensor_type, wchar_t > ConfocalChromaticSensor_traits;

      const ConfocalChromaticSensor_type&
      ConfocalChromaticSensor () const;

      ConfocalChromaticSensor_type&
      ConfocalChromaticSensor ();

      void
      ConfocalChromaticSensor (const ConfocalChromaticSensor_type& x);

      void
      ConfocalChromaticSensor (::std::unique_ptr< ConfocalChromaticSensor_type > p);

      // Constructors.
      //
      ToolWithConfocalChromaticSensorType ();

      ToolWithConfocalChromaticSensorType (const Name_type&,
                                           const id_type&,
                                           const ConfocalChromaticSensor_type&);

      ToolWithConfocalChromaticSensorType (const Name_type&,
                                           const id_type&,
                                           ::std::unique_ptr< ConfocalChromaticSensor_type >);

      ToolWithConfocalChromaticSensorType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      ToolWithConfocalChromaticSensorType (const ToolWithConfocalChromaticSensorType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual ToolWithConfocalChromaticSensorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToolWithConfocalChromaticSensorType&
      operator= (const ToolWithConfocalChromaticSensorType& x);

      virtual 
      ~ToolWithConfocalChromaticSensorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ConfocalChromaticSensor_type > ConfocalChromaticSensor_;
    };

    class QIF30_SYMBOL_DECL ToolWithDrawWireSensorType: public ::xsd::qif30::ToolWithIntegratedSensorBaseType
    {
      public:
      // DrawWireSensor
      //
      typedef ::xsd::qif30::DrawWireSensorType DrawWireSensor_type;
      typedef ::xsd::cxx::tree::traits< DrawWireSensor_type, wchar_t > DrawWireSensor_traits;

      const DrawWireSensor_type&
      DrawWireSensor () const;

      DrawWireSensor_type&
      DrawWireSensor ();

      void
      DrawWireSensor (const DrawWireSensor_type& x);

      void
      DrawWireSensor (::std::unique_ptr< DrawWireSensor_type > p);

      // Constructors.
      //
      ToolWithDrawWireSensorType ();

      ToolWithDrawWireSensorType (const Name_type&,
                                  const id_type&,
                                  const DrawWireSensor_type&);

      ToolWithDrawWireSensorType (const Name_type&,
                                  const id_type&,
                                  ::std::unique_ptr< DrawWireSensor_type >);

      ToolWithDrawWireSensorType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      ToolWithDrawWireSensorType (const ToolWithDrawWireSensorType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual ToolWithDrawWireSensorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToolWithDrawWireSensorType&
      operator= (const ToolWithDrawWireSensorType& x);

      virtual 
      ~ToolWithDrawWireSensorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DrawWireSensor_type > DrawWireSensor_;
    };

    class QIF30_SYMBOL_DECL ToolWithMagnetoInductiveSensorType: public ::xsd::qif30::ToolWithIntegratedSensorBaseType
    {
      public:
      // MagnetoInductiveSensor
      //
      typedef ::xsd::qif30::MagnetoInductiveSensorType MagnetoInductiveSensor_type;
      typedef ::xsd::cxx::tree::traits< MagnetoInductiveSensor_type, wchar_t > MagnetoInductiveSensor_traits;

      const MagnetoInductiveSensor_type&
      MagnetoInductiveSensor () const;

      MagnetoInductiveSensor_type&
      MagnetoInductiveSensor ();

      void
      MagnetoInductiveSensor (const MagnetoInductiveSensor_type& x);

      void
      MagnetoInductiveSensor (::std::unique_ptr< MagnetoInductiveSensor_type > p);

      // Constructors.
      //
      ToolWithMagnetoInductiveSensorType ();

      ToolWithMagnetoInductiveSensorType (const Name_type&,
                                          const id_type&,
                                          const MagnetoInductiveSensor_type&);

      ToolWithMagnetoInductiveSensorType (const Name_type&,
                                          const id_type&,
                                          ::std::unique_ptr< MagnetoInductiveSensor_type >);

      ToolWithMagnetoInductiveSensorType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      ToolWithMagnetoInductiveSensorType (const ToolWithMagnetoInductiveSensorType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual ToolWithMagnetoInductiveSensorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToolWithMagnetoInductiveSensorType&
      operator= (const ToolWithMagnetoInductiveSensorType& x);

      virtual 
      ~ToolWithMagnetoInductiveSensorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< MagnetoInductiveSensor_type > MagnetoInductiveSensor_;
    };

    class QIF30_SYMBOL_DECL ToolWithDVRTSensorType: public ::xsd::qif30::ToolWithIntegratedSensorBaseType
    {
      public:
      // DVRTSensor
      //
      typedef ::xsd::qif30::DifferentialVariableReluctanceTransducerSensorType DVRTSensor_type;
      typedef ::xsd::cxx::tree::traits< DVRTSensor_type, wchar_t > DVRTSensor_traits;

      const DVRTSensor_type&
      DVRTSensor () const;

      DVRTSensor_type&
      DVRTSensor ();

      void
      DVRTSensor (const DVRTSensor_type& x);

      void
      DVRTSensor (::std::unique_ptr< DVRTSensor_type > p);

      // Constructors.
      //
      ToolWithDVRTSensorType ();

      ToolWithDVRTSensorType (const Name_type&,
                              const id_type&,
                              const DVRTSensor_type&);

      ToolWithDVRTSensorType (const Name_type&,
                              const id_type&,
                              ::std::unique_ptr< DVRTSensor_type >);

      ToolWithDVRTSensorType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      ToolWithDVRTSensorType (const ToolWithDVRTSensorType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual ToolWithDVRTSensorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToolWithDVRTSensorType&
      operator= (const ToolWithDVRTSensorType& x);

      virtual 
      ~ToolWithDVRTSensorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DVRTSensor_type > DVRTSensor_;
    };

    class QIF30_SYMBOL_DECL ToolWithLaserTriangulationSensorType: public ::xsd::qif30::ToolWithIntegratedSensorBaseType
    {
      public:
      // LaserTriangulationSensor
      //
      typedef ::xsd::qif30::LaserTriangulationSensorType LaserTriangulationSensor_type;
      typedef ::xsd::cxx::tree::traits< LaserTriangulationSensor_type, wchar_t > LaserTriangulationSensor_traits;

      const LaserTriangulationSensor_type&
      LaserTriangulationSensor () const;

      LaserTriangulationSensor_type&
      LaserTriangulationSensor ();

      void
      LaserTriangulationSensor (const LaserTriangulationSensor_type& x);

      void
      LaserTriangulationSensor (::std::unique_ptr< LaserTriangulationSensor_type > p);

      // Constructors.
      //
      ToolWithLaserTriangulationSensorType ();

      ToolWithLaserTriangulationSensorType (const Name_type&,
                                            const id_type&,
                                            const LaserTriangulationSensor_type&);

      ToolWithLaserTriangulationSensorType (const Name_type&,
                                            const id_type&,
                                            ::std::unique_ptr< LaserTriangulationSensor_type >);

      ToolWithLaserTriangulationSensorType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      ToolWithLaserTriangulationSensorType (const ToolWithLaserTriangulationSensorType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual ToolWithLaserTriangulationSensorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToolWithLaserTriangulationSensorType&
      operator= (const ToolWithLaserTriangulationSensorType& x);

      virtual 
      ~ToolWithLaserTriangulationSensorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< LaserTriangulationSensor_type > LaserTriangulationSensor_;
    };

    class QIF30_SYMBOL_DECL ToolWithStructuredLightSensorType: public ::xsd::qif30::ToolWithIntegratedSensorBaseType
    {
      public:
      // StructuredLightSensor
      //
      typedef ::xsd::qif30::StructuredLightSensorType StructuredLightSensor_type;
      typedef ::xsd::cxx::tree::traits< StructuredLightSensor_type, wchar_t > StructuredLightSensor_traits;

      const StructuredLightSensor_type&
      StructuredLightSensor () const;

      StructuredLightSensor_type&
      StructuredLightSensor ();

      void
      StructuredLightSensor (const StructuredLightSensor_type& x);

      void
      StructuredLightSensor (::std::unique_ptr< StructuredLightSensor_type > p);

      // Constructors.
      //
      ToolWithStructuredLightSensorType ();

      ToolWithStructuredLightSensorType (const Name_type&,
                                         const id_type&,
                                         const StructuredLightSensor_type&);

      ToolWithStructuredLightSensorType (const Name_type&,
                                         const id_type&,
                                         ::std::unique_ptr< StructuredLightSensor_type >);

      ToolWithStructuredLightSensorType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      ToolWithStructuredLightSensorType (const ToolWithStructuredLightSensorType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual ToolWithStructuredLightSensorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToolWithStructuredLightSensorType&
      operator= (const ToolWithStructuredLightSensorType& x);

      virtual 
      ~ToolWithStructuredLightSensorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< StructuredLightSensor_type > StructuredLightSensor_;
    };

    class QIF30_SYMBOL_DECL ToolWithUltrasonicSensorType: public ::xsd::qif30::ToolWithIntegratedSensorBaseType
    {
      public:
      // UltrasonicSensor
      //
      typedef ::xsd::qif30::UltrasonicSensorType UltrasonicSensor_type;
      typedef ::xsd::cxx::tree::traits< UltrasonicSensor_type, wchar_t > UltrasonicSensor_traits;

      const UltrasonicSensor_type&
      UltrasonicSensor () const;

      UltrasonicSensor_type&
      UltrasonicSensor ();

      void
      UltrasonicSensor (const UltrasonicSensor_type& x);

      void
      UltrasonicSensor (::std::unique_ptr< UltrasonicSensor_type > p);

      // Constructors.
      //
      ToolWithUltrasonicSensorType ();

      ToolWithUltrasonicSensorType (const Name_type&,
                                    const id_type&,
                                    const UltrasonicSensor_type&);

      ToolWithUltrasonicSensorType (const Name_type&,
                                    const id_type&,
                                    ::std::unique_ptr< UltrasonicSensor_type >);

      ToolWithUltrasonicSensorType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      ToolWithUltrasonicSensorType (const ToolWithUltrasonicSensorType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual ToolWithUltrasonicSensorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToolWithUltrasonicSensorType&
      operator= (const ToolWithUltrasonicSensorType& x);

      virtual 
      ~ToolWithUltrasonicSensorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< UltrasonicSensor_type > UltrasonicSensor_;
    };

    class QIF30_SYMBOL_DECL ToolWithSimpleTactileProbeSensorType: public ::xsd::qif30::ToolWithIntegratedSensorBaseType
    {
      public:
      // SimpleTactileProbeSensor
      //
      typedef ::xsd::qif30::SimpleTactileProbeSensorType SimpleTactileProbeSensor_type;
      typedef ::xsd::cxx::tree::traits< SimpleTactileProbeSensor_type, wchar_t > SimpleTactileProbeSensor_traits;

      const SimpleTactileProbeSensor_type&
      SimpleTactileProbeSensor () const;

      SimpleTactileProbeSensor_type&
      SimpleTactileProbeSensor ();

      void
      SimpleTactileProbeSensor (const SimpleTactileProbeSensor_type& x);

      void
      SimpleTactileProbeSensor (::std::unique_ptr< SimpleTactileProbeSensor_type > p);

      // Constructors.
      //
      ToolWithSimpleTactileProbeSensorType ();

      ToolWithSimpleTactileProbeSensorType (const Name_type&,
                                            const id_type&,
                                            const SimpleTactileProbeSensor_type&);

      ToolWithSimpleTactileProbeSensorType (const Name_type&,
                                            const id_type&,
                                            ::std::unique_ptr< SimpleTactileProbeSensor_type >);

      ToolWithSimpleTactileProbeSensorType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      ToolWithSimpleTactileProbeSensorType (const ToolWithSimpleTactileProbeSensorType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual ToolWithSimpleTactileProbeSensorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToolWithSimpleTactileProbeSensorType&
      operator= (const ToolWithSimpleTactileProbeSensorType& x);

      virtual 
      ~ToolWithSimpleTactileProbeSensorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SimpleTactileProbeSensor_type > SimpleTactileProbeSensor_;
    };

    class QIF30_SYMBOL_DECL ToolWithComplexTactileProbeSensorType: public ::xsd::qif30::ToolWithIntegratedSensorBaseType
    {
      public:
      // ComplexTactileProbeSensor
      //
      typedef ::xsd::qif30::ComplexTactileProbeSensorType ComplexTactileProbeSensor_type;
      typedef ::xsd::cxx::tree::traits< ComplexTactileProbeSensor_type, wchar_t > ComplexTactileProbeSensor_traits;

      const ComplexTactileProbeSensor_type&
      ComplexTactileProbeSensor () const;

      ComplexTactileProbeSensor_type&
      ComplexTactileProbeSensor ();

      void
      ComplexTactileProbeSensor (const ComplexTactileProbeSensor_type& x);

      void
      ComplexTactileProbeSensor (::std::unique_ptr< ComplexTactileProbeSensor_type > p);

      // Constructors.
      //
      ToolWithComplexTactileProbeSensorType ();

      ToolWithComplexTactileProbeSensorType (const Name_type&,
                                             const id_type&,
                                             const ComplexTactileProbeSensor_type&);

      ToolWithComplexTactileProbeSensorType (const Name_type&,
                                             const id_type&,
                                             ::std::unique_ptr< ComplexTactileProbeSensor_type >);

      ToolWithComplexTactileProbeSensorType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      ToolWithComplexTactileProbeSensorType (const ToolWithComplexTactileProbeSensorType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual ToolWithComplexTactileProbeSensorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToolWithComplexTactileProbeSensorType&
      operator= (const ToolWithComplexTactileProbeSensorType& x);

      virtual 
      ~ToolWithComplexTactileProbeSensorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ComplexTactileProbeSensor_type > ComplexTactileProbeSensor_;
    };

    class QIF30_SYMBOL_DECL ToolWithCCDCameraSensorType: public ::xsd::qif30::ToolWithIntegratedSensorBaseType
    {
      public:
      // ChargeCoupledDeviceCameraSensor
      //
      typedef ::xsd::qif30::ChargeCoupledDeviceCameraSensorType ChargeCoupledDeviceCameraSensor_type;
      typedef ::xsd::cxx::tree::traits< ChargeCoupledDeviceCameraSensor_type, wchar_t > ChargeCoupledDeviceCameraSensor_traits;

      const ChargeCoupledDeviceCameraSensor_type&
      ChargeCoupledDeviceCameraSensor () const;

      ChargeCoupledDeviceCameraSensor_type&
      ChargeCoupledDeviceCameraSensor ();

      void
      ChargeCoupledDeviceCameraSensor (const ChargeCoupledDeviceCameraSensor_type& x);

      void
      ChargeCoupledDeviceCameraSensor (::std::unique_ptr< ChargeCoupledDeviceCameraSensor_type > p);

      // Constructors.
      //
      ToolWithCCDCameraSensorType ();

      ToolWithCCDCameraSensorType (const Name_type&,
                                   const id_type&,
                                   const ChargeCoupledDeviceCameraSensor_type&);

      ToolWithCCDCameraSensorType (const Name_type&,
                                   const id_type&,
                                   ::std::unique_ptr< ChargeCoupledDeviceCameraSensor_type >);

      ToolWithCCDCameraSensorType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      ToolWithCCDCameraSensorType (const ToolWithCCDCameraSensorType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual ToolWithCCDCameraSensorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToolWithCCDCameraSensorType&
      operator= (const ToolWithCCDCameraSensorType& x);

      virtual 
      ~ToolWithCCDCameraSensorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ChargeCoupledDeviceCameraSensor_type > ChargeCoupledDeviceCameraSensor_;
    };

    class QIF30_SYMBOL_DECL ToolWithDetachableSensorsType: public ::xsd::qif30::ToolBaseType
    {
      public:
      // SensorIds
      //
      typedef ::xsd::qif30::ArrayReferenceType SensorIds_type;
      typedef ::xsd::cxx::tree::optional< SensorIds_type > SensorIds_optional;
      typedef ::xsd::cxx::tree::traits< SensorIds_type, wchar_t > SensorIds_traits;

      const SensorIds_optional&
      SensorIds () const;

      SensorIds_optional&
      SensorIds ();

      void
      SensorIds (const SensorIds_type& x);

      void
      SensorIds (const SensorIds_optional& x);

      void
      SensorIds (::std::unique_ptr< SensorIds_type > p);

      // Constructors.
      //
      ToolWithDetachableSensorsType ();

      ToolWithDetachableSensorsType (const Name_type&,
                                     const id_type&);

      ToolWithDetachableSensorsType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      ToolWithDetachableSensorsType (const ToolWithDetachableSensorsType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual ToolWithDetachableSensorsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToolWithDetachableSensorsType&
      operator= (const ToolWithDetachableSensorsType& x);

      virtual 
      ~ToolWithDetachableSensorsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      SensorIds_optional SensorIds_;
    };

    class QIF30_SYMBOL_DECL MeasurementDevicesType: public ::xml_schema::type
    {
      public:
      // MeasurementDevice
      //
      typedef ::xsd::qif30::MeasurementDeviceType MeasurementDevice_type;
      typedef ::xsd::cxx::tree::sequence< MeasurementDevice_type > MeasurementDevice_sequence;
      typedef xsd::cxx::tree::sequence< MeasurementDevice_type >::iterator MeasurementDevice_iterator;
      typedef xsd::cxx::tree::sequence< MeasurementDevice_type >::const_iterator MeasurementDevice_const_iterator;
      typedef ::xsd::cxx::tree::traits< MeasurementDevice_type, wchar_t > MeasurementDevice_traits;

      const MeasurementDevice_sequence&
      MeasurementDevice () const;

      MeasurementDevice_sequence&
      MeasurementDevice ();

      void
      MeasurementDevice (const MeasurementDevice_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      MeasurementDevicesType ();

      MeasurementDevicesType (const n_type&);

      MeasurementDevicesType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      MeasurementDevicesType (const MeasurementDevicesType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual MeasurementDevicesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasurementDevicesType&
      operator= (const MeasurementDevicesType& x);

      virtual 
      ~MeasurementDevicesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MeasurementDevice_sequence MeasurementDevice_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL MeasurementDeviceType: public ::xsd::qif30::MeasurementResourceBaseType
    {
      public:
      // Calibrations
      //
      typedef ::xsd::qif30::CalibrationsType Calibrations_type;
      typedef ::xsd::cxx::tree::optional< Calibrations_type > Calibrations_optional;
      typedef ::xsd::cxx::tree::traits< Calibrations_type, wchar_t > Calibrations_traits;

      const Calibrations_optional&
      Calibrations () const;

      Calibrations_optional&
      Calibrations ();

      void
      Calibrations (const Calibrations_type& x);

      void
      Calibrations (const Calibrations_optional& x);

      void
      Calibrations (::std::unique_ptr< Calibrations_type > p);

      // EnvironmentalRange
      //
      typedef ::xsd::qif30::EnvironmentalRangeType EnvironmentalRange_type;
      typedef ::xsd::cxx::tree::optional< EnvironmentalRange_type > EnvironmentalRange_optional;
      typedef ::xsd::cxx::tree::traits< EnvironmentalRange_type, wchar_t > EnvironmentalRange_traits;

      const EnvironmentalRange_optional&
      EnvironmentalRange () const;

      EnvironmentalRange_optional&
      EnvironmentalRange ();

      void
      EnvironmentalRange (const EnvironmentalRange_type& x);

      void
      EnvironmentalRange (const EnvironmentalRange_optional& x);

      void
      EnvironmentalRange (::std::unique_ptr< EnvironmentalRange_type > p);

      // Constructors.
      //
      MeasurementDeviceType ();

      MeasurementDeviceType (const Name_type&,
                             const id_type&);

      MeasurementDeviceType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      MeasurementDeviceType (const MeasurementDeviceType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual MeasurementDeviceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasurementDeviceType&
      operator= (const MeasurementDeviceType& x);

      virtual 
      ~MeasurementDeviceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Calibrations_optional Calibrations_;
      EnvironmentalRange_optional EnvironmentalRange_;
    };

    class QIF30_SYMBOL_DECL ManualMeasurementDeviceType: public ::xsd::qif30::MeasurementDeviceType
    {
      public:
      // MinMeasuringDistance
      //
      typedef ::xsd::qif30::LinearValueType MinMeasuringDistance_type;
      typedef ::xsd::cxx::tree::optional< MinMeasuringDistance_type > MinMeasuringDistance_optional;
      typedef ::xsd::cxx::tree::traits< MinMeasuringDistance_type, wchar_t > MinMeasuringDistance_traits;

      const MinMeasuringDistance_optional&
      MinMeasuringDistance () const;

      MinMeasuringDistance_optional&
      MinMeasuringDistance ();

      void
      MinMeasuringDistance (const MinMeasuringDistance_type& x);

      void
      MinMeasuringDistance (const MinMeasuringDistance_optional& x);

      void
      MinMeasuringDistance (::std::unique_ptr< MinMeasuringDistance_type > p);

      // MaxMeasuringDistance
      //
      typedef ::xsd::qif30::LinearValueType MaxMeasuringDistance_type;
      typedef ::xsd::cxx::tree::optional< MaxMeasuringDistance_type > MaxMeasuringDistance_optional;
      typedef ::xsd::cxx::tree::traits< MaxMeasuringDistance_type, wchar_t > MaxMeasuringDistance_traits;

      const MaxMeasuringDistance_optional&
      MaxMeasuringDistance () const;

      MaxMeasuringDistance_optional&
      MaxMeasuringDistance ();

      void
      MaxMeasuringDistance (const MaxMeasuringDistance_type& x);

      void
      MaxMeasuringDistance (const MaxMeasuringDistance_optional& x);

      void
      MaxMeasuringDistance (::std::unique_ptr< MaxMeasuringDistance_type > p);

      // Constructors.
      //
      ManualMeasurementDeviceType ();

      ManualMeasurementDeviceType (const Name_type&,
                                   const id_type&);

      ManualMeasurementDeviceType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      ManualMeasurementDeviceType (const ManualMeasurementDeviceType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual ManualMeasurementDeviceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ManualMeasurementDeviceType&
      operator= (const ManualMeasurementDeviceType& x);

      virtual 
      ~ManualMeasurementDeviceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MinMeasuringDistance_optional MinMeasuringDistance_;
      MaxMeasuringDistance_optional MaxMeasuringDistance_;
    };

    class QIF30_SYMBOL_DECL UniversalDeviceType: public ::xsd::qif30::MeasurementDeviceType
    {
      public:
      // Resolution
      //
      typedef ::xsd::qif30::ResolutionBaseType Resolution_type;
      typedef ::xsd::cxx::tree::optional< Resolution_type > Resolution_optional;
      typedef ::xsd::cxx::tree::traits< Resolution_type, wchar_t > Resolution_traits;

      const Resolution_optional&
      Resolution () const;

      Resolution_optional&
      Resolution ();

      void
      Resolution (const Resolution_type& x);

      void
      Resolution (const Resolution_optional& x);

      void
      Resolution (::std::unique_ptr< Resolution_type > p);

      // WorkingVolume
      //
      typedef ::xsd::qif30::WorkingVolumeBaseType WorkingVolume_type;
      typedef ::xsd::cxx::tree::optional< WorkingVolume_type > WorkingVolume_optional;
      typedef ::xsd::cxx::tree::traits< WorkingVolume_type, wchar_t > WorkingVolume_traits;

      const WorkingVolume_optional&
      WorkingVolume () const;

      WorkingVolume_optional&
      WorkingVolume ();

      void
      WorkingVolume (const WorkingVolume_type& x);

      void
      WorkingVolume (const WorkingVolume_optional& x);

      void
      WorkingVolume (::std::unique_ptr< WorkingVolume_type > p);

      // EffectiveWorkingVolume
      //
      typedef ::xsd::qif30::EffectiveWorkingVolumeBaseType EffectiveWorkingVolume_type;
      typedef ::xsd::cxx::tree::optional< EffectiveWorkingVolume_type > EffectiveWorkingVolume_optional;
      typedef ::xsd::cxx::tree::traits< EffectiveWorkingVolume_type, wchar_t > EffectiveWorkingVolume_traits;

      const EffectiveWorkingVolume_optional&
      EffectiveWorkingVolume () const;

      EffectiveWorkingVolume_optional&
      EffectiveWorkingVolume ();

      void
      EffectiveWorkingVolume (const EffectiveWorkingVolume_type& x);

      void
      EffectiveWorkingVolume (const EffectiveWorkingVolume_optional& x);

      void
      EffectiveWorkingVolume (::std::unique_ptr< EffectiveWorkingVolume_type > p);

      // TemperatureCompensation
      //
      typedef ::xsd::qif30::TemperatureCompensationType TemperatureCompensation_type;
      typedef ::xsd::cxx::tree::optional< TemperatureCompensation_type > TemperatureCompensation_optional;
      typedef ::xsd::cxx::tree::traits< TemperatureCompensation_type, wchar_t > TemperatureCompensation_traits;

      const TemperatureCompensation_optional&
      TemperatureCompensation () const;

      TemperatureCompensation_optional&
      TemperatureCompensation ();

      void
      TemperatureCompensation (const TemperatureCompensation_type& x);

      void
      TemperatureCompensation (const TemperatureCompensation_optional& x);

      void
      TemperatureCompensation (::std::unique_ptr< TemperatureCompensation_type > p);

      // Constructors.
      //
      UniversalDeviceType ();

      UniversalDeviceType (const Name_type&,
                           const id_type&);

      UniversalDeviceType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      UniversalDeviceType (const UniversalDeviceType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual UniversalDeviceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UniversalDeviceType&
      operator= (const UniversalDeviceType& x);

      virtual 
      ~UniversalDeviceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Resolution_optional Resolution_;
      WorkingVolume_optional WorkingVolume_;
      EffectiveWorkingVolume_optional EffectiveWorkingVolume_;
      TemperatureCompensation_optional TemperatureCompensation_;
    };

    class QIF30_SYMBOL_DECL TemperatureCompensationEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        NONE,
        DEVICE_ONLY,
        DEVICE_AND_PART_SAME,
        DEVICE_AND_PART_SEPARATE
      };

      TemperatureCompensationEnumType ();

      TemperatureCompensationEnumType (value v);

      TemperatureCompensationEnumType (const wchar_t* v);

      TemperatureCompensationEnumType (const ::std::wstring& v);

      TemperatureCompensationEnumType (const ::xml_schema::nmtoken& v);

      TemperatureCompensationEnumType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      TemperatureCompensationEnumType (const xercesc::DOMAttr& a,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      TemperatureCompensationEnumType (const ::std::wstring& s,
                                       const xercesc::DOMElement* e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      TemperatureCompensationEnumType (const TemperatureCompensationEnumType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      TemperatureCompensationEnumType&
      operator= (const TemperatureCompensationEnumType&) = default;
#endif

      virtual TemperatureCompensationEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TemperatureCompensationEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_TemperatureCompensationEnumType_convert ();
      }

      protected:
      value
      _xsd_TemperatureCompensationEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_TemperatureCompensationEnumType_literals_[4];
      static const value _xsd_TemperatureCompensationEnumType_indexes_[4];
    };

    class QIF30_SYMBOL_DECL TemperatureCompensationType: public ::xml_schema::type
    {
      public:
      // TemperatureCompensationEnum
      //
      typedef ::xsd::qif30::TemperatureCompensationEnumType TemperatureCompensationEnum_type;
      typedef ::xsd::cxx::tree::optional< TemperatureCompensationEnum_type > TemperatureCompensationEnum_optional;
      typedef ::xsd::cxx::tree::traits< TemperatureCompensationEnum_type, wchar_t > TemperatureCompensationEnum_traits;

      const TemperatureCompensationEnum_optional&
      TemperatureCompensationEnum () const;

      TemperatureCompensationEnum_optional&
      TemperatureCompensationEnum ();

      void
      TemperatureCompensationEnum (const TemperatureCompensationEnum_type& x);

      void
      TemperatureCompensationEnum (const TemperatureCompensationEnum_optional& x);

      void
      TemperatureCompensationEnum (::std::unique_ptr< TemperatureCompensationEnum_type > p);

      // OtherTemperatureCompensation
      //
      typedef ::xml_schema::string OtherTemperatureCompensation_type;
      typedef ::xsd::cxx::tree::optional< OtherTemperatureCompensation_type > OtherTemperatureCompensation_optional;
      typedef ::xsd::cxx::tree::traits< OtherTemperatureCompensation_type, wchar_t > OtherTemperatureCompensation_traits;

      const OtherTemperatureCompensation_optional&
      OtherTemperatureCompensation () const;

      OtherTemperatureCompensation_optional&
      OtherTemperatureCompensation ();

      void
      OtherTemperatureCompensation (const OtherTemperatureCompensation_type& x);

      void
      OtherTemperatureCompensation (const OtherTemperatureCompensation_optional& x);

      void
      OtherTemperatureCompensation (::std::unique_ptr< OtherTemperatureCompensation_type > p);

      // Constructors.
      //
      TemperatureCompensationType ();

      TemperatureCompensationType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      TemperatureCompensationType (const TemperatureCompensationType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual TemperatureCompensationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TemperatureCompensationType&
      operator= (const TemperatureCompensationType& x);

      virtual 
      ~TemperatureCompensationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      TemperatureCompensationEnum_optional TemperatureCompensationEnum_;
      OtherTemperatureCompensation_optional OtherTemperatureCompensation_;
    };

    class QIF30_SYMBOL_DECL WorkingVolumeBaseType: public ::xml_schema::type
    {
      public:
      // Constructors.
      //
      WorkingVolumeBaseType ();

      WorkingVolumeBaseType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      WorkingVolumeBaseType (const xercesc::DOMAttr& a,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      WorkingVolumeBaseType (const ::std::wstring& s,
                             const xercesc::DOMElement* e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      WorkingVolumeBaseType (const WorkingVolumeBaseType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual WorkingVolumeBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      WorkingVolumeBaseType&
      operator= (const WorkingVolumeBaseType&) = default;
#endif

      virtual 
      ~WorkingVolumeBaseType ();
    };

    class QIF30_SYMBOL_DECL ClosedShellSetWorkingVolumeType: public ::xsd::qif30::WorkingVolumeBaseType
    {
      public:
      // WorkingClosedShellSet
      //
      typedef ::xsd::qif30::ClosedShellSetType WorkingClosedShellSet_type;
      typedef ::xsd::cxx::tree::traits< WorkingClosedShellSet_type, wchar_t > WorkingClosedShellSet_traits;

      const WorkingClosedShellSet_type&
      WorkingClosedShellSet () const;

      WorkingClosedShellSet_type&
      WorkingClosedShellSet ();

      void
      WorkingClosedShellSet (const WorkingClosedShellSet_type& x);

      void
      WorkingClosedShellSet (::std::unique_ptr< WorkingClosedShellSet_type > p);

      // Constructors.
      //
      ClosedShellSetWorkingVolumeType ();

      ClosedShellSetWorkingVolumeType (const WorkingClosedShellSet_type&);

      ClosedShellSetWorkingVolumeType (::std::unique_ptr< WorkingClosedShellSet_type >);

      ClosedShellSetWorkingVolumeType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      ClosedShellSetWorkingVolumeType (const ClosedShellSetWorkingVolumeType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual ClosedShellSetWorkingVolumeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ClosedShellSetWorkingVolumeType&
      operator= (const ClosedShellSetWorkingVolumeType& x);

      virtual 
      ~ClosedShellSetWorkingVolumeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< WorkingClosedShellSet_type > WorkingClosedShellSet_;
    };

    class QIF30_SYMBOL_DECL ClosedShellSetType: public ::xml_schema::type
    {
      public:
      // PointSet
      //
      typedef ::xsd::qif30::PointSetType PointSet_type;
      typedef ::xsd::cxx::tree::optional< PointSet_type > PointSet_optional;
      typedef ::xsd::cxx::tree::traits< PointSet_type, wchar_t > PointSet_traits;

      const PointSet_optional&
      PointSet () const;

      PointSet_optional&
      PointSet ();

      void
      PointSet (const PointSet_type& x);

      void
      PointSet (const PointSet_optional& x);

      void
      PointSet (::std::unique_ptr< PointSet_type > p);

      // Curve12Set
      //
      typedef ::xsd::qif30::Curve12SetType Curve12Set_type;
      typedef ::xsd::cxx::tree::optional< Curve12Set_type > Curve12Set_optional;
      typedef ::xsd::cxx::tree::traits< Curve12Set_type, wchar_t > Curve12Set_traits;

      const Curve12Set_optional&
      Curve12Set () const;

      Curve12Set_optional&
      Curve12Set ();

      void
      Curve12Set (const Curve12Set_type& x);

      void
      Curve12Set (const Curve12Set_optional& x);

      void
      Curve12Set (::std::unique_ptr< Curve12Set_type > p);

      // Curve13Set
      //
      typedef ::xsd::qif30::Curve13SetType Curve13Set_type;
      typedef ::xsd::cxx::tree::optional< Curve13Set_type > Curve13Set_optional;
      typedef ::xsd::cxx::tree::traits< Curve13Set_type, wchar_t > Curve13Set_traits;

      const Curve13Set_optional&
      Curve13Set () const;

      Curve13Set_optional&
      Curve13Set ();

      void
      Curve13Set (const Curve13Set_type& x);

      void
      Curve13Set (const Curve13Set_optional& x);

      void
      Curve13Set (::std::unique_ptr< Curve13Set_type > p);

      // SurfaceSet
      //
      typedef ::xsd::qif30::SurfaceSetType SurfaceSet_type;
      typedef ::xsd::cxx::tree::optional< SurfaceSet_type > SurfaceSet_optional;
      typedef ::xsd::cxx::tree::traits< SurfaceSet_type, wchar_t > SurfaceSet_traits;

      const SurfaceSet_optional&
      SurfaceSet () const;

      SurfaceSet_optional&
      SurfaceSet ();

      void
      SurfaceSet (const SurfaceSet_type& x);

      void
      SurfaceSet (const SurfaceSet_optional& x);

      void
      SurfaceSet (::std::unique_ptr< SurfaceSet_type > p);

      // CurveMeshSet
      //
      typedef ::xsd::qif30::CurveMeshSetType CurveMeshSet_type;
      typedef ::xsd::cxx::tree::optional< CurveMeshSet_type > CurveMeshSet_optional;
      typedef ::xsd::cxx::tree::traits< CurveMeshSet_type, wchar_t > CurveMeshSet_traits;

      const CurveMeshSet_optional&
      CurveMeshSet () const;

      CurveMeshSet_optional&
      CurveMeshSet ();

      void
      CurveMeshSet (const CurveMeshSet_type& x);

      void
      CurveMeshSet (const CurveMeshSet_optional& x);

      void
      CurveMeshSet (::std::unique_ptr< CurveMeshSet_type > p);

      // SurfaceMeshSet
      //
      typedef ::xsd::qif30::SurfaceMeshSetType SurfaceMeshSet_type;
      typedef ::xsd::cxx::tree::optional< SurfaceMeshSet_type > SurfaceMeshSet_optional;
      typedef ::xsd::cxx::tree::traits< SurfaceMeshSet_type, wchar_t > SurfaceMeshSet_traits;

      const SurfaceMeshSet_optional&
      SurfaceMeshSet () const;

      SurfaceMeshSet_optional&
      SurfaceMeshSet ();

      void
      SurfaceMeshSet (const SurfaceMeshSet_type& x);

      void
      SurfaceMeshSet (const SurfaceMeshSet_optional& x);

      void
      SurfaceMeshSet (::std::unique_ptr< SurfaceMeshSet_type > p);

      // VertexSet
      //
      typedef ::xsd::qif30::VertexSetType VertexSet_type;
      typedef ::xsd::cxx::tree::optional< VertexSet_type > VertexSet_optional;
      typedef ::xsd::cxx::tree::traits< VertexSet_type, wchar_t > VertexSet_traits;

      const VertexSet_optional&
      VertexSet () const;

      VertexSet_optional&
      VertexSet ();

      void
      VertexSet (const VertexSet_type& x);

      void
      VertexSet (const VertexSet_optional& x);

      void
      VertexSet (::std::unique_ptr< VertexSet_type > p);

      // EdgeSet
      //
      typedef ::xsd::qif30::EdgeSetType EdgeSet_type;
      typedef ::xsd::cxx::tree::optional< EdgeSet_type > EdgeSet_optional;
      typedef ::xsd::cxx::tree::traits< EdgeSet_type, wchar_t > EdgeSet_traits;

      const EdgeSet_optional&
      EdgeSet () const;

      EdgeSet_optional&
      EdgeSet ();

      void
      EdgeSet (const EdgeSet_type& x);

      void
      EdgeSet (const EdgeSet_optional& x);

      void
      EdgeSet (::std::unique_ptr< EdgeSet_type > p);

      // LoopSet
      //
      typedef ::xsd::qif30::LoopSetType LoopSet_type;
      typedef ::xsd::cxx::tree::optional< LoopSet_type > LoopSet_optional;
      typedef ::xsd::cxx::tree::traits< LoopSet_type, wchar_t > LoopSet_traits;

      const LoopSet_optional&
      LoopSet () const;

      LoopSet_optional&
      LoopSet ();

      void
      LoopSet (const LoopSet_type& x);

      void
      LoopSet (const LoopSet_optional& x);

      void
      LoopSet (::std::unique_ptr< LoopSet_type > p);

      // FaceSet
      //
      typedef ::xsd::qif30::FaceSetType FaceSet_type;
      typedef ::xsd::cxx::tree::optional< FaceSet_type > FaceSet_optional;
      typedef ::xsd::cxx::tree::traits< FaceSet_type, wchar_t > FaceSet_traits;

      const FaceSet_optional&
      FaceSet () const;

      FaceSet_optional&
      FaceSet ();

      void
      FaceSet (const FaceSet_type& x);

      void
      FaceSet (const FaceSet_optional& x);

      void
      FaceSet (::std::unique_ptr< FaceSet_type > p);

      // ShellSet
      //
      typedef ::xsd::qif30::ShellSetType ShellSet_type;
      typedef ::xsd::cxx::tree::traits< ShellSet_type, wchar_t > ShellSet_traits;

      const ShellSet_type&
      ShellSet () const;

      ShellSet_type&
      ShellSet ();

      void
      ShellSet (const ShellSet_type& x);

      void
      ShellSet (::std::unique_ptr< ShellSet_type > p);

      // Constructors.
      //
      ClosedShellSetType ();

      ClosedShellSetType (const ShellSet_type&);

      ClosedShellSetType (::std::unique_ptr< ShellSet_type >);

      ClosedShellSetType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      ClosedShellSetType (const ClosedShellSetType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual ClosedShellSetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ClosedShellSetType&
      operator= (const ClosedShellSetType& x);

      virtual 
      ~ClosedShellSetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PointSet_optional PointSet_;
      Curve12Set_optional Curve12Set_;
      Curve13Set_optional Curve13Set_;
      SurfaceSet_optional SurfaceSet_;
      CurveMeshSet_optional CurveMeshSet_;
      SurfaceMeshSet_optional SurfaceMeshSet_;
      VertexSet_optional VertexSet_;
      EdgeSet_optional EdgeSet_;
      LoopSet_optional LoopSet_;
      FaceSet_optional FaceSet_;
      ::xsd::cxx::tree::one< ShellSet_type > ShellSet_;
    };

    class QIF30_SYMBOL_DECL CartesianWorkingVolumeType: public ::xsd::qif30::WorkingVolumeBaseType
    {
      public:
      // XAxisLength
      //
      typedef ::xsd::qif30::LinearValueType XAxisLength_type;
      typedef ::xsd::cxx::tree::optional< XAxisLength_type > XAxisLength_optional;
      typedef ::xsd::cxx::tree::traits< XAxisLength_type, wchar_t > XAxisLength_traits;

      const XAxisLength_optional&
      XAxisLength () const;

      XAxisLength_optional&
      XAxisLength ();

      void
      XAxisLength (const XAxisLength_type& x);

      void
      XAxisLength (const XAxisLength_optional& x);

      void
      XAxisLength (::std::unique_ptr< XAxisLength_type > p);

      // YAxisLength
      //
      typedef ::xsd::qif30::LinearValueType YAxisLength_type;
      typedef ::xsd::cxx::tree::optional< YAxisLength_type > YAxisLength_optional;
      typedef ::xsd::cxx::tree::traits< YAxisLength_type, wchar_t > YAxisLength_traits;

      const YAxisLength_optional&
      YAxisLength () const;

      YAxisLength_optional&
      YAxisLength ();

      void
      YAxisLength (const YAxisLength_type& x);

      void
      YAxisLength (const YAxisLength_optional& x);

      void
      YAxisLength (::std::unique_ptr< YAxisLength_type > p);

      // ZAxisLength
      //
      typedef ::xsd::qif30::LinearValueType ZAxisLength_type;
      typedef ::xsd::cxx::tree::optional< ZAxisLength_type > ZAxisLength_optional;
      typedef ::xsd::cxx::tree::traits< ZAxisLength_type, wchar_t > ZAxisLength_traits;

      const ZAxisLength_optional&
      ZAxisLength () const;

      ZAxisLength_optional&
      ZAxisLength ();

      void
      ZAxisLength (const ZAxisLength_type& x);

      void
      ZAxisLength (const ZAxisLength_optional& x);

      void
      ZAxisLength (::std::unique_ptr< ZAxisLength_type > p);

      // Constructors.
      //
      CartesianWorkingVolumeType ();

      CartesianWorkingVolumeType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      CartesianWorkingVolumeType (const CartesianWorkingVolumeType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual CartesianWorkingVolumeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CartesianWorkingVolumeType&
      operator= (const CartesianWorkingVolumeType& x);

      virtual 
      ~CartesianWorkingVolumeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      XAxisLength_optional XAxisLength_;
      YAxisLength_optional YAxisLength_;
      ZAxisLength_optional ZAxisLength_;
    };

    class QIF30_SYMBOL_DECL SphericalWorkingVolumeType: public ::xsd::qif30::WorkingVolumeBaseType
    {
      public:
      // RadialAxisLength
      //
      typedef ::xsd::qif30::LinearValueType RadialAxisLength_type;
      typedef ::xsd::cxx::tree::traits< RadialAxisLength_type, wchar_t > RadialAxisLength_traits;

      const RadialAxisLength_type&
      RadialAxisLength () const;

      RadialAxisLength_type&
      RadialAxisLength ();

      void
      RadialAxisLength (const RadialAxisLength_type& x);

      void
      RadialAxisLength (::std::unique_ptr< RadialAxisLength_type > p);

      // MinAzimuthalAxisAngle
      //
      typedef ::xsd::qif30::AngularValueType MinAzimuthalAxisAngle_type;
      typedef ::xsd::cxx::tree::traits< MinAzimuthalAxisAngle_type, wchar_t > MinAzimuthalAxisAngle_traits;

      const MinAzimuthalAxisAngle_type&
      MinAzimuthalAxisAngle () const;

      MinAzimuthalAxisAngle_type&
      MinAzimuthalAxisAngle ();

      void
      MinAzimuthalAxisAngle (const MinAzimuthalAxisAngle_type& x);

      void
      MinAzimuthalAxisAngle (::std::unique_ptr< MinAzimuthalAxisAngle_type > p);

      // MaxAzimuthalAxisAngle
      //
      typedef ::xsd::qif30::AngularValueType MaxAzimuthalAxisAngle_type;
      typedef ::xsd::cxx::tree::traits< MaxAzimuthalAxisAngle_type, wchar_t > MaxAzimuthalAxisAngle_traits;

      const MaxAzimuthalAxisAngle_type&
      MaxAzimuthalAxisAngle () const;

      MaxAzimuthalAxisAngle_type&
      MaxAzimuthalAxisAngle ();

      void
      MaxAzimuthalAxisAngle (const MaxAzimuthalAxisAngle_type& x);

      void
      MaxAzimuthalAxisAngle (::std::unique_ptr< MaxAzimuthalAxisAngle_type > p);

      // MinPolarAxisAngle
      //
      typedef ::xsd::qif30::AngularValueType MinPolarAxisAngle_type;
      typedef ::xsd::cxx::tree::traits< MinPolarAxisAngle_type, wchar_t > MinPolarAxisAngle_traits;

      const MinPolarAxisAngle_type&
      MinPolarAxisAngle () const;

      MinPolarAxisAngle_type&
      MinPolarAxisAngle ();

      void
      MinPolarAxisAngle (const MinPolarAxisAngle_type& x);

      void
      MinPolarAxisAngle (::std::unique_ptr< MinPolarAxisAngle_type > p);

      // MaxPolarAxisAngle
      //
      typedef ::xsd::qif30::AngularValueType MaxPolarAxisAngle_type;
      typedef ::xsd::cxx::tree::traits< MaxPolarAxisAngle_type, wchar_t > MaxPolarAxisAngle_traits;

      const MaxPolarAxisAngle_type&
      MaxPolarAxisAngle () const;

      MaxPolarAxisAngle_type&
      MaxPolarAxisAngle ();

      void
      MaxPolarAxisAngle (const MaxPolarAxisAngle_type& x);

      void
      MaxPolarAxisAngle (::std::unique_ptr< MaxPolarAxisAngle_type > p);

      // Constructors.
      //
      SphericalWorkingVolumeType ();

      SphericalWorkingVolumeType (const RadialAxisLength_type&,
                                  const MinAzimuthalAxisAngle_type&,
                                  const MaxAzimuthalAxisAngle_type&,
                                  const MinPolarAxisAngle_type&,
                                  const MaxPolarAxisAngle_type&);

      SphericalWorkingVolumeType (::std::unique_ptr< RadialAxisLength_type >,
                                  ::std::unique_ptr< MinAzimuthalAxisAngle_type >,
                                  ::std::unique_ptr< MaxAzimuthalAxisAngle_type >,
                                  ::std::unique_ptr< MinPolarAxisAngle_type >,
                                  ::std::unique_ptr< MaxPolarAxisAngle_type >);

      SphericalWorkingVolumeType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      SphericalWorkingVolumeType (const SphericalWorkingVolumeType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual SphericalWorkingVolumeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SphericalWorkingVolumeType&
      operator= (const SphericalWorkingVolumeType& x);

      virtual 
      ~SphericalWorkingVolumeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< RadialAxisLength_type > RadialAxisLength_;
      ::xsd::cxx::tree::one< MinAzimuthalAxisAngle_type > MinAzimuthalAxisAngle_;
      ::xsd::cxx::tree::one< MaxAzimuthalAxisAngle_type > MaxAzimuthalAxisAngle_;
      ::xsd::cxx::tree::one< MinPolarAxisAngle_type > MinPolarAxisAngle_;
      ::xsd::cxx::tree::one< MaxPolarAxisAngle_type > MaxPolarAxisAngle_;
    };

    class QIF30_SYMBOL_DECL CylindricalWorkingVolumeType: public ::xsd::qif30::WorkingVolumeBaseType
    {
      public:
      // RadialAxisLength
      //
      typedef ::xsd::qif30::LinearValueType RadialAxisLength_type;
      typedef ::xsd::cxx::tree::traits< RadialAxisLength_type, wchar_t > RadialAxisLength_traits;

      const RadialAxisLength_type&
      RadialAxisLength () const;

      RadialAxisLength_type&
      RadialAxisLength ();

      void
      RadialAxisLength (const RadialAxisLength_type& x);

      void
      RadialAxisLength (::std::unique_ptr< RadialAxisLength_type > p);

      // MinAzimuthalAxisAngle
      //
      typedef ::xsd::qif30::AngularValueType MinAzimuthalAxisAngle_type;
      typedef ::xsd::cxx::tree::traits< MinAzimuthalAxisAngle_type, wchar_t > MinAzimuthalAxisAngle_traits;

      const MinAzimuthalAxisAngle_type&
      MinAzimuthalAxisAngle () const;

      MinAzimuthalAxisAngle_type&
      MinAzimuthalAxisAngle ();

      void
      MinAzimuthalAxisAngle (const MinAzimuthalAxisAngle_type& x);

      void
      MinAzimuthalAxisAngle (::std::unique_ptr< MinAzimuthalAxisAngle_type > p);

      // MaxAzimuthalAxisAngle
      //
      typedef ::xsd::qif30::AngularValueType MaxAzimuthalAxisAngle_type;
      typedef ::xsd::cxx::tree::traits< MaxAzimuthalAxisAngle_type, wchar_t > MaxAzimuthalAxisAngle_traits;

      const MaxAzimuthalAxisAngle_type&
      MaxAzimuthalAxisAngle () const;

      MaxAzimuthalAxisAngle_type&
      MaxAzimuthalAxisAngle ();

      void
      MaxAzimuthalAxisAngle (const MaxAzimuthalAxisAngle_type& x);

      void
      MaxAzimuthalAxisAngle (::std::unique_ptr< MaxAzimuthalAxisAngle_type > p);

      // ZAxisLength
      //
      typedef ::xsd::qif30::LinearValueType ZAxisLength_type;
      typedef ::xsd::cxx::tree::traits< ZAxisLength_type, wchar_t > ZAxisLength_traits;

      const ZAxisLength_type&
      ZAxisLength () const;

      ZAxisLength_type&
      ZAxisLength ();

      void
      ZAxisLength (const ZAxisLength_type& x);

      void
      ZAxisLength (::std::unique_ptr< ZAxisLength_type > p);

      // Constructors.
      //
      CylindricalWorkingVolumeType ();

      CylindricalWorkingVolumeType (const RadialAxisLength_type&,
                                    const MinAzimuthalAxisAngle_type&,
                                    const MaxAzimuthalAxisAngle_type&,
                                    const ZAxisLength_type&);

      CylindricalWorkingVolumeType (::std::unique_ptr< RadialAxisLength_type >,
                                    ::std::unique_ptr< MinAzimuthalAxisAngle_type >,
                                    ::std::unique_ptr< MaxAzimuthalAxisAngle_type >,
                                    ::std::unique_ptr< ZAxisLength_type >);

      CylindricalWorkingVolumeType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      CylindricalWorkingVolumeType (const CylindricalWorkingVolumeType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual CylindricalWorkingVolumeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CylindricalWorkingVolumeType&
      operator= (const CylindricalWorkingVolumeType& x);

      virtual 
      ~CylindricalWorkingVolumeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< RadialAxisLength_type > RadialAxisLength_;
      ::xsd::cxx::tree::one< MinAzimuthalAxisAngle_type > MinAzimuthalAxisAngle_;
      ::xsd::cxx::tree::one< MaxAzimuthalAxisAngle_type > MaxAzimuthalAxisAngle_;
      ::xsd::cxx::tree::one< ZAxisLength_type > ZAxisLength_;
    };

    class QIF30_SYMBOL_DECL UserDefinedWorkingVolumeType: public ::xsd::qif30::WorkingVolumeBaseType
    {
      public:
      // FirstAxis
      //
      typedef ::xsd::qif30::UserDefinedAxisType FirstAxis_type;
      typedef ::xsd::cxx::tree::traits< FirstAxis_type, wchar_t > FirstAxis_traits;

      const FirstAxis_type&
      FirstAxis () const;

      FirstAxis_type&
      FirstAxis ();

      void
      FirstAxis (const FirstAxis_type& x);

      void
      FirstAxis (::std::unique_ptr< FirstAxis_type > p);

      // SecondAxis
      //
      typedef ::xsd::qif30::UserDefinedAxisType SecondAxis_type;
      typedef ::xsd::cxx::tree::traits< SecondAxis_type, wchar_t > SecondAxis_traits;

      const SecondAxis_type&
      SecondAxis () const;

      SecondAxis_type&
      SecondAxis ();

      void
      SecondAxis (const SecondAxis_type& x);

      void
      SecondAxis (::std::unique_ptr< SecondAxis_type > p);

      // ThirdAxis
      //
      typedef ::xsd::qif30::UserDefinedAxisType ThirdAxis_type;
      typedef ::xsd::cxx::tree::traits< ThirdAxis_type, wchar_t > ThirdAxis_traits;

      const ThirdAxis_type&
      ThirdAxis () const;

      ThirdAxis_type&
      ThirdAxis ();

      void
      ThirdAxis (const ThirdAxis_type& x);

      void
      ThirdAxis (::std::unique_ptr< ThirdAxis_type > p);

      // Constructors.
      //
      UserDefinedWorkingVolumeType ();

      UserDefinedWorkingVolumeType (const FirstAxis_type&,
                                    const SecondAxis_type&,
                                    const ThirdAxis_type&);

      UserDefinedWorkingVolumeType (::std::unique_ptr< FirstAxis_type >,
                                    ::std::unique_ptr< SecondAxis_type >,
                                    ::std::unique_ptr< ThirdAxis_type >);

      UserDefinedWorkingVolumeType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      UserDefinedWorkingVolumeType (const UserDefinedWorkingVolumeType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual UserDefinedWorkingVolumeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UserDefinedWorkingVolumeType&
      operator= (const UserDefinedWorkingVolumeType& x);

      virtual 
      ~UserDefinedWorkingVolumeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< FirstAxis_type > FirstAxis_;
      ::xsd::cxx::tree::one< SecondAxis_type > SecondAxis_;
      ::xsd::cxx::tree::one< ThirdAxis_type > ThirdAxis_;
    };

    class QIF30_SYMBOL_DECL LinearOrRotaryAxisType: public ::xml_schema::type
    {
      public:
      // Axis
      //
      typedef ::xsd::qif30::UserAxisBaseType Axis_type;
      typedef ::xsd::cxx::tree::traits< Axis_type, wchar_t > Axis_traits;

      const Axis_type&
      Axis () const;

      Axis_type&
      Axis ();

      void
      Axis (const Axis_type& x);

      void
      Axis (::std::unique_ptr< Axis_type > p);

      // Constructors.
      //
      LinearOrRotaryAxisType ();

      LinearOrRotaryAxisType (const Axis_type&);

      LinearOrRotaryAxisType (::std::unique_ptr< Axis_type >);

      LinearOrRotaryAxisType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      LinearOrRotaryAxisType (const LinearOrRotaryAxisType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual LinearOrRotaryAxisType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LinearOrRotaryAxisType&
      operator= (const LinearOrRotaryAxisType& x);

      virtual 
      ~LinearOrRotaryAxisType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Axis_type > Axis_;
    };

    class QIF30_SYMBOL_DECL UserDefinedAxisType: public ::xsd::qif30::LinearOrRotaryAxisType
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // AxisName
      //
      typedef ::xml_schema::token AxisName_type;
      typedef ::xsd::cxx::tree::traits< AxisName_type, wchar_t > AxisName_traits;

      const AxisName_type&
      AxisName () const;

      AxisName_type&
      AxisName ();

      void
      AxisName (const AxisName_type& x);

      void
      AxisName (::std::unique_ptr< AxisName_type > p);

      // Constructors.
      //
      UserDefinedAxisType ();

      UserDefinedAxisType (const Axis_type&,
                           const AxisName_type&);

      UserDefinedAxisType (::std::unique_ptr< Axis_type >,
                           const AxisName_type&);

      UserDefinedAxisType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      UserDefinedAxisType (const UserDefinedAxisType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual UserDefinedAxisType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UserDefinedAxisType&
      operator= (const UserDefinedAxisType& x);

      virtual 
      ~UserDefinedAxisType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      ::xsd::cxx::tree::one< AxisName_type > AxisName_;
    };

    class QIF30_SYMBOL_DECL EffectiveWorkingVolumeBaseType: public ::xml_schema::type
    {
      public:
      // Constructors.
      //
      EffectiveWorkingVolumeBaseType ();

      EffectiveWorkingVolumeBaseType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      EffectiveWorkingVolumeBaseType (const xercesc::DOMAttr& a,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      EffectiveWorkingVolumeBaseType (const ::std::wstring& s,
                                      const xercesc::DOMElement* e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      EffectiveWorkingVolumeBaseType (const EffectiveWorkingVolumeBaseType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual EffectiveWorkingVolumeBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      EffectiveWorkingVolumeBaseType&
      operator= (const EffectiveWorkingVolumeBaseType&) = default;
#endif

      virtual 
      ~EffectiveWorkingVolumeBaseType ();
    };

    class QIF30_SYMBOL_DECL EffectiveCylindricalWorkingVolumeType: public ::xsd::qif30::EffectiveWorkingVolumeBaseType
    {
      public:
      // MinRadius
      //
      typedef ::xsd::qif30::LinearValueType MinRadius_type;
      typedef ::xsd::cxx::tree::traits< MinRadius_type, wchar_t > MinRadius_traits;

      const MinRadius_type&
      MinRadius () const;

      MinRadius_type&
      MinRadius ();

      void
      MinRadius (const MinRadius_type& x);

      void
      MinRadius (::std::unique_ptr< MinRadius_type > p);

      // MaxRadius
      //
      typedef ::xsd::qif30::LinearValueType MaxRadius_type;
      typedef ::xsd::cxx::tree::traits< MaxRadius_type, wchar_t > MaxRadius_traits;

      const MaxRadius_type&
      MaxRadius () const;

      MaxRadius_type&
      MaxRadius ();

      void
      MaxRadius (const MaxRadius_type& x);

      void
      MaxRadius (::std::unique_ptr< MaxRadius_type > p);

      // MinAzimuthalAxisAngle
      //
      typedef ::xsd::qif30::AngularValueType MinAzimuthalAxisAngle_type;
      typedef ::xsd::cxx::tree::traits< MinAzimuthalAxisAngle_type, wchar_t > MinAzimuthalAxisAngle_traits;

      const MinAzimuthalAxisAngle_type&
      MinAzimuthalAxisAngle () const;

      MinAzimuthalAxisAngle_type&
      MinAzimuthalAxisAngle ();

      void
      MinAzimuthalAxisAngle (const MinAzimuthalAxisAngle_type& x);

      void
      MinAzimuthalAxisAngle (::std::unique_ptr< MinAzimuthalAxisAngle_type > p);

      // MaxAzimuthalAxisAngle
      //
      typedef ::xsd::qif30::AngularValueType MaxAzimuthalAxisAngle_type;
      typedef ::xsd::cxx::tree::traits< MaxAzimuthalAxisAngle_type, wchar_t > MaxAzimuthalAxisAngle_traits;

      const MaxAzimuthalAxisAngle_type&
      MaxAzimuthalAxisAngle () const;

      MaxAzimuthalAxisAngle_type&
      MaxAzimuthalAxisAngle ();

      void
      MaxAzimuthalAxisAngle (const MaxAzimuthalAxisAngle_type& x);

      void
      MaxAzimuthalAxisAngle (::std::unique_ptr< MaxAzimuthalAxisAngle_type > p);

      // MinZAxis
      //
      typedef ::xsd::qif30::LinearValueType MinZAxis_type;
      typedef ::xsd::cxx::tree::traits< MinZAxis_type, wchar_t > MinZAxis_traits;

      const MinZAxis_type&
      MinZAxis () const;

      MinZAxis_type&
      MinZAxis ();

      void
      MinZAxis (const MinZAxis_type& x);

      void
      MinZAxis (::std::unique_ptr< MinZAxis_type > p);

      // MaxZAxis
      //
      typedef ::xsd::qif30::LinearValueType MaxZAxis_type;
      typedef ::xsd::cxx::tree::traits< MaxZAxis_type, wchar_t > MaxZAxis_traits;

      const MaxZAxis_type&
      MaxZAxis () const;

      MaxZAxis_type&
      MaxZAxis ();

      void
      MaxZAxis (const MaxZAxis_type& x);

      void
      MaxZAxis (::std::unique_ptr< MaxZAxis_type > p);

      // Constructors.
      //
      EffectiveCylindricalWorkingVolumeType ();

      EffectiveCylindricalWorkingVolumeType (const MinRadius_type&,
                                             const MaxRadius_type&,
                                             const MinAzimuthalAxisAngle_type&,
                                             const MaxAzimuthalAxisAngle_type&,
                                             const MinZAxis_type&,
                                             const MaxZAxis_type&);

      EffectiveCylindricalWorkingVolumeType (::std::unique_ptr< MinRadius_type >,
                                             ::std::unique_ptr< MaxRadius_type >,
                                             ::std::unique_ptr< MinAzimuthalAxisAngle_type >,
                                             ::std::unique_ptr< MaxAzimuthalAxisAngle_type >,
                                             ::std::unique_ptr< MinZAxis_type >,
                                             ::std::unique_ptr< MaxZAxis_type >);

      EffectiveCylindricalWorkingVolumeType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      EffectiveCylindricalWorkingVolumeType (const EffectiveCylindricalWorkingVolumeType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual EffectiveCylindricalWorkingVolumeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EffectiveCylindricalWorkingVolumeType&
      operator= (const EffectiveCylindricalWorkingVolumeType& x);

      virtual 
      ~EffectiveCylindricalWorkingVolumeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< MinRadius_type > MinRadius_;
      ::xsd::cxx::tree::one< MaxRadius_type > MaxRadius_;
      ::xsd::cxx::tree::one< MinAzimuthalAxisAngle_type > MinAzimuthalAxisAngle_;
      ::xsd::cxx::tree::one< MaxAzimuthalAxisAngle_type > MaxAzimuthalAxisAngle_;
      ::xsd::cxx::tree::one< MinZAxis_type > MinZAxis_;
      ::xsd::cxx::tree::one< MaxZAxis_type > MaxZAxis_;
    };

    class QIF30_SYMBOL_DECL EffectiveSphericalWorkingVolumeType: public ::xsd::qif30::EffectiveWorkingVolumeBaseType
    {
      public:
      // MinRadialAxis
      //
      typedef ::xsd::qif30::LinearValueType MinRadialAxis_type;
      typedef ::xsd::cxx::tree::traits< MinRadialAxis_type, wchar_t > MinRadialAxis_traits;

      const MinRadialAxis_type&
      MinRadialAxis () const;

      MinRadialAxis_type&
      MinRadialAxis ();

      void
      MinRadialAxis (const MinRadialAxis_type& x);

      void
      MinRadialAxis (::std::unique_ptr< MinRadialAxis_type > p);

      // MaxRadialAxis
      //
      typedef ::xsd::qif30::LinearValueType MaxRadialAxis_type;
      typedef ::xsd::cxx::tree::traits< MaxRadialAxis_type, wchar_t > MaxRadialAxis_traits;

      const MaxRadialAxis_type&
      MaxRadialAxis () const;

      MaxRadialAxis_type&
      MaxRadialAxis ();

      void
      MaxRadialAxis (const MaxRadialAxis_type& x);

      void
      MaxRadialAxis (::std::unique_ptr< MaxRadialAxis_type > p);

      // MinAzimuthalAxisAngle
      //
      typedef ::xsd::qif30::AngularValueType MinAzimuthalAxisAngle_type;
      typedef ::xsd::cxx::tree::traits< MinAzimuthalAxisAngle_type, wchar_t > MinAzimuthalAxisAngle_traits;

      const MinAzimuthalAxisAngle_type&
      MinAzimuthalAxisAngle () const;

      MinAzimuthalAxisAngle_type&
      MinAzimuthalAxisAngle ();

      void
      MinAzimuthalAxisAngle (const MinAzimuthalAxisAngle_type& x);

      void
      MinAzimuthalAxisAngle (::std::unique_ptr< MinAzimuthalAxisAngle_type > p);

      // MaxAzimuthalAxisAngle
      //
      typedef ::xsd::qif30::AngularValueType MaxAzimuthalAxisAngle_type;
      typedef ::xsd::cxx::tree::traits< MaxAzimuthalAxisAngle_type, wchar_t > MaxAzimuthalAxisAngle_traits;

      const MaxAzimuthalAxisAngle_type&
      MaxAzimuthalAxisAngle () const;

      MaxAzimuthalAxisAngle_type&
      MaxAzimuthalAxisAngle ();

      void
      MaxAzimuthalAxisAngle (const MaxAzimuthalAxisAngle_type& x);

      void
      MaxAzimuthalAxisAngle (::std::unique_ptr< MaxAzimuthalAxisAngle_type > p);

      // MinPolarAxis
      //
      typedef ::xsd::qif30::AngularValueType MinPolarAxis_type;
      typedef ::xsd::cxx::tree::traits< MinPolarAxis_type, wchar_t > MinPolarAxis_traits;

      const MinPolarAxis_type&
      MinPolarAxis () const;

      MinPolarAxis_type&
      MinPolarAxis ();

      void
      MinPolarAxis (const MinPolarAxis_type& x);

      void
      MinPolarAxis (::std::unique_ptr< MinPolarAxis_type > p);

      // MaxPolarAxis
      //
      typedef ::xsd::qif30::AngularValueType MaxPolarAxis_type;
      typedef ::xsd::cxx::tree::traits< MaxPolarAxis_type, wchar_t > MaxPolarAxis_traits;

      const MaxPolarAxis_type&
      MaxPolarAxis () const;

      MaxPolarAxis_type&
      MaxPolarAxis ();

      void
      MaxPolarAxis (const MaxPolarAxis_type& x);

      void
      MaxPolarAxis (::std::unique_ptr< MaxPolarAxis_type > p);

      // Constructors.
      //
      EffectiveSphericalWorkingVolumeType ();

      EffectiveSphericalWorkingVolumeType (const MinRadialAxis_type&,
                                           const MaxRadialAxis_type&,
                                           const MinAzimuthalAxisAngle_type&,
                                           const MaxAzimuthalAxisAngle_type&,
                                           const MinPolarAxis_type&,
                                           const MaxPolarAxis_type&);

      EffectiveSphericalWorkingVolumeType (::std::unique_ptr< MinRadialAxis_type >,
                                           ::std::unique_ptr< MaxRadialAxis_type >,
                                           ::std::unique_ptr< MinAzimuthalAxisAngle_type >,
                                           ::std::unique_ptr< MaxAzimuthalAxisAngle_type >,
                                           ::std::unique_ptr< MinPolarAxis_type >,
                                           ::std::unique_ptr< MaxPolarAxis_type >);

      EffectiveSphericalWorkingVolumeType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      EffectiveSphericalWorkingVolumeType (const EffectiveSphericalWorkingVolumeType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual EffectiveSphericalWorkingVolumeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EffectiveSphericalWorkingVolumeType&
      operator= (const EffectiveSphericalWorkingVolumeType& x);

      virtual 
      ~EffectiveSphericalWorkingVolumeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< MinRadialAxis_type > MinRadialAxis_;
      ::xsd::cxx::tree::one< MaxRadialAxis_type > MaxRadialAxis_;
      ::xsd::cxx::tree::one< MinAzimuthalAxisAngle_type > MinAzimuthalAxisAngle_;
      ::xsd::cxx::tree::one< MaxAzimuthalAxisAngle_type > MaxAzimuthalAxisAngle_;
      ::xsd::cxx::tree::one< MinPolarAxis_type > MinPolarAxis_;
      ::xsd::cxx::tree::one< MaxPolarAxis_type > MaxPolarAxis_;
    };

    class QIF30_SYMBOL_DECL EffectiveCartesianWorkingVolumeType: public ::xsd::qif30::EffectiveWorkingVolumeBaseType
    {
      public:
      // MinPoint
      //
      typedef ::xsd::qif30::PointType MinPoint_type;
      typedef ::xsd::cxx::tree::traits< MinPoint_type, wchar_t > MinPoint_traits;

      const MinPoint_type&
      MinPoint () const;

      MinPoint_type&
      MinPoint ();

      void
      MinPoint (const MinPoint_type& x);

      void
      MinPoint (::std::unique_ptr< MinPoint_type > p);

      // MaxPoint
      //
      typedef ::xsd::qif30::PointType MaxPoint_type;
      typedef ::xsd::cxx::tree::traits< MaxPoint_type, wchar_t > MaxPoint_traits;

      const MaxPoint_type&
      MaxPoint () const;

      MaxPoint_type&
      MaxPoint ();

      void
      MaxPoint (const MaxPoint_type& x);

      void
      MaxPoint (::std::unique_ptr< MaxPoint_type > p);

      // Constructors.
      //
      EffectiveCartesianWorkingVolumeType ();

      EffectiveCartesianWorkingVolumeType (const MinPoint_type&,
                                           const MaxPoint_type&);

      EffectiveCartesianWorkingVolumeType (::std::unique_ptr< MinPoint_type >,
                                           ::std::unique_ptr< MaxPoint_type >);

      EffectiveCartesianWorkingVolumeType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      EffectiveCartesianWorkingVolumeType (const EffectiveCartesianWorkingVolumeType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual EffectiveCartesianWorkingVolumeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EffectiveCartesianWorkingVolumeType&
      operator= (const EffectiveCartesianWorkingVolumeType& x);

      virtual 
      ~EffectiveCartesianWorkingVolumeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< MinPoint_type > MinPoint_;
      ::xsd::cxx::tree::one< MaxPoint_type > MaxPoint_;
    };

    class QIF30_SYMBOL_DECL EffectiveClosedShellSetWorkingVolumeType: public ::xsd::qif30::EffectiveWorkingVolumeBaseType
    {
      public:
      // WorkingClosedShellSet
      //
      typedef ::xsd::qif30::ClosedShellSetType WorkingClosedShellSet_type;
      typedef ::xsd::cxx::tree::traits< WorkingClosedShellSet_type, wchar_t > WorkingClosedShellSet_traits;

      const WorkingClosedShellSet_type&
      WorkingClosedShellSet () const;

      WorkingClosedShellSet_type&
      WorkingClosedShellSet ();

      void
      WorkingClosedShellSet (const WorkingClosedShellSet_type& x);

      void
      WorkingClosedShellSet (::std::unique_ptr< WorkingClosedShellSet_type > p);

      // Constructors.
      //
      EffectiveClosedShellSetWorkingVolumeType ();

      EffectiveClosedShellSetWorkingVolumeType (const WorkingClosedShellSet_type&);

      EffectiveClosedShellSetWorkingVolumeType (::std::unique_ptr< WorkingClosedShellSet_type >);

      EffectiveClosedShellSetWorkingVolumeType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      EffectiveClosedShellSetWorkingVolumeType (const EffectiveClosedShellSetWorkingVolumeType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual EffectiveClosedShellSetWorkingVolumeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EffectiveClosedShellSetWorkingVolumeType&
      operator= (const EffectiveClosedShellSetWorkingVolumeType& x);

      virtual 
      ~EffectiveClosedShellSetWorkingVolumeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< WorkingClosedShellSet_type > WorkingClosedShellSet_;
    };

    class QIF30_SYMBOL_DECL EffectiveUserDefinedWorkingVolumeType: public ::xsd::qif30::EffectiveWorkingVolumeBaseType
    {
      public:
      // UserDefinedWorkingVolumeId
      //
      typedef ::xsd::qif30::QIFReferenceType UserDefinedWorkingVolumeId_type;
      typedef ::xsd::cxx::tree::traits< UserDefinedWorkingVolumeId_type, wchar_t > UserDefinedWorkingVolumeId_traits;

      const UserDefinedWorkingVolumeId_type&
      UserDefinedWorkingVolumeId () const;

      UserDefinedWorkingVolumeId_type&
      UserDefinedWorkingVolumeId ();

      void
      UserDefinedWorkingVolumeId (const UserDefinedWorkingVolumeId_type& x);

      void
      UserDefinedWorkingVolumeId (::std::unique_ptr< UserDefinedWorkingVolumeId_type > p);

      // MinFirstAxis
      //
      typedef ::xsd::qif30::MeasuredDecimalType MinFirstAxis_type;
      typedef ::xsd::cxx::tree::traits< MinFirstAxis_type, wchar_t > MinFirstAxis_traits;

      const MinFirstAxis_type&
      MinFirstAxis () const;

      MinFirstAxis_type&
      MinFirstAxis ();

      void
      MinFirstAxis (const MinFirstAxis_type& x);

      void
      MinFirstAxis (::std::unique_ptr< MinFirstAxis_type > p);

      // MaxFirstAxis
      //
      typedef ::xsd::qif30::MeasuredDecimalType MaxFirstAxis_type;
      typedef ::xsd::cxx::tree::traits< MaxFirstAxis_type, wchar_t > MaxFirstAxis_traits;

      const MaxFirstAxis_type&
      MaxFirstAxis () const;

      MaxFirstAxis_type&
      MaxFirstAxis ();

      void
      MaxFirstAxis (const MaxFirstAxis_type& x);

      void
      MaxFirstAxis (::std::unique_ptr< MaxFirstAxis_type > p);

      // MinSecondAxis
      //
      typedef ::xsd::qif30::MeasuredDecimalType MinSecondAxis_type;
      typedef ::xsd::cxx::tree::traits< MinSecondAxis_type, wchar_t > MinSecondAxis_traits;

      const MinSecondAxis_type&
      MinSecondAxis () const;

      MinSecondAxis_type&
      MinSecondAxis ();

      void
      MinSecondAxis (const MinSecondAxis_type& x);

      void
      MinSecondAxis (::std::unique_ptr< MinSecondAxis_type > p);

      // MaxSecondAxis
      //
      typedef ::xsd::qif30::MeasuredDecimalType MaxSecondAxis_type;
      typedef ::xsd::cxx::tree::traits< MaxSecondAxis_type, wchar_t > MaxSecondAxis_traits;

      const MaxSecondAxis_type&
      MaxSecondAxis () const;

      MaxSecondAxis_type&
      MaxSecondAxis ();

      void
      MaxSecondAxis (const MaxSecondAxis_type& x);

      void
      MaxSecondAxis (::std::unique_ptr< MaxSecondAxis_type > p);

      // MinThirdAxis
      //
      typedef ::xsd::qif30::MeasuredDecimalType MinThirdAxis_type;
      typedef ::xsd::cxx::tree::traits< MinThirdAxis_type, wchar_t > MinThirdAxis_traits;

      const MinThirdAxis_type&
      MinThirdAxis () const;

      MinThirdAxis_type&
      MinThirdAxis ();

      void
      MinThirdAxis (const MinThirdAxis_type& x);

      void
      MinThirdAxis (::std::unique_ptr< MinThirdAxis_type > p);

      // MaxThirdAxis
      //
      typedef ::xsd::qif30::MeasuredDecimalType MaxThirdAxis_type;
      typedef ::xsd::cxx::tree::traits< MaxThirdAxis_type, wchar_t > MaxThirdAxis_traits;

      const MaxThirdAxis_type&
      MaxThirdAxis () const;

      MaxThirdAxis_type&
      MaxThirdAxis ();

      void
      MaxThirdAxis (const MaxThirdAxis_type& x);

      void
      MaxThirdAxis (::std::unique_ptr< MaxThirdAxis_type > p);

      // Constructors.
      //
      EffectiveUserDefinedWorkingVolumeType ();

      EffectiveUserDefinedWorkingVolumeType (const UserDefinedWorkingVolumeId_type&,
                                             const MinFirstAxis_type&,
                                             const MaxFirstAxis_type&,
                                             const MinSecondAxis_type&,
                                             const MaxSecondAxis_type&,
                                             const MinThirdAxis_type&,
                                             const MaxThirdAxis_type&);

      EffectiveUserDefinedWorkingVolumeType (::std::unique_ptr< UserDefinedWorkingVolumeId_type >,
                                             ::std::unique_ptr< MinFirstAxis_type >,
                                             ::std::unique_ptr< MaxFirstAxis_type >,
                                             ::std::unique_ptr< MinSecondAxis_type >,
                                             ::std::unique_ptr< MaxSecondAxis_type >,
                                             ::std::unique_ptr< MinThirdAxis_type >,
                                             ::std::unique_ptr< MaxThirdAxis_type >);

      EffectiveUserDefinedWorkingVolumeType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      EffectiveUserDefinedWorkingVolumeType (const EffectiveUserDefinedWorkingVolumeType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual EffectiveUserDefinedWorkingVolumeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EffectiveUserDefinedWorkingVolumeType&
      operator= (const EffectiveUserDefinedWorkingVolumeType& x);

      virtual 
      ~EffectiveUserDefinedWorkingVolumeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< UserDefinedWorkingVolumeId_type > UserDefinedWorkingVolumeId_;
      ::xsd::cxx::tree::one< MinFirstAxis_type > MinFirstAxis_;
      ::xsd::cxx::tree::one< MaxFirstAxis_type > MaxFirstAxis_;
      ::xsd::cxx::tree::one< MinSecondAxis_type > MinSecondAxis_;
      ::xsd::cxx::tree::one< MaxSecondAxis_type > MaxSecondAxis_;
      ::xsd::cxx::tree::one< MinThirdAxis_type > MinThirdAxis_;
      ::xsd::cxx::tree::one< MaxThirdAxis_type > MaxThirdAxis_;
    };

    class QIF30_SYMBOL_DECL UserAxisBaseType: public ::xml_schema::type
    {
      public:
      // Constructors.
      //
      UserAxisBaseType ();

      UserAxisBaseType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      UserAxisBaseType (const xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      UserAxisBaseType (const ::std::wstring& s,
                        const xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      UserAxisBaseType (const UserAxisBaseType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual UserAxisBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      UserAxisBaseType&
      operator= (const UserAxisBaseType&) = default;
#endif

      virtual 
      ~UserAxisBaseType ();
    };

    class QIF30_SYMBOL_DECL LinearAxisType: public ::xsd::qif30::UserAxisBaseType
    {
      public:
      // MinLinearAxis
      //
      typedef ::xsd::qif30::LinearValueType MinLinearAxis_type;
      typedef ::xsd::cxx::tree::traits< MinLinearAxis_type, wchar_t > MinLinearAxis_traits;

      const MinLinearAxis_type&
      MinLinearAxis () const;

      MinLinearAxis_type&
      MinLinearAxis ();

      void
      MinLinearAxis (const MinLinearAxis_type& x);

      void
      MinLinearAxis (::std::unique_ptr< MinLinearAxis_type > p);

      // MaxLinearAxis
      //
      typedef ::xsd::qif30::LinearValueType MaxLinearAxis_type;
      typedef ::xsd::cxx::tree::traits< MaxLinearAxis_type, wchar_t > MaxLinearAxis_traits;

      const MaxLinearAxis_type&
      MaxLinearAxis () const;

      MaxLinearAxis_type&
      MaxLinearAxis ();

      void
      MaxLinearAxis (const MaxLinearAxis_type& x);

      void
      MaxLinearAxis (::std::unique_ptr< MaxLinearAxis_type > p);

      // Constructors.
      //
      LinearAxisType ();

      LinearAxisType (const MinLinearAxis_type&,
                      const MaxLinearAxis_type&);

      LinearAxisType (::std::unique_ptr< MinLinearAxis_type >,
                      ::std::unique_ptr< MaxLinearAxis_type >);

      LinearAxisType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      LinearAxisType (const LinearAxisType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual LinearAxisType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LinearAxisType&
      operator= (const LinearAxisType& x);

      virtual 
      ~LinearAxisType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< MinLinearAxis_type > MinLinearAxis_;
      ::xsd::cxx::tree::one< MaxLinearAxis_type > MaxLinearAxis_;
    };

    class QIF30_SYMBOL_DECL RotaryAxisType: public ::xsd::qif30::UserAxisBaseType
    {
      public:
      // MinRotaryAxis
      //
      typedef ::xsd::qif30::AngularValueType MinRotaryAxis_type;
      typedef ::xsd::cxx::tree::traits< MinRotaryAxis_type, wchar_t > MinRotaryAxis_traits;

      const MinRotaryAxis_type&
      MinRotaryAxis () const;

      MinRotaryAxis_type&
      MinRotaryAxis ();

      void
      MinRotaryAxis (const MinRotaryAxis_type& x);

      void
      MinRotaryAxis (::std::unique_ptr< MinRotaryAxis_type > p);

      // MaxRotaryAxis
      //
      typedef ::xsd::qif30::AngularValueType MaxRotaryAxis_type;
      typedef ::xsd::cxx::tree::traits< MaxRotaryAxis_type, wchar_t > MaxRotaryAxis_traits;

      const MaxRotaryAxis_type&
      MaxRotaryAxis () const;

      MaxRotaryAxis_type&
      MaxRotaryAxis ();

      void
      MaxRotaryAxis (const MaxRotaryAxis_type& x);

      void
      MaxRotaryAxis (::std::unique_ptr< MaxRotaryAxis_type > p);

      // Constructors.
      //
      RotaryAxisType ();

      RotaryAxisType (const MinRotaryAxis_type&,
                      const MaxRotaryAxis_type&);

      RotaryAxisType (::std::unique_ptr< MinRotaryAxis_type >,
                      ::std::unique_ptr< MaxRotaryAxis_type >);

      RotaryAxisType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      RotaryAxisType (const RotaryAxisType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual RotaryAxisType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      RotaryAxisType&
      operator= (const RotaryAxisType& x);

      virtual 
      ~RotaryAxisType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< MinRotaryAxis_type > MinRotaryAxis_;
      ::xsd::cxx::tree::one< MaxRotaryAxis_type > MaxRotaryAxis_;
    };

    class QIF30_SYMBOL_DECL ResolutionBaseType: public ::xml_schema::type
    {
      public:
      // Constructors.
      //
      ResolutionBaseType ();

      ResolutionBaseType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      ResolutionBaseType (const xercesc::DOMAttr& a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      ResolutionBaseType (const ::std::wstring& s,
                          const xercesc::DOMElement* e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      ResolutionBaseType (const ResolutionBaseType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual ResolutionBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      ResolutionBaseType&
      operator= (const ResolutionBaseType&) = default;
#endif

      virtual 
      ~ResolutionBaseType ();
    };

    class QIF30_SYMBOL_DECL LinearResolutionType: public ::xsd::qif30::ResolutionBaseType
    {
      public:
      // LinearValue
      //
      typedef ::xsd::qif30::LinearValueType LinearValue_type;
      typedef ::xsd::cxx::tree::traits< LinearValue_type, wchar_t > LinearValue_traits;

      const LinearValue_type&
      LinearValue () const;

      LinearValue_type&
      LinearValue ();

      void
      LinearValue (const LinearValue_type& x);

      void
      LinearValue (::std::unique_ptr< LinearValue_type > p);

      // Constructors.
      //
      LinearResolutionType ();

      LinearResolutionType (const LinearValue_type&);

      LinearResolutionType (::std::unique_ptr< LinearValue_type >);

      LinearResolutionType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      LinearResolutionType (const LinearResolutionType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual LinearResolutionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LinearResolutionType&
      operator= (const LinearResolutionType& x);

      virtual 
      ~LinearResolutionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< LinearValue_type > LinearValue_;
    };

    class QIF30_SYMBOL_DECL CartesianResolutionType: public ::xsd::qif30::ResolutionBaseType
    {
      public:
      // CombinedCartesianResolution
      //
      typedef ::xsd::qif30::LinearValueType CombinedCartesianResolution_type;
      typedef ::xsd::cxx::tree::optional< CombinedCartesianResolution_type > CombinedCartesianResolution_optional;
      typedef ::xsd::cxx::tree::traits< CombinedCartesianResolution_type, wchar_t > CombinedCartesianResolution_traits;

      const CombinedCartesianResolution_optional&
      CombinedCartesianResolution () const;

      CombinedCartesianResolution_optional&
      CombinedCartesianResolution ();

      void
      CombinedCartesianResolution (const CombinedCartesianResolution_type& x);

      void
      CombinedCartesianResolution (const CombinedCartesianResolution_optional& x);

      void
      CombinedCartesianResolution (::std::unique_ptr< CombinedCartesianResolution_type > p);

      // XYZResolution
      //
      typedef ::xsd::qif30::XYZResolutionType XYZResolution_type;
      typedef ::xsd::cxx::tree::optional< XYZResolution_type > XYZResolution_optional;
      typedef ::xsd::cxx::tree::traits< XYZResolution_type, wchar_t > XYZResolution_traits;

      const XYZResolution_optional&
      XYZResolution () const;

      XYZResolution_optional&
      XYZResolution ();

      void
      XYZResolution (const XYZResolution_type& x);

      void
      XYZResolution (const XYZResolution_optional& x);

      void
      XYZResolution (::std::unique_ptr< XYZResolution_type > p);

      // Constructors.
      //
      CartesianResolutionType ();

      CartesianResolutionType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      CartesianResolutionType (const CartesianResolutionType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual CartesianResolutionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CartesianResolutionType&
      operator= (const CartesianResolutionType& x);

      virtual 
      ~CartesianResolutionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CombinedCartesianResolution_optional CombinedCartesianResolution_;
      XYZResolution_optional XYZResolution_;
    };

    class QIF30_SYMBOL_DECL XYZResolutionType: public ::xml_schema::type
    {
      public:
      // XResolution
      //
      typedef ::xsd::qif30::LinearValueType XResolution_type;
      typedef ::xsd::cxx::tree::traits< XResolution_type, wchar_t > XResolution_traits;

      const XResolution_type&
      XResolution () const;

      XResolution_type&
      XResolution ();

      void
      XResolution (const XResolution_type& x);

      void
      XResolution (::std::unique_ptr< XResolution_type > p);

      // YResolution
      //
      typedef ::xsd::qif30::LinearValueType YResolution_type;
      typedef ::xsd::cxx::tree::traits< YResolution_type, wchar_t > YResolution_traits;

      const YResolution_type&
      YResolution () const;

      YResolution_type&
      YResolution ();

      void
      YResolution (const YResolution_type& x);

      void
      YResolution (::std::unique_ptr< YResolution_type > p);

      // ZResolution
      //
      typedef ::xsd::qif30::LinearValueType ZResolution_type;
      typedef ::xsd::cxx::tree::traits< ZResolution_type, wchar_t > ZResolution_traits;

      const ZResolution_type&
      ZResolution () const;

      ZResolution_type&
      ZResolution ();

      void
      ZResolution (const ZResolution_type& x);

      void
      ZResolution (::std::unique_ptr< ZResolution_type > p);

      // Constructors.
      //
      XYZResolutionType ();

      XYZResolutionType (const XResolution_type&,
                         const YResolution_type&,
                         const ZResolution_type&);

      XYZResolutionType (::std::unique_ptr< XResolution_type >,
                         ::std::unique_ptr< YResolution_type >,
                         ::std::unique_ptr< ZResolution_type >);

      XYZResolutionType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      XYZResolutionType (const XYZResolutionType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual XYZResolutionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      XYZResolutionType&
      operator= (const XYZResolutionType& x);

      virtual 
      ~XYZResolutionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< XResolution_type > XResolution_;
      ::xsd::cxx::tree::one< YResolution_type > YResolution_;
      ::xsd::cxx::tree::one< ZResolution_type > ZResolution_;
    };

    class QIF30_SYMBOL_DECL RAPZResolutionType: public ::xml_schema::type
    {
      public:
      // RadialResolution
      //
      typedef ::xsd::qif30::LinearValueType RadialResolution_type;
      typedef ::xsd::cxx::tree::traits< RadialResolution_type, wchar_t > RadialResolution_traits;

      const RadialResolution_type&
      RadialResolution () const;

      RadialResolution_type&
      RadialResolution ();

      void
      RadialResolution (const RadialResolution_type& x);

      void
      RadialResolution (::std::unique_ptr< RadialResolution_type > p);

      // AzimuthalAngleResolution
      //
      typedef ::xsd::qif30::AngularValueType AzimuthalAngleResolution_type;
      typedef ::xsd::cxx::tree::traits< AzimuthalAngleResolution_type, wchar_t > AzimuthalAngleResolution_traits;

      const AzimuthalAngleResolution_type&
      AzimuthalAngleResolution () const;

      AzimuthalAngleResolution_type&
      AzimuthalAngleResolution ();

      void
      AzimuthalAngleResolution (const AzimuthalAngleResolution_type& x);

      void
      AzimuthalAngleResolution (::std::unique_ptr< AzimuthalAngleResolution_type > p);

      // PolarAngleResolution
      //
      typedef ::xsd::qif30::AngularValueType PolarAngleResolution_type;
      typedef ::xsd::cxx::tree::traits< PolarAngleResolution_type, wchar_t > PolarAngleResolution_traits;

      const PolarAngleResolution_type&
      PolarAngleResolution () const;

      PolarAngleResolution_type&
      PolarAngleResolution ();

      void
      PolarAngleResolution (const PolarAngleResolution_type& x);

      void
      PolarAngleResolution (::std::unique_ptr< PolarAngleResolution_type > p);

      // Constructors.
      //
      RAPZResolutionType ();

      RAPZResolutionType (const RadialResolution_type&,
                          const AzimuthalAngleResolution_type&,
                          const PolarAngleResolution_type&);

      RAPZResolutionType (::std::unique_ptr< RadialResolution_type >,
                          ::std::unique_ptr< AzimuthalAngleResolution_type >,
                          ::std::unique_ptr< PolarAngleResolution_type >);

      RAPZResolutionType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      RAPZResolutionType (const RAPZResolutionType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual RAPZResolutionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      RAPZResolutionType&
      operator= (const RAPZResolutionType& x);

      virtual 
      ~RAPZResolutionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< RadialResolution_type > RadialResolution_;
      ::xsd::cxx::tree::one< AzimuthalAngleResolution_type > AzimuthalAngleResolution_;
      ::xsd::cxx::tree::one< PolarAngleResolution_type > PolarAngleResolution_;
    };

    class QIF30_SYMBOL_DECL SphericalResolutionType: public ::xsd::qif30::ResolutionBaseType
    {
      public:
      // CombinedSphericalResolution
      //
      typedef ::xsd::qif30::CombinedSphericalResolutionType CombinedSphericalResolution_type;
      typedef ::xsd::cxx::tree::optional< CombinedSphericalResolution_type > CombinedSphericalResolution_optional;
      typedef ::xsd::cxx::tree::traits< CombinedSphericalResolution_type, wchar_t > CombinedSphericalResolution_traits;

      const CombinedSphericalResolution_optional&
      CombinedSphericalResolution () const;

      CombinedSphericalResolution_optional&
      CombinedSphericalResolution ();

      void
      CombinedSphericalResolution (const CombinedSphericalResolution_type& x);

      void
      CombinedSphericalResolution (const CombinedSphericalResolution_optional& x);

      void
      CombinedSphericalResolution (::std::unique_ptr< CombinedSphericalResolution_type > p);

      // RAPZResolution
      //
      typedef ::xsd::qif30::RAPZResolutionType RAPZResolution_type;
      typedef ::xsd::cxx::tree::optional< RAPZResolution_type > RAPZResolution_optional;
      typedef ::xsd::cxx::tree::traits< RAPZResolution_type, wchar_t > RAPZResolution_traits;

      const RAPZResolution_optional&
      RAPZResolution () const;

      RAPZResolution_optional&
      RAPZResolution ();

      void
      RAPZResolution (const RAPZResolution_type& x);

      void
      RAPZResolution (const RAPZResolution_optional& x);

      void
      RAPZResolution (::std::unique_ptr< RAPZResolution_type > p);

      // RAPResolution
      //
      typedef ::xsd::qif30::RAPZResolutionType RAPResolution_type;
      typedef ::xsd::cxx::tree::optional< RAPResolution_type > RAPResolution_optional;
      typedef ::xsd::cxx::tree::traits< RAPResolution_type, wchar_t > RAPResolution_traits;

      const RAPResolution_optional&
      RAPResolution () const;

      RAPResolution_optional&
      RAPResolution ();

      void
      RAPResolution (const RAPResolution_type& x);

      void
      RAPResolution (const RAPResolution_optional& x);

      void
      RAPResolution (::std::unique_ptr< RAPResolution_type > p);

      // Constructors.
      //
      SphericalResolutionType ();

      SphericalResolutionType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      SphericalResolutionType (const SphericalResolutionType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual SphericalResolutionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SphericalResolutionType&
      operator= (const SphericalResolutionType& x);

      virtual 
      ~SphericalResolutionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CombinedSphericalResolution_optional CombinedSphericalResolution_;
      RAPZResolution_optional RAPZResolution_;
      RAPResolution_optional RAPResolution_;
    };

    class QIF30_SYMBOL_DECL CombinedSphericalResolutionType: public ::xml_schema::type
    {
      public:
      // CombinedRadialResolution
      //
      typedef ::xsd::qif30::LinearValueType CombinedRadialResolution_type;
      typedef ::xsd::cxx::tree::traits< CombinedRadialResolution_type, wchar_t > CombinedRadialResolution_traits;

      const CombinedRadialResolution_type&
      CombinedRadialResolution () const;

      CombinedRadialResolution_type&
      CombinedRadialResolution ();

      void
      CombinedRadialResolution (const CombinedRadialResolution_type& x);

      void
      CombinedRadialResolution (::std::unique_ptr< CombinedRadialResolution_type > p);

      // CombinedAzimuthalResolution
      //
      typedef ::xsd::qif30::AngularValueType CombinedAzimuthalResolution_type;
      typedef ::xsd::cxx::tree::traits< CombinedAzimuthalResolution_type, wchar_t > CombinedAzimuthalResolution_traits;

      const CombinedAzimuthalResolution_type&
      CombinedAzimuthalResolution () const;

      CombinedAzimuthalResolution_type&
      CombinedAzimuthalResolution ();

      void
      CombinedAzimuthalResolution (const CombinedAzimuthalResolution_type& x);

      void
      CombinedAzimuthalResolution (::std::unique_ptr< CombinedAzimuthalResolution_type > p);

      // CombinedPolarResolution
      //
      typedef ::xsd::qif30::AngularValueType CombinedPolarResolution_type;
      typedef ::xsd::cxx::tree::traits< CombinedPolarResolution_type, wchar_t > CombinedPolarResolution_traits;

      const CombinedPolarResolution_type&
      CombinedPolarResolution () const;

      CombinedPolarResolution_type&
      CombinedPolarResolution ();

      void
      CombinedPolarResolution (const CombinedPolarResolution_type& x);

      void
      CombinedPolarResolution (::std::unique_ptr< CombinedPolarResolution_type > p);

      // Constructors.
      //
      CombinedSphericalResolutionType ();

      CombinedSphericalResolutionType (const CombinedRadialResolution_type&,
                                       const CombinedAzimuthalResolution_type&,
                                       const CombinedPolarResolution_type&);

      CombinedSphericalResolutionType (::std::unique_ptr< CombinedRadialResolution_type >,
                                       ::std::unique_ptr< CombinedAzimuthalResolution_type >,
                                       ::std::unique_ptr< CombinedPolarResolution_type >);

      CombinedSphericalResolutionType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      CombinedSphericalResolutionType (const CombinedSphericalResolutionType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual CombinedSphericalResolutionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CombinedSphericalResolutionType&
      operator= (const CombinedSphericalResolutionType& x);

      virtual 
      ~CombinedSphericalResolutionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< CombinedRadialResolution_type > CombinedRadialResolution_;
      ::xsd::cxx::tree::one< CombinedAzimuthalResolution_type > CombinedAzimuthalResolution_;
      ::xsd::cxx::tree::one< CombinedPolarResolution_type > CombinedPolarResolution_;
    };

    class QIF30_SYMBOL_DECL UserDefinedResolutionType: public ::xsd::qif30::ResolutionBaseType
    {
      public:
      // CombinedUserDefinedResolution
      //
      typedef ::xsd::qif30::CombinedUserDefinedResolutionType CombinedUserDefinedResolution_type;
      typedef ::xsd::cxx::tree::optional< CombinedUserDefinedResolution_type > CombinedUserDefinedResolution_optional;
      typedef ::xsd::cxx::tree::traits< CombinedUserDefinedResolution_type, wchar_t > CombinedUserDefinedResolution_traits;

      const CombinedUserDefinedResolution_optional&
      CombinedUserDefinedResolution () const;

      CombinedUserDefinedResolution_optional&
      CombinedUserDefinedResolution ();

      void
      CombinedUserDefinedResolution (const CombinedUserDefinedResolution_type& x);

      void
      CombinedUserDefinedResolution (const CombinedUserDefinedResolution_optional& x);

      void
      CombinedUserDefinedResolution (::std::unique_ptr< CombinedUserDefinedResolution_type > p);

      // ABCResolution
      //
      typedef ::xsd::qif30::ABCResolutionType ABCResolution_type;
      typedef ::xsd::cxx::tree::traits< ABCResolution_type, wchar_t > ABCResolution_traits;

      const ABCResolution_type&
      ABCResolution () const;

      ABCResolution_type&
      ABCResolution ();

      void
      ABCResolution (const ABCResolution_type& x);

      void
      ABCResolution (::std::unique_ptr< ABCResolution_type > p);

      // Constructors.
      //
      UserDefinedResolutionType ();

      UserDefinedResolutionType (const ABCResolution_type&);

      UserDefinedResolutionType (::std::unique_ptr< ABCResolution_type >);

      UserDefinedResolutionType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      UserDefinedResolutionType (const UserDefinedResolutionType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual UserDefinedResolutionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UserDefinedResolutionType&
      operator= (const UserDefinedResolutionType& x);

      virtual 
      ~UserDefinedResolutionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CombinedUserDefinedResolution_optional CombinedUserDefinedResolution_;
      ::xsd::cxx::tree::one< ABCResolution_type > ABCResolution_;
    };

    class QIF30_SYMBOL_DECL ABCResolutionType: public ::xml_schema::type
    {
      public:
      // AAxisResolution
      //
      typedef ::xsd::qif30::LinearOrRotaryAxisType AAxisResolution_type;
      typedef ::xsd::cxx::tree::traits< AAxisResolution_type, wchar_t > AAxisResolution_traits;

      const AAxisResolution_type&
      AAxisResolution () const;

      AAxisResolution_type&
      AAxisResolution ();

      void
      AAxisResolution (const AAxisResolution_type& x);

      void
      AAxisResolution (::std::unique_ptr< AAxisResolution_type > p);

      // BAxisResolution
      //
      typedef ::xsd::qif30::LinearOrRotaryAxisType BAxisResolution_type;
      typedef ::xsd::cxx::tree::traits< BAxisResolution_type, wchar_t > BAxisResolution_traits;

      const BAxisResolution_type&
      BAxisResolution () const;

      BAxisResolution_type&
      BAxisResolution ();

      void
      BAxisResolution (const BAxisResolution_type& x);

      void
      BAxisResolution (::std::unique_ptr< BAxisResolution_type > p);

      // CAxisResolution
      //
      typedef ::xsd::qif30::LinearOrRotaryAxisType CAxisResolution_type;
      typedef ::xsd::cxx::tree::traits< CAxisResolution_type, wchar_t > CAxisResolution_traits;

      const CAxisResolution_type&
      CAxisResolution () const;

      CAxisResolution_type&
      CAxisResolution ();

      void
      CAxisResolution (const CAxisResolution_type& x);

      void
      CAxisResolution (::std::unique_ptr< CAxisResolution_type > p);

      // Constructors.
      //
      ABCResolutionType ();

      ABCResolutionType (const AAxisResolution_type&,
                         const BAxisResolution_type&,
                         const CAxisResolution_type&);

      ABCResolutionType (::std::unique_ptr< AAxisResolution_type >,
                         ::std::unique_ptr< BAxisResolution_type >,
                         ::std::unique_ptr< CAxisResolution_type >);

      ABCResolutionType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      ABCResolutionType (const ABCResolutionType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual ABCResolutionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ABCResolutionType&
      operator= (const ABCResolutionType& x);

      virtual 
      ~ABCResolutionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< AAxisResolution_type > AAxisResolution_;
      ::xsd::cxx::tree::one< BAxisResolution_type > BAxisResolution_;
      ::xsd::cxx::tree::one< CAxisResolution_type > CAxisResolution_;
    };

    class QIF30_SYMBOL_DECL CombinedUserDefinedResolutionType: public ::xml_schema::type
    {
      public:
      // ACombinedResolution
      //
      typedef ::xsd::qif30::LinearOrRotaryAxisType ACombinedResolution_type;
      typedef ::xsd::cxx::tree::traits< ACombinedResolution_type, wchar_t > ACombinedResolution_traits;

      const ACombinedResolution_type&
      ACombinedResolution () const;

      ACombinedResolution_type&
      ACombinedResolution ();

      void
      ACombinedResolution (const ACombinedResolution_type& x);

      void
      ACombinedResolution (::std::unique_ptr< ACombinedResolution_type > p);

      // BCombinedResolution
      //
      typedef ::xsd::qif30::LinearOrRotaryAxisType BCombinedResolution_type;
      typedef ::xsd::cxx::tree::traits< BCombinedResolution_type, wchar_t > BCombinedResolution_traits;

      const BCombinedResolution_type&
      BCombinedResolution () const;

      BCombinedResolution_type&
      BCombinedResolution ();

      void
      BCombinedResolution (const BCombinedResolution_type& x);

      void
      BCombinedResolution (::std::unique_ptr< BCombinedResolution_type > p);

      // CCombinedResolution
      //
      typedef ::xsd::qif30::LinearOrRotaryAxisType CCombinedResolution_type;
      typedef ::xsd::cxx::tree::traits< CCombinedResolution_type, wchar_t > CCombinedResolution_traits;

      const CCombinedResolution_type&
      CCombinedResolution () const;

      CCombinedResolution_type&
      CCombinedResolution ();

      void
      CCombinedResolution (const CCombinedResolution_type& x);

      void
      CCombinedResolution (::std::unique_ptr< CCombinedResolution_type > p);

      // Constructors.
      //
      CombinedUserDefinedResolutionType ();

      CombinedUserDefinedResolutionType (const ACombinedResolution_type&,
                                         const BCombinedResolution_type&,
                                         const CCombinedResolution_type&);

      CombinedUserDefinedResolutionType (::std::unique_ptr< ACombinedResolution_type >,
                                         ::std::unique_ptr< BCombinedResolution_type >,
                                         ::std::unique_ptr< CCombinedResolution_type >);

      CombinedUserDefinedResolutionType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      CombinedUserDefinedResolutionType (const CombinedUserDefinedResolutionType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual CombinedUserDefinedResolutionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CombinedUserDefinedResolutionType&
      operator= (const CombinedUserDefinedResolutionType& x);

      virtual 
      ~CombinedUserDefinedResolutionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ACombinedResolution_type > ACombinedResolution_;
      ::xsd::cxx::tree::one< BCombinedResolution_type > BCombinedResolution_;
      ::xsd::cxx::tree::one< CCombinedResolution_type > CCombinedResolution_;
    };

    class QIF30_SYMBOL_DECL CalibrationMasterType: public ::xml_schema::type
    {
      public:
      // SerialNumber
      //
      typedef ::xml_schema::string SerialNumber_type;
      typedef ::xsd::cxx::tree::traits< SerialNumber_type, wchar_t > SerialNumber_traits;

      const SerialNumber_type&
      SerialNumber () const;

      SerialNumber_type&
      SerialNumber ();

      void
      SerialNumber (const SerialNumber_type& x);

      void
      SerialNumber (::std::unique_ptr< SerialNumber_type > p);

      // Description
      //
      typedef ::xml_schema::string Description_type;
      typedef ::xsd::cxx::tree::optional< Description_type > Description_optional;
      typedef ::xsd::cxx::tree::traits< Description_type, wchar_t > Description_traits;

      const Description_optional&
      Description () const;

      Description_optional&
      Description ();

      void
      Description (const Description_type& x);

      void
      Description (const Description_optional& x);

      void
      Description (::std::unique_ptr< Description_type > p);

      // Constructors.
      //
      CalibrationMasterType ();

      CalibrationMasterType (const SerialNumber_type&);

      CalibrationMasterType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      CalibrationMasterType (const CalibrationMasterType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual CalibrationMasterType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CalibrationMasterType&
      operator= (const CalibrationMasterType& x);

      virtual 
      ~CalibrationMasterType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SerialNumber_type > SerialNumber_;
      Description_optional Description_;
    };

    class QIF30_SYMBOL_DECL CalibrationType: public ::xml_schema::type
    {
      public:
      // CalibrationMaster
      //
      typedef ::xsd::qif30::CalibrationMasterType CalibrationMaster_type;
      typedef ::xsd::cxx::tree::optional< CalibrationMaster_type > CalibrationMaster_optional;
      typedef ::xsd::cxx::tree::traits< CalibrationMaster_type, wchar_t > CalibrationMaster_traits;

      const CalibrationMaster_optional&
      CalibrationMaster () const;

      CalibrationMaster_optional&
      CalibrationMaster ();

      void
      CalibrationMaster (const CalibrationMaster_type& x);

      void
      CalibrationMaster (const CalibrationMaster_optional& x);

      void
      CalibrationMaster (::std::unique_ptr< CalibrationMaster_type > p);

      // Temperatures
      //
      typedef ::xsd::qif30::TemperaturesType Temperatures_type;
      typedef ::xsd::cxx::tree::optional< Temperatures_type > Temperatures_optional;
      typedef ::xsd::cxx::tree::traits< Temperatures_type, wchar_t > Temperatures_traits;

      const Temperatures_optional&
      Temperatures () const;

      Temperatures_optional&
      Temperatures ();

      void
      Temperatures (const Temperatures_type& x);

      void
      Temperatures (const Temperatures_optional& x);

      void
      Temperatures (::std::unique_ptr< Temperatures_type > p);

      // CalibrationDate
      //
      typedef ::xml_schema::date_time CalibrationDate_type;
      typedef ::xsd::cxx::tree::optional< CalibrationDate_type > CalibrationDate_optional;
      typedef ::xsd::cxx::tree::traits< CalibrationDate_type, wchar_t > CalibrationDate_traits;

      const CalibrationDate_optional&
      CalibrationDate () const;

      CalibrationDate_optional&
      CalibrationDate ();

      void
      CalibrationDate (const CalibrationDate_type& x);

      void
      CalibrationDate (const CalibrationDate_optional& x);

      void
      CalibrationDate (::std::unique_ptr< CalibrationDate_type > p);

      // ExpirationDate
      //
      typedef ::xml_schema::date_time ExpirationDate_type;
      typedef ::xsd::cxx::tree::traits< ExpirationDate_type, wchar_t > ExpirationDate_traits;

      const ExpirationDate_type&
      ExpirationDate () const;

      ExpirationDate_type&
      ExpirationDate ();

      void
      ExpirationDate (const ExpirationDate_type& x);

      void
      ExpirationDate (::std::unique_ptr< ExpirationDate_type > p);

      // Constructors.
      //
      CalibrationType ();

      CalibrationType (const ExpirationDate_type&);

      CalibrationType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      CalibrationType (const CalibrationType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual CalibrationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CalibrationType&
      operator= (const CalibrationType& x);

      virtual 
      ~CalibrationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CalibrationMaster_optional CalibrationMaster_;
      Temperatures_optional Temperatures_;
      CalibrationDate_optional CalibrationDate_;
      ::xsd::cxx::tree::one< ExpirationDate_type > ExpirationDate_;
    };

    class QIF30_SYMBOL_DECL CalibrationsType: public ::xml_schema::type
    {
      public:
      // Calibration
      //
      typedef ::xsd::qif30::CalibrationType Calibration_type;
      typedef ::xsd::cxx::tree::sequence< Calibration_type > Calibration_sequence;
      typedef xsd::cxx::tree::sequence< Calibration_type >::iterator Calibration_iterator;
      typedef xsd::cxx::tree::sequence< Calibration_type >::const_iterator Calibration_const_iterator;
      typedef ::xsd::cxx::tree::traits< Calibration_type, wchar_t > Calibration_traits;

      const Calibration_sequence&
      Calibration () const;

      Calibration_sequence&
      Calibration ();

      void
      Calibration (const Calibration_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      CalibrationsType ();

      CalibrationsType (const n_type&);

      CalibrationsType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      CalibrationsType (const CalibrationsType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual CalibrationsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CalibrationsType&
      operator= (const CalibrationsType& x);

      virtual 
      ~CalibrationsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Calibration_sequence Calibration_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL QualificationsType: public ::xml_schema::type
    {
      public:
      // Qualification
      //
      typedef ::xsd::qif30::QualificationType Qualification_type;
      typedef ::xsd::cxx::tree::sequence< Qualification_type > Qualification_sequence;
      typedef xsd::cxx::tree::sequence< Qualification_type >::iterator Qualification_iterator;
      typedef xsd::cxx::tree::sequence< Qualification_type >::const_iterator Qualification_const_iterator;
      typedef ::xsd::cxx::tree::traits< Qualification_type, wchar_t > Qualification_traits;

      const Qualification_sequence&
      Qualification () const;

      Qualification_sequence&
      Qualification ();

      void
      Qualification (const Qualification_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      QualificationsType ();

      QualificationsType (const n_type&);

      QualificationsType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      QualificationsType (const QualificationsType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual QualificationsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      QualificationsType&
      operator= (const QualificationsType& x);

      virtual 
      ~QualificationsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Qualification_sequence Qualification_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL QualificationType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // Description
      //
      typedef ::xml_schema::string Description_type;
      typedef ::xsd::cxx::tree::traits< Description_type, wchar_t > Description_traits;

      const Description_type&
      Description () const;

      Description_type&
      Description ();

      void
      Description (const Description_type& x);

      void
      Description (::std::unique_ptr< Description_type > p);

      // Constructors.
      //
      QualificationType ();

      QualificationType (const Description_type&);

      QualificationType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      QualificationType (const QualificationType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual QualificationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      QualificationType&
      operator= (const QualificationType& x);

      virtual 
      ~QualificationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      ::xsd::cxx::tree::one< Description_type > Description_;
    };

    class QIF30_SYMBOL_DECL TemperaturesType: public ::xml_schema::type
    {
      public:
      // Temperature
      //
      typedef ::xsd::qif30::TemperatureType Temperature_type;
      typedef ::xsd::cxx::tree::sequence< Temperature_type > Temperature_sequence;
      typedef xsd::cxx::tree::sequence< Temperature_type >::iterator Temperature_iterator;
      typedef xsd::cxx::tree::sequence< Temperature_type >::const_iterator Temperature_const_iterator;
      typedef ::xsd::cxx::tree::traits< Temperature_type, wchar_t > Temperature_traits;

      const Temperature_sequence&
      Temperature () const;

      Temperature_sequence&
      Temperature ();

      void
      Temperature (const Temperature_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      TemperaturesType ();

      TemperaturesType (const n_type&);

      TemperaturesType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      TemperaturesType (const TemperaturesType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual TemperaturesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TemperaturesType&
      operator= (const TemperaturesType& x);

      virtual 
      ~TemperaturesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Temperature_sequence Temperature_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL TemperatureType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // Temperature
      //
      typedef ::xsd::qif30::TemperatureValueType Temperature_type;
      typedef ::xsd::cxx::tree::traits< Temperature_type, wchar_t > Temperature_traits;

      const Temperature_type&
      Temperature () const;

      Temperature_type&
      Temperature ();

      void
      Temperature (const Temperature_type& x);

      void
      Temperature (::std::unique_ptr< Temperature_type > p);

      // TimeStamp
      //
      typedef ::xml_schema::date_time TimeStamp_type;
      typedef ::xsd::cxx::tree::optional< TimeStamp_type > TimeStamp_optional;
      typedef ::xsd::cxx::tree::traits< TimeStamp_type, wchar_t > TimeStamp_traits;

      const TimeStamp_optional&
      TimeStamp () const;

      TimeStamp_optional&
      TimeStamp ();

      void
      TimeStamp (const TimeStamp_type& x);

      void
      TimeStamp (const TimeStamp_optional& x);

      void
      TimeStamp (::std::unique_ptr< TimeStamp_type > p);

      // Constructors.
      //
      TemperatureType ();

      TemperatureType (const Temperature_type&);

      TemperatureType (::std::unique_ptr< Temperature_type >);

      TemperatureType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      TemperatureType (const TemperatureType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual TemperatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TemperatureType&
      operator= (const TemperatureType& x);

      virtual 
      ~TemperatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      ::xsd::cxx::tree::one< Temperature_type > Temperature_;
      TimeStamp_optional TimeStamp_;
    };

    class QIF30_SYMBOL_DECL LinearVariableDifferentialTransformerEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        AC_LINEAR_VARIABLE_DIFFERENTIAL_TRANSFORMER,
        DC_LINEAR_VARIABLE_DIFFERENTIAL_TRANSFORMER
      };

      LinearVariableDifferentialTransformerEnumType ();

      LinearVariableDifferentialTransformerEnumType (value v);

      LinearVariableDifferentialTransformerEnumType (const wchar_t* v);

      LinearVariableDifferentialTransformerEnumType (const ::std::wstring& v);

      LinearVariableDifferentialTransformerEnumType (const ::xml_schema::nmtoken& v);

      LinearVariableDifferentialTransformerEnumType (const xercesc::DOMElement& e,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

      LinearVariableDifferentialTransformerEnumType (const xercesc::DOMAttr& a,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

      LinearVariableDifferentialTransformerEnumType (const ::std::wstring& s,
                                                     const xercesc::DOMElement* e,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

      LinearVariableDifferentialTransformerEnumType (const LinearVariableDifferentialTransformerEnumType& x,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      LinearVariableDifferentialTransformerEnumType&
      operator= (const LinearVariableDifferentialTransformerEnumType&) = default;
#endif

      virtual LinearVariableDifferentialTransformerEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LinearVariableDifferentialTransformerEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_LinearVariableDifferentialTransformerEnumType_convert ();
      }

      protected:
      value
      _xsd_LinearVariableDifferentialTransformerEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_LinearVariableDifferentialTransformerEnumType_literals_[2];
      static const value _xsd_LinearVariableDifferentialTransformerEnumType_indexes_[2];
    };

    class QIF30_SYMBOL_DECL LinearVariableDifferentialTransformerSensorType: public ::xsd::qif30::DetachableSensorBaseType
    {
      public:
      // TypeOfLinearVariableDifferentialTransformer
      //
      typedef ::xsd::qif30::LinearVariableDifferentialTransformerEnumType TypeOfLinearVariableDifferentialTransformer_type;
      typedef ::xsd::cxx::tree::optional< TypeOfLinearVariableDifferentialTransformer_type > TypeOfLinearVariableDifferentialTransformer_optional;
      typedef ::xsd::cxx::tree::traits< TypeOfLinearVariableDifferentialTransformer_type, wchar_t > TypeOfLinearVariableDifferentialTransformer_traits;

      const TypeOfLinearVariableDifferentialTransformer_optional&
      TypeOfLinearVariableDifferentialTransformer () const;

      TypeOfLinearVariableDifferentialTransformer_optional&
      TypeOfLinearVariableDifferentialTransformer ();

      void
      TypeOfLinearVariableDifferentialTransformer (const TypeOfLinearVariableDifferentialTransformer_type& x);

      void
      TypeOfLinearVariableDifferentialTransformer (const TypeOfLinearVariableDifferentialTransformer_optional& x);

      void
      TypeOfLinearVariableDifferentialTransformer (::std::unique_ptr< TypeOfLinearVariableDifferentialTransformer_type > p);

      // MinMeasuringDistance
      //
      typedef ::xsd::qif30::LinearValueType MinMeasuringDistance_type;
      typedef ::xsd::cxx::tree::optional< MinMeasuringDistance_type > MinMeasuringDistance_optional;
      typedef ::xsd::cxx::tree::traits< MinMeasuringDistance_type, wchar_t > MinMeasuringDistance_traits;

      const MinMeasuringDistance_optional&
      MinMeasuringDistance () const;

      MinMeasuringDistance_optional&
      MinMeasuringDistance ();

      void
      MinMeasuringDistance (const MinMeasuringDistance_type& x);

      void
      MinMeasuringDistance (const MinMeasuringDistance_optional& x);

      void
      MinMeasuringDistance (::std::unique_ptr< MinMeasuringDistance_type > p);

      // MaxMeasuringDistance
      //
      typedef ::xsd::qif30::LinearValueType MaxMeasuringDistance_type;
      typedef ::xsd::cxx::tree::optional< MaxMeasuringDistance_type > MaxMeasuringDistance_optional;
      typedef ::xsd::cxx::tree::traits< MaxMeasuringDistance_type, wchar_t > MaxMeasuringDistance_traits;

      const MaxMeasuringDistance_optional&
      MaxMeasuringDistance () const;

      MaxMeasuringDistance_optional&
      MaxMeasuringDistance ();

      void
      MaxMeasuringDistance (const MaxMeasuringDistance_type& x);

      void
      MaxMeasuringDistance (const MaxMeasuringDistance_optional& x);

      void
      MaxMeasuringDistance (::std::unique_ptr< MaxMeasuringDistance_type > p);

      // TemperatureStability
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType TemperatureStability_type;
      typedef ::xsd::cxx::tree::optional< TemperatureStability_type > TemperatureStability_optional;
      typedef ::xsd::cxx::tree::traits< TemperatureStability_type, wchar_t > TemperatureStability_traits;

      const TemperatureStability_optional&
      TemperatureStability () const;

      TemperatureStability_optional&
      TemperatureStability ();

      void
      TemperatureStability (const TemperatureStability_type& x);

      void
      TemperatureStability (const TemperatureStability_optional& x);

      void
      TemperatureStability (::std::unique_ptr< TemperatureStability_type > p);

      // ExcitationFrequency
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType ExcitationFrequency_type;
      typedef ::xsd::cxx::tree::optional< ExcitationFrequency_type > ExcitationFrequency_optional;
      typedef ::xsd::cxx::tree::traits< ExcitationFrequency_type, wchar_t > ExcitationFrequency_traits;

      const ExcitationFrequency_optional&
      ExcitationFrequency () const;

      ExcitationFrequency_optional&
      ExcitationFrequency ();

      void
      ExcitationFrequency (const ExcitationFrequency_type& x);

      void
      ExcitationFrequency (const ExcitationFrequency_optional& x);

      void
      ExcitationFrequency (::std::unique_ptr< ExcitationFrequency_type > p);

      // ExcitationAmplitude
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType ExcitationAmplitude_type;
      typedef ::xsd::cxx::tree::optional< ExcitationAmplitude_type > ExcitationAmplitude_optional;
      typedef ::xsd::cxx::tree::traits< ExcitationAmplitude_type, wchar_t > ExcitationAmplitude_traits;

      const ExcitationAmplitude_optional&
      ExcitationAmplitude () const;

      ExcitationAmplitude_optional&
      ExcitationAmplitude ();

      void
      ExcitationAmplitude (const ExcitationAmplitude_type& x);

      void
      ExcitationAmplitude (const ExcitationAmplitude_optional& x);

      void
      ExcitationAmplitude (::std::unique_ptr< ExcitationAmplitude_type > p);

      // Diameter
      //
      typedef ::xsd::qif30::LinearValueType Diameter_type;
      typedef ::xsd::cxx::tree::optional< Diameter_type > Diameter_optional;
      typedef ::xsd::cxx::tree::traits< Diameter_type, wchar_t > Diameter_traits;

      const Diameter_optional&
      Diameter () const;

      Diameter_optional&
      Diameter ();

      void
      Diameter (const Diameter_type& x);

      void
      Diameter (const Diameter_optional& x);

      void
      Diameter (::std::unique_ptr< Diameter_type > p);

      // ShockTolerance
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType ShockTolerance_type;
      typedef ::xsd::cxx::tree::optional< ShockTolerance_type > ShockTolerance_optional;
      typedef ::xsd::cxx::tree::traits< ShockTolerance_type, wchar_t > ShockTolerance_traits;

      const ShockTolerance_optional&
      ShockTolerance () const;

      ShockTolerance_optional&
      ShockTolerance ();

      void
      ShockTolerance (const ShockTolerance_type& x);

      void
      ShockTolerance (const ShockTolerance_optional& x);

      void
      ShockTolerance (::std::unique_ptr< ShockTolerance_type > p);

      // VibrationTolerance
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType VibrationTolerance_type;
      typedef ::xsd::cxx::tree::optional< VibrationTolerance_type > VibrationTolerance_optional;
      typedef ::xsd::cxx::tree::traits< VibrationTolerance_type, wchar_t > VibrationTolerance_traits;

      const VibrationTolerance_optional&
      VibrationTolerance () const;

      VibrationTolerance_optional&
      VibrationTolerance ();

      void
      VibrationTolerance (const VibrationTolerance_type& x);

      void
      VibrationTolerance (const VibrationTolerance_optional& x);

      void
      VibrationTolerance (::std::unique_ptr< VibrationTolerance_type > p);

      // HousingMaterial
      //
      typedef ::xml_schema::string HousingMaterial_type;
      typedef ::xsd::cxx::tree::optional< HousingMaterial_type > HousingMaterial_optional;
      typedef ::xsd::cxx::tree::traits< HousingMaterial_type, wchar_t > HousingMaterial_traits;

      const HousingMaterial_optional&
      HousingMaterial () const;

      HousingMaterial_optional&
      HousingMaterial ();

      void
      HousingMaterial (const HousingMaterial_type& x);

      void
      HousingMaterial (const HousingMaterial_optional& x);

      void
      HousingMaterial (::std::unique_ptr< HousingMaterial_type > p);

      // ElectronicDescription
      //
      typedef ::xml_schema::string ElectronicDescription_type;
      typedef ::xsd::cxx::tree::optional< ElectronicDescription_type > ElectronicDescription_optional;
      typedef ::xsd::cxx::tree::traits< ElectronicDescription_type, wchar_t > ElectronicDescription_traits;

      const ElectronicDescription_optional&
      ElectronicDescription () const;

      ElectronicDescription_optional&
      ElectronicDescription ();

      void
      ElectronicDescription (const ElectronicDescription_type& x);

      void
      ElectronicDescription (const ElectronicDescription_optional& x);

      void
      ElectronicDescription (::std::unique_ptr< ElectronicDescription_type > p);

      // Constructors.
      //
      LinearVariableDifferentialTransformerSensorType ();

      LinearVariableDifferentialTransformerSensorType (const Name_type&,
                                                       const id_type&);

      LinearVariableDifferentialTransformerSensorType (const xercesc::DOMElement& e,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

      LinearVariableDifferentialTransformerSensorType (const LinearVariableDifferentialTransformerSensorType& x,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

      virtual LinearVariableDifferentialTransformerSensorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LinearVariableDifferentialTransformerSensorType&
      operator= (const LinearVariableDifferentialTransformerSensorType& x);

      virtual 
      ~LinearVariableDifferentialTransformerSensorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      TypeOfLinearVariableDifferentialTransformer_optional TypeOfLinearVariableDifferentialTransformer_;
      MinMeasuringDistance_optional MinMeasuringDistance_;
      MaxMeasuringDistance_optional MaxMeasuringDistance_;
      TemperatureStability_optional TemperatureStability_;
      ExcitationFrequency_optional ExcitationFrequency_;
      ExcitationAmplitude_optional ExcitationAmplitude_;
      Diameter_optional Diameter_;
      ShockTolerance_optional ShockTolerance_;
      VibrationTolerance_optional VibrationTolerance_;
      HousingMaterial_optional HousingMaterial_;
      ElectronicDescription_optional ElectronicDescription_;
    };

    class QIF30_SYMBOL_DECL CapacitiveSensorType: public ::xsd::qif30::DetachableSensorBaseType
    {
      public:
      // MinOperatingVoltage
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType MinOperatingVoltage_type;
      typedef ::xsd::cxx::tree::optional< MinOperatingVoltage_type > MinOperatingVoltage_optional;
      typedef ::xsd::cxx::tree::traits< MinOperatingVoltage_type, wchar_t > MinOperatingVoltage_traits;

      const MinOperatingVoltage_optional&
      MinOperatingVoltage () const;

      MinOperatingVoltage_optional&
      MinOperatingVoltage ();

      void
      MinOperatingVoltage (const MinOperatingVoltage_type& x);

      void
      MinOperatingVoltage (const MinOperatingVoltage_optional& x);

      void
      MinOperatingVoltage (::std::unique_ptr< MinOperatingVoltage_type > p);

      // MaxOperatingVoltage
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType MaxOperatingVoltage_type;
      typedef ::xsd::cxx::tree::optional< MaxOperatingVoltage_type > MaxOperatingVoltage_optional;
      typedef ::xsd::cxx::tree::traits< MaxOperatingVoltage_type, wchar_t > MaxOperatingVoltage_traits;

      const MaxOperatingVoltage_optional&
      MaxOperatingVoltage () const;

      MaxOperatingVoltage_optional&
      MaxOperatingVoltage ();

      void
      MaxOperatingVoltage (const MaxOperatingVoltage_type& x);

      void
      MaxOperatingVoltage (const MaxOperatingVoltage_optional& x);

      void
      MaxOperatingVoltage (::std::unique_ptr< MaxOperatingVoltage_type > p);

      // MinMeasuringDistance
      //
      typedef ::xsd::qif30::LinearValueType MinMeasuringDistance_type;
      typedef ::xsd::cxx::tree::optional< MinMeasuringDistance_type > MinMeasuringDistance_optional;
      typedef ::xsd::cxx::tree::traits< MinMeasuringDistance_type, wchar_t > MinMeasuringDistance_traits;

      const MinMeasuringDistance_optional&
      MinMeasuringDistance () const;

      MinMeasuringDistance_optional&
      MinMeasuringDistance ();

      void
      MinMeasuringDistance (const MinMeasuringDistance_type& x);

      void
      MinMeasuringDistance (const MinMeasuringDistance_optional& x);

      void
      MinMeasuringDistance (::std::unique_ptr< MinMeasuringDistance_type > p);

      // MaxMeasuringDistance
      //
      typedef ::xsd::qif30::LinearValueType MaxMeasuringDistance_type;
      typedef ::xsd::cxx::tree::optional< MaxMeasuringDistance_type > MaxMeasuringDistance_optional;
      typedef ::xsd::cxx::tree::traits< MaxMeasuringDistance_type, wchar_t > MaxMeasuringDistance_traits;

      const MaxMeasuringDistance_optional&
      MaxMeasuringDistance () const;

      MaxMeasuringDistance_optional&
      MaxMeasuringDistance ();

      void
      MaxMeasuringDistance (const MaxMeasuringDistance_type& x);

      void
      MaxMeasuringDistance (const MaxMeasuringDistance_optional& x);

      void
      MaxMeasuringDistance (::std::unique_ptr< MaxMeasuringDistance_type > p);

      // TemperatureStability
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType TemperatureStability_type;
      typedef ::xsd::cxx::tree::optional< TemperatureStability_type > TemperatureStability_optional;
      typedef ::xsd::cxx::tree::traits< TemperatureStability_type, wchar_t > TemperatureStability_traits;

      const TemperatureStability_optional&
      TemperatureStability () const;

      TemperatureStability_optional&
      TemperatureStability ();

      void
      TemperatureStability (const TemperatureStability_type& x);

      void
      TemperatureStability (const TemperatureStability_optional& x);

      void
      TemperatureStability (::std::unique_ptr< TemperatureStability_type > p);

      // MinimumTargetDiameter
      //
      typedef ::xsd::qif30::LinearValueType MinimumTargetDiameter_type;
      typedef ::xsd::cxx::tree::optional< MinimumTargetDiameter_type > MinimumTargetDiameter_optional;
      typedef ::xsd::cxx::tree::traits< MinimumTargetDiameter_type, wchar_t > MinimumTargetDiameter_traits;

      const MinimumTargetDiameter_optional&
      MinimumTargetDiameter () const;

      MinimumTargetDiameter_optional&
      MinimumTargetDiameter ();

      void
      MinimumTargetDiameter (const MinimumTargetDiameter_type& x);

      void
      MinimumTargetDiameter (const MinimumTargetDiameter_optional& x);

      void
      MinimumTargetDiameter (::std::unique_ptr< MinimumTargetDiameter_type > p);

      // HousingMaterial
      //
      typedef ::xml_schema::string HousingMaterial_type;
      typedef ::xsd::cxx::tree::optional< HousingMaterial_type > HousingMaterial_optional;
      typedef ::xsd::cxx::tree::traits< HousingMaterial_type, wchar_t > HousingMaterial_traits;

      const HousingMaterial_optional&
      HousingMaterial () const;

      HousingMaterial_optional&
      HousingMaterial ();

      void
      HousingMaterial (const HousingMaterial_type& x);

      void
      HousingMaterial (const HousingMaterial_optional& x);

      void
      HousingMaterial (::std::unique_ptr< HousingMaterial_type > p);

      // Mounting
      //
      typedef ::xml_schema::string Mounting_type;
      typedef ::xsd::cxx::tree::optional< Mounting_type > Mounting_optional;
      typedef ::xsd::cxx::tree::traits< Mounting_type, wchar_t > Mounting_traits;

      const Mounting_optional&
      Mounting () const;

      Mounting_optional&
      Mounting ();

      void
      Mounting (const Mounting_type& x);

      void
      Mounting (const Mounting_optional& x);

      void
      Mounting (::std::unique_ptr< Mounting_type > p);

      // Constructors.
      //
      CapacitiveSensorType ();

      CapacitiveSensorType (const Name_type&,
                            const id_type&);

      CapacitiveSensorType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      CapacitiveSensorType (const CapacitiveSensorType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual CapacitiveSensorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CapacitiveSensorType&
      operator= (const CapacitiveSensorType& x);

      virtual 
      ~CapacitiveSensorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MinOperatingVoltage_optional MinOperatingVoltage_;
      MaxOperatingVoltage_optional MaxOperatingVoltage_;
      MinMeasuringDistance_optional MinMeasuringDistance_;
      MaxMeasuringDistance_optional MaxMeasuringDistance_;
      TemperatureStability_optional TemperatureStability_;
      MinimumTargetDiameter_optional MinimumTargetDiameter_;
      HousingMaterial_optional HousingMaterial_;
      Mounting_optional Mounting_;
    };

    class QIF30_SYMBOL_DECL EddyCurrentSensorType: public ::xsd::qif30::SensorType
    {
      public:
      // MaxPressureFront
      //
      typedef ::xsd::qif30::PressureValueType MaxPressureFront_type;
      typedef ::xsd::cxx::tree::optional< MaxPressureFront_type > MaxPressureFront_optional;
      typedef ::xsd::cxx::tree::traits< MaxPressureFront_type, wchar_t > MaxPressureFront_traits;

      const MaxPressureFront_optional&
      MaxPressureFront () const;

      MaxPressureFront_optional&
      MaxPressureFront ();

      void
      MaxPressureFront (const MaxPressureFront_type& x);

      void
      MaxPressureFront (const MaxPressureFront_optional& x);

      void
      MaxPressureFront (::std::unique_ptr< MaxPressureFront_type > p);

      // MaxPressureSide
      //
      typedef ::xsd::qif30::PressureValueType MaxPressureSide_type;
      typedef ::xsd::cxx::tree::optional< MaxPressureSide_type > MaxPressureSide_optional;
      typedef ::xsd::cxx::tree::traits< MaxPressureSide_type, wchar_t > MaxPressureSide_traits;

      const MaxPressureSide_optional&
      MaxPressureSide () const;

      MaxPressureSide_optional&
      MaxPressureSide ();

      void
      MaxPressureSide (const MaxPressureSide_type& x);

      void
      MaxPressureSide (const MaxPressureSide_optional& x);

      void
      MaxPressureSide (::std::unique_ptr< MaxPressureSide_type > p);

      // MinMeasuringDistance
      //
      typedef ::xsd::qif30::LinearValueType MinMeasuringDistance_type;
      typedef ::xsd::cxx::tree::optional< MinMeasuringDistance_type > MinMeasuringDistance_optional;
      typedef ::xsd::cxx::tree::traits< MinMeasuringDistance_type, wchar_t > MinMeasuringDistance_traits;

      const MinMeasuringDistance_optional&
      MinMeasuringDistance () const;

      MinMeasuringDistance_optional&
      MinMeasuringDistance ();

      void
      MinMeasuringDistance (const MinMeasuringDistance_type& x);

      void
      MinMeasuringDistance (const MinMeasuringDistance_optional& x);

      void
      MinMeasuringDistance (::std::unique_ptr< MinMeasuringDistance_type > p);

      // MaxMeasuringDistance
      //
      typedef ::xsd::qif30::LinearValueType MaxMeasuringDistance_type;
      typedef ::xsd::cxx::tree::optional< MaxMeasuringDistance_type > MaxMeasuringDistance_optional;
      typedef ::xsd::cxx::tree::traits< MaxMeasuringDistance_type, wchar_t > MaxMeasuringDistance_traits;

      const MaxMeasuringDistance_optional&
      MaxMeasuringDistance () const;

      MaxMeasuringDistance_optional&
      MaxMeasuringDistance ();

      void
      MaxMeasuringDistance (const MaxMeasuringDistance_type& x);

      void
      MaxMeasuringDistance (const MaxMeasuringDistance_optional& x);

      void
      MaxMeasuringDistance (::std::unique_ptr< MaxMeasuringDistance_type > p);

      // TemperatureStability
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType TemperatureStability_type;
      typedef ::xsd::cxx::tree::optional< TemperatureStability_type > TemperatureStability_optional;
      typedef ::xsd::cxx::tree::traits< TemperatureStability_type, wchar_t > TemperatureStability_traits;

      const TemperatureStability_optional&
      TemperatureStability () const;

      TemperatureStability_optional&
      TemperatureStability ();

      void
      TemperatureStability (const TemperatureStability_type& x);

      void
      TemperatureStability (const TemperatureStability_optional& x);

      void
      TemperatureStability (::std::unique_ptr< TemperatureStability_type > p);

      // OffsetDistance
      //
      typedef ::xsd::qif30::LinearValueType OffsetDistance_type;
      typedef ::xsd::cxx::tree::optional< OffsetDistance_type > OffsetDistance_optional;
      typedef ::xsd::cxx::tree::traits< OffsetDistance_type, wchar_t > OffsetDistance_traits;

      const OffsetDistance_optional&
      OffsetDistance () const;

      OffsetDistance_optional&
      OffsetDistance ();

      void
      OffsetDistance (const OffsetDistance_type& x);

      void
      OffsetDistance (const OffsetDistance_optional& x);

      void
      OffsetDistance (::std::unique_ptr< OffsetDistance_type > p);

      // FrequencyResponse
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType FrequencyResponse_type;
      typedef ::xsd::cxx::tree::optional< FrequencyResponse_type > FrequencyResponse_optional;
      typedef ::xsd::cxx::tree::traits< FrequencyResponse_type, wchar_t > FrequencyResponse_traits;

      const FrequencyResponse_optional&
      FrequencyResponse () const;

      FrequencyResponse_optional&
      FrequencyResponse ();

      void
      FrequencyResponse (const FrequencyResponse_type& x);

      void
      FrequencyResponse (const FrequencyResponse_optional& x);

      void
      FrequencyResponse (::std::unique_ptr< FrequencyResponse_type > p);

      // MinPowerSupplyVoltage
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType MinPowerSupplyVoltage_type;
      typedef ::xsd::cxx::tree::optional< MinPowerSupplyVoltage_type > MinPowerSupplyVoltage_optional;
      typedef ::xsd::cxx::tree::traits< MinPowerSupplyVoltage_type, wchar_t > MinPowerSupplyVoltage_traits;

      const MinPowerSupplyVoltage_optional&
      MinPowerSupplyVoltage () const;

      MinPowerSupplyVoltage_optional&
      MinPowerSupplyVoltage ();

      void
      MinPowerSupplyVoltage (const MinPowerSupplyVoltage_type& x);

      void
      MinPowerSupplyVoltage (const MinPowerSupplyVoltage_optional& x);

      void
      MinPowerSupplyVoltage (::std::unique_ptr< MinPowerSupplyVoltage_type > p);

      // MaxPowerSupplyVoltage
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType MaxPowerSupplyVoltage_type;
      typedef ::xsd::cxx::tree::optional< MaxPowerSupplyVoltage_type > MaxPowerSupplyVoltage_optional;
      typedef ::xsd::cxx::tree::traits< MaxPowerSupplyVoltage_type, wchar_t > MaxPowerSupplyVoltage_traits;

      const MaxPowerSupplyVoltage_optional&
      MaxPowerSupplyVoltage () const;

      MaxPowerSupplyVoltage_optional&
      MaxPowerSupplyVoltage ();

      void
      MaxPowerSupplyVoltage (const MaxPowerSupplyVoltage_type& x);

      void
      MaxPowerSupplyVoltage (const MaxPowerSupplyVoltage_optional& x);

      void
      MaxPowerSupplyVoltage (::std::unique_ptr< MaxPowerSupplyVoltage_type > p);

      // HousingMaterial
      //
      typedef ::xml_schema::string HousingMaterial_type;
      typedef ::xsd::cxx::tree::optional< HousingMaterial_type > HousingMaterial_optional;
      typedef ::xsd::cxx::tree::traits< HousingMaterial_type, wchar_t > HousingMaterial_traits;

      const HousingMaterial_optional&
      HousingMaterial () const;

      HousingMaterial_optional&
      HousingMaterial ();

      void
      HousingMaterial (const HousingMaterial_type& x);

      void
      HousingMaterial (const HousingMaterial_optional& x);

      void
      HousingMaterial (::std::unique_ptr< HousingMaterial_type > p);

      // MeasurementObjectMaterial
      //
      typedef ::xml_schema::string MeasurementObjectMaterial_type;
      typedef ::xsd::cxx::tree::optional< MeasurementObjectMaterial_type > MeasurementObjectMaterial_optional;
      typedef ::xsd::cxx::tree::traits< MeasurementObjectMaterial_type, wchar_t > MeasurementObjectMaterial_traits;

      const MeasurementObjectMaterial_optional&
      MeasurementObjectMaterial () const;

      MeasurementObjectMaterial_optional&
      MeasurementObjectMaterial ();

      void
      MeasurementObjectMaterial (const MeasurementObjectMaterial_type& x);

      void
      MeasurementObjectMaterial (const MeasurementObjectMaterial_optional& x);

      void
      MeasurementObjectMaterial (::std::unique_ptr< MeasurementObjectMaterial_type > p);

      // Constructors.
      //
      EddyCurrentSensorType ();

      EddyCurrentSensorType (const Name_type&,
                             const id_type&);

      EddyCurrentSensorType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      EddyCurrentSensorType (const EddyCurrentSensorType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual EddyCurrentSensorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EddyCurrentSensorType&
      operator= (const EddyCurrentSensorType& x);

      virtual 
      ~EddyCurrentSensorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MaxPressureFront_optional MaxPressureFront_;
      MaxPressureSide_optional MaxPressureSide_;
      MinMeasuringDistance_optional MinMeasuringDistance_;
      MaxMeasuringDistance_optional MaxMeasuringDistance_;
      TemperatureStability_optional TemperatureStability_;
      OffsetDistance_optional OffsetDistance_;
      FrequencyResponse_optional FrequencyResponse_;
      MinPowerSupplyVoltage_optional MinPowerSupplyVoltage_;
      MaxPowerSupplyVoltage_optional MaxPowerSupplyVoltage_;
      HousingMaterial_optional HousingMaterial_;
      MeasurementObjectMaterial_optional MeasurementObjectMaterial_;
    };

    class QIF30_SYMBOL_DECL ConfocalChromaticSensorType: public ::xsd::qif30::SensorType
    {
      public:
      // SpotDiameter
      //
      typedef ::xsd::qif30::LinearValueType SpotDiameter_type;
      typedef ::xsd::cxx::tree::optional< SpotDiameter_type > SpotDiameter_optional;
      typedef ::xsd::cxx::tree::traits< SpotDiameter_type, wchar_t > SpotDiameter_traits;

      const SpotDiameter_optional&
      SpotDiameter () const;

      SpotDiameter_optional&
      SpotDiameter ();

      void
      SpotDiameter (const SpotDiameter_type& x);

      void
      SpotDiameter (const SpotDiameter_optional& x);

      void
      SpotDiameter (::std::unique_ptr< SpotDiameter_type > p);

      // MinMeasuringDistance
      //
      typedef ::xsd::qif30::LinearValueType MinMeasuringDistance_type;
      typedef ::xsd::cxx::tree::optional< MinMeasuringDistance_type > MinMeasuringDistance_optional;
      typedef ::xsd::cxx::tree::traits< MinMeasuringDistance_type, wchar_t > MinMeasuringDistance_traits;

      const MinMeasuringDistance_optional&
      MinMeasuringDistance () const;

      MinMeasuringDistance_optional&
      MinMeasuringDistance ();

      void
      MinMeasuringDistance (const MinMeasuringDistance_type& x);

      void
      MinMeasuringDistance (const MinMeasuringDistance_optional& x);

      void
      MinMeasuringDistance (::std::unique_ptr< MinMeasuringDistance_type > p);

      // MaxMeasuringDistance
      //
      typedef ::xsd::qif30::LinearValueType MaxMeasuringDistance_type;
      typedef ::xsd::cxx::tree::optional< MaxMeasuringDistance_type > MaxMeasuringDistance_optional;
      typedef ::xsd::cxx::tree::traits< MaxMeasuringDistance_type, wchar_t > MaxMeasuringDistance_traits;

      const MaxMeasuringDistance_optional&
      MaxMeasuringDistance () const;

      MaxMeasuringDistance_optional&
      MaxMeasuringDistance ();

      void
      MaxMeasuringDistance (const MaxMeasuringDistance_type& x);

      void
      MaxMeasuringDistance (const MaxMeasuringDistance_optional& x);

      void
      MaxMeasuringDistance (::std::unique_ptr< MaxMeasuringDistance_type > p);

      // MultiPeakMeasurement
      //
      typedef ::xml_schema::int_ MultiPeakMeasurement_type;
      typedef ::xsd::cxx::tree::optional< MultiPeakMeasurement_type > MultiPeakMeasurement_optional;
      typedef ::xsd::cxx::tree::traits< MultiPeakMeasurement_type, wchar_t > MultiPeakMeasurement_traits;

      const MultiPeakMeasurement_optional&
      MultiPeakMeasurement () const;

      MultiPeakMeasurement_optional&
      MultiPeakMeasurement ();

      void
      MultiPeakMeasurement (const MultiPeakMeasurement_type& x);

      void
      MultiPeakMeasurement (const MultiPeakMeasurement_optional& x);

      // LightSource
      //
      typedef ::xml_schema::string LightSource_type;
      typedef ::xsd::cxx::tree::optional< LightSource_type > LightSource_optional;
      typedef ::xsd::cxx::tree::traits< LightSource_type, wchar_t > LightSource_traits;

      const LightSource_optional&
      LightSource () const;

      LightSource_optional&
      LightSource ();

      void
      LightSource (const LightSource_type& x);

      void
      LightSource (const LightSource_optional& x);

      void
      LightSource (::std::unique_ptr< LightSource_type > p);

      // MaxTilt
      //
      typedef ::xsd::qif30::AngularValueType MaxTilt_type;
      typedef ::xsd::cxx::tree::optional< MaxTilt_type > MaxTilt_optional;
      typedef ::xsd::cxx::tree::traits< MaxTilt_type, wchar_t > MaxTilt_traits;

      const MaxTilt_optional&
      MaxTilt () const;

      MaxTilt_optional&
      MaxTilt ();

      void
      MaxTilt (const MaxTilt_type& x);

      void
      MaxTilt (const MaxTilt_optional& x);

      void
      MaxTilt (::std::unique_ptr< MaxTilt_type > p);

      // HousingMaterial
      //
      typedef ::xml_schema::string HousingMaterial_type;
      typedef ::xsd::cxx::tree::optional< HousingMaterial_type > HousingMaterial_optional;
      typedef ::xsd::cxx::tree::traits< HousingMaterial_type, wchar_t > HousingMaterial_traits;

      const HousingMaterial_optional&
      HousingMaterial () const;

      HousingMaterial_optional&
      HousingMaterial ();

      void
      HousingMaterial (const HousingMaterial_type& x);

      void
      HousingMaterial (const HousingMaterial_optional& x);

      void
      HousingMaterial (::std::unique_ptr< HousingMaterial_type > p);

      // OpticalFiberCableLength
      //
      typedef ::xsd::qif30::LinearValueType OpticalFiberCableLength_type;
      typedef ::xsd::cxx::tree::optional< OpticalFiberCableLength_type > OpticalFiberCableLength_optional;
      typedef ::xsd::cxx::tree::traits< OpticalFiberCableLength_type, wchar_t > OpticalFiberCableLength_traits;

      const OpticalFiberCableLength_optional&
      OpticalFiberCableLength () const;

      OpticalFiberCableLength_optional&
      OpticalFiberCableLength ();

      void
      OpticalFiberCableLength (const OpticalFiberCableLength_type& x);

      void
      OpticalFiberCableLength (const OpticalFiberCableLength_optional& x);

      void
      OpticalFiberCableLength (::std::unique_ptr< OpticalFiberCableLength_type > p);

      // ShockTolerance
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType ShockTolerance_type;
      typedef ::xsd::cxx::tree::optional< ShockTolerance_type > ShockTolerance_optional;
      typedef ::xsd::cxx::tree::traits< ShockTolerance_type, wchar_t > ShockTolerance_traits;

      const ShockTolerance_optional&
      ShockTolerance () const;

      ShockTolerance_optional&
      ShockTolerance ();

      void
      ShockTolerance (const ShockTolerance_type& x);

      void
      ShockTolerance (const ShockTolerance_optional& x);

      void
      ShockTolerance (::std::unique_ptr< ShockTolerance_type > p);

      // VibrationTolerance
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType VibrationTolerance_type;
      typedef ::xsd::cxx::tree::optional< VibrationTolerance_type > VibrationTolerance_optional;
      typedef ::xsd::cxx::tree::traits< VibrationTolerance_type, wchar_t > VibrationTolerance_traits;

      const VibrationTolerance_optional&
      VibrationTolerance () const;

      VibrationTolerance_optional&
      VibrationTolerance ();

      void
      VibrationTolerance (const VibrationTolerance_type& x);

      void
      VibrationTolerance (const VibrationTolerance_optional& x);

      void
      VibrationTolerance (::std::unique_ptr< VibrationTolerance_type > p);

      // Constructors.
      //
      ConfocalChromaticSensorType ();

      ConfocalChromaticSensorType (const Name_type&,
                                   const id_type&);

      ConfocalChromaticSensorType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      ConfocalChromaticSensorType (const ConfocalChromaticSensorType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual ConfocalChromaticSensorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConfocalChromaticSensorType&
      operator= (const ConfocalChromaticSensorType& x);

      virtual 
      ~ConfocalChromaticSensorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      SpotDiameter_optional SpotDiameter_;
      MinMeasuringDistance_optional MinMeasuringDistance_;
      MaxMeasuringDistance_optional MaxMeasuringDistance_;
      MultiPeakMeasurement_optional MultiPeakMeasurement_;
      LightSource_optional LightSource_;
      MaxTilt_optional MaxTilt_;
      HousingMaterial_optional HousingMaterial_;
      OpticalFiberCableLength_optional OpticalFiberCableLength_;
      ShockTolerance_optional ShockTolerance_;
      VibrationTolerance_optional VibrationTolerance_;
    };

    class QIF30_SYMBOL_DECL DrawWireSensorType: public ::xsd::qif30::SensorType
    {
      public:
      // MinMeasuringDistance
      //
      typedef ::xsd::qif30::LinearValueType MinMeasuringDistance_type;
      typedef ::xsd::cxx::tree::optional< MinMeasuringDistance_type > MinMeasuringDistance_optional;
      typedef ::xsd::cxx::tree::traits< MinMeasuringDistance_type, wchar_t > MinMeasuringDistance_traits;

      const MinMeasuringDistance_optional&
      MinMeasuringDistance () const;

      MinMeasuringDistance_optional&
      MinMeasuringDistance ();

      void
      MinMeasuringDistance (const MinMeasuringDistance_type& x);

      void
      MinMeasuringDistance (const MinMeasuringDistance_optional& x);

      void
      MinMeasuringDistance (::std::unique_ptr< MinMeasuringDistance_type > p);

      // MaxMeasuringDistance
      //
      typedef ::xsd::qif30::LinearValueType MaxMeasuringDistance_type;
      typedef ::xsd::cxx::tree::optional< MaxMeasuringDistance_type > MaxMeasuringDistance_optional;
      typedef ::xsd::cxx::tree::traits< MaxMeasuringDistance_type, wchar_t > MaxMeasuringDistance_traits;

      const MaxMeasuringDistance_optional&
      MaxMeasuringDistance () const;

      MaxMeasuringDistance_optional&
      MaxMeasuringDistance ();

      void
      MaxMeasuringDistance (const MaxMeasuringDistance_type& x);

      void
      MaxMeasuringDistance (const MaxMeasuringDistance_optional& x);

      void
      MaxMeasuringDistance (::std::unique_ptr< MaxMeasuringDistance_type > p);

      // MaxWireExtensionForce
      //
      typedef ::xsd::qif30::ForceValueType MaxWireExtensionForce_type;
      typedef ::xsd::cxx::tree::optional< MaxWireExtensionForce_type > MaxWireExtensionForce_optional;
      typedef ::xsd::cxx::tree::traits< MaxWireExtensionForce_type, wchar_t > MaxWireExtensionForce_traits;

      const MaxWireExtensionForce_optional&
      MaxWireExtensionForce () const;

      MaxWireExtensionForce_optional&
      MaxWireExtensionForce ();

      void
      MaxWireExtensionForce (const MaxWireExtensionForce_type& x);

      void
      MaxWireExtensionForce (const MaxWireExtensionForce_optional& x);

      void
      MaxWireExtensionForce (::std::unique_ptr< MaxWireExtensionForce_type > p);

      // MinWireRetractionForce
      //
      typedef ::xsd::qif30::ForceValueType MinWireRetractionForce_type;
      typedef ::xsd::cxx::tree::optional< MinWireRetractionForce_type > MinWireRetractionForce_optional;
      typedef ::xsd::cxx::tree::traits< MinWireRetractionForce_type, wchar_t > MinWireRetractionForce_traits;

      const MinWireRetractionForce_optional&
      MinWireRetractionForce () const;

      MinWireRetractionForce_optional&
      MinWireRetractionForce ();

      void
      MinWireRetractionForce (const MinWireRetractionForce_type& x);

      void
      MinWireRetractionForce (const MinWireRetractionForce_optional& x);

      void
      MinWireRetractionForce (::std::unique_ptr< MinWireRetractionForce_type > p);

      // MaxWireAcceleration
      //
      typedef ::xml_schema::string MaxWireAcceleration_type;
      typedef ::xsd::cxx::tree::optional< MaxWireAcceleration_type > MaxWireAcceleration_optional;
      typedef ::xsd::cxx::tree::traits< MaxWireAcceleration_type, wchar_t > MaxWireAcceleration_traits;

      const MaxWireAcceleration_optional&
      MaxWireAcceleration () const;

      MaxWireAcceleration_optional&
      MaxWireAcceleration ();

      void
      MaxWireAcceleration (const MaxWireAcceleration_type& x);

      void
      MaxWireAcceleration (const MaxWireAcceleration_optional& x);

      void
      MaxWireAcceleration (::std::unique_ptr< MaxWireAcceleration_type > p);

      // Constructors.
      //
      DrawWireSensorType ();

      DrawWireSensorType (const Name_type&,
                          const id_type&);

      DrawWireSensorType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      DrawWireSensorType (const DrawWireSensorType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual DrawWireSensorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DrawWireSensorType&
      operator= (const DrawWireSensorType& x);

      virtual 
      ~DrawWireSensorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MinMeasuringDistance_optional MinMeasuringDistance_;
      MaxMeasuringDistance_optional MaxMeasuringDistance_;
      MaxWireExtensionForce_optional MaxWireExtensionForce_;
      MinWireRetractionForce_optional MinWireRetractionForce_;
      MaxWireAcceleration_optional MaxWireAcceleration_;
    };

    class QIF30_SYMBOL_DECL MagnetoInductiveSensorType: public ::xsd::qif30::SensorType
    {
      public:
      // MinMeasuringDistance
      //
      typedef ::xsd::qif30::LinearValueType MinMeasuringDistance_type;
      typedef ::xsd::cxx::tree::optional< MinMeasuringDistance_type > MinMeasuringDistance_optional;
      typedef ::xsd::cxx::tree::traits< MinMeasuringDistance_type, wchar_t > MinMeasuringDistance_traits;

      const MinMeasuringDistance_optional&
      MinMeasuringDistance () const;

      MinMeasuringDistance_optional&
      MinMeasuringDistance ();

      void
      MinMeasuringDistance (const MinMeasuringDistance_type& x);

      void
      MinMeasuringDistance (const MinMeasuringDistance_optional& x);

      void
      MinMeasuringDistance (::std::unique_ptr< MinMeasuringDistance_type > p);

      // MaxMeasuringDistance
      //
      typedef ::xsd::qif30::LinearValueType MaxMeasuringDistance_type;
      typedef ::xsd::cxx::tree::optional< MaxMeasuringDistance_type > MaxMeasuringDistance_optional;
      typedef ::xsd::cxx::tree::traits< MaxMeasuringDistance_type, wchar_t > MaxMeasuringDistance_traits;

      const MaxMeasuringDistance_optional&
      MaxMeasuringDistance () const;

      MaxMeasuringDistance_optional&
      MaxMeasuringDistance ();

      void
      MaxMeasuringDistance (const MaxMeasuringDistance_type& x);

      void
      MaxMeasuringDistance (const MaxMeasuringDistance_optional& x);

      void
      MaxMeasuringDistance (::std::unique_ptr< MaxMeasuringDistance_type > p);

      // FrequencyResponse
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType FrequencyResponse_type;
      typedef ::xsd::cxx::tree::optional< FrequencyResponse_type > FrequencyResponse_optional;
      typedef ::xsd::cxx::tree::traits< FrequencyResponse_type, wchar_t > FrequencyResponse_traits;

      const FrequencyResponse_optional&
      FrequencyResponse () const;

      FrequencyResponse_optional&
      FrequencyResponse ();

      void
      FrequencyResponse (const FrequencyResponse_type& x);

      void
      FrequencyResponse (const FrequencyResponse_optional& x);

      void
      FrequencyResponse (::std::unique_ptr< FrequencyResponse_type > p);

      // OffsetDistance
      //
      typedef ::xsd::qif30::LinearValueType OffsetDistance_type;
      typedef ::xsd::cxx::tree::optional< OffsetDistance_type > OffsetDistance_optional;
      typedef ::xsd::cxx::tree::traits< OffsetDistance_type, wchar_t > OffsetDistance_traits;

      const OffsetDistance_optional&
      OffsetDistance () const;

      OffsetDistance_optional&
      OffsetDistance ();

      void
      OffsetDistance (const OffsetDistance_type& x);

      void
      OffsetDistance (const OffsetDistance_optional& x);

      void
      OffsetDistance (::std::unique_ptr< OffsetDistance_type > p);

      // MaxPressure
      //
      typedef ::xsd::qif30::PressureValueType MaxPressure_type;
      typedef ::xsd::cxx::tree::optional< MaxPressure_type > MaxPressure_optional;
      typedef ::xsd::cxx::tree::traits< MaxPressure_type, wchar_t > MaxPressure_traits;

      const MaxPressure_optional&
      MaxPressure () const;

      MaxPressure_optional&
      MaxPressure ();

      void
      MaxPressure (const MaxPressure_type& x);

      void
      MaxPressure (const MaxPressure_optional& x);

      void
      MaxPressure (::std::unique_ptr< MaxPressure_type > p);

      // ShockTolerance
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType ShockTolerance_type;
      typedef ::xsd::cxx::tree::optional< ShockTolerance_type > ShockTolerance_optional;
      typedef ::xsd::cxx::tree::traits< ShockTolerance_type, wchar_t > ShockTolerance_traits;

      const ShockTolerance_optional&
      ShockTolerance () const;

      ShockTolerance_optional&
      ShockTolerance ();

      void
      ShockTolerance (const ShockTolerance_type& x);

      void
      ShockTolerance (const ShockTolerance_optional& x);

      void
      ShockTolerance (::std::unique_ptr< ShockTolerance_type > p);

      // VibrationTolerance
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType VibrationTolerance_type;
      typedef ::xsd::cxx::tree::optional< VibrationTolerance_type > VibrationTolerance_optional;
      typedef ::xsd::cxx::tree::traits< VibrationTolerance_type, wchar_t > VibrationTolerance_traits;

      const VibrationTolerance_optional&
      VibrationTolerance () const;

      VibrationTolerance_optional&
      VibrationTolerance ();

      void
      VibrationTolerance (const VibrationTolerance_type& x);

      void
      VibrationTolerance (const VibrationTolerance_optional& x);

      void
      VibrationTolerance (::std::unique_ptr< VibrationTolerance_type > p);

      // HousingMaterial
      //
      typedef ::xml_schema::string HousingMaterial_type;
      typedef ::xsd::cxx::tree::optional< HousingMaterial_type > HousingMaterial_optional;
      typedef ::xsd::cxx::tree::traits< HousingMaterial_type, wchar_t > HousingMaterial_traits;

      const HousingMaterial_optional&
      HousingMaterial () const;

      HousingMaterial_optional&
      HousingMaterial ();

      void
      HousingMaterial (const HousingMaterial_type& x);

      void
      HousingMaterial (const HousingMaterial_optional& x);

      void
      HousingMaterial (::std::unique_ptr< HousingMaterial_type > p);

      // MaxCurrentConsumption
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType MaxCurrentConsumption_type;
      typedef ::xsd::cxx::tree::optional< MaxCurrentConsumption_type > MaxCurrentConsumption_optional;
      typedef ::xsd::cxx::tree::traits< MaxCurrentConsumption_type, wchar_t > MaxCurrentConsumption_traits;

      const MaxCurrentConsumption_optional&
      MaxCurrentConsumption () const;

      MaxCurrentConsumption_optional&
      MaxCurrentConsumption ();

      void
      MaxCurrentConsumption (const MaxCurrentConsumption_type& x);

      void
      MaxCurrentConsumption (const MaxCurrentConsumption_optional& x);

      void
      MaxCurrentConsumption (::std::unique_ptr< MaxCurrentConsumption_type > p);

      // MinPowerSupplyVoltage
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType MinPowerSupplyVoltage_type;
      typedef ::xsd::cxx::tree::optional< MinPowerSupplyVoltage_type > MinPowerSupplyVoltage_optional;
      typedef ::xsd::cxx::tree::traits< MinPowerSupplyVoltage_type, wchar_t > MinPowerSupplyVoltage_traits;

      const MinPowerSupplyVoltage_optional&
      MinPowerSupplyVoltage () const;

      MinPowerSupplyVoltage_optional&
      MinPowerSupplyVoltage ();

      void
      MinPowerSupplyVoltage (const MinPowerSupplyVoltage_type& x);

      void
      MinPowerSupplyVoltage (const MinPowerSupplyVoltage_optional& x);

      void
      MinPowerSupplyVoltage (::std::unique_ptr< MinPowerSupplyVoltage_type > p);

      // MaxPowerSupplyVoltage
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType MaxPowerSupplyVoltage_type;
      typedef ::xsd::cxx::tree::optional< MaxPowerSupplyVoltage_type > MaxPowerSupplyVoltage_optional;
      typedef ::xsd::cxx::tree::traits< MaxPowerSupplyVoltage_type, wchar_t > MaxPowerSupplyVoltage_traits;

      const MaxPowerSupplyVoltage_optional&
      MaxPowerSupplyVoltage () const;

      MaxPowerSupplyVoltage_optional&
      MaxPowerSupplyVoltage ();

      void
      MaxPowerSupplyVoltage (const MaxPowerSupplyVoltage_type& x);

      void
      MaxPowerSupplyVoltage (const MaxPowerSupplyVoltage_optional& x);

      void
      MaxPowerSupplyVoltage (::std::unique_ptr< MaxPowerSupplyVoltage_type > p);

      // Constructors.
      //
      MagnetoInductiveSensorType ();

      MagnetoInductiveSensorType (const Name_type&,
                                  const id_type&);

      MagnetoInductiveSensorType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      MagnetoInductiveSensorType (const MagnetoInductiveSensorType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual MagnetoInductiveSensorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MagnetoInductiveSensorType&
      operator= (const MagnetoInductiveSensorType& x);

      virtual 
      ~MagnetoInductiveSensorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MinMeasuringDistance_optional MinMeasuringDistance_;
      MaxMeasuringDistance_optional MaxMeasuringDistance_;
      FrequencyResponse_optional FrequencyResponse_;
      OffsetDistance_optional OffsetDistance_;
      MaxPressure_optional MaxPressure_;
      ShockTolerance_optional ShockTolerance_;
      VibrationTolerance_optional VibrationTolerance_;
      HousingMaterial_optional HousingMaterial_;
      MaxCurrentConsumption_optional MaxCurrentConsumption_;
      MinPowerSupplyVoltage_optional MinPowerSupplyVoltage_;
      MaxPowerSupplyVoltage_optional MaxPowerSupplyVoltage_;
    };

    class QIF30_SYMBOL_DECL DifferentialVariableReluctanceTransducerSensorType: public ::xsd::qif30::SensorType
    {
      public:
      // MinMeasuringDistance
      //
      typedef ::xsd::qif30::LinearValueType MinMeasuringDistance_type;
      typedef ::xsd::cxx::tree::optional< MinMeasuringDistance_type > MinMeasuringDistance_optional;
      typedef ::xsd::cxx::tree::traits< MinMeasuringDistance_type, wchar_t > MinMeasuringDistance_traits;

      const MinMeasuringDistance_optional&
      MinMeasuringDistance () const;

      MinMeasuringDistance_optional&
      MinMeasuringDistance ();

      void
      MinMeasuringDistance (const MinMeasuringDistance_type& x);

      void
      MinMeasuringDistance (const MinMeasuringDistance_optional& x);

      void
      MinMeasuringDistance (::std::unique_ptr< MinMeasuringDistance_type > p);

      // MaxMeasuringDistance
      //
      typedef ::xsd::qif30::LinearValueType MaxMeasuringDistance_type;
      typedef ::xsd::cxx::tree::optional< MaxMeasuringDistance_type > MaxMeasuringDistance_optional;
      typedef ::xsd::cxx::tree::traits< MaxMeasuringDistance_type, wchar_t > MaxMeasuringDistance_traits;

      const MaxMeasuringDistance_optional&
      MaxMeasuringDistance () const;

      MaxMeasuringDistance_optional&
      MaxMeasuringDistance ();

      void
      MaxMeasuringDistance (const MaxMeasuringDistance_type& x);

      void
      MaxMeasuringDistance (const MaxMeasuringDistance_optional& x);

      void
      MaxMeasuringDistance (::std::unique_ptr< MaxMeasuringDistance_type > p);

      // Hysteresis
      //
      typedef ::xsd::qif30::LinearValueType Hysteresis_type;
      typedef ::xsd::cxx::tree::optional< Hysteresis_type > Hysteresis_optional;
      typedef ::xsd::cxx::tree::traits< Hysteresis_type, wchar_t > Hysteresis_traits;

      const Hysteresis_optional&
      Hysteresis () const;

      Hysteresis_optional&
      Hysteresis ();

      void
      Hysteresis (const Hysteresis_type& x);

      void
      Hysteresis (const Hysteresis_optional& x);

      void
      Hysteresis (::std::unique_ptr< Hysteresis_type > p);

      // FrequencyResponse
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType FrequencyResponse_type;
      typedef ::xsd::cxx::tree::optional< FrequencyResponse_type > FrequencyResponse_optional;
      typedef ::xsd::cxx::tree::traits< FrequencyResponse_type, wchar_t > FrequencyResponse_traits;

      const FrequencyResponse_optional&
      FrequencyResponse () const;

      FrequencyResponse_optional&
      FrequencyResponse ();

      void
      FrequencyResponse (const FrequencyResponse_type& x);

      void
      FrequencyResponse (const FrequencyResponse_optional& x);

      void
      FrequencyResponse (::std::unique_ptr< FrequencyResponse_type > p);

      // TemperatureStability
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType TemperatureStability_type;
      typedef ::xsd::cxx::tree::optional< TemperatureStability_type > TemperatureStability_optional;
      typedef ::xsd::cxx::tree::traits< TemperatureStability_type, wchar_t > TemperatureStability_traits;

      const TemperatureStability_optional&
      TemperatureStability () const;

      TemperatureStability_optional&
      TemperatureStability ();

      void
      TemperatureStability (const TemperatureStability_type& x);

      void
      TemperatureStability (const TemperatureStability_optional& x);

      void
      TemperatureStability (::std::unique_ptr< TemperatureStability_type > p);

      // HousingMaterial
      //
      typedef ::xml_schema::string HousingMaterial_type;
      typedef ::xsd::cxx::tree::optional< HousingMaterial_type > HousingMaterial_optional;
      typedef ::xsd::cxx::tree::traits< HousingMaterial_type, wchar_t > HousingMaterial_traits;

      const HousingMaterial_optional&
      HousingMaterial () const;

      HousingMaterial_optional&
      HousingMaterial ();

      void
      HousingMaterial (const HousingMaterial_type& x);

      void
      HousingMaterial (const HousingMaterial_optional& x);

      void
      HousingMaterial (::std::unique_ptr< HousingMaterial_type > p);

      // Constructors.
      //
      DifferentialVariableReluctanceTransducerSensorType ();

      DifferentialVariableReluctanceTransducerSensorType (const Name_type&,
                                                          const id_type&);

      DifferentialVariableReluctanceTransducerSensorType (const xercesc::DOMElement& e,
                                                          ::xml_schema::flags f = 0,
                                                          ::xml_schema::container* c = 0);

      DifferentialVariableReluctanceTransducerSensorType (const DifferentialVariableReluctanceTransducerSensorType& x,
                                                          ::xml_schema::flags f = 0,
                                                          ::xml_schema::container* c = 0);

      virtual DifferentialVariableReluctanceTransducerSensorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DifferentialVariableReluctanceTransducerSensorType&
      operator= (const DifferentialVariableReluctanceTransducerSensorType& x);

      virtual 
      ~DifferentialVariableReluctanceTransducerSensorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MinMeasuringDistance_optional MinMeasuringDistance_;
      MaxMeasuringDistance_optional MaxMeasuringDistance_;
      Hysteresis_optional Hysteresis_;
      FrequencyResponse_optional FrequencyResponse_;
      TemperatureStability_optional TemperatureStability_;
      HousingMaterial_optional HousingMaterial_;
    };

    class QIF30_SYMBOL_DECL LaserTriangulationSensorType: public ::xsd::qif30::SensorType
    {
      public:
      // AverageSpotDiameter
      //
      typedef ::xsd::qif30::LinearValueType AverageSpotDiameter_type;
      typedef ::xsd::cxx::tree::optional< AverageSpotDiameter_type > AverageSpotDiameter_optional;
      typedef ::xsd::cxx::tree::traits< AverageSpotDiameter_type, wchar_t > AverageSpotDiameter_traits;

      const AverageSpotDiameter_optional&
      AverageSpotDiameter () const;

      AverageSpotDiameter_optional&
      AverageSpotDiameter ();

      void
      AverageSpotDiameter (const AverageSpotDiameter_type& x);

      void
      AverageSpotDiameter (const AverageSpotDiameter_optional& x);

      void
      AverageSpotDiameter (::std::unique_ptr< AverageSpotDiameter_type > p);

      // LaserSafetyClass
      //
      typedef ::xml_schema::string LaserSafetyClass_type;
      typedef ::xsd::cxx::tree::optional< LaserSafetyClass_type > LaserSafetyClass_optional;
      typedef ::xsd::cxx::tree::traits< LaserSafetyClass_type, wchar_t > LaserSafetyClass_traits;

      const LaserSafetyClass_optional&
      LaserSafetyClass () const;

      LaserSafetyClass_optional&
      LaserSafetyClass ();

      void
      LaserSafetyClass (const LaserSafetyClass_type& x);

      void
      LaserSafetyClass (const LaserSafetyClass_optional& x);

      void
      LaserSafetyClass (::std::unique_ptr< LaserSafetyClass_type > p);

      // MaxMeasurementFrequency
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType MaxMeasurementFrequency_type;
      typedef ::xsd::cxx::tree::optional< MaxMeasurementFrequency_type > MaxMeasurementFrequency_optional;
      typedef ::xsd::cxx::tree::traits< MaxMeasurementFrequency_type, wchar_t > MaxMeasurementFrequency_traits;

      const MaxMeasurementFrequency_optional&
      MaxMeasurementFrequency () const;

      MaxMeasurementFrequency_optional&
      MaxMeasurementFrequency ();

      void
      MaxMeasurementFrequency (const MaxMeasurementFrequency_type& x);

      void
      MaxMeasurementFrequency (const MaxMeasurementFrequency_optional& x);

      void
      MaxMeasurementFrequency (::std::unique_ptr< MaxMeasurementFrequency_type > p);

      // MinMeasuringDistance
      //
      typedef ::xsd::qif30::LinearValueType MinMeasuringDistance_type;
      typedef ::xsd::cxx::tree::optional< MinMeasuringDistance_type > MinMeasuringDistance_optional;
      typedef ::xsd::cxx::tree::traits< MinMeasuringDistance_type, wchar_t > MinMeasuringDistance_traits;

      const MinMeasuringDistance_optional&
      MinMeasuringDistance () const;

      MinMeasuringDistance_optional&
      MinMeasuringDistance ();

      void
      MinMeasuringDistance (const MinMeasuringDistance_type& x);

      void
      MinMeasuringDistance (const MinMeasuringDistance_optional& x);

      void
      MinMeasuringDistance (::std::unique_ptr< MinMeasuringDistance_type > p);

      // MaxMeasuringDistance
      //
      typedef ::xsd::qif30::LinearValueType MaxMeasuringDistance_type;
      typedef ::xsd::cxx::tree::optional< MaxMeasuringDistance_type > MaxMeasuringDistance_optional;
      typedef ::xsd::cxx::tree::traits< MaxMeasuringDistance_type, wchar_t > MaxMeasuringDistance_traits;

      const MaxMeasuringDistance_optional&
      MaxMeasuringDistance () const;

      MaxMeasuringDistance_optional&
      MaxMeasuringDistance ();

      void
      MaxMeasuringDistance (const MaxMeasuringDistance_type& x);

      void
      MaxMeasuringDistance (const MaxMeasuringDistance_optional& x);

      void
      MaxMeasuringDistance (::std::unique_ptr< MaxMeasuringDistance_type > p);

      // HousingMaterial
      //
      typedef ::xml_schema::string HousingMaterial_type;
      typedef ::xsd::cxx::tree::optional< HousingMaterial_type > HousingMaterial_optional;
      typedef ::xsd::cxx::tree::traits< HousingMaterial_type, wchar_t > HousingMaterial_traits;

      const HousingMaterial_optional&
      HousingMaterial () const;

      HousingMaterial_optional&
      HousingMaterial ();

      void
      HousingMaterial (const HousingMaterial_type& x);

      void
      HousingMaterial (const HousingMaterial_optional& x);

      void
      HousingMaterial (::std::unique_ptr< HousingMaterial_type > p);

      // PermissibleAmbientLight
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType PermissibleAmbientLight_type;
      typedef ::xsd::cxx::tree::optional< PermissibleAmbientLight_type > PermissibleAmbientLight_optional;
      typedef ::xsd::cxx::tree::traits< PermissibleAmbientLight_type, wchar_t > PermissibleAmbientLight_traits;

      const PermissibleAmbientLight_optional&
      PermissibleAmbientLight () const;

      PermissibleAmbientLight_optional&
      PermissibleAmbientLight ();

      void
      PermissibleAmbientLight (const PermissibleAmbientLight_type& x);

      void
      PermissibleAmbientLight (const PermissibleAmbientLight_optional& x);

      void
      PermissibleAmbientLight (::std::unique_ptr< PermissibleAmbientLight_type > p);

      // ShockTolerance
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType ShockTolerance_type;
      typedef ::xsd::cxx::tree::optional< ShockTolerance_type > ShockTolerance_optional;
      typedef ::xsd::cxx::tree::traits< ShockTolerance_type, wchar_t > ShockTolerance_traits;

      const ShockTolerance_optional&
      ShockTolerance () const;

      ShockTolerance_optional&
      ShockTolerance ();

      void
      ShockTolerance (const ShockTolerance_type& x);

      void
      ShockTolerance (const ShockTolerance_optional& x);

      void
      ShockTolerance (::std::unique_ptr< ShockTolerance_type > p);

      // VibrationTolerance
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType VibrationTolerance_type;
      typedef ::xsd::cxx::tree::optional< VibrationTolerance_type > VibrationTolerance_optional;
      typedef ::xsd::cxx::tree::traits< VibrationTolerance_type, wchar_t > VibrationTolerance_traits;

      const VibrationTolerance_optional&
      VibrationTolerance () const;

      VibrationTolerance_optional&
      VibrationTolerance ();

      void
      VibrationTolerance (const VibrationTolerance_type& x);

      void
      VibrationTolerance (const VibrationTolerance_optional& x);

      void
      VibrationTolerance (::std::unique_ptr< VibrationTolerance_type > p);

      // OutputPower
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType OutputPower_type;
      typedef ::xsd::cxx::tree::optional< OutputPower_type > OutputPower_optional;
      typedef ::xsd::cxx::tree::traits< OutputPower_type, wchar_t > OutputPower_traits;

      const OutputPower_optional&
      OutputPower () const;

      OutputPower_optional&
      OutputPower ();

      void
      OutputPower (const OutputPower_type& x);

      void
      OutputPower (const OutputPower_optional& x);

      void
      OutputPower (::std::unique_ptr< OutputPower_type > p);

      // Laser
      //
      typedef ::xsd::qif30::LaserType Laser_type;
      typedef ::xsd::cxx::tree::optional< Laser_type > Laser_optional;
      typedef ::xsd::cxx::tree::traits< Laser_type, wchar_t > Laser_traits;

      const Laser_optional&
      Laser () const;

      Laser_optional&
      Laser ();

      void
      Laser (const Laser_type& x);

      void
      Laser (const Laser_optional& x);

      void
      Laser (::std::unique_ptr< Laser_type > p);

      // Constructors.
      //
      LaserTriangulationSensorType ();

      LaserTriangulationSensorType (const Name_type&,
                                    const id_type&);

      LaserTriangulationSensorType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      LaserTriangulationSensorType (const LaserTriangulationSensorType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual LaserTriangulationSensorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LaserTriangulationSensorType&
      operator= (const LaserTriangulationSensorType& x);

      virtual 
      ~LaserTriangulationSensorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      AverageSpotDiameter_optional AverageSpotDiameter_;
      LaserSafetyClass_optional LaserSafetyClass_;
      MaxMeasurementFrequency_optional MaxMeasurementFrequency_;
      MinMeasuringDistance_optional MinMeasuringDistance_;
      MaxMeasuringDistance_optional MaxMeasuringDistance_;
      HousingMaterial_optional HousingMaterial_;
      PermissibleAmbientLight_optional PermissibleAmbientLight_;
      ShockTolerance_optional ShockTolerance_;
      VibrationTolerance_optional VibrationTolerance_;
      OutputPower_optional OutputPower_;
      Laser_optional Laser_;
    };

    class QIF30_SYMBOL_DECL StructuredLightSensorType: public ::xsd::qif30::SensorType
    {
      public:
      // OutputFileFormat
      //
      typedef ::xml_schema::string OutputFileFormat_type;
      typedef ::xsd::cxx::tree::optional< OutputFileFormat_type > OutputFileFormat_optional;
      typedef ::xsd::cxx::tree::traits< OutputFileFormat_type, wchar_t > OutputFileFormat_traits;

      const OutputFileFormat_optional&
      OutputFileFormat () const;

      OutputFileFormat_optional&
      OutputFileFormat ();

      void
      OutputFileFormat (const OutputFileFormat_type& x);

      void
      OutputFileFormat (const OutputFileFormat_optional& x);

      void
      OutputFileFormat (::std::unique_ptr< OutputFileFormat_type > p);

      // MeasurementFieldSize
      //
      typedef ::xsd::qif30::LinearValueType MeasurementFieldSize_type;
      typedef ::xsd::cxx::tree::optional< MeasurementFieldSize_type > MeasurementFieldSize_optional;
      typedef ::xsd::cxx::tree::traits< MeasurementFieldSize_type, wchar_t > MeasurementFieldSize_traits;

      const MeasurementFieldSize_optional&
      MeasurementFieldSize () const;

      MeasurementFieldSize_optional&
      MeasurementFieldSize ();

      void
      MeasurementFieldSize (const MeasurementFieldSize_type& x);

      void
      MeasurementFieldSize (const MeasurementFieldSize_optional& x);

      void
      MeasurementFieldSize (::std::unique_ptr< MeasurementFieldSize_type > p);

      // NumberOfCameraPixels
      //
      typedef ::xml_schema::int_ NumberOfCameraPixels_type;
      typedef ::xsd::cxx::tree::optional< NumberOfCameraPixels_type > NumberOfCameraPixels_optional;
      typedef ::xsd::cxx::tree::traits< NumberOfCameraPixels_type, wchar_t > NumberOfCameraPixels_traits;

      const NumberOfCameraPixels_optional&
      NumberOfCameraPixels () const;

      NumberOfCameraPixels_optional&
      NumberOfCameraPixels ();

      void
      NumberOfCameraPixels (const NumberOfCameraPixels_type& x);

      void
      NumberOfCameraPixels (const NumberOfCameraPixels_optional& x);

      // LightSource
      //
      typedef ::xml_schema::string LightSource_type;
      typedef ::xsd::cxx::tree::optional< LightSource_type > LightSource_optional;
      typedef ::xsd::cxx::tree::traits< LightSource_type, wchar_t > LightSource_traits;

      const LightSource_optional&
      LightSource () const;

      LightSource_optional&
      LightSource ();

      void
      LightSource (const LightSource_type& x);

      void
      LightSource (const LightSource_optional& x);

      void
      LightSource (::std::unique_ptr< LightSource_type > p);

      // MeasurementRate
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType MeasurementRate_type;
      typedef ::xsd::cxx::tree::optional< MeasurementRate_type > MeasurementRate_optional;
      typedef ::xsd::cxx::tree::traits< MeasurementRate_type, wchar_t > MeasurementRate_traits;

      const MeasurementRate_optional&
      MeasurementRate () const;

      MeasurementRate_optional&
      MeasurementRate ();

      void
      MeasurementRate (const MeasurementRate_type& x);

      void
      MeasurementRate (const MeasurementRate_optional& x);

      void
      MeasurementRate (::std::unique_ptr< MeasurementRate_type > p);

      // WorkingVolume
      //
      typedef ::xsd::qif30::WorkingVolumeBaseType WorkingVolume_type;
      typedef ::xsd::cxx::tree::optional< WorkingVolume_type > WorkingVolume_optional;
      typedef ::xsd::cxx::tree::traits< WorkingVolume_type, wchar_t > WorkingVolume_traits;

      const WorkingVolume_optional&
      WorkingVolume () const;

      WorkingVolume_optional&
      WorkingVolume ();

      void
      WorkingVolume (const WorkingVolume_type& x);

      void
      WorkingVolume (const WorkingVolume_optional& x);

      void
      WorkingVolume (::std::unique_ptr< WorkingVolume_type > p);

      // StandOffDistance
      //
      typedef ::xsd::qif30::LinearValueType StandOffDistance_type;
      typedef ::xsd::cxx::tree::optional< StandOffDistance_type > StandOffDistance_optional;
      typedef ::xsd::cxx::tree::traits< StandOffDistance_type, wchar_t > StandOffDistance_traits;

      const StandOffDistance_optional&
      StandOffDistance () const;

      StandOffDistance_optional&
      StandOffDistance ();

      void
      StandOffDistance (const StandOffDistance_type& x);

      void
      StandOffDistance (const StandOffDistance_optional& x);

      void
      StandOffDistance (::std::unique_ptr< StandOffDistance_type > p);

      // MaxPermissibleProbingError
      //
      typedef ::xsd::qif30::LinearValueType MaxPermissibleProbingError_type;
      typedef ::xsd::cxx::tree::optional< MaxPermissibleProbingError_type > MaxPermissibleProbingError_optional;
      typedef ::xsd::cxx::tree::traits< MaxPermissibleProbingError_type, wchar_t > MaxPermissibleProbingError_traits;

      const MaxPermissibleProbingError_optional&
      MaxPermissibleProbingError () const;

      MaxPermissibleProbingError_optional&
      MaxPermissibleProbingError ();

      void
      MaxPermissibleProbingError (const MaxPermissibleProbingError_type& x);

      void
      MaxPermissibleProbingError (const MaxPermissibleProbingError_optional& x);

      void
      MaxPermissibleProbingError (::std::unique_ptr< MaxPermissibleProbingError_type > p);

      // Laser
      //
      typedef ::xsd::qif30::LaserType Laser_type;
      typedef ::xsd::cxx::tree::optional< Laser_type > Laser_optional;
      typedef ::xsd::cxx::tree::traits< Laser_type, wchar_t > Laser_traits;

      const Laser_optional&
      Laser () const;

      Laser_optional&
      Laser ();

      void
      Laser (const Laser_type& x);

      void
      Laser (const Laser_optional& x);

      void
      Laser (::std::unique_ptr< Laser_type > p);

      // Constructors.
      //
      StructuredLightSensorType ();

      StructuredLightSensorType (const Name_type&,
                                 const id_type&);

      StructuredLightSensorType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      StructuredLightSensorType (const StructuredLightSensorType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual StructuredLightSensorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StructuredLightSensorType&
      operator= (const StructuredLightSensorType& x);

      virtual 
      ~StructuredLightSensorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      OutputFileFormat_optional OutputFileFormat_;
      MeasurementFieldSize_optional MeasurementFieldSize_;
      NumberOfCameraPixels_optional NumberOfCameraPixels_;
      LightSource_optional LightSource_;
      MeasurementRate_optional MeasurementRate_;
      WorkingVolume_optional WorkingVolume_;
      StandOffDistance_optional StandOffDistance_;
      MaxPermissibleProbingError_optional MaxPermissibleProbingError_;
      Laser_optional Laser_;
    };

    class QIF30_SYMBOL_DECL UltrasonicSensorType: public ::xsd::qif30::SensorType
    {
      public:
      // MinMeasuringDistance
      //
      typedef ::xsd::qif30::LinearValueType MinMeasuringDistance_type;
      typedef ::xsd::cxx::tree::optional< MinMeasuringDistance_type > MinMeasuringDistance_optional;
      typedef ::xsd::cxx::tree::traits< MinMeasuringDistance_type, wchar_t > MinMeasuringDistance_traits;

      const MinMeasuringDistance_optional&
      MinMeasuringDistance () const;

      MinMeasuringDistance_optional&
      MinMeasuringDistance ();

      void
      MinMeasuringDistance (const MinMeasuringDistance_type& x);

      void
      MinMeasuringDistance (const MinMeasuringDistance_optional& x);

      void
      MinMeasuringDistance (::std::unique_ptr< MinMeasuringDistance_type > p);

      // MaxMeasuringDistance
      //
      typedef ::xsd::qif30::LinearValueType MaxMeasuringDistance_type;
      typedef ::xsd::cxx::tree::optional< MaxMeasuringDistance_type > MaxMeasuringDistance_optional;
      typedef ::xsd::cxx::tree::traits< MaxMeasuringDistance_type, wchar_t > MaxMeasuringDistance_traits;

      const MaxMeasuringDistance_optional&
      MaxMeasuringDistance () const;

      MaxMeasuringDistance_optional&
      MaxMeasuringDistance ();

      void
      MaxMeasuringDistance (const MaxMeasuringDistance_type& x);

      void
      MaxMeasuringDistance (const MaxMeasuringDistance_optional& x);

      void
      MaxMeasuringDistance (::std::unique_ptr< MaxMeasuringDistance_type > p);

      // SamplingFrequency
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType SamplingFrequency_type;
      typedef ::xsd::cxx::tree::optional< SamplingFrequency_type > SamplingFrequency_optional;
      typedef ::xsd::cxx::tree::traits< SamplingFrequency_type, wchar_t > SamplingFrequency_traits;

      const SamplingFrequency_optional&
      SamplingFrequency () const;

      SamplingFrequency_optional&
      SamplingFrequency ();

      void
      SamplingFrequency (const SamplingFrequency_type& x);

      void
      SamplingFrequency (const SamplingFrequency_optional& x);

      void
      SamplingFrequency (::std::unique_ptr< SamplingFrequency_type > p);

      // AppliedFrequency
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType AppliedFrequency_type;
      typedef ::xsd::cxx::tree::optional< AppliedFrequency_type > AppliedFrequency_optional;
      typedef ::xsd::cxx::tree::traits< AppliedFrequency_type, wchar_t > AppliedFrequency_traits;

      const AppliedFrequency_optional&
      AppliedFrequency () const;

      AppliedFrequency_optional&
      AppliedFrequency ();

      void
      AppliedFrequency (const AppliedFrequency_type& x);

      void
      AppliedFrequency (const AppliedFrequency_optional& x);

      void
      AppliedFrequency (::std::unique_ptr< AppliedFrequency_type > p);

      // MaxResponseTime
      //
      typedef ::xsd::qif30::TimeValueType MaxResponseTime_type;
      typedef ::xsd::cxx::tree::optional< MaxResponseTime_type > MaxResponseTime_optional;
      typedef ::xsd::cxx::tree::traits< MaxResponseTime_type, wchar_t > MaxResponseTime_traits;

      const MaxResponseTime_optional&
      MaxResponseTime () const;

      MaxResponseTime_optional&
      MaxResponseTime ();

      void
      MaxResponseTime (const MaxResponseTime_type& x);

      void
      MaxResponseTime (const MaxResponseTime_optional& x);

      void
      MaxResponseTime (::std::unique_ptr< MaxResponseTime_type > p);

      // ShockTolerance
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType ShockTolerance_type;
      typedef ::xsd::cxx::tree::optional< ShockTolerance_type > ShockTolerance_optional;
      typedef ::xsd::cxx::tree::traits< ShockTolerance_type, wchar_t > ShockTolerance_traits;

      const ShockTolerance_optional&
      ShockTolerance () const;

      ShockTolerance_optional&
      ShockTolerance ();

      void
      ShockTolerance (const ShockTolerance_type& x);

      void
      ShockTolerance (const ShockTolerance_optional& x);

      void
      ShockTolerance (::std::unique_ptr< ShockTolerance_type > p);

      // VibrationTolerance
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType VibrationTolerance_type;
      typedef ::xsd::cxx::tree::optional< VibrationTolerance_type > VibrationTolerance_optional;
      typedef ::xsd::cxx::tree::traits< VibrationTolerance_type, wchar_t > VibrationTolerance_traits;

      const VibrationTolerance_optional&
      VibrationTolerance () const;

      VibrationTolerance_optional&
      VibrationTolerance ();

      void
      VibrationTolerance (const VibrationTolerance_type& x);

      void
      VibrationTolerance (const VibrationTolerance_optional& x);

      void
      VibrationTolerance (::std::unique_ptr< VibrationTolerance_type > p);

      // MinPowerSupplyVoltage
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType MinPowerSupplyVoltage_type;
      typedef ::xsd::cxx::tree::optional< MinPowerSupplyVoltage_type > MinPowerSupplyVoltage_optional;
      typedef ::xsd::cxx::tree::traits< MinPowerSupplyVoltage_type, wchar_t > MinPowerSupplyVoltage_traits;

      const MinPowerSupplyVoltage_optional&
      MinPowerSupplyVoltage () const;

      MinPowerSupplyVoltage_optional&
      MinPowerSupplyVoltage ();

      void
      MinPowerSupplyVoltage (const MinPowerSupplyVoltage_type& x);

      void
      MinPowerSupplyVoltage (const MinPowerSupplyVoltage_optional& x);

      void
      MinPowerSupplyVoltage (::std::unique_ptr< MinPowerSupplyVoltage_type > p);

      // MaxPowerSupplyVoltage
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType MaxPowerSupplyVoltage_type;
      typedef ::xsd::cxx::tree::optional< MaxPowerSupplyVoltage_type > MaxPowerSupplyVoltage_optional;
      typedef ::xsd::cxx::tree::traits< MaxPowerSupplyVoltage_type, wchar_t > MaxPowerSupplyVoltage_traits;

      const MaxPowerSupplyVoltage_optional&
      MaxPowerSupplyVoltage () const;

      MaxPowerSupplyVoltage_optional&
      MaxPowerSupplyVoltage ();

      void
      MaxPowerSupplyVoltage (const MaxPowerSupplyVoltage_type& x);

      void
      MaxPowerSupplyVoltage (const MaxPowerSupplyVoltage_optional& x);

      void
      MaxPowerSupplyVoltage (::std::unique_ptr< MaxPowerSupplyVoltage_type > p);

      // Constructors.
      //
      UltrasonicSensorType ();

      UltrasonicSensorType (const Name_type&,
                            const id_type&);

      UltrasonicSensorType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      UltrasonicSensorType (const UltrasonicSensorType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual UltrasonicSensorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UltrasonicSensorType&
      operator= (const UltrasonicSensorType& x);

      virtual 
      ~UltrasonicSensorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MinMeasuringDistance_optional MinMeasuringDistance_;
      MaxMeasuringDistance_optional MaxMeasuringDistance_;
      SamplingFrequency_optional SamplingFrequency_;
      AppliedFrequency_optional AppliedFrequency_;
      MaxResponseTime_optional MaxResponseTime_;
      ShockTolerance_optional ShockTolerance_;
      VibrationTolerance_optional VibrationTolerance_;
      MinPowerSupplyVoltage_optional MinPowerSupplyVoltage_;
      MaxPowerSupplyVoltage_optional MaxPowerSupplyVoltage_;
    };

    class QIF30_SYMBOL_DECL TipEndGeometryEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        SPHERE,
        CYLINDER,
        CYLINDER_WITH_SPHERE,
        HEMISPHERE,
        SPHERICAL_DISC,
        POINT
      };

      TipEndGeometryEnumType ();

      TipEndGeometryEnumType (value v);

      TipEndGeometryEnumType (const wchar_t* v);

      TipEndGeometryEnumType (const ::std::wstring& v);

      TipEndGeometryEnumType (const ::xml_schema::nmtoken& v);

      TipEndGeometryEnumType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      TipEndGeometryEnumType (const xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      TipEndGeometryEnumType (const ::std::wstring& s,
                              const xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      TipEndGeometryEnumType (const TipEndGeometryEnumType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      TipEndGeometryEnumType&
      operator= (const TipEndGeometryEnumType&) = default;
#endif

      virtual TipEndGeometryEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TipEndGeometryEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_TipEndGeometryEnumType_convert ();
      }

      protected:
      value
      _xsd_TipEndGeometryEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_TipEndGeometryEnumType_literals_[6];
      static const value _xsd_TipEndGeometryEnumType_indexes_[6];
    };

    class QIF30_SYMBOL_DECL TipEndGeometryType: public ::xml_schema::type
    {
      public:
      // TipEndGeometryEnum
      //
      typedef ::xsd::qif30::TipEndGeometryEnumType TipEndGeometryEnum_type;
      typedef ::xsd::cxx::tree::optional< TipEndGeometryEnum_type > TipEndGeometryEnum_optional;
      typedef ::xsd::cxx::tree::traits< TipEndGeometryEnum_type, wchar_t > TipEndGeometryEnum_traits;

      const TipEndGeometryEnum_optional&
      TipEndGeometryEnum () const;

      TipEndGeometryEnum_optional&
      TipEndGeometryEnum ();

      void
      TipEndGeometryEnum (const TipEndGeometryEnum_type& x);

      void
      TipEndGeometryEnum (const TipEndGeometryEnum_optional& x);

      void
      TipEndGeometryEnum (::std::unique_ptr< TipEndGeometryEnum_type > p);

      // OtherTipEndGeometry
      //
      typedef ::xml_schema::string OtherTipEndGeometry_type;
      typedef ::xsd::cxx::tree::optional< OtherTipEndGeometry_type > OtherTipEndGeometry_optional;
      typedef ::xsd::cxx::tree::traits< OtherTipEndGeometry_type, wchar_t > OtherTipEndGeometry_traits;

      const OtherTipEndGeometry_optional&
      OtherTipEndGeometry () const;

      OtherTipEndGeometry_optional&
      OtherTipEndGeometry ();

      void
      OtherTipEndGeometry (const OtherTipEndGeometry_type& x);

      void
      OtherTipEndGeometry (const OtherTipEndGeometry_optional& x);

      void
      OtherTipEndGeometry (::std::unique_ptr< OtherTipEndGeometry_type > p);

      // Constructors.
      //
      TipEndGeometryType ();

      TipEndGeometryType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      TipEndGeometryType (const TipEndGeometryType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual TipEndGeometryType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TipEndGeometryType&
      operator= (const TipEndGeometryType& x);

      virtual 
      ~TipEndGeometryType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      TipEndGeometryEnum_optional TipEndGeometryEnum_;
      OtherTipEndGeometry_optional OtherTipEndGeometry_;
    };

    class QIF30_SYMBOL_DECL TactileProbeSensorBaseType: public ::xsd::qif30::DetachableSensorBaseType
    {
      public:
      // Constructors.
      //
      TactileProbeSensorBaseType ();

      TactileProbeSensorBaseType (const Name_type&,
                                  const id_type&);

      TactileProbeSensorBaseType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      TactileProbeSensorBaseType (const TactileProbeSensorBaseType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual TactileProbeSensorBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      TactileProbeSensorBaseType&
      operator= (const TactileProbeSensorBaseType&) = default;
#endif

      virtual 
      ~TactileProbeSensorBaseType ();
    };

    class QIF30_SYMBOL_DECL SimpleTactileProbeSensorType: public ::xsd::qif30::TactileProbeSensorBaseType
    {
      public:
      // Qualifications
      //
      typedef ::xsd::qif30::QualificationsType Qualifications_type;
      typedef ::xsd::cxx::tree::optional< Qualifications_type > Qualifications_optional;
      typedef ::xsd::cxx::tree::traits< Qualifications_type, wchar_t > Qualifications_traits;

      const Qualifications_optional&
      Qualifications () const;

      Qualifications_optional&
      Qualifications ();

      void
      Qualifications (const Qualifications_type& x);

      void
      Qualifications (const Qualifications_optional& x);

      void
      Qualifications (::std::unique_ptr< Qualifications_type > p);

      // Length
      //
      typedef ::xsd::qif30::LinearValueType Length_type;
      typedef ::xsd::cxx::tree::optional< Length_type > Length_optional;
      typedef ::xsd::cxx::tree::traits< Length_type, wchar_t > Length_traits;

      const Length_optional&
      Length () const;

      Length_optional&
      Length ();

      void
      Length (const Length_type& x);

      void
      Length (const Length_optional& x);

      void
      Length (::std::unique_ptr< Length_type > p);

      // TipEndGeometry
      //
      typedef ::xsd::qif30::TipEndGeometryType TipEndGeometry_type;
      typedef ::xsd::cxx::tree::optional< TipEndGeometry_type > TipEndGeometry_optional;
      typedef ::xsd::cxx::tree::traits< TipEndGeometry_type, wchar_t > TipEndGeometry_traits;

      const TipEndGeometry_optional&
      TipEndGeometry () const;

      TipEndGeometry_optional&
      TipEndGeometry ();

      void
      TipEndGeometry (const TipEndGeometry_type& x);

      void
      TipEndGeometry (const TipEndGeometry_optional& x);

      void
      TipEndGeometry (::std::unique_ptr< TipEndGeometry_type > p);

      // TipEndDiameter
      //
      typedef ::xsd::qif30::LinearValueType TipEndDiameter_type;
      typedef ::xsd::cxx::tree::optional< TipEndDiameter_type > TipEndDiameter_optional;
      typedef ::xsd::cxx::tree::traits< TipEndDiameter_type, wchar_t > TipEndDiameter_traits;

      const TipEndDiameter_optional&
      TipEndDiameter () const;

      TipEndDiameter_optional&
      TipEndDiameter ();

      void
      TipEndDiameter (const TipEndDiameter_type& x);

      void
      TipEndDiameter (const TipEndDiameter_optional& x);

      void
      TipEndDiameter (::std::unique_ptr< TipEndDiameter_type > p);

      // TipEndMaterial
      //
      typedef ::xml_schema::string TipEndMaterial_type;
      typedef ::xsd::cxx::tree::optional< TipEndMaterial_type > TipEndMaterial_optional;
      typedef ::xsd::cxx::tree::traits< TipEndMaterial_type, wchar_t > TipEndMaterial_traits;

      const TipEndMaterial_optional&
      TipEndMaterial () const;

      TipEndMaterial_optional&
      TipEndMaterial ();

      void
      TipEndMaterial (const TipEndMaterial_type& x);

      void
      TipEndMaterial (const TipEndMaterial_optional& x);

      void
      TipEndMaterial (::std::unique_ptr< TipEndMaterial_type > p);

      // StemMaterial
      //
      typedef ::xml_schema::string StemMaterial_type;
      typedef ::xsd::cxx::tree::optional< StemMaterial_type > StemMaterial_optional;
      typedef ::xsd::cxx::tree::traits< StemMaterial_type, wchar_t > StemMaterial_traits;

      const StemMaterial_optional&
      StemMaterial () const;

      StemMaterial_optional&
      StemMaterial ();

      void
      StemMaterial (const StemMaterial_type& x);

      void
      StemMaterial (const StemMaterial_optional& x);

      void
      StemMaterial (::std::unique_ptr< StemMaterial_type > p);

      // StemDiameter
      //
      typedef ::xsd::qif30::LinearValueType StemDiameter_type;
      typedef ::xsd::cxx::tree::optional< StemDiameter_type > StemDiameter_optional;
      typedef ::xsd::cxx::tree::traits< StemDiameter_type, wchar_t > StemDiameter_traits;

      const StemDiameter_optional&
      StemDiameter () const;

      StemDiameter_optional&
      StemDiameter ();

      void
      StemDiameter (const StemDiameter_type& x);

      void
      StemDiameter (const StemDiameter_optional& x);

      void
      StemDiameter (::std::unique_ptr< StemDiameter_type > p);

      // Constructors.
      //
      SimpleTactileProbeSensorType ();

      SimpleTactileProbeSensorType (const Name_type&,
                                    const id_type&);

      SimpleTactileProbeSensorType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      SimpleTactileProbeSensorType (const SimpleTactileProbeSensorType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual SimpleTactileProbeSensorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SimpleTactileProbeSensorType&
      operator= (const SimpleTactileProbeSensorType& x);

      virtual 
      ~SimpleTactileProbeSensorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Qualifications_optional Qualifications_;
      Length_optional Length_;
      TipEndGeometry_optional TipEndGeometry_;
      TipEndDiameter_optional TipEndDiameter_;
      TipEndMaterial_optional TipEndMaterial_;
      StemMaterial_optional StemMaterial_;
      StemDiameter_optional StemDiameter_;
    };

    class QIF30_SYMBOL_DECL ComplexTactileProbeSensorType: public ::xsd::qif30::TactileProbeSensorBaseType
    {
      public:
      // LocatedTips
      //
      typedef ::xsd::qif30::LocatedTipsType LocatedTips_type;
      typedef ::xsd::cxx::tree::traits< LocatedTips_type, wchar_t > LocatedTips_traits;

      const LocatedTips_type&
      LocatedTips () const;

      LocatedTips_type&
      LocatedTips ();

      void
      LocatedTips (const LocatedTips_type& x);

      void
      LocatedTips (::std::unique_ptr< LocatedTips_type > p);

      // Constructors.
      //
      ComplexTactileProbeSensorType ();

      ComplexTactileProbeSensorType (const Name_type&,
                                     const id_type&,
                                     const LocatedTips_type&);

      ComplexTactileProbeSensorType (const Name_type&,
                                     const id_type&,
                                     ::std::unique_ptr< LocatedTips_type >);

      ComplexTactileProbeSensorType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      ComplexTactileProbeSensorType (const ComplexTactileProbeSensorType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual ComplexTactileProbeSensorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ComplexTactileProbeSensorType&
      operator= (const ComplexTactileProbeSensorType& x);

      virtual 
      ~ComplexTactileProbeSensorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< LocatedTips_type > LocatedTips_;
    };

    class QIF30_SYMBOL_DECL LocatedTipsType: public ::xml_schema::type
    {
      public:
      // LocatedTip
      //
      typedef ::xsd::qif30::LocatedTipType LocatedTip_type;
      typedef ::xsd::cxx::tree::sequence< LocatedTip_type > LocatedTip_sequence;
      typedef xsd::cxx::tree::sequence< LocatedTip_type >::iterator LocatedTip_iterator;
      typedef xsd::cxx::tree::sequence< LocatedTip_type >::const_iterator LocatedTip_const_iterator;
      typedef ::xsd::cxx::tree::traits< LocatedTip_type, wchar_t > LocatedTip_traits;

      const LocatedTip_sequence&
      LocatedTip () const;

      LocatedTip_sequence&
      LocatedTip ();

      void
      LocatedTip (const LocatedTip_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      LocatedTipsType ();

      LocatedTipsType (const n_type&);

      LocatedTipsType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      LocatedTipsType (const LocatedTipsType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual LocatedTipsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LocatedTipsType&
      operator= (const LocatedTipsType& x);

      virtual 
      ~LocatedTipsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      LocatedTip_sequence LocatedTip_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ProbeTipType: public ::xsd::qif30::MeasurementResourceBaseType
    {
      public:
      // TipEndGeometry
      //
      typedef ::xsd::qif30::TipEndGeometryType TipEndGeometry_type;
      typedef ::xsd::cxx::tree::optional< TipEndGeometry_type > TipEndGeometry_optional;
      typedef ::xsd::cxx::tree::traits< TipEndGeometry_type, wchar_t > TipEndGeometry_traits;

      const TipEndGeometry_optional&
      TipEndGeometry () const;

      TipEndGeometry_optional&
      TipEndGeometry ();

      void
      TipEndGeometry (const TipEndGeometry_type& x);

      void
      TipEndGeometry (const TipEndGeometry_optional& x);

      void
      TipEndGeometry (::std::unique_ptr< TipEndGeometry_type > p);

      // TipEndDiameter
      //
      typedef ::xsd::qif30::LinearValueType TipEndDiameter_type;
      typedef ::xsd::cxx::tree::optional< TipEndDiameter_type > TipEndDiameter_optional;
      typedef ::xsd::cxx::tree::traits< TipEndDiameter_type, wchar_t > TipEndDiameter_traits;

      const TipEndDiameter_optional&
      TipEndDiameter () const;

      TipEndDiameter_optional&
      TipEndDiameter ();

      void
      TipEndDiameter (const TipEndDiameter_type& x);

      void
      TipEndDiameter (const TipEndDiameter_optional& x);

      void
      TipEndDiameter (::std::unique_ptr< TipEndDiameter_type > p);

      // TipEndMaterial
      //
      typedef ::xml_schema::string TipEndMaterial_type;
      typedef ::xsd::cxx::tree::optional< TipEndMaterial_type > TipEndMaterial_optional;
      typedef ::xsd::cxx::tree::traits< TipEndMaterial_type, wchar_t > TipEndMaterial_traits;

      const TipEndMaterial_optional&
      TipEndMaterial () const;

      TipEndMaterial_optional&
      TipEndMaterial ();

      void
      TipEndMaterial (const TipEndMaterial_type& x);

      void
      TipEndMaterial (const TipEndMaterial_optional& x);

      void
      TipEndMaterial (::std::unique_ptr< TipEndMaterial_type > p);

      // StemMaterial
      //
      typedef ::xml_schema::string StemMaterial_type;
      typedef ::xsd::cxx::tree::optional< StemMaterial_type > StemMaterial_optional;
      typedef ::xsd::cxx::tree::traits< StemMaterial_type, wchar_t > StemMaterial_traits;

      const StemMaterial_optional&
      StemMaterial () const;

      StemMaterial_optional&
      StemMaterial ();

      void
      StemMaterial (const StemMaterial_type& x);

      void
      StemMaterial (const StemMaterial_optional& x);

      void
      StemMaterial (::std::unique_ptr< StemMaterial_type > p);

      // StemDiameter
      //
      typedef ::xsd::qif30::LinearValueType StemDiameter_type;
      typedef ::xsd::cxx::tree::optional< StemDiameter_type > StemDiameter_optional;
      typedef ::xsd::cxx::tree::traits< StemDiameter_type, wchar_t > StemDiameter_traits;

      const StemDiameter_optional&
      StemDiameter () const;

      StemDiameter_optional&
      StemDiameter ();

      void
      StemDiameter (const StemDiameter_type& x);

      void
      StemDiameter (const StemDiameter_optional& x);

      void
      StemDiameter (::std::unique_ptr< StemDiameter_type > p);

      // Constructors.
      //
      ProbeTipType ();

      ProbeTipType (const Name_type&,
                    const id_type&);

      ProbeTipType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      ProbeTipType (const ProbeTipType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual ProbeTipType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ProbeTipType&
      operator= (const ProbeTipType& x);

      virtual 
      ~ProbeTipType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      TipEndGeometry_optional TipEndGeometry_;
      TipEndDiameter_optional TipEndDiameter_;
      TipEndMaterial_optional TipEndMaterial_;
      StemMaterial_optional StemMaterial_;
      StemDiameter_optional StemDiameter_;
    };

    class QIF30_SYMBOL_DECL LocatedTipType: public ::xml_schema::type
    {
      public:
      // ProbeTip
      //
      typedef ::xsd::qif30::ProbeTipType ProbeTip_type;
      typedef ::xsd::cxx::tree::traits< ProbeTip_type, wchar_t > ProbeTip_traits;

      const ProbeTip_type&
      ProbeTip () const;

      ProbeTip_type&
      ProbeTip ();

      void
      ProbeTip (const ProbeTip_type& x);

      void
      ProbeTip (::std::unique_ptr< ProbeTip_type > p);

      // TipEndLocation
      //
      typedef ::xsd::qif30::PointType TipEndLocation_type;
      typedef ::xsd::cxx::tree::traits< TipEndLocation_type, wchar_t > TipEndLocation_traits;

      const TipEndLocation_type&
      TipEndLocation () const;

      TipEndLocation_type&
      TipEndLocation ();

      void
      TipEndLocation (const TipEndLocation_type& x);

      void
      TipEndLocation (::std::unique_ptr< TipEndLocation_type > p);

      // Constructors.
      //
      LocatedTipType ();

      LocatedTipType (const ProbeTip_type&,
                      const TipEndLocation_type&);

      LocatedTipType (::std::unique_ptr< ProbeTip_type >,
                      ::std::unique_ptr< TipEndLocation_type >);

      LocatedTipType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      LocatedTipType (const LocatedTipType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual LocatedTipType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LocatedTipType&
      operator= (const LocatedTipType& x);

      virtual 
      ~LocatedTipType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ProbeTip_type > ProbeTip_;
      ::xsd::cxx::tree::one< TipEndLocation_type > TipEndLocation_;
    };

    class QIF30_SYMBOL_DECL ChargeCoupledDeviceCameraSensorType: public ::xsd::qif30::SensorType
    {
      public:
      // NumberOfPixels
      //
      typedef ::xml_schema::int_ NumberOfPixels_type;
      typedef ::xsd::cxx::tree::optional< NumberOfPixels_type > NumberOfPixels_optional;
      typedef ::xsd::cxx::tree::traits< NumberOfPixels_type, wchar_t > NumberOfPixels_traits;

      const NumberOfPixels_optional&
      NumberOfPixels () const;

      NumberOfPixels_optional&
      NumberOfPixels ();

      void
      NumberOfPixels (const NumberOfPixels_type& x);

      void
      NumberOfPixels (const NumberOfPixels_optional& x);

      // MaxReadoutFrequency
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType MaxReadoutFrequency_type;
      typedef ::xsd::cxx::tree::optional< MaxReadoutFrequency_type > MaxReadoutFrequency_optional;
      typedef ::xsd::cxx::tree::traits< MaxReadoutFrequency_type, wchar_t > MaxReadoutFrequency_traits;

      const MaxReadoutFrequency_optional&
      MaxReadoutFrequency () const;

      MaxReadoutFrequency_optional&
      MaxReadoutFrequency ();

      void
      MaxReadoutFrequency (const MaxReadoutFrequency_type& x);

      void
      MaxReadoutFrequency (const MaxReadoutFrequency_optional& x);

      void
      MaxReadoutFrequency (::std::unique_ptr< MaxReadoutFrequency_type > p);

      // HorizontalFieldOfView
      //
      typedef ::xsd::qif30::LinearValueType HorizontalFieldOfView_type;
      typedef ::xsd::cxx::tree::optional< HorizontalFieldOfView_type > HorizontalFieldOfView_optional;
      typedef ::xsd::cxx::tree::traits< HorizontalFieldOfView_type, wchar_t > HorizontalFieldOfView_traits;

      const HorizontalFieldOfView_optional&
      HorizontalFieldOfView () const;

      HorizontalFieldOfView_optional&
      HorizontalFieldOfView ();

      void
      HorizontalFieldOfView (const HorizontalFieldOfView_type& x);

      void
      HorizontalFieldOfView (const HorizontalFieldOfView_optional& x);

      void
      HorizontalFieldOfView (::std::unique_ptr< HorizontalFieldOfView_type > p);

      // VerticalFieldOfView
      //
      typedef ::xsd::qif30::LinearValueType VerticalFieldOfView_type;
      typedef ::xsd::cxx::tree::optional< VerticalFieldOfView_type > VerticalFieldOfView_optional;
      typedef ::xsd::cxx::tree::traits< VerticalFieldOfView_type, wchar_t > VerticalFieldOfView_traits;

      const VerticalFieldOfView_optional&
      VerticalFieldOfView () const;

      VerticalFieldOfView_optional&
      VerticalFieldOfView ();

      void
      VerticalFieldOfView (const VerticalFieldOfView_type& x);

      void
      VerticalFieldOfView (const VerticalFieldOfView_optional& x);

      void
      VerticalFieldOfView (::std::unique_ptr< VerticalFieldOfView_type > p);

      // MaxReadNoise
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType MaxReadNoise_type;
      typedef ::xsd::cxx::tree::optional< MaxReadNoise_type > MaxReadNoise_optional;
      typedef ::xsd::cxx::tree::traits< MaxReadNoise_type, wchar_t > MaxReadNoise_traits;

      const MaxReadNoise_optional&
      MaxReadNoise () const;

      MaxReadNoise_optional&
      MaxReadNoise ();

      void
      MaxReadNoise (const MaxReadNoise_type& x);

      void
      MaxReadNoise (const MaxReadNoise_optional& x);

      void
      MaxReadNoise (::std::unique_ptr< MaxReadNoise_type > p);

      // MaxFrameRate
      //
      typedef ::xsd::qif30::PositiveDecimalType MaxFrameRate_type;
      typedef ::xsd::cxx::tree::optional< MaxFrameRate_type > MaxFrameRate_optional;
      typedef ::xsd::cxx::tree::traits< MaxFrameRate_type, wchar_t > MaxFrameRate_traits;

      const MaxFrameRate_optional&
      MaxFrameRate () const;

      MaxFrameRate_optional&
      MaxFrameRate ();

      void
      MaxFrameRate (const MaxFrameRate_type& x);

      void
      MaxFrameRate (const MaxFrameRate_optional& x);

      void
      MaxFrameRate (::std::unique_ptr< MaxFrameRate_type > p);

      // PixelSize
      //
      typedef ::xsd::qif30::LinearValueType PixelSize_type;
      typedef ::xsd::cxx::tree::optional< PixelSize_type > PixelSize_optional;
      typedef ::xsd::cxx::tree::traits< PixelSize_type, wchar_t > PixelSize_traits;

      const PixelSize_optional&
      PixelSize () const;

      PixelSize_optional&
      PixelSize ();

      void
      PixelSize (const PixelSize_type& x);

      void
      PixelSize (const PixelSize_optional& x);

      void
      PixelSize (::std::unique_ptr< PixelSize_type > p);

      // SustainedDataRate
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType SustainedDataRate_type;
      typedef ::xsd::cxx::tree::optional< SustainedDataRate_type > SustainedDataRate_optional;
      typedef ::xsd::cxx::tree::traits< SustainedDataRate_type, wchar_t > SustainedDataRate_traits;

      const SustainedDataRate_optional&
      SustainedDataRate () const;

      SustainedDataRate_optional&
      SustainedDataRate ();

      void
      SustainedDataRate (const SustainedDataRate_type& x);

      void
      SustainedDataRate (const SustainedDataRate_optional& x);

      void
      SustainedDataRate (::std::unique_ptr< SustainedDataRate_type > p);

      // DarkCurrent
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType DarkCurrent_type;
      typedef ::xsd::cxx::tree::optional< DarkCurrent_type > DarkCurrent_optional;
      typedef ::xsd::cxx::tree::traits< DarkCurrent_type, wchar_t > DarkCurrent_traits;

      const DarkCurrent_optional&
      DarkCurrent () const;

      DarkCurrent_optional&
      DarkCurrent ();

      void
      DarkCurrent (const DarkCurrent_type& x);

      void
      DarkCurrent (const DarkCurrent_optional& x);

      void
      DarkCurrent (::std::unique_ptr< DarkCurrent_type > p);

      // MaxPixelClockSpeed
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType MaxPixelClockSpeed_type;
      typedef ::xsd::cxx::tree::optional< MaxPixelClockSpeed_type > MaxPixelClockSpeed_optional;
      typedef ::xsd::cxx::tree::traits< MaxPixelClockSpeed_type, wchar_t > MaxPixelClockSpeed_traits;

      const MaxPixelClockSpeed_optional&
      MaxPixelClockSpeed () const;

      MaxPixelClockSpeed_optional&
      MaxPixelClockSpeed ();

      void
      MaxPixelClockSpeed (const MaxPixelClockSpeed_type& x);

      void
      MaxPixelClockSpeed (const MaxPixelClockSpeed_optional& x);

      void
      MaxPixelClockSpeed (::std::unique_ptr< MaxPixelClockSpeed_type > p);

      // Linearity
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType Linearity_type;
      typedef ::xsd::cxx::tree::optional< Linearity_type > Linearity_optional;
      typedef ::xsd::cxx::tree::traits< Linearity_type, wchar_t > Linearity_traits;

      const Linearity_optional&
      Linearity () const;

      Linearity_optional&
      Linearity ();

      void
      Linearity (const Linearity_type& x);

      void
      Linearity (const Linearity_optional& x);

      void
      Linearity (::std::unique_ptr< Linearity_type > p);

      // MaxOutputVoltage
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType MaxOutputVoltage_type;
      typedef ::xsd::cxx::tree::optional< MaxOutputVoltage_type > MaxOutputVoltage_optional;
      typedef ::xsd::cxx::tree::traits< MaxOutputVoltage_type, wchar_t > MaxOutputVoltage_traits;

      const MaxOutputVoltage_optional&
      MaxOutputVoltage () const;

      MaxOutputVoltage_optional&
      MaxOutputVoltage ();

      void
      MaxOutputVoltage (const MaxOutputVoltage_type& x);

      void
      MaxOutputVoltage (const MaxOutputVoltage_optional& x);

      void
      MaxOutputVoltage (::std::unique_ptr< MaxOutputVoltage_type > p);

      // Constructors.
      //
      ChargeCoupledDeviceCameraSensorType ();

      ChargeCoupledDeviceCameraSensorType (const Name_type&,
                                           const id_type&);

      ChargeCoupledDeviceCameraSensorType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      ChargeCoupledDeviceCameraSensorType (const ChargeCoupledDeviceCameraSensorType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual ChargeCoupledDeviceCameraSensorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ChargeCoupledDeviceCameraSensorType&
      operator= (const ChargeCoupledDeviceCameraSensorType& x);

      virtual 
      ~ChargeCoupledDeviceCameraSensorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      NumberOfPixels_optional NumberOfPixels_;
      MaxReadoutFrequency_optional MaxReadoutFrequency_;
      HorizontalFieldOfView_optional HorizontalFieldOfView_;
      VerticalFieldOfView_optional VerticalFieldOfView_;
      MaxReadNoise_optional MaxReadNoise_;
      MaxFrameRate_optional MaxFrameRate_;
      PixelSize_optional PixelSize_;
      SustainedDataRate_optional SustainedDataRate_;
      DarkCurrent_optional DarkCurrent_;
      MaxPixelClockSpeed_optional MaxPixelClockSpeed_;
      Linearity_optional Linearity_;
      MaxOutputVoltage_optional MaxOutputVoltage_;
    };

    class QIF30_SYMBOL_DECL CMMType: public ::xsd::qif30::UniversalDeviceType
    {
      public:
      // Constructors.
      //
      CMMType ();

      CMMType (const Name_type&,
               const id_type&);

      CMMType (const xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

      CMMType (const CMMType& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

      virtual CMMType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      CMMType&
      operator= (const CMMType&) = default;
#endif

      virtual 
      ~CMMType ();
    };

    class QIF30_SYMBOL_DECL CartesianCMMType: public ::xsd::qif30::CMMType
    {
      public:
      // HomeLocation
      //
      typedef ::xsd::qif30::PointType HomeLocation_type;
      typedef ::xsd::cxx::tree::optional< HomeLocation_type > HomeLocation_optional;
      typedef ::xsd::cxx::tree::traits< HomeLocation_type, wchar_t > HomeLocation_traits;

      const HomeLocation_optional&
      HomeLocation () const;

      HomeLocation_optional&
      HomeLocation ();

      void
      HomeLocation (const HomeLocation_type& x);

      void
      HomeLocation (const HomeLocation_optional& x);

      void
      HomeLocation (::std::unique_ptr< HomeLocation_type > p);

      // CMMGeometry
      //
      typedef ::xsd::qif30::CartesianCMMGeometryType CMMGeometry_type;
      typedef ::xsd::cxx::tree::optional< CMMGeometry_type > CMMGeometry_optional;
      typedef ::xsd::cxx::tree::traits< CMMGeometry_type, wchar_t > CMMGeometry_traits;

      const CMMGeometry_optional&
      CMMGeometry () const;

      CMMGeometry_optional&
      CMMGeometry ();

      void
      CMMGeometry (const CMMGeometry_type& x);

      void
      CMMGeometry (const CMMGeometry_optional& x);

      void
      CMMGeometry (::std::unique_ptr< CMMGeometry_type > p);

      // CMMAxisDirections
      //
      typedef ::xsd::qif30::CMMAxisDirectionsBaseType CMMAxisDirections_type;
      typedef ::xsd::cxx::tree::optional< CMMAxisDirections_type > CMMAxisDirections_optional;
      typedef ::xsd::cxx::tree::traits< CMMAxisDirections_type, wchar_t > CMMAxisDirections_traits;

      const CMMAxisDirections_optional&
      CMMAxisDirections () const;

      CMMAxisDirections_optional&
      CMMAxisDirections ();

      void
      CMMAxisDirections (const CMMAxisDirections_type& x);

      void
      CMMAxisDirections (const CMMAxisDirections_optional& x);

      void
      CMMAxisDirections (::std::unique_ptr< CMMAxisDirections_type > p);

      // Scales
      //
      typedef ::xsd::qif30::MeasurementDeviceScalesBaseType Scales_type;
      typedef ::xsd::cxx::tree::optional< Scales_type > Scales_optional;
      typedef ::xsd::cxx::tree::traits< Scales_type, wchar_t > Scales_traits;

      const Scales_optional&
      Scales () const;

      Scales_optional&
      Scales ();

      void
      Scales (const Scales_type& x);

      void
      Scales (const Scales_optional& x);

      void
      Scales (::std::unique_ptr< Scales_type > p);

      // MaxWorkpieceHeight
      //
      typedef ::xsd::qif30::LinearValueType MaxWorkpieceHeight_type;
      typedef ::xsd::cxx::tree::optional< MaxWorkpieceHeight_type > MaxWorkpieceHeight_optional;
      typedef ::xsd::cxx::tree::traits< MaxWorkpieceHeight_type, wchar_t > MaxWorkpieceHeight_traits;

      const MaxWorkpieceHeight_optional&
      MaxWorkpieceHeight () const;

      MaxWorkpieceHeight_optional&
      MaxWorkpieceHeight ();

      void
      MaxWorkpieceHeight (const MaxWorkpieceHeight_type& x);

      void
      MaxWorkpieceHeight (const MaxWorkpieceHeight_optional& x);

      void
      MaxWorkpieceHeight (::std::unique_ptr< MaxWorkpieceHeight_type > p);

      // MaxWorkpieceMass
      //
      typedef ::xsd::qif30::MassValueType MaxWorkpieceMass_type;
      typedef ::xsd::cxx::tree::optional< MaxWorkpieceMass_type > MaxWorkpieceMass_optional;
      typedef ::xsd::cxx::tree::traits< MaxWorkpieceMass_type, wchar_t > MaxWorkpieceMass_traits;

      const MaxWorkpieceMass_optional&
      MaxWorkpieceMass () const;

      MaxWorkpieceMass_optional&
      MaxWorkpieceMass ();

      void
      MaxWorkpieceMass (const MaxWorkpieceMass_type& x);

      void
      MaxWorkpieceMass (const MaxWorkpieceMass_optional& x);

      void
      MaxWorkpieceMass (::std::unique_ptr< MaxWorkpieceMass_type > p);

      // JoystickSpeeds
      //
      typedef ::xsd::qif30::CartesianCMMSpeedsType JoystickSpeeds_type;
      typedef ::xsd::cxx::tree::optional< JoystickSpeeds_type > JoystickSpeeds_optional;
      typedef ::xsd::cxx::tree::traits< JoystickSpeeds_type, wchar_t > JoystickSpeeds_traits;

      const JoystickSpeeds_optional&
      JoystickSpeeds () const;

      JoystickSpeeds_optional&
      JoystickSpeeds ();

      void
      JoystickSpeeds (const JoystickSpeeds_type& x);

      void
      JoystickSpeeds (const JoystickSpeeds_optional& x);

      void
      JoystickSpeeds (::std::unique_ptr< JoystickSpeeds_type > p);

      // CMMSpeeds
      //
      typedef ::xsd::qif30::CMMSpeedsBaseType CMMSpeeds_type;
      typedef ::xsd::cxx::tree::optional< CMMSpeeds_type > CMMSpeeds_optional;
      typedef ::xsd::cxx::tree::traits< CMMSpeeds_type, wchar_t > CMMSpeeds_traits;

      const CMMSpeeds_optional&
      CMMSpeeds () const;

      CMMSpeeds_optional&
      CMMSpeeds ();

      void
      CMMSpeeds (const CMMSpeeds_type& x);

      void
      CMMSpeeds (const CMMSpeeds_optional& x);

      void
      CMMSpeeds (::std::unique_ptr< CMMSpeeds_type > p);

      // RotaryTable
      //
      typedef ::xsd::qif30::RotaryTableType RotaryTable_type;
      typedef ::xsd::cxx::tree::optional< RotaryTable_type > RotaryTable_optional;
      typedef ::xsd::cxx::tree::traits< RotaryTable_type, wchar_t > RotaryTable_traits;

      const RotaryTable_optional&
      RotaryTable () const;

      RotaryTable_optional&
      RotaryTable ();

      void
      RotaryTable (const RotaryTable_type& x);

      void
      RotaryTable (const RotaryTable_optional& x);

      void
      RotaryTable (::std::unique_ptr< RotaryTable_type > p);

      // Accuracies
      //
      typedef ::xsd::qif30::CartesianCMMAccuraciesType Accuracies_type;
      typedef ::xsd::cxx::tree::optional< Accuracies_type > Accuracies_optional;
      typedef ::xsd::cxx::tree::traits< Accuracies_type, wchar_t > Accuracies_traits;

      const Accuracies_optional&
      Accuracies () const;

      Accuracies_optional&
      Accuracies ();

      void
      Accuracies (const Accuracies_type& x);

      void
      Accuracies (const Accuracies_optional& x);

      void
      Accuracies (::std::unique_ptr< Accuracies_type > p);

      // ToolIds
      //
      typedef ::xsd::qif30::ArrayReferenceType ToolIds_type;
      typedef ::xsd::cxx::tree::optional< ToolIds_type > ToolIds_optional;
      typedef ::xsd::cxx::tree::traits< ToolIds_type, wchar_t > ToolIds_traits;

      const ToolIds_optional&
      ToolIds () const;

      ToolIds_optional&
      ToolIds ();

      void
      ToolIds (const ToolIds_type& x);

      void
      ToolIds (const ToolIds_optional& x);

      void
      ToolIds (::std::unique_ptr< ToolIds_type > p);

      // SensorIds
      //
      typedef ::xsd::qif30::ArrayReferenceType SensorIds_type;
      typedef ::xsd::cxx::tree::optional< SensorIds_type > SensorIds_optional;
      typedef ::xsd::cxx::tree::traits< SensorIds_type, wchar_t > SensorIds_traits;

      const SensorIds_optional&
      SensorIds () const;

      SensorIds_optional&
      SensorIds ();

      void
      SensorIds (const SensorIds_type& x);

      void
      SensorIds (const SensorIds_optional& x);

      void
      SensorIds (::std::unique_ptr< SensorIds_type > p);

      // Constructors.
      //
      CartesianCMMType ();

      CartesianCMMType (const Name_type&,
                        const id_type&);

      CartesianCMMType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      CartesianCMMType (const CartesianCMMType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual CartesianCMMType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CartesianCMMType&
      operator= (const CartesianCMMType& x);

      virtual 
      ~CartesianCMMType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      HomeLocation_optional HomeLocation_;
      CMMGeometry_optional CMMGeometry_;
      CMMAxisDirections_optional CMMAxisDirections_;
      Scales_optional Scales_;
      MaxWorkpieceHeight_optional MaxWorkpieceHeight_;
      MaxWorkpieceMass_optional MaxWorkpieceMass_;
      JoystickSpeeds_optional JoystickSpeeds_;
      CMMSpeeds_optional CMMSpeeds_;
      RotaryTable_optional RotaryTable_;
      Accuracies_optional Accuracies_;
      ToolIds_optional ToolIds_;
      SensorIds_optional SensorIds_;
    };

    class QIF30_SYMBOL_DECL MultipleCarriageCartesianCMMType: public ::xsd::qif30::CartesianCMMType
    {
      public:
      // Carriages
      //
      typedef ::xsd::qif30::CarriagesType Carriages_type;
      typedef ::xsd::cxx::tree::traits< Carriages_type, wchar_t > Carriages_traits;

      const Carriages_type&
      Carriages () const;

      Carriages_type&
      Carriages ();

      void
      Carriages (const Carriages_type& x);

      void
      Carriages (::std::unique_ptr< Carriages_type > p);

      // Constructors.
      //
      MultipleCarriageCartesianCMMType ();

      MultipleCarriageCartesianCMMType (const Name_type&,
                                        const id_type&,
                                        const Carriages_type&);

      MultipleCarriageCartesianCMMType (const Name_type&,
                                        const id_type&,
                                        ::std::unique_ptr< Carriages_type >);

      MultipleCarriageCartesianCMMType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      MultipleCarriageCartesianCMMType (const MultipleCarriageCartesianCMMType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual MultipleCarriageCartesianCMMType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MultipleCarriageCartesianCMMType&
      operator= (const MultipleCarriageCartesianCMMType& x);

      virtual 
      ~MultipleCarriageCartesianCMMType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Carriages_type > Carriages_;
    };

    class QIF30_SYMBOL_DECL LightPenCMMType: public ::xsd::qif30::CMMType
    {
      public:
      // LightPenCMMChargeCoupledDeviceCameraSensor
      //
      typedef ::xsd::qif30::ChargeCoupledDeviceCameraSensorType LightPenCMMChargeCoupledDeviceCameraSensor_type;
      typedef ::xsd::cxx::tree::optional< LightPenCMMChargeCoupledDeviceCameraSensor_type > LightPenCMMChargeCoupledDeviceCameraSensor_optional;
      typedef ::xsd::cxx::tree::traits< LightPenCMMChargeCoupledDeviceCameraSensor_type, wchar_t > LightPenCMMChargeCoupledDeviceCameraSensor_traits;

      const LightPenCMMChargeCoupledDeviceCameraSensor_optional&
      LightPenCMMChargeCoupledDeviceCameraSensor () const;

      LightPenCMMChargeCoupledDeviceCameraSensor_optional&
      LightPenCMMChargeCoupledDeviceCameraSensor ();

      void
      LightPenCMMChargeCoupledDeviceCameraSensor (const LightPenCMMChargeCoupledDeviceCameraSensor_type& x);

      void
      LightPenCMMChargeCoupledDeviceCameraSensor (const LightPenCMMChargeCoupledDeviceCameraSensor_optional& x);

      void
      LightPenCMMChargeCoupledDeviceCameraSensor (::std::unique_ptr< LightPenCMMChargeCoupledDeviceCameraSensor_type > p);

      // LightSource
      //
      typedef ::xml_schema::string LightSource_type;
      typedef ::xsd::cxx::tree::optional< LightSource_type > LightSource_optional;
      typedef ::xsd::cxx::tree::traits< LightSource_type, wchar_t > LightSource_traits;

      const LightSource_optional&
      LightSource () const;

      LightSource_optional&
      LightSource ();

      void
      LightSource (const LightSource_type& x);

      void
      LightSource (const LightSource_optional& x);

      void
      LightSource (::std::unique_ptr< LightSource_type > p);

      // NominalVolumetricAccuracy
      //
      typedef ::xsd::qif30::LinearValueType NominalVolumetricAccuracy_type;
      typedef ::xsd::cxx::tree::optional< NominalVolumetricAccuracy_type > NominalVolumetricAccuracy_optional;
      typedef ::xsd::cxx::tree::traits< NominalVolumetricAccuracy_type, wchar_t > NominalVolumetricAccuracy_traits;

      const NominalVolumetricAccuracy_optional&
      NominalVolumetricAccuracy () const;

      NominalVolumetricAccuracy_optional&
      NominalVolumetricAccuracy ();

      void
      NominalVolumetricAccuracy (const NominalVolumetricAccuracy_type& x);

      void
      NominalVolumetricAccuracy (const NominalVolumetricAccuracy_optional& x);

      void
      NominalVolumetricAccuracy (::std::unique_ptr< NominalVolumetricAccuracy_type > p);

      // ActualVolumetricAccuracy
      //
      typedef ::xsd::qif30::LinearValueType ActualVolumetricAccuracy_type;
      typedef ::xsd::cxx::tree::optional< ActualVolumetricAccuracy_type > ActualVolumetricAccuracy_optional;
      typedef ::xsd::cxx::tree::traits< ActualVolumetricAccuracy_type, wchar_t > ActualVolumetricAccuracy_traits;

      const ActualVolumetricAccuracy_optional&
      ActualVolumetricAccuracy () const;

      ActualVolumetricAccuracy_optional&
      ActualVolumetricAccuracy ();

      void
      ActualVolumetricAccuracy (const ActualVolumetricAccuracy_type& x);

      void
      ActualVolumetricAccuracy (const ActualVolumetricAccuracy_optional& x);

      void
      ActualVolumetricAccuracy (::std::unique_ptr< ActualVolumetricAccuracy_type > p);

      // NominalSinglePointAccuracy
      //
      typedef ::xsd::qif30::LinearValueType NominalSinglePointAccuracy_type;
      typedef ::xsd::cxx::tree::optional< NominalSinglePointAccuracy_type > NominalSinglePointAccuracy_optional;
      typedef ::xsd::cxx::tree::traits< NominalSinglePointAccuracy_type, wchar_t > NominalSinglePointAccuracy_traits;

      const NominalSinglePointAccuracy_optional&
      NominalSinglePointAccuracy () const;

      NominalSinglePointAccuracy_optional&
      NominalSinglePointAccuracy ();

      void
      NominalSinglePointAccuracy (const NominalSinglePointAccuracy_type& x);

      void
      NominalSinglePointAccuracy (const NominalSinglePointAccuracy_optional& x);

      void
      NominalSinglePointAccuracy (::std::unique_ptr< NominalSinglePointAccuracy_type > p);

      // ActualSinglePointAccuracy
      //
      typedef ::xsd::qif30::LinearValueType ActualSinglePointAccuracy_type;
      typedef ::xsd::cxx::tree::optional< ActualSinglePointAccuracy_type > ActualSinglePointAccuracy_optional;
      typedef ::xsd::cxx::tree::traits< ActualSinglePointAccuracy_type, wchar_t > ActualSinglePointAccuracy_traits;

      const ActualSinglePointAccuracy_optional&
      ActualSinglePointAccuracy () const;

      ActualSinglePointAccuracy_optional&
      ActualSinglePointAccuracy ();

      void
      ActualSinglePointAccuracy (const ActualSinglePointAccuracy_type& x);

      void
      ActualSinglePointAccuracy (const ActualSinglePointAccuracy_optional& x);

      void
      ActualSinglePointAccuracy (::std::unique_ptr< ActualSinglePointAccuracy_type > p);

      // ScanningSpeed
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType ScanningSpeed_type;
      typedef ::xsd::cxx::tree::optional< ScanningSpeed_type > ScanningSpeed_optional;
      typedef ::xsd::cxx::tree::traits< ScanningSpeed_type, wchar_t > ScanningSpeed_traits;

      const ScanningSpeed_optional&
      ScanningSpeed () const;

      ScanningSpeed_optional&
      ScanningSpeed ();

      void
      ScanningSpeed (const ScanningSpeed_type& x);

      void
      ScanningSpeed (const ScanningSpeed_optional& x);

      void
      ScanningSpeed (::std::unique_ptr< ScanningSpeed_type > p);

      // LaserClass
      //
      typedef ::xml_schema::string LaserClass_type;
      typedef ::xsd::cxx::tree::optional< LaserClass_type > LaserClass_optional;
      typedef ::xsd::cxx::tree::traits< LaserClass_type, wchar_t > LaserClass_traits;

      const LaserClass_optional&
      LaserClass () const;

      LaserClass_optional&
      LaserClass ();

      void
      LaserClass (const LaserClass_type& x);

      void
      LaserClass (const LaserClass_optional& x);

      void
      LaserClass (::std::unique_ptr< LaserClass_type > p);

      // Constructors.
      //
      LightPenCMMType ();

      LightPenCMMType (const Name_type&,
                       const id_type&);

      LightPenCMMType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      LightPenCMMType (const LightPenCMMType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual LightPenCMMType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LightPenCMMType&
      operator= (const LightPenCMMType& x);

      virtual 
      ~LightPenCMMType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      LightPenCMMChargeCoupledDeviceCameraSensor_optional LightPenCMMChargeCoupledDeviceCameraSensor_;
      LightSource_optional LightSource_;
      NominalVolumetricAccuracy_optional NominalVolumetricAccuracy_;
      ActualVolumetricAccuracy_optional ActualVolumetricAccuracy_;
      NominalSinglePointAccuracy_optional NominalSinglePointAccuracy_;
      ActualSinglePointAccuracy_optional ActualSinglePointAccuracy_;
      ScanningSpeed_optional ScanningSpeed_;
      LaserClass_optional LaserClass_;
    };

    class QIF30_SYMBOL_DECL ParallelLinkCMMType: public ::xsd::qif30::CMMType
    {
      public:
      // CMMSpeeds
      //
      typedef ::xsd::qif30::CMMSpeedsBaseType CMMSpeeds_type;
      typedef ::xsd::cxx::tree::optional< CMMSpeeds_type > CMMSpeeds_optional;
      typedef ::xsd::cxx::tree::traits< CMMSpeeds_type, wchar_t > CMMSpeeds_traits;

      const CMMSpeeds_optional&
      CMMSpeeds () const;

      CMMSpeeds_optional&
      CMMSpeeds ();

      void
      CMMSpeeds (const CMMSpeeds_type& x);

      void
      CMMSpeeds (const CMMSpeeds_optional& x);

      void
      CMMSpeeds (::std::unique_ptr< CMMSpeeds_type > p);

      // AxesTravelDistance
      //
      typedef ::xsd::qif30::XYZLinearSpecificationType AxesTravelDistance_type;
      typedef ::xsd::cxx::tree::optional< AxesTravelDistance_type > AxesTravelDistance_optional;
      typedef ::xsd::cxx::tree::traits< AxesTravelDistance_type, wchar_t > AxesTravelDistance_traits;

      const AxesTravelDistance_optional&
      AxesTravelDistance () const;

      AxesTravelDistance_optional&
      AxesTravelDistance ();

      void
      AxesTravelDistance (const AxesTravelDistance_type& x);

      void
      AxesTravelDistance (const AxesTravelDistance_optional& x);

      void
      AxesTravelDistance (::std::unique_ptr< AxesTravelDistance_type > p);

      // AxesRotationAngle
      //
      typedef ::xsd::qif30::AngularValueType AxesRotationAngle_type;
      typedef ::xsd::cxx::tree::optional< AxesRotationAngle_type > AxesRotationAngle_optional;
      typedef ::xsd::cxx::tree::traits< AxesRotationAngle_type, wchar_t > AxesRotationAngle_traits;

      const AxesRotationAngle_optional&
      AxesRotationAngle () const;

      AxesRotationAngle_optional&
      AxesRotationAngle ();

      void
      AxesRotationAngle (const AxesRotationAngle_type& x);

      void
      AxesRotationAngle (const AxesRotationAngle_optional& x);

      void
      AxesRotationAngle (::std::unique_ptr< AxesRotationAngle_type > p);

      // AxisBacklash
      //
      typedef ::xsd::qif30::XYZLinearSpecificationType AxisBacklash_type;
      typedef ::xsd::cxx::tree::optional< AxisBacklash_type > AxisBacklash_optional;
      typedef ::xsd::cxx::tree::traits< AxisBacklash_type, wchar_t > AxisBacklash_traits;

      const AxisBacklash_optional&
      AxisBacklash () const;

      AxisBacklash_optional&
      AxisBacklash ();

      void
      AxisBacklash (const AxisBacklash_type& x);

      void
      AxisBacklash (const AxisBacklash_optional& x);

      void
      AxisBacklash (::std::unique_ptr< AxisBacklash_type > p);

      // AxisRepeatability
      //
      typedef ::xsd::qif30::XYZLinearSpecificationType AxisRepeatability_type;
      typedef ::xsd::cxx::tree::optional< AxisRepeatability_type > AxisRepeatability_optional;
      typedef ::xsd::cxx::tree::traits< AxisRepeatability_type, wchar_t > AxisRepeatability_traits;

      const AxisRepeatability_optional&
      AxisRepeatability () const;

      AxisRepeatability_optional&
      AxisRepeatability ();

      void
      AxisRepeatability (const AxisRepeatability_type& x);

      void
      AxisRepeatability (const AxisRepeatability_optional& x);

      void
      AxisRepeatability (::std::unique_ptr< AxisRepeatability_type > p);

      // MaxLoad
      //
      typedef ::xsd::qif30::MassValueType MaxLoad_type;
      typedef ::xsd::cxx::tree::optional< MaxLoad_type > MaxLoad_optional;
      typedef ::xsd::cxx::tree::traits< MaxLoad_type, wchar_t > MaxLoad_traits;

      const MaxLoad_optional&
      MaxLoad () const;

      MaxLoad_optional&
      MaxLoad ();

      void
      MaxLoad (const MaxLoad_type& x);

      void
      MaxLoad (const MaxLoad_optional& x);

      void
      MaxLoad (::std::unique_ptr< MaxLoad_type > p);

      // StageMaterial
      //
      typedef ::xml_schema::string StageMaterial_type;
      typedef ::xsd::cxx::tree::optional< StageMaterial_type > StageMaterial_optional;
      typedef ::xsd::cxx::tree::traits< StageMaterial_type, wchar_t > StageMaterial_traits;

      const StageMaterial_optional&
      StageMaterial () const;

      StageMaterial_optional&
      StageMaterial ();

      void
      StageMaterial (const StageMaterial_type& x);

      void
      StageMaterial (const StageMaterial_optional& x);

      void
      StageMaterial (::std::unique_ptr< StageMaterial_type > p);

      // MaxHoldingForce
      //
      typedef ::xsd::qif30::ForceValueType MaxHoldingForce_type;
      typedef ::xsd::cxx::tree::optional< MaxHoldingForce_type > MaxHoldingForce_optional;
      typedef ::xsd::cxx::tree::traits< MaxHoldingForce_type, wchar_t > MaxHoldingForce_traits;

      const MaxHoldingForce_optional&
      MaxHoldingForce () const;

      MaxHoldingForce_optional&
      MaxHoldingForce ();

      void
      MaxHoldingForce (const MaxHoldingForce_type& x);

      void
      MaxHoldingForce (const MaxHoldingForce_optional& x);

      void
      MaxHoldingForce (::std::unique_ptr< MaxHoldingForce_type > p);

      // MotorType
      //
      typedef ::xml_schema::string MotorType_type;
      typedef ::xsd::cxx::tree::optional< MotorType_type > MotorType_optional;
      typedef ::xsd::cxx::tree::traits< MotorType_type, wchar_t > MotorType_traits;

      const MotorType_optional&
      MotorType () const;

      MotorType_optional&
      MotorType ();

      void
      MotorType (const MotorType_type& x);

      void
      MotorType (const MotorType_optional& x);

      void
      MotorType (::std::unique_ptr< MotorType_type > p);

      // LinksStiffness
      //
      typedef ::xsd::qif30::StiffnessType LinksStiffness_type;
      typedef ::xsd::cxx::tree::optional< LinksStiffness_type > LinksStiffness_optional;
      typedef ::xsd::cxx::tree::traits< LinksStiffness_type, wchar_t > LinksStiffness_traits;

      const LinksStiffness_optional&
      LinksStiffness () const;

      LinksStiffness_optional&
      LinksStiffness ();

      void
      LinksStiffness (const LinksStiffness_type& x);

      void
      LinksStiffness (const LinksStiffness_optional& x);

      void
      LinksStiffness (::std::unique_ptr< LinksStiffness_type > p);

      // ToolIds
      //
      typedef ::xsd::qif30::ArrayReferenceType ToolIds_type;
      typedef ::xsd::cxx::tree::optional< ToolIds_type > ToolIds_optional;
      typedef ::xsd::cxx::tree::traits< ToolIds_type, wchar_t > ToolIds_traits;

      const ToolIds_optional&
      ToolIds () const;

      ToolIds_optional&
      ToolIds ();

      void
      ToolIds (const ToolIds_type& x);

      void
      ToolIds (const ToolIds_optional& x);

      void
      ToolIds (::std::unique_ptr< ToolIds_type > p);

      // Constructors.
      //
      ParallelLinkCMMType ();

      ParallelLinkCMMType (const Name_type&,
                           const id_type&);

      ParallelLinkCMMType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      ParallelLinkCMMType (const ParallelLinkCMMType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual ParallelLinkCMMType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ParallelLinkCMMType&
      operator= (const ParallelLinkCMMType& x);

      virtual 
      ~ParallelLinkCMMType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CMMSpeeds_optional CMMSpeeds_;
      AxesTravelDistance_optional AxesTravelDistance_;
      AxesRotationAngle_optional AxesRotationAngle_;
      AxisBacklash_optional AxisBacklash_;
      AxisRepeatability_optional AxisRepeatability_;
      MaxLoad_optional MaxLoad_;
      StageMaterial_optional StageMaterial_;
      MaxHoldingForce_optional MaxHoldingForce_;
      MotorType_optional MotorType_;
      LinksStiffness_optional LinksStiffness_;
      ToolIds_optional ToolIds_;
    };

    class QIF30_SYMBOL_DECL AACMMType: public ::xsd::qif30::CMMType
    {
      public:
      // HomeLocation
      //
      typedef ::xsd::qif30::PointType HomeLocation_type;
      typedef ::xsd::cxx::tree::optional< HomeLocation_type > HomeLocation_optional;
      typedef ::xsd::cxx::tree::traits< HomeLocation_type, wchar_t > HomeLocation_traits;

      const HomeLocation_optional&
      HomeLocation () const;

      HomeLocation_optional&
      HomeLocation ();

      void
      HomeLocation (const HomeLocation_type& x);

      void
      HomeLocation (const HomeLocation_optional& x);

      void
      HomeLocation (::std::unique_ptr< HomeLocation_type > p);

      // NumberOfJoints
      //
      typedef ::xml_schema::int_ NumberOfJoints_type;
      typedef ::xsd::cxx::tree::optional< NumberOfJoints_type > NumberOfJoints_optional;
      typedef ::xsd::cxx::tree::traits< NumberOfJoints_type, wchar_t > NumberOfJoints_traits;

      const NumberOfJoints_optional&
      NumberOfJoints () const;

      NumberOfJoints_optional&
      NumberOfJoints ();

      void
      NumberOfJoints (const NumberOfJoints_type& x);

      void
      NumberOfJoints (const NumberOfJoints_optional& x);

      // MinMeasuringDistance
      //
      typedef ::xsd::qif30::LinearValueType MinMeasuringDistance_type;
      typedef ::xsd::cxx::tree::optional< MinMeasuringDistance_type > MinMeasuringDistance_optional;
      typedef ::xsd::cxx::tree::traits< MinMeasuringDistance_type, wchar_t > MinMeasuringDistance_traits;

      const MinMeasuringDistance_optional&
      MinMeasuringDistance () const;

      MinMeasuringDistance_optional&
      MinMeasuringDistance ();

      void
      MinMeasuringDistance (const MinMeasuringDistance_type& x);

      void
      MinMeasuringDistance (const MinMeasuringDistance_optional& x);

      void
      MinMeasuringDistance (::std::unique_ptr< MinMeasuringDistance_type > p);

      // MaxMeasuringDistance
      //
      typedef ::xsd::qif30::LinearValueType MaxMeasuringDistance_type;
      typedef ::xsd::cxx::tree::optional< MaxMeasuringDistance_type > MaxMeasuringDistance_optional;
      typedef ::xsd::cxx::tree::traits< MaxMeasuringDistance_type, wchar_t > MaxMeasuringDistance_traits;

      const MaxMeasuringDistance_optional&
      MaxMeasuringDistance () const;

      MaxMeasuringDistance_optional&
      MaxMeasuringDistance ();

      void
      MaxMeasuringDistance (const MaxMeasuringDistance_type& x);

      void
      MaxMeasuringDistance (const MaxMeasuringDistance_optional& x);

      void
      MaxMeasuringDistance (::std::unique_ptr< MaxMeasuringDistance_type > p);

      // ProbeTipDiameter
      //
      typedef ::xsd::qif30::LinearValueType ProbeTipDiameter_type;
      typedef ::xsd::cxx::tree::optional< ProbeTipDiameter_type > ProbeTipDiameter_optional;
      typedef ::xsd::cxx::tree::traits< ProbeTipDiameter_type, wchar_t > ProbeTipDiameter_traits;

      const ProbeTipDiameter_optional&
      ProbeTipDiameter () const;

      ProbeTipDiameter_optional&
      ProbeTipDiameter ();

      void
      ProbeTipDiameter (const ProbeTipDiameter_type& x);

      void
      ProbeTipDiameter (const ProbeTipDiameter_optional& x);

      void
      ProbeTipDiameter (::std::unique_ptr< ProbeTipDiameter_type > p);

      // Accuracies
      //
      typedef ::xsd::qif30::AACMMAccuraciesType Accuracies_type;
      typedef ::xsd::cxx::tree::optional< Accuracies_type > Accuracies_optional;
      typedef ::xsd::cxx::tree::traits< Accuracies_type, wchar_t > Accuracies_traits;

      const Accuracies_optional&
      Accuracies () const;

      Accuracies_optional&
      Accuracies ();

      void
      Accuracies (const Accuracies_type& x);

      void
      Accuracies (const Accuracies_optional& x);

      void
      Accuracies (::std::unique_ptr< Accuracies_type > p);

      // Constructors.
      //
      AACMMType ();

      AACMMType (const Name_type&,
                 const id_type&);

      AACMMType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      AACMMType (const AACMMType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual AACMMType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AACMMType&
      operator= (const AACMMType& x);

      virtual 
      ~AACMMType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      HomeLocation_optional HomeLocation_;
      NumberOfJoints_optional NumberOfJoints_;
      MinMeasuringDistance_optional MinMeasuringDistance_;
      MaxMeasuringDistance_optional MaxMeasuringDistance_;
      ProbeTipDiameter_optional ProbeTipDiameter_;
      Accuracies_optional Accuracies_;
    };

    class QIF30_SYMBOL_DECL CaliperType: public ::xsd::qif30::ManualMeasurementDeviceType
    {
      public:
      // LinearResolution
      //
      typedef ::xsd::qif30::LinearResolutionType LinearResolution_type;
      typedef ::xsd::cxx::tree::optional< LinearResolution_type > LinearResolution_optional;
      typedef ::xsd::cxx::tree::traits< LinearResolution_type, wchar_t > LinearResolution_traits;

      const LinearResolution_optional&
      LinearResolution () const;

      LinearResolution_optional&
      LinearResolution ();

      void
      LinearResolution (const LinearResolution_type& x);

      void
      LinearResolution (const LinearResolution_optional& x);

      void
      LinearResolution (::std::unique_ptr< LinearResolution_type > p);

      // Accuracy
      //
      typedef ::xsd::qif30::NumericalLengthAccuracyType Accuracy_type;
      typedef ::xsd::cxx::tree::optional< Accuracy_type > Accuracy_optional;
      typedef ::xsd::cxx::tree::traits< Accuracy_type, wchar_t > Accuracy_traits;

      const Accuracy_optional&
      Accuracy () const;

      Accuracy_optional&
      Accuracy ();

      void
      Accuracy (const Accuracy_type& x);

      void
      Accuracy (const Accuracy_optional& x);

      void
      Accuracy (::std::unique_ptr< Accuracy_type > p);

      // CanMeasureInnerD
      //
      typedef ::xml_schema::boolean CanMeasureInnerD_type;
      typedef ::xsd::cxx::tree::optional< CanMeasureInnerD_type > CanMeasureInnerD_optional;
      typedef ::xsd::cxx::tree::traits< CanMeasureInnerD_type, wchar_t > CanMeasureInnerD_traits;

      const CanMeasureInnerD_optional&
      CanMeasureInnerD () const;

      CanMeasureInnerD_optional&
      CanMeasureInnerD ();

      void
      CanMeasureInnerD (const CanMeasureInnerD_type& x);

      void
      CanMeasureInnerD (const CanMeasureInnerD_optional& x);

      // CanMeasureOuterD
      //
      typedef ::xml_schema::boolean CanMeasureOuterD_type;
      typedef ::xsd::cxx::tree::optional< CanMeasureOuterD_type > CanMeasureOuterD_optional;
      typedef ::xsd::cxx::tree::traits< CanMeasureOuterD_type, wchar_t > CanMeasureOuterD_traits;

      const CanMeasureOuterD_optional&
      CanMeasureOuterD () const;

      CanMeasureOuterD_optional&
      CanMeasureOuterD ();

      void
      CanMeasureOuterD (const CanMeasureOuterD_type& x);

      void
      CanMeasureOuterD (const CanMeasureOuterD_optional& x);

      // CanMeasureDepth
      //
      typedef ::xml_schema::boolean CanMeasureDepth_type;
      typedef ::xsd::cxx::tree::optional< CanMeasureDepth_type > CanMeasureDepth_optional;
      typedef ::xsd::cxx::tree::traits< CanMeasureDepth_type, wchar_t > CanMeasureDepth_traits;

      const CanMeasureDepth_optional&
      CanMeasureDepth () const;

      CanMeasureDepth_optional&
      CanMeasureDepth ();

      void
      CanMeasureDepth (const CanMeasureDepth_type& x);

      void
      CanMeasureDepth (const CanMeasureDepth_optional& x);

      // Constructors.
      //
      CaliperType ();

      CaliperType (const Name_type&,
                   const id_type&);

      CaliperType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      CaliperType (const CaliperType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual CaliperType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CaliperType&
      operator= (const CaliperType& x);

      virtual 
      ~CaliperType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      LinearResolution_optional LinearResolution_;
      Accuracy_optional Accuracy_;
      CanMeasureInnerD_optional CanMeasureInnerD_;
      CanMeasureOuterD_optional CanMeasureOuterD_;
      CanMeasureDepth_optional CanMeasureDepth_;
    };

    class QIF30_SYMBOL_DECL CaliperDialType: public ::xsd::qif30::CaliperType
    {
      public:
      // Constructors.
      //
      CaliperDialType ();

      CaliperDialType (const Name_type&,
                       const id_type&);

      CaliperDialType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      CaliperDialType (const CaliperDialType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual CaliperDialType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      CaliperDialType&
      operator= (const CaliperDialType&) = default;
#endif

      virtual 
      ~CaliperDialType ();
    };

    class QIF30_SYMBOL_DECL CaliperDigitalType: public ::xsd::qif30::CaliperType
    {
      public:
      // Constructors.
      //
      CaliperDigitalType ();

      CaliperDigitalType (const Name_type&,
                          const id_type&);

      CaliperDigitalType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      CaliperDigitalType (const CaliperDigitalType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual CaliperDigitalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      CaliperDigitalType&
      operator= (const CaliperDigitalType&) = default;
#endif

      virtual 
      ~CaliperDigitalType ();
    };

    class QIF30_SYMBOL_DECL MicrometerType: public ::xsd::qif30::ManualMeasurementDeviceType
    {
      public:
      // LinearResolution
      //
      typedef ::xsd::qif30::LinearResolutionType LinearResolution_type;
      typedef ::xsd::cxx::tree::optional< LinearResolution_type > LinearResolution_optional;
      typedef ::xsd::cxx::tree::traits< LinearResolution_type, wchar_t > LinearResolution_traits;

      const LinearResolution_optional&
      LinearResolution () const;

      LinearResolution_optional&
      LinearResolution ();

      void
      LinearResolution (const LinearResolution_type& x);

      void
      LinearResolution (const LinearResolution_optional& x);

      void
      LinearResolution (::std::unique_ptr< LinearResolution_type > p);

      // Accuracy
      //
      typedef ::xsd::qif30::NumericalLengthAccuracyType Accuracy_type;
      typedef ::xsd::cxx::tree::optional< Accuracy_type > Accuracy_optional;
      typedef ::xsd::cxx::tree::traits< Accuracy_type, wchar_t > Accuracy_traits;

      const Accuracy_optional&
      Accuracy () const;

      Accuracy_optional&
      Accuracy ();

      void
      Accuracy (const Accuracy_type& x);

      void
      Accuracy (const Accuracy_optional& x);

      void
      Accuracy (::std::unique_ptr< Accuracy_type > p);

      // MeasuringForce
      //
      typedef ::xsd::qif30::ForceValueType MeasuringForce_type;
      typedef ::xsd::cxx::tree::optional< MeasuringForce_type > MeasuringForce_optional;
      typedef ::xsd::cxx::tree::traits< MeasuringForce_type, wchar_t > MeasuringForce_traits;

      const MeasuringForce_optional&
      MeasuringForce () const;

      MeasuringForce_optional&
      MeasuringForce ();

      void
      MeasuringForce (const MeasuringForce_type& x);

      void
      MeasuringForce (const MeasuringForce_optional& x);

      void
      MeasuringForce (::std::unique_ptr< MeasuringForce_type > p);

      // InternalExternal
      //
      typedef ::xsd::qif30::InternalExternalEnumType InternalExternal_type;
      typedef ::xsd::cxx::tree::optional< InternalExternal_type > InternalExternal_optional;
      typedef ::xsd::cxx::tree::traits< InternalExternal_type, wchar_t > InternalExternal_traits;

      const InternalExternal_optional&
      InternalExternal () const;

      InternalExternal_optional&
      InternalExternal ();

      void
      InternalExternal (const InternalExternal_type& x);

      void
      InternalExternal (const InternalExternal_optional& x);

      void
      InternalExternal (::std::unique_ptr< InternalExternal_type > p);

      static const InternalExternal_type&
      InternalExternal_default_value ();

      // Constructors.
      //
      MicrometerType ();

      MicrometerType (const Name_type&,
                      const id_type&);

      MicrometerType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      MicrometerType (const MicrometerType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual MicrometerType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MicrometerType&
      operator= (const MicrometerType& x);

      virtual 
      ~MicrometerType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      LinearResolution_optional LinearResolution_;
      Accuracy_optional Accuracy_;
      MeasuringForce_optional MeasuringForce_;
      InternalExternal_optional InternalExternal_;
      static const InternalExternal_type InternalExternal_default_value_;
    };

    class QIF30_SYMBOL_DECL MicrometerAnalogType: public ::xsd::qif30::MicrometerType
    {
      public:
      // Constructors.
      //
      MicrometerAnalogType ();

      MicrometerAnalogType (const Name_type&,
                            const id_type&);

      MicrometerAnalogType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      MicrometerAnalogType (const MicrometerAnalogType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual MicrometerAnalogType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      MicrometerAnalogType&
      operator= (const MicrometerAnalogType&) = default;
#endif

      virtual 
      ~MicrometerAnalogType ();
    };

    class QIF30_SYMBOL_DECL MicrometerDigitalType: public ::xsd::qif30::MicrometerType
    {
      public:
      // Constructors.
      //
      MicrometerDigitalType ();

      MicrometerDigitalType (const Name_type&,
                             const id_type&);

      MicrometerDigitalType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      MicrometerDigitalType (const MicrometerDigitalType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual MicrometerDigitalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      MicrometerDigitalType&
      operator= (const MicrometerDigitalType&) = default;
#endif

      virtual 
      ~MicrometerDigitalType ();
    };

    class QIF30_SYMBOL_DECL GageDeviceType: public ::xsd::qif30::ManualMeasurementDeviceType
    {
      public:
      // Constructors.
      //
      GageDeviceType ();

      GageDeviceType (const Name_type&,
                      const id_type&);

      GageDeviceType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      GageDeviceType (const GageDeviceType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual GageDeviceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      GageDeviceType&
      operator= (const GageDeviceType&) = default;
#endif

      virtual 
      ~GageDeviceType ();
    };

    class QIF30_SYMBOL_DECL SineBarType: public ::xsd::qif30::ManualMeasurementDeviceType
    {
      public:
      // NominalBallCenterToBallCenterLength
      //
      typedef ::xsd::qif30::LinearValueType NominalBallCenterToBallCenterLength_type;
      typedef ::xsd::cxx::tree::optional< NominalBallCenterToBallCenterLength_type > NominalBallCenterToBallCenterLength_optional;
      typedef ::xsd::cxx::tree::traits< NominalBallCenterToBallCenterLength_type, wchar_t > NominalBallCenterToBallCenterLength_traits;

      const NominalBallCenterToBallCenterLength_optional&
      NominalBallCenterToBallCenterLength () const;

      NominalBallCenterToBallCenterLength_optional&
      NominalBallCenterToBallCenterLength ();

      void
      NominalBallCenterToBallCenterLength (const NominalBallCenterToBallCenterLength_type& x);

      void
      NominalBallCenterToBallCenterLength (const NominalBallCenterToBallCenterLength_optional& x);

      void
      NominalBallCenterToBallCenterLength (::std::unique_ptr< NominalBallCenterToBallCenterLength_type > p);

      // CylinderCenterToCylinderCenterAccuracy
      //
      typedef ::xsd::qif30::LinearValueType CylinderCenterToCylinderCenterAccuracy_type;
      typedef ::xsd::cxx::tree::optional< CylinderCenterToCylinderCenterAccuracy_type > CylinderCenterToCylinderCenterAccuracy_optional;
      typedef ::xsd::cxx::tree::traits< CylinderCenterToCylinderCenterAccuracy_type, wchar_t > CylinderCenterToCylinderCenterAccuracy_traits;

      const CylinderCenterToCylinderCenterAccuracy_optional&
      CylinderCenterToCylinderCenterAccuracy () const;

      CylinderCenterToCylinderCenterAccuracy_optional&
      CylinderCenterToCylinderCenterAccuracy ();

      void
      CylinderCenterToCylinderCenterAccuracy (const CylinderCenterToCylinderCenterAccuracy_type& x);

      void
      CylinderCenterToCylinderCenterAccuracy (const CylinderCenterToCylinderCenterAccuracy_optional& x);

      void
      CylinderCenterToCylinderCenterAccuracy (::std::unique_ptr< CylinderCenterToCylinderCenterAccuracy_type > p);

      // Parallelism
      //
      typedef ::xsd::qif30::LinearValueType Parallelism_type;
      typedef ::xsd::cxx::tree::optional< Parallelism_type > Parallelism_optional;
      typedef ::xsd::cxx::tree::traits< Parallelism_type, wchar_t > Parallelism_traits;

      const Parallelism_optional&
      Parallelism () const;

      Parallelism_optional&
      Parallelism ();

      void
      Parallelism (const Parallelism_type& x);

      void
      Parallelism (const Parallelism_optional& x);

      void
      Parallelism (::std::unique_ptr< Parallelism_type > p);

      // OverallLength
      //
      typedef ::xsd::qif30::LinearValueType OverallLength_type;
      typedef ::xsd::cxx::tree::optional< OverallLength_type > OverallLength_optional;
      typedef ::xsd::cxx::tree::traits< OverallLength_type, wchar_t > OverallLength_traits;

      const OverallLength_optional&
      OverallLength () const;

      OverallLength_optional&
      OverallLength ();

      void
      OverallLength (const OverallLength_type& x);

      void
      OverallLength (const OverallLength_optional& x);

      void
      OverallLength (::std::unique_ptr< OverallLength_type > p);

      // Material
      //
      typedef ::xml_schema::string Material_type;
      typedef ::xsd::cxx::tree::optional< Material_type > Material_optional;
      typedef ::xsd::cxx::tree::traits< Material_type, wchar_t > Material_traits;

      const Material_optional&
      Material () const;

      Material_optional&
      Material ();

      void
      Material (const Material_type& x);

      void
      Material (const Material_optional& x);

      void
      Material (::std::unique_ptr< Material_type > p);

      // Magnetic
      //
      typedef ::xml_schema::boolean Magnetic_type;
      typedef ::xsd::cxx::tree::optional< Magnetic_type > Magnetic_optional;
      typedef ::xsd::cxx::tree::traits< Magnetic_type, wchar_t > Magnetic_traits;

      const Magnetic_optional&
      Magnetic () const;

      Magnetic_optional&
      Magnetic ();

      void
      Magnetic (const Magnetic_type& x);

      void
      Magnetic (const Magnetic_optional& x);

      // Width
      //
      typedef ::xsd::qif30::LinearValueType Width_type;
      typedef ::xsd::cxx::tree::optional< Width_type > Width_optional;
      typedef ::xsd::cxx::tree::traits< Width_type, wchar_t > Width_traits;

      const Width_optional&
      Width () const;

      Width_optional&
      Width ();

      void
      Width (const Width_type& x);

      void
      Width (const Width_optional& x);

      void
      Width (::std::unique_ptr< Width_type > p);

      // Constructors.
      //
      SineBarType ();

      SineBarType (const Name_type&,
                   const id_type&);

      SineBarType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      SineBarType (const SineBarType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual SineBarType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SineBarType&
      operator= (const SineBarType& x);

      virtual 
      ~SineBarType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      NominalBallCenterToBallCenterLength_optional NominalBallCenterToBallCenterLength_;
      CylinderCenterToCylinderCenterAccuracy_optional CylinderCenterToCylinderCenterAccuracy_;
      Parallelism_optional Parallelism_;
      OverallLength_optional OverallLength_;
      Material_optional Material_;
      Magnetic_optional Magnetic_;
      Width_optional Width_;
    };

    class QIF30_SYMBOL_DECL TheodoliteType: public ::xsd::qif30::UniversalDeviceType
    {
      public:
      // LongitudinalTrackingSpeed
      //
      typedef ::xsd::qif30::SpeedValueType LongitudinalTrackingSpeed_type;
      typedef ::xsd::cxx::tree::optional< LongitudinalTrackingSpeed_type > LongitudinalTrackingSpeed_optional;
      typedef ::xsd::cxx::tree::traits< LongitudinalTrackingSpeed_type, wchar_t > LongitudinalTrackingSpeed_traits;

      const LongitudinalTrackingSpeed_optional&
      LongitudinalTrackingSpeed () const;

      LongitudinalTrackingSpeed_optional&
      LongitudinalTrackingSpeed ();

      void
      LongitudinalTrackingSpeed (const LongitudinalTrackingSpeed_type& x);

      void
      LongitudinalTrackingSpeed (const LongitudinalTrackingSpeed_optional& x);

      void
      LongitudinalTrackingSpeed (::std::unique_ptr< LongitudinalTrackingSpeed_type > p);

      // LateralTrackingSpeed
      //
      typedef ::xsd::qif30::SpeedValueType LateralTrackingSpeed_type;
      typedef ::xsd::cxx::tree::optional< LateralTrackingSpeed_type > LateralTrackingSpeed_optional;
      typedef ::xsd::cxx::tree::traits< LateralTrackingSpeed_type, wchar_t > LateralTrackingSpeed_traits;

      const LateralTrackingSpeed_optional&
      LateralTrackingSpeed () const;

      LateralTrackingSpeed_optional&
      LateralTrackingSpeed ();

      void
      LateralTrackingSpeed (const LateralTrackingSpeed_type& x);

      void
      LateralTrackingSpeed (const LateralTrackingSpeed_optional& x);

      void
      LateralTrackingSpeed (::std::unique_ptr< LateralTrackingSpeed_type > p);

      // Magnification
      //
      typedef ::xml_schema::decimal Magnification_type;
      typedef ::xsd::cxx::tree::optional< Magnification_type > Magnification_optional;
      typedef ::xsd::cxx::tree::traits< Magnification_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > Magnification_traits;

      const Magnification_optional&
      Magnification () const;

      Magnification_optional&
      Magnification ();

      void
      Magnification (const Magnification_type& x);

      void
      Magnification (const Magnification_optional& x);

      // FieldOfViewDiameter
      //
      typedef ::xsd::qif30::LinearValueType FieldOfViewDiameter_type;
      typedef ::xsd::cxx::tree::optional< FieldOfViewDiameter_type > FieldOfViewDiameter_optional;
      typedef ::xsd::cxx::tree::traits< FieldOfViewDiameter_type, wchar_t > FieldOfViewDiameter_traits;

      const FieldOfViewDiameter_optional&
      FieldOfViewDiameter () const;

      FieldOfViewDiameter_optional&
      FieldOfViewDiameter ();

      void
      FieldOfViewDiameter (const FieldOfViewDiameter_type& x);

      void
      FieldOfViewDiameter (const FieldOfViewDiameter_optional& x);

      void
      FieldOfViewDiameter (::std::unique_ptr< FieldOfViewDiameter_type > p);

      // ApertureSize
      //
      typedef ::xsd::qif30::LinearValueType ApertureSize_type;
      typedef ::xsd::cxx::tree::optional< ApertureSize_type > ApertureSize_optional;
      typedef ::xsd::cxx::tree::traits< ApertureSize_type, wchar_t > ApertureSize_traits;

      const ApertureSize_optional&
      ApertureSize () const;

      ApertureSize_optional&
      ApertureSize ();

      void
      ApertureSize (const ApertureSize_type& x);

      void
      ApertureSize (const ApertureSize_optional& x);

      void
      ApertureSize (::std::unique_ptr< ApertureSize_type > p);

      // MaxFocusDistance
      //
      typedef ::xsd::qif30::LinearValueType MaxFocusDistance_type;
      typedef ::xsd::cxx::tree::optional< MaxFocusDistance_type > MaxFocusDistance_optional;
      typedef ::xsd::cxx::tree::traits< MaxFocusDistance_type, wchar_t > MaxFocusDistance_traits;

      const MaxFocusDistance_optional&
      MaxFocusDistance () const;

      MaxFocusDistance_optional&
      MaxFocusDistance ();

      void
      MaxFocusDistance (const MaxFocusDistance_type& x);

      void
      MaxFocusDistance (const MaxFocusDistance_optional& x);

      void
      MaxFocusDistance (::std::unique_ptr< MaxFocusDistance_type > p);

      // AngularAccuracy
      //
      typedef ::xsd::qif30::AngularValueType AngularAccuracy_type;
      typedef ::xsd::cxx::tree::optional< AngularAccuracy_type > AngularAccuracy_optional;
      typedef ::xsd::cxx::tree::traits< AngularAccuracy_type, wchar_t > AngularAccuracy_traits;

      const AngularAccuracy_optional&
      AngularAccuracy () const;

      AngularAccuracy_optional&
      AngularAccuracy ();

      void
      AngularAccuracy (const AngularAccuracy_type& x);

      void
      AngularAccuracy (const AngularAccuracy_optional& x);

      void
      AngularAccuracy (::std::unique_ptr< AngularAccuracy_type > p);

      // MaxTiltCompensation
      //
      typedef ::xsd::qif30::AngularValueType MaxTiltCompensation_type;
      typedef ::xsd::cxx::tree::optional< MaxTiltCompensation_type > MaxTiltCompensation_optional;
      typedef ::xsd::cxx::tree::traits< MaxTiltCompensation_type, wchar_t > MaxTiltCompensation_traits;

      const MaxTiltCompensation_optional&
      MaxTiltCompensation () const;

      MaxTiltCompensation_optional&
      MaxTiltCompensation ();

      void
      MaxTiltCompensation (const MaxTiltCompensation_type& x);

      void
      MaxTiltCompensation (const MaxTiltCompensation_optional& x);

      void
      MaxTiltCompensation (::std::unique_ptr< MaxTiltCompensation_type > p);

      // ChargeCoupledDeviceCameraSensor
      //
      typedef ::xsd::qif30::ChargeCoupledDeviceCameraSensorType ChargeCoupledDeviceCameraSensor_type;
      typedef ::xsd::cxx::tree::optional< ChargeCoupledDeviceCameraSensor_type > ChargeCoupledDeviceCameraSensor_optional;
      typedef ::xsd::cxx::tree::traits< ChargeCoupledDeviceCameraSensor_type, wchar_t > ChargeCoupledDeviceCameraSensor_traits;

      const ChargeCoupledDeviceCameraSensor_optional&
      ChargeCoupledDeviceCameraSensor () const;

      ChargeCoupledDeviceCameraSensor_optional&
      ChargeCoupledDeviceCameraSensor ();

      void
      ChargeCoupledDeviceCameraSensor (const ChargeCoupledDeviceCameraSensor_type& x);

      void
      ChargeCoupledDeviceCameraSensor (const ChargeCoupledDeviceCameraSensor_optional& x);

      void
      ChargeCoupledDeviceCameraSensor (::std::unique_ptr< ChargeCoupledDeviceCameraSensor_type > p);

      // MinFocusDistance
      //
      typedef ::xsd::qif30::LinearValueType MinFocusDistance_type;
      typedef ::xsd::cxx::tree::optional< MinFocusDistance_type > MinFocusDistance_optional;
      typedef ::xsd::cxx::tree::traits< MinFocusDistance_type, wchar_t > MinFocusDistance_traits;

      const MinFocusDistance_optional&
      MinFocusDistance () const;

      MinFocusDistance_optional&
      MinFocusDistance ();

      void
      MinFocusDistance (const MinFocusDistance_type& x);

      void
      MinFocusDistance (const MinFocusDistance_optional& x);

      void
      MinFocusDistance (::std::unique_ptr< MinFocusDistance_type > p);

      // EffectiveDiameterOfObjective
      //
      typedef ::xsd::qif30::LinearValueType EffectiveDiameterOfObjective_type;
      typedef ::xsd::cxx::tree::optional< EffectiveDiameterOfObjective_type > EffectiveDiameterOfObjective_optional;
      typedef ::xsd::cxx::tree::traits< EffectiveDiameterOfObjective_type, wchar_t > EffectiveDiameterOfObjective_traits;

      const EffectiveDiameterOfObjective_optional&
      EffectiveDiameterOfObjective () const;

      EffectiveDiameterOfObjective_optional&
      EffectiveDiameterOfObjective ();

      void
      EffectiveDiameterOfObjective (const EffectiveDiameterOfObjective_type& x);

      void
      EffectiveDiameterOfObjective (const EffectiveDiameterOfObjective_optional& x);

      void
      EffectiveDiameterOfObjective (::std::unique_ptr< EffectiveDiameterOfObjective_type > p);

      // StadiaBaseConstant
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType StadiaBaseConstant_type;
      typedef ::xsd::cxx::tree::optional< StadiaBaseConstant_type > StadiaBaseConstant_optional;
      typedef ::xsd::cxx::tree::traits< StadiaBaseConstant_type, wchar_t > StadiaBaseConstant_traits;

      const StadiaBaseConstant_optional&
      StadiaBaseConstant () const;

      StadiaBaseConstant_optional&
      StadiaBaseConstant ();

      void
      StadiaBaseConstant (const StadiaBaseConstant_type& x);

      void
      StadiaBaseConstant (const StadiaBaseConstant_optional& x);

      void
      StadiaBaseConstant (::std::unique_ptr< StadiaBaseConstant_type > p);

      // StadiaRateConstant
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType StadiaRateConstant_type;
      typedef ::xsd::cxx::tree::optional< StadiaRateConstant_type > StadiaRateConstant_optional;
      typedef ::xsd::cxx::tree::traits< StadiaRateConstant_type, wchar_t > StadiaRateConstant_traits;

      const StadiaRateConstant_optional&
      StadiaRateConstant () const;

      StadiaRateConstant_optional&
      StadiaRateConstant ();

      void
      StadiaRateConstant (const StadiaRateConstant_type& x);

      void
      StadiaRateConstant (const StadiaRateConstant_optional& x);

      void
      StadiaRateConstant (::std::unique_ptr< StadiaRateConstant_type > p);

      // MinPowerSupplyVoltage
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType MinPowerSupplyVoltage_type;
      typedef ::xsd::cxx::tree::optional< MinPowerSupplyVoltage_type > MinPowerSupplyVoltage_optional;
      typedef ::xsd::cxx::tree::traits< MinPowerSupplyVoltage_type, wchar_t > MinPowerSupplyVoltage_traits;

      const MinPowerSupplyVoltage_optional&
      MinPowerSupplyVoltage () const;

      MinPowerSupplyVoltage_optional&
      MinPowerSupplyVoltage ();

      void
      MinPowerSupplyVoltage (const MinPowerSupplyVoltage_type& x);

      void
      MinPowerSupplyVoltage (const MinPowerSupplyVoltage_optional& x);

      void
      MinPowerSupplyVoltage (::std::unique_ptr< MinPowerSupplyVoltage_type > p);

      // MaxPowerSupplyVoltage
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType MaxPowerSupplyVoltage_type;
      typedef ::xsd::cxx::tree::optional< MaxPowerSupplyVoltage_type > MaxPowerSupplyVoltage_optional;
      typedef ::xsd::cxx::tree::traits< MaxPowerSupplyVoltage_type, wchar_t > MaxPowerSupplyVoltage_traits;

      const MaxPowerSupplyVoltage_optional&
      MaxPowerSupplyVoltage () const;

      MaxPowerSupplyVoltage_optional&
      MaxPowerSupplyVoltage ();

      void
      MaxPowerSupplyVoltage (const MaxPowerSupplyVoltage_type& x);

      void
      MaxPowerSupplyVoltage (const MaxPowerSupplyVoltage_optional& x);

      void
      MaxPowerSupplyVoltage (::std::unique_ptr< MaxPowerSupplyVoltage_type > p);

      // Laser
      //
      typedef ::xsd::qif30::LaserType Laser_type;
      typedef ::xsd::cxx::tree::optional< Laser_type > Laser_optional;
      typedef ::xsd::cxx::tree::traits< Laser_type, wchar_t > Laser_traits;

      const Laser_optional&
      Laser () const;

      Laser_optional&
      Laser ();

      void
      Laser (const Laser_type& x);

      void
      Laser (const Laser_optional& x);

      void
      Laser (::std::unique_ptr< Laser_type > p);

      // Constructors.
      //
      TheodoliteType ();

      TheodoliteType (const Name_type&,
                      const id_type&);

      TheodoliteType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      TheodoliteType (const TheodoliteType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual TheodoliteType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TheodoliteType&
      operator= (const TheodoliteType& x);

      virtual 
      ~TheodoliteType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      LongitudinalTrackingSpeed_optional LongitudinalTrackingSpeed_;
      LateralTrackingSpeed_optional LateralTrackingSpeed_;
      Magnification_optional Magnification_;
      FieldOfViewDiameter_optional FieldOfViewDiameter_;
      ApertureSize_optional ApertureSize_;
      MaxFocusDistance_optional MaxFocusDistance_;
      AngularAccuracy_optional AngularAccuracy_;
      MaxTiltCompensation_optional MaxTiltCompensation_;
      ChargeCoupledDeviceCameraSensor_optional ChargeCoupledDeviceCameraSensor_;
      MinFocusDistance_optional MinFocusDistance_;
      EffectiveDiameterOfObjective_optional EffectiveDiameterOfObjective_;
      StadiaBaseConstant_optional StadiaBaseConstant_;
      StadiaRateConstant_optional StadiaRateConstant_;
      MinPowerSupplyVoltage_optional MinPowerSupplyVoltage_;
      MaxPowerSupplyVoltage_optional MaxPowerSupplyVoltage_;
      Laser_optional Laser_;
    };

    class QIF30_SYMBOL_DECL UniversalLengthMeasuringType: public ::xsd::qif30::UniversalDeviceType
    {
      public:
      // MinMeasuringDistance
      //
      typedef ::xsd::qif30::LinearValueType MinMeasuringDistance_type;
      typedef ::xsd::cxx::tree::optional< MinMeasuringDistance_type > MinMeasuringDistance_optional;
      typedef ::xsd::cxx::tree::traits< MinMeasuringDistance_type, wchar_t > MinMeasuringDistance_traits;

      const MinMeasuringDistance_optional&
      MinMeasuringDistance () const;

      MinMeasuringDistance_optional&
      MinMeasuringDistance ();

      void
      MinMeasuringDistance (const MinMeasuringDistance_type& x);

      void
      MinMeasuringDistance (const MinMeasuringDistance_optional& x);

      void
      MinMeasuringDistance (::std::unique_ptr< MinMeasuringDistance_type > p);

      // MaxMeasuringDistance
      //
      typedef ::xsd::qif30::LinearValueType MaxMeasuringDistance_type;
      typedef ::xsd::cxx::tree::optional< MaxMeasuringDistance_type > MaxMeasuringDistance_optional;
      typedef ::xsd::cxx::tree::traits< MaxMeasuringDistance_type, wchar_t > MaxMeasuringDistance_traits;

      const MaxMeasuringDistance_optional&
      MaxMeasuringDistance () const;

      MaxMeasuringDistance_optional&
      MaxMeasuringDistance ();

      void
      MaxMeasuringDistance (const MaxMeasuringDistance_type& x);

      void
      MaxMeasuringDistance (const MaxMeasuringDistance_optional& x);

      void
      MaxMeasuringDistance (::std::unique_ptr< MaxMeasuringDistance_type > p);

      // MeasuringForce
      //
      typedef ::xsd::qif30::ForceValueType MeasuringForce_type;
      typedef ::xsd::cxx::tree::optional< MeasuringForce_type > MeasuringForce_optional;
      typedef ::xsd::cxx::tree::traits< MeasuringForce_type, wchar_t > MeasuringForce_traits;

      const MeasuringForce_optional&
      MeasuringForce () const;

      MeasuringForce_optional&
      MeasuringForce ();

      void
      MeasuringForce (const MeasuringForce_type& x);

      void
      MeasuringForce (const MeasuringForce_optional& x);

      void
      MeasuringForce (::std::unique_ptr< MeasuringForce_type > p);

      // Accuracy
      //
      typedef ::xsd::qif30::LinearErrorType Accuracy_type;
      typedef ::xsd::cxx::tree::optional< Accuracy_type > Accuracy_optional;
      typedef ::xsd::cxx::tree::traits< Accuracy_type, wchar_t > Accuracy_traits;

      const Accuracy_optional&
      Accuracy () const;

      Accuracy_optional&
      Accuracy ();

      void
      Accuracy (const Accuracy_type& x);

      void
      Accuracy (const Accuracy_optional& x);

      void
      Accuracy (::std::unique_ptr< Accuracy_type > p);

      // Repeatability
      //
      typedef ::xsd::qif30::LinearValueType Repeatability_type;
      typedef ::xsd::cxx::tree::optional< Repeatability_type > Repeatability_optional;
      typedef ::xsd::cxx::tree::traits< Repeatability_type, wchar_t > Repeatability_traits;

      const Repeatability_optional&
      Repeatability () const;

      Repeatability_optional&
      Repeatability ();

      void
      Repeatability (const Repeatability_type& x);

      void
      Repeatability (const Repeatability_optional& x);

      void
      Repeatability (::std::unique_ptr< Repeatability_type > p);

      // ToolIds
      //
      typedef ::xsd::qif30::ArrayReferenceType ToolIds_type;
      typedef ::xsd::cxx::tree::optional< ToolIds_type > ToolIds_optional;
      typedef ::xsd::cxx::tree::traits< ToolIds_type, wchar_t > ToolIds_traits;

      const ToolIds_optional&
      ToolIds () const;

      ToolIds_optional&
      ToolIds ();

      void
      ToolIds (const ToolIds_type& x);

      void
      ToolIds (const ToolIds_optional& x);

      void
      ToolIds (::std::unique_ptr< ToolIds_type > p);

      // MaxWorkpieceWeight
      //
      typedef ::xsd::qif30::MassValueType MaxWorkpieceWeight_type;
      typedef ::xsd::cxx::tree::optional< MaxWorkpieceWeight_type > MaxWorkpieceWeight_optional;
      typedef ::xsd::cxx::tree::traits< MaxWorkpieceWeight_type, wchar_t > MaxWorkpieceWeight_traits;

      const MaxWorkpieceWeight_optional&
      MaxWorkpieceWeight () const;

      MaxWorkpieceWeight_optional&
      MaxWorkpieceWeight ();

      void
      MaxWorkpieceWeight (const MaxWorkpieceWeight_type& x);

      void
      MaxWorkpieceWeight (const MaxWorkpieceWeight_optional& x);

      void
      MaxWorkpieceWeight (::std::unique_ptr< MaxWorkpieceWeight_type > p);

      // Constructors.
      //
      UniversalLengthMeasuringType ();

      UniversalLengthMeasuringType (const Name_type&,
                                    const id_type&);

      UniversalLengthMeasuringType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      UniversalLengthMeasuringType (const UniversalLengthMeasuringType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual UniversalLengthMeasuringType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UniversalLengthMeasuringType&
      operator= (const UniversalLengthMeasuringType& x);

      virtual 
      ~UniversalLengthMeasuringType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MinMeasuringDistance_optional MinMeasuringDistance_;
      MaxMeasuringDistance_optional MaxMeasuringDistance_;
      MeasuringForce_optional MeasuringForce_;
      Accuracy_optional Accuracy_;
      Repeatability_optional Repeatability_;
      ToolIds_optional ToolIds_;
      MaxWorkpieceWeight_optional MaxWorkpieceWeight_;
    };

    class QIF30_SYMBOL_DECL ComputedTomographyType: public ::xsd::qif30::UniversalDeviceType
    {
      public:
      // SourceDescription
      //
      typedef ::xml_schema::string SourceDescription_type;
      typedef ::xsd::cxx::tree::optional< SourceDescription_type > SourceDescription_optional;
      typedef ::xsd::cxx::tree::traits< SourceDescription_type, wchar_t > SourceDescription_traits;

      const SourceDescription_optional&
      SourceDescription () const;

      SourceDescription_optional&
      SourceDescription ();

      void
      SourceDescription (const SourceDescription_type& x);

      void
      SourceDescription (const SourceDescription_optional& x);

      void
      SourceDescription (::std::unique_ptr< SourceDescription_type > p);

      // SamplePenetratingMaterial
      //
      typedef ::xml_schema::string SamplePenetratingMaterial_type;
      typedef ::xsd::cxx::tree::optional< SamplePenetratingMaterial_type > SamplePenetratingMaterial_optional;
      typedef ::xsd::cxx::tree::traits< SamplePenetratingMaterial_type, wchar_t > SamplePenetratingMaterial_traits;

      const SamplePenetratingMaterial_optional&
      SamplePenetratingMaterial () const;

      SamplePenetratingMaterial_optional&
      SamplePenetratingMaterial ();

      void
      SamplePenetratingMaterial (const SamplePenetratingMaterial_type& x);

      void
      SamplePenetratingMaterial (const SamplePenetratingMaterial_optional& x);

      void
      SamplePenetratingMaterial (::std::unique_ptr< SamplePenetratingMaterial_type > p);

      // SamplePenetratingMaterialLength
      //
      typedef ::xsd::qif30::LinearValueType SamplePenetratingMaterialLength_type;
      typedef ::xsd::cxx::tree::optional< SamplePenetratingMaterialLength_type > SamplePenetratingMaterialLength_optional;
      typedef ::xsd::cxx::tree::traits< SamplePenetratingMaterialLength_type, wchar_t > SamplePenetratingMaterialLength_traits;

      const SamplePenetratingMaterialLength_optional&
      SamplePenetratingMaterialLength () const;

      SamplePenetratingMaterialLength_optional&
      SamplePenetratingMaterialLength ();

      void
      SamplePenetratingMaterialLength (const SamplePenetratingMaterialLength_type& x);

      void
      SamplePenetratingMaterialLength (const SamplePenetratingMaterialLength_optional& x);

      void
      SamplePenetratingMaterialLength (::std::unique_ptr< SamplePenetratingMaterialLength_type > p);

      // FocalSpotSize
      //
      typedef ::xsd::qif30::LinearValueType FocalSpotSize_type;
      typedef ::xsd::cxx::tree::optional< FocalSpotSize_type > FocalSpotSize_optional;
      typedef ::xsd::cxx::tree::traits< FocalSpotSize_type, wchar_t > FocalSpotSize_traits;

      const FocalSpotSize_optional&
      FocalSpotSize () const;

      FocalSpotSize_optional&
      FocalSpotSize ();

      void
      FocalSpotSize (const FocalSpotSize_type& x);

      void
      FocalSpotSize (const FocalSpotSize_optional& x);

      void
      FocalSpotSize (::std::unique_ptr< FocalSpotSize_type > p);

      // MaxWorkpieceMass
      //
      typedef ::xsd::qif30::MassValueType MaxWorkpieceMass_type;
      typedef ::xsd::cxx::tree::optional< MaxWorkpieceMass_type > MaxWorkpieceMass_optional;
      typedef ::xsd::cxx::tree::traits< MaxWorkpieceMass_type, wchar_t > MaxWorkpieceMass_traits;

      const MaxWorkpieceMass_optional&
      MaxWorkpieceMass () const;

      MaxWorkpieceMass_optional&
      MaxWorkpieceMass ();

      void
      MaxWorkpieceMass (const MaxWorkpieceMass_type& x);

      void
      MaxWorkpieceMass (const MaxWorkpieceMass_optional& x);

      void
      MaxWorkpieceMass (::std::unique_ptr< MaxWorkpieceMass_type > p);

      // SafetyLevel
      //
      typedef ::xml_schema::string SafetyLevel_type;
      typedef ::xsd::cxx::tree::optional< SafetyLevel_type > SafetyLevel_optional;
      typedef ::xsd::cxx::tree::traits< SafetyLevel_type, wchar_t > SafetyLevel_traits;

      const SafetyLevel_optional&
      SafetyLevel () const;

      SafetyLevel_optional&
      SafetyLevel ();

      void
      SafetyLevel (const SafetyLevel_type& x);

      void
      SafetyLevel (const SafetyLevel_optional& x);

      void
      SafetyLevel (::std::unique_ptr< SafetyLevel_type > p);

      // CabinetDimensions
      //
      typedef ::xsd::qif30::CartesianWorkingVolumeType CabinetDimensions_type;
      typedef ::xsd::cxx::tree::optional< CabinetDimensions_type > CabinetDimensions_optional;
      typedef ::xsd::cxx::tree::traits< CabinetDimensions_type, wchar_t > CabinetDimensions_traits;

      const CabinetDimensions_optional&
      CabinetDimensions () const;

      CabinetDimensions_optional&
      CabinetDimensions ();

      void
      CabinetDimensions (const CabinetDimensions_type& x);

      void
      CabinetDimensions (const CabinetDimensions_optional& x);

      void
      CabinetDimensions (::std::unique_ptr< CabinetDimensions_type > p);

      // MaxPower
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType MaxPower_type;
      typedef ::xsd::cxx::tree::optional< MaxPower_type > MaxPower_optional;
      typedef ::xsd::cxx::tree::traits< MaxPower_type, wchar_t > MaxPower_traits;

      const MaxPower_optional&
      MaxPower () const;

      MaxPower_optional&
      MaxPower ();

      void
      MaxPower (const MaxPower_type& x);

      void
      MaxPower (const MaxPower_optional& x);

      void
      MaxPower (::std::unique_ptr< MaxPower_type > p);

      // DetectorBitNumber
      //
      typedef ::xml_schema::decimal DetectorBitNumber_type;
      typedef ::xsd::cxx::tree::optional< DetectorBitNumber_type > DetectorBitNumber_optional;
      typedef ::xsd::cxx::tree::traits< DetectorBitNumber_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > DetectorBitNumber_traits;

      const DetectorBitNumber_optional&
      DetectorBitNumber () const;

      DetectorBitNumber_optional&
      DetectorBitNumber ();

      void
      DetectorBitNumber (const DetectorBitNumber_type& x);

      void
      DetectorBitNumber (const DetectorBitNumber_optional& x);

      // DetectorPixelSize
      //
      typedef ::xsd::qif30::LinearValueType DetectorPixelSize_type;
      typedef ::xsd::cxx::tree::optional< DetectorPixelSize_type > DetectorPixelSize_optional;
      typedef ::xsd::cxx::tree::traits< DetectorPixelSize_type, wchar_t > DetectorPixelSize_traits;

      const DetectorPixelSize_optional&
      DetectorPixelSize () const;

      DetectorPixelSize_optional&
      DetectorPixelSize ();

      void
      DetectorPixelSize (const DetectorPixelSize_type& x);

      void
      DetectorPixelSize (const DetectorPixelSize_optional& x);

      void
      DetectorPixelSize (::std::unique_ptr< DetectorPixelSize_type > p);

      // ActivePixelsNumber
      //
      typedef ::xsd::qif30::FunctionDiscreteType ActivePixelsNumber_type;
      typedef ::xsd::cxx::tree::optional< ActivePixelsNumber_type > ActivePixelsNumber_optional;
      typedef ::xsd::cxx::tree::traits< ActivePixelsNumber_type, wchar_t > ActivePixelsNumber_traits;

      const ActivePixelsNumber_optional&
      ActivePixelsNumber () const;

      ActivePixelsNumber_optional&
      ActivePixelsNumber ();

      void
      ActivePixelsNumber (const ActivePixelsNumber_type& x);

      void
      ActivePixelsNumber (const ActivePixelsNumber_optional& x);

      void
      ActivePixelsNumber (::std::unique_ptr< ActivePixelsNumber_type > p);

      // MaxKV
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType MaxKV_type;
      typedef ::xsd::cxx::tree::optional< MaxKV_type > MaxKV_optional;
      typedef ::xsd::cxx::tree::traits< MaxKV_type, wchar_t > MaxKV_traits;

      const MaxKV_optional&
      MaxKV () const;

      MaxKV_optional&
      MaxKV ();

      void
      MaxKV (const MaxKV_type& x);

      void
      MaxKV (const MaxKV_optional& x);

      void
      MaxKV (::std::unique_ptr< MaxKV_type > p);

      // MinOperatingCurrent
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType MinOperatingCurrent_type;
      typedef ::xsd::cxx::tree::optional< MinOperatingCurrent_type > MinOperatingCurrent_optional;
      typedef ::xsd::cxx::tree::traits< MinOperatingCurrent_type, wchar_t > MinOperatingCurrent_traits;

      const MinOperatingCurrent_optional&
      MinOperatingCurrent () const;

      MinOperatingCurrent_optional&
      MinOperatingCurrent ();

      void
      MinOperatingCurrent (const MinOperatingCurrent_type& x);

      void
      MinOperatingCurrent (const MinOperatingCurrent_optional& x);

      void
      MinOperatingCurrent (::std::unique_ptr< MinOperatingCurrent_type > p);

      // MaxOperatingCurrent
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType MaxOperatingCurrent_type;
      typedef ::xsd::cxx::tree::optional< MaxOperatingCurrent_type > MaxOperatingCurrent_optional;
      typedef ::xsd::cxx::tree::traits< MaxOperatingCurrent_type, wchar_t > MaxOperatingCurrent_traits;

      const MaxOperatingCurrent_optional&
      MaxOperatingCurrent () const;

      MaxOperatingCurrent_optional&
      MaxOperatingCurrent ();

      void
      MaxOperatingCurrent (const MaxOperatingCurrent_type& x);

      void
      MaxOperatingCurrent (const MaxOperatingCurrent_optional& x);

      void
      MaxOperatingCurrent (::std::unique_ptr< MaxOperatingCurrent_type > p);

      // MaxFramePerSecond
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType MaxFramePerSecond_type;
      typedef ::xsd::cxx::tree::optional< MaxFramePerSecond_type > MaxFramePerSecond_optional;
      typedef ::xsd::cxx::tree::traits< MaxFramePerSecond_type, wchar_t > MaxFramePerSecond_traits;

      const MaxFramePerSecond_optional&
      MaxFramePerSecond () const;

      MaxFramePerSecond_optional&
      MaxFramePerSecond ();

      void
      MaxFramePerSecond (const MaxFramePerSecond_type& x);

      void
      MaxFramePerSecond (const MaxFramePerSecond_optional& x);

      void
      MaxFramePerSecond (::std::unique_ptr< MaxFramePerSecond_type > p);

      // RotaryTable
      //
      typedef ::xsd::qif30::RotaryTableType RotaryTable_type;
      typedef ::xsd::cxx::tree::optional< RotaryTable_type > RotaryTable_optional;
      typedef ::xsd::cxx::tree::traits< RotaryTable_type, wchar_t > RotaryTable_traits;

      const RotaryTable_optional&
      RotaryTable () const;

      RotaryTable_optional&
      RotaryTable ();

      void
      RotaryTable (const RotaryTable_type& x);

      void
      RotaryTable (const RotaryTable_optional& x);

      void
      RotaryTable (::std::unique_ptr< RotaryTable_type > p);

      // ToolIds
      //
      typedef ::xsd::qif30::ArrayReferenceType ToolIds_type;
      typedef ::xsd::cxx::tree::optional< ToolIds_type > ToolIds_optional;
      typedef ::xsd::cxx::tree::traits< ToolIds_type, wchar_t > ToolIds_traits;

      const ToolIds_optional&
      ToolIds () const;

      ToolIds_optional&
      ToolIds ();

      void
      ToolIds (const ToolIds_type& x);

      void
      ToolIds (const ToolIds_optional& x);

      void
      ToolIds (::std::unique_ptr< ToolIds_type > p);

      // Constructors.
      //
      ComputedTomographyType ();

      ComputedTomographyType (const Name_type&,
                              const id_type&);

      ComputedTomographyType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      ComputedTomographyType (const ComputedTomographyType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual ComputedTomographyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ComputedTomographyType&
      operator= (const ComputedTomographyType& x);

      virtual 
      ~ComputedTomographyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      SourceDescription_optional SourceDescription_;
      SamplePenetratingMaterial_optional SamplePenetratingMaterial_;
      SamplePenetratingMaterialLength_optional SamplePenetratingMaterialLength_;
      FocalSpotSize_optional FocalSpotSize_;
      MaxWorkpieceMass_optional MaxWorkpieceMass_;
      SafetyLevel_optional SafetyLevel_;
      CabinetDimensions_optional CabinetDimensions_;
      MaxPower_optional MaxPower_;
      DetectorBitNumber_optional DetectorBitNumber_;
      DetectorPixelSize_optional DetectorPixelSize_;
      ActivePixelsNumber_optional ActivePixelsNumber_;
      MaxKV_optional MaxKV_;
      MinOperatingCurrent_optional MinOperatingCurrent_;
      MaxOperatingCurrent_optional MaxOperatingCurrent_;
      MaxFramePerSecond_optional MaxFramePerSecond_;
      RotaryTable_optional RotaryTable_;
      ToolIds_optional ToolIds_;
    };

    class QIF30_SYMBOL_DECL OpticalComparatorType: public ::xsd::qif30::UniversalDeviceType
    {
      public:
      // Magnification
      //
      typedef ::xml_schema::decimal Magnification_type;
      typedef ::xsd::cxx::tree::optional< Magnification_type > Magnification_optional;
      typedef ::xsd::cxx::tree::traits< Magnification_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > Magnification_traits;

      const Magnification_optional&
      Magnification () const;

      Magnification_optional&
      Magnification ();

      void
      Magnification (const Magnification_type& x);

      void
      Magnification (const Magnification_optional& x);

      // EffectiveScreenDiameter
      //
      typedef ::xsd::qif30::LinearValueType EffectiveScreenDiameter_type;
      typedef ::xsd::cxx::tree::optional< EffectiveScreenDiameter_type > EffectiveScreenDiameter_optional;
      typedef ::xsd::cxx::tree::traits< EffectiveScreenDiameter_type, wchar_t > EffectiveScreenDiameter_traits;

      const EffectiveScreenDiameter_optional&
      EffectiveScreenDiameter () const;

      EffectiveScreenDiameter_optional&
      EffectiveScreenDiameter ();

      void
      EffectiveScreenDiameter (const EffectiveScreenDiameter_type& x);

      void
      EffectiveScreenDiameter (const EffectiveScreenDiameter_optional& x);

      void
      EffectiveScreenDiameter (::std::unique_ptr< EffectiveScreenDiameter_type > p);

      // ScreenMaterial
      //
      typedef ::xml_schema::string ScreenMaterial_type;
      typedef ::xsd::cxx::tree::optional< ScreenMaterial_type > ScreenMaterial_optional;
      typedef ::xsd::cxx::tree::traits< ScreenMaterial_type, wchar_t > ScreenMaterial_traits;

      const ScreenMaterial_optional&
      ScreenMaterial () const;

      ScreenMaterial_optional&
      ScreenMaterial ();

      void
      ScreenMaterial (const ScreenMaterial_type& x);

      void
      ScreenMaterial (const ScreenMaterial_optional& x);

      void
      ScreenMaterial (::std::unique_ptr< ScreenMaterial_type > p);

      // AngleResolution
      //
      typedef ::xsd::qif30::AngularValueType AngleResolution_type;
      typedef ::xsd::cxx::tree::optional< AngleResolution_type > AngleResolution_optional;
      typedef ::xsd::cxx::tree::traits< AngleResolution_type, wchar_t > AngleResolution_traits;

      const AngleResolution_optional&
      AngleResolution () const;

      AngleResolution_optional&
      AngleResolution ();

      void
      AngleResolution (const AngleResolution_type& x);

      void
      AngleResolution (const AngleResolution_optional& x);

      void
      AngleResolution (::std::unique_ptr< AngleResolution_type > p);

      // SurfaceIlluminationLightSource
      //
      typedef ::xml_schema::string SurfaceIlluminationLightSource_type;
      typedef ::xsd::cxx::tree::optional< SurfaceIlluminationLightSource_type > SurfaceIlluminationLightSource_optional;
      typedef ::xsd::cxx::tree::traits< SurfaceIlluminationLightSource_type, wchar_t > SurfaceIlluminationLightSource_traits;

      const SurfaceIlluminationLightSource_optional&
      SurfaceIlluminationLightSource () const;

      SurfaceIlluminationLightSource_optional&
      SurfaceIlluminationLightSource ();

      void
      SurfaceIlluminationLightSource (const SurfaceIlluminationLightSource_type& x);

      void
      SurfaceIlluminationLightSource (const SurfaceIlluminationLightSource_optional& x);

      void
      SurfaceIlluminationLightSource (::std::unique_ptr< SurfaceIlluminationLightSource_type > p);

      // ContourIlluminationLightSource
      //
      typedef ::xml_schema::string ContourIlluminationLightSource_type;
      typedef ::xsd::cxx::tree::optional< ContourIlluminationLightSource_type > ContourIlluminationLightSource_optional;
      typedef ::xsd::cxx::tree::traits< ContourIlluminationLightSource_type, wchar_t > ContourIlluminationLightSource_traits;

      const ContourIlluminationLightSource_optional&
      ContourIlluminationLightSource () const;

      ContourIlluminationLightSource_optional&
      ContourIlluminationLightSource ();

      void
      ContourIlluminationLightSource (const ContourIlluminationLightSource_type& x);

      void
      ContourIlluminationLightSource (const ContourIlluminationLightSource_optional& x);

      void
      ContourIlluminationLightSource (::std::unique_ptr< ContourIlluminationLightSource_type > p);

      // MaxWorkpieceHeight
      //
      typedef ::xsd::qif30::LinearValueType MaxWorkpieceHeight_type;
      typedef ::xsd::cxx::tree::optional< MaxWorkpieceHeight_type > MaxWorkpieceHeight_optional;
      typedef ::xsd::cxx::tree::traits< MaxWorkpieceHeight_type, wchar_t > MaxWorkpieceHeight_traits;

      const MaxWorkpieceHeight_optional&
      MaxWorkpieceHeight () const;

      MaxWorkpieceHeight_optional&
      MaxWorkpieceHeight ();

      void
      MaxWorkpieceHeight (const MaxWorkpieceHeight_type& x);

      void
      MaxWorkpieceHeight (const MaxWorkpieceHeight_optional& x);

      void
      MaxWorkpieceHeight (::std::unique_ptr< MaxWorkpieceHeight_type > p);

      // WorkingDistance
      //
      typedef ::xsd::qif30::LinearValueType WorkingDistance_type;
      typedef ::xsd::cxx::tree::optional< WorkingDistance_type > WorkingDistance_optional;
      typedef ::xsd::cxx::tree::traits< WorkingDistance_type, wchar_t > WorkingDistance_traits;

      const WorkingDistance_optional&
      WorkingDistance () const;

      WorkingDistance_optional&
      WorkingDistance ();

      void
      WorkingDistance (const WorkingDistance_type& x);

      void
      WorkingDistance (const WorkingDistance_optional& x);

      void
      WorkingDistance (::std::unique_ptr< WorkingDistance_type > p);

      // ToolIds
      //
      typedef ::xsd::qif30::ArrayReferenceType ToolIds_type;
      typedef ::xsd::cxx::tree::optional< ToolIds_type > ToolIds_optional;
      typedef ::xsd::cxx::tree::traits< ToolIds_type, wchar_t > ToolIds_traits;

      const ToolIds_optional&
      ToolIds () const;

      ToolIds_optional&
      ToolIds ();

      void
      ToolIds (const ToolIds_type& x);

      void
      ToolIds (const ToolIds_optional& x);

      void
      ToolIds (::std::unique_ptr< ToolIds_type > p);

      // Constructors.
      //
      OpticalComparatorType ();

      OpticalComparatorType (const Name_type&,
                             const id_type&);

      OpticalComparatorType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      OpticalComparatorType (const OpticalComparatorType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual OpticalComparatorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OpticalComparatorType&
      operator= (const OpticalComparatorType& x);

      virtual 
      ~OpticalComparatorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Magnification_optional Magnification_;
      EffectiveScreenDiameter_optional EffectiveScreenDiameter_;
      ScreenMaterial_optional ScreenMaterial_;
      AngleResolution_optional AngleResolution_;
      SurfaceIlluminationLightSource_optional SurfaceIlluminationLightSource_;
      ContourIlluminationLightSource_optional ContourIlluminationLightSource_;
      MaxWorkpieceHeight_optional MaxWorkpieceHeight_;
      WorkingDistance_optional WorkingDistance_;
      ToolIds_optional ToolIds_;
    };

    class QIF30_SYMBOL_DECL MicroscopeType: public ::xsd::qif30::UniversalDeviceType
    {
      public:
      // IlluminationUnit
      //
      typedef ::xml_schema::string IlluminationUnit_type;
      typedef ::xsd::cxx::tree::optional< IlluminationUnit_type > IlluminationUnit_optional;
      typedef ::xsd::cxx::tree::traits< IlluminationUnit_type, wchar_t > IlluminationUnit_traits;

      const IlluminationUnit_optional&
      IlluminationUnit () const;

      IlluminationUnit_optional&
      IlluminationUnit ();

      void
      IlluminationUnit (const IlluminationUnit_type& x);

      void
      IlluminationUnit (const IlluminationUnit_optional& x);

      void
      IlluminationUnit (::std::unique_ptr< IlluminationUnit_type > p);

      // TotalMagnification
      //
      typedef ::xml_schema::decimal TotalMagnification_type;
      typedef ::xsd::cxx::tree::optional< TotalMagnification_type > TotalMagnification_optional;
      typedef ::xsd::cxx::tree::traits< TotalMagnification_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > TotalMagnification_traits;

      const TotalMagnification_optional&
      TotalMagnification () const;

      TotalMagnification_optional&
      TotalMagnification ();

      void
      TotalMagnification (const TotalMagnification_type& x);

      void
      TotalMagnification (const TotalMagnification_optional& x);

      // EyePieceMagnification
      //
      typedef ::xml_schema::decimal EyePieceMagnification_type;
      typedef ::xsd::cxx::tree::optional< EyePieceMagnification_type > EyePieceMagnification_optional;
      typedef ::xsd::cxx::tree::traits< EyePieceMagnification_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > EyePieceMagnification_traits;

      const EyePieceMagnification_optional&
      EyePieceMagnification () const;

      EyePieceMagnification_optional&
      EyePieceMagnification ();

      void
      EyePieceMagnification (const EyePieceMagnification_type& x);

      void
      EyePieceMagnification (const EyePieceMagnification_optional& x);

      // ObjectiveMagnification
      //
      typedef ::xml_schema::decimal ObjectiveMagnification_type;
      typedef ::xsd::cxx::tree::optional< ObjectiveMagnification_type > ObjectiveMagnification_optional;
      typedef ::xsd::cxx::tree::traits< ObjectiveMagnification_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > ObjectiveMagnification_traits;

      const ObjectiveMagnification_optional&
      ObjectiveMagnification () const;

      ObjectiveMagnification_optional&
      ObjectiveMagnification ();

      void
      ObjectiveMagnification (const ObjectiveMagnification_type& x);

      void
      ObjectiveMagnification (const ObjectiveMagnification_optional& x);

      // MaxWorkpieceHeight
      //
      typedef ::xsd::qif30::LinearValueType MaxWorkpieceHeight_type;
      typedef ::xsd::cxx::tree::optional< MaxWorkpieceHeight_type > MaxWorkpieceHeight_optional;
      typedef ::xsd::cxx::tree::traits< MaxWorkpieceHeight_type, wchar_t > MaxWorkpieceHeight_traits;

      const MaxWorkpieceHeight_optional&
      MaxWorkpieceHeight () const;

      MaxWorkpieceHeight_optional&
      MaxWorkpieceHeight ();

      void
      MaxWorkpieceHeight (const MaxWorkpieceHeight_type& x);

      void
      MaxWorkpieceHeight (const MaxWorkpieceHeight_optional& x);

      void
      MaxWorkpieceHeight (::std::unique_ptr< MaxWorkpieceHeight_type > p);

      // MaxWorkpieceWeight
      //
      typedef ::xsd::qif30::MassValueType MaxWorkpieceWeight_type;
      typedef ::xsd::cxx::tree::optional< MaxWorkpieceWeight_type > MaxWorkpieceWeight_optional;
      typedef ::xsd::cxx::tree::traits< MaxWorkpieceWeight_type, wchar_t > MaxWorkpieceWeight_traits;

      const MaxWorkpieceWeight_optional&
      MaxWorkpieceWeight () const;

      MaxWorkpieceWeight_optional&
      MaxWorkpieceWeight ();

      void
      MaxWorkpieceWeight (const MaxWorkpieceWeight_type& x);

      void
      MaxWorkpieceWeight (const MaxWorkpieceWeight_optional& x);

      void
      MaxWorkpieceWeight (::std::unique_ptr< MaxWorkpieceWeight_type > p);

      // Accuracy
      //
      typedef ::xsd::qif30::LinearErrorType Accuracy_type;
      typedef ::xsd::cxx::tree::optional< Accuracy_type > Accuracy_optional;
      typedef ::xsd::cxx::tree::traits< Accuracy_type, wchar_t > Accuracy_traits;

      const Accuracy_optional&
      Accuracy () const;

      Accuracy_optional&
      Accuracy ();

      void
      Accuracy (const Accuracy_type& x);

      void
      Accuracy (const Accuracy_optional& x);

      void
      Accuracy (::std::unique_ptr< Accuracy_type > p);

      // StageSwivelingAngle
      //
      typedef ::xsd::qif30::AngularValueType StageSwivelingAngle_type;
      typedef ::xsd::cxx::tree::optional< StageSwivelingAngle_type > StageSwivelingAngle_optional;
      typedef ::xsd::cxx::tree::traits< StageSwivelingAngle_type, wchar_t > StageSwivelingAngle_traits;

      const StageSwivelingAngle_optional&
      StageSwivelingAngle () const;

      StageSwivelingAngle_optional&
      StageSwivelingAngle ();

      void
      StageSwivelingAngle (const StageSwivelingAngle_type& x);

      void
      StageSwivelingAngle (const StageSwivelingAngle_optional& x);

      void
      StageSwivelingAngle (::std::unique_ptr< StageSwivelingAngle_type > p);

      // ToolIds
      //
      typedef ::xsd::qif30::ArrayReferenceType ToolIds_type;
      typedef ::xsd::cxx::tree::optional< ToolIds_type > ToolIds_optional;
      typedef ::xsd::cxx::tree::traits< ToolIds_type, wchar_t > ToolIds_traits;

      const ToolIds_optional&
      ToolIds () const;

      ToolIds_optional&
      ToolIds ();

      void
      ToolIds (const ToolIds_type& x);

      void
      ToolIds (const ToolIds_optional& x);

      void
      ToolIds (::std::unique_ptr< ToolIds_type > p);

      // Constructors.
      //
      MicroscopeType ();

      MicroscopeType (const Name_type&,
                      const id_type&);

      MicroscopeType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      MicroscopeType (const MicroscopeType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual MicroscopeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MicroscopeType&
      operator= (const MicroscopeType& x);

      virtual 
      ~MicroscopeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      IlluminationUnit_optional IlluminationUnit_;
      TotalMagnification_optional TotalMagnification_;
      EyePieceMagnification_optional EyePieceMagnification_;
      ObjectiveMagnification_optional ObjectiveMagnification_;
      MaxWorkpieceHeight_optional MaxWorkpieceHeight_;
      MaxWorkpieceWeight_optional MaxWorkpieceWeight_;
      Accuracy_optional Accuracy_;
      StageSwivelingAngle_optional StageSwivelingAngle_;
      ToolIds_optional ToolIds_;
    };

    class QIF30_SYMBOL_DECL AutocollimatorType: public ::xsd::qif30::UniversalDeviceType
    {
      public:
      // LightSource
      //
      typedef ::xml_schema::string LightSource_type;
      typedef ::xsd::cxx::tree::optional< LightSource_type > LightSource_optional;
      typedef ::xsd::cxx::tree::traits< LightSource_type, wchar_t > LightSource_traits;

      const LightSource_optional&
      LightSource () const;

      LightSource_optional&
      LightSource ();

      void
      LightSource (const LightSource_type& x);

      void
      LightSource (const LightSource_optional& x);

      void
      LightSource (::std::unique_ptr< LightSource_type > p);

      // MeasuringAccuracy
      //
      typedef ::xsd::qif30::AngularErrorType MeasuringAccuracy_type;
      typedef ::xsd::cxx::tree::optional< MeasuringAccuracy_type > MeasuringAccuracy_optional;
      typedef ::xsd::cxx::tree::traits< MeasuringAccuracy_type, wchar_t > MeasuringAccuracy_traits;

      const MeasuringAccuracy_optional&
      MeasuringAccuracy () const;

      MeasuringAccuracy_optional&
      MeasuringAccuracy ();

      void
      MeasuringAccuracy (const MeasuringAccuracy_type& x);

      void
      MeasuringAccuracy (const MeasuringAccuracy_optional& x);

      void
      MeasuringAccuracy (::std::unique_ptr< MeasuringAccuracy_type > p);

      // Magnification
      //
      typedef ::xml_schema::decimal Magnification_type;
      typedef ::xsd::cxx::tree::optional< Magnification_type > Magnification_optional;
      typedef ::xsd::cxx::tree::traits< Magnification_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > Magnification_traits;

      const Magnification_optional&
      Magnification () const;

      Magnification_optional&
      Magnification ();

      void
      Magnification (const Magnification_type& x);

      void
      Magnification (const Magnification_optional& x);

      // ApertureSize
      //
      typedef ::xsd::qif30::LinearValueType ApertureSize_type;
      typedef ::xsd::cxx::tree::optional< ApertureSize_type > ApertureSize_optional;
      typedef ::xsd::cxx::tree::traits< ApertureSize_type, wchar_t > ApertureSize_traits;

      const ApertureSize_optional&
      ApertureSize () const;

      ApertureSize_optional&
      ApertureSize ();

      void
      ApertureSize (const ApertureSize_type& x);

      void
      ApertureSize (const ApertureSize_optional& x);

      void
      ApertureSize (::std::unique_ptr< ApertureSize_type > p);

      // MinMeasuringDistance
      //
      typedef ::xsd::qif30::AngularValueType MinMeasuringDistance_type;
      typedef ::xsd::cxx::tree::optional< MinMeasuringDistance_type > MinMeasuringDistance_optional;
      typedef ::xsd::cxx::tree::traits< MinMeasuringDistance_type, wchar_t > MinMeasuringDistance_traits;

      const MinMeasuringDistance_optional&
      MinMeasuringDistance () const;

      MinMeasuringDistance_optional&
      MinMeasuringDistance ();

      void
      MinMeasuringDistance (const MinMeasuringDistance_type& x);

      void
      MinMeasuringDistance (const MinMeasuringDistance_optional& x);

      void
      MinMeasuringDistance (::std::unique_ptr< MinMeasuringDistance_type > p);

      // MaxMeasuringDistance
      //
      typedef ::xsd::qif30::AngularValueType MaxMeasuringDistance_type;
      typedef ::xsd::cxx::tree::optional< MaxMeasuringDistance_type > MaxMeasuringDistance_optional;
      typedef ::xsd::cxx::tree::traits< MaxMeasuringDistance_type, wchar_t > MaxMeasuringDistance_traits;

      const MaxMeasuringDistance_optional&
      MaxMeasuringDistance () const;

      MaxMeasuringDistance_optional&
      MaxMeasuringDistance ();

      void
      MaxMeasuringDistance (const MaxMeasuringDistance_type& x);

      void
      MaxMeasuringDistance (const MaxMeasuringDistance_optional& x);

      void
      MaxMeasuringDistance (::std::unique_ptr< MaxMeasuringDistance_type > p);

      // ObjectiveFocalLength
      //
      typedef ::xsd::qif30::LinearValueType ObjectiveFocalLength_type;
      typedef ::xsd::cxx::tree::optional< ObjectiveFocalLength_type > ObjectiveFocalLength_optional;
      typedef ::xsd::cxx::tree::traits< ObjectiveFocalLength_type, wchar_t > ObjectiveFocalLength_traits;

      const ObjectiveFocalLength_optional&
      ObjectiveFocalLength () const;

      ObjectiveFocalLength_optional&
      ObjectiveFocalLength ();

      void
      ObjectiveFocalLength (const ObjectiveFocalLength_type& x);

      void
      ObjectiveFocalLength (const ObjectiveFocalLength_optional& x);

      void
      ObjectiveFocalLength (::std::unique_ptr< ObjectiveFocalLength_type > p);

      // FieldOfView
      //
      typedef ::xsd::qif30::AngularValueType FieldOfView_type;
      typedef ::xsd::cxx::tree::optional< FieldOfView_type > FieldOfView_optional;
      typedef ::xsd::cxx::tree::traits< FieldOfView_type, wchar_t > FieldOfView_traits;

      const FieldOfView_optional&
      FieldOfView () const;

      FieldOfView_optional&
      FieldOfView ();

      void
      FieldOfView (const FieldOfView_type& x);

      void
      FieldOfView (const FieldOfView_optional& x);

      void
      FieldOfView (::std::unique_ptr< FieldOfView_type > p);

      // Constructors.
      //
      AutocollimatorType ();

      AutocollimatorType (const Name_type&,
                          const id_type&);

      AutocollimatorType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      AutocollimatorType (const AutocollimatorType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual AutocollimatorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AutocollimatorType&
      operator= (const AutocollimatorType& x);

      virtual 
      ~AutocollimatorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      LightSource_optional LightSource_;
      MeasuringAccuracy_optional MeasuringAccuracy_;
      Magnification_optional Magnification_;
      ApertureSize_optional ApertureSize_;
      MinMeasuringDistance_optional MinMeasuringDistance_;
      MaxMeasuringDistance_optional MaxMeasuringDistance_;
      ObjectiveFocalLength_optional ObjectiveFocalLength_;
      FieldOfView_optional FieldOfView_;
    };

    class QIF30_SYMBOL_DECL LaserTrackerType: public ::xsd::qif30::UniversalDeviceType
    {
      public:
      // MaximumAngularVelocity
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType MaximumAngularVelocity_type;
      typedef ::xsd::cxx::tree::optional< MaximumAngularVelocity_type > MaximumAngularVelocity_optional;
      typedef ::xsd::cxx::tree::traits< MaximumAngularVelocity_type, wchar_t > MaximumAngularVelocity_traits;

      const MaximumAngularVelocity_optional&
      MaximumAngularVelocity () const;

      MaximumAngularVelocity_optional&
      MaximumAngularVelocity ();

      void
      MaximumAngularVelocity (const MaximumAngularVelocity_type& x);

      void
      MaximumAngularVelocity (const MaximumAngularVelocity_optional& x);

      void
      MaximumAngularVelocity (::std::unique_ptr< MaximumAngularVelocity_type > p);

      // DistanceAccuracy
      //
      typedef ::xsd::qif30::LinearErrorType DistanceAccuracy_type;
      typedef ::xsd::cxx::tree::optional< DistanceAccuracy_type > DistanceAccuracy_optional;
      typedef ::xsd::cxx::tree::traits< DistanceAccuracy_type, wchar_t > DistanceAccuracy_traits;

      const DistanceAccuracy_optional&
      DistanceAccuracy () const;

      DistanceAccuracy_optional&
      DistanceAccuracy ();

      void
      DistanceAccuracy (const DistanceAccuracy_type& x);

      void
      DistanceAccuracy (const DistanceAccuracy_optional& x);

      void
      DistanceAccuracy (::std::unique_ptr< DistanceAccuracy_type > p);

      // AngularAccuracy
      //
      typedef ::xsd::qif30::AngularErrorType AngularAccuracy_type;
      typedef ::xsd::cxx::tree::optional< AngularAccuracy_type > AngularAccuracy_optional;
      typedef ::xsd::cxx::tree::traits< AngularAccuracy_type, wchar_t > AngularAccuracy_traits;

      const AngularAccuracy_optional&
      AngularAccuracy () const;

      AngularAccuracy_optional&
      AngularAccuracy ();

      void
      AngularAccuracy (const AngularAccuracy_type& x);

      void
      AngularAccuracy (const AngularAccuracy_optional& x);

      void
      AngularAccuracy (::std::unique_ptr< AngularAccuracy_type > p);

      // SamplingRate
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType SamplingRate_type;
      typedef ::xsd::cxx::tree::optional< SamplingRate_type > SamplingRate_optional;
      typedef ::xsd::cxx::tree::traits< SamplingRate_type, wchar_t > SamplingRate_traits;

      const SamplingRate_optional&
      SamplingRate () const;

      SamplingRate_optional&
      SamplingRate ();

      void
      SamplingRate (const SamplingRate_type& x);

      void
      SamplingRate (const SamplingRate_optional& x);

      void
      SamplingRate (::std::unique_ptr< SamplingRate_type > p);

      // TargetMirror
      //
      typedef ::xsd::qif30::TargetMirrorEnumType TargetMirror_type;
      typedef ::xsd::cxx::tree::optional< TargetMirror_type > TargetMirror_optional;
      typedef ::xsd::cxx::tree::traits< TargetMirror_type, wchar_t > TargetMirror_traits;

      const TargetMirror_optional&
      TargetMirror () const;

      TargetMirror_optional&
      TargetMirror ();

      void
      TargetMirror (const TargetMirror_type& x);

      void
      TargetMirror (const TargetMirror_optional& x);

      void
      TargetMirror (::std::unique_ptr< TargetMirror_type > p);

      // HeadMass
      //
      typedef ::xsd::qif30::MassValueType HeadMass_type;
      typedef ::xsd::cxx::tree::optional< HeadMass_type > HeadMass_optional;
      typedef ::xsd::cxx::tree::traits< HeadMass_type, wchar_t > HeadMass_traits;

      const HeadMass_optional&
      HeadMass () const;

      HeadMass_optional&
      HeadMass ();

      void
      HeadMass (const HeadMass_type& x);

      void
      HeadMass (const HeadMass_optional& x);

      void
      HeadMass (::std::unique_ptr< HeadMass_type > p);

      // HeadSize
      //
      typedef ::xsd::qif30::CartesianWorkingVolumeType HeadSize_type;
      typedef ::xsd::cxx::tree::optional< HeadSize_type > HeadSize_optional;
      typedef ::xsd::cxx::tree::traits< HeadSize_type, wchar_t > HeadSize_traits;

      const HeadSize_optional&
      HeadSize () const;

      HeadSize_optional&
      HeadSize ();

      void
      HeadSize (const HeadSize_type& x);

      void
      HeadSize (const HeadSize_optional& x);

      void
      HeadSize (::std::unique_ptr< HeadSize_type > p);

      // MaximumWorkingAmplitude
      //
      typedef ::xsd::qif30::LinearValueType MaximumWorkingAmplitude_type;
      typedef ::xsd::cxx::tree::optional< MaximumWorkingAmplitude_type > MaximumWorkingAmplitude_optional;
      typedef ::xsd::cxx::tree::traits< MaximumWorkingAmplitude_type, wchar_t > MaximumWorkingAmplitude_traits;

      const MaximumWorkingAmplitude_optional&
      MaximumWorkingAmplitude () const;

      MaximumWorkingAmplitude_optional&
      MaximumWorkingAmplitude ();

      void
      MaximumWorkingAmplitude (const MaximumWorkingAmplitude_type& x);

      void
      MaximumWorkingAmplitude (const MaximumWorkingAmplitude_optional& x);

      void
      MaximumWorkingAmplitude (::std::unique_ptr< MaximumWorkingAmplitude_type > p);

      // Laser
      //
      typedef ::xsd::qif30::LaserType Laser_type;
      typedef ::xsd::cxx::tree::optional< Laser_type > Laser_optional;
      typedef ::xsd::cxx::tree::traits< Laser_type, wchar_t > Laser_traits;

      const Laser_optional&
      Laser () const;

      Laser_optional&
      Laser ();

      void
      Laser (const Laser_type& x);

      void
      Laser (const Laser_optional& x);

      void
      Laser (::std::unique_ptr< Laser_type > p);

      // Repeatability
      //
      typedef ::xsd::qif30::LinearValueType Repeatability_type;
      typedef ::xsd::cxx::tree::optional< Repeatability_type > Repeatability_optional;
      typedef ::xsd::cxx::tree::traits< Repeatability_type, wchar_t > Repeatability_traits;

      const Repeatability_optional&
      Repeatability () const;

      Repeatability_optional&
      Repeatability ();

      void
      Repeatability (const Repeatability_type& x);

      void
      Repeatability (const Repeatability_optional& x);

      void
      Repeatability (::std::unique_ptr< Repeatability_type > p);

      // Constructors.
      //
      LaserTrackerType ();

      LaserTrackerType (const Name_type&,
                        const id_type&);

      LaserTrackerType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      LaserTrackerType (const LaserTrackerType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual LaserTrackerType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LaserTrackerType&
      operator= (const LaserTrackerType& x);

      virtual 
      ~LaserTrackerType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MaximumAngularVelocity_optional MaximumAngularVelocity_;
      DistanceAccuracy_optional DistanceAccuracy_;
      AngularAccuracy_optional AngularAccuracy_;
      SamplingRate_optional SamplingRate_;
      TargetMirror_optional TargetMirror_;
      HeadMass_optional HeadMass_;
      HeadSize_optional HeadSize_;
      MaximumWorkingAmplitude_optional MaximumWorkingAmplitude_;
      Laser_optional Laser_;
      Repeatability_optional Repeatability_;
    };

    class QIF30_SYMBOL_DECL LaserRadarType: public ::xsd::qif30::UniversalDeviceType
    {
      public:
      // MeasurementLaser
      //
      typedef ::xsd::qif30::LaserType MeasurementLaser_type;
      typedef ::xsd::cxx::tree::optional< MeasurementLaser_type > MeasurementLaser_optional;
      typedef ::xsd::cxx::tree::traits< MeasurementLaser_type, wchar_t > MeasurementLaser_traits;

      const MeasurementLaser_optional&
      MeasurementLaser () const;

      MeasurementLaser_optional&
      MeasurementLaser ();

      void
      MeasurementLaser (const MeasurementLaser_type& x);

      void
      MeasurementLaser (const MeasurementLaser_optional& x);

      void
      MeasurementLaser (::std::unique_ptr< MeasurementLaser_type > p);

      // PointingLaser
      //
      typedef ::xsd::qif30::LaserType PointingLaser_type;
      typedef ::xsd::cxx::tree::optional< PointingLaser_type > PointingLaser_optional;
      typedef ::xsd::cxx::tree::traits< PointingLaser_type, wchar_t > PointingLaser_traits;

      const PointingLaser_optional&
      PointingLaser () const;

      PointingLaser_optional&
      PointingLaser ();

      void
      PointingLaser (const PointingLaser_type& x);

      void
      PointingLaser (const PointingLaser_optional& x);

      void
      PointingLaser (::std::unique_ptr< PointingLaser_type > p);

      // MaxPointsRate
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType MaxPointsRate_type;
      typedef ::xsd::cxx::tree::optional< MaxPointsRate_type > MaxPointsRate_optional;
      typedef ::xsd::cxx::tree::traits< MaxPointsRate_type, wchar_t > MaxPointsRate_traits;

      const MaxPointsRate_optional&
      MaxPointsRate () const;

      MaxPointsRate_optional&
      MaxPointsRate ();

      void
      MaxPointsRate (const MaxPointsRate_type& x);

      void
      MaxPointsRate (const MaxPointsRate_optional& x);

      void
      MaxPointsRate (::std::unique_ptr< MaxPointsRate_type > p);

      // MaxMeasurementRange
      //
      typedef ::xsd::qif30::LinearValueType MaxMeasurementRange_type;
      typedef ::xsd::cxx::tree::optional< MaxMeasurementRange_type > MaxMeasurementRange_optional;
      typedef ::xsd::cxx::tree::traits< MaxMeasurementRange_type, wchar_t > MaxMeasurementRange_traits;

      const MaxMeasurementRange_optional&
      MaxMeasurementRange () const;

      MaxMeasurementRange_optional&
      MaxMeasurementRange ();

      void
      MaxMeasurementRange (const MaxMeasurementRange_type& x);

      void
      MaxMeasurementRange (const MaxMeasurementRange_optional& x);

      void
      MaxMeasurementRange (::std::unique_ptr< MaxMeasurementRange_type > p);

      // MinMeasurementRange
      //
      typedef ::xsd::qif30::LinearValueType MinMeasurementRange_type;
      typedef ::xsd::cxx::tree::optional< MinMeasurementRange_type > MinMeasurementRange_optional;
      typedef ::xsd::cxx::tree::traits< MinMeasurementRange_type, wchar_t > MinMeasurementRange_traits;

      const MinMeasurementRange_optional&
      MinMeasurementRange () const;

      MinMeasurementRange_optional&
      MinMeasurementRange ();

      void
      MinMeasurementRange (const MinMeasurementRange_type& x);

      void
      MinMeasurementRange (const MinMeasurementRange_optional& x);

      void
      MinMeasurementRange (::std::unique_ptr< MinMeasurementRange_type > p);

      // ScanningSpeed
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType ScanningSpeed_type;
      typedef ::xsd::cxx::tree::optional< ScanningSpeed_type > ScanningSpeed_optional;
      typedef ::xsd::cxx::tree::traits< ScanningSpeed_type, wchar_t > ScanningSpeed_traits;

      const ScanningSpeed_optional&
      ScanningSpeed () const;

      ScanningSpeed_optional&
      ScanningSpeed ();

      void
      ScanningSpeed (const ScanningSpeed_type& x);

      void
      ScanningSpeed (const ScanningSpeed_optional& x);

      void
      ScanningSpeed (::std::unique_ptr< ScanningSpeed_type > p);

      // DistanceAccuracy
      //
      typedef ::xsd::qif30::LinearErrorType DistanceAccuracy_type;
      typedef ::xsd::cxx::tree::optional< DistanceAccuracy_type > DistanceAccuracy_optional;
      typedef ::xsd::cxx::tree::traits< DistanceAccuracy_type, wchar_t > DistanceAccuracy_traits;

      const DistanceAccuracy_optional&
      DistanceAccuracy () const;

      DistanceAccuracy_optional&
      DistanceAccuracy ();

      void
      DistanceAccuracy (const DistanceAccuracy_type& x);

      void
      DistanceAccuracy (const DistanceAccuracy_optional& x);

      void
      DistanceAccuracy (::std::unique_ptr< DistanceAccuracy_type > p);

      // AzimuthAngularAccuracy
      //
      typedef ::xsd::qif30::AngularErrorType AzimuthAngularAccuracy_type;
      typedef ::xsd::cxx::tree::optional< AzimuthAngularAccuracy_type > AzimuthAngularAccuracy_optional;
      typedef ::xsd::cxx::tree::traits< AzimuthAngularAccuracy_type, wchar_t > AzimuthAngularAccuracy_traits;

      const AzimuthAngularAccuracy_optional&
      AzimuthAngularAccuracy () const;

      AzimuthAngularAccuracy_optional&
      AzimuthAngularAccuracy ();

      void
      AzimuthAngularAccuracy (const AzimuthAngularAccuracy_type& x);

      void
      AzimuthAngularAccuracy (const AzimuthAngularAccuracy_optional& x);

      void
      AzimuthAngularAccuracy (::std::unique_ptr< AzimuthAngularAccuracy_type > p);

      // ElevationAngularAccuracy
      //
      typedef ::xsd::qif30::AngularErrorType ElevationAngularAccuracy_type;
      typedef ::xsd::cxx::tree::optional< ElevationAngularAccuracy_type > ElevationAngularAccuracy_optional;
      typedef ::xsd::cxx::tree::traits< ElevationAngularAccuracy_type, wchar_t > ElevationAngularAccuracy_traits;

      const ElevationAngularAccuracy_optional&
      ElevationAngularAccuracy () const;

      ElevationAngularAccuracy_optional&
      ElevationAngularAccuracy ();

      void
      ElevationAngularAccuracy (const ElevationAngularAccuracy_type& x);

      void
      ElevationAngularAccuracy (const ElevationAngularAccuracy_optional& x);

      void
      ElevationAngularAccuracy (::std::unique_ptr< ElevationAngularAccuracy_type > p);

      // RangeForVolumetricUncertainty
      //
      typedef ::xsd::qif30::LinearValueType RangeForVolumetricUncertainty_type;
      typedef ::xsd::cxx::tree::optional< RangeForVolumetricUncertainty_type > RangeForVolumetricUncertainty_optional;
      typedef ::xsd::cxx::tree::traits< RangeForVolumetricUncertainty_type, wchar_t > RangeForVolumetricUncertainty_traits;

      const RangeForVolumetricUncertainty_optional&
      RangeForVolumetricUncertainty () const;

      RangeForVolumetricUncertainty_optional&
      RangeForVolumetricUncertainty ();

      void
      RangeForVolumetricUncertainty (const RangeForVolumetricUncertainty_type& x);

      void
      RangeForVolumetricUncertainty (const RangeForVolumetricUncertainty_optional& x);

      void
      RangeForVolumetricUncertainty (::std::unique_ptr< RangeForVolumetricUncertainty_type > p);

      // VolumetricUncertainty
      //
      typedef ::xsd::qif30::LinearValueType VolumetricUncertainty_type;
      typedef ::xsd::cxx::tree::optional< VolumetricUncertainty_type > VolumetricUncertainty_optional;
      typedef ::xsd::cxx::tree::traits< VolumetricUncertainty_type, wchar_t > VolumetricUncertainty_traits;

      const VolumetricUncertainty_optional&
      VolumetricUncertainty () const;

      VolumetricUncertainty_optional&
      VolumetricUncertainty ();

      void
      VolumetricUncertainty (const VolumetricUncertainty_type& x);

      void
      VolumetricUncertainty (const VolumetricUncertainty_optional& x);

      void
      VolumetricUncertainty (::std::unique_ptr< VolumetricUncertainty_type > p);

      // MaxEnvironmentalAltitude
      //
      typedef ::xsd::qif30::LinearValueType MaxEnvironmentalAltitude_type;
      typedef ::xsd::cxx::tree::optional< MaxEnvironmentalAltitude_type > MaxEnvironmentalAltitude_optional;
      typedef ::xsd::cxx::tree::traits< MaxEnvironmentalAltitude_type, wchar_t > MaxEnvironmentalAltitude_traits;

      const MaxEnvironmentalAltitude_optional&
      MaxEnvironmentalAltitude () const;

      MaxEnvironmentalAltitude_optional&
      MaxEnvironmentalAltitude ();

      void
      MaxEnvironmentalAltitude (const MaxEnvironmentalAltitude_type& x);

      void
      MaxEnvironmentalAltitude (const MaxEnvironmentalAltitude_optional& x);

      void
      MaxEnvironmentalAltitude (::std::unique_ptr< MaxEnvironmentalAltitude_type > p);

      // MinEnvironmentalAltitude
      //
      typedef ::xsd::qif30::LinearValueType MinEnvironmentalAltitude_type;
      typedef ::xsd::cxx::tree::optional< MinEnvironmentalAltitude_type > MinEnvironmentalAltitude_optional;
      typedef ::xsd::cxx::tree::traits< MinEnvironmentalAltitude_type, wchar_t > MinEnvironmentalAltitude_traits;

      const MinEnvironmentalAltitude_optional&
      MinEnvironmentalAltitude () const;

      MinEnvironmentalAltitude_optional&
      MinEnvironmentalAltitude ();

      void
      MinEnvironmentalAltitude (const MinEnvironmentalAltitude_type& x);

      void
      MinEnvironmentalAltitude (const MinEnvironmentalAltitude_optional& x);

      void
      MinEnvironmentalAltitude (::std::unique_ptr< MinEnvironmentalAltitude_type > p);

      // SurfacePointsSpeed
      //
      typedef ::xsd::qif30::TimeValueType SurfacePointsSpeed_type;
      typedef ::xsd::cxx::tree::optional< SurfacePointsSpeed_type > SurfacePointsSpeed_optional;
      typedef ::xsd::cxx::tree::traits< SurfacePointsSpeed_type, wchar_t > SurfacePointsSpeed_traits;

      const SurfacePointsSpeed_optional&
      SurfacePointsSpeed () const;

      SurfacePointsSpeed_optional&
      SurfacePointsSpeed ();

      void
      SurfacePointsSpeed (const SurfacePointsSpeed_type& x);

      void
      SurfacePointsSpeed (const SurfacePointsSpeed_optional& x);

      void
      SurfacePointsSpeed (::std::unique_ptr< SurfacePointsSpeed_type > p);

      // ToolingBallSpeed
      //
      typedef ::xsd::qif30::TimeValueType ToolingBallSpeed_type;
      typedef ::xsd::cxx::tree::optional< ToolingBallSpeed_type > ToolingBallSpeed_optional;
      typedef ::xsd::cxx::tree::traits< ToolingBallSpeed_type, wchar_t > ToolingBallSpeed_traits;

      const ToolingBallSpeed_optional&
      ToolingBallSpeed () const;

      ToolingBallSpeed_optional&
      ToolingBallSpeed ();

      void
      ToolingBallSpeed (const ToolingBallSpeed_type& x);

      void
      ToolingBallSpeed (const ToolingBallSpeed_optional& x);

      void
      ToolingBallSpeed (::std::unique_ptr< ToolingBallSpeed_type > p);

      // FeatureSpeed
      //
      typedef ::xsd::qif30::TimeValueType FeatureSpeed_type;
      typedef ::xsd::cxx::tree::optional< FeatureSpeed_type > FeatureSpeed_optional;
      typedef ::xsd::cxx::tree::traits< FeatureSpeed_type, wchar_t > FeatureSpeed_traits;

      const FeatureSpeed_optional&
      FeatureSpeed () const;

      FeatureSpeed_optional&
      FeatureSpeed ();

      void
      FeatureSpeed (const FeatureSpeed_type& x);

      void
      FeatureSpeed (const FeatureSpeed_optional& x);

      void
      FeatureSpeed (::std::unique_ptr< FeatureSpeed_type > p);

      // Constructors.
      //
      LaserRadarType ();

      LaserRadarType (const Name_type&,
                      const id_type&);

      LaserRadarType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      LaserRadarType (const LaserRadarType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual LaserRadarType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LaserRadarType&
      operator= (const LaserRadarType& x);

      virtual 
      ~LaserRadarType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MeasurementLaser_optional MeasurementLaser_;
      PointingLaser_optional PointingLaser_;
      MaxPointsRate_optional MaxPointsRate_;
      MaxMeasurementRange_optional MaxMeasurementRange_;
      MinMeasurementRange_optional MinMeasurementRange_;
      ScanningSpeed_optional ScanningSpeed_;
      DistanceAccuracy_optional DistanceAccuracy_;
      AzimuthAngularAccuracy_optional AzimuthAngularAccuracy_;
      ElevationAngularAccuracy_optional ElevationAngularAccuracy_;
      RangeForVolumetricUncertainty_optional RangeForVolumetricUncertainty_;
      VolumetricUncertainty_optional VolumetricUncertainty_;
      MaxEnvironmentalAltitude_optional MaxEnvironmentalAltitude_;
      MinEnvironmentalAltitude_optional MinEnvironmentalAltitude_;
      SurfacePointsSpeed_optional SurfacePointsSpeed_;
      ToolingBallSpeed_optional ToolingBallSpeed_;
      FeatureSpeed_optional FeatureSpeed_;
    };

    class QIF30_SYMBOL_DECL StiffnessType: public ::xml_schema::type
    {
      public:
      // XStiffness
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType XStiffness_type;
      typedef ::xsd::cxx::tree::optional< XStiffness_type > XStiffness_optional;
      typedef ::xsd::cxx::tree::traits< XStiffness_type, wchar_t > XStiffness_traits;

      const XStiffness_optional&
      XStiffness () const;

      XStiffness_optional&
      XStiffness ();

      void
      XStiffness (const XStiffness_type& x);

      void
      XStiffness (const XStiffness_optional& x);

      void
      XStiffness (::std::unique_ptr< XStiffness_type > p);

      // YStiffness
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType YStiffness_type;
      typedef ::xsd::cxx::tree::optional< YStiffness_type > YStiffness_optional;
      typedef ::xsd::cxx::tree::traits< YStiffness_type, wchar_t > YStiffness_traits;

      const YStiffness_optional&
      YStiffness () const;

      YStiffness_optional&
      YStiffness ();

      void
      YStiffness (const YStiffness_type& x);

      void
      YStiffness (const YStiffness_optional& x);

      void
      YStiffness (::std::unique_ptr< YStiffness_type > p);

      // ZStiffness
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType ZStiffness_type;
      typedef ::xsd::cxx::tree::optional< ZStiffness_type > ZStiffness_optional;
      typedef ::xsd::cxx::tree::traits< ZStiffness_type, wchar_t > ZStiffness_traits;

      const ZStiffness_optional&
      ZStiffness () const;

      ZStiffness_optional&
      ZStiffness ();

      void
      ZStiffness (const ZStiffness_type& x);

      void
      ZStiffness (const ZStiffness_optional& x);

      void
      ZStiffness (::std::unique_ptr< ZStiffness_type > p);

      // Constructors.
      //
      StiffnessType ();

      StiffnessType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      StiffnessType (const StiffnessType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual StiffnessType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StiffnessType&
      operator= (const StiffnessType& x);

      virtual 
      ~StiffnessType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      XStiffness_optional XStiffness_;
      YStiffness_optional YStiffness_;
      ZStiffness_optional ZStiffness_;
    };

    class QIF30_SYMBOL_DECL CMMDirectionEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        RIGHT,
        LEFT,
        FRONT,
        BACK,
        UP,
        DOWN
      };

      CMMDirectionEnumType ();

      CMMDirectionEnumType (value v);

      CMMDirectionEnumType (const wchar_t* v);

      CMMDirectionEnumType (const ::std::wstring& v);

      CMMDirectionEnumType (const ::xml_schema::nmtoken& v);

      CMMDirectionEnumType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      CMMDirectionEnumType (const xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      CMMDirectionEnumType (const ::std::wstring& s,
                            const xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      CMMDirectionEnumType (const CMMDirectionEnumType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      CMMDirectionEnumType&
      operator= (const CMMDirectionEnumType&) = default;
#endif

      virtual CMMDirectionEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CMMDirectionEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_CMMDirectionEnumType_convert ();
      }

      protected:
      value
      _xsd_CMMDirectionEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_CMMDirectionEnumType_literals_[6];
      static const value _xsd_CMMDirectionEnumType_indexes_[6];
    };

    class QIF30_SYMBOL_DECL CartesianCMMGeometryType: public ::xml_schema::type
    {
      public:
      // CartesianCMMGeometryEnum
      //
      typedef ::xsd::qif30::CartesianCMMGeometryEnumType CartesianCMMGeometryEnum_type;
      typedef ::xsd::cxx::tree::optional< CartesianCMMGeometryEnum_type > CartesianCMMGeometryEnum_optional;
      typedef ::xsd::cxx::tree::traits< CartesianCMMGeometryEnum_type, wchar_t > CartesianCMMGeometryEnum_traits;

      const CartesianCMMGeometryEnum_optional&
      CartesianCMMGeometryEnum () const;

      CartesianCMMGeometryEnum_optional&
      CartesianCMMGeometryEnum ();

      void
      CartesianCMMGeometryEnum (const CartesianCMMGeometryEnum_type& x);

      void
      CartesianCMMGeometryEnum (const CartesianCMMGeometryEnum_optional& x);

      void
      CartesianCMMGeometryEnum (::std::unique_ptr< CartesianCMMGeometryEnum_type > p);

      // OtherCartesianCMMGeometry
      //
      typedef ::xml_schema::string OtherCartesianCMMGeometry_type;
      typedef ::xsd::cxx::tree::optional< OtherCartesianCMMGeometry_type > OtherCartesianCMMGeometry_optional;
      typedef ::xsd::cxx::tree::traits< OtherCartesianCMMGeometry_type, wchar_t > OtherCartesianCMMGeometry_traits;

      const OtherCartesianCMMGeometry_optional&
      OtherCartesianCMMGeometry () const;

      OtherCartesianCMMGeometry_optional&
      OtherCartesianCMMGeometry ();

      void
      OtherCartesianCMMGeometry (const OtherCartesianCMMGeometry_type& x);

      void
      OtherCartesianCMMGeometry (const OtherCartesianCMMGeometry_optional& x);

      void
      OtherCartesianCMMGeometry (::std::unique_ptr< OtherCartesianCMMGeometry_type > p);

      // Constructors.
      //
      CartesianCMMGeometryType ();

      CartesianCMMGeometryType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      CartesianCMMGeometryType (const CartesianCMMGeometryType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual CartesianCMMGeometryType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CartesianCMMGeometryType&
      operator= (const CartesianCMMGeometryType& x);

      virtual 
      ~CartesianCMMGeometryType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CartesianCMMGeometryEnum_optional CartesianCMMGeometryEnum_;
      OtherCartesianCMMGeometry_optional OtherCartesianCMMGeometry_;
    };

    class QIF30_SYMBOL_DECL CartesianCMMGeometryEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        FIXED_BRIDGE,
        MOVING_BRIDGE,
        L_SHAPED_BRIDGE,
        COLUMN,
        FIXED_TABLE_CANTILEVER_ARM,
        MOVING_TABLE_CANTILEVER_ARM,
        FIXED_TABLE_HORIZONTAL_ARM,
        MOVING_TABLE_HORIZONTAL_ARM,
        MOVING_RAM_HORIZONTAL_ARM,
        GANTRY
      };

      CartesianCMMGeometryEnumType ();

      CartesianCMMGeometryEnumType (value v);

      CartesianCMMGeometryEnumType (const wchar_t* v);

      CartesianCMMGeometryEnumType (const ::std::wstring& v);

      CartesianCMMGeometryEnumType (const ::xml_schema::nmtoken& v);

      CartesianCMMGeometryEnumType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      CartesianCMMGeometryEnumType (const xercesc::DOMAttr& a,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      CartesianCMMGeometryEnumType (const ::std::wstring& s,
                                    const xercesc::DOMElement* e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      CartesianCMMGeometryEnumType (const CartesianCMMGeometryEnumType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      CartesianCMMGeometryEnumType&
      operator= (const CartesianCMMGeometryEnumType&) = default;
#endif

      virtual CartesianCMMGeometryEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CartesianCMMGeometryEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_CartesianCMMGeometryEnumType_convert ();
      }

      protected:
      value
      _xsd_CartesianCMMGeometryEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_CartesianCMMGeometryEnumType_literals_[10];
      static const value _xsd_CartesianCMMGeometryEnumType_indexes_[10];
    };

    class QIF30_SYMBOL_DECL CMMAxisDirectionsBaseType: public ::xml_schema::type
    {
      public:
      // Constructors.
      //
      CMMAxisDirectionsBaseType ();

      CMMAxisDirectionsBaseType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      CMMAxisDirectionsBaseType (const xercesc::DOMAttr& a,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      CMMAxisDirectionsBaseType (const ::std::wstring& s,
                                 const xercesc::DOMElement* e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      CMMAxisDirectionsBaseType (const CMMAxisDirectionsBaseType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual CMMAxisDirectionsBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      CMMAxisDirectionsBaseType&
      operator= (const CMMAxisDirectionsBaseType&) = default;
#endif

      virtual 
      ~CMMAxisDirectionsBaseType ();
    };

    class QIF30_SYMBOL_DECL CartesianCMMAxisDirectionsType: public ::xsd::qif30::CMMAxisDirectionsBaseType
    {
      public:
      // XAxisDirection
      //
      typedef ::xsd::qif30::CMMDirectionEnumType XAxisDirection_type;
      typedef ::xsd::cxx::tree::traits< XAxisDirection_type, wchar_t > XAxisDirection_traits;

      const XAxisDirection_type&
      XAxisDirection () const;

      XAxisDirection_type&
      XAxisDirection ();

      void
      XAxisDirection (const XAxisDirection_type& x);

      void
      XAxisDirection (::std::unique_ptr< XAxisDirection_type > p);

      // YAxisDirection
      //
      typedef ::xsd::qif30::CMMDirectionEnumType YAxisDirection_type;
      typedef ::xsd::cxx::tree::traits< YAxisDirection_type, wchar_t > YAxisDirection_traits;

      const YAxisDirection_type&
      YAxisDirection () const;

      YAxisDirection_type&
      YAxisDirection ();

      void
      YAxisDirection (const YAxisDirection_type& x);

      void
      YAxisDirection (::std::unique_ptr< YAxisDirection_type > p);

      // ZAxisDirection
      //
      typedef ::xsd::qif30::CMMDirectionEnumType ZAxisDirection_type;
      typedef ::xsd::cxx::tree::traits< ZAxisDirection_type, wchar_t > ZAxisDirection_traits;

      const ZAxisDirection_type&
      ZAxisDirection () const;

      ZAxisDirection_type&
      ZAxisDirection ();

      void
      ZAxisDirection (const ZAxisDirection_type& x);

      void
      ZAxisDirection (::std::unique_ptr< ZAxisDirection_type > p);

      // Constructors.
      //
      CartesianCMMAxisDirectionsType ();

      CartesianCMMAxisDirectionsType (const XAxisDirection_type&,
                                      const YAxisDirection_type&,
                                      const ZAxisDirection_type&);

      CartesianCMMAxisDirectionsType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      CartesianCMMAxisDirectionsType (const CartesianCMMAxisDirectionsType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual CartesianCMMAxisDirectionsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CartesianCMMAxisDirectionsType&
      operator= (const CartesianCMMAxisDirectionsType& x);

      virtual 
      ~CartesianCMMAxisDirectionsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< XAxisDirection_type > XAxisDirection_;
      ::xsd::cxx::tree::one< YAxisDirection_type > YAxisDirection_;
      ::xsd::cxx::tree::one< ZAxisDirection_type > ZAxisDirection_;
    };

    class QIF30_SYMBOL_DECL XYZLinearSpecificationType: public ::xml_schema::type
    {
      public:
      // X
      //
      typedef ::xsd::qif30::LinearValueType X_type;
      typedef ::xsd::cxx::tree::optional< X_type > X_optional;
      typedef ::xsd::cxx::tree::traits< X_type, wchar_t > X_traits;

      const X_optional&
      X () const;

      X_optional&
      X ();

      void
      X (const X_type& x);

      void
      X (const X_optional& x);

      void
      X (::std::unique_ptr< X_type > p);

      // Y
      //
      typedef ::xsd::qif30::LinearValueType Y_type;
      typedef ::xsd::cxx::tree::optional< Y_type > Y_optional;
      typedef ::xsd::cxx::tree::traits< Y_type, wchar_t > Y_traits;

      const Y_optional&
      Y () const;

      Y_optional&
      Y ();

      void
      Y (const Y_type& x);

      void
      Y (const Y_optional& x);

      void
      Y (::std::unique_ptr< Y_type > p);

      // Z
      //
      typedef ::xsd::qif30::LinearValueType Z_type;
      typedef ::xsd::cxx::tree::optional< Z_type > Z_optional;
      typedef ::xsd::cxx::tree::traits< Z_type, wchar_t > Z_traits;

      const Z_optional&
      Z () const;

      Z_optional&
      Z ();

      void
      Z (const Z_type& x);

      void
      Z (const Z_optional& x);

      void
      Z (::std::unique_ptr< Z_type > p);

      // Constructors.
      //
      XYZLinearSpecificationType ();

      XYZLinearSpecificationType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      XYZLinearSpecificationType (const XYZLinearSpecificationType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual XYZLinearSpecificationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      XYZLinearSpecificationType&
      operator= (const XYZLinearSpecificationType& x);

      virtual 
      ~XYZLinearSpecificationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      X_optional X_;
      Y_optional Y_;
      Z_optional Z_;
    };

    class QIF30_SYMBOL_DECL TargetMirrorEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        CUBE_CORNER,
        CATS_EYE,
        PLANE_MIRROR
      };

      TargetMirrorEnumType ();

      TargetMirrorEnumType (value v);

      TargetMirrorEnumType (const wchar_t* v);

      TargetMirrorEnumType (const ::std::wstring& v);

      TargetMirrorEnumType (const ::xml_schema::nmtoken& v);

      TargetMirrorEnumType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      TargetMirrorEnumType (const xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      TargetMirrorEnumType (const ::std::wstring& s,
                            const xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      TargetMirrorEnumType (const TargetMirrorEnumType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      TargetMirrorEnumType&
      operator= (const TargetMirrorEnumType&) = default;
#endif

      virtual TargetMirrorEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TargetMirrorEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_TargetMirrorEnumType_convert ();
      }

      protected:
      value
      _xsd_TargetMirrorEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_TargetMirrorEnumType_literals_[3];
      static const value _xsd_TargetMirrorEnumType_indexes_[3];
    };

    class QIF30_SYMBOL_DECL MeasurementDeviceScalesBaseType: public ::xml_schema::type
    {
      public:
      // Constructors.
      //
      MeasurementDeviceScalesBaseType ();

      MeasurementDeviceScalesBaseType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      MeasurementDeviceScalesBaseType (const xercesc::DOMAttr& a,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      MeasurementDeviceScalesBaseType (const ::std::wstring& s,
                                       const xercesc::DOMElement* e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      MeasurementDeviceScalesBaseType (const MeasurementDeviceScalesBaseType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual MeasurementDeviceScalesBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      MeasurementDeviceScalesBaseType&
      operator= (const MeasurementDeviceScalesBaseType&) = default;
#endif

      virtual 
      ~MeasurementDeviceScalesBaseType ();
    };

    class QIF30_SYMBOL_DECL CartesianMeasurementDeviceScalesType: public ::xsd::qif30::MeasurementDeviceScalesBaseType
    {
      public:
      // XScale
      //
      typedef ::xsd::qif30::MeasurementDeviceScaleType XScale_type;
      typedef ::xsd::cxx::tree::traits< XScale_type, wchar_t > XScale_traits;

      const XScale_type&
      XScale () const;

      XScale_type&
      XScale ();

      void
      XScale (const XScale_type& x);

      void
      XScale (::std::unique_ptr< XScale_type > p);

      // YScale
      //
      typedef ::xsd::qif30::MeasurementDeviceScaleType YScale_type;
      typedef ::xsd::cxx::tree::traits< YScale_type, wchar_t > YScale_traits;

      const YScale_type&
      YScale () const;

      YScale_type&
      YScale ();

      void
      YScale (const YScale_type& x);

      void
      YScale (::std::unique_ptr< YScale_type > p);

      // ZScale
      //
      typedef ::xsd::qif30::MeasurementDeviceScaleType ZScale_type;
      typedef ::xsd::cxx::tree::traits< ZScale_type, wchar_t > ZScale_traits;

      const ZScale_type&
      ZScale () const;

      ZScale_type&
      ZScale ();

      void
      ZScale (const ZScale_type& x);

      void
      ZScale (::std::unique_ptr< ZScale_type > p);

      // Constructors.
      //
      CartesianMeasurementDeviceScalesType ();

      CartesianMeasurementDeviceScalesType (const XScale_type&,
                                            const YScale_type&,
                                            const ZScale_type&);

      CartesianMeasurementDeviceScalesType (::std::unique_ptr< XScale_type >,
                                            ::std::unique_ptr< YScale_type >,
                                            ::std::unique_ptr< ZScale_type >);

      CartesianMeasurementDeviceScalesType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      CartesianMeasurementDeviceScalesType (const CartesianMeasurementDeviceScalesType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual CartesianMeasurementDeviceScalesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CartesianMeasurementDeviceScalesType&
      operator= (const CartesianMeasurementDeviceScalesType& x);

      virtual 
      ~CartesianMeasurementDeviceScalesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< XScale_type > XScale_;
      ::xsd::cxx::tree::one< YScale_type > YScale_;
      ::xsd::cxx::tree::one< ZScale_type > ZScale_;
    };

    class QIF30_SYMBOL_DECL MeasurementDeviceScaleType: public ::xml_schema::type
    {
      public:
      // ScaleMaterial
      //
      typedef ::xml_schema::string ScaleMaterial_type;
      typedef ::xsd::cxx::tree::optional< ScaleMaterial_type > ScaleMaterial_optional;
      typedef ::xsd::cxx::tree::traits< ScaleMaterial_type, wchar_t > ScaleMaterial_traits;

      const ScaleMaterial_optional&
      ScaleMaterial () const;

      ScaleMaterial_optional&
      ScaleMaterial ();

      void
      ScaleMaterial (const ScaleMaterial_type& x);

      void
      ScaleMaterial (const ScaleMaterial_optional& x);

      void
      ScaleMaterial (::std::unique_ptr< ScaleMaterial_type > p);

      // ScaleCoefficientOfExpansion
      //
      typedef ::xml_schema::decimal ScaleCoefficientOfExpansion_type;
      typedef ::xsd::cxx::tree::optional< ScaleCoefficientOfExpansion_type > ScaleCoefficientOfExpansion_optional;
      typedef ::xsd::cxx::tree::traits< ScaleCoefficientOfExpansion_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > ScaleCoefficientOfExpansion_traits;

      const ScaleCoefficientOfExpansion_optional&
      ScaleCoefficientOfExpansion () const;

      ScaleCoefficientOfExpansion_optional&
      ScaleCoefficientOfExpansion ();

      void
      ScaleCoefficientOfExpansion (const ScaleCoefficientOfExpansion_type& x);

      void
      ScaleCoefficientOfExpansion (const ScaleCoefficientOfExpansion_optional& x);

      // ScaleCoefficientOfExpansionUncertainty
      //
      typedef ::xml_schema::decimal ScaleCoefficientOfExpansionUncertainty_type;
      typedef ::xsd::cxx::tree::optional< ScaleCoefficientOfExpansionUncertainty_type > ScaleCoefficientOfExpansionUncertainty_optional;
      typedef ::xsd::cxx::tree::traits< ScaleCoefficientOfExpansionUncertainty_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > ScaleCoefficientOfExpansionUncertainty_traits;

      const ScaleCoefficientOfExpansionUncertainty_optional&
      ScaleCoefficientOfExpansionUncertainty () const;

      ScaleCoefficientOfExpansionUncertainty_optional&
      ScaleCoefficientOfExpansionUncertainty ();

      void
      ScaleCoefficientOfExpansionUncertainty (const ScaleCoefficientOfExpansionUncertainty_type& x);

      void
      ScaleCoefficientOfExpansionUncertainty (const ScaleCoefficientOfExpansionUncertainty_optional& x);

      // TypeOfScale
      //
      typedef ::xsd::qif30::TypeOfScaleType TypeOfScale_type;
      typedef ::xsd::cxx::tree::optional< TypeOfScale_type > TypeOfScale_optional;
      typedef ::xsd::cxx::tree::traits< TypeOfScale_type, wchar_t > TypeOfScale_traits;

      const TypeOfScale_optional&
      TypeOfScale () const;

      TypeOfScale_optional&
      TypeOfScale ();

      void
      TypeOfScale (const TypeOfScale_type& x);

      void
      TypeOfScale (const TypeOfScale_optional& x);

      void
      TypeOfScale (::std::unique_ptr< TypeOfScale_type > p);

      // ScaleResolution
      //
      typedef ::xsd::qif30::LinearValueType ScaleResolution_type;
      typedef ::xsd::cxx::tree::optional< ScaleResolution_type > ScaleResolution_optional;
      typedef ::xsd::cxx::tree::traits< ScaleResolution_type, wchar_t > ScaleResolution_traits;

      const ScaleResolution_optional&
      ScaleResolution () const;

      ScaleResolution_optional&
      ScaleResolution ();

      void
      ScaleResolution (const ScaleResolution_type& x);

      void
      ScaleResolution (const ScaleResolution_optional& x);

      void
      ScaleResolution (::std::unique_ptr< ScaleResolution_type > p);

      // ScaleReference
      //
      typedef ::xsd::qif30::ScaleReferenceEnumType ScaleReference_type;
      typedef ::xsd::cxx::tree::optional< ScaleReference_type > ScaleReference_optional;
      typedef ::xsd::cxx::tree::traits< ScaleReference_type, wchar_t > ScaleReference_traits;

      const ScaleReference_optional&
      ScaleReference () const;

      ScaleReference_optional&
      ScaleReference ();

      void
      ScaleReference (const ScaleReference_type& x);

      void
      ScaleReference (const ScaleReference_optional& x);

      void
      ScaleReference (::std::unique_ptr< ScaleReference_type > p);

      // Constructors.
      //
      MeasurementDeviceScaleType ();

      MeasurementDeviceScaleType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      MeasurementDeviceScaleType (const MeasurementDeviceScaleType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual MeasurementDeviceScaleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasurementDeviceScaleType&
      operator= (const MeasurementDeviceScaleType& x);

      virtual 
      ~MeasurementDeviceScaleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ScaleMaterial_optional ScaleMaterial_;
      ScaleCoefficientOfExpansion_optional ScaleCoefficientOfExpansion_;
      ScaleCoefficientOfExpansionUncertainty_optional ScaleCoefficientOfExpansionUncertainty_;
      TypeOfScale_optional TypeOfScale_;
      ScaleResolution_optional ScaleResolution_;
      ScaleReference_optional ScaleReference_;
    };

    class QIF30_SYMBOL_DECL ScaleReferenceEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        SCALE_ABSOLUTE,
        SCALE_INCREMENTAL
      };

      ScaleReferenceEnumType ();

      ScaleReferenceEnumType (value v);

      ScaleReferenceEnumType (const wchar_t* v);

      ScaleReferenceEnumType (const ::std::wstring& v);

      ScaleReferenceEnumType (const ::xml_schema::nmtoken& v);

      ScaleReferenceEnumType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      ScaleReferenceEnumType (const xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      ScaleReferenceEnumType (const ::std::wstring& s,
                              const xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      ScaleReferenceEnumType (const ScaleReferenceEnumType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      ScaleReferenceEnumType&
      operator= (const ScaleReferenceEnumType&) = default;
#endif

      virtual ScaleReferenceEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ScaleReferenceEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_ScaleReferenceEnumType_convert ();
      }

      protected:
      value
      _xsd_ScaleReferenceEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_ScaleReferenceEnumType_literals_[2];
      static const value _xsd_ScaleReferenceEnumType_indexes_[2];
    };

    class QIF30_SYMBOL_DECL TypeOfScaleEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        ELECTROOPTICAL_LINEAR,
        ELECTROOPTICAL_ROTARY,
        LASER_INTERFEROMETER_LINEAR,
        TIME_OF_FLIGHT_LINEAR
      };

      TypeOfScaleEnumType ();

      TypeOfScaleEnumType (value v);

      TypeOfScaleEnumType (const wchar_t* v);

      TypeOfScaleEnumType (const ::std::wstring& v);

      TypeOfScaleEnumType (const ::xml_schema::nmtoken& v);

      TypeOfScaleEnumType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      TypeOfScaleEnumType (const xercesc::DOMAttr& a,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      TypeOfScaleEnumType (const ::std::wstring& s,
                           const xercesc::DOMElement* e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      TypeOfScaleEnumType (const TypeOfScaleEnumType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      TypeOfScaleEnumType&
      operator= (const TypeOfScaleEnumType&) = default;
#endif

      virtual TypeOfScaleEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TypeOfScaleEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_TypeOfScaleEnumType_convert ();
      }

      protected:
      value
      _xsd_TypeOfScaleEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_TypeOfScaleEnumType_literals_[4];
      static const value _xsd_TypeOfScaleEnumType_indexes_[4];
    };

    class QIF30_SYMBOL_DECL TypeOfScaleType: public ::xml_schema::type
    {
      public:
      // TypeOfScaleEnum
      //
      typedef ::xsd::qif30::TypeOfScaleEnumType TypeOfScaleEnum_type;
      typedef ::xsd::cxx::tree::optional< TypeOfScaleEnum_type > TypeOfScaleEnum_optional;
      typedef ::xsd::cxx::tree::traits< TypeOfScaleEnum_type, wchar_t > TypeOfScaleEnum_traits;

      const TypeOfScaleEnum_optional&
      TypeOfScaleEnum () const;

      TypeOfScaleEnum_optional&
      TypeOfScaleEnum ();

      void
      TypeOfScaleEnum (const TypeOfScaleEnum_type& x);

      void
      TypeOfScaleEnum (const TypeOfScaleEnum_optional& x);

      void
      TypeOfScaleEnum (::std::unique_ptr< TypeOfScaleEnum_type > p);

      // OtherTypeOfScale
      //
      typedef ::xml_schema::string OtherTypeOfScale_type;
      typedef ::xsd::cxx::tree::optional< OtherTypeOfScale_type > OtherTypeOfScale_optional;
      typedef ::xsd::cxx::tree::traits< OtherTypeOfScale_type, wchar_t > OtherTypeOfScale_traits;

      const OtherTypeOfScale_optional&
      OtherTypeOfScale () const;

      OtherTypeOfScale_optional&
      OtherTypeOfScale ();

      void
      OtherTypeOfScale (const OtherTypeOfScale_type& x);

      void
      OtherTypeOfScale (const OtherTypeOfScale_optional& x);

      void
      OtherTypeOfScale (::std::unique_ptr< OtherTypeOfScale_type > p);

      // Constructors.
      //
      TypeOfScaleType ();

      TypeOfScaleType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      TypeOfScaleType (const TypeOfScaleType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual TypeOfScaleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TypeOfScaleType&
      operator= (const TypeOfScaleType& x);

      virtual 
      ~TypeOfScaleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      TypeOfScaleEnum_optional TypeOfScaleEnum_;
      OtherTypeOfScale_optional OtherTypeOfScale_;
    };

    class QIF30_SYMBOL_DECL CMMSpeedsBaseType: public ::xml_schema::type
    {
      public:
      // Constructors.
      //
      CMMSpeedsBaseType ();

      CMMSpeedsBaseType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      CMMSpeedsBaseType (const xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      CMMSpeedsBaseType (const ::std::wstring& s,
                         const xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      CMMSpeedsBaseType (const CMMSpeedsBaseType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual CMMSpeedsBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      CMMSpeedsBaseType&
      operator= (const CMMSpeedsBaseType&) = default;
#endif

      virtual 
      ~CMMSpeedsBaseType ();
    };

    class QIF30_SYMBOL_DECL CartesianCMMSpeedsType: public ::xsd::qif30::CMMSpeedsBaseType
    {
      public:
      // MaxXTraverseSpeed
      //
      typedef ::xsd::qif30::SpeedValueType MaxXTraverseSpeed_type;
      typedef ::xsd::cxx::tree::optional< MaxXTraverseSpeed_type > MaxXTraverseSpeed_optional;
      typedef ::xsd::cxx::tree::traits< MaxXTraverseSpeed_type, wchar_t > MaxXTraverseSpeed_traits;

      const MaxXTraverseSpeed_optional&
      MaxXTraverseSpeed () const;

      MaxXTraverseSpeed_optional&
      MaxXTraverseSpeed ();

      void
      MaxXTraverseSpeed (const MaxXTraverseSpeed_type& x);

      void
      MaxXTraverseSpeed (const MaxXTraverseSpeed_optional& x);

      void
      MaxXTraverseSpeed (::std::unique_ptr< MaxXTraverseSpeed_type > p);

      // MaxYTraverseSpeed
      //
      typedef ::xsd::qif30::SpeedValueType MaxYTraverseSpeed_type;
      typedef ::xsd::cxx::tree::optional< MaxYTraverseSpeed_type > MaxYTraverseSpeed_optional;
      typedef ::xsd::cxx::tree::traits< MaxYTraverseSpeed_type, wchar_t > MaxYTraverseSpeed_traits;

      const MaxYTraverseSpeed_optional&
      MaxYTraverseSpeed () const;

      MaxYTraverseSpeed_optional&
      MaxYTraverseSpeed ();

      void
      MaxYTraverseSpeed (const MaxYTraverseSpeed_type& x);

      void
      MaxYTraverseSpeed (const MaxYTraverseSpeed_optional& x);

      void
      MaxYTraverseSpeed (::std::unique_ptr< MaxYTraverseSpeed_type > p);

      // MaxZTraverseSpeed
      //
      typedef ::xsd::qif30::SpeedValueType MaxZTraverseSpeed_type;
      typedef ::xsd::cxx::tree::optional< MaxZTraverseSpeed_type > MaxZTraverseSpeed_optional;
      typedef ::xsd::cxx::tree::traits< MaxZTraverseSpeed_type, wchar_t > MaxZTraverseSpeed_traits;

      const MaxZTraverseSpeed_optional&
      MaxZTraverseSpeed () const;

      MaxZTraverseSpeed_optional&
      MaxZTraverseSpeed ();

      void
      MaxZTraverseSpeed (const MaxZTraverseSpeed_type& x);

      void
      MaxZTraverseSpeed (const MaxZTraverseSpeed_optional& x);

      void
      MaxZTraverseSpeed (::std::unique_ptr< MaxZTraverseSpeed_type > p);

      // MaxXProbingSpeed
      //
      typedef ::xsd::qif30::SpeedValueType MaxXProbingSpeed_type;
      typedef ::xsd::cxx::tree::optional< MaxXProbingSpeed_type > MaxXProbingSpeed_optional;
      typedef ::xsd::cxx::tree::traits< MaxXProbingSpeed_type, wchar_t > MaxXProbingSpeed_traits;

      const MaxXProbingSpeed_optional&
      MaxXProbingSpeed () const;

      MaxXProbingSpeed_optional&
      MaxXProbingSpeed ();

      void
      MaxXProbingSpeed (const MaxXProbingSpeed_type& x);

      void
      MaxXProbingSpeed (const MaxXProbingSpeed_optional& x);

      void
      MaxXProbingSpeed (::std::unique_ptr< MaxXProbingSpeed_type > p);

      // MaxYProbingSpeed
      //
      typedef ::xsd::qif30::SpeedValueType MaxYProbingSpeed_type;
      typedef ::xsd::cxx::tree::optional< MaxYProbingSpeed_type > MaxYProbingSpeed_optional;
      typedef ::xsd::cxx::tree::traits< MaxYProbingSpeed_type, wchar_t > MaxYProbingSpeed_traits;

      const MaxYProbingSpeed_optional&
      MaxYProbingSpeed () const;

      MaxYProbingSpeed_optional&
      MaxYProbingSpeed ();

      void
      MaxYProbingSpeed (const MaxYProbingSpeed_type& x);

      void
      MaxYProbingSpeed (const MaxYProbingSpeed_optional& x);

      void
      MaxYProbingSpeed (::std::unique_ptr< MaxYProbingSpeed_type > p);

      // MaxZProbingSpeed
      //
      typedef ::xsd::qif30::SpeedValueType MaxZProbingSpeed_type;
      typedef ::xsd::cxx::tree::optional< MaxZProbingSpeed_type > MaxZProbingSpeed_optional;
      typedef ::xsd::cxx::tree::traits< MaxZProbingSpeed_type, wchar_t > MaxZProbingSpeed_traits;

      const MaxZProbingSpeed_optional&
      MaxZProbingSpeed () const;

      MaxZProbingSpeed_optional&
      MaxZProbingSpeed ();

      void
      MaxZProbingSpeed (const MaxZProbingSpeed_type& x);

      void
      MaxZProbingSpeed (const MaxZProbingSpeed_optional& x);

      void
      MaxZProbingSpeed (::std::unique_ptr< MaxZProbingSpeed_type > p);

      // Constructors.
      //
      CartesianCMMSpeedsType ();

      CartesianCMMSpeedsType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      CartesianCMMSpeedsType (const CartesianCMMSpeedsType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual CartesianCMMSpeedsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CartesianCMMSpeedsType&
      operator= (const CartesianCMMSpeedsType& x);

      virtual 
      ~CartesianCMMSpeedsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MaxXTraverseSpeed_optional MaxXTraverseSpeed_;
      MaxYTraverseSpeed_optional MaxYTraverseSpeed_;
      MaxZTraverseSpeed_optional MaxZTraverseSpeed_;
      MaxXProbingSpeed_optional MaxXProbingSpeed_;
      MaxYProbingSpeed_optional MaxYProbingSpeed_;
      MaxZProbingSpeed_optional MaxZProbingSpeed_;
    };

    class QIF30_SYMBOL_DECL ParallelLinkCMMSpeedsType: public ::xsd::qif30::CMMSpeedsBaseType
    {
      public:
      // MaxXTraverseSpeed
      //
      typedef ::xsd::qif30::SpeedValueType MaxXTraverseSpeed_type;
      typedef ::xsd::cxx::tree::optional< MaxXTraverseSpeed_type > MaxXTraverseSpeed_optional;
      typedef ::xsd::cxx::tree::traits< MaxXTraverseSpeed_type, wchar_t > MaxXTraverseSpeed_traits;

      const MaxXTraverseSpeed_optional&
      MaxXTraverseSpeed () const;

      MaxXTraverseSpeed_optional&
      MaxXTraverseSpeed ();

      void
      MaxXTraverseSpeed (const MaxXTraverseSpeed_type& x);

      void
      MaxXTraverseSpeed (const MaxXTraverseSpeed_optional& x);

      void
      MaxXTraverseSpeed (::std::unique_ptr< MaxXTraverseSpeed_type > p);

      // MaxYTraverseSpeed
      //
      typedef ::xsd::qif30::SpeedValueType MaxYTraverseSpeed_type;
      typedef ::xsd::cxx::tree::optional< MaxYTraverseSpeed_type > MaxYTraverseSpeed_optional;
      typedef ::xsd::cxx::tree::traits< MaxYTraverseSpeed_type, wchar_t > MaxYTraverseSpeed_traits;

      const MaxYTraverseSpeed_optional&
      MaxYTraverseSpeed () const;

      MaxYTraverseSpeed_optional&
      MaxYTraverseSpeed ();

      void
      MaxYTraverseSpeed (const MaxYTraverseSpeed_type& x);

      void
      MaxYTraverseSpeed (const MaxYTraverseSpeed_optional& x);

      void
      MaxYTraverseSpeed (::std::unique_ptr< MaxYTraverseSpeed_type > p);

      // MaxZTraverseSpeed
      //
      typedef ::xsd::qif30::SpeedValueType MaxZTraverseSpeed_type;
      typedef ::xsd::cxx::tree::optional< MaxZTraverseSpeed_type > MaxZTraverseSpeed_optional;
      typedef ::xsd::cxx::tree::traits< MaxZTraverseSpeed_type, wchar_t > MaxZTraverseSpeed_traits;

      const MaxZTraverseSpeed_optional&
      MaxZTraverseSpeed () const;

      MaxZTraverseSpeed_optional&
      MaxZTraverseSpeed ();

      void
      MaxZTraverseSpeed (const MaxZTraverseSpeed_type& x);

      void
      MaxZTraverseSpeed (const MaxZTraverseSpeed_optional& x);

      void
      MaxZTraverseSpeed (::std::unique_ptr< MaxZTraverseSpeed_type > p);

      // MaxXProbingSpeed
      //
      typedef ::xsd::qif30::SpeedValueType MaxXProbingSpeed_type;
      typedef ::xsd::cxx::tree::optional< MaxXProbingSpeed_type > MaxXProbingSpeed_optional;
      typedef ::xsd::cxx::tree::traits< MaxXProbingSpeed_type, wchar_t > MaxXProbingSpeed_traits;

      const MaxXProbingSpeed_optional&
      MaxXProbingSpeed () const;

      MaxXProbingSpeed_optional&
      MaxXProbingSpeed ();

      void
      MaxXProbingSpeed (const MaxXProbingSpeed_type& x);

      void
      MaxXProbingSpeed (const MaxXProbingSpeed_optional& x);

      void
      MaxXProbingSpeed (::std::unique_ptr< MaxXProbingSpeed_type > p);

      // MaxYProbingSpeed
      //
      typedef ::xsd::qif30::SpeedValueType MaxYProbingSpeed_type;
      typedef ::xsd::cxx::tree::optional< MaxYProbingSpeed_type > MaxYProbingSpeed_optional;
      typedef ::xsd::cxx::tree::traits< MaxYProbingSpeed_type, wchar_t > MaxYProbingSpeed_traits;

      const MaxYProbingSpeed_optional&
      MaxYProbingSpeed () const;

      MaxYProbingSpeed_optional&
      MaxYProbingSpeed ();

      void
      MaxYProbingSpeed (const MaxYProbingSpeed_type& x);

      void
      MaxYProbingSpeed (const MaxYProbingSpeed_optional& x);

      void
      MaxYProbingSpeed (::std::unique_ptr< MaxYProbingSpeed_type > p);

      // MaxZProbingSpeed
      //
      typedef ::xsd::qif30::SpeedValueType MaxZProbingSpeed_type;
      typedef ::xsd::cxx::tree::optional< MaxZProbingSpeed_type > MaxZProbingSpeed_optional;
      typedef ::xsd::cxx::tree::traits< MaxZProbingSpeed_type, wchar_t > MaxZProbingSpeed_traits;

      const MaxZProbingSpeed_optional&
      MaxZProbingSpeed () const;

      MaxZProbingSpeed_optional&
      MaxZProbingSpeed ();

      void
      MaxZProbingSpeed (const MaxZProbingSpeed_type& x);

      void
      MaxZProbingSpeed (const MaxZProbingSpeed_optional& x);

      void
      MaxZProbingSpeed (::std::unique_ptr< MaxZProbingSpeed_type > p);

      // MaxXRotation
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType MaxXRotation_type;
      typedef ::xsd::cxx::tree::optional< MaxXRotation_type > MaxXRotation_optional;
      typedef ::xsd::cxx::tree::traits< MaxXRotation_type, wchar_t > MaxXRotation_traits;

      const MaxXRotation_optional&
      MaxXRotation () const;

      MaxXRotation_optional&
      MaxXRotation ();

      void
      MaxXRotation (const MaxXRotation_type& x);

      void
      MaxXRotation (const MaxXRotation_optional& x);

      void
      MaxXRotation (::std::unique_ptr< MaxXRotation_type > p);

      // MaxYRotation
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType MaxYRotation_type;
      typedef ::xsd::cxx::tree::optional< MaxYRotation_type > MaxYRotation_optional;
      typedef ::xsd::cxx::tree::traits< MaxYRotation_type, wchar_t > MaxYRotation_traits;

      const MaxYRotation_optional&
      MaxYRotation () const;

      MaxYRotation_optional&
      MaxYRotation ();

      void
      MaxYRotation (const MaxYRotation_type& x);

      void
      MaxYRotation (const MaxYRotation_optional& x);

      void
      MaxYRotation (::std::unique_ptr< MaxYRotation_type > p);

      // MaxZRotation
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType MaxZRotation_type;
      typedef ::xsd::cxx::tree::optional< MaxZRotation_type > MaxZRotation_optional;
      typedef ::xsd::cxx::tree::traits< MaxZRotation_type, wchar_t > MaxZRotation_traits;

      const MaxZRotation_optional&
      MaxZRotation () const;

      MaxZRotation_optional&
      MaxZRotation ();

      void
      MaxZRotation (const MaxZRotation_type& x);

      void
      MaxZRotation (const MaxZRotation_optional& x);

      void
      MaxZRotation (::std::unique_ptr< MaxZRotation_type > p);

      // Constructors.
      //
      ParallelLinkCMMSpeedsType ();

      ParallelLinkCMMSpeedsType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      ParallelLinkCMMSpeedsType (const ParallelLinkCMMSpeedsType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual ParallelLinkCMMSpeedsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ParallelLinkCMMSpeedsType&
      operator= (const ParallelLinkCMMSpeedsType& x);

      virtual 
      ~ParallelLinkCMMSpeedsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MaxXTraverseSpeed_optional MaxXTraverseSpeed_;
      MaxYTraverseSpeed_optional MaxYTraverseSpeed_;
      MaxZTraverseSpeed_optional MaxZTraverseSpeed_;
      MaxXProbingSpeed_optional MaxXProbingSpeed_;
      MaxYProbingSpeed_optional MaxYProbingSpeed_;
      MaxZProbingSpeed_optional MaxZProbingSpeed_;
      MaxXRotation_optional MaxXRotation_;
      MaxYRotation_optional MaxYRotation_;
      MaxZRotation_optional MaxZRotation_;
    };

    class QIF30_SYMBOL_DECL FunctionDiscreteType: public ::xml_schema::type
    {
      public:
      // DomainValues
      //
      typedef ::xsd::qif30::ListDoubleType DomainValues_type;
      typedef ::xsd::cxx::tree::traits< DomainValues_type, wchar_t > DomainValues_traits;

      const DomainValues_type&
      DomainValues () const;

      DomainValues_type&
      DomainValues ();

      void
      DomainValues (const DomainValues_type& x);

      void
      DomainValues (::std::unique_ptr< DomainValues_type > p);

      // RangeValues
      //
      typedef ::xsd::qif30::ListDoubleType RangeValues_type;
      typedef ::xsd::cxx::tree::traits< RangeValues_type, wchar_t > RangeValues_traits;

      const RangeValues_type&
      RangeValues () const;

      RangeValues_type&
      RangeValues ();

      void
      RangeValues (const RangeValues_type& x);

      void
      RangeValues (::std::unique_ptr< RangeValues_type > p);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      FunctionDiscreteType ();

      FunctionDiscreteType (const DomainValues_type&,
                            const RangeValues_type&,
                            const n_type&);

      FunctionDiscreteType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      FunctionDiscreteType (const FunctionDiscreteType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual FunctionDiscreteType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FunctionDiscreteType&
      operator= (const FunctionDiscreteType& x);

      virtual 
      ~FunctionDiscreteType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DomainValues_type > DomainValues_;
      ::xsd::cxx::tree::one< RangeValues_type > RangeValues_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL LengthFunctionDiscreteType: public ::xsd::qif30::FunctionDiscreteType
    {
      public:
      // DomainLinearUnit
      //
      typedef ::xml_schema::token DomainLinearUnit_type;
      typedef ::xsd::cxx::tree::traits< DomainLinearUnit_type, wchar_t > DomainLinearUnit_traits;

      const DomainLinearUnit_type&
      DomainLinearUnit () const;

      DomainLinearUnit_type&
      DomainLinearUnit ();

      void
      DomainLinearUnit (const DomainLinearUnit_type& x);

      void
      DomainLinearUnit (::std::unique_ptr< DomainLinearUnit_type > p);

      // RangeLinearUnit
      //
      typedef ::xml_schema::token RangeLinearUnit_type;
      typedef ::xsd::cxx::tree::traits< RangeLinearUnit_type, wchar_t > RangeLinearUnit_traits;

      const RangeLinearUnit_type&
      RangeLinearUnit () const;

      RangeLinearUnit_type&
      RangeLinearUnit ();

      void
      RangeLinearUnit (const RangeLinearUnit_type& x);

      void
      RangeLinearUnit (::std::unique_ptr< RangeLinearUnit_type > p);

      // Constructors.
      //
      LengthFunctionDiscreteType ();

      LengthFunctionDiscreteType (const DomainValues_type&,
                                  const RangeValues_type&,
                                  const n_type&,
                                  const DomainLinearUnit_type&,
                                  const RangeLinearUnit_type&);

      LengthFunctionDiscreteType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      LengthFunctionDiscreteType (const LengthFunctionDiscreteType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual LengthFunctionDiscreteType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LengthFunctionDiscreteType&
      operator= (const LengthFunctionDiscreteType& x);

      virtual 
      ~LengthFunctionDiscreteType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DomainLinearUnit_type > DomainLinearUnit_;
      ::xsd::cxx::tree::one< RangeLinearUnit_type > RangeLinearUnit_;
    };

    class QIF30_SYMBOL_DECL AngleFunctionDiscreteType: public ::xsd::qif30::FunctionDiscreteType
    {
      public:
      // DomainLinearUnit
      //
      typedef ::xml_schema::token DomainLinearUnit_type;
      typedef ::xsd::cxx::tree::traits< DomainLinearUnit_type, wchar_t > DomainLinearUnit_traits;

      const DomainLinearUnit_type&
      DomainLinearUnit () const;

      DomainLinearUnit_type&
      DomainLinearUnit ();

      void
      DomainLinearUnit (const DomainLinearUnit_type& x);

      void
      DomainLinearUnit (::std::unique_ptr< DomainLinearUnit_type > p);

      // RangeAngularUnit
      //
      typedef ::xml_schema::token RangeAngularUnit_type;
      typedef ::xsd::cxx::tree::traits< RangeAngularUnit_type, wchar_t > RangeAngularUnit_traits;

      const RangeAngularUnit_type&
      RangeAngularUnit () const;

      RangeAngularUnit_type&
      RangeAngularUnit ();

      void
      RangeAngularUnit (const RangeAngularUnit_type& x);

      void
      RangeAngularUnit (::std::unique_ptr< RangeAngularUnit_type > p);

      // Constructors.
      //
      AngleFunctionDiscreteType ();

      AngleFunctionDiscreteType (const DomainValues_type&,
                                 const RangeValues_type&,
                                 const n_type&,
                                 const DomainLinearUnit_type&,
                                 const RangeAngularUnit_type&);

      AngleFunctionDiscreteType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      AngleFunctionDiscreteType (const AngleFunctionDiscreteType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual AngleFunctionDiscreteType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AngleFunctionDiscreteType&
      operator= (const AngleFunctionDiscreteType& x);

      virtual 
      ~AngleFunctionDiscreteType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DomainLinearUnit_type > DomainLinearUnit_;
      ::xsd::cxx::tree::one< RangeAngularUnit_type > RangeAngularUnit_;
    };

    class QIF30_SYMBOL_DECL MeasurementDeviceAccuracyBaseType: public ::xml_schema::type
    {
      public:
      // EnvironmentalRange
      //
      typedef ::xsd::qif30::EnvironmentalRangeType EnvironmentalRange_type;
      typedef ::xsd::cxx::tree::traits< EnvironmentalRange_type, wchar_t > EnvironmentalRange_traits;

      const EnvironmentalRange_type&
      EnvironmentalRange () const;

      EnvironmentalRange_type&
      EnvironmentalRange ();

      void
      EnvironmentalRange (const EnvironmentalRange_type& x);

      void
      EnvironmentalRange (::std::unique_ptr< EnvironmentalRange_type > p);

      // Constructors.
      //
      MeasurementDeviceAccuracyBaseType ();

      MeasurementDeviceAccuracyBaseType (const EnvironmentalRange_type&);

      MeasurementDeviceAccuracyBaseType (::std::unique_ptr< EnvironmentalRange_type >);

      MeasurementDeviceAccuracyBaseType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      MeasurementDeviceAccuracyBaseType (const MeasurementDeviceAccuracyBaseType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual MeasurementDeviceAccuracyBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      MeasurementDeviceAccuracyBaseType&
      operator= (const MeasurementDeviceAccuracyBaseType& x);

      virtual 
      ~MeasurementDeviceAccuracyBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< EnvironmentalRange_type > EnvironmentalRange_;
    };

    class QIF30_SYMBOL_DECL NumericalLengthAccuracyType: public ::xsd::qif30::MeasurementDeviceAccuracyBaseType
    {
      public:
      // AccuracyValue
      //
      typedef ::xsd::qif30::LinearValueType AccuracyValue_type;
      typedef ::xsd::cxx::tree::traits< AccuracyValue_type, wchar_t > AccuracyValue_traits;

      const AccuracyValue_type&
      AccuracyValue () const;

      AccuracyValue_type&
      AccuracyValue ();

      void
      AccuracyValue (const AccuracyValue_type& x);

      void
      AccuracyValue (::std::unique_ptr< AccuracyValue_type > p);

      // Constructors.
      //
      NumericalLengthAccuracyType ();

      NumericalLengthAccuracyType (const EnvironmentalRange_type&,
                                   const AccuracyValue_type&);

      NumericalLengthAccuracyType (::std::unique_ptr< EnvironmentalRange_type >,
                                   ::std::unique_ptr< AccuracyValue_type >);

      NumericalLengthAccuracyType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      NumericalLengthAccuracyType (const NumericalLengthAccuracyType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual NumericalLengthAccuracyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      NumericalLengthAccuracyType&
      operator= (const NumericalLengthAccuracyType& x);

      virtual 
      ~NumericalLengthAccuracyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< AccuracyValue_type > AccuracyValue_;
    };

    class QIF30_SYMBOL_DECL EnvironmentalRangeType: public ::xml_schema::type
    {
      public:
      // Name
      //
      typedef ::xml_schema::nmtoken Name_type;
      typedef ::xsd::cxx::tree::optional< Name_type > Name_optional;
      typedef ::xsd::cxx::tree::traits< Name_type, wchar_t > Name_traits;

      const Name_optional&
      Name () const;

      Name_optional&
      Name ();

      void
      Name (const Name_type& x);

      void
      Name (const Name_optional& x);

      void
      Name (::std::unique_ptr< Name_type > p);

      // Description
      //
      typedef ::xml_schema::string Description_type;
      typedef ::xsd::cxx::tree::optional< Description_type > Description_optional;
      typedef ::xsd::cxx::tree::traits< Description_type, wchar_t > Description_traits;

      const Description_optional&
      Description () const;

      Description_optional&
      Description ();

      void
      Description (const Description_type& x);

      void
      Description (const Description_optional& x);

      void
      Description (::std::unique_ptr< Description_type > p);

      // MaxAmbientTemperature
      //
      typedef ::xsd::qif30::TemperatureValueType MaxAmbientTemperature_type;
      typedef ::xsd::cxx::tree::optional< MaxAmbientTemperature_type > MaxAmbientTemperature_optional;
      typedef ::xsd::cxx::tree::traits< MaxAmbientTemperature_type, wchar_t > MaxAmbientTemperature_traits;

      const MaxAmbientTemperature_optional&
      MaxAmbientTemperature () const;

      MaxAmbientTemperature_optional&
      MaxAmbientTemperature ();

      void
      MaxAmbientTemperature (const MaxAmbientTemperature_type& x);

      void
      MaxAmbientTemperature (const MaxAmbientTemperature_optional& x);

      void
      MaxAmbientTemperature (::std::unique_ptr< MaxAmbientTemperature_type > p);

      // MinAmbientTemperature
      //
      typedef ::xsd::qif30::TemperatureValueType MinAmbientTemperature_type;
      typedef ::xsd::cxx::tree::optional< MinAmbientTemperature_type > MinAmbientTemperature_optional;
      typedef ::xsd::cxx::tree::traits< MinAmbientTemperature_type, wchar_t > MinAmbientTemperature_traits;

      const MinAmbientTemperature_optional&
      MinAmbientTemperature () const;

      MinAmbientTemperature_optional&
      MinAmbientTemperature ();

      void
      MinAmbientTemperature (const MinAmbientTemperature_type& x);

      void
      MinAmbientTemperature (const MinAmbientTemperature_optional& x);

      void
      MinAmbientTemperature (::std::unique_ptr< MinAmbientTemperature_type > p);

      // MaxAmbientAirPressure
      //
      typedef ::xsd::qif30::PressureValueType MaxAmbientAirPressure_type;
      typedef ::xsd::cxx::tree::optional< MaxAmbientAirPressure_type > MaxAmbientAirPressure_optional;
      typedef ::xsd::cxx::tree::traits< MaxAmbientAirPressure_type, wchar_t > MaxAmbientAirPressure_traits;

      const MaxAmbientAirPressure_optional&
      MaxAmbientAirPressure () const;

      MaxAmbientAirPressure_optional&
      MaxAmbientAirPressure ();

      void
      MaxAmbientAirPressure (const MaxAmbientAirPressure_type& x);

      void
      MaxAmbientAirPressure (const MaxAmbientAirPressure_optional& x);

      void
      MaxAmbientAirPressure (::std::unique_ptr< MaxAmbientAirPressure_type > p);

      // MinAmbientAirPressure
      //
      typedef ::xsd::qif30::PressureValueType MinAmbientAirPressure_type;
      typedef ::xsd::cxx::tree::optional< MinAmbientAirPressure_type > MinAmbientAirPressure_optional;
      typedef ::xsd::cxx::tree::traits< MinAmbientAirPressure_type, wchar_t > MinAmbientAirPressure_traits;

      const MinAmbientAirPressure_optional&
      MinAmbientAirPressure () const;

      MinAmbientAirPressure_optional&
      MinAmbientAirPressure ();

      void
      MinAmbientAirPressure (const MinAmbientAirPressure_type& x);

      void
      MinAmbientAirPressure (const MinAmbientAirPressure_optional& x);

      void
      MinAmbientAirPressure (::std::unique_ptr< MinAmbientAirPressure_type > p);

      // MaxAmbientRelativeHumidity
      //
      typedef ::xsd::qif30::SpecifiedDecimalType MaxAmbientRelativeHumidity_type;
      typedef ::xsd::cxx::tree::optional< MaxAmbientRelativeHumidity_type > MaxAmbientRelativeHumidity_optional;
      typedef ::xsd::cxx::tree::traits< MaxAmbientRelativeHumidity_type, wchar_t > MaxAmbientRelativeHumidity_traits;

      const MaxAmbientRelativeHumidity_optional&
      MaxAmbientRelativeHumidity () const;

      MaxAmbientRelativeHumidity_optional&
      MaxAmbientRelativeHumidity ();

      void
      MaxAmbientRelativeHumidity (const MaxAmbientRelativeHumidity_type& x);

      void
      MaxAmbientRelativeHumidity (const MaxAmbientRelativeHumidity_optional& x);

      void
      MaxAmbientRelativeHumidity (::std::unique_ptr< MaxAmbientRelativeHumidity_type > p);

      // MinAmbientRelativeHumidity
      //
      typedef ::xsd::qif30::SpecifiedDecimalType MinAmbientRelativeHumidity_type;
      typedef ::xsd::cxx::tree::optional< MinAmbientRelativeHumidity_type > MinAmbientRelativeHumidity_optional;
      typedef ::xsd::cxx::tree::traits< MinAmbientRelativeHumidity_type, wchar_t > MinAmbientRelativeHumidity_traits;

      const MinAmbientRelativeHumidity_optional&
      MinAmbientRelativeHumidity () const;

      MinAmbientRelativeHumidity_optional&
      MinAmbientRelativeHumidity ();

      void
      MinAmbientRelativeHumidity (const MinAmbientRelativeHumidity_type& x);

      void
      MinAmbientRelativeHumidity (const MinAmbientRelativeHumidity_optional& x);

      void
      MinAmbientRelativeHumidity (::std::unique_ptr< MinAmbientRelativeHumidity_type > p);

      // MaxVibration
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType MaxVibration_type;
      typedef ::xsd::cxx::tree::optional< MaxVibration_type > MaxVibration_optional;
      typedef ::xsd::cxx::tree::traits< MaxVibration_type, wchar_t > MaxVibration_traits;

      const MaxVibration_optional&
      MaxVibration () const;

      MaxVibration_optional&
      MaxVibration ();

      void
      MaxVibration (const MaxVibration_type& x);

      void
      MaxVibration (const MaxVibration_optional& x);

      void
      MaxVibration (::std::unique_ptr< MaxVibration_type > p);

      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // Constructors.
      //
      EnvironmentalRangeType ();

      EnvironmentalRangeType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      EnvironmentalRangeType (const EnvironmentalRangeType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual EnvironmentalRangeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EnvironmentalRangeType&
      operator= (const EnvironmentalRangeType& x);

      virtual 
      ~EnvironmentalRangeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Name_optional Name_;
      Description_optional Description_;
      MaxAmbientTemperature_optional MaxAmbientTemperature_;
      MinAmbientTemperature_optional MinAmbientTemperature_;
      MaxAmbientAirPressure_optional MaxAmbientAirPressure_;
      MinAmbientAirPressure_optional MinAmbientAirPressure_;
      MaxAmbientRelativeHumidity_optional MaxAmbientRelativeHumidity_;
      MinAmbientRelativeHumidity_optional MinAmbientRelativeHumidity_;
      MaxVibration_optional MaxVibration_;
      Attributes_optional Attributes_;
    };

    class QIF30_SYMBOL_DECL CartesianCMMAccuracyType: public ::xsd::qif30::MeasurementDeviceAccuracyBaseType
    {
      public:
      // CartesianCMMAccuracyTest
      //
      typedef ::xsd::qif30::CMMAccuracyTestBaseType CartesianCMMAccuracyTest_type;
      typedef ::xsd::cxx::tree::traits< CartesianCMMAccuracyTest_type, wchar_t > CartesianCMMAccuracyTest_traits;

      const CartesianCMMAccuracyTest_type&
      CartesianCMMAccuracyTest () const;

      CartesianCMMAccuracyTest_type&
      CartesianCMMAccuracyTest ();

      void
      CartesianCMMAccuracyTest (const CartesianCMMAccuracyTest_type& x);

      void
      CartesianCMMAccuracyTest (::std::unique_ptr< CartesianCMMAccuracyTest_type > p);

      // AccuracySource
      //
      typedef ::xsd::qif30::AccuracySourceType AccuracySource_type;
      typedef ::xsd::cxx::tree::traits< AccuracySource_type, wchar_t > AccuracySource_traits;

      const AccuracySource_type&
      AccuracySource () const;

      AccuracySource_type&
      AccuracySource ();

      void
      AccuracySource (const AccuracySource_type& x);

      void
      AccuracySource (::std::unique_ptr< AccuracySource_type > p);

      // Constructors.
      //
      CartesianCMMAccuracyType ();

      CartesianCMMAccuracyType (const EnvironmentalRange_type&,
                                const CartesianCMMAccuracyTest_type&,
                                const AccuracySource_type&);

      CartesianCMMAccuracyType (::std::unique_ptr< EnvironmentalRange_type >,
                                const CartesianCMMAccuracyTest_type&,
                                ::std::unique_ptr< AccuracySource_type >);

      CartesianCMMAccuracyType (const EnvironmentalRange_type&,
                                ::std::unique_ptr< CartesianCMMAccuracyTest_type >,
                                const AccuracySource_type&);

      CartesianCMMAccuracyType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      CartesianCMMAccuracyType (const CartesianCMMAccuracyType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual CartesianCMMAccuracyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CartesianCMMAccuracyType&
      operator= (const CartesianCMMAccuracyType& x);

      virtual 
      ~CartesianCMMAccuracyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< CartesianCMMAccuracyTest_type > CartesianCMMAccuracyTest_;
      ::xsd::cxx::tree::one< AccuracySource_type > AccuracySource_;
    };

    class QIF30_SYMBOL_DECL AACMMAccuracyType: public ::xsd::qif30::MeasurementDeviceAccuracyBaseType
    {
      public:
      // AACMMAccuracyTest
      //
      typedef ::xsd::qif30::CMMAccuracyTestBaseType AACMMAccuracyTest_type;
      typedef ::xsd::cxx::tree::traits< AACMMAccuracyTest_type, wchar_t > AACMMAccuracyTest_traits;

      const AACMMAccuracyTest_type&
      AACMMAccuracyTest () const;

      AACMMAccuracyTest_type&
      AACMMAccuracyTest ();

      void
      AACMMAccuracyTest (const AACMMAccuracyTest_type& x);

      void
      AACMMAccuracyTest (::std::unique_ptr< AACMMAccuracyTest_type > p);

      // AccuracySource
      //
      typedef ::xsd::qif30::AccuracySourceType AccuracySource_type;
      typedef ::xsd::cxx::tree::traits< AccuracySource_type, wchar_t > AccuracySource_traits;

      const AccuracySource_type&
      AccuracySource () const;

      AccuracySource_type&
      AccuracySource ();

      void
      AccuracySource (const AccuracySource_type& x);

      void
      AccuracySource (::std::unique_ptr< AccuracySource_type > p);

      // Constructors.
      //
      AACMMAccuracyType ();

      AACMMAccuracyType (const EnvironmentalRange_type&,
                         const AACMMAccuracyTest_type&,
                         const AccuracySource_type&);

      AACMMAccuracyType (::std::unique_ptr< EnvironmentalRange_type >,
                         const AACMMAccuracyTest_type&,
                         ::std::unique_ptr< AccuracySource_type >);

      AACMMAccuracyType (const EnvironmentalRange_type&,
                         ::std::unique_ptr< AACMMAccuracyTest_type >,
                         const AccuracySource_type&);

      AACMMAccuracyType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      AACMMAccuracyType (const AACMMAccuracyType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual AACMMAccuracyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AACMMAccuracyType&
      operator= (const AACMMAccuracyType& x);

      virtual 
      ~AACMMAccuracyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< AACMMAccuracyTest_type > AACMMAccuracyTest_;
      ::xsd::cxx::tree::one< AccuracySource_type > AccuracySource_;
    };

    class QIF30_SYMBOL_DECL CartesianCMMAccuraciesType: public ::xml_schema::type
    {
      public:
      // CartesianCMMAccuracy
      //
      typedef ::xsd::qif30::CartesianCMMAccuracyType CartesianCMMAccuracy_type;
      typedef ::xsd::cxx::tree::sequence< CartesianCMMAccuracy_type > CartesianCMMAccuracy_sequence;
      typedef xsd::cxx::tree::sequence< CartesianCMMAccuracy_type >::iterator CartesianCMMAccuracy_iterator;
      typedef xsd::cxx::tree::sequence< CartesianCMMAccuracy_type >::const_iterator CartesianCMMAccuracy_const_iterator;
      typedef ::xsd::cxx::tree::traits< CartesianCMMAccuracy_type, wchar_t > CartesianCMMAccuracy_traits;

      const CartesianCMMAccuracy_sequence&
      CartesianCMMAccuracy () const;

      CartesianCMMAccuracy_sequence&
      CartesianCMMAccuracy ();

      void
      CartesianCMMAccuracy (const CartesianCMMAccuracy_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      CartesianCMMAccuraciesType ();

      CartesianCMMAccuraciesType (const n_type&);

      CartesianCMMAccuraciesType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      CartesianCMMAccuraciesType (const CartesianCMMAccuraciesType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual CartesianCMMAccuraciesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CartesianCMMAccuraciesType&
      operator= (const CartesianCMMAccuraciesType& x);

      virtual 
      ~CartesianCMMAccuraciesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CartesianCMMAccuracy_sequence CartesianCMMAccuracy_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL AACMMAccuraciesType: public ::xml_schema::type
    {
      public:
      // AACMMAccuracy
      //
      typedef ::xsd::qif30::AACMMAccuracyType AACMMAccuracy_type;
      typedef ::xsd::cxx::tree::sequence< AACMMAccuracy_type > AACMMAccuracy_sequence;
      typedef xsd::cxx::tree::sequence< AACMMAccuracy_type >::iterator AACMMAccuracy_iterator;
      typedef xsd::cxx::tree::sequence< AACMMAccuracy_type >::const_iterator AACMMAccuracy_const_iterator;
      typedef ::xsd::cxx::tree::traits< AACMMAccuracy_type, wchar_t > AACMMAccuracy_traits;

      const AACMMAccuracy_sequence&
      AACMMAccuracy () const;

      AACMMAccuracy_sequence&
      AACMMAccuracy ();

      void
      AACMMAccuracy (const AACMMAccuracy_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      AACMMAccuraciesType ();

      AACMMAccuraciesType (const n_type&);

      AACMMAccuraciesType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      AACMMAccuraciesType (const AACMMAccuraciesType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual AACMMAccuraciesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AACMMAccuraciesType&
      operator= (const AACMMAccuraciesType& x);

      virtual 
      ~AACMMAccuraciesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      AACMMAccuracy_sequence AACMMAccuracy_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL AccuracySourceType: public ::xml_schema::type
    {
      public:
      // AccuracySourceEnum
      //
      typedef ::xsd::qif30::AccuracySourceEnumType AccuracySourceEnum_type;
      typedef ::xsd::cxx::tree::optional< AccuracySourceEnum_type > AccuracySourceEnum_optional;
      typedef ::xsd::cxx::tree::traits< AccuracySourceEnum_type, wchar_t > AccuracySourceEnum_traits;

      const AccuracySourceEnum_optional&
      AccuracySourceEnum () const;

      AccuracySourceEnum_optional&
      AccuracySourceEnum ();

      void
      AccuracySourceEnum (const AccuracySourceEnum_type& x);

      void
      AccuracySourceEnum (const AccuracySourceEnum_optional& x);

      void
      AccuracySourceEnum (::std::unique_ptr< AccuracySourceEnum_type > p);

      // OtherAccuracySource
      //
      typedef ::xml_schema::string OtherAccuracySource_type;
      typedef ::xsd::cxx::tree::optional< OtherAccuracySource_type > OtherAccuracySource_optional;
      typedef ::xsd::cxx::tree::traits< OtherAccuracySource_type, wchar_t > OtherAccuracySource_traits;

      const OtherAccuracySource_optional&
      OtherAccuracySource () const;

      OtherAccuracySource_optional&
      OtherAccuracySource ();

      void
      OtherAccuracySource (const OtherAccuracySource_type& x);

      void
      OtherAccuracySource (const OtherAccuracySource_optional& x);

      void
      OtherAccuracySource (::std::unique_ptr< OtherAccuracySource_type > p);

      // Constructors.
      //
      AccuracySourceType ();

      AccuracySourceType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      AccuracySourceType (const AccuracySourceType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual AccuracySourceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AccuracySourceType&
      operator= (const AccuracySourceType& x);

      virtual 
      ~AccuracySourceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      AccuracySourceEnum_optional AccuracySourceEnum_;
      OtherAccuracySource_optional OtherAccuracySource_;
    };

    class QIF30_SYMBOL_DECL AccuracySourceEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        MANUFACTURER_SPECIFICATION,
        CUSTOM_CERTIFICATION
      };

      AccuracySourceEnumType ();

      AccuracySourceEnumType (value v);

      AccuracySourceEnumType (const wchar_t* v);

      AccuracySourceEnumType (const ::std::wstring& v);

      AccuracySourceEnumType (const ::xml_schema::nmtoken& v);

      AccuracySourceEnumType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      AccuracySourceEnumType (const xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      AccuracySourceEnumType (const ::std::wstring& s,
                              const xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      AccuracySourceEnumType (const AccuracySourceEnumType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      AccuracySourceEnumType&
      operator= (const AccuracySourceEnumType&) = default;
#endif

      virtual AccuracySourceEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AccuracySourceEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_AccuracySourceEnumType_convert ();
      }

      protected:
      value
      _xsd_AccuracySourceEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_AccuracySourceEnumType_literals_[2];
      static const value _xsd_AccuracySourceEnumType_indexes_[2];
    };

    class QIF30_SYMBOL_DECL CMMAccuracyTestBaseType: public ::xml_schema::type
    {
      public:
      // Constructors.
      //
      CMMAccuracyTestBaseType ();

      CMMAccuracyTestBaseType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      CMMAccuracyTestBaseType (const xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      CMMAccuracyTestBaseType (const ::std::wstring& s,
                               const xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      CMMAccuracyTestBaseType (const CMMAccuracyTestBaseType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual CMMAccuracyTestBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      CMMAccuracyTestBaseType&
      operator= (const CMMAccuracyTestBaseType&) = default;
#endif

      virtual 
      ~CMMAccuracyTestBaseType ();
    };

    class QIF30_SYMBOL_DECL FPSTestType: public ::xsd::qif30::CMMAccuracyTestBaseType
    {
      public:
      // XLinearity
      //
      typedef ::xsd::qif30::LengthFunctionDiscreteType XLinearity_type;
      typedef ::xsd::cxx::tree::traits< XLinearity_type, wchar_t > XLinearity_traits;

      const XLinearity_type&
      XLinearity () const;

      XLinearity_type&
      XLinearity ();

      void
      XLinearity (const XLinearity_type& x);

      void
      XLinearity (::std::unique_ptr< XLinearity_type > p);

      // YLinearity
      //
      typedef ::xsd::qif30::LengthFunctionDiscreteType YLinearity_type;
      typedef ::xsd::cxx::tree::traits< YLinearity_type, wchar_t > YLinearity_traits;

      const YLinearity_type&
      YLinearity () const;

      YLinearity_type&
      YLinearity ();

      void
      YLinearity (const YLinearity_type& x);

      void
      YLinearity (::std::unique_ptr< YLinearity_type > p);

      // ZLinearity
      //
      typedef ::xsd::qif30::LengthFunctionDiscreteType ZLinearity_type;
      typedef ::xsd::cxx::tree::traits< ZLinearity_type, wchar_t > ZLinearity_traits;

      const ZLinearity_type&
      ZLinearity () const;

      ZLinearity_type&
      ZLinearity ();

      void
      ZLinearity (const ZLinearity_type& x);

      void
      ZLinearity (::std::unique_ptr< ZLinearity_type > p);

      // XAxisRoll
      //
      typedef ::xsd::qif30::AngleFunctionDiscreteType XAxisRoll_type;
      typedef ::xsd::cxx::tree::traits< XAxisRoll_type, wchar_t > XAxisRoll_traits;

      const XAxisRoll_type&
      XAxisRoll () const;

      XAxisRoll_type&
      XAxisRoll ();

      void
      XAxisRoll (const XAxisRoll_type& x);

      void
      XAxisRoll (::std::unique_ptr< XAxisRoll_type > p);

      // XAxisPitch
      //
      typedef ::xsd::qif30::AngleFunctionDiscreteType XAxisPitch_type;
      typedef ::xsd::cxx::tree::traits< XAxisPitch_type, wchar_t > XAxisPitch_traits;

      const XAxisPitch_type&
      XAxisPitch () const;

      XAxisPitch_type&
      XAxisPitch ();

      void
      XAxisPitch (const XAxisPitch_type& x);

      void
      XAxisPitch (::std::unique_ptr< XAxisPitch_type > p);

      // XAxisYaw
      //
      typedef ::xsd::qif30::AngleFunctionDiscreteType XAxisYaw_type;
      typedef ::xsd::cxx::tree::traits< XAxisYaw_type, wchar_t > XAxisYaw_traits;

      const XAxisYaw_type&
      XAxisYaw () const;

      XAxisYaw_type&
      XAxisYaw ();

      void
      XAxisYaw (const XAxisYaw_type& x);

      void
      XAxisYaw (::std::unique_ptr< XAxisYaw_type > p);

      // YAxisRoll
      //
      typedef ::xsd::qif30::AngleFunctionDiscreteType YAxisRoll_type;
      typedef ::xsd::cxx::tree::traits< YAxisRoll_type, wchar_t > YAxisRoll_traits;

      const YAxisRoll_type&
      YAxisRoll () const;

      YAxisRoll_type&
      YAxisRoll ();

      void
      YAxisRoll (const YAxisRoll_type& x);

      void
      YAxisRoll (::std::unique_ptr< YAxisRoll_type > p);

      // YAxisPitch
      //
      typedef ::xsd::qif30::AngleFunctionDiscreteType YAxisPitch_type;
      typedef ::xsd::cxx::tree::traits< YAxisPitch_type, wchar_t > YAxisPitch_traits;

      const YAxisPitch_type&
      YAxisPitch () const;

      YAxisPitch_type&
      YAxisPitch ();

      void
      YAxisPitch (const YAxisPitch_type& x);

      void
      YAxisPitch (::std::unique_ptr< YAxisPitch_type > p);

      // YAxisYaw
      //
      typedef ::xsd::qif30::AngleFunctionDiscreteType YAxisYaw_type;
      typedef ::xsd::cxx::tree::traits< YAxisYaw_type, wchar_t > YAxisYaw_traits;

      const YAxisYaw_type&
      YAxisYaw () const;

      YAxisYaw_type&
      YAxisYaw ();

      void
      YAxisYaw (const YAxisYaw_type& x);

      void
      YAxisYaw (::std::unique_ptr< YAxisYaw_type > p);

      // ZAxisRoll
      //
      typedef ::xsd::qif30::AngleFunctionDiscreteType ZAxisRoll_type;
      typedef ::xsd::cxx::tree::traits< ZAxisRoll_type, wchar_t > ZAxisRoll_traits;

      const ZAxisRoll_type&
      ZAxisRoll () const;

      ZAxisRoll_type&
      ZAxisRoll ();

      void
      ZAxisRoll (const ZAxisRoll_type& x);

      void
      ZAxisRoll (::std::unique_ptr< ZAxisRoll_type > p);

      // ZAxisPitch
      //
      typedef ::xsd::qif30::AngleFunctionDiscreteType ZAxisPitch_type;
      typedef ::xsd::cxx::tree::traits< ZAxisPitch_type, wchar_t > ZAxisPitch_traits;

      const ZAxisPitch_type&
      ZAxisPitch () const;

      ZAxisPitch_type&
      ZAxisPitch ();

      void
      ZAxisPitch (const ZAxisPitch_type& x);

      void
      ZAxisPitch (::std::unique_ptr< ZAxisPitch_type > p);

      // ZAxisYaw
      //
      typedef ::xsd::qif30::AngleFunctionDiscreteType ZAxisYaw_type;
      typedef ::xsd::cxx::tree::traits< ZAxisYaw_type, wchar_t > ZAxisYaw_traits;

      const ZAxisYaw_type&
      ZAxisYaw () const;

      ZAxisYaw_type&
      ZAxisYaw ();

      void
      ZAxisYaw (const ZAxisYaw_type& x);

      void
      ZAxisYaw (::std::unique_ptr< ZAxisYaw_type > p);

      // XAxisStraightnessY
      //
      typedef ::xsd::qif30::LengthFunctionDiscreteType XAxisStraightnessY_type;
      typedef ::xsd::cxx::tree::traits< XAxisStraightnessY_type, wchar_t > XAxisStraightnessY_traits;

      const XAxisStraightnessY_type&
      XAxisStraightnessY () const;

      XAxisStraightnessY_type&
      XAxisStraightnessY ();

      void
      XAxisStraightnessY (const XAxisStraightnessY_type& x);

      void
      XAxisStraightnessY (::std::unique_ptr< XAxisStraightnessY_type > p);

      // XAxisStraightnessZ
      //
      typedef ::xsd::qif30::LengthFunctionDiscreteType XAxisStraightnessZ_type;
      typedef ::xsd::cxx::tree::traits< XAxisStraightnessZ_type, wchar_t > XAxisStraightnessZ_traits;

      const XAxisStraightnessZ_type&
      XAxisStraightnessZ () const;

      XAxisStraightnessZ_type&
      XAxisStraightnessZ ();

      void
      XAxisStraightnessZ (const XAxisStraightnessZ_type& x);

      void
      XAxisStraightnessZ (::std::unique_ptr< XAxisStraightnessZ_type > p);

      // YAxisStraightnessX
      //
      typedef ::xsd::qif30::LengthFunctionDiscreteType YAxisStraightnessX_type;
      typedef ::xsd::cxx::tree::traits< YAxisStraightnessX_type, wchar_t > YAxisStraightnessX_traits;

      const YAxisStraightnessX_type&
      YAxisStraightnessX () const;

      YAxisStraightnessX_type&
      YAxisStraightnessX ();

      void
      YAxisStraightnessX (const YAxisStraightnessX_type& x);

      void
      YAxisStraightnessX (::std::unique_ptr< YAxisStraightnessX_type > p);

      // YAxisStraightnessZ
      //
      typedef ::xsd::qif30::LengthFunctionDiscreteType YAxisStraightnessZ_type;
      typedef ::xsd::cxx::tree::traits< YAxisStraightnessZ_type, wchar_t > YAxisStraightnessZ_traits;

      const YAxisStraightnessZ_type&
      YAxisStraightnessZ () const;

      YAxisStraightnessZ_type&
      YAxisStraightnessZ ();

      void
      YAxisStraightnessZ (const YAxisStraightnessZ_type& x);

      void
      YAxisStraightnessZ (::std::unique_ptr< YAxisStraightnessZ_type > p);

      // ZAxisStraightnessX
      //
      typedef ::xsd::qif30::LengthFunctionDiscreteType ZAxisStraightnessX_type;
      typedef ::xsd::cxx::tree::traits< ZAxisStraightnessX_type, wchar_t > ZAxisStraightnessX_traits;

      const ZAxisStraightnessX_type&
      ZAxisStraightnessX () const;

      ZAxisStraightnessX_type&
      ZAxisStraightnessX ();

      void
      ZAxisStraightnessX (const ZAxisStraightnessX_type& x);

      void
      ZAxisStraightnessX (::std::unique_ptr< ZAxisStraightnessX_type > p);

      // ZAxisStraightnessY
      //
      typedef ::xsd::qif30::LengthFunctionDiscreteType ZAxisStraightnessY_type;
      typedef ::xsd::cxx::tree::traits< ZAxisStraightnessY_type, wchar_t > ZAxisStraightnessY_traits;

      const ZAxisStraightnessY_type&
      ZAxisStraightnessY () const;

      ZAxisStraightnessY_type&
      ZAxisStraightnessY ();

      void
      ZAxisStraightnessY (const ZAxisStraightnessY_type& x);

      void
      ZAxisStraightnessY (::std::unique_ptr< ZAxisStraightnessY_type > p);

      // XYSquareness
      //
      typedef ::xml_schema::double_ XYSquareness_type;
      typedef ::xsd::cxx::tree::traits< XYSquareness_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > XYSquareness_traits;

      const XYSquareness_type&
      XYSquareness () const;

      XYSquareness_type&
      XYSquareness ();

      void
      XYSquareness (const XYSquareness_type& x);

      // XZSquareness
      //
      typedef ::xml_schema::double_ XZSquareness_type;
      typedef ::xsd::cxx::tree::traits< XZSquareness_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > XZSquareness_traits;

      const XZSquareness_type&
      XZSquareness () const;

      XZSquareness_type&
      XZSquareness ();

      void
      XZSquareness (const XZSquareness_type& x);

      // YZSquareness
      //
      typedef ::xml_schema::double_ YZSquareness_type;
      typedef ::xsd::cxx::tree::traits< YZSquareness_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > YZSquareness_traits;

      const YZSquareness_type&
      YZSquareness () const;

      YZSquareness_type&
      YZSquareness ();

      void
      YZSquareness (const YZSquareness_type& x);

      // Constructors.
      //
      FPSTestType ();

      FPSTestType (const XLinearity_type&,
                   const YLinearity_type&,
                   const ZLinearity_type&,
                   const XAxisRoll_type&,
                   const XAxisPitch_type&,
                   const XAxisYaw_type&,
                   const YAxisRoll_type&,
                   const YAxisPitch_type&,
                   const YAxisYaw_type&,
                   const ZAxisRoll_type&,
                   const ZAxisPitch_type&,
                   const ZAxisYaw_type&,
                   const XAxisStraightnessY_type&,
                   const XAxisStraightnessZ_type&,
                   const YAxisStraightnessX_type&,
                   const YAxisStraightnessZ_type&,
                   const ZAxisStraightnessX_type&,
                   const ZAxisStraightnessY_type&,
                   const XYSquareness_type&,
                   const XZSquareness_type&,
                   const YZSquareness_type&);

      FPSTestType (::std::unique_ptr< XLinearity_type >,
                   ::std::unique_ptr< YLinearity_type >,
                   ::std::unique_ptr< ZLinearity_type >,
                   ::std::unique_ptr< XAxisRoll_type >,
                   ::std::unique_ptr< XAxisPitch_type >,
                   ::std::unique_ptr< XAxisYaw_type >,
                   ::std::unique_ptr< YAxisRoll_type >,
                   ::std::unique_ptr< YAxisPitch_type >,
                   ::std::unique_ptr< YAxisYaw_type >,
                   ::std::unique_ptr< ZAxisRoll_type >,
                   ::std::unique_ptr< ZAxisPitch_type >,
                   ::std::unique_ptr< ZAxisYaw_type >,
                   ::std::unique_ptr< XAxisStraightnessY_type >,
                   ::std::unique_ptr< XAxisStraightnessZ_type >,
                   ::std::unique_ptr< YAxisStraightnessX_type >,
                   ::std::unique_ptr< YAxisStraightnessZ_type >,
                   ::std::unique_ptr< ZAxisStraightnessX_type >,
                   ::std::unique_ptr< ZAxisStraightnessY_type >,
                   const XYSquareness_type&,
                   const XZSquareness_type&,
                   const YZSquareness_type&);

      FPSTestType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      FPSTestType (const FPSTestType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual FPSTestType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FPSTestType&
      operator= (const FPSTestType& x);

      virtual 
      ~FPSTestType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< XLinearity_type > XLinearity_;
      ::xsd::cxx::tree::one< YLinearity_type > YLinearity_;
      ::xsd::cxx::tree::one< ZLinearity_type > ZLinearity_;
      ::xsd::cxx::tree::one< XAxisRoll_type > XAxisRoll_;
      ::xsd::cxx::tree::one< XAxisPitch_type > XAxisPitch_;
      ::xsd::cxx::tree::one< XAxisYaw_type > XAxisYaw_;
      ::xsd::cxx::tree::one< YAxisRoll_type > YAxisRoll_;
      ::xsd::cxx::tree::one< YAxisPitch_type > YAxisPitch_;
      ::xsd::cxx::tree::one< YAxisYaw_type > YAxisYaw_;
      ::xsd::cxx::tree::one< ZAxisRoll_type > ZAxisRoll_;
      ::xsd::cxx::tree::one< ZAxisPitch_type > ZAxisPitch_;
      ::xsd::cxx::tree::one< ZAxisYaw_type > ZAxisYaw_;
      ::xsd::cxx::tree::one< XAxisStraightnessY_type > XAxisStraightnessY_;
      ::xsd::cxx::tree::one< XAxisStraightnessZ_type > XAxisStraightnessZ_;
      ::xsd::cxx::tree::one< YAxisStraightnessX_type > YAxisStraightnessX_;
      ::xsd::cxx::tree::one< YAxisStraightnessZ_type > YAxisStraightnessZ_;
      ::xsd::cxx::tree::one< ZAxisStraightnessX_type > ZAxisStraightnessX_;
      ::xsd::cxx::tree::one< ZAxisStraightnessY_type > ZAxisStraightnessY_;
      ::xsd::cxx::tree::one< XYSquareness_type > XYSquareness_;
      ::xsd::cxx::tree::one< XZSquareness_type > XZSquareness_;
      ::xsd::cxx::tree::one< YZSquareness_type > YZSquareness_;
    };

    class QIF30_SYMBOL_DECL CartesianCMMB89TestType: public ::xsd::qif30::CMMAccuracyTestBaseType
    {
      public:
      // XLinearAccuracy
      //
      typedef ::xsd::qif30::LinearValueType XLinearAccuracy_type;
      typedef ::xsd::cxx::tree::traits< XLinearAccuracy_type, wchar_t > XLinearAccuracy_traits;

      const XLinearAccuracy_type&
      XLinearAccuracy () const;

      XLinearAccuracy_type&
      XLinearAccuracy ();

      void
      XLinearAccuracy (const XLinearAccuracy_type& x);

      void
      XLinearAccuracy (::std::unique_ptr< XLinearAccuracy_type > p);

      // YLinearAccuracy
      //
      typedef ::xsd::qif30::LinearValueType YLinearAccuracy_type;
      typedef ::xsd::cxx::tree::traits< YLinearAccuracy_type, wchar_t > YLinearAccuracy_traits;

      const YLinearAccuracy_type&
      YLinearAccuracy () const;

      YLinearAccuracy_type&
      YLinearAccuracy ();

      void
      YLinearAccuracy (const YLinearAccuracy_type& x);

      void
      YLinearAccuracy (::std::unique_ptr< YLinearAccuracy_type > p);

      // ZLinearAccuracy
      //
      typedef ::xsd::qif30::LinearValueType ZLinearAccuracy_type;
      typedef ::xsd::cxx::tree::traits< ZLinearAccuracy_type, wchar_t > ZLinearAccuracy_traits;

      const ZLinearAccuracy_type&
      ZLinearAccuracy () const;

      ZLinearAccuracy_type&
      ZLinearAccuracy ();

      void
      ZLinearAccuracy (const ZLinearAccuracy_type& x);

      void
      ZLinearAccuracy (::std::unique_ptr< ZLinearAccuracy_type > p);

      // OffsetVolumetricPerformance
      //
      typedef ::xsd::qif30::LinearValueType OffsetVolumetricPerformance_type;
      typedef ::xsd::cxx::tree::traits< OffsetVolumetricPerformance_type, wchar_t > OffsetVolumetricPerformance_traits;

      const OffsetVolumetricPerformance_type&
      OffsetVolumetricPerformance () const;

      OffsetVolumetricPerformance_type&
      OffsetVolumetricPerformance ();

      void
      OffsetVolumetricPerformance (const OffsetVolumetricPerformance_type& x);

      void
      OffsetVolumetricPerformance (::std::unique_ptr< OffsetVolumetricPerformance_type > p);

      // VolumetricPerformance
      //
      typedef ::xsd::qif30::LinearValueType VolumetricPerformance_type;
      typedef ::xsd::cxx::tree::traits< VolumetricPerformance_type, wchar_t > VolumetricPerformance_traits;

      const VolumetricPerformance_type&
      VolumetricPerformance () const;

      VolumetricPerformance_type&
      VolumetricPerformance ();

      void
      VolumetricPerformance (const VolumetricPerformance_type& x);

      void
      VolumetricPerformance (::std::unique_ptr< VolumetricPerformance_type > p);

      // Repeatability
      //
      typedef ::xsd::qif30::LinearValueType Repeatability_type;
      typedef ::xsd::cxx::tree::traits< Repeatability_type, wchar_t > Repeatability_traits;

      const Repeatability_type&
      Repeatability () const;

      Repeatability_type&
      Repeatability ();

      void
      Repeatability (const Repeatability_type& x);

      void
      Repeatability (::std::unique_ptr< Repeatability_type > p);

      // Constructors.
      //
      CartesianCMMB89TestType ();

      CartesianCMMB89TestType (const XLinearAccuracy_type&,
                               const YLinearAccuracy_type&,
                               const ZLinearAccuracy_type&,
                               const OffsetVolumetricPerformance_type&,
                               const VolumetricPerformance_type&,
                               const Repeatability_type&);

      CartesianCMMB89TestType (::std::unique_ptr< XLinearAccuracy_type >,
                               ::std::unique_ptr< YLinearAccuracy_type >,
                               ::std::unique_ptr< ZLinearAccuracy_type >,
                               ::std::unique_ptr< OffsetVolumetricPerformance_type >,
                               ::std::unique_ptr< VolumetricPerformance_type >,
                               ::std::unique_ptr< Repeatability_type >);

      CartesianCMMB89TestType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      CartesianCMMB89TestType (const CartesianCMMB89TestType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual CartesianCMMB89TestType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CartesianCMMB89TestType&
      operator= (const CartesianCMMB89TestType& x);

      virtual 
      ~CartesianCMMB89TestType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< XLinearAccuracy_type > XLinearAccuracy_;
      ::xsd::cxx::tree::one< YLinearAccuracy_type > YLinearAccuracy_;
      ::xsd::cxx::tree::one< ZLinearAccuracy_type > ZLinearAccuracy_;
      ::xsd::cxx::tree::one< OffsetVolumetricPerformance_type > OffsetVolumetricPerformance_;
      ::xsd::cxx::tree::one< VolumetricPerformance_type > VolumetricPerformance_;
      ::xsd::cxx::tree::one< Repeatability_type > Repeatability_;
    };

    class QIF30_SYMBOL_DECL AACMMB89TestType: public ::xsd::qif30::CMMAccuracyTestBaseType
    {
      public:
      // EffectiveDiameterPerformanceTest
      //
      typedef ::xsd::qif30::EffectiveDiameterPerformanceTestType EffectiveDiameterPerformanceTest_type;
      typedef ::xsd::cxx::tree::optional< EffectiveDiameterPerformanceTest_type > EffectiveDiameterPerformanceTest_optional;
      typedef ::xsd::cxx::tree::traits< EffectiveDiameterPerformanceTest_type, wchar_t > EffectiveDiameterPerformanceTest_traits;

      const EffectiveDiameterPerformanceTest_optional&
      EffectiveDiameterPerformanceTest () const;

      EffectiveDiameterPerformanceTest_optional&
      EffectiveDiameterPerformanceTest ();

      void
      EffectiveDiameterPerformanceTest (const EffectiveDiameterPerformanceTest_type& x);

      void
      EffectiveDiameterPerformanceTest (const EffectiveDiameterPerformanceTest_optional& x);

      void
      EffectiveDiameterPerformanceTest (::std::unique_ptr< EffectiveDiameterPerformanceTest_type > p);

      // SinglePointArticulationPerformanceTest
      //
      typedef ::xsd::qif30::SinglePointArticulationPerformanceTestType SinglePointArticulationPerformanceTest_type;
      typedef ::xsd::cxx::tree::optional< SinglePointArticulationPerformanceTest_type > SinglePointArticulationPerformanceTest_optional;
      typedef ::xsd::cxx::tree::traits< SinglePointArticulationPerformanceTest_type, wchar_t > SinglePointArticulationPerformanceTest_traits;

      const SinglePointArticulationPerformanceTest_optional&
      SinglePointArticulationPerformanceTest () const;

      SinglePointArticulationPerformanceTest_optional&
      SinglePointArticulationPerformanceTest ();

      void
      SinglePointArticulationPerformanceTest (const SinglePointArticulationPerformanceTest_type& x);

      void
      SinglePointArticulationPerformanceTest (const SinglePointArticulationPerformanceTest_optional& x);

      void
      SinglePointArticulationPerformanceTest (::std::unique_ptr< SinglePointArticulationPerformanceTest_type > p);

      // VolumetricPerformanceTest
      //
      typedef ::xsd::qif30::VolumetricPerformanceTestType VolumetricPerformanceTest_type;
      typedef ::xsd::cxx::tree::optional< VolumetricPerformanceTest_type > VolumetricPerformanceTest_optional;
      typedef ::xsd::cxx::tree::traits< VolumetricPerformanceTest_type, wchar_t > VolumetricPerformanceTest_traits;

      const VolumetricPerformanceTest_optional&
      VolumetricPerformanceTest () const;

      VolumetricPerformanceTest_optional&
      VolumetricPerformanceTest ();

      void
      VolumetricPerformanceTest (const VolumetricPerformanceTest_type& x);

      void
      VolumetricPerformanceTest (const VolumetricPerformanceTest_optional& x);

      void
      VolumetricPerformanceTest (::std::unique_ptr< VolumetricPerformanceTest_type > p);

      // Constructors.
      //
      AACMMB89TestType ();

      AACMMB89TestType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      AACMMB89TestType (const AACMMB89TestType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual AACMMB89TestType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AACMMB89TestType&
      operator= (const AACMMB89TestType& x);

      virtual 
      ~AACMMB89TestType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      EffectiveDiameterPerformanceTest_optional EffectiveDiameterPerformanceTest_;
      SinglePointArticulationPerformanceTest_optional SinglePointArticulationPerformanceTest_;
      VolumetricPerformanceTest_optional VolumetricPerformanceTest_;
    };

    class QIF30_SYMBOL_DECL EffectiveDiameterPerformanceTestType: public ::xml_schema::type
    {
      public:
      // AverageDiameter
      //
      typedef ::xml_schema::decimal AverageDiameter_type;
      typedef ::xsd::cxx::tree::traits< AverageDiameter_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > AverageDiameter_traits;

      const AverageDiameter_type&
      AverageDiameter () const;

      AverageDiameter_type&
      AverageDiameter ();

      void
      AverageDiameter (const AverageDiameter_type& x);

      // StandardDeviation
      //
      typedef ::xml_schema::decimal StandardDeviation_type;
      typedef ::xsd::cxx::tree::traits< StandardDeviation_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > StandardDeviation_traits;

      const StandardDeviation_type&
      StandardDeviation () const;

      StandardDeviation_type&
      StandardDeviation ();

      void
      StandardDeviation (const StandardDeviation_type& x);

      // Constructors.
      //
      EffectiveDiameterPerformanceTestType ();

      EffectiveDiameterPerformanceTestType (const AverageDiameter_type&,
                                            const StandardDeviation_type&);

      EffectiveDiameterPerformanceTestType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      EffectiveDiameterPerformanceTestType (const EffectiveDiameterPerformanceTestType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual EffectiveDiameterPerformanceTestType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EffectiveDiameterPerformanceTestType&
      operator= (const EffectiveDiameterPerformanceTestType& x);

      virtual 
      ~EffectiveDiameterPerformanceTestType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< AverageDiameter_type > AverageDiameter_;
      ::xsd::cxx::tree::one< StandardDeviation_type > StandardDeviation_;
    };

    class QIF30_SYMBOL_DECL SinglePointArticulationPerformanceTestType: public ::xml_schema::type
    {
      public:
      // MaxDeviationFromAverageNear
      //
      typedef ::xsd::qif30::LinearValueType MaxDeviationFromAverageNear_type;
      typedef ::xsd::cxx::tree::traits< MaxDeviationFromAverageNear_type, wchar_t > MaxDeviationFromAverageNear_traits;

      const MaxDeviationFromAverageNear_type&
      MaxDeviationFromAverageNear () const;

      MaxDeviationFromAverageNear_type&
      MaxDeviationFromAverageNear ();

      void
      MaxDeviationFromAverageNear (const MaxDeviationFromAverageNear_type& x);

      void
      MaxDeviationFromAverageNear (::std::unique_ptr< MaxDeviationFromAverageNear_type > p);

      // MaxDeviationFromAverageFar
      //
      typedef ::xsd::qif30::LinearValueType MaxDeviationFromAverageFar_type;
      typedef ::xsd::cxx::tree::traits< MaxDeviationFromAverageFar_type, wchar_t > MaxDeviationFromAverageFar_traits;

      const MaxDeviationFromAverageFar_type&
      MaxDeviationFromAverageFar () const;

      MaxDeviationFromAverageFar_type&
      MaxDeviationFromAverageFar ();

      void
      MaxDeviationFromAverageFar (const MaxDeviationFromAverageFar_type& x);

      void
      MaxDeviationFromAverageFar (::std::unique_ptr< MaxDeviationFromAverageFar_type > p);

      // MaxDeviationFromAverageMiddle
      //
      typedef ::xsd::qif30::LinearValueType MaxDeviationFromAverageMiddle_type;
      typedef ::xsd::cxx::tree::traits< MaxDeviationFromAverageMiddle_type, wchar_t > MaxDeviationFromAverageMiddle_traits;

      const MaxDeviationFromAverageMiddle_type&
      MaxDeviationFromAverageMiddle () const;

      MaxDeviationFromAverageMiddle_type&
      MaxDeviationFromAverageMiddle ();

      void
      MaxDeviationFromAverageMiddle (const MaxDeviationFromAverageMiddle_type& x);

      void
      MaxDeviationFromAverageMiddle (::std::unique_ptr< MaxDeviationFromAverageMiddle_type > p);

      // TwiceStandardDeviationNear
      //
      typedef ::xsd::qif30::LinearValueType TwiceStandardDeviationNear_type;
      typedef ::xsd::cxx::tree::traits< TwiceStandardDeviationNear_type, wchar_t > TwiceStandardDeviationNear_traits;

      const TwiceStandardDeviationNear_type&
      TwiceStandardDeviationNear () const;

      TwiceStandardDeviationNear_type&
      TwiceStandardDeviationNear ();

      void
      TwiceStandardDeviationNear (const TwiceStandardDeviationNear_type& x);

      void
      TwiceStandardDeviationNear (::std::unique_ptr< TwiceStandardDeviationNear_type > p);

      // TwiceStandardDeviationFar
      //
      typedef ::xsd::qif30::LinearValueType TwiceStandardDeviationFar_type;
      typedef ::xsd::cxx::tree::traits< TwiceStandardDeviationFar_type, wchar_t > TwiceStandardDeviationFar_traits;

      const TwiceStandardDeviationFar_type&
      TwiceStandardDeviationFar () const;

      TwiceStandardDeviationFar_type&
      TwiceStandardDeviationFar ();

      void
      TwiceStandardDeviationFar (const TwiceStandardDeviationFar_type& x);

      void
      TwiceStandardDeviationFar (::std::unique_ptr< TwiceStandardDeviationFar_type > p);

      // TwiceStandardDeviationMiddle
      //
      typedef ::xsd::qif30::LinearValueType TwiceStandardDeviationMiddle_type;
      typedef ::xsd::cxx::tree::traits< TwiceStandardDeviationMiddle_type, wchar_t > TwiceStandardDeviationMiddle_traits;

      const TwiceStandardDeviationMiddle_type&
      TwiceStandardDeviationMiddle () const;

      TwiceStandardDeviationMiddle_type&
      TwiceStandardDeviationMiddle ();

      void
      TwiceStandardDeviationMiddle (const TwiceStandardDeviationMiddle_type& x);

      void
      TwiceStandardDeviationMiddle (::std::unique_ptr< TwiceStandardDeviationMiddle_type > p);

      // Constructors.
      //
      SinglePointArticulationPerformanceTestType ();

      SinglePointArticulationPerformanceTestType (const MaxDeviationFromAverageNear_type&,
                                                  const MaxDeviationFromAverageFar_type&,
                                                  const MaxDeviationFromAverageMiddle_type&,
                                                  const TwiceStandardDeviationNear_type&,
                                                  const TwiceStandardDeviationFar_type&,
                                                  const TwiceStandardDeviationMiddle_type&);

      SinglePointArticulationPerformanceTestType (::std::unique_ptr< MaxDeviationFromAverageNear_type >,
                                                  ::std::unique_ptr< MaxDeviationFromAverageFar_type >,
                                                  ::std::unique_ptr< MaxDeviationFromAverageMiddle_type >,
                                                  ::std::unique_ptr< TwiceStandardDeviationNear_type >,
                                                  ::std::unique_ptr< TwiceStandardDeviationFar_type >,
                                                  ::std::unique_ptr< TwiceStandardDeviationMiddle_type >);

      SinglePointArticulationPerformanceTestType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      SinglePointArticulationPerformanceTestType (const SinglePointArticulationPerformanceTestType& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      virtual SinglePointArticulationPerformanceTestType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SinglePointArticulationPerformanceTestType&
      operator= (const SinglePointArticulationPerformanceTestType& x);

      virtual 
      ~SinglePointArticulationPerformanceTestType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< MaxDeviationFromAverageNear_type > MaxDeviationFromAverageNear_;
      ::xsd::cxx::tree::one< MaxDeviationFromAverageFar_type > MaxDeviationFromAverageFar_;
      ::xsd::cxx::tree::one< MaxDeviationFromAverageMiddle_type > MaxDeviationFromAverageMiddle_;
      ::xsd::cxx::tree::one< TwiceStandardDeviationNear_type > TwiceStandardDeviationNear_;
      ::xsd::cxx::tree::one< TwiceStandardDeviationFar_type > TwiceStandardDeviationFar_;
      ::xsd::cxx::tree::one< TwiceStandardDeviationMiddle_type > TwiceStandardDeviationMiddle_;
    };

    class QIF30_SYMBOL_DECL VolumetricPerformanceTestType: public ::xml_schema::type
    {
      public:
      // DeviationsFromCalibration
      //
      typedef ::xsd::qif30::TwentyLinearValuesType DeviationsFromCalibration_type;
      typedef ::xsd::cxx::tree::traits< DeviationsFromCalibration_type, wchar_t > DeviationsFromCalibration_traits;

      const DeviationsFromCalibration_type&
      DeviationsFromCalibration () const;

      DeviationsFromCalibration_type&
      DeviationsFromCalibration ();

      void
      DeviationsFromCalibration (const DeviationsFromCalibration_type& x);

      void
      DeviationsFromCalibration (::std::unique_ptr< DeviationsFromCalibration_type > p);

      // TwiceStandardDeviation
      //
      typedef ::xsd::qif30::LinearValueType TwiceStandardDeviation_type;
      typedef ::xsd::cxx::tree::traits< TwiceStandardDeviation_type, wchar_t > TwiceStandardDeviation_traits;

      const TwiceStandardDeviation_type&
      TwiceStandardDeviation () const;

      TwiceStandardDeviation_type&
      TwiceStandardDeviation ();

      void
      TwiceStandardDeviation (const TwiceStandardDeviation_type& x);

      void
      TwiceStandardDeviation (::std::unique_ptr< TwiceStandardDeviation_type > p);

      // Constructors.
      //
      VolumetricPerformanceTestType ();

      VolumetricPerformanceTestType (const DeviationsFromCalibration_type&,
                                     const TwiceStandardDeviation_type&);

      VolumetricPerformanceTestType (::std::unique_ptr< DeviationsFromCalibration_type >,
                                     ::std::unique_ptr< TwiceStandardDeviation_type >);

      VolumetricPerformanceTestType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      VolumetricPerformanceTestType (const VolumetricPerformanceTestType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual VolumetricPerformanceTestType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      VolumetricPerformanceTestType&
      operator= (const VolumetricPerformanceTestType& x);

      virtual 
      ~VolumetricPerformanceTestType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DeviationsFromCalibration_type > DeviationsFromCalibration_;
      ::xsd::cxx::tree::one< TwiceStandardDeviation_type > TwiceStandardDeviation_;
    };

    class QIF30_SYMBOL_DECL TwentyLinearValuesType: public ::xml_schema::type
    {
      public:
      // LinearValue
      //
      typedef ::xsd::qif30::LinearValueType LinearValue_type;
      typedef ::xsd::cxx::tree::sequence< LinearValue_type > LinearValue_sequence;
      typedef xsd::cxx::tree::sequence< LinearValue_type >::iterator LinearValue_iterator;
      typedef xsd::cxx::tree::sequence< LinearValue_type >::const_iterator LinearValue_const_iterator;
      typedef ::xsd::cxx::tree::traits< LinearValue_type, wchar_t > LinearValue_traits;

      const LinearValue_sequence&
      LinearValue () const;

      LinearValue_sequence&
      LinearValue ();

      void
      LinearValue (const LinearValue_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      TwentyLinearValuesType ();

      TwentyLinearValuesType (const n_type&);

      TwentyLinearValuesType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      TwentyLinearValuesType (const TwentyLinearValuesType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual TwentyLinearValuesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TwentyLinearValuesType&
      operator= (const TwentyLinearValuesType& x);

      virtual 
      ~TwentyLinearValuesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      LinearValue_sequence LinearValue_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ISO10360TestType: public ::xsd::qif30::CMMAccuracyTestBaseType
    {
      public:
      // MaxErrorConstant
      //
      typedef ::xsd::qif30::LinearValueType MaxErrorConstant_type;
      typedef ::xsd::cxx::tree::optional< MaxErrorConstant_type > MaxErrorConstant_optional;
      typedef ::xsd::cxx::tree::traits< MaxErrorConstant_type, wchar_t > MaxErrorConstant_traits;

      const MaxErrorConstant_optional&
      MaxErrorConstant () const;

      MaxErrorConstant_optional&
      MaxErrorConstant ();

      void
      MaxErrorConstant (const MaxErrorConstant_type& x);

      void
      MaxErrorConstant (const MaxErrorConstant_optional& x);

      void
      MaxErrorConstant (::std::unique_ptr< MaxErrorConstant_type > p);

      // LinearError
      //
      typedef ::xsd::qif30::LinearErrorType LinearError_type;
      typedef ::xsd::cxx::tree::optional< LinearError_type > LinearError_optional;
      typedef ::xsd::cxx::tree::traits< LinearError_type, wchar_t > LinearError_traits;

      const LinearError_optional&
      LinearError () const;

      LinearError_optional&
      LinearError ();

      void
      LinearError (const LinearError_type& x);

      void
      LinearError (const LinearError_optional& x);

      void
      LinearError (::std::unique_ptr< LinearError_type > p);

      // LesserError
      //
      typedef ::xsd::qif30::LesserErrorType LesserError_type;
      typedef ::xsd::cxx::tree::optional< LesserError_type > LesserError_optional;
      typedef ::xsd::cxx::tree::traits< LesserError_type, wchar_t > LesserError_traits;

      const LesserError_optional&
      LesserError () const;

      LesserError_optional&
      LesserError ();

      void
      LesserError (const LesserError_type& x);

      void
      LesserError (const LesserError_optional& x);

      void
      LesserError (::std::unique_ptr< LesserError_type > p);

      // Constructors.
      //
      ISO10360TestType ();

      ISO10360TestType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      ISO10360TestType (const ISO10360TestType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual ISO10360TestType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ISO10360TestType&
      operator= (const ISO10360TestType& x);

      virtual 
      ~ISO10360TestType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MaxErrorConstant_optional MaxErrorConstant_;
      LinearError_optional LinearError_;
      LesserError_optional LesserError_;
    };

    class QIF30_SYMBOL_DECL LinearErrorType: public ::xml_schema::type
    {
      public:
      // BaseError
      //
      typedef ::xsd::qif30::LinearValueType BaseError_type;
      typedef ::xsd::cxx::tree::traits< BaseError_type, wchar_t > BaseError_traits;

      const BaseError_type&
      BaseError () const;

      BaseError_type&
      BaseError ();

      void
      BaseError (const BaseError_type& x);

      void
      BaseError (::std::unique_ptr< BaseError_type > p);

      // ErrorRate
      //
      typedef ::xml_schema::decimal ErrorRate_type;
      typedef ::xsd::cxx::tree::traits< ErrorRate_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > ErrorRate_traits;

      const ErrorRate_type&
      ErrorRate () const;

      ErrorRate_type&
      ErrorRate ();

      void
      ErrorRate (const ErrorRate_type& x);

      // Constructors.
      //
      LinearErrorType ();

      LinearErrorType (const BaseError_type&,
                       const ErrorRate_type&);

      LinearErrorType (::std::unique_ptr< BaseError_type >,
                       const ErrorRate_type&);

      LinearErrorType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      LinearErrorType (const LinearErrorType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual LinearErrorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LinearErrorType&
      operator= (const LinearErrorType& x);

      virtual 
      ~LinearErrorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseError_type > BaseError_;
      ::xsd::cxx::tree::one< ErrorRate_type > ErrorRate_;
    };

    class QIF30_SYMBOL_DECL LesserErrorType: public ::xml_schema::type
    {
      public:
      // MaxErrorConstant
      //
      typedef ::xsd::qif30::LinearValueType MaxErrorConstant_type;
      typedef ::xsd::cxx::tree::traits< MaxErrorConstant_type, wchar_t > MaxErrorConstant_traits;

      const MaxErrorConstant_type&
      MaxErrorConstant () const;

      MaxErrorConstant_type&
      MaxErrorConstant ();

      void
      MaxErrorConstant (const MaxErrorConstant_type& x);

      void
      MaxErrorConstant (::std::unique_ptr< MaxErrorConstant_type > p);

      // LinearError
      //
      typedef ::xsd::qif30::LinearErrorType LinearError_type;
      typedef ::xsd::cxx::tree::traits< LinearError_type, wchar_t > LinearError_traits;

      const LinearError_type&
      LinearError () const;

      LinearError_type&
      LinearError ();

      void
      LinearError (const LinearError_type& x);

      void
      LinearError (::std::unique_ptr< LinearError_type > p);

      // Constructors.
      //
      LesserErrorType ();

      LesserErrorType (const MaxErrorConstant_type&,
                       const LinearError_type&);

      LesserErrorType (::std::unique_ptr< MaxErrorConstant_type >,
                       ::std::unique_ptr< LinearError_type >);

      LesserErrorType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      LesserErrorType (const LesserErrorType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual LesserErrorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LesserErrorType&
      operator= (const LesserErrorType& x);

      virtual 
      ~LesserErrorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< MaxErrorConstant_type > MaxErrorConstant_;
      ::xsd::cxx::tree::one< LinearError_type > LinearError_;
    };

    class QIF30_SYMBOL_DECL PointAccuracyTestType: public ::xsd::qif30::CMMAccuracyTestBaseType
    {
      public:
      // Accuracy
      //
      typedef ::xsd::qif30::LinearValueType Accuracy_type;
      typedef ::xsd::cxx::tree::traits< Accuracy_type, wchar_t > Accuracy_traits;

      const Accuracy_type&
      Accuracy () const;

      Accuracy_type&
      Accuracy ();

      void
      Accuracy (const Accuracy_type& x);

      void
      Accuracy (::std::unique_ptr< Accuracy_type > p);

      // Constructors.
      //
      PointAccuracyTestType ();

      PointAccuracyTestType (const Accuracy_type&);

      PointAccuracyTestType (::std::unique_ptr< Accuracy_type >);

      PointAccuracyTestType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      PointAccuracyTestType (const PointAccuracyTestType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual PointAccuracyTestType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointAccuracyTestType&
      operator= (const PointAccuracyTestType& x);

      virtual 
      ~PointAccuracyTestType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Accuracy_type > Accuracy_;
    };

    class QIF30_SYMBOL_DECL AngularErrorType: public ::xml_schema::type
    {
      public:
      // BaseError
      //
      typedef ::xsd::qif30::AngularValueType BaseError_type;
      typedef ::xsd::cxx::tree::traits< BaseError_type, wchar_t > BaseError_traits;

      const BaseError_type&
      BaseError () const;

      BaseError_type&
      BaseError ();

      void
      BaseError (const BaseError_type& x);

      void
      BaseError (::std::unique_ptr< BaseError_type > p);

      // ErrorRate
      //
      typedef ::xml_schema::decimal ErrorRate_type;
      typedef ::xsd::cxx::tree::traits< ErrorRate_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > ErrorRate_traits;

      const ErrorRate_type&
      ErrorRate () const;

      ErrorRate_type&
      ErrorRate ();

      void
      ErrorRate (const ErrorRate_type& x);

      // Constructors.
      //
      AngularErrorType ();

      AngularErrorType (const BaseError_type&,
                        const ErrorRate_type&);

      AngularErrorType (::std::unique_ptr< BaseError_type >,
                        const ErrorRate_type&);

      AngularErrorType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      AngularErrorType (const AngularErrorType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual AngularErrorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AngularErrorType&
      operator= (const AngularErrorType& x);

      virtual 
      ~AngularErrorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseError_type > BaseError_;
      ::xsd::cxx::tree::one< ErrorRate_type > ErrorRate_;
    };

    class QIF30_SYMBOL_DECL RotaryTableType: public ::xml_schema::type
    {
      public:
      // LocationOnCMM
      //
      typedef ::xsd::qif30::PointType LocationOnCMM_type;
      typedef ::xsd::cxx::tree::traits< LocationOnCMM_type, wchar_t > LocationOnCMM_traits;

      const LocationOnCMM_type&
      LocationOnCMM () const;

      LocationOnCMM_type&
      LocationOnCMM ();

      void
      LocationOnCMM (const LocationOnCMM_type& x);

      void
      LocationOnCMM (::std::unique_ptr< LocationOnCMM_type > p);

      // AxisDirection
      //
      typedef ::xsd::qif30::UnitVectorType AxisDirection_type;
      typedef ::xsd::cxx::tree::traits< AxisDirection_type, wchar_t > AxisDirection_traits;

      const AxisDirection_type&
      AxisDirection () const;

      AxisDirection_type&
      AxisDirection ();

      void
      AxisDirection (const AxisDirection_type& x);

      void
      AxisDirection (::std::unique_ptr< AxisDirection_type > p);

      // ZeroIndexDirection
      //
      typedef ::xsd::qif30::UnitVectorType ZeroIndexDirection_type;
      typedef ::xsd::cxx::tree::traits< ZeroIndexDirection_type, wchar_t > ZeroIndexDirection_traits;

      const ZeroIndexDirection_type&
      ZeroIndexDirection () const;

      ZeroIndexDirection_type&
      ZeroIndexDirection ();

      void
      ZeroIndexDirection (const ZeroIndexDirection_type& x);

      void
      ZeroIndexDirection (::std::unique_ptr< ZeroIndexDirection_type > p);

      // TableRadius
      //
      typedef ::xsd::qif30::LinearValueType TableRadius_type;
      typedef ::xsd::cxx::tree::traits< TableRadius_type, wchar_t > TableRadius_traits;

      const TableRadius_type&
      TableRadius () const;

      TableRadius_type&
      TableRadius ();

      void
      TableRadius (const TableRadius_type& x);

      void
      TableRadius (::std::unique_ptr< TableRadius_type > p);

      // TableErrors
      //
      typedef ::xsd::qif30::TableErrorsType TableErrors_type;
      typedef ::xsd::cxx::tree::traits< TableErrors_type, wchar_t > TableErrors_traits;

      const TableErrors_type&
      TableErrors () const;

      TableErrors_type&
      TableErrors ();

      void
      TableErrors (const TableErrors_type& x);

      void
      TableErrors (::std::unique_ptr< TableErrors_type > p);

      // Constructors.
      //
      RotaryTableType ();

      RotaryTableType (const LocationOnCMM_type&,
                       const AxisDirection_type&,
                       const ZeroIndexDirection_type&,
                       const TableRadius_type&,
                       const TableErrors_type&);

      RotaryTableType (::std::unique_ptr< LocationOnCMM_type >,
                       ::std::unique_ptr< AxisDirection_type >,
                       ::std::unique_ptr< ZeroIndexDirection_type >,
                       ::std::unique_ptr< TableRadius_type >,
                       ::std::unique_ptr< TableErrors_type >);

      RotaryTableType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      RotaryTableType (const RotaryTableType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual RotaryTableType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      RotaryTableType&
      operator= (const RotaryTableType& x);

      virtual 
      ~RotaryTableType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< LocationOnCMM_type > LocationOnCMM_;
      ::xsd::cxx::tree::one< AxisDirection_type > AxisDirection_;
      ::xsd::cxx::tree::one< ZeroIndexDirection_type > ZeroIndexDirection_;
      ::xsd::cxx::tree::one< TableRadius_type > TableRadius_;
      ::xsd::cxx::tree::one< TableErrors_type > TableErrors_;
    };

    class QIF30_SYMBOL_DECL TableErrorsType: public ::xml_schema::type
    {
      public:
      // AxialError
      //
      typedef ::xsd::qif30::LinearValueType AxialError_type;
      typedef ::xsd::cxx::tree::traits< AxialError_type, wchar_t > AxialError_traits;

      const AxialError_type&
      AxialError () const;

      AxialError_type&
      AxialError ();

      void
      AxialError (const AxialError_type& x);

      void
      AxialError (::std::unique_ptr< AxialError_type > p);

      // RadialError
      //
      typedef ::xsd::qif30::LinearValueType RadialError_type;
      typedef ::xsd::cxx::tree::traits< RadialError_type, wchar_t > RadialError_traits;

      const RadialError_type&
      RadialError () const;

      RadialError_type&
      RadialError ();

      void
      RadialError (const RadialError_type& x);

      void
      RadialError (::std::unique_ptr< RadialError_type > p);

      // TangentialError
      //
      typedef ::xsd::qif30::LinearValueType TangentialError_type;
      typedef ::xsd::cxx::tree::traits< TangentialError_type, wchar_t > TangentialError_traits;

      const TangentialError_type&
      TangentialError () const;

      TangentialError_type&
      TangentialError ();

      void
      TangentialError (const TangentialError_type& x);

      void
      TangentialError (::std::unique_ptr< TangentialError_type > p);

      // Constructors.
      //
      TableErrorsType ();

      TableErrorsType (const AxialError_type&,
                       const RadialError_type&,
                       const TangentialError_type&);

      TableErrorsType (::std::unique_ptr< AxialError_type >,
                       ::std::unique_ptr< RadialError_type >,
                       ::std::unique_ptr< TangentialError_type >);

      TableErrorsType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      TableErrorsType (const TableErrorsType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual TableErrorsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TableErrorsType&
      operator= (const TableErrorsType& x);

      virtual 
      ~TableErrorsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< AxialError_type > AxialError_;
      ::xsd::cxx::tree::one< RadialError_type > RadialError_;
      ::xsd::cxx::tree::one< TangentialError_type > TangentialError_;
    };
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace xsd
{
  namespace qif30
  {
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace xsd
{
  namespace qif30
  {
    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasurementResourcesType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasurementResourceBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CarriageType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CarriagesType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FixturesType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasurementRoomType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasurementRoomsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FixtureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SensorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LaserType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DetachableSensorBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DetachableSensorsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToolsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToolBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToolWithIntegratedSensorBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToolWithLVDTSensorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToolWithCapacitiveSensorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToolWithEddyCurrentSensorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToolWithConfocalChromaticSensorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToolWithDrawWireSensorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToolWithMagnetoInductiveSensorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToolWithDVRTSensorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToolWithLaserTriangulationSensorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToolWithStructuredLightSensorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToolWithUltrasonicSensorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToolWithSimpleTactileProbeSensorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToolWithComplexTactileProbeSensorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToolWithCCDCameraSensorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToolWithDetachableSensorsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasurementDevicesType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasurementDeviceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ManualMeasurementDeviceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UniversalDeviceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TemperatureCompensationEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const TemperatureCompensationEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const TemperatureCompensationEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TemperatureCompensationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WorkingVolumeBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const WorkingVolumeBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const WorkingVolumeBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ClosedShellSetWorkingVolumeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ClosedShellSetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CartesianWorkingVolumeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphericalWorkingVolumeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CylindricalWorkingVolumeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedWorkingVolumeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LinearOrRotaryAxisType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedAxisType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EffectiveWorkingVolumeBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const EffectiveWorkingVolumeBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const EffectiveWorkingVolumeBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EffectiveCylindricalWorkingVolumeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EffectiveSphericalWorkingVolumeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EffectiveCartesianWorkingVolumeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EffectiveClosedShellSetWorkingVolumeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EffectiveUserDefinedWorkingVolumeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserAxisBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const UserAxisBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const UserAxisBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LinearAxisType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const RotaryAxisType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ResolutionBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const ResolutionBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const ResolutionBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LinearResolutionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CartesianResolutionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const XYZResolutionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const RAPZResolutionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphericalResolutionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CombinedSphericalResolutionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedResolutionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ABCResolutionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CombinedUserDefinedResolutionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CalibrationMasterType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CalibrationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CalibrationsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const QualificationsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const QualificationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TemperaturesType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TemperatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LinearVariableDifferentialTransformerEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const LinearVariableDifferentialTransformerEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const LinearVariableDifferentialTransformerEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LinearVariableDifferentialTransformerSensorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CapacitiveSensorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EddyCurrentSensorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConfocalChromaticSensorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DrawWireSensorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MagnetoInductiveSensorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DifferentialVariableReluctanceTransducerSensorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LaserTriangulationSensorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StructuredLightSensorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UltrasonicSensorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TipEndGeometryEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const TipEndGeometryEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const TipEndGeometryEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TipEndGeometryType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TactileProbeSensorBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SimpleTactileProbeSensorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ComplexTactileProbeSensorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LocatedTipsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ProbeTipType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LocatedTipType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ChargeCoupledDeviceCameraSensorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CMMType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CartesianCMMType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MultipleCarriageCartesianCMMType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LightPenCMMType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ParallelLinkCMMType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AACMMType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CaliperType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CaliperDialType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CaliperDigitalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MicrometerType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MicrometerAnalogType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MicrometerDigitalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const GageDeviceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SineBarType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TheodoliteType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UniversalLengthMeasuringType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ComputedTomographyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OpticalComparatorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MicroscopeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AutocollimatorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LaserTrackerType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LaserRadarType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StiffnessType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CMMDirectionEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const CMMDirectionEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const CMMDirectionEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CartesianCMMGeometryType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CartesianCMMGeometryEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const CartesianCMMGeometryEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const CartesianCMMGeometryEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CMMAxisDirectionsBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const CMMAxisDirectionsBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const CMMAxisDirectionsBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CartesianCMMAxisDirectionsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const XYZLinearSpecificationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TargetMirrorEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const TargetMirrorEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const TargetMirrorEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasurementDeviceScalesBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const MeasurementDeviceScalesBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const MeasurementDeviceScalesBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CartesianMeasurementDeviceScalesType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasurementDeviceScaleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ScaleReferenceEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const ScaleReferenceEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const ScaleReferenceEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TypeOfScaleEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const TypeOfScaleEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const TypeOfScaleEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TypeOfScaleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CMMSpeedsBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const CMMSpeedsBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const CMMSpeedsBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CartesianCMMSpeedsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ParallelLinkCMMSpeedsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FunctionDiscreteType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LengthFunctionDiscreteType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngleFunctionDiscreteType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasurementDeviceAccuracyBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const NumericalLengthAccuracyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EnvironmentalRangeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CartesianCMMAccuracyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AACMMAccuracyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CartesianCMMAccuraciesType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AACMMAccuraciesType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AccuracySourceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AccuracySourceEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const AccuracySourceEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const AccuracySourceEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CMMAccuracyTestBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const CMMAccuracyTestBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const CMMAccuracyTestBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FPSTestType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CartesianCMMB89TestType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AACMMB89TestType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EffectiveDiameterPerformanceTestType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SinglePointArticulationPerformanceTestType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const VolumetricPerformanceTestType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TwentyLinearValuesType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ISO10360TestType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LinearErrorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LesserErrorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointAccuracyTestType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngularErrorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const RotaryTableType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TableErrorsType&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX___QIFAPPLICATIONS_QIFMEASUREMENT_RESOURCES_HXX
