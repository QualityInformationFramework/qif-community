// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

#ifndef CXX___QIFAPPLICATIONS_QIFRULES_HXX
#define CXX___QIFAPPLICATIONS_QIFRULES_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_WCHAR
#define XSD_USE_WCHAR
#endif

#ifndef XSD_CXX_TREE_USE_WCHAR
#define XSD_CXX_TREE_USE_WCHAR
#endif

// Begin prologue.
//
#include "..\\export.hxx"
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (LIBXSD_VERSION != 400002000000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< wchar_t, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< wchar_t, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< wchar_t, string > normalized_string;
  typedef ::xsd::cxx::tree::token< wchar_t, normalized_string > token;
  typedef ::xsd::cxx::tree::name< wchar_t, token > name;
  typedef ::xsd::cxx::tree::nmtoken< wchar_t, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< wchar_t, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< wchar_t, name > ncname;
  typedef ::xsd::cxx::tree::language< wchar_t, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< wchar_t, ncname > id;
  typedef ::xsd::cxx::tree::idref< wchar_t, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< wchar_t, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< wchar_t, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< wchar_t, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< wchar_t > buffer;
  typedef ::xsd::cxx::tree::base64_binary< wchar_t, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< wchar_t, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< wchar_t, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< wchar_t, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< wchar_t, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< wchar_t, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< wchar_t, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< wchar_t, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< wchar_t, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< wchar_t, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< wchar_t, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< wchar_t, ncname > entity;
  typedef ::xsd::cxx::tree::entities< wchar_t, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< wchar_t > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< wchar_t > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< wchar_t > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< wchar_t > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< wchar_t > error;
  typedef ::xsd::cxx::tree::diagnostics< wchar_t > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< wchar_t > exception;
  typedef ::xsd::cxx::tree::bounds< wchar_t > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< wchar_t > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< wchar_t > parsing;
  typedef ::xsd::cxx::tree::expected_element< wchar_t > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< wchar_t > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< wchar_t > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< wchar_t > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< wchar_t > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< wchar_t > no_prefix_mapping;
  typedef ::xsd::cxx::tree::no_type_info< wchar_t > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< wchar_t > not_derived;
  typedef ::xsd::cxx::tree::serialization< wchar_t > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< wchar_t > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace xsd
{
  namespace qif30
  {
    class QIFRulesType;
    class RulesUnitsType;
    class FeatureRulesType;
    class QIFRuleBaseType;
    class IfThenElseFeatureRulesType;
    class MaxFeatureRulesType;
    class PointRuleBaseType;
    class IfThenFeatureRuleType;
    class ElseRuleType;
    class ThenPointsType;
    class IfThenCircleRuleType;
    class CirclePointSamplingStrategyType;
    class IfThenCircularArcRuleType;
    class CircularArcPointSamplingStrategyType;
    class IfThenConeRuleType;
    class ConePointSamplingStrategyType;
    class IfThenConicalSegmentRuleType;
    class ConicalSegmentPointSamplingStrategyType;
    class IfThenCylinderRuleType;
    class CylinderPointSamplingStrategyType;
    class IfThenCylindricalSegmentRuleType;
    class CylindricalSegmentPointSamplingStrategyType;
    class IfThenEllipseRuleType;
    class EllipsePointSamplingStrategyType;
    class IfThenEllipticalArcRuleType;
    class EllipticalArcPointSamplingStrategyType;
    class IfThenElongatedCircleRuleType;
    class ElongatedCirclePointSamplingStrategyType;
    class IfThenElongatedCylinderRuleType;
    class ElongatedCylinderPointSamplingStrategyType;
    class IfThenExtrudedCrossSectionRuleType;
    class ExtrudedCrossSectionPointSamplingStrategyType;
    class IfThenLineRuleType;
    class LinePointSamplingStrategyType;
    class IfThenOppositeAngledLinesRuleType;
    class OppositeAngledLinesPointSamplingStrategyType;
    class IfThenOppositeAngledPlanesRuleType;
    class OppositeAngledPlanesPointSamplingStrategyType;
    class IfThenOppositeParallelLinesRuleType;
    class OppositeParallelLinesPointSamplingStrategyType;
    class IfThenOppositeParallelPlanesRuleType;
    class OppositeParallelPlanesPointSamplingStrategyType;
    class IfThenPlaneRuleType;
    class PlanePointSamplingStrategyType;
    class IfThenPointDefinedCurveRuleType;
    class PointDefinedCurvePointSamplingStrategyType;
    class IfThenPointDefinedSurfaceRuleType;
    class PointDefinedSurfacePointSamplingStrategyType;
    class IfThenPointRuleType;
    class PointPointSamplingStrategyType;
    class IfThenSphereRuleType;
    class SpherePointSamplingStrategyType;
    class IfThenSphericalSegmentRuleType;
    class SphericalSegmentPointSamplingStrategyType;
    class IfThenSurfaceOfRevolutionRuleType;
    class SurfaceOfRevolutionPointSamplingStrategyType;
    class IfThenToroidalSegmentRuleType;
    class ToroidalSegmentPointSamplingStrategyType;
    class IfThenTorusRuleType;
    class TorusPointSamplingStrategyType;
    class IfThenSurfaceRuleType;
    class IfThenCurveRuleType;
    class DMESelectionRulesType;
    class DMEThenType;
    class DMEDecisionBaseType;
    class ApplicabilityBaseType;
    class QIFMustType;
    class QIFMustNotType;
    class QIFMayType;
    class DMEDecisionClassType;
    class DMEParameterConstraintSetType;
    class DMEParameterConstraintType;
    class DMEDecisionIdType;
    class DMEDecisionMakeModelType;
    class IfThenDMERuleType;
    class ZeroToOneType;
  }
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "../QIFLibrary/Expressions.hxx"

#include "../QIFLibrary/IntermediatesPMI.hxx"

namespace xsd
{
  namespace qif30
  {
    class QIF30_SYMBOL_DECL QIFRulesType: public ::xml_schema::type
    {
      public:
      // Version
      //
      typedef ::xsd::qif30::VersionType Version_type;
      typedef ::xsd::cxx::tree::optional< Version_type > Version_optional;
      typedef ::xsd::cxx::tree::traits< Version_type, wchar_t > Version_traits;

      const Version_optional&
      Version () const;

      Version_optional&
      Version ();

      void
      Version (const Version_type& x);

      void
      Version (const Version_optional& x);

      void
      Version (::std::unique_ptr< Version_type > p);

      // RulesUnits
      //
      typedef ::xsd::qif30::RulesUnitsType RulesUnits_type;
      typedef ::xsd::cxx::tree::optional< RulesUnits_type > RulesUnits_optional;
      typedef ::xsd::cxx::tree::traits< RulesUnits_type, wchar_t > RulesUnits_traits;

      const RulesUnits_optional&
      RulesUnits () const;

      RulesUnits_optional&
      RulesUnits ();

      void
      RulesUnits (const RulesUnits_type& x);

      void
      RulesUnits (const RulesUnits_optional& x);

      void
      RulesUnits (::std::unique_ptr< RulesUnits_type > p);

      // FeatureRules
      //
      typedef ::xsd::qif30::FeatureRulesType FeatureRules_type;
      typedef ::xsd::cxx::tree::optional< FeatureRules_type > FeatureRules_optional;
      typedef ::xsd::cxx::tree::traits< FeatureRules_type, wchar_t > FeatureRules_traits;

      const FeatureRules_optional&
      FeatureRules () const;

      FeatureRules_optional&
      FeatureRules ();

      void
      FeatureRules (const FeatureRules_type& x);

      void
      FeatureRules (const FeatureRules_optional& x);

      void
      FeatureRules (::std::unique_ptr< FeatureRules_type > p);

      // DMESelectionRules
      //
      typedef ::xsd::qif30::DMESelectionRulesType DMESelectionRules_type;
      typedef ::xsd::cxx::tree::optional< DMESelectionRules_type > DMESelectionRules_optional;
      typedef ::xsd::cxx::tree::traits< DMESelectionRules_type, wchar_t > DMESelectionRules_traits;

      const DMESelectionRules_optional&
      DMESelectionRules () const;

      DMESelectionRules_optional&
      DMESelectionRules ();

      void
      DMESelectionRules (const DMESelectionRules_type& x);

      void
      DMESelectionRules (const DMESelectionRules_optional& x);

      void
      DMESelectionRules (::std::unique_ptr< DMESelectionRules_type > p);

      // Constructors.
      //
      QIFRulesType ();

      QIFRulesType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      QIFRulesType (const QIFRulesType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual QIFRulesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      QIFRulesType&
      operator= (const QIFRulesType& x);

      virtual 
      ~QIFRulesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Version_optional Version_;
      RulesUnits_optional RulesUnits_;
      FeatureRules_optional FeatureRules_;
      DMESelectionRules_optional DMESelectionRules_;
    };

    class QIF30_SYMBOL_DECL RulesUnitsType: public ::xml_schema::type
    {
      public:
      // AreaUnit
      //
      typedef ::xsd::qif30::AreaUnitType AreaUnit_type;
      typedef ::xsd::cxx::tree::optional< AreaUnit_type > AreaUnit_optional;
      typedef ::xsd::cxx::tree::traits< AreaUnit_type, wchar_t > AreaUnit_traits;

      const AreaUnit_optional&
      AreaUnit () const;

      AreaUnit_optional&
      AreaUnit ();

      void
      AreaUnit (const AreaUnit_type& x);

      void
      AreaUnit (const AreaUnit_optional& x);

      void
      AreaUnit (::std::unique_ptr< AreaUnit_type > p);

      // AngularUnit
      //
      typedef ::xsd::qif30::AngularUnitType AngularUnit_type;
      typedef ::xsd::cxx::tree::optional< AngularUnit_type > AngularUnit_optional;
      typedef ::xsd::cxx::tree::traits< AngularUnit_type, wchar_t > AngularUnit_traits;

      const AngularUnit_optional&
      AngularUnit () const;

      AngularUnit_optional&
      AngularUnit ();

      void
      AngularUnit (const AngularUnit_type& x);

      void
      AngularUnit (const AngularUnit_optional& x);

      void
      AngularUnit (::std::unique_ptr< AngularUnit_type > p);

      // ForceUnit
      //
      typedef ::xsd::qif30::ForceUnitType ForceUnit_type;
      typedef ::xsd::cxx::tree::optional< ForceUnit_type > ForceUnit_optional;
      typedef ::xsd::cxx::tree::traits< ForceUnit_type, wchar_t > ForceUnit_traits;

      const ForceUnit_optional&
      ForceUnit () const;

      ForceUnit_optional&
      ForceUnit ();

      void
      ForceUnit (const ForceUnit_type& x);

      void
      ForceUnit (const ForceUnit_optional& x);

      void
      ForceUnit (::std::unique_ptr< ForceUnit_type > p);

      // LinearUnit
      //
      typedef ::xsd::qif30::LinearUnitType LinearUnit_type;
      typedef ::xsd::cxx::tree::optional< LinearUnit_type > LinearUnit_optional;
      typedef ::xsd::cxx::tree::traits< LinearUnit_type, wchar_t > LinearUnit_traits;

      const LinearUnit_optional&
      LinearUnit () const;

      LinearUnit_optional&
      LinearUnit ();

      void
      LinearUnit (const LinearUnit_type& x);

      void
      LinearUnit (const LinearUnit_optional& x);

      void
      LinearUnit (::std::unique_ptr< LinearUnit_type > p);

      // MassUnit
      //
      typedef ::xsd::qif30::MassUnitType MassUnit_type;
      typedef ::xsd::cxx::tree::optional< MassUnit_type > MassUnit_optional;
      typedef ::xsd::cxx::tree::traits< MassUnit_type, wchar_t > MassUnit_traits;

      const MassUnit_optional&
      MassUnit () const;

      MassUnit_optional&
      MassUnit ();

      void
      MassUnit (const MassUnit_type& x);

      void
      MassUnit (const MassUnit_optional& x);

      void
      MassUnit (::std::unique_ptr< MassUnit_type > p);

      // PressureUnit
      //
      typedef ::xsd::qif30::PressureUnitType PressureUnit_type;
      typedef ::xsd::cxx::tree::optional< PressureUnit_type > PressureUnit_optional;
      typedef ::xsd::cxx::tree::traits< PressureUnit_type, wchar_t > PressureUnit_traits;

      const PressureUnit_optional&
      PressureUnit () const;

      PressureUnit_optional&
      PressureUnit ();

      void
      PressureUnit (const PressureUnit_type& x);

      void
      PressureUnit (const PressureUnit_optional& x);

      void
      PressureUnit (::std::unique_ptr< PressureUnit_type > p);

      // SpeedUnit
      //
      typedef ::xsd::qif30::SpeedUnitType SpeedUnit_type;
      typedef ::xsd::cxx::tree::optional< SpeedUnit_type > SpeedUnit_optional;
      typedef ::xsd::cxx::tree::traits< SpeedUnit_type, wchar_t > SpeedUnit_traits;

      const SpeedUnit_optional&
      SpeedUnit () const;

      SpeedUnit_optional&
      SpeedUnit ();

      void
      SpeedUnit (const SpeedUnit_type& x);

      void
      SpeedUnit (const SpeedUnit_optional& x);

      void
      SpeedUnit (::std::unique_ptr< SpeedUnit_type > p);

      // TemperatureUnit
      //
      typedef ::xsd::qif30::TemperatureUnitType TemperatureUnit_type;
      typedef ::xsd::cxx::tree::optional< TemperatureUnit_type > TemperatureUnit_optional;
      typedef ::xsd::cxx::tree::traits< TemperatureUnit_type, wchar_t > TemperatureUnit_traits;

      const TemperatureUnit_optional&
      TemperatureUnit () const;

      TemperatureUnit_optional&
      TemperatureUnit ();

      void
      TemperatureUnit (const TemperatureUnit_type& x);

      void
      TemperatureUnit (const TemperatureUnit_optional& x);

      void
      TemperatureUnit (::std::unique_ptr< TemperatureUnit_type > p);

      // TimeUnit
      //
      typedef ::xsd::qif30::TimeUnitType TimeUnit_type;
      typedef ::xsd::cxx::tree::optional< TimeUnit_type > TimeUnit_optional;
      typedef ::xsd::cxx::tree::traits< TimeUnit_type, wchar_t > TimeUnit_traits;

      const TimeUnit_optional&
      TimeUnit () const;

      TimeUnit_optional&
      TimeUnit ();

      void
      TimeUnit (const TimeUnit_type& x);

      void
      TimeUnit (const TimeUnit_optional& x);

      void
      TimeUnit (::std::unique_ptr< TimeUnit_type > p);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      RulesUnitsType ();

      RulesUnitsType (const n_type&);

      RulesUnitsType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      RulesUnitsType (const RulesUnitsType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual RulesUnitsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      RulesUnitsType&
      operator= (const RulesUnitsType& x);

      virtual 
      ~RulesUnitsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      AreaUnit_optional AreaUnit_;
      AngularUnit_optional AngularUnit_;
      ForceUnit_optional ForceUnit_;
      LinearUnit_optional LinearUnit_;
      MassUnit_optional MassUnit_;
      PressureUnit_optional PressureUnit_;
      SpeedUnit_optional SpeedUnit_;
      TemperatureUnit_optional TemperatureUnit_;
      TimeUnit_optional TimeUnit_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL FeatureRulesType: public ::xml_schema::type
    {
      public:
      // IfThenElseFeatureRules
      //
      typedef ::xsd::qif30::IfThenElseFeatureRulesType IfThenElseFeatureRules_type;
      typedef ::xsd::cxx::tree::optional< IfThenElseFeatureRules_type > IfThenElseFeatureRules_optional;
      typedef ::xsd::cxx::tree::traits< IfThenElseFeatureRules_type, wchar_t > IfThenElseFeatureRules_traits;

      const IfThenElseFeatureRules_optional&
      IfThenElseFeatureRules () const;

      IfThenElseFeatureRules_optional&
      IfThenElseFeatureRules ();

      void
      IfThenElseFeatureRules (const IfThenElseFeatureRules_type& x);

      void
      IfThenElseFeatureRules (const IfThenElseFeatureRules_optional& x);

      void
      IfThenElseFeatureRules (::std::unique_ptr< IfThenElseFeatureRules_type > p);

      // MaxFeatureRules
      //
      typedef ::xsd::qif30::MaxFeatureRulesType MaxFeatureRules_type;
      typedef ::xsd::cxx::tree::optional< MaxFeatureRules_type > MaxFeatureRules_optional;
      typedef ::xsd::cxx::tree::traits< MaxFeatureRules_type, wchar_t > MaxFeatureRules_traits;

      const MaxFeatureRules_optional&
      MaxFeatureRules () const;

      MaxFeatureRules_optional&
      MaxFeatureRules ();

      void
      MaxFeatureRules (const MaxFeatureRules_type& x);

      void
      MaxFeatureRules (const MaxFeatureRules_optional& x);

      void
      MaxFeatureRules (::std::unique_ptr< MaxFeatureRules_type > p);

      // Constructors.
      //
      FeatureRulesType ();

      FeatureRulesType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      FeatureRulesType (const FeatureRulesType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual FeatureRulesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FeatureRulesType&
      operator= (const FeatureRulesType& x);

      virtual 
      ~FeatureRulesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      IfThenElseFeatureRules_optional IfThenElseFeatureRules_;
      MaxFeatureRules_optional MaxFeatureRules_;
    };

    class QIF30_SYMBOL_DECL QIFRuleBaseType: public ::xml_schema::type
    {
      public:
      // UUID
      //
      typedef ::xsd::qif30::QPIdType UUID_type;
      typedef ::xsd::cxx::tree::optional< UUID_type > UUID_optional;
      typedef ::xsd::cxx::tree::traits< UUID_type, wchar_t > UUID_traits;

      const UUID_optional&
      UUID () const;

      UUID_optional&
      UUID ();

      void
      UUID (const UUID_type& x);

      void
      UUID (const UUID_optional& x);

      void
      UUID (::std::unique_ptr< UUID_type > p);

      // name
      //
      typedef ::xml_schema::token name_type;
      typedef ::xsd::cxx::tree::optional< name_type > name_optional;
      typedef ::xsd::cxx::tree::traits< name_type, wchar_t > name_traits;

      const name_optional&
      name () const;

      name_optional&
      name ();

      void
      name (const name_type& x);

      void
      name (const name_optional& x);

      void
      name (::std::unique_ptr< name_type > p);

      // Constructors.
      //
      QIFRuleBaseType ();

      QIFRuleBaseType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      QIFRuleBaseType (const QIFRuleBaseType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual QIFRuleBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      QIFRuleBaseType&
      operator= (const QIFRuleBaseType& x);

      virtual 
      ~QIFRuleBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      UUID_optional UUID_;
      name_optional name_;
    };

    class QIF30_SYMBOL_DECL IfThenElseFeatureRulesType: public ::xml_schema::type
    {
      public:
      // IfThenFeatureRule
      //
      typedef ::xsd::qif30::IfThenFeatureRuleType IfThenFeatureRule_type;
      typedef ::xsd::cxx::tree::sequence< IfThenFeatureRule_type > IfThenFeatureRule_sequence;
      typedef xsd::cxx::tree::sequence< IfThenFeatureRule_type >::iterator IfThenFeatureRule_iterator;
      typedef xsd::cxx::tree::sequence< IfThenFeatureRule_type >::const_iterator IfThenFeatureRule_const_iterator;
      typedef ::xsd::cxx::tree::traits< IfThenFeatureRule_type, wchar_t > IfThenFeatureRule_traits;

      const IfThenFeatureRule_sequence&
      IfThenFeatureRule () const;

      IfThenFeatureRule_sequence&
      IfThenFeatureRule ();

      void
      IfThenFeatureRule (const IfThenFeatureRule_sequence& s);

      // Else
      //
      typedef ::xsd::qif30::ElseRuleType Else_type;
      typedef ::xsd::cxx::tree::optional< Else_type > Else_optional;
      typedef ::xsd::cxx::tree::traits< Else_type, wchar_t > Else_traits;

      const Else_optional&
      Else () const;

      Else_optional&
      Else ();

      void
      Else (const Else_type& x);

      void
      Else (const Else_optional& x);

      void
      Else (::std::unique_ptr< Else_type > p);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      IfThenElseFeatureRulesType ();

      IfThenElseFeatureRulesType (const n_type&);

      IfThenElseFeatureRulesType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      IfThenElseFeatureRulesType (const IfThenElseFeatureRulesType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual IfThenElseFeatureRulesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenElseFeatureRulesType&
      operator= (const IfThenElseFeatureRulesType& x);

      virtual 
      ~IfThenElseFeatureRulesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      IfThenFeatureRule_sequence IfThenFeatureRule_;
      Else_optional Else_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL MaxFeatureRulesType: public ::xml_schema::type
    {
      public:
      // IfThenFeatureRule
      //
      typedef ::xsd::qif30::IfThenFeatureRuleType IfThenFeatureRule_type;
      typedef ::xsd::cxx::tree::sequence< IfThenFeatureRule_type > IfThenFeatureRule_sequence;
      typedef xsd::cxx::tree::sequence< IfThenFeatureRule_type >::iterator IfThenFeatureRule_iterator;
      typedef xsd::cxx::tree::sequence< IfThenFeatureRule_type >::const_iterator IfThenFeatureRule_const_iterator;
      typedef ::xsd::cxx::tree::traits< IfThenFeatureRule_type, wchar_t > IfThenFeatureRule_traits;

      const IfThenFeatureRule_sequence&
      IfThenFeatureRule () const;

      IfThenFeatureRule_sequence&
      IfThenFeatureRule ();

      void
      IfThenFeatureRule (const IfThenFeatureRule_sequence& s);

      // Else
      //
      typedef ::xsd::qif30::ElseRuleType Else_type;
      typedef ::xsd::cxx::tree::optional< Else_type > Else_optional;
      typedef ::xsd::cxx::tree::traits< Else_type, wchar_t > Else_traits;

      const Else_optional&
      Else () const;

      Else_optional&
      Else ();

      void
      Else (const Else_type& x);

      void
      Else (const Else_optional& x);

      void
      Else (::std::unique_ptr< Else_type > p);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      MaxFeatureRulesType ();

      MaxFeatureRulesType (const n_type&);

      MaxFeatureRulesType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      MaxFeatureRulesType (const MaxFeatureRulesType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual MaxFeatureRulesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MaxFeatureRulesType&
      operator= (const MaxFeatureRulesType& x);

      virtual 
      ~MaxFeatureRulesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      IfThenFeatureRule_sequence IfThenFeatureRule_;
      Else_optional Else_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL PointRuleBaseType: public ::xsd::qif30::QIFRuleBaseType
    {
      public:
      // Constructors.
      //
      PointRuleBaseType ();

      PointRuleBaseType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      PointRuleBaseType (const PointRuleBaseType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual PointRuleBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      PointRuleBaseType&
      operator= (const PointRuleBaseType&) = default;
#endif

      virtual 
      ~PointRuleBaseType ();
    };

    class QIF30_SYMBOL_DECL IfThenFeatureRuleType: public ::xsd::qif30::PointRuleBaseType
    {
      public:
      // BooleanExpression
      //
      typedef ::xsd::qif30::BooleanExpressionBaseType BooleanExpression_type;
      typedef ::xsd::cxx::tree::optional< BooleanExpression_type > BooleanExpression_optional;
      typedef ::xsd::cxx::tree::traits< BooleanExpression_type, wchar_t > BooleanExpression_traits;

      const BooleanExpression_optional&
      BooleanExpression () const;

      BooleanExpression_optional&
      BooleanExpression ();

      void
      BooleanExpression (const BooleanExpression_type& x);

      void
      BooleanExpression (const BooleanExpression_optional& x);

      void
      BooleanExpression (::std::unique_ptr< BooleanExpression_type > p);

      // ThenPoints
      //
      typedef ::xsd::qif30::ThenPointsType ThenPoints_type;
      typedef ::xsd::cxx::tree::optional< ThenPoints_type > ThenPoints_optional;
      typedef ::xsd::cxx::tree::traits< ThenPoints_type, wchar_t > ThenPoints_traits;

      const ThenPoints_optional&
      ThenPoints () const;

      ThenPoints_optional&
      ThenPoints ();

      void
      ThenPoints (const ThenPoints_type& x);

      void
      ThenPoints (const ThenPoints_optional& x);

      void
      ThenPoints (::std::unique_ptr< ThenPoints_type > p);

      // Constructors.
      //
      IfThenFeatureRuleType ();

      IfThenFeatureRuleType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      IfThenFeatureRuleType (const IfThenFeatureRuleType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual IfThenFeatureRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenFeatureRuleType&
      operator= (const IfThenFeatureRuleType& x);

      virtual 
      ~IfThenFeatureRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BooleanExpression_optional BooleanExpression_;
      ThenPoints_optional ThenPoints_;
    };

    class QIF30_SYMBOL_DECL ElseRuleType: public ::xsd::qif30::PointRuleBaseType
    {
      public:
      // ThenPoints
      //
      typedef ::xsd::qif30::ThenPointsType ThenPoints_type;
      typedef ::xsd::cxx::tree::traits< ThenPoints_type, wchar_t > ThenPoints_traits;

      const ThenPoints_type&
      ThenPoints () const;

      ThenPoints_type&
      ThenPoints ();

      void
      ThenPoints (const ThenPoints_type& x);

      void
      ThenPoints (::std::unique_ptr< ThenPoints_type > p);

      // Constructors.
      //
      ElseRuleType ();

      ElseRuleType (const ThenPoints_type&);

      ElseRuleType (::std::unique_ptr< ThenPoints_type >);

      ElseRuleType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      ElseRuleType (const ElseRuleType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual ElseRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElseRuleType&
      operator= (const ElseRuleType& x);

      virtual 
      ~ElseRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ThenPoints_type > ThenPoints_;
    };

    class QIF30_SYMBOL_DECL ThenPointsType: public ::xml_schema::type
    {
      public:
      // NumberOfPoints
      //
      typedef ::xml_schema::unsigned_int NumberOfPoints_type;
      typedef ::xsd::cxx::tree::optional< NumberOfPoints_type > NumberOfPoints_optional;
      typedef ::xsd::cxx::tree::traits< NumberOfPoints_type, wchar_t > NumberOfPoints_traits;

      const NumberOfPoints_optional&
      NumberOfPoints () const;

      NumberOfPoints_optional&
      NumberOfPoints ();

      void
      NumberOfPoints (const NumberOfPoints_type& x);

      void
      NumberOfPoints (const NumberOfPoints_optional& x);

      // MinPoints
      //
      typedef ::xml_schema::unsigned_int MinPoints_type;
      typedef ::xsd::cxx::tree::optional< MinPoints_type > MinPoints_optional;
      typedef ::xsd::cxx::tree::traits< MinPoints_type, wchar_t > MinPoints_traits;

      const MinPoints_optional&
      MinPoints () const;

      MinPoints_optional&
      MinPoints ();

      void
      MinPoints (const MinPoints_type& x);

      void
      MinPoints (const MinPoints_optional& x);

      // PointDensity
      //
      typedef ::xsd::qif30::PositiveDecimalType PointDensity_type;
      typedef ::xsd::cxx::tree::optional< PointDensity_type > PointDensity_optional;
      typedef ::xsd::cxx::tree::traits< PointDensity_type, wchar_t > PointDensity_traits;

      const PointDensity_optional&
      PointDensity () const;

      PointDensity_optional&
      PointDensity ();

      void
      PointDensity (const PointDensity_type& x);

      void
      PointDensity (const PointDensity_optional& x);

      void
      PointDensity (::std::unique_ptr< PointDensity_type > p);

      // MinPointDensity
      //
      typedef ::xsd::qif30::PositiveDecimalType MinPointDensity_type;
      typedef ::xsd::cxx::tree::optional< MinPointDensity_type > MinPointDensity_optional;
      typedef ::xsd::cxx::tree::traits< MinPointDensity_type, wchar_t > MinPointDensity_traits;

      const MinPointDensity_optional&
      MinPointDensity () const;

      MinPointDensity_optional&
      MinPointDensity ();

      void
      MinPointDensity (const MinPointDensity_type& x);

      void
      MinPointDensity (const MinPointDensity_optional& x);

      void
      MinPointDensity (::std::unique_ptr< MinPointDensity_type > p);

      // Constructors.
      //
      ThenPointsType ();

      ThenPointsType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      ThenPointsType (const ThenPointsType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual ThenPointsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ThenPointsType&
      operator= (const ThenPointsType& x);

      virtual 
      ~ThenPointsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      NumberOfPoints_optional NumberOfPoints_;
      MinPoints_optional MinPoints_;
      PointDensity_optional PointDensity_;
      MinPointDensity_optional MinPointDensity_;
    };

    class QIF30_SYMBOL_DECL IfThenCircleRuleType: public ::xsd::qif30::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif30::CirclePointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, wchar_t > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif30::SubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, wchar_t > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenCircleRuleType ();

      IfThenCircleRuleType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      IfThenCircleRuleType (const IfThenCircleRuleType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual IfThenCircleRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenCircleRuleType&
      operator= (const IfThenCircleRuleType& x);

      virtual 
      ~IfThenCircleRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class QIF30_SYMBOL_DECL CirclePointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif30::ClosedCurvePointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, wchar_t > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, wchar_t > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      CirclePointSamplingStrategyType ();

      CirclePointSamplingStrategyType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      CirclePointSamplingStrategyType (const CirclePointSamplingStrategyType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual CirclePointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CirclePointSamplingStrategyType&
      operator= (const CirclePointSamplingStrategyType& x);

      virtual 
      ~CirclePointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class QIF30_SYMBOL_DECL IfThenCircularArcRuleType: public ::xsd::qif30::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif30::CircularArcPointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, wchar_t > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif30::SubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, wchar_t > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenCircularArcRuleType ();

      IfThenCircularArcRuleType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      IfThenCircularArcRuleType (const IfThenCircularArcRuleType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual IfThenCircularArcRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenCircularArcRuleType&
      operator= (const IfThenCircularArcRuleType& x);

      virtual 
      ~IfThenCircularArcRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class QIF30_SYMBOL_DECL CircularArcPointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif30::OpenCurvePointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, wchar_t > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, wchar_t > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      CircularArcPointSamplingStrategyType ();

      CircularArcPointSamplingStrategyType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      CircularArcPointSamplingStrategyType (const CircularArcPointSamplingStrategyType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual CircularArcPointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircularArcPointSamplingStrategyType&
      operator= (const CircularArcPointSamplingStrategyType& x);

      virtual 
      ~CircularArcPointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class QIF30_SYMBOL_DECL IfThenConeRuleType: public ::xsd::qif30::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif30::ConePointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, wchar_t > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif30::SubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, wchar_t > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenConeRuleType ();

      IfThenConeRuleType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      IfThenConeRuleType (const IfThenConeRuleType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual IfThenConeRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenConeRuleType&
      operator= (const IfThenConeRuleType& x);

      virtual 
      ~IfThenConeRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class QIF30_SYMBOL_DECL ConePointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif30::ConePointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, wchar_t > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, wchar_t > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      ConePointSamplingStrategyType ();

      ConePointSamplingStrategyType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      ConePointSamplingStrategyType (const ConePointSamplingStrategyType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual ConePointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConePointSamplingStrategyType&
      operator= (const ConePointSamplingStrategyType& x);

      virtual 
      ~ConePointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class QIF30_SYMBOL_DECL IfThenConicalSegmentRuleType: public ::xsd::qif30::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif30::ConicalSegmentPointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, wchar_t > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif30::SubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, wchar_t > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenConicalSegmentRuleType ();

      IfThenConicalSegmentRuleType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      IfThenConicalSegmentRuleType (const IfThenConicalSegmentRuleType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual IfThenConicalSegmentRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenConicalSegmentRuleType&
      operator= (const IfThenConicalSegmentRuleType& x);

      virtual 
      ~IfThenConicalSegmentRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class QIF30_SYMBOL_DECL ConicalSegmentPointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif30::ConePointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, wchar_t > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, wchar_t > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      ConicalSegmentPointSamplingStrategyType ();

      ConicalSegmentPointSamplingStrategyType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      ConicalSegmentPointSamplingStrategyType (const ConicalSegmentPointSamplingStrategyType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual ConicalSegmentPointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConicalSegmentPointSamplingStrategyType&
      operator= (const ConicalSegmentPointSamplingStrategyType& x);

      virtual 
      ~ConicalSegmentPointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class QIF30_SYMBOL_DECL IfThenCylinderRuleType: public ::xsd::qif30::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif30::CylinderPointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, wchar_t > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif30::SubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, wchar_t > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenCylinderRuleType ();

      IfThenCylinderRuleType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      IfThenCylinderRuleType (const IfThenCylinderRuleType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual IfThenCylinderRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenCylinderRuleType&
      operator= (const IfThenCylinderRuleType& x);

      virtual 
      ~IfThenCylinderRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class QIF30_SYMBOL_DECL CylinderPointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif30::SurfaceOfRevolutionPointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, wchar_t > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, wchar_t > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      CylinderPointSamplingStrategyType ();

      CylinderPointSamplingStrategyType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      CylinderPointSamplingStrategyType (const CylinderPointSamplingStrategyType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual CylinderPointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CylinderPointSamplingStrategyType&
      operator= (const CylinderPointSamplingStrategyType& x);

      virtual 
      ~CylinderPointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class QIF30_SYMBOL_DECL IfThenCylindricalSegmentRuleType: public ::xsd::qif30::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif30::CylindricalSegmentPointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, wchar_t > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif30::SubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, wchar_t > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenCylindricalSegmentRuleType ();

      IfThenCylindricalSegmentRuleType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      IfThenCylindricalSegmentRuleType (const IfThenCylindricalSegmentRuleType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual IfThenCylindricalSegmentRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenCylindricalSegmentRuleType&
      operator= (const IfThenCylindricalSegmentRuleType& x);

      virtual 
      ~IfThenCylindricalSegmentRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class QIF30_SYMBOL_DECL CylindricalSegmentPointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif30::SurfaceOfRevolutionPointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, wchar_t > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, wchar_t > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      CylindricalSegmentPointSamplingStrategyType ();

      CylindricalSegmentPointSamplingStrategyType (const xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      CylindricalSegmentPointSamplingStrategyType (const CylindricalSegmentPointSamplingStrategyType& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      virtual CylindricalSegmentPointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CylindricalSegmentPointSamplingStrategyType&
      operator= (const CylindricalSegmentPointSamplingStrategyType& x);

      virtual 
      ~CylindricalSegmentPointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class QIF30_SYMBOL_DECL IfThenEllipseRuleType: public ::xsd::qif30::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif30::EllipsePointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, wchar_t > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif30::SubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, wchar_t > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenEllipseRuleType ();

      IfThenEllipseRuleType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      IfThenEllipseRuleType (const IfThenEllipseRuleType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual IfThenEllipseRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenEllipseRuleType&
      operator= (const IfThenEllipseRuleType& x);

      virtual 
      ~IfThenEllipseRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class QIF30_SYMBOL_DECL EllipsePointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif30::ClosedCurvePointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, wchar_t > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, wchar_t > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      EllipsePointSamplingStrategyType ();

      EllipsePointSamplingStrategyType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      EllipsePointSamplingStrategyType (const EllipsePointSamplingStrategyType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual EllipsePointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipsePointSamplingStrategyType&
      operator= (const EllipsePointSamplingStrategyType& x);

      virtual 
      ~EllipsePointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class QIF30_SYMBOL_DECL IfThenEllipticalArcRuleType: public ::xsd::qif30::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif30::EllipticalArcPointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, wchar_t > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif30::SubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, wchar_t > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenEllipticalArcRuleType ();

      IfThenEllipticalArcRuleType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      IfThenEllipticalArcRuleType (const IfThenEllipticalArcRuleType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual IfThenEllipticalArcRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenEllipticalArcRuleType&
      operator= (const IfThenEllipticalArcRuleType& x);

      virtual 
      ~IfThenEllipticalArcRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class QIF30_SYMBOL_DECL EllipticalArcPointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif30::OpenCurvePointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, wchar_t > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, wchar_t > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      EllipticalArcPointSamplingStrategyType ();

      EllipticalArcPointSamplingStrategyType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      EllipticalArcPointSamplingStrategyType (const EllipticalArcPointSamplingStrategyType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual EllipticalArcPointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipticalArcPointSamplingStrategyType&
      operator= (const EllipticalArcPointSamplingStrategyType& x);

      virtual 
      ~EllipticalArcPointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class QIF30_SYMBOL_DECL IfThenElongatedCircleRuleType: public ::xsd::qif30::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif30::ElongatedCirclePointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, wchar_t > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif30::SubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, wchar_t > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenElongatedCircleRuleType ();

      IfThenElongatedCircleRuleType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      IfThenElongatedCircleRuleType (const IfThenElongatedCircleRuleType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual IfThenElongatedCircleRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenElongatedCircleRuleType&
      operator= (const IfThenElongatedCircleRuleType& x);

      virtual 
      ~IfThenElongatedCircleRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class QIF30_SYMBOL_DECL ElongatedCirclePointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif30::OpenCurvePointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, wchar_t > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, wchar_t > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      ElongatedCirclePointSamplingStrategyType ();

      ElongatedCirclePointSamplingStrategyType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      ElongatedCirclePointSamplingStrategyType (const ElongatedCirclePointSamplingStrategyType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual ElongatedCirclePointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElongatedCirclePointSamplingStrategyType&
      operator= (const ElongatedCirclePointSamplingStrategyType& x);

      virtual 
      ~ElongatedCirclePointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class QIF30_SYMBOL_DECL IfThenElongatedCylinderRuleType: public ::xsd::qif30::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif30::ElongatedCylinderPointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, wchar_t > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif30::SubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, wchar_t > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenElongatedCylinderRuleType ();

      IfThenElongatedCylinderRuleType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      IfThenElongatedCylinderRuleType (const IfThenElongatedCylinderRuleType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual IfThenElongatedCylinderRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenElongatedCylinderRuleType&
      operator= (const IfThenElongatedCylinderRuleType& x);

      virtual 
      ~IfThenElongatedCylinderRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class QIF30_SYMBOL_DECL ElongatedCylinderPointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif30::ElongatedCylinderPointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, wchar_t > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, wchar_t > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      ElongatedCylinderPointSamplingStrategyType ();

      ElongatedCylinderPointSamplingStrategyType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      ElongatedCylinderPointSamplingStrategyType (const ElongatedCylinderPointSamplingStrategyType& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      virtual ElongatedCylinderPointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElongatedCylinderPointSamplingStrategyType&
      operator= (const ElongatedCylinderPointSamplingStrategyType& x);

      virtual 
      ~ElongatedCylinderPointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class QIF30_SYMBOL_DECL IfThenExtrudedCrossSectionRuleType: public ::xsd::qif30::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif30::ExtrudedCrossSectionPointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, wchar_t > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif30::SubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, wchar_t > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenExtrudedCrossSectionRuleType ();

      IfThenExtrudedCrossSectionRuleType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      IfThenExtrudedCrossSectionRuleType (const IfThenExtrudedCrossSectionRuleType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual IfThenExtrudedCrossSectionRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenExtrudedCrossSectionRuleType&
      operator= (const IfThenExtrudedCrossSectionRuleType& x);

      virtual 
      ~IfThenExtrudedCrossSectionRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class QIF30_SYMBOL_DECL ExtrudedCrossSectionPointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif30::ExtrudedCrossSectionPointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, wchar_t > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, wchar_t > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      ExtrudedCrossSectionPointSamplingStrategyType ();

      ExtrudedCrossSectionPointSamplingStrategyType (const xercesc::DOMElement& e,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

      ExtrudedCrossSectionPointSamplingStrategyType (const ExtrudedCrossSectionPointSamplingStrategyType& x,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

      virtual ExtrudedCrossSectionPointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ExtrudedCrossSectionPointSamplingStrategyType&
      operator= (const ExtrudedCrossSectionPointSamplingStrategyType& x);

      virtual 
      ~ExtrudedCrossSectionPointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class QIF30_SYMBOL_DECL IfThenLineRuleType: public ::xsd::qif30::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif30::LinePointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, wchar_t > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif30::SubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, wchar_t > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenLineRuleType ();

      IfThenLineRuleType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      IfThenLineRuleType (const IfThenLineRuleType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual IfThenLineRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenLineRuleType&
      operator= (const IfThenLineRuleType& x);

      virtual 
      ~IfThenLineRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class QIF30_SYMBOL_DECL LinePointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif30::OpenCurvePointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, wchar_t > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, wchar_t > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      LinePointSamplingStrategyType ();

      LinePointSamplingStrategyType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      LinePointSamplingStrategyType (const LinePointSamplingStrategyType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual LinePointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LinePointSamplingStrategyType&
      operator= (const LinePointSamplingStrategyType& x);

      virtual 
      ~LinePointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class QIF30_SYMBOL_DECL IfThenOppositeAngledLinesRuleType: public ::xsd::qif30::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif30::OppositeAngledLinesPointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, wchar_t > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif30::SubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, wchar_t > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenOppositeAngledLinesRuleType ();

      IfThenOppositeAngledLinesRuleType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      IfThenOppositeAngledLinesRuleType (const IfThenOppositeAngledLinesRuleType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual IfThenOppositeAngledLinesRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenOppositeAngledLinesRuleType&
      operator= (const IfThenOppositeAngledLinesRuleType& x);

      virtual 
      ~IfThenOppositeAngledLinesRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class QIF30_SYMBOL_DECL OppositeAngledLinesPointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif30::OpenCurvePointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, wchar_t > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, wchar_t > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      OppositeAngledLinesPointSamplingStrategyType ();

      OppositeAngledLinesPointSamplingStrategyType (const xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      OppositeAngledLinesPointSamplingStrategyType (const OppositeAngledLinesPointSamplingStrategyType& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      virtual OppositeAngledLinesPointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeAngledLinesPointSamplingStrategyType&
      operator= (const OppositeAngledLinesPointSamplingStrategyType& x);

      virtual 
      ~OppositeAngledLinesPointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class QIF30_SYMBOL_DECL IfThenOppositeAngledPlanesRuleType: public ::xsd::qif30::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif30::OppositeAngledPlanesPointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, wchar_t > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif30::SubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, wchar_t > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenOppositeAngledPlanesRuleType ();

      IfThenOppositeAngledPlanesRuleType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      IfThenOppositeAngledPlanesRuleType (const IfThenOppositeAngledPlanesRuleType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual IfThenOppositeAngledPlanesRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenOppositeAngledPlanesRuleType&
      operator= (const IfThenOppositeAngledPlanesRuleType& x);

      virtual 
      ~IfThenOppositeAngledPlanesRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class QIF30_SYMBOL_DECL OppositeAngledPlanesPointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif30::PlanePointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, wchar_t > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, wchar_t > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      OppositeAngledPlanesPointSamplingStrategyType ();

      OppositeAngledPlanesPointSamplingStrategyType (const xercesc::DOMElement& e,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

      OppositeAngledPlanesPointSamplingStrategyType (const OppositeAngledPlanesPointSamplingStrategyType& x,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

      virtual OppositeAngledPlanesPointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeAngledPlanesPointSamplingStrategyType&
      operator= (const OppositeAngledPlanesPointSamplingStrategyType& x);

      virtual 
      ~OppositeAngledPlanesPointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class QIF30_SYMBOL_DECL IfThenOppositeParallelLinesRuleType: public ::xsd::qif30::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif30::OppositeParallelLinesPointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, wchar_t > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif30::SubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, wchar_t > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenOppositeParallelLinesRuleType ();

      IfThenOppositeParallelLinesRuleType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      IfThenOppositeParallelLinesRuleType (const IfThenOppositeParallelLinesRuleType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual IfThenOppositeParallelLinesRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenOppositeParallelLinesRuleType&
      operator= (const IfThenOppositeParallelLinesRuleType& x);

      virtual 
      ~IfThenOppositeParallelLinesRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class QIF30_SYMBOL_DECL OppositeParallelLinesPointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif30::OpenCurvePointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, wchar_t > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, wchar_t > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      OppositeParallelLinesPointSamplingStrategyType ();

      OppositeParallelLinesPointSamplingStrategyType (const xercesc::DOMElement& e,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

      OppositeParallelLinesPointSamplingStrategyType (const OppositeParallelLinesPointSamplingStrategyType& x,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

      virtual OppositeParallelLinesPointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeParallelLinesPointSamplingStrategyType&
      operator= (const OppositeParallelLinesPointSamplingStrategyType& x);

      virtual 
      ~OppositeParallelLinesPointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class QIF30_SYMBOL_DECL IfThenOppositeParallelPlanesRuleType: public ::xsd::qif30::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif30::OppositeParallelPlanesPointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, wchar_t > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif30::SubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, wchar_t > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenOppositeParallelPlanesRuleType ();

      IfThenOppositeParallelPlanesRuleType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      IfThenOppositeParallelPlanesRuleType (const IfThenOppositeParallelPlanesRuleType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual IfThenOppositeParallelPlanesRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenOppositeParallelPlanesRuleType&
      operator= (const IfThenOppositeParallelPlanesRuleType& x);

      virtual 
      ~IfThenOppositeParallelPlanesRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class QIF30_SYMBOL_DECL OppositeParallelPlanesPointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif30::PlanePointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, wchar_t > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, wchar_t > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      OppositeParallelPlanesPointSamplingStrategyType ();

      OppositeParallelPlanesPointSamplingStrategyType (const xercesc::DOMElement& e,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

      OppositeParallelPlanesPointSamplingStrategyType (const OppositeParallelPlanesPointSamplingStrategyType& x,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

      virtual OppositeParallelPlanesPointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeParallelPlanesPointSamplingStrategyType&
      operator= (const OppositeParallelPlanesPointSamplingStrategyType& x);

      virtual 
      ~OppositeParallelPlanesPointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class QIF30_SYMBOL_DECL IfThenPlaneRuleType: public ::xsd::qif30::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif30::PlanePointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, wchar_t > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif30::SubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, wchar_t > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenPlaneRuleType ();

      IfThenPlaneRuleType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      IfThenPlaneRuleType (const IfThenPlaneRuleType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual IfThenPlaneRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenPlaneRuleType&
      operator= (const IfThenPlaneRuleType& x);

      virtual 
      ~IfThenPlaneRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class QIF30_SYMBOL_DECL PlanePointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif30::PlanePointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, wchar_t > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, wchar_t > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      PlanePointSamplingStrategyType ();

      PlanePointSamplingStrategyType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      PlanePointSamplingStrategyType (const PlanePointSamplingStrategyType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual PlanePointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PlanePointSamplingStrategyType&
      operator= (const PlanePointSamplingStrategyType& x);

      virtual 
      ~PlanePointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class QIF30_SYMBOL_DECL IfThenPointDefinedCurveRuleType: public ::xsd::qif30::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif30::PointDefinedCurvePointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, wchar_t > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif30::SubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, wchar_t > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenPointDefinedCurveRuleType ();

      IfThenPointDefinedCurveRuleType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      IfThenPointDefinedCurveRuleType (const IfThenPointDefinedCurveRuleType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual IfThenPointDefinedCurveRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenPointDefinedCurveRuleType&
      operator= (const IfThenPointDefinedCurveRuleType& x);

      virtual 
      ~IfThenPointDefinedCurveRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class QIF30_SYMBOL_DECL PointDefinedCurvePointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif30::PointDefinedPointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, wchar_t > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, wchar_t > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      PointDefinedCurvePointSamplingStrategyType ();

      PointDefinedCurvePointSamplingStrategyType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      PointDefinedCurvePointSamplingStrategyType (const PointDefinedCurvePointSamplingStrategyType& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      virtual PointDefinedCurvePointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointDefinedCurvePointSamplingStrategyType&
      operator= (const PointDefinedCurvePointSamplingStrategyType& x);

      virtual 
      ~PointDefinedCurvePointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class QIF30_SYMBOL_DECL IfThenPointDefinedSurfaceRuleType: public ::xsd::qif30::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif30::PointDefinedSurfacePointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, wchar_t > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif30::SubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, wchar_t > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenPointDefinedSurfaceRuleType ();

      IfThenPointDefinedSurfaceRuleType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      IfThenPointDefinedSurfaceRuleType (const IfThenPointDefinedSurfaceRuleType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual IfThenPointDefinedSurfaceRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenPointDefinedSurfaceRuleType&
      operator= (const IfThenPointDefinedSurfaceRuleType& x);

      virtual 
      ~IfThenPointDefinedSurfaceRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class QIF30_SYMBOL_DECL PointDefinedSurfacePointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif30::PointDefinedPointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, wchar_t > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, wchar_t > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      PointDefinedSurfacePointSamplingStrategyType ();

      PointDefinedSurfacePointSamplingStrategyType (const xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      PointDefinedSurfacePointSamplingStrategyType (const PointDefinedSurfacePointSamplingStrategyType& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      virtual PointDefinedSurfacePointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointDefinedSurfacePointSamplingStrategyType&
      operator= (const PointDefinedSurfacePointSamplingStrategyType& x);

      virtual 
      ~PointDefinedSurfacePointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class QIF30_SYMBOL_DECL IfThenPointRuleType: public ::xsd::qif30::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif30::PointPointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, wchar_t > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > p);

      // Constructors.
      //
      IfThenPointRuleType ();

      IfThenPointRuleType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      IfThenPointRuleType (const IfThenPointRuleType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual IfThenPointRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenPointRuleType&
      operator= (const IfThenPointRuleType& x);

      virtual 
      ~IfThenPointRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
    };

    class QIF30_SYMBOL_DECL PointPointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif30::PointPointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, wchar_t > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, wchar_t > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      PointPointSamplingStrategyType ();

      PointPointSamplingStrategyType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      PointPointSamplingStrategyType (const PointPointSamplingStrategyType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual PointPointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointPointSamplingStrategyType&
      operator= (const PointPointSamplingStrategyType& x);

      virtual 
      ~PointPointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class QIF30_SYMBOL_DECL IfThenSphereRuleType: public ::xsd::qif30::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif30::SpherePointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, wchar_t > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif30::SubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, wchar_t > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenSphereRuleType ();

      IfThenSphereRuleType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      IfThenSphereRuleType (const IfThenSphereRuleType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual IfThenSphereRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenSphereRuleType&
      operator= (const IfThenSphereRuleType& x);

      virtual 
      ~IfThenSphereRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class QIF30_SYMBOL_DECL SpherePointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif30::SpherePointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, wchar_t > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, wchar_t > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      SpherePointSamplingStrategyType ();

      SpherePointSamplingStrategyType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      SpherePointSamplingStrategyType (const SpherePointSamplingStrategyType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual SpherePointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SpherePointSamplingStrategyType&
      operator= (const SpherePointSamplingStrategyType& x);

      virtual 
      ~SpherePointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class QIF30_SYMBOL_DECL IfThenSphericalSegmentRuleType: public ::xsd::qif30::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif30::SphericalSegmentPointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, wchar_t > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif30::SubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, wchar_t > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenSphericalSegmentRuleType ();

      IfThenSphericalSegmentRuleType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      IfThenSphericalSegmentRuleType (const IfThenSphericalSegmentRuleType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual IfThenSphericalSegmentRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenSphericalSegmentRuleType&
      operator= (const IfThenSphericalSegmentRuleType& x);

      virtual 
      ~IfThenSphericalSegmentRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class QIF30_SYMBOL_DECL SphericalSegmentPointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif30::SpherePointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, wchar_t > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, wchar_t > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      SphericalSegmentPointSamplingStrategyType ();

      SphericalSegmentPointSamplingStrategyType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      SphericalSegmentPointSamplingStrategyType (const SphericalSegmentPointSamplingStrategyType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      virtual SphericalSegmentPointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SphericalSegmentPointSamplingStrategyType&
      operator= (const SphericalSegmentPointSamplingStrategyType& x);

      virtual 
      ~SphericalSegmentPointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class QIF30_SYMBOL_DECL IfThenSurfaceOfRevolutionRuleType: public ::xsd::qif30::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif30::SurfaceOfRevolutionPointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, wchar_t > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif30::SubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, wchar_t > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenSurfaceOfRevolutionRuleType ();

      IfThenSurfaceOfRevolutionRuleType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      IfThenSurfaceOfRevolutionRuleType (const IfThenSurfaceOfRevolutionRuleType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual IfThenSurfaceOfRevolutionRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenSurfaceOfRevolutionRuleType&
      operator= (const IfThenSurfaceOfRevolutionRuleType& x);

      virtual 
      ~IfThenSurfaceOfRevolutionRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class QIF30_SYMBOL_DECL SurfaceOfRevolutionPointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif30::SurfaceOfRevolutionPointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, wchar_t > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, wchar_t > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      SurfaceOfRevolutionPointSamplingStrategyType ();

      SurfaceOfRevolutionPointSamplingStrategyType (const xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      SurfaceOfRevolutionPointSamplingStrategyType (const SurfaceOfRevolutionPointSamplingStrategyType& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      virtual SurfaceOfRevolutionPointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SurfaceOfRevolutionPointSamplingStrategyType&
      operator= (const SurfaceOfRevolutionPointSamplingStrategyType& x);

      virtual 
      ~SurfaceOfRevolutionPointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class QIF30_SYMBOL_DECL IfThenToroidalSegmentRuleType: public ::xsd::qif30::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif30::ToroidalSegmentPointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, wchar_t > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif30::SubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, wchar_t > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenToroidalSegmentRuleType ();

      IfThenToroidalSegmentRuleType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      IfThenToroidalSegmentRuleType (const IfThenToroidalSegmentRuleType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual IfThenToroidalSegmentRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenToroidalSegmentRuleType&
      operator= (const IfThenToroidalSegmentRuleType& x);

      virtual 
      ~IfThenToroidalSegmentRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class QIF30_SYMBOL_DECL ToroidalSegmentPointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif30::SurfaceOfRevolutionPointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, wchar_t > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, wchar_t > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      ToroidalSegmentPointSamplingStrategyType ();

      ToroidalSegmentPointSamplingStrategyType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      ToroidalSegmentPointSamplingStrategyType (const ToroidalSegmentPointSamplingStrategyType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual ToroidalSegmentPointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToroidalSegmentPointSamplingStrategyType&
      operator= (const ToroidalSegmentPointSamplingStrategyType& x);

      virtual 
      ~ToroidalSegmentPointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class QIF30_SYMBOL_DECL IfThenTorusRuleType: public ::xsd::qif30::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif30::TorusPointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, wchar_t > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::unique_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif30::SubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, wchar_t > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::unique_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenTorusRuleType ();

      IfThenTorusRuleType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      IfThenTorusRuleType (const IfThenTorusRuleType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual IfThenTorusRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenTorusRuleType&
      operator= (const IfThenTorusRuleType& x);

      virtual 
      ~IfThenTorusRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class QIF30_SYMBOL_DECL TorusPointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif30::SurfaceOfRevolutionPointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, wchar_t > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::unique_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, wchar_t > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::unique_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      TorusPointSamplingStrategyType ();

      TorusPointSamplingStrategyType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      TorusPointSamplingStrategyType (const TorusPointSamplingStrategyType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual TorusPointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TorusPointSamplingStrategyType&
      operator= (const TorusPointSamplingStrategyType& x);

      virtual 
      ~TorusPointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class QIF30_SYMBOL_DECL IfThenSurfaceRuleType: public ::xsd::qif30::IfThenFeatureRuleType
    {
      public:
      // Constructors.
      //
      IfThenSurfaceRuleType ();

      IfThenSurfaceRuleType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      IfThenSurfaceRuleType (const IfThenSurfaceRuleType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual IfThenSurfaceRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      IfThenSurfaceRuleType&
      operator= (const IfThenSurfaceRuleType&) = default;
#endif

      virtual 
      ~IfThenSurfaceRuleType ();
    };

    class QIF30_SYMBOL_DECL IfThenCurveRuleType: public ::xsd::qif30::IfThenFeatureRuleType
    {
      public:
      // Constructors.
      //
      IfThenCurveRuleType ();

      IfThenCurveRuleType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      IfThenCurveRuleType (const IfThenCurveRuleType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual IfThenCurveRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      IfThenCurveRuleType&
      operator= (const IfThenCurveRuleType&) = default;
#endif

      virtual 
      ~IfThenCurveRuleType ();
    };

    class QIF30_SYMBOL_DECL DMESelectionRulesType: public ::xml_schema::type
    {
      public:
      // DMEDecisionRule
      //
      typedef ::xsd::qif30::IfThenDMERuleType DMEDecisionRule_type;
      typedef ::xsd::cxx::tree::sequence< DMEDecisionRule_type > DMEDecisionRule_sequence;
      typedef xsd::cxx::tree::sequence< DMEDecisionRule_type >::iterator DMEDecisionRule_iterator;
      typedef xsd::cxx::tree::sequence< DMEDecisionRule_type >::const_iterator DMEDecisionRule_const_iterator;
      typedef ::xsd::cxx::tree::traits< DMEDecisionRule_type, wchar_t > DMEDecisionRule_traits;

      const DMEDecisionRule_sequence&
      DMEDecisionRule () const;

      DMEDecisionRule_sequence&
      DMEDecisionRule ();

      void
      DMEDecisionRule (const DMEDecisionRule_sequence& s);

      // defaultDesirability
      //
      typedef ::xsd::qif30::ZeroToOneType defaultDesirability_type;
      typedef ::xsd::cxx::tree::traits< defaultDesirability_type, wchar_t > defaultDesirability_traits;

      const defaultDesirability_type&
      defaultDesirability () const;

      defaultDesirability_type&
      defaultDesirability ();

      void
      defaultDesirability (const defaultDesirability_type& x);

      void
      defaultDesirability (::std::unique_ptr< defaultDesirability_type > p);

      static defaultDesirability_type
      defaultDesirability_default_value ();

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      DMESelectionRulesType ();

      DMESelectionRulesType (const n_type&);

      DMESelectionRulesType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      DMESelectionRulesType (const DMESelectionRulesType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual DMESelectionRulesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DMESelectionRulesType&
      operator= (const DMESelectionRulesType& x);

      virtual 
      ~DMESelectionRulesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      DMEDecisionRule_sequence DMEDecisionRule_;
      ::xsd::cxx::tree::one< defaultDesirability_type > defaultDesirability_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL DMEThenType: public ::xml_schema::type
    {
      public:
      // DMEDecision
      //
      typedef ::xsd::qif30::DMEDecisionBaseType DMEDecision_type;
      typedef ::xsd::cxx::tree::sequence< DMEDecision_type > DMEDecision_sequence;
      typedef xsd::cxx::tree::sequence< DMEDecision_type >::iterator DMEDecision_iterator;
      typedef xsd::cxx::tree::sequence< DMEDecision_type >::const_iterator DMEDecision_const_iterator;
      typedef ::xsd::cxx::tree::traits< DMEDecision_type, wchar_t > DMEDecision_traits;

      const DMEDecision_sequence&
      DMEDecision () const;

      DMEDecision_sequence&
      DMEDecision ();

      void
      DMEDecision (const DMEDecision_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      DMEThenType ();

      DMEThenType (const n_type&);

      DMEThenType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      DMEThenType (const DMEThenType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual DMEThenType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DMEThenType&
      operator= (const DMEThenType& x);

      virtual 
      ~DMEThenType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      DMEDecision_sequence DMEDecision_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL DMEDecisionBaseType: public ::xml_schema::type
    {
      public:
      // Applicability
      //
      typedef ::xsd::qif30::ApplicabilityBaseType Applicability_type;
      typedef ::xsd::cxx::tree::traits< Applicability_type, wchar_t > Applicability_traits;

      const Applicability_type&
      Applicability () const;

      Applicability_type&
      Applicability ();

      void
      Applicability (const Applicability_type& x);

      void
      Applicability (::std::unique_ptr< Applicability_type > p);

      // Constructors.
      //
      DMEDecisionBaseType ();

      DMEDecisionBaseType (const Applicability_type&);

      DMEDecisionBaseType (::std::unique_ptr< Applicability_type >);

      DMEDecisionBaseType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      DMEDecisionBaseType (const DMEDecisionBaseType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual DMEDecisionBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      DMEDecisionBaseType&
      operator= (const DMEDecisionBaseType& x);

      virtual 
      ~DMEDecisionBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Applicability_type > Applicability_;
    };

    class QIF30_SYMBOL_DECL ApplicabilityBaseType: public ::xml_schema::type
    {
      public:
      // Constructors.
      //
      ApplicabilityBaseType ();

      ApplicabilityBaseType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      ApplicabilityBaseType (const xercesc::DOMAttr& a,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      ApplicabilityBaseType (const ::std::wstring& s,
                             const xercesc::DOMElement* e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      ApplicabilityBaseType (const ApplicabilityBaseType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual ApplicabilityBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      ApplicabilityBaseType&
      operator= (const ApplicabilityBaseType&) = default;
#endif

      virtual 
      ~ApplicabilityBaseType ();
    };

    class QIF30_SYMBOL_DECL QIFMustType: public ::xsd::qif30::ApplicabilityBaseType
    {
      public:
      // Constructors.
      //
      QIFMustType ();

      QIFMustType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      QIFMustType (const xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      QIFMustType (const ::std::wstring& s,
                   const xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      QIFMustType (const QIFMustType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual QIFMustType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      QIFMustType&
      operator= (const QIFMustType&) = default;
#endif

      virtual 
      ~QIFMustType ();
    };

    class QIF30_SYMBOL_DECL QIFMustNotType: public ::xsd::qif30::ApplicabilityBaseType
    {
      public:
      // Constructors.
      //
      QIFMustNotType ();

      QIFMustNotType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      QIFMustNotType (const xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      QIFMustNotType (const ::std::wstring& s,
                      const xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      QIFMustNotType (const QIFMustNotType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual QIFMustNotType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      QIFMustNotType&
      operator= (const QIFMustNotType&) = default;
#endif

      virtual 
      ~QIFMustNotType ();
    };

    class QIF30_SYMBOL_DECL QIFMayType: public ::xsd::qif30::ApplicabilityBaseType
    {
      public:
      // desirability
      //
      typedef ::xsd::qif30::ZeroToOneType desirability_type;
      typedef ::xsd::cxx::tree::optional< desirability_type > desirability_optional;
      typedef ::xsd::cxx::tree::traits< desirability_type, wchar_t > desirability_traits;

      const desirability_optional&
      desirability () const;

      desirability_optional&
      desirability ();

      void
      desirability (const desirability_type& x);

      void
      desirability (const desirability_optional& x);

      void
      desirability (::std::unique_ptr< desirability_type > p);

      // Constructors.
      //
      QIFMayType ();

      QIFMayType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      QIFMayType (const QIFMayType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual QIFMayType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      QIFMayType&
      operator= (const QIFMayType& x);

      virtual 
      ~QIFMayType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      desirability_optional desirability_;
    };

    class QIF30_SYMBOL_DECL DMEDecisionClassType: public ::xsd::qif30::DMEDecisionBaseType
    {
      public:
      // DMEClassName
      //
      typedef ::xsd::qif30::DMEClassNameEnumType DMEClassName_type;
      typedef ::xsd::cxx::tree::traits< DMEClassName_type, wchar_t > DMEClassName_traits;

      const DMEClassName_type&
      DMEClassName () const;

      DMEClassName_type&
      DMEClassName ();

      void
      DMEClassName (const DMEClassName_type& x);

      void
      DMEClassName (::std::unique_ptr< DMEClassName_type > p);

      // ParameterConstraints
      //
      typedef ::xsd::qif30::DMEParameterConstraintSetType ParameterConstraints_type;
      typedef ::xsd::cxx::tree::optional< ParameterConstraints_type > ParameterConstraints_optional;
      typedef ::xsd::cxx::tree::traits< ParameterConstraints_type, wchar_t > ParameterConstraints_traits;

      const ParameterConstraints_optional&
      ParameterConstraints () const;

      ParameterConstraints_optional&
      ParameterConstraints ();

      void
      ParameterConstraints (const ParameterConstraints_type& x);

      void
      ParameterConstraints (const ParameterConstraints_optional& x);

      void
      ParameterConstraints (::std::unique_ptr< ParameterConstraints_type > p);

      // Constructors.
      //
      DMEDecisionClassType ();

      DMEDecisionClassType (const Applicability_type&,
                            const DMEClassName_type&);

      DMEDecisionClassType (::std::unique_ptr< Applicability_type >,
                            const DMEClassName_type&);

      DMEDecisionClassType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      DMEDecisionClassType (const DMEDecisionClassType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual DMEDecisionClassType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DMEDecisionClassType&
      operator= (const DMEDecisionClassType& x);

      virtual 
      ~DMEDecisionClassType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DMEClassName_type > DMEClassName_;
      ParameterConstraints_optional ParameterConstraints_;
    };

    class QIF30_SYMBOL_DECL DMEParameterConstraintSetType: public ::xml_schema::type
    {
      public:
      // DMEParameterConstraint
      //
      typedef ::xsd::qif30::DMEParameterConstraintType DMEParameterConstraint_type;
      typedef ::xsd::cxx::tree::sequence< DMEParameterConstraint_type > DMEParameterConstraint_sequence;
      typedef xsd::cxx::tree::sequence< DMEParameterConstraint_type >::iterator DMEParameterConstraint_iterator;
      typedef xsd::cxx::tree::sequence< DMEParameterConstraint_type >::const_iterator DMEParameterConstraint_const_iterator;
      typedef ::xsd::cxx::tree::traits< DMEParameterConstraint_type, wchar_t > DMEParameterConstraint_traits;

      const DMEParameterConstraint_sequence&
      DMEParameterConstraint () const;

      DMEParameterConstraint_sequence&
      DMEParameterConstraint ();

      void
      DMEParameterConstraint (const DMEParameterConstraint_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      DMEParameterConstraintSetType ();

      DMEParameterConstraintSetType (const n_type&);

      DMEParameterConstraintSetType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      DMEParameterConstraintSetType (const DMEParameterConstraintSetType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual DMEParameterConstraintSetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DMEParameterConstraintSetType&
      operator= (const DMEParameterConstraintSetType& x);

      virtual 
      ~DMEParameterConstraintSetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      DMEParameterConstraint_sequence DMEParameterConstraint_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL DMEParameterConstraintType: public ::xml_schema::type
    {
      public:
      // ParameterName
      //
      typedef ::xml_schema::token ParameterName_type;
      typedef ::xsd::cxx::tree::traits< ParameterName_type, wchar_t > ParameterName_traits;

      const ParameterName_type&
      ParameterName () const;

      ParameterName_type&
      ParameterName ();

      void
      ParameterName (const ParameterName_type& x);

      void
      ParameterName (::std::unique_ptr< ParameterName_type > p);

      // Comparison
      //
      typedef ::xsd::qif30::ArithmeticComparisonEnumType Comparison_type;
      typedef ::xsd::cxx::tree::traits< Comparison_type, wchar_t > Comparison_traits;

      const Comparison_type&
      Comparison () const;

      Comparison_type&
      Comparison ();

      void
      Comparison (const Comparison_type& x);

      void
      Comparison (::std::unique_ptr< Comparison_type > p);

      // ArithmeticExpression
      //
      typedef ::xsd::qif30::ArithmeticExpressionBaseType ArithmeticExpression_type;
      typedef ::xsd::cxx::tree::traits< ArithmeticExpression_type, wchar_t > ArithmeticExpression_traits;

      const ArithmeticExpression_type&
      ArithmeticExpression () const;

      ArithmeticExpression_type&
      ArithmeticExpression ();

      void
      ArithmeticExpression (const ArithmeticExpression_type& x);

      void
      ArithmeticExpression (::std::unique_ptr< ArithmeticExpression_type > p);

      // Constructors.
      //
      DMEParameterConstraintType ();

      DMEParameterConstraintType (const ParameterName_type&,
                                  const Comparison_type&,
                                  const ArithmeticExpression_type&);

      DMEParameterConstraintType (const ParameterName_type&,
                                  const Comparison_type&,
                                  ::std::unique_ptr< ArithmeticExpression_type >);

      DMEParameterConstraintType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      DMEParameterConstraintType (const DMEParameterConstraintType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual DMEParameterConstraintType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DMEParameterConstraintType&
      operator= (const DMEParameterConstraintType& x);

      virtual 
      ~DMEParameterConstraintType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ParameterName_type > ParameterName_;
      ::xsd::cxx::tree::one< Comparison_type > Comparison_;
      ::xsd::cxx::tree::one< ArithmeticExpression_type > ArithmeticExpression_;
    };

    class QIF30_SYMBOL_DECL DMEDecisionIdType: public ::xsd::qif30::DMEDecisionBaseType
    {
      public:
      // DMEId
      //
      typedef ::xsd::qif30::QIFReferenceType DMEId_type;
      typedef ::xsd::cxx::tree::traits< DMEId_type, wchar_t > DMEId_traits;

      const DMEId_type&
      DMEId () const;

      DMEId_type&
      DMEId ();

      void
      DMEId (const DMEId_type& x);

      void
      DMEId (::std::unique_ptr< DMEId_type > p);

      // Constructors.
      //
      DMEDecisionIdType ();

      DMEDecisionIdType (const Applicability_type&,
                         const DMEId_type&);

      DMEDecisionIdType (const Applicability_type&,
                         ::std::unique_ptr< DMEId_type >);

      DMEDecisionIdType (::std::unique_ptr< Applicability_type >,
                         const DMEId_type&);

      DMEDecisionIdType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      DMEDecisionIdType (const DMEDecisionIdType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual DMEDecisionIdType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DMEDecisionIdType&
      operator= (const DMEDecisionIdType& x);

      virtual 
      ~DMEDecisionIdType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DMEId_type > DMEId_;
    };

    class QIF30_SYMBOL_DECL DMEDecisionMakeModelType: public ::xsd::qif30::DMEDecisionBaseType
    {
      public:
      // Manufacturer
      //
      typedef ::xml_schema::string Manufacturer_type;
      typedef ::xsd::cxx::tree::traits< Manufacturer_type, wchar_t > Manufacturer_traits;

      const Manufacturer_type&
      Manufacturer () const;

      Manufacturer_type&
      Manufacturer ();

      void
      Manufacturer (const Manufacturer_type& x);

      void
      Manufacturer (::std::unique_ptr< Manufacturer_type > p);

      // ModelNumber
      //
      typedef ::xml_schema::string ModelNumber_type;
      typedef ::xsd::cxx::tree::traits< ModelNumber_type, wchar_t > ModelNumber_traits;

      const ModelNumber_type&
      ModelNumber () const;

      ModelNumber_type&
      ModelNumber ();

      void
      ModelNumber (const ModelNumber_type& x);

      void
      ModelNumber (::std::unique_ptr< ModelNumber_type > p);

      // SerialNumber
      //
      typedef ::xml_schema::string SerialNumber_type;
      typedef ::xsd::cxx::tree::optional< SerialNumber_type > SerialNumber_optional;
      typedef ::xsd::cxx::tree::traits< SerialNumber_type, wchar_t > SerialNumber_traits;

      const SerialNumber_optional&
      SerialNumber () const;

      SerialNumber_optional&
      SerialNumber ();

      void
      SerialNumber (const SerialNumber_type& x);

      void
      SerialNumber (const SerialNumber_optional& x);

      void
      SerialNumber (::std::unique_ptr< SerialNumber_type > p);

      // Constructors.
      //
      DMEDecisionMakeModelType ();

      DMEDecisionMakeModelType (const Applicability_type&,
                                const Manufacturer_type&,
                                const ModelNumber_type&);

      DMEDecisionMakeModelType (::std::unique_ptr< Applicability_type >,
                                const Manufacturer_type&,
                                const ModelNumber_type&);

      DMEDecisionMakeModelType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      DMEDecisionMakeModelType (const DMEDecisionMakeModelType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual DMEDecisionMakeModelType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DMEDecisionMakeModelType&
      operator= (const DMEDecisionMakeModelType& x);

      virtual 
      ~DMEDecisionMakeModelType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Manufacturer_type > Manufacturer_;
      ::xsd::cxx::tree::one< ModelNumber_type > ModelNumber_;
      SerialNumber_optional SerialNumber_;
    };

    class QIF30_SYMBOL_DECL IfThenDMERuleType: public ::xsd::qif30::QIFRuleBaseType
    {
      public:
      // BooleanExpression
      //
      typedef ::xsd::qif30::BooleanExpressionBaseType BooleanExpression_type;
      typedef ::xsd::cxx::tree::optional< BooleanExpression_type > BooleanExpression_optional;
      typedef ::xsd::cxx::tree::traits< BooleanExpression_type, wchar_t > BooleanExpression_traits;

      const BooleanExpression_optional&
      BooleanExpression () const;

      BooleanExpression_optional&
      BooleanExpression ();

      void
      BooleanExpression (const BooleanExpression_type& x);

      void
      BooleanExpression (const BooleanExpression_optional& x);

      void
      BooleanExpression (::std::unique_ptr< BooleanExpression_type > p);

      // DMEThen
      //
      typedef ::xsd::qif30::DMEThenType DMEThen_type;
      typedef ::xsd::cxx::tree::traits< DMEThen_type, wchar_t > DMEThen_traits;

      const DMEThen_type&
      DMEThen () const;

      DMEThen_type&
      DMEThen ();

      void
      DMEThen (const DMEThen_type& x);

      void
      DMEThen (::std::unique_ptr< DMEThen_type > p);

      // Constructors.
      //
      IfThenDMERuleType ();

      IfThenDMERuleType (const DMEThen_type&);

      IfThenDMERuleType (::std::unique_ptr< DMEThen_type >);

      IfThenDMERuleType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      IfThenDMERuleType (const IfThenDMERuleType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual IfThenDMERuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenDMERuleType&
      operator= (const IfThenDMERuleType& x);

      virtual 
      ~IfThenDMERuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BooleanExpression_optional BooleanExpression_;
      ::xsd::cxx::tree::one< DMEThen_type > DMEThen_;
    };

    class QIF30_SYMBOL_DECL ZeroToOneType: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
    {
      public:
      // Constructors.
      //
      ZeroToOneType ();

      ZeroToOneType (const ::xml_schema::double_&);

      ZeroToOneType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      ZeroToOneType (const xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      ZeroToOneType (const ::std::wstring& s,
                     const xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      ZeroToOneType (const ZeroToOneType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual ZeroToOneType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ZeroToOneType&
      operator= (const ZeroToOneType&) = default;
#endif

      virtual 
      ~ZeroToOneType ();
    };
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace xsd
{
  namespace qif30
  {
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace xsd
{
  namespace qif30
  {
    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const QIFRulesType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const RulesUnitsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FeatureRulesType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const QIFRuleBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const IfThenElseFeatureRulesType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MaxFeatureRulesType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointRuleBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const IfThenFeatureRuleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ElseRuleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ThenPointsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const IfThenCircleRuleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CirclePointSamplingStrategyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const IfThenCircularArcRuleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircularArcPointSamplingStrategyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const IfThenConeRuleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConePointSamplingStrategyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const IfThenConicalSegmentRuleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConicalSegmentPointSamplingStrategyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const IfThenCylinderRuleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CylinderPointSamplingStrategyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const IfThenCylindricalSegmentRuleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CylindricalSegmentPointSamplingStrategyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const IfThenEllipseRuleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipsePointSamplingStrategyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const IfThenEllipticalArcRuleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipticalArcPointSamplingStrategyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const IfThenElongatedCircleRuleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ElongatedCirclePointSamplingStrategyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const IfThenElongatedCylinderRuleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ElongatedCylinderPointSamplingStrategyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const IfThenExtrudedCrossSectionRuleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ExtrudedCrossSectionPointSamplingStrategyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const IfThenLineRuleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LinePointSamplingStrategyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const IfThenOppositeAngledLinesRuleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeAngledLinesPointSamplingStrategyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const IfThenOppositeAngledPlanesRuleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeAngledPlanesPointSamplingStrategyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const IfThenOppositeParallelLinesRuleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeParallelLinesPointSamplingStrategyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const IfThenOppositeParallelPlanesRuleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeParallelPlanesPointSamplingStrategyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const IfThenPlaneRuleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PlanePointSamplingStrategyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const IfThenPointDefinedCurveRuleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointDefinedCurvePointSamplingStrategyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const IfThenPointDefinedSurfaceRuleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointDefinedSurfacePointSamplingStrategyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const IfThenPointRuleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointPointSamplingStrategyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const IfThenSphereRuleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SpherePointSamplingStrategyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const IfThenSphericalSegmentRuleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphericalSegmentPointSamplingStrategyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const IfThenSurfaceOfRevolutionRuleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceOfRevolutionPointSamplingStrategyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const IfThenToroidalSegmentRuleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToroidalSegmentPointSamplingStrategyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const IfThenTorusRuleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TorusPointSamplingStrategyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const IfThenSurfaceRuleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const IfThenCurveRuleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DMESelectionRulesType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DMEThenType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DMEDecisionBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ApplicabilityBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const ApplicabilityBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const ApplicabilityBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const QIFMustType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const QIFMustType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const QIFMustType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const QIFMustNotType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const QIFMustNotType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const QIFMustNotType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const QIFMayType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DMEDecisionClassType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DMEParameterConstraintSetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DMEParameterConstraintType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DMEDecisionIdType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DMEDecisionMakeModelType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const IfThenDMERuleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ZeroToOneType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const ZeroToOneType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const ZeroToOneType&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX___QIFAPPLICATIONS_QIFRULES_HXX
