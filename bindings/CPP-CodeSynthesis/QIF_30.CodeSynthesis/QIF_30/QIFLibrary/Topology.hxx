// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

#ifndef CXX___QIFLIBRARY_TOPOLOGY_HXX
#define CXX___QIFLIBRARY_TOPOLOGY_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_WCHAR
#define XSD_USE_WCHAR
#endif

#ifndef XSD_CXX_TREE_USE_WCHAR
#define XSD_CXX_TREE_USE_WCHAR
#endif

// Begin prologue.
//
#include "..\\export.hxx"
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (LIBXSD_VERSION != 400002000000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< wchar_t, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< wchar_t, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< wchar_t, string > normalized_string;
  typedef ::xsd::cxx::tree::token< wchar_t, normalized_string > token;
  typedef ::xsd::cxx::tree::name< wchar_t, token > name;
  typedef ::xsd::cxx::tree::nmtoken< wchar_t, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< wchar_t, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< wchar_t, name > ncname;
  typedef ::xsd::cxx::tree::language< wchar_t, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< wchar_t, ncname > id;
  typedef ::xsd::cxx::tree::idref< wchar_t, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< wchar_t, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< wchar_t, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< wchar_t, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< wchar_t > buffer;
  typedef ::xsd::cxx::tree::base64_binary< wchar_t, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< wchar_t, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< wchar_t, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< wchar_t, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< wchar_t, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< wchar_t, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< wchar_t, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< wchar_t, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< wchar_t, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< wchar_t, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< wchar_t, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< wchar_t, ncname > entity;
  typedef ::xsd::cxx::tree::entities< wchar_t, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< wchar_t > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< wchar_t > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< wchar_t > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< wchar_t > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< wchar_t > error;
  typedef ::xsd::cxx::tree::diagnostics< wchar_t > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< wchar_t > exception;
  typedef ::xsd::cxx::tree::bounds< wchar_t > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< wchar_t > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< wchar_t > parsing;
  typedef ::xsd::cxx::tree::expected_element< wchar_t > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< wchar_t > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< wchar_t > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< wchar_t > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< wchar_t > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< wchar_t > no_prefix_mapping;
  typedef ::xsd::cxx::tree::no_type_info< wchar_t > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< wchar_t > not_derived;
  typedef ::xsd::cxx::tree::serialization< wchar_t > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< wchar_t > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace xsd
{
  namespace qif30
  {
    class TopologySetType;
    class TopologyBaseType;
    class VertexSetType;
    class VertexType;
    class EdgeSetType;
    class ValidationEdgeType;
    class EdgeType;
    class LoopSetType;
    class LoopBaseType;
    class LoopFormEnumType;
    class CoEdgeType;
    class CoEdgesType;
    class CoEdgeMeshType;
    class CoEdgesMeshType;
    class LoopType;
    class LoopMeshType;
    class FaceSetType;
    class ValidationFaceType;
    class FaceBaseType;
    class FaceType;
    class FaceMeshType;
    class ShellSetType;
    class ShellFormEnumType;
    class ShellType;
    class BodySetType;
    class ValidationBodyType;
    class BodyType;
    class BodyFormEnumType;
    class PointCloudSetType;
    class PointCloudType;
  }
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "../QIFLibrary/PrimitivesPD.hxx"

namespace xsd
{
  namespace qif30
  {
    class QIF30_SYMBOL_DECL TopologySetType: public ::xml_schema::type
    {
      public:
      // VertexSet
      //
      typedef ::xsd::qif30::VertexSetType VertexSet_type;
      typedef ::xsd::cxx::tree::optional< VertexSet_type > VertexSet_optional;
      typedef ::xsd::cxx::tree::traits< VertexSet_type, wchar_t > VertexSet_traits;

      const VertexSet_optional&
      VertexSet () const;

      VertexSet_optional&
      VertexSet ();

      void
      VertexSet (const VertexSet_type& x);

      void
      VertexSet (const VertexSet_optional& x);

      void
      VertexSet (::std::unique_ptr< VertexSet_type > p);

      // EdgeSet
      //
      typedef ::xsd::qif30::EdgeSetType EdgeSet_type;
      typedef ::xsd::cxx::tree::optional< EdgeSet_type > EdgeSet_optional;
      typedef ::xsd::cxx::tree::traits< EdgeSet_type, wchar_t > EdgeSet_traits;

      const EdgeSet_optional&
      EdgeSet () const;

      EdgeSet_optional&
      EdgeSet ();

      void
      EdgeSet (const EdgeSet_type& x);

      void
      EdgeSet (const EdgeSet_optional& x);

      void
      EdgeSet (::std::unique_ptr< EdgeSet_type > p);

      // LoopSet
      //
      typedef ::xsd::qif30::LoopSetType LoopSet_type;
      typedef ::xsd::cxx::tree::optional< LoopSet_type > LoopSet_optional;
      typedef ::xsd::cxx::tree::traits< LoopSet_type, wchar_t > LoopSet_traits;

      const LoopSet_optional&
      LoopSet () const;

      LoopSet_optional&
      LoopSet ();

      void
      LoopSet (const LoopSet_type& x);

      void
      LoopSet (const LoopSet_optional& x);

      void
      LoopSet (::std::unique_ptr< LoopSet_type > p);

      // FaceSet
      //
      typedef ::xsd::qif30::FaceSetType FaceSet_type;
      typedef ::xsd::cxx::tree::optional< FaceSet_type > FaceSet_optional;
      typedef ::xsd::cxx::tree::traits< FaceSet_type, wchar_t > FaceSet_traits;

      const FaceSet_optional&
      FaceSet () const;

      FaceSet_optional&
      FaceSet ();

      void
      FaceSet (const FaceSet_type& x);

      void
      FaceSet (const FaceSet_optional& x);

      void
      FaceSet (::std::unique_ptr< FaceSet_type > p);

      // ShellSet
      //
      typedef ::xsd::qif30::ShellSetType ShellSet_type;
      typedef ::xsd::cxx::tree::optional< ShellSet_type > ShellSet_optional;
      typedef ::xsd::cxx::tree::traits< ShellSet_type, wchar_t > ShellSet_traits;

      const ShellSet_optional&
      ShellSet () const;

      ShellSet_optional&
      ShellSet ();

      void
      ShellSet (const ShellSet_type& x);

      void
      ShellSet (const ShellSet_optional& x);

      void
      ShellSet (::std::unique_ptr< ShellSet_type > p);

      // BodySet
      //
      typedef ::xsd::qif30::BodySetType BodySet_type;
      typedef ::xsd::cxx::tree::optional< BodySet_type > BodySet_optional;
      typedef ::xsd::cxx::tree::traits< BodySet_type, wchar_t > BodySet_traits;

      const BodySet_optional&
      BodySet () const;

      BodySet_optional&
      BodySet ();

      void
      BodySet (const BodySet_type& x);

      void
      BodySet (const BodySet_optional& x);

      void
      BodySet (::std::unique_ptr< BodySet_type > p);

      // PointCloudSet
      //
      typedef ::xsd::qif30::PointCloudSetType PointCloudSet_type;
      typedef ::xsd::cxx::tree::optional< PointCloudSet_type > PointCloudSet_optional;
      typedef ::xsd::cxx::tree::traits< PointCloudSet_type, wchar_t > PointCloudSet_traits;

      const PointCloudSet_optional&
      PointCloudSet () const;

      PointCloudSet_optional&
      PointCloudSet ();

      void
      PointCloudSet (const PointCloudSet_type& x);

      void
      PointCloudSet (const PointCloudSet_optional& x);

      void
      PointCloudSet (::std::unique_ptr< PointCloudSet_type > p);

      // Constructors.
      //
      TopologySetType ();

      TopologySetType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      TopologySetType (const TopologySetType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual TopologySetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TopologySetType&
      operator= (const TopologySetType& x);

      virtual 
      ~TopologySetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      VertexSet_optional VertexSet_;
      EdgeSet_optional EdgeSet_;
      LoopSet_optional LoopSet_;
      FaceSet_optional FaceSet_;
      ShellSet_optional ShellSet_;
      BodySet_optional BodySet_;
      PointCloudSet_optional PointCloudSet_;
    };

    class QIF30_SYMBOL_DECL TopologyBaseType: public ::xsd::qif30::DrawableBaseType
    {
      public:
      // Constructors.
      //
      TopologyBaseType ();

      TopologyBaseType (const id_type&);

      TopologyBaseType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      TopologyBaseType (const TopologyBaseType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual TopologyBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      TopologyBaseType&
      operator= (const TopologyBaseType&) = default;
#endif

      virtual 
      ~TopologyBaseType ();
    };

    class QIF30_SYMBOL_DECL VertexSetType: public ::xml_schema::type
    {
      public:
      // Vertex
      //
      typedef ::xsd::qif30::VertexType Vertex_type;
      typedef ::xsd::cxx::tree::sequence< Vertex_type > Vertex_sequence;
      typedef xsd::cxx::tree::sequence< Vertex_type >::iterator Vertex_iterator;
      typedef xsd::cxx::tree::sequence< Vertex_type >::const_iterator Vertex_const_iterator;
      typedef ::xsd::cxx::tree::traits< Vertex_type, wchar_t > Vertex_traits;

      const Vertex_sequence&
      Vertex () const;

      Vertex_sequence&
      Vertex ();

      void
      Vertex (const Vertex_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      VertexSetType ();

      VertexSetType (const n_type&);

      VertexSetType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      VertexSetType (const VertexSetType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual VertexSetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      VertexSetType&
      operator= (const VertexSetType& x);

      virtual 
      ~VertexSetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Vertex_sequence Vertex_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL VertexType: public ::xsd::qif30::TopologyBaseType
    {
      public:
      // Point
      //
      typedef ::xsd::qif30::ElementReferenceType Point_type;
      typedef ::xsd::cxx::tree::traits< Point_type, wchar_t > Point_traits;

      const Point_type&
      Point () const;

      Point_type&
      Point ();

      void
      Point (const Point_type& x);

      void
      Point (::std::unique_ptr< Point_type > p);

      // tolerance
      //
      typedef ::xml_schema::double_ tolerance_type;
      typedef ::xsd::cxx::tree::optional< tolerance_type > tolerance_optional;
      typedef ::xsd::cxx::tree::traits< tolerance_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > tolerance_traits;

      const tolerance_optional&
      tolerance () const;

      tolerance_optional&
      tolerance ();

      void
      tolerance (const tolerance_type& x);

      void
      tolerance (const tolerance_optional& x);

      // Constructors.
      //
      VertexType ();

      VertexType (const id_type&,
                  const Point_type&);

      VertexType (const id_type&,
                  ::std::unique_ptr< Point_type >);

      VertexType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      VertexType (const VertexType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual VertexType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      VertexType&
      operator= (const VertexType& x);

      virtual 
      ~VertexType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Point_type > Point_;
      tolerance_optional tolerance_;
    };

    class QIF30_SYMBOL_DECL EdgeSetType: public ::xml_schema::type
    {
      public:
      // Edge
      //
      typedef ::xsd::qif30::EdgeType Edge_type;
      typedef ::xsd::cxx::tree::sequence< Edge_type > Edge_sequence;
      typedef xsd::cxx::tree::sequence< Edge_type >::iterator Edge_iterator;
      typedef xsd::cxx::tree::sequence< Edge_type >::const_iterator Edge_const_iterator;
      typedef ::xsd::cxx::tree::traits< Edge_type, wchar_t > Edge_traits;

      const Edge_sequence&
      Edge () const;

      Edge_sequence&
      Edge ();

      void
      Edge (const Edge_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      EdgeSetType ();

      EdgeSetType (const n_type&);

      EdgeSetType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      EdgeSetType (const EdgeSetType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual EdgeSetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EdgeSetType&
      operator= (const EdgeSetType& x);

      virtual 
      ~EdgeSetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Edge_sequence Edge_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ValidationEdgeType: public ::xml_schema::type
    {
      public:
      // Length
      //
      typedef ::xml_schema::double_ Length_type;
      typedef ::xsd::cxx::tree::optional< Length_type > Length_optional;
      typedef ::xsd::cxx::tree::traits< Length_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > Length_traits;

      const Length_optional&
      Length () const;

      Length_optional&
      Length ();

      void
      Length (const Length_type& x);

      void
      Length (const Length_optional& x);

      // Centroid
      //
      typedef ::xsd::qif30::PointSimpleType Centroid_type;
      typedef ::xsd::cxx::tree::optional< Centroid_type > Centroid_optional;
      typedef ::xsd::cxx::tree::traits< Centroid_type, wchar_t > Centroid_traits;

      const Centroid_optional&
      Centroid () const;

      Centroid_optional&
      Centroid ();

      void
      Centroid (const Centroid_type& x);

      void
      Centroid (const Centroid_optional& x);

      void
      Centroid (::std::unique_ptr< Centroid_type > p);

      // Box
      //
      typedef ::xsd::qif30::BoundingBoxAxisAlignedType Box_type;
      typedef ::xsd::cxx::tree::optional< Box_type > Box_optional;
      typedef ::xsd::cxx::tree::traits< Box_type, wchar_t > Box_traits;

      const Box_optional&
      Box () const;

      Box_optional&
      Box ();

      void
      Box (const Box_type& x);

      void
      Box (const Box_optional& x);

      void
      Box (::std::unique_ptr< Box_type > p);

      // Points
      //
      typedef ::xsd::qif30::ValidationPointsType Points_type;
      typedef ::xsd::cxx::tree::optional< Points_type > Points_optional;
      typedef ::xsd::cxx::tree::traits< Points_type, wchar_t > Points_traits;

      const Points_optional&
      Points () const;

      Points_optional&
      Points ();

      void
      Points (const Points_type& x);

      void
      Points (const Points_optional& x);

      void
      Points (::std::unique_ptr< Points_type > p);

      // Constructors.
      //
      ValidationEdgeType ();

      ValidationEdgeType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      ValidationEdgeType (const ValidationEdgeType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual ValidationEdgeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ValidationEdgeType&
      operator= (const ValidationEdgeType& x);

      virtual 
      ~ValidationEdgeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Length_optional Length_;
      Centroid_optional Centroid_;
      Box_optional Box_;
      Points_optional Points_;
    };

    class QIF30_SYMBOL_DECL EdgeType: public ::xsd::qif30::TopologyBaseType
    {
      public:
      // Validation
      //
      typedef ::xsd::qif30::ValidationEdgeType Validation_type;
      typedef ::xsd::cxx::tree::optional< Validation_type > Validation_optional;
      typedef ::xsd::cxx::tree::traits< Validation_type, wchar_t > Validation_traits;

      const Validation_optional&
      Validation () const;

      Validation_optional&
      Validation ();

      void
      Validation (const Validation_type& x);

      void
      Validation (const Validation_optional& x);

      void
      Validation (::std::unique_ptr< Validation_type > p);

      // Curve
      //
      typedef ::xsd::qif30::ElementReferenceType Curve_type;
      typedef ::xsd::cxx::tree::traits< Curve_type, wchar_t > Curve_traits;

      const Curve_type&
      Curve () const;

      Curve_type&
      Curve ();

      void
      Curve (const Curve_type& x);

      void
      Curve (::std::unique_ptr< Curve_type > p);

      // VertexBeg
      //
      typedef ::xsd::qif30::ElementReferenceType VertexBeg_type;
      typedef ::xsd::cxx::tree::traits< VertexBeg_type, wchar_t > VertexBeg_traits;

      const VertexBeg_type&
      VertexBeg () const;

      VertexBeg_type&
      VertexBeg ();

      void
      VertexBeg (const VertexBeg_type& x);

      void
      VertexBeg (::std::unique_ptr< VertexBeg_type > p);

      // VertexEnd
      //
      typedef ::xsd::qif30::ElementReferenceType VertexEnd_type;
      typedef ::xsd::cxx::tree::traits< VertexEnd_type, wchar_t > VertexEnd_traits;

      const VertexEnd_type&
      VertexEnd () const;

      VertexEnd_type&
      VertexEnd ();

      void
      VertexEnd (const VertexEnd_type& x);

      void
      VertexEnd (::std::unique_ptr< VertexEnd_type > p);

      // tolerance
      //
      typedef ::xml_schema::double_ tolerance_type;
      typedef ::xsd::cxx::tree::optional< tolerance_type > tolerance_optional;
      typedef ::xsd::cxx::tree::traits< tolerance_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > tolerance_traits;

      const tolerance_optional&
      tolerance () const;

      tolerance_optional&
      tolerance ();

      void
      tolerance (const tolerance_type& x);

      void
      tolerance (const tolerance_optional& x);

      // Constructors.
      //
      EdgeType ();

      EdgeType (const id_type&,
                const Curve_type&,
                const VertexBeg_type&,
                const VertexEnd_type&);

      EdgeType (const id_type&,
                ::std::unique_ptr< Curve_type >,
                ::std::unique_ptr< VertexBeg_type >,
                ::std::unique_ptr< VertexEnd_type >);

      EdgeType (const xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      EdgeType (const EdgeType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      virtual EdgeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EdgeType&
      operator= (const EdgeType& x);

      virtual 
      ~EdgeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Validation_optional Validation_;
      ::xsd::cxx::tree::one< Curve_type > Curve_;
      ::xsd::cxx::tree::one< VertexBeg_type > VertexBeg_;
      ::xsd::cxx::tree::one< VertexEnd_type > VertexEnd_;
      tolerance_optional tolerance_;
    };

    class QIF30_SYMBOL_DECL LoopSetType: public ::xml_schema::type
    {
      public:
      // LoopBase
      //
      typedef ::xsd::qif30::LoopBaseType LoopBase_type;
      typedef ::xsd::cxx::tree::sequence< LoopBase_type > LoopBase_sequence;
      typedef xsd::cxx::tree::sequence< LoopBase_type >::iterator LoopBase_iterator;
      typedef xsd::cxx::tree::sequence< LoopBase_type >::const_iterator LoopBase_const_iterator;
      typedef ::xsd::cxx::tree::traits< LoopBase_type, wchar_t > LoopBase_traits;

      const LoopBase_sequence&
      LoopBase () const;

      LoopBase_sequence&
      LoopBase ();

      void
      LoopBase (const LoopBase_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      LoopSetType ();

      LoopSetType (const n_type&);

      LoopSetType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      LoopSetType (const LoopSetType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual LoopSetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LoopSetType&
      operator= (const LoopSetType& x);

      virtual 
      ~LoopSetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      LoopBase_sequence LoopBase_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL LoopBaseType: public ::xsd::qif30::TopologyBaseType
    {
      public:
      // Constructors.
      //
      LoopBaseType ();

      LoopBaseType (const id_type&);

      LoopBaseType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      LoopBaseType (const LoopBaseType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual LoopBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      LoopBaseType&
      operator= (const LoopBaseType&) = default;
#endif

      virtual 
      ~LoopBaseType ();
    };

    class QIF30_SYMBOL_DECL LoopFormEnumType: public ::xml_schema::string
    {
      public:
      enum value
      {
        UNKNOWN,
        OUTER,
        INNER,
        SLIT,
        VERTEX
      };

      LoopFormEnumType ();

      LoopFormEnumType (value v);

      LoopFormEnumType (const wchar_t* v);

      LoopFormEnumType (const ::std::wstring& v);

      LoopFormEnumType (const ::xml_schema::string& v);

      LoopFormEnumType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      LoopFormEnumType (const xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      LoopFormEnumType (const ::std::wstring& s,
                        const xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      LoopFormEnumType (const LoopFormEnumType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      LoopFormEnumType&
      operator= (const LoopFormEnumType&) = default;
#endif

      virtual LoopFormEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LoopFormEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_LoopFormEnumType_convert ();
      }

      protected:
      value
      _xsd_LoopFormEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_LoopFormEnumType_literals_[5];
      static const value _xsd_LoopFormEnumType_indexes_[5];
    };

    class QIF30_SYMBOL_DECL CoEdgeType: public ::xml_schema::type
    {
      public:
      // EdgeOriented
      //
      typedef ::xsd::qif30::EdgeOrientedType EdgeOriented_type;
      typedef ::xsd::cxx::tree::traits< EdgeOriented_type, wchar_t > EdgeOriented_traits;

      const EdgeOriented_type&
      EdgeOriented () const;

      EdgeOriented_type&
      EdgeOriented ();

      void
      EdgeOriented (const EdgeOriented_type& x);

      void
      EdgeOriented (::std::unique_ptr< EdgeOriented_type > p);

      // Curve12
      //
      typedef ::xsd::qif30::ElementReferenceType Curve12_type;
      typedef ::xsd::cxx::tree::optional< Curve12_type > Curve12_optional;
      typedef ::xsd::cxx::tree::traits< Curve12_type, wchar_t > Curve12_traits;

      const Curve12_optional&
      Curve12 () const;

      Curve12_optional&
      Curve12 ();

      void
      Curve12 (const Curve12_type& x);

      void
      Curve12 (const Curve12_optional& x);

      void
      Curve12 (::std::unique_ptr< Curve12_type > p);

      // Constructors.
      //
      CoEdgeType ();

      CoEdgeType (const EdgeOriented_type&);

      CoEdgeType (::std::unique_ptr< EdgeOriented_type >);

      CoEdgeType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      CoEdgeType (const CoEdgeType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual CoEdgeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CoEdgeType&
      operator= (const CoEdgeType& x);

      virtual 
      ~CoEdgeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< EdgeOriented_type > EdgeOriented_;
      Curve12_optional Curve12_;
    };

    class QIF30_SYMBOL_DECL CoEdgesType: public ::xml_schema::type
    {
      public:
      // CoEdge
      //
      typedef ::xsd::qif30::CoEdgeType CoEdge_type;
      typedef ::xsd::cxx::tree::sequence< CoEdge_type > CoEdge_sequence;
      typedef xsd::cxx::tree::sequence< CoEdge_type >::iterator CoEdge_iterator;
      typedef xsd::cxx::tree::sequence< CoEdge_type >::const_iterator CoEdge_const_iterator;
      typedef ::xsd::cxx::tree::traits< CoEdge_type, wchar_t > CoEdge_traits;

      const CoEdge_sequence&
      CoEdge () const;

      CoEdge_sequence&
      CoEdge ();

      void
      CoEdge (const CoEdge_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      CoEdgesType ();

      CoEdgesType (const n_type&);

      CoEdgesType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      CoEdgesType (const CoEdgesType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual CoEdgesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CoEdgesType&
      operator= (const CoEdgesType& x);

      virtual 
      ~CoEdgesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CoEdge_sequence CoEdge_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL CoEdgeMeshType: public ::xml_schema::type
    {
      public:
      // EdgeOriented
      //
      typedef ::xsd::qif30::EdgeOrientedType EdgeOriented_type;
      typedef ::xsd::cxx::tree::traits< EdgeOriented_type, wchar_t > EdgeOriented_traits;

      const EdgeOriented_type&
      EdgeOriented () const;

      EdgeOriented_type&
      EdgeOriented ();

      void
      EdgeOriented (const EdgeOriented_type& x);

      void
      EdgeOriented (::std::unique_ptr< EdgeOriented_type > p);

      // CurveMesh
      //
      typedef ::xsd::qif30::ElementReferenceType CurveMesh_type;
      typedef ::xsd::cxx::tree::optional< CurveMesh_type > CurveMesh_optional;
      typedef ::xsd::cxx::tree::traits< CurveMesh_type, wchar_t > CurveMesh_traits;

      const CurveMesh_optional&
      CurveMesh () const;

      CurveMesh_optional&
      CurveMesh ();

      void
      CurveMesh (const CurveMesh_type& x);

      void
      CurveMesh (const CurveMesh_optional& x);

      void
      CurveMesh (::std::unique_ptr< CurveMesh_type > p);

      // Constructors.
      //
      CoEdgeMeshType ();

      CoEdgeMeshType (const EdgeOriented_type&);

      CoEdgeMeshType (::std::unique_ptr< EdgeOriented_type >);

      CoEdgeMeshType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      CoEdgeMeshType (const CoEdgeMeshType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual CoEdgeMeshType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CoEdgeMeshType&
      operator= (const CoEdgeMeshType& x);

      virtual 
      ~CoEdgeMeshType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< EdgeOriented_type > EdgeOriented_;
      CurveMesh_optional CurveMesh_;
    };

    class QIF30_SYMBOL_DECL CoEdgesMeshType: public ::xml_schema::type
    {
      public:
      // CoEdgeMesh
      //
      typedef ::xsd::qif30::CoEdgeMeshType CoEdgeMesh_type;
      typedef ::xsd::cxx::tree::sequence< CoEdgeMesh_type > CoEdgeMesh_sequence;
      typedef xsd::cxx::tree::sequence< CoEdgeMesh_type >::iterator CoEdgeMesh_iterator;
      typedef xsd::cxx::tree::sequence< CoEdgeMesh_type >::const_iterator CoEdgeMesh_const_iterator;
      typedef ::xsd::cxx::tree::traits< CoEdgeMesh_type, wchar_t > CoEdgeMesh_traits;

      const CoEdgeMesh_sequence&
      CoEdgeMesh () const;

      CoEdgeMesh_sequence&
      CoEdgeMesh ();

      void
      CoEdgeMesh (const CoEdgeMesh_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      CoEdgesMeshType ();

      CoEdgesMeshType (const n_type&);

      CoEdgesMeshType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      CoEdgesMeshType (const CoEdgesMeshType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual CoEdgesMeshType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CoEdgesMeshType&
      operator= (const CoEdgesMeshType& x);

      virtual 
      ~CoEdgesMeshType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CoEdgeMesh_sequence CoEdgeMesh_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL LoopType: public ::xsd::qif30::LoopBaseType
    {
      public:
      // CoEdges
      //
      typedef ::xsd::qif30::CoEdgesType CoEdges_type;
      typedef ::xsd::cxx::tree::traits< CoEdges_type, wchar_t > CoEdges_traits;

      const CoEdges_type&
      CoEdges () const;

      CoEdges_type&
      CoEdges ();

      void
      CoEdges (const CoEdges_type& x);

      void
      CoEdges (::std::unique_ptr< CoEdges_type > p);

      // form
      //
      typedef ::xsd::qif30::LoopFormEnumType form_type;
      typedef ::xsd::cxx::tree::traits< form_type, wchar_t > form_traits;

      const form_type&
      form () const;

      form_type&
      form ();

      void
      form (const form_type& x);

      void
      form (::std::unique_ptr< form_type > p);

      static const form_type&
      form_default_value ();

      // Constructors.
      //
      LoopType ();

      LoopType (const id_type&,
                const CoEdges_type&);

      LoopType (const id_type&,
                ::std::unique_ptr< CoEdges_type >);

      LoopType (const xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      LoopType (const LoopType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      virtual LoopType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LoopType&
      operator= (const LoopType& x);

      virtual 
      ~LoopType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< CoEdges_type > CoEdges_;
      ::xsd::cxx::tree::one< form_type > form_;
      static const form_type form_default_value_;
    };

    class QIF30_SYMBOL_DECL LoopMeshType: public ::xsd::qif30::LoopBaseType
    {
      public:
      // CoEdgesMesh
      //
      typedef ::xsd::qif30::CoEdgesMeshType CoEdgesMesh_type;
      typedef ::xsd::cxx::tree::traits< CoEdgesMesh_type, wchar_t > CoEdgesMesh_traits;

      const CoEdgesMesh_type&
      CoEdgesMesh () const;

      CoEdgesMesh_type&
      CoEdgesMesh ();

      void
      CoEdgesMesh (const CoEdgesMesh_type& x);

      void
      CoEdgesMesh (::std::unique_ptr< CoEdgesMesh_type > p);

      // Constructors.
      //
      LoopMeshType ();

      LoopMeshType (const id_type&,
                    const CoEdgesMesh_type&);

      LoopMeshType (const id_type&,
                    ::std::unique_ptr< CoEdgesMesh_type >);

      LoopMeshType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      LoopMeshType (const LoopMeshType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual LoopMeshType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LoopMeshType&
      operator= (const LoopMeshType& x);

      virtual 
      ~LoopMeshType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< CoEdgesMesh_type > CoEdgesMesh_;
    };

    class QIF30_SYMBOL_DECL FaceSetType: public ::xml_schema::type
    {
      public:
      // FaceBase
      //
      typedef ::xsd::qif30::FaceBaseType FaceBase_type;
      typedef ::xsd::cxx::tree::sequence< FaceBase_type > FaceBase_sequence;
      typedef xsd::cxx::tree::sequence< FaceBase_type >::iterator FaceBase_iterator;
      typedef xsd::cxx::tree::sequence< FaceBase_type >::const_iterator FaceBase_const_iterator;
      typedef ::xsd::cxx::tree::traits< FaceBase_type, wchar_t > FaceBase_traits;

      const FaceBase_sequence&
      FaceBase () const;

      FaceBase_sequence&
      FaceBase ();

      void
      FaceBase (const FaceBase_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      FaceSetType ();

      FaceSetType (const n_type&);

      FaceSetType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      FaceSetType (const FaceSetType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual FaceSetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FaceSetType&
      operator= (const FaceSetType& x);

      virtual 
      ~FaceSetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      FaceBase_sequence FaceBase_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ValidationFaceType: public ::xml_schema::type
    {
      public:
      // Area
      //
      typedef ::xml_schema::double_ Area_type;
      typedef ::xsd::cxx::tree::optional< Area_type > Area_optional;
      typedef ::xsd::cxx::tree::traits< Area_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > Area_traits;

      const Area_optional&
      Area () const;

      Area_optional&
      Area ();

      void
      Area (const Area_type& x);

      void
      Area (const Area_optional& x);

      // Centroid
      //
      typedef ::xsd::qif30::PointSimpleType Centroid_type;
      typedef ::xsd::cxx::tree::optional< Centroid_type > Centroid_optional;
      typedef ::xsd::cxx::tree::traits< Centroid_type, wchar_t > Centroid_traits;

      const Centroid_optional&
      Centroid () const;

      Centroid_optional&
      Centroid ();

      void
      Centroid (const Centroid_type& x);

      void
      Centroid (const Centroid_optional& x);

      void
      Centroid (::std::unique_ptr< Centroid_type > p);

      // Box
      //
      typedef ::xsd::qif30::BoundingBoxAxisAlignedType Box_type;
      typedef ::xsd::cxx::tree::optional< Box_type > Box_optional;
      typedef ::xsd::cxx::tree::traits< Box_type, wchar_t > Box_traits;

      const Box_optional&
      Box () const;

      Box_optional&
      Box ();

      void
      Box (const Box_type& x);

      void
      Box (const Box_optional& x);

      void
      Box (::std::unique_ptr< Box_type > p);

      // Points
      //
      typedef ::xsd::qif30::ValidationPointsType Points_type;
      typedef ::xsd::cxx::tree::optional< Points_type > Points_optional;
      typedef ::xsd::cxx::tree::traits< Points_type, wchar_t > Points_traits;

      const Points_optional&
      Points () const;

      Points_optional&
      Points ();

      void
      Points (const Points_type& x);

      void
      Points (const Points_optional& x);

      void
      Points (::std::unique_ptr< Points_type > p);

      // Constructors.
      //
      ValidationFaceType ();

      ValidationFaceType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      ValidationFaceType (const ValidationFaceType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual ValidationFaceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ValidationFaceType&
      operator= (const ValidationFaceType& x);

      virtual 
      ~ValidationFaceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Area_optional Area_;
      Centroid_optional Centroid_;
      Box_optional Box_;
      Points_optional Points_;
    };

    class QIF30_SYMBOL_DECL FaceBaseType: public ::xsd::qif30::TopologyBaseType
    {
      public:
      // Validation
      //
      typedef ::xsd::qif30::ValidationFaceType Validation_type;
      typedef ::xsd::cxx::tree::optional< Validation_type > Validation_optional;
      typedef ::xsd::cxx::tree::traits< Validation_type, wchar_t > Validation_traits;

      const Validation_optional&
      Validation () const;

      Validation_optional&
      Validation ();

      void
      Validation (const Validation_type& x);

      void
      Validation (const Validation_optional& x);

      void
      Validation (::std::unique_ptr< Validation_type > p);

      // turned
      //
      typedef ::xml_schema::boolean turned_type;
      typedef ::xsd::cxx::tree::traits< turned_type, wchar_t > turned_traits;

      const turned_type&
      turned () const;

      turned_type&
      turned ();

      void
      turned (const turned_type& x);

      static turned_type
      turned_default_value ();

      // Constructors.
      //
      FaceBaseType ();

      FaceBaseType (const id_type&);

      FaceBaseType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      FaceBaseType (const FaceBaseType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual FaceBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      FaceBaseType&
      operator= (const FaceBaseType& x);

      virtual 
      ~FaceBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Validation_optional Validation_;
      ::xsd::cxx::tree::one< turned_type > turned_;
    };

    class QIF30_SYMBOL_DECL FaceType: public ::xsd::qif30::FaceBaseType
    {
      public:
      // Surface
      //
      typedef ::xsd::qif30::ElementReferenceType Surface_type;
      typedef ::xsd::cxx::tree::traits< Surface_type, wchar_t > Surface_traits;

      const Surface_type&
      Surface () const;

      Surface_type&
      Surface ();

      void
      Surface (const Surface_type& x);

      void
      Surface (::std::unique_ptr< Surface_type > p);

      // LoopIds
      //
      typedef ::xsd::qif30::ArrayReferenceType LoopIds_type;
      typedef ::xsd::cxx::tree::optional< LoopIds_type > LoopIds_optional;
      typedef ::xsd::cxx::tree::traits< LoopIds_type, wchar_t > LoopIds_traits;

      const LoopIds_optional&
      LoopIds () const;

      LoopIds_optional&
      LoopIds ();

      void
      LoopIds (const LoopIds_type& x);

      void
      LoopIds (const LoopIds_optional& x);

      void
      LoopIds (::std::unique_ptr< LoopIds_type > p);

      // hasOuter
      //
      typedef ::xml_schema::boolean hasOuter_type;
      typedef ::xsd::cxx::tree::traits< hasOuter_type, wchar_t > hasOuter_traits;

      const hasOuter_type&
      hasOuter () const;

      hasOuter_type&
      hasOuter ();

      void
      hasOuter (const hasOuter_type& x);

      static hasOuter_type
      hasOuter_default_value ();

      // Constructors.
      //
      FaceType ();

      FaceType (const id_type&,
                const Surface_type&);

      FaceType (const id_type&,
                ::std::unique_ptr< Surface_type >);

      FaceType (const xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      FaceType (const FaceType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      virtual FaceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FaceType&
      operator= (const FaceType& x);

      virtual 
      ~FaceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Surface_type > Surface_;
      LoopIds_optional LoopIds_;
      ::xsd::cxx::tree::one< hasOuter_type > hasOuter_;
    };

    class QIF30_SYMBOL_DECL FaceMeshType: public ::xsd::qif30::FaceBaseType
    {
      public:
      // Mesh
      //
      typedef ::xsd::qif30::ElementReferenceType Mesh_type;
      typedef ::xsd::cxx::tree::traits< Mesh_type, wchar_t > Mesh_traits;

      const Mesh_type&
      Mesh () const;

      Mesh_type&
      Mesh ();

      void
      Mesh (const Mesh_type& x);

      void
      Mesh (::std::unique_ptr< Mesh_type > p);

      // LoopIds
      //
      typedef ::xsd::qif30::ArrayReferenceType LoopIds_type;
      typedef ::xsd::cxx::tree::optional< LoopIds_type > LoopIds_optional;
      typedef ::xsd::cxx::tree::traits< LoopIds_type, wchar_t > LoopIds_traits;

      const LoopIds_optional&
      LoopIds () const;

      LoopIds_optional&
      LoopIds ();

      void
      LoopIds (const LoopIds_type& x);

      void
      LoopIds (const LoopIds_optional& x);

      void
      LoopIds (::std::unique_ptr< LoopIds_type > p);

      // Triangles
      //
      typedef ::xsd::qif30::ArrayIntType Triangles_type;
      typedef ::xsd::cxx::tree::optional< Triangles_type > Triangles_optional;
      typedef ::xsd::cxx::tree::traits< Triangles_type, wchar_t > Triangles_traits;

      const Triangles_optional&
      Triangles () const;

      Triangles_optional&
      Triangles ();

      void
      Triangles (const Triangles_type& x);

      void
      Triangles (const Triangles_optional& x);

      void
      Triangles (::std::unique_ptr< Triangles_type > p);

      // TrianglesBinary
      //
      typedef ::xsd::qif30::ArrayBinaryType TrianglesBinary_type;
      typedef ::xsd::cxx::tree::optional< TrianglesBinary_type > TrianglesBinary_optional;
      typedef ::xsd::cxx::tree::traits< TrianglesBinary_type, wchar_t > TrianglesBinary_traits;

      const TrianglesBinary_optional&
      TrianglesBinary () const;

      TrianglesBinary_optional&
      TrianglesBinary ();

      void
      TrianglesBinary (const TrianglesBinary_type& x);

      void
      TrianglesBinary (const TrianglesBinary_optional& x);

      void
      TrianglesBinary (::std::unique_ptr< TrianglesBinary_type > p);

      // TrianglesVisible
      //
      typedef ::xsd::qif30::ArrayIntType TrianglesVisible_type;
      typedef ::xsd::cxx::tree::optional< TrianglesVisible_type > TrianglesVisible_optional;
      typedef ::xsd::cxx::tree::traits< TrianglesVisible_type, wchar_t > TrianglesVisible_traits;

      const TrianglesVisible_optional&
      TrianglesVisible () const;

      TrianglesVisible_optional&
      TrianglesVisible ();

      void
      TrianglesVisible (const TrianglesVisible_type& x);

      void
      TrianglesVisible (const TrianglesVisible_optional& x);

      void
      TrianglesVisible (::std::unique_ptr< TrianglesVisible_type > p);

      // TrianglesVisibleBinary
      //
      typedef ::xsd::qif30::ArrayBinaryType TrianglesVisibleBinary_type;
      typedef ::xsd::cxx::tree::optional< TrianglesVisibleBinary_type > TrianglesVisibleBinary_optional;
      typedef ::xsd::cxx::tree::traits< TrianglesVisibleBinary_type, wchar_t > TrianglesVisibleBinary_traits;

      const TrianglesVisibleBinary_optional&
      TrianglesVisibleBinary () const;

      TrianglesVisibleBinary_optional&
      TrianglesVisibleBinary ();

      void
      TrianglesVisibleBinary (const TrianglesVisibleBinary_type& x);

      void
      TrianglesVisibleBinary (const TrianglesVisibleBinary_optional& x);

      void
      TrianglesVisibleBinary (::std::unique_ptr< TrianglesVisibleBinary_type > p);

      // TrianglesHidden
      //
      typedef ::xsd::qif30::ArrayIntType TrianglesHidden_type;
      typedef ::xsd::cxx::tree::optional< TrianglesHidden_type > TrianglesHidden_optional;
      typedef ::xsd::cxx::tree::traits< TrianglesHidden_type, wchar_t > TrianglesHidden_traits;

      const TrianglesHidden_optional&
      TrianglesHidden () const;

      TrianglesHidden_optional&
      TrianglesHidden ();

      void
      TrianglesHidden (const TrianglesHidden_type& x);

      void
      TrianglesHidden (const TrianglesHidden_optional& x);

      void
      TrianglesHidden (::std::unique_ptr< TrianglesHidden_type > p);

      // TrianglesHiddenBinary
      //
      typedef ::xsd::qif30::ArrayBinaryType TrianglesHiddenBinary_type;
      typedef ::xsd::cxx::tree::optional< TrianglesHiddenBinary_type > TrianglesHiddenBinary_optional;
      typedef ::xsd::cxx::tree::traits< TrianglesHiddenBinary_type, wchar_t > TrianglesHiddenBinary_traits;

      const TrianglesHiddenBinary_optional&
      TrianglesHiddenBinary () const;

      TrianglesHiddenBinary_optional&
      TrianglesHiddenBinary ();

      void
      TrianglesHiddenBinary (const TrianglesHiddenBinary_type& x);

      void
      TrianglesHiddenBinary (const TrianglesHiddenBinary_optional& x);

      void
      TrianglesHiddenBinary (::std::unique_ptr< TrianglesHiddenBinary_type > p);

      // TrianglesColor
      //
      typedef ::xsd::qif30::ArrayUnsignedByteType TrianglesColor_type;
      typedef ::xsd::cxx::tree::optional< TrianglesColor_type > TrianglesColor_optional;
      typedef ::xsd::cxx::tree::traits< TrianglesColor_type, wchar_t > TrianglesColor_traits;

      const TrianglesColor_optional&
      TrianglesColor () const;

      TrianglesColor_optional&
      TrianglesColor ();

      void
      TrianglesColor (const TrianglesColor_type& x);

      void
      TrianglesColor (const TrianglesColor_optional& x);

      void
      TrianglesColor (::std::unique_ptr< TrianglesColor_type > p);

      // TrianglesColorBinary
      //
      typedef ::xsd::qif30::ArrayBinaryType TrianglesColorBinary_type;
      typedef ::xsd::cxx::tree::optional< TrianglesColorBinary_type > TrianglesColorBinary_optional;
      typedef ::xsd::cxx::tree::traits< TrianglesColorBinary_type, wchar_t > TrianglesColorBinary_traits;

      const TrianglesColorBinary_optional&
      TrianglesColorBinary () const;

      TrianglesColorBinary_optional&
      TrianglesColorBinary ();

      void
      TrianglesColorBinary (const TrianglesColorBinary_type& x);

      void
      TrianglesColorBinary (const TrianglesColorBinary_optional& x);

      void
      TrianglesColorBinary (::std::unique_ptr< TrianglesColorBinary_type > p);

      // Constructors.
      //
      FaceMeshType ();

      FaceMeshType (const id_type&,
                    const Mesh_type&);

      FaceMeshType (const id_type&,
                    ::std::unique_ptr< Mesh_type >);

      FaceMeshType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      FaceMeshType (const FaceMeshType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual FaceMeshType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FaceMeshType&
      operator= (const FaceMeshType& x);

      virtual 
      ~FaceMeshType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Mesh_type > Mesh_;
      LoopIds_optional LoopIds_;
      Triangles_optional Triangles_;
      TrianglesBinary_optional TrianglesBinary_;
      TrianglesVisible_optional TrianglesVisible_;
      TrianglesVisibleBinary_optional TrianglesVisibleBinary_;
      TrianglesHidden_optional TrianglesHidden_;
      TrianglesHiddenBinary_optional TrianglesHiddenBinary_;
      TrianglesColor_optional TrianglesColor_;
      TrianglesColorBinary_optional TrianglesColorBinary_;
    };

    class QIF30_SYMBOL_DECL ShellSetType: public ::xml_schema::type
    {
      public:
      // Shell
      //
      typedef ::xsd::qif30::ShellType Shell_type;
      typedef ::xsd::cxx::tree::sequence< Shell_type > Shell_sequence;
      typedef xsd::cxx::tree::sequence< Shell_type >::iterator Shell_iterator;
      typedef xsd::cxx::tree::sequence< Shell_type >::const_iterator Shell_const_iterator;
      typedef ::xsd::cxx::tree::traits< Shell_type, wchar_t > Shell_traits;

      const Shell_sequence&
      Shell () const;

      Shell_sequence&
      Shell ();

      void
      Shell (const Shell_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      ShellSetType ();

      ShellSetType (const n_type&);

      ShellSetType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      ShellSetType (const ShellSetType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual ShellSetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ShellSetType&
      operator= (const ShellSetType& x);

      virtual 
      ~ShellSetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Shell_sequence Shell_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ShellFormEnumType: public ::xml_schema::string
    {
      public:
      enum value
      {
        UNKNOWN,
        OUTER,
        INNER
      };

      ShellFormEnumType ();

      ShellFormEnumType (value v);

      ShellFormEnumType (const wchar_t* v);

      ShellFormEnumType (const ::std::wstring& v);

      ShellFormEnumType (const ::xml_schema::string& v);

      ShellFormEnumType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      ShellFormEnumType (const xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      ShellFormEnumType (const ::std::wstring& s,
                         const xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      ShellFormEnumType (const ShellFormEnumType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      ShellFormEnumType&
      operator= (const ShellFormEnumType&) = default;
#endif

      virtual ShellFormEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ShellFormEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_ShellFormEnumType_convert ();
      }

      protected:
      value
      _xsd_ShellFormEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_ShellFormEnumType_literals_[3];
      static const value _xsd_ShellFormEnumType_indexes_[3];
    };

    class QIF30_SYMBOL_DECL ShellType: public ::xsd::qif30::TopologyBaseType
    {
      public:
      // FaceIds
      //
      typedef ::xsd::qif30::ArrayReferenceType FaceIds_type;
      typedef ::xsd::cxx::tree::optional< FaceIds_type > FaceIds_optional;
      typedef ::xsd::cxx::tree::traits< FaceIds_type, wchar_t > FaceIds_traits;

      const FaceIds_optional&
      FaceIds () const;

      FaceIds_optional&
      FaceIds ();

      void
      FaceIds (const FaceIds_type& x);

      void
      FaceIds (const FaceIds_optional& x);

      void
      FaceIds (::std::unique_ptr< FaceIds_type > p);

      // turned
      //
      typedef ::xml_schema::boolean turned_type;
      typedef ::xsd::cxx::tree::traits< turned_type, wchar_t > turned_traits;

      const turned_type&
      turned () const;

      turned_type&
      turned ();

      void
      turned (const turned_type& x);

      static turned_type
      turned_default_value ();

      // closed
      //
      typedef ::xml_schema::boolean closed_type;
      typedef ::xsd::cxx::tree::traits< closed_type, wchar_t > closed_traits;

      const closed_type&
      closed () const;

      closed_type&
      closed ();

      void
      closed (const closed_type& x);

      static closed_type
      closed_default_value ();

      // form
      //
      typedef ::xsd::qif30::ShellFormEnumType form_type;
      typedef ::xsd::cxx::tree::traits< form_type, wchar_t > form_traits;

      const form_type&
      form () const;

      form_type&
      form ();

      void
      form (const form_type& x);

      void
      form (::std::unique_ptr< form_type > p);

      static const form_type&
      form_default_value ();

      // Constructors.
      //
      ShellType ();

      ShellType (const id_type&);

      ShellType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      ShellType (const ShellType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual ShellType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ShellType&
      operator= (const ShellType& x);

      virtual 
      ~ShellType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      FaceIds_optional FaceIds_;
      ::xsd::cxx::tree::one< turned_type > turned_;
      ::xsd::cxx::tree::one< closed_type > closed_;
      ::xsd::cxx::tree::one< form_type > form_;
      static const form_type form_default_value_;
    };

    class QIF30_SYMBOL_DECL BodySetType: public ::xml_schema::type
    {
      public:
      // Body
      //
      typedef ::xsd::qif30::BodyType Body_type;
      typedef ::xsd::cxx::tree::sequence< Body_type > Body_sequence;
      typedef xsd::cxx::tree::sequence< Body_type >::iterator Body_iterator;
      typedef xsd::cxx::tree::sequence< Body_type >::const_iterator Body_const_iterator;
      typedef ::xsd::cxx::tree::traits< Body_type, wchar_t > Body_traits;

      const Body_sequence&
      Body () const;

      Body_sequence&
      Body ();

      void
      Body (const Body_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      BodySetType ();

      BodySetType (const n_type&);

      BodySetType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      BodySetType (const BodySetType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual BodySetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      BodySetType&
      operator= (const BodySetType& x);

      virtual 
      ~BodySetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Body_sequence Body_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ValidationBodyType: public ::xml_schema::type
    {
      public:
      // Area
      //
      typedef ::xml_schema::double_ Area_type;
      typedef ::xsd::cxx::tree::optional< Area_type > Area_optional;
      typedef ::xsd::cxx::tree::traits< Area_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > Area_traits;

      const Area_optional&
      Area () const;

      Area_optional&
      Area ();

      void
      Area (const Area_type& x);

      void
      Area (const Area_optional& x);

      // Centroid
      //
      typedef ::xsd::qif30::PointSimpleType Centroid_type;
      typedef ::xsd::cxx::tree::optional< Centroid_type > Centroid_optional;
      typedef ::xsd::cxx::tree::traits< Centroid_type, wchar_t > Centroid_traits;

      const Centroid_optional&
      Centroid () const;

      Centroid_optional&
      Centroid ();

      void
      Centroid (const Centroid_type& x);

      void
      Centroid (const Centroid_optional& x);

      void
      Centroid (::std::unique_ptr< Centroid_type > p);

      // Volume
      //
      typedef ::xml_schema::double_ Volume_type;
      typedef ::xsd::cxx::tree::optional< Volume_type > Volume_optional;
      typedef ::xsd::cxx::tree::traits< Volume_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > Volume_traits;

      const Volume_optional&
      Volume () const;

      Volume_optional&
      Volume ();

      void
      Volume (const Volume_type& x);

      void
      Volume (const Volume_optional& x);

      // Box
      //
      typedef ::xsd::qif30::BoundingBoxAxisAlignedType Box_type;
      typedef ::xsd::cxx::tree::optional< Box_type > Box_optional;
      typedef ::xsd::cxx::tree::traits< Box_type, wchar_t > Box_traits;

      const Box_optional&
      Box () const;

      Box_optional&
      Box ();

      void
      Box (const Box_type& x);

      void
      Box (const Box_optional& x);

      void
      Box (::std::unique_ptr< Box_type > p);

      // FacePoints
      //
      typedef ::xsd::qif30::ValidationPointsType FacePoints_type;
      typedef ::xsd::cxx::tree::optional< FacePoints_type > FacePoints_optional;
      typedef ::xsd::cxx::tree::traits< FacePoints_type, wchar_t > FacePoints_traits;

      const FacePoints_optional&
      FacePoints () const;

      FacePoints_optional&
      FacePoints ();

      void
      FacePoints (const FacePoints_type& x);

      void
      FacePoints (const FacePoints_optional& x);

      void
      FacePoints (::std::unique_ptr< FacePoints_type > p);

      // EdgePoints
      //
      typedef ::xsd::qif30::ValidationPointsType EdgePoints_type;
      typedef ::xsd::cxx::tree::optional< EdgePoints_type > EdgePoints_optional;
      typedef ::xsd::cxx::tree::traits< EdgePoints_type, wchar_t > EdgePoints_traits;

      const EdgePoints_optional&
      EdgePoints () const;

      EdgePoints_optional&
      EdgePoints ();

      void
      EdgePoints (const EdgePoints_type& x);

      void
      EdgePoints (const EdgePoints_optional& x);

      void
      EdgePoints (::std::unique_ptr< EdgePoints_type > p);

      // Constructors.
      //
      ValidationBodyType ();

      ValidationBodyType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      ValidationBodyType (const ValidationBodyType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual ValidationBodyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ValidationBodyType&
      operator= (const ValidationBodyType& x);

      virtual 
      ~ValidationBodyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Area_optional Area_;
      Centroid_optional Centroid_;
      Volume_optional Volume_;
      Box_optional Box_;
      FacePoints_optional FacePoints_;
      EdgePoints_optional EdgePoints_;
    };

    class QIF30_SYMBOL_DECL BodyType: public ::xsd::qif30::TopologyBaseType
    {
      public:
      // Validation
      //
      typedef ::xsd::qif30::ValidationBodyType Validation_type;
      typedef ::xsd::cxx::tree::optional< Validation_type > Validation_optional;
      typedef ::xsd::cxx::tree::traits< Validation_type, wchar_t > Validation_traits;

      const Validation_optional&
      Validation () const;

      Validation_optional&
      Validation ();

      void
      Validation (const Validation_type& x);

      void
      Validation (const Validation_optional& x);

      void
      Validation (::std::unique_ptr< Validation_type > p);

      // Transform
      //
      typedef ::xsd::qif30::ElementReferenceType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // ShellIds
      //
      typedef ::xsd::qif30::ArrayReferenceType ShellIds_type;
      typedef ::xsd::cxx::tree::optional< ShellIds_type > ShellIds_optional;
      typedef ::xsd::cxx::tree::traits< ShellIds_type, wchar_t > ShellIds_traits;

      const ShellIds_optional&
      ShellIds () const;

      ShellIds_optional&
      ShellIds ();

      void
      ShellIds (const ShellIds_type& x);

      void
      ShellIds (const ShellIds_optional& x);

      void
      ShellIds (::std::unique_ptr< ShellIds_type > p);

      // FaceIds
      //
      typedef ::xsd::qif30::ArrayReferenceType FaceIds_type;
      typedef ::xsd::cxx::tree::optional< FaceIds_type > FaceIds_optional;
      typedef ::xsd::cxx::tree::traits< FaceIds_type, wchar_t > FaceIds_traits;

      const FaceIds_optional&
      FaceIds () const;

      FaceIds_optional&
      FaceIds ();

      void
      FaceIds (const FaceIds_type& x);

      void
      FaceIds (const FaceIds_optional& x);

      void
      FaceIds (::std::unique_ptr< FaceIds_type > p);

      // LoopIds
      //
      typedef ::xsd::qif30::ArrayReferenceType LoopIds_type;
      typedef ::xsd::cxx::tree::optional< LoopIds_type > LoopIds_optional;
      typedef ::xsd::cxx::tree::traits< LoopIds_type, wchar_t > LoopIds_traits;

      const LoopIds_optional&
      LoopIds () const;

      LoopIds_optional&
      LoopIds ();

      void
      LoopIds (const LoopIds_type& x);

      void
      LoopIds (const LoopIds_optional& x);

      void
      LoopIds (::std::unique_ptr< LoopIds_type > p);

      // EdgeIds
      //
      typedef ::xsd::qif30::ArrayReferenceType EdgeIds_type;
      typedef ::xsd::cxx::tree::optional< EdgeIds_type > EdgeIds_optional;
      typedef ::xsd::cxx::tree::traits< EdgeIds_type, wchar_t > EdgeIds_traits;

      const EdgeIds_optional&
      EdgeIds () const;

      EdgeIds_optional&
      EdgeIds ();

      void
      EdgeIds (const EdgeIds_type& x);

      void
      EdgeIds (const EdgeIds_optional& x);

      void
      EdgeIds (::std::unique_ptr< EdgeIds_type > p);

      // VertexIds
      //
      typedef ::xsd::qif30::ArrayReferenceType VertexIds_type;
      typedef ::xsd::cxx::tree::optional< VertexIds_type > VertexIds_optional;
      typedef ::xsd::cxx::tree::traits< VertexIds_type, wchar_t > VertexIds_traits;

      const VertexIds_optional&
      VertexIds () const;

      VertexIds_optional&
      VertexIds ();

      void
      VertexIds (const VertexIds_type& x);

      void
      VertexIds (const VertexIds_optional& x);

      void
      VertexIds (::std::unique_ptr< VertexIds_type > p);

      // form
      //
      typedef ::xsd::qif30::BodyFormEnumType form_type;
      typedef ::xsd::cxx::tree::traits< form_type, wchar_t > form_traits;

      const form_type&
      form () const;

      form_type&
      form ();

      void
      form (const form_type& x);

      void
      form (::std::unique_ptr< form_type > p);

      static const form_type&
      form_default_value ();

      // materialIndex
      //
      typedef ::xsd::qif30::NaturalType materialIndex_type;
      typedef ::xsd::cxx::tree::optional< materialIndex_type > materialIndex_optional;
      typedef ::xsd::cxx::tree::traits< materialIndex_type, wchar_t > materialIndex_traits;

      const materialIndex_optional&
      materialIndex () const;

      materialIndex_optional&
      materialIndex ();

      void
      materialIndex (const materialIndex_type& x);

      void
      materialIndex (const materialIndex_optional& x);

      void
      materialIndex (::std::unique_ptr< materialIndex_type > p);

      // Constructors.
      //
      BodyType ();

      BodyType (const id_type&);

      BodyType (const xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      BodyType (const BodyType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      virtual BodyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      BodyType&
      operator= (const BodyType& x);

      virtual 
      ~BodyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Validation_optional Validation_;
      Transform_optional Transform_;
      ShellIds_optional ShellIds_;
      FaceIds_optional FaceIds_;
      LoopIds_optional LoopIds_;
      EdgeIds_optional EdgeIds_;
      VertexIds_optional VertexIds_;
      ::xsd::cxx::tree::one< form_type > form_;
      static const form_type form_default_value_;
      materialIndex_optional materialIndex_;
    };

    class QIF30_SYMBOL_DECL BodyFormEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        UNDEFINED,
        TRIMMED_SURFACE,
        WIRE,
        SOLID,
        SHEET,
        MIXED
      };

      BodyFormEnumType ();

      BodyFormEnumType (value v);

      BodyFormEnumType (const wchar_t* v);

      BodyFormEnumType (const ::std::wstring& v);

      BodyFormEnumType (const ::xml_schema::nmtoken& v);

      BodyFormEnumType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      BodyFormEnumType (const xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      BodyFormEnumType (const ::std::wstring& s,
                        const xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      BodyFormEnumType (const BodyFormEnumType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      BodyFormEnumType&
      operator= (const BodyFormEnumType&) = default;
#endif

      virtual BodyFormEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      BodyFormEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_BodyFormEnumType_convert ();
      }

      protected:
      value
      _xsd_BodyFormEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_BodyFormEnumType_literals_[6];
      static const value _xsd_BodyFormEnumType_indexes_[6];
    };

    class QIF30_SYMBOL_DECL PointCloudSetType: public ::xml_schema::type
    {
      public:
      // PointCloud
      //
      typedef ::xsd::qif30::PointCloudType PointCloud_type;
      typedef ::xsd::cxx::tree::sequence< PointCloud_type > PointCloud_sequence;
      typedef xsd::cxx::tree::sequence< PointCloud_type >::iterator PointCloud_iterator;
      typedef xsd::cxx::tree::sequence< PointCloud_type >::const_iterator PointCloud_const_iterator;
      typedef ::xsd::cxx::tree::traits< PointCloud_type, wchar_t > PointCloud_traits;

      const PointCloud_sequence&
      PointCloud () const;

      PointCloud_sequence&
      PointCloud ();

      void
      PointCloud (const PointCloud_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      PointCloudSetType ();

      PointCloudSetType (const n_type&);

      PointCloudSetType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      PointCloudSetType (const PointCloudSetType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual PointCloudSetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointCloudSetType&
      operator= (const PointCloudSetType& x);

      virtual 
      ~PointCloudSetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PointCloud_sequence PointCloud_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL PointCloudType: public ::xsd::qif30::TopologyBaseType
    {
      public:
      // Points
      //
      typedef ::xsd::qif30::ArrayPointType Points_type;
      typedef ::xsd::cxx::tree::optional< Points_type > Points_optional;
      typedef ::xsd::cxx::tree::traits< Points_type, wchar_t > Points_traits;

      const Points_optional&
      Points () const;

      Points_optional&
      Points ();

      void
      Points (const Points_type& x);

      void
      Points (const Points_optional& x);

      void
      Points (::std::unique_ptr< Points_type > p);

      // PointsBinary
      //
      typedef ::xsd::qif30::ArrayBinaryType PointsBinary_type;
      typedef ::xsd::cxx::tree::optional< PointsBinary_type > PointsBinary_optional;
      typedef ::xsd::cxx::tree::traits< PointsBinary_type, wchar_t > PointsBinary_traits;

      const PointsBinary_optional&
      PointsBinary () const;

      PointsBinary_optional&
      PointsBinary ();

      void
      PointsBinary (const PointsBinary_type& x);

      void
      PointsBinary (const PointsBinary_optional& x);

      void
      PointsBinary (::std::unique_ptr< PointsBinary_type > p);

      // Normals
      //
      typedef ::xsd::qif30::ArrayUnitVectorType Normals_type;
      typedef ::xsd::cxx::tree::optional< Normals_type > Normals_optional;
      typedef ::xsd::cxx::tree::traits< Normals_type, wchar_t > Normals_traits;

      const Normals_optional&
      Normals () const;

      Normals_optional&
      Normals ();

      void
      Normals (const Normals_type& x);

      void
      Normals (const Normals_optional& x);

      void
      Normals (::std::unique_ptr< Normals_type > p);

      // NormalsBinary
      //
      typedef ::xsd::qif30::ArrayBinaryType NormalsBinary_type;
      typedef ::xsd::cxx::tree::optional< NormalsBinary_type > NormalsBinary_optional;
      typedef ::xsd::cxx::tree::traits< NormalsBinary_type, wchar_t > NormalsBinary_traits;

      const NormalsBinary_optional&
      NormalsBinary () const;

      NormalsBinary_optional&
      NormalsBinary ();

      void
      NormalsBinary (const NormalsBinary_type& x);

      void
      NormalsBinary (const NormalsBinary_optional& x);

      void
      NormalsBinary (::std::unique_ptr< NormalsBinary_type > p);

      // PointsVisible
      //
      typedef ::xsd::qif30::ArrayIntType PointsVisible_type;
      typedef ::xsd::cxx::tree::optional< PointsVisible_type > PointsVisible_optional;
      typedef ::xsd::cxx::tree::traits< PointsVisible_type, wchar_t > PointsVisible_traits;

      const PointsVisible_optional&
      PointsVisible () const;

      PointsVisible_optional&
      PointsVisible ();

      void
      PointsVisible (const PointsVisible_type& x);

      void
      PointsVisible (const PointsVisible_optional& x);

      void
      PointsVisible (::std::unique_ptr< PointsVisible_type > p);

      // PointsVisibleBinary
      //
      typedef ::xsd::qif30::ArrayBinaryType PointsVisibleBinary_type;
      typedef ::xsd::cxx::tree::optional< PointsVisibleBinary_type > PointsVisibleBinary_optional;
      typedef ::xsd::cxx::tree::traits< PointsVisibleBinary_type, wchar_t > PointsVisibleBinary_traits;

      const PointsVisibleBinary_optional&
      PointsVisibleBinary () const;

      PointsVisibleBinary_optional&
      PointsVisibleBinary ();

      void
      PointsVisibleBinary (const PointsVisibleBinary_type& x);

      void
      PointsVisibleBinary (const PointsVisibleBinary_optional& x);

      void
      PointsVisibleBinary (::std::unique_ptr< PointsVisibleBinary_type > p);

      // PointsHidden
      //
      typedef ::xsd::qif30::ArrayIntType PointsHidden_type;
      typedef ::xsd::cxx::tree::optional< PointsHidden_type > PointsHidden_optional;
      typedef ::xsd::cxx::tree::traits< PointsHidden_type, wchar_t > PointsHidden_traits;

      const PointsHidden_optional&
      PointsHidden () const;

      PointsHidden_optional&
      PointsHidden ();

      void
      PointsHidden (const PointsHidden_type& x);

      void
      PointsHidden (const PointsHidden_optional& x);

      void
      PointsHidden (::std::unique_ptr< PointsHidden_type > p);

      // PointsHiddenBinary
      //
      typedef ::xsd::qif30::ArrayBinaryType PointsHiddenBinary_type;
      typedef ::xsd::cxx::tree::optional< PointsHiddenBinary_type > PointsHiddenBinary_optional;
      typedef ::xsd::cxx::tree::traits< PointsHiddenBinary_type, wchar_t > PointsHiddenBinary_traits;

      const PointsHiddenBinary_optional&
      PointsHiddenBinary () const;

      PointsHiddenBinary_optional&
      PointsHiddenBinary ();

      void
      PointsHiddenBinary (const PointsHiddenBinary_type& x);

      void
      PointsHiddenBinary (const PointsHiddenBinary_optional& x);

      void
      PointsHiddenBinary (::std::unique_ptr< PointsHiddenBinary_type > p);

      // PointsColor
      //
      typedef ::xsd::qif30::ArrayUnsignedByteType PointsColor_type;
      typedef ::xsd::cxx::tree::optional< PointsColor_type > PointsColor_optional;
      typedef ::xsd::cxx::tree::traits< PointsColor_type, wchar_t > PointsColor_traits;

      const PointsColor_optional&
      PointsColor () const;

      PointsColor_optional&
      PointsColor ();

      void
      PointsColor (const PointsColor_type& x);

      void
      PointsColor (const PointsColor_optional& x);

      void
      PointsColor (::std::unique_ptr< PointsColor_type > p);

      // PointsColorBinary
      //
      typedef ::xsd::qif30::ArrayBinaryType PointsColorBinary_type;
      typedef ::xsd::cxx::tree::optional< PointsColorBinary_type > PointsColorBinary_optional;
      typedef ::xsd::cxx::tree::traits< PointsColorBinary_type, wchar_t > PointsColorBinary_traits;

      const PointsColorBinary_optional&
      PointsColorBinary () const;

      PointsColorBinary_optional&
      PointsColorBinary ();

      void
      PointsColorBinary (const PointsColorBinary_type& x);

      void
      PointsColorBinary (const PointsColorBinary_optional& x);

      void
      PointsColorBinary (::std::unique_ptr< PointsColorBinary_type > p);

      // Constructors.
      //
      PointCloudType ();

      PointCloudType (const id_type&);

      PointCloudType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      PointCloudType (const PointCloudType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual PointCloudType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointCloudType&
      operator= (const PointCloudType& x);

      virtual 
      ~PointCloudType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Points_optional Points_;
      PointsBinary_optional PointsBinary_;
      Normals_optional Normals_;
      NormalsBinary_optional NormalsBinary_;
      PointsVisible_optional PointsVisible_;
      PointsVisibleBinary_optional PointsVisibleBinary_;
      PointsHidden_optional PointsHidden_;
      PointsHiddenBinary_optional PointsHiddenBinary_;
      PointsColor_optional PointsColor_;
      PointsColorBinary_optional PointsColorBinary_;
    };
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace xsd
{
  namespace qif30
  {
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace xsd
{
  namespace qif30
  {
    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TopologySetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TopologyBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const VertexSetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const VertexType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EdgeSetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ValidationEdgeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EdgeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LoopSetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LoopBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LoopFormEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const LoopFormEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const LoopFormEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CoEdgeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CoEdgesType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CoEdgeMeshType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CoEdgesMeshType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LoopType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LoopMeshType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FaceSetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ValidationFaceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FaceBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FaceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FaceMeshType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ShellSetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ShellFormEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const ShellFormEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const ShellFormEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ShellType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const BodySetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ValidationBodyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const BodyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const BodyFormEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const BodyFormEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const BodyFormEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointCloudSetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointCloudType&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX___QIFLIBRARY_TOPOLOGY_HXX
